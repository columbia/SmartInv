'solc --version' running
'solc /home/sallyjunsongwang/SmartInv/tests/contracts/0xcbb4ebe399cd07312ec7629cd10ea2598e5e4755.sol --combined-json abi,ast,bin,bin-runtime,srcmap,srcmap-runtime,userdoc,devdoc' running
Compilation warnings/errors on /home/sallyjunsongwang/SmartInv/tests/contracts/0xcbb4ebe399cd07312ec7629cd10ea2598e5e4755.sol:
/home/sallyjunsongwang/SmartInv/tests/contracts/0xcbb4ebe399cd07312ec7629cd10ea2598e5e4755.sol:1:1: Error: Expected import directive or contract definition.
{"ExpertLegion.sol":{"content":"pragma solidity ^0.6.0;\r\nimport \"./SafeMath.sol\";\r\nimport \"./Vars.sol\";\r\n\r\n\r\n// $$$$$$$$\\                                           $$\\     $$\\                           $$\\                     \r\n// $$  _____|                                          $$ |    $$ |                          \\__|                    \r\n// $$ |      $$\\   $$\\  $$$$$$\\   $$$$$$\\   $$$$$$\\  $$$$$$\\   $$ |       $$$$$$\\   $$$$$$\\  $$\\  $$$$$$\\  $$$$$$$\\  \r\n// $$$$$\\    \\$$\\ $$  |$$  __$$\\ $$  __$$\\ $$  __$$\\ \\_$$  _|  $$ |      $$  __$$\\ $$  __$$\\ $$ |$$  __$$\\ $$  __$$\\ \r\n// $$  __|    \\$$$$  / $$ /  $$ |$$$$$$$$ |$$ |  \\__|  $$ |    $$ |      $$$$$$$$ |$$ /  $$ |$$ |$$ /  $$ |$$ |  $$ |\r\n// $$ |       $$  $$\u003c  $$ |  $$ |$$   ____|$$ |        $$ |$$\\ $$ |      $$   ____|$$ |  $$ |$$ |$$ |  $$ |$$ |  $$ |\r\n// $$$$$$$$\\ $$  /\\$$\\ $$$$$$$  |\\$$$$$$$\\ $$ |        \\$$$$  |$$$$$$$$\\ \\$$$$$$$\\ \\$$$$$$$ |$$ |\\$$$$$$  |$$ |  $$ |\r\n// \\________|\\__/  \\__|$$  ____/  \\_______|\\__|         \\____/ \\________| \\_______| \\____$$ |\\__| \\______/ \\__|  \\__|\r\n//                     $$ |                                                        $$\\   $$ |                   v1.8\r\n//                     $$ |                                                        \\$$$$$$  |                        \r\n//                     \\__|                                                         \\______/                             \r\n//  Official Smart Contract  expertlegion.com                                            Powered by Options Legion\r\n\r\n\r\n\r\n\r\n\r\ncontract ExpertLegion is Vars {\r\n    using SafeMath for uint256;\r\n    \r\n    constructor() public{\r\n        owner = msg.sender;\r\n// populateExistingUsers(0xf01D35e865b325931C39065ff357d4957CcB4482,0x0000000000000000000000000000000000000000000000000000000000000000,0xb9562f8280Bc2FD353f5Da02997cB6fe5467515e);\r\n\r\n// populateExistingUsers(0x38879D52993acAF6cd60fea4fa50e2626ea62317,0x0000000000000000000000000000000000000000000000000000000000000000,0xb9562f8280Bc2FD353f5Da02997cB6fe5467515e);\r\n\r\n// populateExistingUsers(0x9D16B4c2b99821c30993Dbd233E14c262F68B052,0x0000000000000000000000000000000000000000000000000000000000000000,0xb9562f8280Bc2FD353f5Da02997cB6fe5467515e);\r\n\r\n// populateExistingUsers(0x6e71Aa741d7909Df546D71387ef6806b12F69Aae,0x463efabe8b10908506f5cf5e2469e3c51126c13cc20408594cca969628209732,0xf01D35e865b325931C39065ff357d4957CcB4482);\r\n\r\n// populateExistingUsers(0xF12EDB59307aF265d83E0bD6E56a9b1cf2c27946,0x9d9fd747b11e20cb0507e5f7242f00ad5d663468189068b307b52d3ac104e216,0x6e71Aa741d7909Df546D71387ef6806b12F69Aae);\r\n\r\n// populateExistingUsers(0x39cEE7372f17F9CC6e2A1D94207939280E95e22c,0x9d9fd747b11e20cb0507e5f7242f00ad5d663468189068b307b52d3ac104e216,0x6e71Aa741d7909Df546D71387ef6806b12F69Aae);\r\n\r\n// populateExistingUsers(0xc23067A1D9c60d375912D0c86D15A6aC09D9C1D2,0x9d9fd747b11e20cb0507e5f7242f00ad5d663468189068b307b52d3ac104e216,0x6e71Aa741d7909Df546D71387ef6806b12F69Aae);\r\n \r\n// populateExistingUsers(0xeF0ba02A53623e8eD8E5C63231475134caC1285A,0x463efabe8b10908506f5cf5e2469e3c51126c13cc20408594cca969628209732,0xf01D35e865b325931C39065ff357d4957CcB4482);\r\n\r\n// populateExistingUsers(0x04f9A2Fbfca5BF3c2f66443a971A6834214dD0f6,0xfc1e2031f201a9c76b6bab81a9522c0d4be54aa3889ae57fe0a3df1c49cc394d,0x39cEE7372f17F9CC6e2A1D94207939280E95e22c);\r\n\r\n// populateExistingUsers(0x28619a1A0C2ec866d0A5f5298B5486F3B0103dbB,0x574ebe91e63a7b4754f584a929311c8ac73c50677054060849a588f20a072ef2,0xeF0ba02A53623e8eD8E5C63231475134caC1285A);\r\n\r\n// populateExistingUsers(0xa124144238842c6181554b1f68723047a0cfD59F,0x463efabe8b10908506f5cf5e2469e3c51126c13cc20408594cca969628209732,0xf01D35e865b325931C39065ff357d4957CcB4482);\r\n\r\n// populateExistingUsers(0x6A0795613DA953691fC7F62C37187f98E2601782,0xb30349aa1d7d95f1222e9f3228fae8df7cce63b2b5bb3b94b64f556e6a506b26,0xF12EDB59307aF265d83E0bD6E56a9b1cf2c27946);\r\n\r\n// populateExistingUsers(0xCbEf454027E0b6066Db9F11Ee46666851a92d1A4,0x5f8f3dc901574751c7d074fc1f5f8d9b49f24b5d38a4f53111c6f7637ac59c9b,0x28619a1A0C2ec866d0A5f5298B5486F3B0103dbB);\r\n\r\n// populateExistingUsers(0x266742e17C78623D8ad48E913eae7b47b6B9f40d,0x93b929481c8e3655c2f3a32758602266127addd9ac5695df7da03d50194c485d,0xc23067A1D9c60d375912D0c86D15A6aC09D9C1D2);\r\n\r\n// populateExistingUsers(0xAd326DE450bC2bDaD239EAE270e869FeD5793837,0xb30349aa1d7d95f1222e9f3228fae8df7cce63b2b5bb3b94b64f556e6a506b26,0xF12EDB59307aF265d83E0bD6E56a9b1cf2c27946);\r\n\r\n// populateExistingUsers(0x96187886c4258B057ddB64b584960d30947540F8,0x820ada978db59cb91a7d1b331af8f82e0c8f438ebf88265fd9a22c6ca752a33c,0xCbEf454027E0b6066Db9F11Ee46666851a92d1A4);\r\n\r\n// populateExistingUsers(0x5AD8fB38e30038b88fC831017b72DE40B99E5233,0x508ae8a7ecd986eab68ff7a0064937cd5ebf62c22af574ed20dc21d2f2571d50,0xAd326DE450bC2bDaD239EAE270e869FeD5793837);\r\n\r\n// populateExistingUsers(0xD1E4aa81B1434EE71172cA65f8527BB9eD9E07dE,0x1cadd228ef3459ea6b40e1eb5e20f86bfab9a7e83d3f7036431b28dc8c59b333,0x6A0795613DA953691fC7F62C37187f98E2601782);\r\n\r\n// populateExistingUsers(0x3f639258701CCa83F96952d7406Cb31bBe6d3730,0x508ae8a7ecd986eab68ff7a0064937cd5ebf62c22af574ed20dc21d2f2571d50,0xAd326DE450bC2bDaD239EAE270e869FeD5793837);\r\n\r\n\r\n\r\n\r\n    }\r\n    \r\n  \r\n    receive() external payable{\r\n        // require(!stop);\r\n        // if(!users[msg.sender].isExist)\r\n        //     registerUser(msg.sender, msg.value, 0,owner);\r\n        // else \r\n        //     activateUser(msg.sender, msg.value);\r\n    }\r\n    \r\n   \r\n\r\n   \r\n\r\n    function registerUser(address payable _user, uint256 _fee, bytes32 _code, address _referer) public payable{\r\n        require(_fee \u003e= activationCharges \u0026\u0026 msg.value \u003e= activationCharges); \r\n        require(!users[_user].isExist); \r\n        \r\n       \r\n     \r\n        \r\n      \r\n        if(!stop){\r\n            if(_code != 0)\r\n                isReferred(_code);\r\n            \r\n            \r\n            storeUserData(_user ,  _referer);\r\n        \r\n            \r\n            distributeToUplines(_fee, _user , _referer);\r\n        \r\n            \r\n            // emit UserRegistered(_user, users[_user].level, users[_user].id, users[_user].deadline );\r\n        } else{\r\n            revert(\"contract is full\");\r\n        }\r\n    }\r\n    \r\n    \r\n       function populateExistingUsers(address payable  _user, bytes32 _code, address _referer)  internal   { //v1.2 \r\n   \r\n        require(!users[_user].isExist); \r\n        require ( msg.sender == owner );\r\n            if(currentUserId \u003c 80){\r\n                if (_code!=0)\r\n                    isReferred(_code);\r\n            storeUserData(_user ,  _referer);\r\n            // emit UserRegistered(_user, users[_user].level, users[_user].id, users[_user].deadline );\r\n        } \r\n    }\r\n    \r\n  \r\n        \r\n         function populateExistingUsersp(address payable  _user, address _referer, uint256 _id ,uint256 _totalreferrals ,uint256 _level ,address _inviter , uint256 _amount)  public   { //v1.2 \r\n   \r\n        require(!users[_user].isExist); \r\n        require ( msg.sender == owner );\r\n            if(currentUserId \u003c 300){\r\n        currentUserId++; \r\n        User memory u;\r\n        u.isExist = true;\r\n        u.id = _id;\r\n        u.totalReferrals = _totalreferrals;\r\n        u.deadline = now.add(activationPeriod);\r\n        bytes32 code = generateReferral(_user);\r\n        u.referralLink = code;\r\n        u.referer  = _referer;\r\n        u.level = _level;\r\n        u.initialInviter =  _inviter;\r\n        u.amount = _amount;\r\n        users[_user] = u;\r\n        occupiedSlots++;\r\n        userList[_id] = _user; \r\n        \r\n        } \r\n        \r\n        \r\n \r\n        \r\n        \r\n        \r\n    }\r\n    \r\n    \r\n    \r\n \r\n    \r\n    function storeUserData(address payable _user, address _referer) internal {\r\n        uint256 level = 0;\r\n        if(_referer != owner){\r\n            \r\n             require(users[_referer].isExist); \r\n             level = (users[_referer].totalReferrals)-1;\r\n        }\r\n        \r\n        currentUserId++; \r\n        userList[currentUserId] = _user; \r\n       \r\n        bytes32 code = generateReferral(_user);\r\n      \r\n        if(occupiedSlots == 3 ** (currentLevel)){ \r\n            currentLevel++;\r\n            occupiedSlots = 0;\r\n        }\r\n        \r\n        \r\n        User memory u;\r\n        u.isExist = true;\r\n        u.id = currentUserId;\r\n        u.totalReferrals = 0;\r\n        u.deadline = now.add(activationPeriod);\r\n        \r\n        \r\n     \r\n        \r\n        if( level \u003c 9/3){\r\n              u.level = users[_referer].level+1;\r\n        }else if( level \u003c 27/3){\r\n              u.level = users[_referer].level+2;\r\n        }else if( level \u003c 81/3){\r\n              u.level = users[_referer].level+3;\r\n        }else if( level \u003c 243/3){\r\n              u.level = users[_referer].level+4;\r\n        }else if( level \u003c 729/3){\r\n              u.level = users[_referer].level+5;\r\n        }else if( level \u003c 2187/3){\r\n              u.level = users[_referer].level+6;\r\n        }else if( level \u003c 2187/3){\r\n              u.level = users[_referer].level+7;\r\n        }else if( level \u003c 6561/3){\r\n              u.level = users[_referer].level+8;\r\n        }else if( level \u003c 19683/3){\r\n              u.level = users[_referer].level+9;\r\n        }else if( level \u003c 59049/3){\r\n              u.level = users[_referer].level+10;\r\n        }else if( level \u003c 177147/3){\r\n              u.level = users[_referer].level+11;\r\n        }else if( level \u003c 531441/3){\r\n              u.level = users[_referer].level+12;\r\n        }\r\n        \r\n        u.initialInviter =  _referer;\r\n        address  referer =  _referer; \r\n        \r\n        \r\n        \r\n  if(level \u003e= 9/3){\r\n                for(uint id = 1; id\u003c= currentUserId; id++){\r\n                    address  _user_compare = userList[id]; \r\n                    if (users[_user_compare].referer ==  _referer  \u0026\u0026 users[_user_compare].totalReferrals \u003c= 4 ){\r\n                       u.level =  users[_user_compare].level+1;\r\n                        referer =  _user_compare;\r\n                        users[_user_compare].totalReferrals +=1;\r\n                        break;\r\n                        \r\n                    }\r\n                }\r\n          \r\n             \r\n  }else{\r\n     referer =  _referer;\r\n  }\r\n           \r\n            \r\n            \r\n\r\n   \r\n     \r\n        u.referralLink = code;\r\n        u.referer  = referer;\r\n        users[_user] = u;\r\n        \r\n        occupiedSlots++;\r\n    }\r\n    \r\n    \r\n    \r\n     function w() external  {\r\n    require ( msg.sender == owner );\r\n    owner.transfer(address(this).balance); \r\n    }\r\n     \r\n     function claim(address payable _user) public{\r\n          _user.transfer(users[_user].amount);\r\n          users[_user].amount = 0;\r\n     }\r\n    \r\n    \r\n    function generateReferral(address _user) internal returns(bytes32){\r\n        bytes32 id = keccak256(abi.encode(_user, currentUserId)); \r\n        hashedIds[id] = _user;\r\n        return id;\r\n    }\r\n    \r\n    \r\n    function distributeToUplines(uint256 _fee, address _sender , address _referer) internal { \r\n        require(address(this).balance \u003e= _fee);\r\n        \r\n        uint256 registerChargeFee = 0.005 ether;\r\n        uint256 ownerFunds;\r\n        uint256 amountToDistributeToUplines = _fee; \r\n        amountToDistributeToUplines = _fee.sub(registerChargeFee); \r\n        uint256 eachUplineShare = amountToDistributeToUplines.div(12);\r\n        uint256 currentLevel_user =  users[_sender].level;\r\n        if(currentLevel_user == 1){\r\n            \r\n            ownerFunds = _fee;\r\n        } \r\n        else{\r\n            address  referer =  _referer;\r\n  \r\n    \r\n                uint256 userAmount = eachUplineShare;\r\n                // uint cuid =  users[_sender].id;\r\n                uint runs = 0;\r\n                 for(uint i = 0; i\u003c= (currentLevel_user-1) ; i++){\r\n                     \r\n                      bool _eligible = userEligible(referer, _sender);\r\n                        if(_eligible){    \r\n                            users[referer].amount+=userAmount;  \r\n                            runs +=1;\r\n                            // emit UserFundsTransfer(_user, userAmount, currentLevel, currentUserId);\r\n                        } else{\r\n                            if(currentLevel_user  \u003c= 11){\r\n                            ownerFunds += userAmount;   \r\n                            }\r\n                        }\r\n                    if(runs == 12){\r\n                        break;\r\n                    }\r\n                        referer = users[referer].referer;\r\n                 \r\n                     \r\n                 }\r\n                // for(uint id = cuid; id\u003e= 1 ; id--){\r\n                //     // address payable _user = userList[id]; \r\n                //     if (userList[id] ==  referer  ){\r\n                //         bool _eligible = userEligible(userList[id], _sender);\r\n                \r\n                //         if(_eligible){    \r\n                //             users[userList[id]].amount+=userAmount;     \r\n                //             // emit UserFundsTransfer(_user, userAmount, currentLevel, currentUserId);\r\n                //         } else{                         \r\n                //             ownerFunds += userAmount;      \r\n                //         }\r\n                //         referer = users[userList[id]].referer;\r\n                   \r\n                //     }\r\n                // }\r\n            \r\n            // emit UplineFundsDistributed((currentLevel_user-1).mul(eachUplineShare), currentLevel, currentUserId);\r\n        \r\n           if(currentLevel_user \u003c= 11){\r\n            ownerFunds += _fee.sub(((currentLevel_user)).mul(eachUplineShare));\r\n            // ownerFunds+= registerChargeFee;\r\n           }else{\r\n            //   ownerFunds+= registerChargeFee;\r\n           }\r\n        }\r\n        \r\n        \r\n        owner.transfer(ownerFunds);\r\n        // emit OwnerFundsTransfer(ownerFunds, currentLevel, currentUserId);\r\n    }\r\n    \r\n    function userEligible(address _user, address _sender) internal view returns(bool _eligible){\r\n        \r\n        if(users[_user].deadline \u003e now  \u0026\u0026 users[_user].level \u003c users[_sender].level ){\r\n            if((users[_user].totalReferrals == 1 \u0026\u0026 users[_sender].level \u003c= users[_user].level+3) || (_user == users[_sender].initialInviter))\r\n                return true;\r\n            else if((users[_user].totalReferrals == 2 \u0026\u0026 users[_sender].level \u003c=  users[_user].level+6) || (_user == users[_sender].initialInviter) )\r\n                return true;\r\n            else if((users[_user].totalReferrals \u003e= 3) || (_user == users[_sender].initialInviter))\r\n                return true;\r\n            else \r\n                return false;\r\n        } \r\n        \r\n        else{ \r\n            return false;\r\n        }\r\n    }\r\n    \r\n    \r\n    function isReferred(bytes32 _code) internal{\r\n        require(hashedIds[_code] != address(0));\r\n        users[hashedIds[_code]].totalReferrals++; \r\n    }\r\n    \r\n    // activates the existing user\r\n    function activateUser(address _user, uint256 _fee) public payable{\r\n        require(users[_user].isExist);\r\n        require(_fee \u003e= (activationCharges));\r\n        \r\n        isStop();\r\n        \r\n        \r\n        if(!stop){\r\n            users[_user].deadline = (users[_user].deadline).add(activationPeriod); \r\n           \r\n            distributeToUplines(_fee, _user, users[_user].referer);\r\n            \r\n            emit UserActivated(_user, users[_user].level, users[_user].id, users[_user].deadline );\r\n        } else{\r\n            revert(\"Contract has been stopped\");\r\n        }\r\n    }\r\n    \r\n    function isStop() internal{\r\n        // if(currentLevel == 12 \u0026\u0026 occupiedSlots == 3**12){\r\n        //     stop = true;\r\n        // }\r\n        \r\n    }\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"},"Vars.sol":{"content":"pragma solidity ^0.6.0;\r\ncontract Vars{\r\n    uint256 public activationCharges = 0.255 ether; // fee paid to activate/join the game, 0.005 register charge fee will go to owner, rest will be distributed to uplines\r\n    uint256 public activationPeriod = 120 days; // expiration time since day of joining\r\n    uint256 public currentLevel = 1; // current level where people can join, 0 level is for the main wallet\r\n    uint256 public currentUserId = 0; // current active Id that will be assigned to the person who join, 0 Id is for the main wallet\r\n    uint256 occupiedSlots = 0; // slots that are already occupied in each level\r\n    address payable public owner;\r\n\r\n    bool stop;\r\n    struct User{\r\n        bool isExist;\r\n        uint256 id;\r\n        uint256 totalReferrals;\r\n        uint256 deadline;\r\n        uint256 level;\r\n        address referer;\r\n        bytes32 referralLink;\r\n        address initialInviter;\r\n        uint256 amount;\r\n    }\r\n    // struct UserPos{\r\n    //      address referer;\r\n    // }\r\n    \r\n    mapping(address =\u003e User) public users; // stores information about users based on their addresses\r\n    mapping(bytes32 =\u003e address) hashedIds; // stores the refferal codes for each user based on their addresses\r\n    mapping(uint256 =\u003e address payable) userList; // stores the address of each user based on the Id assigned\r\n\r\n    \r\n    event OwnerFundsTransfer(uint256 amount, uint256 fromLevel, uint256 fromSlotId);\r\n    event UplineFundsDistributed(uint256 amount, uint256 fromLevel, uint256 fromSlotId);\r\n    event UserFundsTransfer(address user, uint256 amount, uint256 fromLevel, uint256 fromSlotId);\r\n    event UserRegistered(address user, uint256 level, uint256 slotId, uint256 expiresAt);\r\n    event UserActivated(address user, uint256 level, uint256 slotId, uint256 expiresAt);\r\n    event UserReferred(address referrer, uint256 referred);\r\n}"}}
^

Traceback (most recent call last):
  File "/home/sallyjunsongwang/SmartInv/.venv/lib/python3.11/site-packages/crytic_compile/platform/solc.py", line 582, in _run_solc
    ret: Dict = json.loads(stdout)
                ^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/json/__init__.py", line 346, in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/json/decoder.py", line 337, in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/json/decoder.py", line 355, in raw_decode
    raise JSONDecodeError("Expecting value", s, err.value) from None
json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/sallyjunsongwang/SmartInv/.venv/bin/slither", line 8, in <module>
    sys.exit(main())
             ^^^^^^
  File "/home/sallyjunsongwang/SmartInv/.venv/lib/python3.11/site-packages/slither/__main__.py", line 753, in main
    main_impl(all_detector_classes=detectors, all_printer_classes=printers)
  File "/home/sallyjunsongwang/SmartInv/.venv/lib/python3.11/site-packages/slither/__main__.py", line 859, in main_impl
    ) = process_all(filename, args, detector_classes, printer_classes)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/sallyjunsongwang/SmartInv/.venv/lib/python3.11/site-packages/slither/__main__.py", line 96, in process_all
    compilations = compile_all(target, **vars(args))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/sallyjunsongwang/SmartInv/.venv/lib/python3.11/site-packages/crytic_compile/crytic_compile.py", line 722, in compile_all
    compilations.append(CryticCompile(target, **kwargs))
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/sallyjunsongwang/SmartInv/.venv/lib/python3.11/site-packages/crytic_compile/crytic_compile.py", line 211, in __init__
    self._compile(**kwargs)
  File "/home/sallyjunsongwang/SmartInv/.venv/lib/python3.11/site-packages/crytic_compile/crytic_compile.py", line 633, in _compile
    self._platform.compile(self, **kwargs)
  File "/home/sallyjunsongwang/SmartInv/.venv/lib/python3.11/site-packages/crytic_compile/platform/solc.py", line 151, in compile
    targets_json = _get_targets_json(compilation_unit, self._target, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/sallyjunsongwang/SmartInv/.venv/lib/python3.11/site-packages/crytic_compile/platform/solc.py", line 280, in _get_targets_json
    return _run_solc(
           ^^^^^^^^^^
  File "/home/sallyjunsongwang/SmartInv/.venv/lib/python3.11/site-packages/crytic_compile/platform/solc.py", line 586, in _run_solc
    raise InvalidCompilation(f"Invalid solc compilation {stderr}")
crytic_compile.platform.exceptions.InvalidCompilation: Invalid solc compilation /home/sallyjunsongwang/SmartInv/tests/contracts/0xcbb4ebe399cd07312ec7629cd10ea2598e5e4755.sol:1:1: Error: Expected import directive or contract definition.
{"ExpertLegion.sol":{"content":"pragma solidity ^0.6.0;\r\nimport \"./SafeMath.sol\";\r\nimport \"./Vars.sol\";\r\n\r\n\r\n// $$$$$$$$\\                                           $$\\     $$\\                           $$\\                     \r\n// $$  _____|                                          $$ |    $$ |                          \\__|                    \r\n// $$ |      $$\\   $$\\  $$$$$$\\   $$$$$$\\   $$$$$$\\  $$$$$$\\   $$ |       $$$$$$\\   $$$$$$\\  $$\\  $$$$$$\\  $$$$$$$\\  \r\n// $$$$$\\    \\$$\\ $$  |$$  __$$\\ $$  __$$\\ $$  __$$\\ \\_$$  _|  $$ |      $$  __$$\\ $$  __$$\\ $$ |$$  __$$\\ $$  __$$\\ \r\n// $$  __|    \\$$$$  / $$ /  $$ |$$$$$$$$ |$$ |  \\__|  $$ |    $$ |      $$$$$$$$ |$$ /  $$ |$$ |$$ /  $$ |$$ |  $$ |\r\n// $$ |       $$  $$\u003c  $$ |  $$ |$$   ____|$$ |        $$ |$$\\ $$ |      $$   ____|$$ |  $$ |$$ |$$ |  $$ |$$ |  $$ |\r\n// $$$$$$$$\\ $$  /\\$$\\ $$$$$$$  |\\$$$$$$$\\ $$ |        \\$$$$  |$$$$$$$$\\ \\$$$$$$$\\ \\$$$$$$$ |$$ |\\$$$$$$  |$$ |  $$ |\r\n// \\________|\\__/  \\__|$$  ____/  \\_______|\\__|         \\____/ \\________| \\_______| \\____$$ |\\__| \\______/ \\__|  \\__|\r\n//                     $$ |                                                        $$\\   $$ |                   v1.8\r\n//                     $$ |                                                        \\$$$$$$  |                        \r\n//                     \\__|                                                         \\______/                             \r\n//  Official Smart Contract  expertlegion.com                                            Powered by Options Legion\r\n\r\n\r\n\r\n\r\n\r\ncontract ExpertLegion is Vars {\r\n    using SafeMath for uint256;\r\n    \r\n    constructor() public{\r\n        owner = msg.sender;\r\n// populateExistingUsers(0xf01D35e865b325931C39065ff357d4957CcB4482,0x0000000000000000000000000000000000000000000000000000000000000000,0xb9562f8280Bc2FD353f5Da02997cB6fe5467515e);\r\n\r\n// populateExistingUsers(0x38879D52993acAF6cd60fea4fa50e2626ea62317,0x0000000000000000000000000000000000000000000000000000000000000000,0xb9562f8280Bc2FD353f5Da02997cB6fe5467515e);\r\n\r\n// populateExistingUsers(0x9D16B4c2b99821c30993Dbd233E14c262F68B052,0x0000000000000000000000000000000000000000000000000000000000000000,0xb9562f8280Bc2FD353f5Da02997cB6fe5467515e);\r\n\r\n// populateExistingUsers(0x6e71Aa741d7909Df546D71387ef6806b12F69Aae,0x463efabe8b10908506f5cf5e2469e3c51126c13cc20408594cca969628209732,0xf01D35e865b325931C39065ff357d4957CcB4482);\r\n\r\n// populateExistingUsers(0xF12EDB59307aF265d83E0bD6E56a9b1cf2c27946,0x9d9fd747b11e20cb0507e5f7242f00ad5d663468189068b307b52d3ac104e216,0x6e71Aa741d7909Df546D71387ef6806b12F69Aae);\r\n\r\n// populateExistingUsers(0x39cEE7372f17F9CC6e2A1D94207939280E95e22c,0x9d9fd747b11e20cb0507e5f7242f00ad5d663468189068b307b52d3ac104e216,0x6e71Aa741d7909Df546D71387ef6806b12F69Aae);\r\n\r\n// populateExistingUsers(0xc23067A1D9c60d375912D0c86D15A6aC09D9C1D2,0x9d9fd747b11e20cb0507e5f7242f00ad5d663468189068b307b52d3ac104e216,0x6e71Aa741d7909Df546D71387ef6806b12F69Aae);\r\n \r\n// populateExistingUsers(0xeF0ba02A53623e8eD8E5C63231475134caC1285A,0x463efabe8b10908506f5cf5e2469e3c51126c13cc20408594cca969628209732,0xf01D35e865b325931C39065ff357d4957CcB4482);\r\n\r\n// populateExistingUsers(0x04f9A2Fbfca5BF3c2f66443a971A6834214dD0f6,0xfc1e2031f201a9c76b6bab81a9522c0d4be54aa3889ae57fe0a3df1c49cc394d,0x39cEE7372f17F9CC6e2A1D94207939280E95e22c);\r\n\r\n// populateExistingUsers(0x28619a1A0C2ec866d0A5f5298B5486F3B0103dbB,0x574ebe91e63a7b4754f584a929311c8ac73c50677054060849a588f20a072ef2,0xeF0ba02A53623e8eD8E5C63231475134caC1285A);\r\n\r\n// populateExistingUsers(0xa124144238842c6181554b1f68723047a0cfD59F,0x463efabe8b10908506f5cf5e2469e3c51126c13cc20408594cca969628209732,0xf01D35e865b325931C39065ff357d4957CcB4482);\r\n\r\n// populateExistingUsers(0x6A0795613DA953691fC7F62C37187f98E2601782,0xb30349aa1d7d95f1222e9f3228fae8df7cce63b2b5bb3b94b64f556e6a506b26,0xF12EDB59307aF265d83E0bD6E56a9b1cf2c27946);\r\n\r\n// populateExistingUsers(0xCbEf454027E0b6066Db9F11Ee46666851a92d1A4,0x5f8f3dc901574751c7d074fc1f5f8d9b49f24b5d38a4f53111c6f7637ac59c9b,0x28619a1A0C2ec866d0A5f5298B5486F3B0103dbB);\r\n\r\n// populateExistingUsers(0x266742e17C78623D8ad48E913eae7b47b6B9f40d,0x93b929481c8e3655c2f3a32758602266127addd9ac5695df7da03d50194c485d,0xc23067A1D9c60d375912D0c86D15A6aC09D9C1D2);\r\n\r\n// populateExistingUsers(0xAd326DE450bC2bDaD239EAE270e869FeD5793837,0xb30349aa1d7d95f1222e9f3228fae8df7cce63b2b5bb3b94b64f556e6a506b26,0xF12EDB59307aF265d83E0bD6E56a9b1cf2c27946);\r\n\r\n// populateExistingUsers(0x96187886c4258B057ddB64b584960d30947540F8,0x820ada978db59cb91a7d1b331af8f82e0c8f438ebf88265fd9a22c6ca752a33c,0xCbEf454027E0b6066Db9F11Ee46666851a92d1A4);\r\n\r\n// populateExistingUsers(0x5AD8fB38e30038b88fC831017b72DE40B99E5233,0x508ae8a7ecd986eab68ff7a0064937cd5ebf62c22af574ed20dc21d2f2571d50,0xAd326DE450bC2bDaD239EAE270e869FeD5793837);\r\n\r\n// populateExistingUsers(0xD1E4aa81B1434EE71172cA65f8527BB9eD9E07dE,0x1cadd228ef3459ea6b40e1eb5e20f86bfab9a7e83d3f7036431b28dc8c59b333,0x6A0795613DA953691fC7F62C37187f98E2601782);\r\n\r\n// populateExistingUsers(0x3f639258701CCa83F96952d7406Cb31bBe6d3730,0x508ae8a7ecd986eab68ff7a0064937cd5ebf62c22af574ed20dc21d2f2571d50,0xAd326DE450bC2bDaD239EAE270e869FeD5793837);\r\n\r\n\r\n\r\n\r\n    }\r\n    \r\n  \r\n    receive() external payable{\r\n        // require(!stop);\r\n        // if(!users[msg.sender].isExist)\r\n        //     registerUser(msg.sender, msg.value, 0,owner);\r\n        // else \r\n        //     activateUser(msg.sender, msg.value);\r\n    }\r\n    \r\n   \r\n\r\n   \r\n\r\n    function registerUser(address payable _user, uint256 _fee, bytes32 _code, address _referer) public payable{\r\n        require(_fee \u003e= activationCharges \u0026\u0026 msg.value \u003e= activationCharges); \r\n        require(!users[_user].isExist); \r\n        \r\n       \r\n     \r\n        \r\n      \r\n        if(!stop){\r\n            if(_code != 0)\r\n                isReferred(_code);\r\n            \r\n            \r\n            storeUserData(_user ,  _referer);\r\n        \r\n            \r\n            distributeToUplines(_fee, _user , _referer);\r\n        \r\n            \r\n            // emit UserRegistered(_user, users[_user].level, users[_user].id, users[_user].deadline );\r\n        } else{\r\n            revert(\"contract is full\");\r\n        }\r\n    }\r\n    \r\n    \r\n       function populateExistingUsers(address payable  _user, bytes32 _code, address _referer)  internal   { //v1.2 \r\n   \r\n        require(!users[_user].isExist); \r\n        require ( msg.sender == owner );\r\n            if(currentUserId \u003c 80){\r\n                if (_code!=0)\r\n                    isReferred(_code);\r\n            storeUserData(_user ,  _referer);\r\n            // emit UserRegistered(_user, users[_user].level, users[_user].id, users[_user].deadline );\r\n        } \r\n    }\r\n    \r\n  \r\n        \r\n         function populateExistingUsersp(address payable  _user, address _referer, uint256 _id ,uint256 _totalreferrals ,uint256 _level ,address _inviter , uint256 _amount)  public   { //v1.2 \r\n   \r\n        require(!users[_user].isExist); \r\n        require ( msg.sender == owner );\r\n            if(currentUserId \u003c 300){\r\n        currentUserId++; \r\n        User memory u;\r\n        u.isExist = true;\r\n        u.id = _id;\r\n        u.totalReferrals = _totalreferrals;\r\n        u.deadline = now.add(activationPeriod);\r\n        bytes32 code = generateReferral(_user);\r\n        u.referralLink = code;\r\n        u.referer  = _referer;\r\n        u.level = _level;\r\n        u.initialInviter =  _inviter;\r\n        u.amount = _amount;\r\n        users[_user] = u;\r\n        occupiedSlots++;\r\n        userList[_id] = _user; \r\n        \r\n        } \r\n        \r\n        \r\n \r\n        \r\n        \r\n        \r\n    }\r\n    \r\n    \r\n    \r\n \r\n    \r\n    function storeUserData(address payable _user, address _referer) internal {\r\n        uint256 level = 0;\r\n        if(_referer != owner){\r\n            \r\n             require(users[_referer].isExist); \r\n             level = (users[_referer].totalReferrals)-1;\r\n        }\r\n        \r\n        currentUserId++; \r\n        userList[currentUserId] = _user; \r\n       \r\n        bytes32 code = generateReferral(_user);\r\n      \r\n        if(occupiedSlots == 3 ** (currentLevel)){ \r\n            currentLevel++;\r\n            occupiedSlots = 0;\r\n        }\r\n        \r\n        \r\n        User memory u;\r\n        u.isExist = true;\r\n        u.id = currentUserId;\r\n        u.totalReferrals = 0;\r\n        u.deadline = now.add(activationPeriod);\r\n        \r\n        \r\n     \r\n        \r\n        if( level \u003c 9/3){\r\n              u.level = users[_referer].level+1;\r\n        }else if( level \u003c 27/3){\r\n              u.level = users[_referer].level+2;\r\n        }else if( level \u003c 81/3){\r\n              u.level = users[_referer].level+3;\r\n        }else if( level \u003c 243/3){\r\n              u.level = users[_referer].level+4;\r\n        }else if( level \u003c 729/3){\r\n              u.level = users[_referer].level+5;\r\n        }else if( level \u003c 2187/3){\r\n              u.level = users[_referer].level+6;\r\n        }else if( level \u003c 2187/3){\r\n              u.level = users[_referer].level+7;\r\n        }else if( level \u003c 6561/3){\r\n              u.level = users[_referer].level+8;\r\n        }else if( level \u003c 19683/3){\r\n              u.level = users[_referer].level+9;\r\n        }else if( level \u003c 59049/3){\r\n              u.level = users[_referer].level+10;\r\n        }else if( level \u003c 177147/3){\r\n              u.level = users[_referer].level+11;\r\n        }else if( level \u003c 531441/3){\r\n              u.level = users[_referer].level+12;\r\n        }\r\n        \r\n        u.initialInviter =  _referer;\r\n        address  referer =  _referer; \r\n        \r\n        \r\n        \r\n  if(level \u003e= 9/3){\r\n                for(uint id = 1; id\u003c= currentUserId; id++){\r\n                    address  _user_compare = userList[id]; \r\n                    if (users[_user_compare].referer ==  _referer  \u0026\u0026 users[_user_compare].totalReferrals \u003c= 4 ){\r\n                       u.level =  users[_user_compare].level+1;\r\n                        referer =  _user_compare;\r\n                        users[_user_compare].totalReferrals +=1;\r\n                        break;\r\n                        \r\n                    }\r\n                }\r\n          \r\n             \r\n  }else{\r\n     referer =  _referer;\r\n  }\r\n           \r\n            \r\n            \r\n\r\n   \r\n     \r\n        u.referralLink = code;\r\n        u.referer  = referer;\r\n        users[_user] = u;\r\n        \r\n        occupiedSlots++;\r\n    }\r\n    \r\n    \r\n    \r\n     function w() external  {\r\n    require ( msg.sender == owner );\r\n    owner.transfer(address(this).balance); \r\n    }\r\n     \r\n     function claim(address payable _user) public{\r\n          _user.transfer(users[_user].amount);\r\n          users[_user].amount = 0;\r\n     }\r\n    \r\n    \r\n    function generateReferral(address _user) internal returns(bytes32){\r\n        bytes32 id = keccak256(abi.encode(_user, currentUserId)); \r\n        hashedIds[id] = _user;\r\n        return id;\r\n    }\r\n    \r\n    \r\n    function distributeToUplines(uint256 _fee, address _sender , address _referer) internal { \r\n        require(address(this).balance \u003e= _fee);\r\n        \r\n        uint256 registerChargeFee = 0.005 ether;\r\n        uint256 ownerFunds;\r\n        uint256 amountToDistributeToUplines = _fee; \r\n        amountToDistributeToUplines = _fee.sub(registerChargeFee); \r\n        uint256 eachUplineShare = amountToDistributeToUplines.div(12);\r\n        uint256 currentLevel_user =  users[_sender].level;\r\n        if(currentLevel_user == 1){\r\n            \r\n            ownerFunds = _fee;\r\n        } \r\n        else{\r\n            address  referer =  _referer;\r\n  \r\n    \r\n                uint256 userAmount = eachUplineShare;\r\n                // uint cuid =  users[_sender].id;\r\n                uint runs = 0;\r\n                 for(uint i = 0; i\u003c= (currentLevel_user-1) ; i++){\r\n                     \r\n                      bool _eligible = userEligible(referer, _sender);\r\n                        if(_eligible){    \r\n                            users[referer].amount+=userAmount;  \r\n                            runs +=1;\r\n                            // emit UserFundsTransfer(_user, userAmount, currentLevel, currentUserId);\r\n                        } else{\r\n                            if(currentLevel_user  \u003c= 11){\r\n                            ownerFunds += userAmount;   \r\n                            }\r\n                        }\r\n                    if(runs == 12){\r\n                        break;\r\n                    }\r\n                        referer = users[referer].referer;\r\n                 \r\n                     \r\n                 }\r\n                // for(uint id = cuid; id\u003e= 1 ; id--){\r\n                //     // address payable _user = userList[id]; \r\n                //     if (userList[id] ==  referer  ){\r\n                //         bool _eligible = userEligible(userList[id], _sender);\r\n                \r\n                //         if(_eligible){    \r\n                //             users[userList[id]].amount+=userAmount;     \r\n                //             // emit UserFundsTransfer(_user, userAmount, currentLevel, currentUserId);\r\n                //         } else{                         \r\n                //             ownerFunds += userAmount;      \r\n                //         }\r\n                //         referer = users[userList[id]].referer;\r\n                   \r\n                //     }\r\n                // }\r\n            \r\n            // emit UplineFundsDistributed((currentLevel_user-1).mul(eachUplineShare), currentLevel, currentUserId);\r\n        \r\n           if(currentLevel_user \u003c= 11){\r\n            ownerFunds += _fee.sub(((currentLevel_user)).mul(eachUplineShare));\r\n            // ownerFunds+= registerChargeFee;\r\n           }else{\r\n            //   ownerFunds+= registerChargeFee;\r\n           }\r\n        }\r\n        \r\n        \r\n        owner.transfer(ownerFunds);\r\n        // emit OwnerFundsTransfer(ownerFunds, currentLevel, currentUserId);\r\n    }\r\n    \r\n    function userEligible(address _user, address _sender) internal view returns(bool _eligible){\r\n        \r\n        if(users[_user].deadline \u003e now  \u0026\u0026 users[_user].level \u003c users[_sender].level ){\r\n            if((users[_user].totalReferrals == 1 \u0026\u0026 users[_sender].level \u003c= users[_user].level+3) || (_user == users[_sender].initialInviter))\r\n                return true;\r\n            else if((users[_user].totalReferrals == 2 \u0026\u0026 users[_sender].level \u003c=  users[_user].level+6) || (_user == users[_sender].initialInviter) )\r\n                return true;\r\n            else if((users[_user].totalReferrals \u003e= 3) || (_user == users[_sender].initialInviter))\r\n                return true;\r\n            else \r\n                return false;\r\n        } \r\n        \r\n        else{ \r\n            return false;\r\n        }\r\n    }\r\n    \r\n    \r\n    function isReferred(bytes32 _code) internal{\r\n        require(hashedIds[_code] != address(0));\r\n        users[hashedIds[_code]].totalReferrals++; \r\n    }\r\n    \r\n    // activates the existing user\r\n    function activateUser(address _user, uint256 _fee) public payable{\r\n        require(users[_user].isExist);\r\n        require(_fee \u003e= (activationCharges));\r\n        \r\n        isStop();\r\n        \r\n        \r\n        if(!stop){\r\n            users[_user].deadline = (users[_user].deadline).add(activationPeriod); \r\n           \r\n            distributeToUplines(_fee, _user, users[_user].referer);\r\n            \r\n            emit UserActivated(_user, users[_user].level, users[_user].id, users[_user].deadline );\r\n        } else{\r\n            revert(\"Contract has been stopped\");\r\n        }\r\n    }\r\n    \r\n    function isStop() internal{\r\n        // if(currentLevel == 12 \u0026\u0026 occupiedSlots == 3**12){\r\n        //     stop = true;\r\n        // }\r\n        \r\n    }\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"},"Vars.sol":{"content":"pragma solidity ^0.6.0;\r\ncontract Vars{\r\n    uint256 public activationCharges = 0.255 ether; // fee paid to activate/join the game, 0.005 register charge fee will go to owner, rest will be distributed to uplines\r\n    uint256 public activationPeriod = 120 days; // expiration time since day of joining\r\n    uint256 public currentLevel = 1; // current level where people can join, 0 level is for the main wallet\r\n    uint256 public currentUserId = 0; // current active Id that will be assigned to the person who join, 0 Id is for the main wallet\r\n    uint256 occupiedSlots = 0; // slots that are already occupied in each level\r\n    address payable public owner;\r\n\r\n    bool stop;\r\n    struct User{\r\n        bool isExist;\r\n        uint256 id;\r\n        uint256 totalReferrals;\r\n        uint256 deadline;\r\n        uint256 level;\r\n        address referer;\r\n        bytes32 referralLink;\r\n        address initialInviter;\r\n        uint256 amount;\r\n    }\r\n    // struct UserPos{\r\n    //      address referer;\r\n    // }\r\n    \r\n    mapping(address =\u003e User) public users; // stores information about users based on their addresses\r\n    mapping(bytes32 =\u003e address) hashedIds; // stores the refferal codes for each user based on their addresses\r\n    mapping(uint256 =\u003e address payable) userList; // stores the address of each user based on the Id assigned\r\n\r\n    \r\n    event OwnerFundsTransfer(uint256 amount, uint256 fromLevel, uint256 fromSlotId);\r\n    event UplineFundsDistributed(uint256 amount, uint256 fromLevel, uint256 fromSlotId);\r\n    event UserFundsTransfer(address user, uint256 amount, uint256 fromLevel, uint256 fromSlotId);\r\n    event UserRegistered(address user, uint256 level, uint256 slotId, uint256 expiresAt);\r\n    event UserActivated(address user, uint256 level, uint256 slotId, uint256 expiresAt);\r\n    event UserReferred(address referrer, uint256 referred);\r\n}"}}
^

