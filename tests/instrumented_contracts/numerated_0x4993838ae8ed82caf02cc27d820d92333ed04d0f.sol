1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/MorphsEngine.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/*\n\n            ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó\n            ‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù\n            ‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó\n            ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë\n            ‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë\n            ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n                         Genesis II - 2022-02-25\n\n                           https://morphs.wtf\n\n    Dreamt up and built at Playgrounds <https://playgrounds.wtf>\n    Powered by shell <https://heyshell.xyz>\n    Designed by @polyforms_ <https://twitter.com/polyforms_>\n\n    ---\n\n    This is the second official Morphs engine from Playgrounds ü™ê\n\n    It adds a few twists for the final days of minting and leaves some open\n    ended ideas to explore in future engines.\n\n    You are free to iterate on any Morphs tokens you own! If others like the\n    updates you've made to the project, they could join your fork too.\n\n    Join us in the lab: https://discord.gg/uskZYttHw6\n\n*/\n\nimport \"@r-group/shell-contracts/contracts/engines/ShellBaseEngine.sol\";\nimport \"@r-group/shell-contracts/contracts/engines/OnChainMetadataEngine.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ncontract MorphsEngine is ShellBaseEngine, OnChainMetadataEngine {\n    /// @notice Attempted mint after minting period has ended\n    error MintingPeriodHasEnded();\n\n    /// @notice Attempted cutover for a collection that already switched, or\n    /// from incorrect msg sender\n    error InvalidCutover();\n\n    /// @notice Some actions require msg.sender to own the token being\n    /// interacting with\n    error NotTokenOwner();\n\n    /// @notice Morphs only works with ERC-721s for now, since we are allowing\n    /// owner-specific behavior with sigils and balance checks for entangled\n    /// Morphs. It could be made compat with ERC-1155s with some finessing if desired\n    error InvalidCollection();\n\n    /// @notice Sigil attempted to be set that didnt pass verification\n    error InvalidSigil();\n\n    /// @notice Can't mint after March 1st midnight CST\n    uint256 public constant MINTING_ENDS_AT_TIMESTAMP = 1646114400;\n\n    /// @notice Displayed on heyshell.xyz\n    function name() external pure returns (string memory) {\n        return \"morphs-v2\";\n    }\n\n    /// @notice Mint a morph!\n    /// @param flag Permenantly written into the NFT. Cannot be modified after mint\n    function mint(IShellFramework collection, uint256 flag)\n        external\n        returns (uint256)\n    {\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp >= MINTING_ENDS_AT_TIMESTAMP) {\n            revert MintingPeriodHasEnded();\n        }\n\n        IntStorage[] memory intData;\n\n        // flag is written to token mint data if set\n        if (flag != 0) {\n            intData = new IntStorage[](1);\n            intData[0] = IntStorage({key: \"flag\", value: flag});\n        } else {\n            intData = new IntStorage[](0);\n        }\n\n        uint256 tokenId = collection.mint(\n            MintEntry({\n                to: msg.sender,\n                amount: 1,\n                options: MintOptions({\n                    storeEngine: false,\n                    storeMintedTo: false,\n                    storeTimestamp: false,\n                    storeBlockNumber: false,\n                    stringData: new StringStorage[](0),\n                    intData: intData\n                })\n            })\n        );\n\n        return tokenId;\n    }\n\n    /// @notice Mint several Morphs in a single transaction (flag=0 for all)\n    function batchMint(IShellFramework collection, uint256 count) external {\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp >= MINTING_ENDS_AT_TIMESTAMP) {\n            revert MintingPeriodHasEnded();\n        }\n\n        StringStorage[] memory stringData = new StringStorage[](0);\n        IntStorage[] memory intData = new IntStorage[](0);\n\n        for (uint256 i = 0; i < count; i++) {\n            collection.mint(\n                MintEntry({\n                    to: msg.sender,\n                    amount: 1,\n                    options: MintOptions({\n                        storeEngine: false,\n                        storeMintedTo: false,\n                        storeTimestamp: false,\n                        storeBlockNumber: false,\n                        stringData: stringData,\n                        intData: intData\n                    })\n                })\n            );\n        }\n    }\n\n    /// @notice start using the new token rolling logic, can only be called once\n    /// and by the root fork owner of the collection\n    function cutover(IShellFramework collection) external {\n        if (collection.readForkInt(StorageLocation.ENGINE, 0, \"cutover\") != 0) {\n            revert InvalidCutover();\n        }\n        if (msg.sender != collection.getForkOwner(0)) {\n            revert InvalidCutover();\n        }\n\n        // cutover token = next token ID, all future tokens will use new algo\n        collection.writeForkInt(\n            StorageLocation.ENGINE,\n            0,\n            \"cutover\",\n            collection.nextTokenId()\n        );\n    }\n\n    /// @notice Owner of a token may write a \"sigil\" string value to token\n    /// storage at any time\n    function updateSigil(\n        IShellFramework collection,\n        uint256 tokenId,\n        string memory sigil\n    ) external {\n        IERC721 erc721 = IERC721(address(collection));\n\n        if (erc721.ownerOf(tokenId) != msg.sender) {\n            revert NotTokenOwner();\n        }\n\n        if (bytes(sigil).length > 8) {\n            revert InvalidSigil();\n        }\n\n        collection.writeTokenString(\n            StorageLocation.ENGINE,\n            tokenId,\n            \"sigil\",\n            sigil\n        );\n    }\n\n    /// @dev because of the owner semantics, we want to be able to assume the\n    /// collection is a 721\n    function afterEngineSet(uint256)\n        external\n        view\n        override(IEngine, ShellBaseEngine)\n    {\n        IShellFramework collection = IShellFramework(msg.sender);\n        bool is721 = collection.supportsInterface(type(IERC721).interfaceId);\n\n        if (!is721) {\n            revert InvalidCollection();\n        }\n    }\n\n    /// @notice Gets the flag value written at mint time for a specific NFT\n    function getFlag(IShellFramework collection, uint256 tokenId)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            collection.readTokenInt(StorageLocation.MINT_DATA, tokenId, \"flag\");\n    }\n\n    /// @notice Returns true if this token was minted after the engine cutover\n    function isCutoverToken(IShellFramework collection, uint256 tokenId)\n        public\n        view\n        returns (bool)\n    {\n        uint256 transitionTokenId = collection.readForkInt(\n            StorageLocation.ENGINE,\n            0,\n            \"cutover\"\n        );\n\n        return transitionTokenId != 0 && tokenId >= transitionTokenId;\n    }\n\n    /// @notice Get the palette index (1-based) for a specific token\n    function getPaletteIndex(IShellFramework collection, uint256 tokenId)\n        public\n        view\n        returns (uint256)\n    {\n        // new logic, select palette 7-24\n        if (isCutoverToken(collection, tokenId)) {\n            return selectInRange(tokenId, 7, 24);\n        }\n\n        // OG logic - only selects palette 1-6\n        return selectInRange(tokenId, 1, 6);\n    }\n\n    /// @notice Get the edition index (0-based) for a specific token\n    function getEditionIndex(IShellFramework collection, uint256 tokenId)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 flag = getFlag(collection, tokenId);\n        bool isCutover = isCutoverToken(collection, tokenId);\n\n        // celestial = always use 0th edition\n        if (flag > 2) {\n            return 0;\n        }\n\n        // OG tokens always = edition 1\n        if (!isCutover) {\n            return 1;\n        }\n\n        // else, edition is strictly a function of the palette\n        // palette will be 7-24 since this is a post-cutover token\n        uint256 palette = getPaletteIndex(collection, tokenId);\n\n        if (palette < 13) {\n            return 2;\n        }\n        if (palette < 19) {\n            return 3;\n        }\n\n        return 4;\n    }\n\n    /// @notice Get the variation for a specific token\n    function getVariation(IShellFramework collection, uint256 tokenId)\n        public\n        view\n        returns (string memory)\n    {\n        bool isCutover = isCutoverToken(collection, tokenId);\n        uint256 flag = getFlag(collection, tokenId);\n\n        // all celestials (old and new) roll a variation based on flag value\n        if (flag > 2) {\n            // 5 celestials, Z1-Z5\n            return\n                string.concat(\"Z\", Strings.toString(selectInRange(flag, 1, 5)));\n        }\n\n        // OG logic\n        if (!isCutover) {\n            if (flag == 2) {\n                // Only 1 OG cosmic\n                return \"X1\";\n            } else if (flag == 1) {\n                // 4 OG mythicals, M1-M4\n                return\n                    string.concat(\n                        \"M\",\n                        Strings.toString(selectInRange(tokenId, 1, 4))\n                    );\n            }\n\n            // 10 OG citizen, C1-C10\n            return\n                string.concat(\n                    \"C\",\n                    Strings.toString(selectInRange(tokenId, 1, 10))\n                );\n        }\n\n        // post-cutover logic\n        if (flag == 2) {\n            // 4 new cosmic, X2-5\n            return\n                string.concat(\n                    \"X\",\n                    Strings.toString(selectInRange(tokenId, 2, 5))\n                );\n        } else if (flag == 1) {\n            // 11 new mythicals, M5-15\n            return\n                string.concat(\n                    \"M\",\n                    Strings.toString(selectInRange(tokenId, 5, 15))\n                );\n        }\n\n        // 15 new citizens, C11-25\n        return\n            string.concat(\n                \"C\",\n                Strings.toString(selectInRange(tokenId, 11, 25))\n            );\n    }\n\n    /// @dev return a number between lower and upper, inclusive... based on seed\n    function selectInRange(\n        uint256 seed,\n        uint256 lower,\n        uint256 upper\n    ) private pure returns (uint256) {\n        uint256 i = uint256(keccak256(abi.encodePacked(seed))) %\n            (upper - lower + 1);\n        return lower + i;\n    }\n\n    /// @notice Get the name of a palette by index\n    function getPaletteName(uint256 index) public pure returns (string memory) {\n        if (index == 1) {\n            return \"Greyskull\";\n        } else if (index == 2) {\n            return \"Ancient Opinions\";\n        } else if (index == 3) {\n            return \"The Desert Sun\";\n        } else if (index == 4) {\n            return \"The Deep\";\n        } else if (index == 5) {\n            return \"The Jade Prism\";\n        } else if (index == 6) {\n            return \"Cosmic Understanding\";\n        } else if (index == 7) {\n            return \"Ancient Grudges\";\n        } else if (index == 8) {\n            return \"Radiant Beginnings\";\n        } else if (index == 9) {\n            return \"Desert Sand\";\n        } else if (index == 10) {\n            return \"Arcane Slate\";\n        } else if (index == 11) {\n            return \"The Vibrant Forest\";\n        } else if (index == 12) {\n            return \"Evening Star\";\n        } else if (index == 13) {\n            return \"Dawn\";\n        } else if (index == 14) {\n            return \"Calm Air\";\n        } else if (index == 15) {\n            return \"Solarion\";\n        } else if (index == 16) {\n            return \"Morning Sun\";\n        } else if (index == 17) {\n            return \"Emerald\";\n        } else if (index == 18) {\n            return \"Stellaris\";\n        } else if (index == 19) {\n            return \"Future Island\";\n        } else if (index == 20) {\n            return \"Scorched Emerald\";\n        } else if (index == 21) {\n            return \"Stone\";\n        } else if (index == 22) {\n            return \"The Night Sky\";\n        } else if (index == 23) {\n            return \"The Beacon\";\n        } else if (index == 24) {\n            return \"Blackskull\";\n        }\n\n        return \"\";\n    }\n\n    /// @notice Read the sigil value in storage for a specific token\n    function getSigil(IShellFramework collection, uint256 tokenId)\n        public\n        view\n        returns (string memory)\n    {\n        return\n            collection.readTokenString(\n                StorageLocation.ENGINE,\n                tokenId,\n                \"sigil\"\n            );\n    }\n\n    /// @notice Returns true if a token has an address as a flag that has at\n    /// least 1 Morph\n    function isEntangled(IShellFramework collection, uint256 tokenId)\n        public\n        view\n        returns (bool)\n    {\n        uint256 flag = getFlag(collection, tokenId);\n        IERC721 erc721 = IERC721(address(collection));\n        address subject = address(uint160(flag));\n\n        return flag > 0 && erc721.balanceOf(subject) > 0;\n    }\n\n    function _computeName(IShellFramework collection, uint256 tokenId)\n        internal\n        view\n        override\n        returns (string memory)\n    {\n        uint256 flag = getFlag(collection, tokenId);\n        bool entangled = isEntangled(collection, tokenId);\n\n        return\n            string(\n                abi.encodePacked(\n                    \"Morph #\",\n                    Strings.toString(tokenId),\n                    entangled ? \": Entangled Scroll of \" : flag > 2\n                        ? \": Celestial Scroll of \"\n                        : flag == 2\n                        ? \": Cosmic Scroll of \"\n                        : flag == 1\n                        ? \": Mythical Scroll of \"\n                        : \": Scroll of \",\n                    getPaletteName(getPaletteIndex(collection, tokenId))\n                )\n            );\n    }\n\n    function _computeDescription(IShellFramework collection, uint256 tokenId)\n        internal\n        view\n        override\n        returns (string memory)\n    {\n        uint256 flag = getFlag(collection, tokenId);\n\n        return\n            string.concat(\n                flag > 2\n                    ? \"A mysterious scroll... you feel it pulsating with celestial energy. Its presence bridges the gap between old and new.\"\n                    : flag == 2\n                    ? \"A mysterious scroll... you feel it pulsating with cosmic energy. Its whispers speak secrets of cosmic significance.\"\n                    : flag == 1\n                    ? \"A mysterious scroll... you feel it pulsating with mythical energy. You sense its power is great.\"\n                    : \"A mysterious scroll... you feel it pulsating with energy. What secrets might it hold?\",\n                isEntangled(collection, tokenId)\n                    ? string.concat(\n                        \"\\\\n\\\\nThis Morph is entangled with address \",\n                        Strings.toHexString(flag)\n                    )\n                    : flag > 2\n                    ? string.concat(\n                        \"\\\\n\\\\nEternal celestial signature: \",\n                        Strings.toString(flag)\n                    )\n                    : \"\",\n                isCutoverToken(collection, tokenId)\n                    ? \"\\\\n\\\\nThis Morph was minted in the Genesis II era.\"\n                    : \"\\\\n\\\\nThis Morph was minted in the Genesis I era.\",\n                \"\\\\n\\\\nhttps://playgrounds.wtf\"\n            );\n    }\n\n    // compute the metadata image field for a given token\n    function _computeImageUri(IShellFramework collection, uint256 tokenId)\n        internal\n        view\n        override\n        returns (string memory)\n    {\n        uint256 edition = getEditionIndex(collection, tokenId);\n        uint256 palette = getPaletteIndex(collection, tokenId);\n        string memory variation = getVariation(collection, tokenId);\n\n        string memory image = string.concat(\n            \"S\",\n            Strings.toString(edition),\n            \"-\",\n            \"P\",\n            Strings.toString(palette),\n            \"-\",\n            variation,\n            \".png\"\n        );\n\n        return\n            string.concat(\n                \"ipfs://ipfs/QmeQi6Ufs4JyrMR54o9TRraKMRhp1MTL2Bn811ad8Y7kK1/\",\n                image\n            );\n    }\n\n    // compute the external_url field for a given token\n    function _computeExternalUrl(IShellFramework, uint256)\n        internal\n        pure\n        override\n        returns (string memory)\n    {\n        return \"https://morphs.wtf\";\n    }\n\n    function _computeAttributes(IShellFramework collection, uint256 tokenId)\n        internal\n        view\n        override\n        returns (Attribute[] memory)\n    {\n        uint256 palette = getPaletteIndex(collection, tokenId);\n        string memory sigil = getSigil(collection, tokenId);\n\n        Attribute[] memory attributes = new Attribute[](8);\n\n        attributes[0] = Attribute({\n            key: \"Palette\",\n            value: getPaletteName(palette)\n        });\n\n        attributes[1] = Attribute({\n            key: \"Variation\",\n            value: getVariation(collection, tokenId)\n        });\n\n        uint256 flag = getFlag(collection, tokenId);\n        attributes[2] = Attribute({\n            key: \"Affinity\",\n            value: flag > 2 ? \"Celestial\" : flag == 2 ? \"Cosmic\" : flag == 1\n                ? \"Mythical\"\n                : \"Citizen\"\n        });\n\n        attributes[3] = Attribute({\n            key: \"Era\",\n            value: isCutoverToken(collection, tokenId)\n                ? \"Genesis II\"\n                : \"Genesis I\"\n        });\n\n        attributes[4] = Attribute({\n            key: \"Signature\",\n            value: flag > 2 ? Strings.toString(flag) : \"None\"\n        });\n\n        attributes[5] = Attribute({\n            key: \"Group\",\n            value: string.concat(\n                \"Group \",\n                Strings.toString(getEditionIndex(collection, tokenId))\n            )\n        });\n\n        attributes[6] = Attribute({\n            key: \"Sigil\",\n            value: bytes(sigil).length > 0 ? sigil : \"Unaligned\"\n        });\n\n        attributes[7] = Attribute({\n            key: \"Quantum Status\",\n            value: isEntangled(collection, tokenId)\n                ? \"Entangled\"\n                : \"Independent\"\n        });\n\n        return attributes;\n    }\n}\n"
6     },
7     "@r-group/shell-contracts/contracts/engines/ShellBaseEngine.sol": {
8       "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"../IEngine.sol\";\n\n// simple starting point for engines\n// - default name\n// - proper erc165 support\n// - no royalties\n// - nop on beforeTokenTransfer and afterEngineSet hooks\nabstract contract ShellBaseEngine is IEngine {\n\n    // nop\n    function beforeTokenTransfer(\n        address,\n        address,\n        address,\n        uint256,\n        uint256\n    ) external pure virtual override {\n        return;\n    }\n\n    // nop\n    function afterEngineSet(uint256) external view virtual override {\n        return;\n    }\n\n    // no royalties\n    function getRoyaltyInfo(\n        IShellFramework,\n        uint256,\n        uint256\n    ) external view virtual returns (address receiver, uint256 royaltyAmount) {\n        receiver = address(0);\n        royaltyAmount = 0;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceId == type(IEngine).interfaceId ||\n            interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
9     },
10     "@r-group/shell-contracts/contracts/engines/OnChainMetadataEngine.sol": {
11       "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../libraries/Base64.sol\";\nimport \"../IShellFramework.sol\";\nimport \"../IEngine.sol\";\n\nstruct Attribute {\n    string key;\n    string value;\n}\n\nabstract contract OnChainMetadataEngine is IEngine {\n    // Called by the collection to resolve a response for tokenURI\n    function getTokenURI(IShellFramework collection, uint256 tokenId)\n        external\n        view\n        returns (string memory)\n    {\n        string memory name = _computeName(collection, tokenId);\n        string memory description = _computeDescription(collection, tokenId);\n        string memory image = _computeImageUri(collection, tokenId);\n        string memory externalUrl = _computeExternalUrl(collection, tokenId);\n        Attribute[] memory attributes = _computeAttributes(collection, tokenId);\n\n        string memory attributesInnerJson = \"\";\n        for (uint256 i = 0; i < attributes.length; i++) {\n            attributesInnerJson = string(\n                bytes(\n                    abi.encodePacked(\n                        attributesInnerJson,\n                        i > 0 ? \", \" : \"\",\n                        '{\"trait_type\": \"',\n                        attributes[i].key,\n                        '\", \"value\": \"',\n                        attributes[i].value,\n                        '\"}'\n                    )\n                )\n            );\n        }\n\n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    Base64.encode(\n                        bytes(\n                            abi.encodePacked(\n                                '{\"name\":\"',\n                                name,\n                                '\", \"description\":\"',\n                                description,\n                                '\", \"image\": \"',\n                                image,\n                                '\", \"external_url\": \"',\n                                externalUrl,\n                                '\", \"attributes\": [',\n                                attributesInnerJson,\n                                \"]}\"\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    // compute the metadata name for a given token\n    function _computeName(IShellFramework collection, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (string memory);\n\n    // compute the metadata description for a given token\n    function _computeDescription(IShellFramework collection, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (string memory);\n\n    // compute the metadata image field for a given token\n    function _computeImageUri(IShellFramework collection, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (string memory);\n\n    // compute the external_url field for a given token\n    function _computeExternalUrl(IShellFramework collection, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (string memory);\n\n    function _computeAttributes(IShellFramework collection, uint256 token)\n        internal\n        view\n        virtual\n        returns (Attribute[] memory);\n}\n"
12     },
13     "@openzeppelin/contracts/utils/Strings.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
15     },
16     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
18     },
19     "@openzeppelin/contracts/interfaces/IERC165.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
21     },
22     "@r-group/shell-contracts/contracts/IEngine.sol": {
23       "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"./IShellFramework.sol\";\n\n// Required interface for framework engines\n// interfaceId = 0x0b1d171c\ninterface IEngine is IERC165 {\n    // Get the name for this engine\n    function name() external pure returns (string memory);\n\n    // Called by the framework to resolve a response for tokenURI method\n    function getTokenURI(IShellFramework collection, uint256 tokenId)\n        external\n        view\n        returns (string memory);\n\n    // Called by the framework to resolve a response for royaltyInfo method\n    function getRoyaltyInfo(\n        IShellFramework collection,\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount);\n\n    // Called by the framework during a transfer, including mints (from=0) and\n    // burns (to=0). Cannot break transfer even in the case of reverting, as the\n    // collection will wrap the downstream call in a try/catch\n    // collection = msg.sender\n    function beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount\n    ) external;\n\n    // Called by the framework whenever an engine is set on a fork, including\n    // the collection (fork id = 0). Can be used by engine developers to prevent\n    // an engine from being installed in a collection or non-canonical fork if\n    // desired\n    // collection = msg.sender\n    function afterEngineSet(uint256 forkId) external;\n}\n"
24     },
25     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
27     },
28     "@r-group/shell-contracts/contracts/IShellFramework.sol": {
29       "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport \"./libraries/IOwnable.sol\";\nimport \"./IEngine.sol\";\n\n// storage flag\nenum StorageLocation {\n    INVALID,\n    // set by the engine at any time, mutable\n    ENGINE,\n    // set by the engine during minting, immutable\n    MINT_DATA,\n    // set by the framework during minting or collection creation, immutable\n    FRAMEWORK\n}\n\n// string key / value\nstruct StringStorage {\n    string key;\n    string value;\n}\n\n// int key / value\nstruct IntStorage {\n    string key;\n    uint256 value;\n}\n\n// data provided when minting a new token\nstruct MintEntry {\n    address to;\n    uint256 amount;\n    MintOptions options;\n}\n\n// Data provided by engine when minting a new token\nstruct MintOptions {\n    bool storeEngine;\n    bool storeMintedTo;\n    bool storeTimestamp;\n    bool storeBlockNumber;\n    StringStorage[] stringData;\n    IntStorage[] intData;\n}\n\n// Information about a fork\nstruct Fork {\n    IEngine engine;\n    address owner;\n}\n\n// Interface for every collection launched by shell.\n// Concrete implementations must return true on ERC165 checks for this interface\n// (as well as erc165 / 2981)\n// interfaceId = TBD\ninterface IShellFramework is IERC165, IERC2981 {\n    // ---\n    // Framework errors\n    // ---\n\n    // an engine was provided that did no pass the expected erc165 checks\n    error InvalidEngine();\n\n    // a write was attempted that is not allowed\n    error WriteNotAllowed();\n\n    // an operation was attempted but msg.sender was not the expected engine\n    error SenderNotEngine();\n\n    // an operation was attempted but msg.sender was not the fork owner\n    error SenderNotForkOwner();\n\n    // a token fork was attempted by an invalid msg.sender\n    error SenderCannotFork();\n\n    // ---\n    // Framework events\n    // ---\n\n    // a fork was created\n    event ForkCreated(uint256 forkId, IEngine engine, address owner);\n\n    // a fork had a new engine installed\n    event ForkEngineUpdated(uint256 forkId, IEngine engine);\n\n    // a fork had a new owner set\n    event ForkOwnerUpdated(uint256 forkId, address owner);\n\n    // a token has been set to a new fork\n    event TokenForkUpdated(uint256 tokenId, uint256 forkId);\n\n    // ---\n    // Storage events\n    // ---\n\n    // A fork string was stored\n    event ForkStringUpdated(\n        StorageLocation location,\n        uint256 forkId,\n        string key,\n        string value\n    );\n\n    // A fork int was stored\n    event ForkIntUpdated(\n        StorageLocation location,\n        uint256 forkId,\n        string key,\n        uint256 value\n    );\n\n    // A token string was stored\n    event TokenStringUpdated(\n        StorageLocation location,\n        uint256 tokenId,\n        string key,\n        string value\n    );\n\n    // A token int was stored\n    event TokenIntUpdated(\n        StorageLocation location,\n        uint256 tokenId,\n        string key,\n        uint256 value\n    );\n\n    // ---\n    // Collection base\n    // ---\n\n    // called immediately after cloning\n    function initialize(\n        string calldata name,\n        string calldata symbol,\n        IEngine engine,\n        address owner\n    ) external;\n\n    // ---\n    // General collection info / metadata\n    // ---\n\n    // collection owner (fork 0 owner)\n    function owner() external view returns (address);\n\n    // collection name\n    function name() external view returns (string memory);\n\n    // collection name\n    function symbol() external view returns (string memory);\n\n    // next token id serial number\n    function nextTokenId() external view returns (uint256);\n\n    // next fork id serial number\n    function nextForkId() external view returns (uint256);\n\n    // ---\n    // Fork functionality\n    // ---\n\n    // Create a new fork with a specific engine, fork all the tokenIds to the\n    // new engine, and return the fork ID\n    function createFork(\n        IEngine engine,\n        address owner,\n        uint256[] calldata tokenIds\n    ) external returns (uint256);\n\n    // Set the engine for a specific fork. Must be fork owner\n    function setForkEngine(uint256 forkId, IEngine engine) external;\n\n    // Set the fork owner. Must be fork owner\n    function setForkOwner(uint256 forkId, address owner) external;\n\n    // Set the fork of a specific token. Must be token owner\n    function setTokenFork(uint256 tokenId, uint256 forkId) external;\n\n    // Set the fork for several tokens. Must own all tokens\n    function setTokenForks(uint256[] memory tokenIds, uint256 forkId) external;\n\n    // ---\n    // Fork views\n    // ---\n\n    // Get information about a fork\n    function getFork(uint256 forkId) external view returns (Fork memory);\n\n    // Get a fork's engine\n    function getForkEngine(uint256 forkId) external view returns (IEngine);\n\n    // Get a fork's owner\n    function getForkOwner(uint256 forkId) external view returns (address);\n\n    // Get a token's fork ID\n    function getTokenForkId(uint256 tokenId) external view returns (uint256);\n\n    // Get a token's engine. getFork(getTokenForkId(tokenId)).engine\n    function getTokenEngine(uint256 tokenId) external view returns (IEngine);\n\n    // Determine if a given msg.sender can fork a token\n    function canSenderForkToken(address sender, uint256 tokenId)\n        external\n        view\n        returns (bool);\n\n    // ---\n    // Engine functionality\n    // ---\n\n    // mint new tokens. Only callable by collection engine\n    function mint(MintEntry calldata entry) external returns (uint256);\n\n    // ---\n    // Storage writes\n    // ---\n\n    // Write a string to collection storage. Only callable by collection engine\n    function writeForkString(\n        StorageLocation location,\n        uint256 forkId,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    // Write a string to collection storage. Only callable by collection engine\n    function writeForkInt(\n        StorageLocation location,\n        uint256 forkId,\n        string calldata key,\n        uint256 value\n    ) external;\n\n    // Write a string to token storage. Only callable by token engine\n    function writeTokenString(\n        StorageLocation location,\n        uint256 tokenId,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    // Write a string to token storage. Only callable by token engine\n    function writeTokenInt(\n        StorageLocation location,\n        uint256 tokenId,\n        string calldata key,\n        uint256 value\n    ) external;\n\n    // ---\n    // Storage reads\n    // ---\n\n    // Read a string from collection storage\n    function readForkString(\n        StorageLocation location,\n        uint256 forkId,\n        string calldata key\n    ) external view returns (string memory);\n\n    // Read a uint256 from collection storage\n    function readForkInt(\n        StorageLocation location,\n        uint256 forkId,\n        string calldata key\n    ) external view returns (uint256);\n\n    // Read a string from token storage\n    function readTokenString(\n        StorageLocation location,\n        uint256 tokenId,\n        string calldata key\n    ) external view returns (string memory);\n\n    // Read a uint256 from token storage\n    function readTokenInt(\n        StorageLocation location,\n        uint256 tokenId,\n        string calldata key\n    ) external view returns (uint256);\n}\n"
30     },
31     "@openzeppelin/contracts/interfaces/IERC2981.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Called with the sale price to determine how much royalty is owed and to whom.\n     * @param tokenId - the NFT asset queried for royalty information\n     * @param salePrice - the sale price of the NFT asset specified by `tokenId`\n     * @return receiver - address of who should be sent the royalty payment\n     * @return royaltyAmount - the royalty payment amount for `salePrice`\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
33     },
34     "@r-group/shell-contracts/contracts/libraries/IOwnable.sol": {
35       "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// (semi) standard ownable interface\ninterface IOwnable {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    function owner() external view returns (address);\n\n    function renounceOwnership() external;\n\n    function transferOwnership(address newOwner) external;\n}\n"
36     },
37     "@r-group/shell-contracts/contracts/libraries/Base64.sol": {
38       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// https://github.com/Brechtpd/base64/blob/main/base64.sol\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides a function for encoding some bytes in base64\nlibrary Base64 {\n    string internal constant TABLE =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return \"\";\n\n        // load the table into memory\n        string memory table = TABLE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                dataPtr := add(dataPtr, 3)\n\n                // read 3 bytes\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore(\n                    resultPtr,\n                    shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore(\n                    resultPtr,\n                    shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore(\n                    resultPtr,\n                    shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore(\n                    resultPtr,\n                    shl(248, mload(add(tablePtr, and(input, 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n        }\n\n        return result;\n    }\n}\n"
39     }
40   },
41   "settings": {
42     "optimizer": {
43       "enabled": true,
44       "runs": 200
45     },
46     "outputSelection": {
47       "*": {
48         "*": [
49           "evm.bytecode",
50           "evm.deployedBytecode",
51           "devdoc",
52           "userdoc",
53           "metadata",
54           "abi"
55         ]
56       }
57     },
58     "libraries": {}
59   }
60 }}