1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/Metalend.sol": {
5       "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {Sunsetable} from \"./Sunsetable.sol\";\nimport {Constants} from \"./Constants.sol\";\n\ncontract Metalend is IERC721Receiver, Ownable, Pausable, Sunsetable {\n  /** -----------------------------------------------------------------------------\n   *   State variable definitions\n   *   -----------------------------------------------------------------------------\n   */\n  // struct object that represents a single instance of a loan:\n  struct LoanItem {\n    // Storage packing - try and use the smallest number of slots!\n    // (One slot is 32 bytes, or 256 bits, and you have to declare\n    // these in order for the EVM to pack them together. . .)\n    // Addresses are 20 bytes.\n    // Slot 1, 256:\n    uint128 loanId;\n    uint128 currentBalance;\n    // Slot 2, 248:\n    bool isCurrent;\n    address payable borrower;\n    uint32 startDate;\n    uint32 endDate;\n    uint16 tokenId;\n  }\n\n  // Slot 1 192 (160 + 16 + 16)\n  // This designates the eligible NFT address, i.e. the address from which NFTs can\n  // receive loans in exchange for custodied collateral (the NFT itself):\n  // Contract implementation of ERC721\n  IERC721 public tokenContract;\n  // Term in days:\n  uint16 public termInDays;\n  // How close to the end date do we need to be to extend in days?\n  uint16 public extensionHorizon;\n\n  // Slot 2 256 (128 + 64 + 64)\n  // In this version the loan amount is a fixed amount:\n  uint128 public loanAmount;\n  // Each loan attracts a lending fee. The amount the borrower has to repay to redeem the\n  // NFT is the loan amount plus the lending fee:\n  uint64 public lendingFee;\n  // A fee to extend the loan by another loan term:\n  uint64 public extensionFee;\n\n  // Slot 3 - 160 (160)\n  // Reposession address - this is the address that NFTs will be send to on the expiry\n  // of the loan term.\n  address public repoAddress;\n\n  // The array of items under loan:\n  LoanItem[] public itemsUnderLoan;\n\n  /** -----------------------------------------------------------------------------\n   *   Contract event definitions\n   *   -----------------------------------------------------------------------------\n   */\n  // Events are broadcast and can be watched and tracked on chain:\n  event lendingTransaction(\n    uint128 indexed loanId,\n    uint256 indexed transactionCode,\n    address indexed borrower,\n    uint16 tokenId,\n    uint256 transactionValue,\n    uint256 transactionFee,\n    uint256 loanEndDate,\n    uint256 effectiveDate\n  );\n  event eligibleNFTAddressSet(address indexed nftAddress);\n  event repoAddressSet(address indexed repoAddress);\n  event loanAmountSet(uint128 indexed loanAmount);\n  event lendingFeeSet(uint64 indexed lendingFee);\n  event extensionFeeSet(uint64 indexed extensionFee);\n  event termInDaysSet(uint16 indexed termInDays);\n  event extensionHorizonSet(uint16 indexed extensionHorizon);\n  event ethWithdrawn(uint256 indexed withdrawal, uint256 effectiveDate);\n  event ethDeposited(uint256 indexed deposit, uint256 effectiveDate);\n\n  constructor(\n    address _tokenAddress,\n    uint128 _loanAmount,\n    uint16 _termInDays,\n    address _repoAddress,\n    uint64 _lendingFee,\n    uint64 _extensionFee,\n    uint16 _extensionHorizon\n  ) {\n    tokenContract = IERC721(_tokenAddress);\n    loanAmount = _loanAmount;\n    termInDays = _termInDays;\n    repoAddress = _repoAddress;\n    lendingFee = _lendingFee;\n    extensionFee = _extensionFee;\n    extensionHorizon = _extensionHorizon;\n    pause();\n  }\n\n  /** -----------------------------------------------------------------------------\n   *   Modifier definitions\n   *   -----------------------------------------------------------------------------\n   */\n\n  // Check to see if the array item has the borrower as the calling address:\n  modifier OnlyItemBorrower(uint128 _loanId) {\n    require(\n      itemsUnderLoan[_loanId].borrower == msg.sender,\n      \"Payments can only be made by the borrower\"\n    );\n    _;\n  }\n\n  // Check to see if the array item returned is no longer current:\n  modifier IsUnderLoan(uint128 _loanId) {\n    require(\n      itemsUnderLoan[_loanId].isCurrent == true,\n      \"Item is not currently under loan\"\n    );\n    _;\n  }\n\n  // Check to see if loan can be extended:\n  modifier LoanEligibleForExtension(uint128 _loanId) {\n    require(\n      extensionsAllowed() == true,\n      \"Extensions currently not allowed\"\n    );\n    require(\n      isWithinExtensionHorizon(_loanId) == true,\n      \"Loan is not within extension horizon\"\n    );\n    _;\n  }\n\n  // Check to see if loan is within term:\n  modifier LoanWithinLoanTerm(uint128 _loanId) {\n    require(\n      isWithinLoanTerm(_loanId) == true,\n      \"Loan term has expired\");\n    _;\n  }\n\n  /** -----------------------------------------------------------------------------\n   *   Set routines - these routines allow the owner to set parameters on this contract:\n   *   -----------------------------------------------------------------------------\n   */\n\n  // Set the address that assets are transfered to on repossession:\n  function setRepoAddress(address _repoAddress)\n    external\n    onlyOwner\n    returns (bool)\n  {\n    repoAddress = _repoAddress;\n    emit repoAddressSet(_repoAddress);\n    return true;\n  }\n\n  // Set the loan amount:\n  function setLoanAmount(uint128 _loanAmount)\n    external\n    onlyOwner\n    returns (bool)\n  {\n    require(_loanAmount != loanAmount, \"No change to loan amount\");\n    if (_loanAmount > loanAmount) {\n        require(\n            (_loanAmount - loanAmount) <=\n                Constants.LOAN_AMOUNT_MAX_INCREMENT,\n            \"Change exceeds max increment\"\n        );\n    } else {\n        require(\n            (loanAmount - _loanAmount) <=\n                Constants.LOAN_AMOUNT_MAX_INCREMENT,\n            \"Change exceeds max increment\"\n        );\n    }\n    loanAmount = _loanAmount;\n    emit loanAmountSet(_loanAmount);\n    return true;\n  }\n\n  // Set the lending fee:\n  function setLendingFee(uint64 _lendingFee) external onlyOwner returns (bool) {\n    require(_lendingFee != lendingFee, \"No change to lending fee\");\n    if (_lendingFee > lendingFee) {\n      require(\n        (_lendingFee - lendingFee) <= Constants.FEE_MAX_INCREMENT,\n        \"Change exceeds max increment\"\n      );\n      } else {\n        require(\n          (lendingFee - _lendingFee) <= Constants.FEE_MAX_INCREMENT,\n          \"Change exceeds max increment\"\n          );\n      }\n    lendingFee = _lendingFee;\n    emit lendingFeeSet(_lendingFee);\n    return true;\n  }\n\n  // Set the extension fee:\n  function setExtensionFee(uint64 _extensionFee)\n    external\n    onlyOwner\n    returns (bool)\n  {\n    require(_extensionFee != extensionFee, \"No change to extension fee\");\n    if (_extensionFee > extensionFee) {\n        require(\n            (_extensionFee - extensionFee) <= Constants.FEE_MAX_INCREMENT,\n            \"Change exceeds max increment\"\n        );\n    } else {\n        require(\n            (extensionFee - _extensionFee) <= Constants.FEE_MAX_INCREMENT,\n            \"Change exceeds max increment\"\n        );\n    }\n    extensionFee = _extensionFee;\n    emit extensionFeeSet(_extensionFee);\n    return true;\n  }\n\n  // Set the term in days:\n  function setTermInDays(uint16 _termInDays) external onlyOwner returns (bool) {\n    require(_termInDays != termInDays, \"No change to term\");\n    require(\n      _termInDays <= Constants.LOAN_TERM_MAX,\n      \"Change is more than max term\"\n    );\n    require(\n      _termInDays >= Constants.LOAN_TERM_MIN,\n      \"Change is less than min term\"\n    );\n    require(\n      _termInDays >= extensionHorizon,\n      \"Term must be greater than or equal to extension horizon\"\n    );\n    termInDays = _termInDays;\n    emit termInDaysSet(_termInDays);\n    return true;\n  }\n\n  // Set extension horizon in days:\n  function setExtensionHorizon(uint16 _extensionHorizon)\n    external\n    onlyOwner\n    returns (bool)\n  {\n    require(_extensionHorizon != extensionHorizon, \"No change to horizon\");\n    require(\n      _extensionHorizon <= Constants.LOAN_TERM_MAX,\n      \"Change is more than max term\"\n    );\n    require(\n      _extensionHorizon >= Constants.LOAN_TERM_MIN,\n      \"Change is less than min term\"\n    );\n    require(\n      _extensionHorizon <= termInDays,\n      \"Extension horizon must be less than or equal to term\"\n    );\n    extensionHorizon = _extensionHorizon;\n    emit extensionHorizonSet(_extensionHorizon);\n    return true;\n  }\n\n  /** -----------------------------------------------------------------------------\n   *   Contract routines - these do all the work:\n   *   -----------------------------------------------------------------------------\n   */\n  //Always returns `IERC721Receiver.onERC721Received.selector`. We need this to custody NFTs on the contract:\n  function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes memory\n  ) external virtual override returns (bytes4) {\n    return this.onERC721Received.selector;\n  }\n\n  // Allow contract to receive ETH:\n  receive() external payable {\n    require(msg.sender == owner(), \"Only owner can fund contract.\");\n    require(msg.value > 0, \"No ether was sent.\");\n    emit ethDeposited(msg.value, block.timestamp);\n  }\n\n  // The fallback function is executed on a call to the contract if\n  // none of the other functions match the given function signature.\n  fallback() external payable {\n    revert();\n  }\n\n  function getParameters()\n    external\n    view\n    returns (\n      address _tokenAddress,\n      uint32 _loanTerm,\n      uint128 _loanAmount,\n      uint128 _loanFee,\n      uint64 _extensionHorizon,\n      uint128 _extensionFee,\n      bool _isPaused,\n      bool _isSunset\n    )\n  {\n    return (\n      address(tokenContract),\n      termInDays,\n      loanAmount,\n      lendingFee,\n      extensionHorizon,\n      extensionFee,\n      paused(),\n      sunsetModeActive()\n    );\n  }\n\n  function getLoans() external view returns (LoanItem[] memory) {\n    return itemsUnderLoan;\n  }\n\n  function pause() public onlyOwner {\n    _pause();\n  }\n\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n\n  function sunset() external onlyOwner {\n    _sunset();\n  }\n\n  function sunrise() external onlyOwner {\n    _sunrise();\n  }\n\n  function extensionsAllowed() public view returns (bool) {\n    return (extensionFee > 0);\n  }\n\n  function isWithinExtensionHorizon(uint128 _loanId) public view returns (bool) {\n    return\n      (block.timestamp +\n      (extensionHorizon * Constants.SECONDS_TO_DAYS_FACTOR) >=\n      itemsUnderLoan[_loanId].endDate);\n  }\n\n  function isWithinLoanTerm(uint128 _loanId) public view returns (bool) {\n    return (block.timestamp <= itemsUnderLoan[_loanId].endDate);\n  }\n\n  // Ensure that the owner can withdraw deposited ETH:\n  function withdraw(uint256 _withdrawal) external onlyOwner returns (bool) {\n    (bool success, ) = msg.sender.call{value: _withdrawal}(\"\");\n    require(success, \"Transfer failed.\");\n    emit ethWithdrawn(_withdrawal, block.timestamp);\n    return true;\n  }\n\n  // This function is called to advance the borrower ETH in exchange for taking\n  // custody of the asset.\n  function takeLoan(uint16 tokenId) external whenNotPaused whenSun {\n    // The id is the length of the current array as this is the next item:\n    uint256 newItemId = itemsUnderLoan.length;\n    uint32 endDate = uint32(block.timestamp) +\n      (termInDays * Constants.SECONDS_TO_DAYS_FACTOR);\n    // Add this to the array:\n    itemsUnderLoan.push(\n      LoanItem(\n        uint128(newItemId),\n        loanAmount + lendingFee,\n        true,\n        payable(msg.sender),\n        uint32(block.timestamp),\n        endDate,\n        tokenId\n      )\n    );\n    // Custody the asset to this contract:\n    tokenContract.safeTransferFrom(msg.sender, address(this), tokenId);\n    // Send the borrower their ETH:\n    payable(msg.sender).transfer(loanAmount);\n    emit lendingTransaction(\n      uint128(newItemId),\n      Constants.TXNCODE_LOAN_ADVANCED,\n      msg.sender,\n      tokenId,\n      loanAmount,\n      lendingFee,\n      endDate,\n      block.timestamp\n    );\n  }\n\n  // This function is called when the borrower makes a payment. If the payment\n  // clears the balance of the loan this routine will also return the NFT to the\n  // borrower:\n  function makeLoanPayment(uint128 _loanId)\n    external\n    payable\n    IsUnderLoan(_loanId)\n    OnlyItemBorrower(_loanId)\n    LoanWithinLoanTerm(_loanId)\n    whenNotPaused\n  {\n    require(\n      msg.value <= itemsUnderLoan[_loanId].currentBalance,\n      \"Payment exceeds current balance\"\n    );\n    // Reduce the balance outstanding by the amount of ETH received:\n    itemsUnderLoan[_loanId].currentBalance -= uint128(msg.value);\n\n    // See if this payment means the loan is done and we can return the asset:\n    if (itemsUnderLoan[_loanId].currentBalance == 0) {\n      _closeLoan(_loanId, msg.sender);\n\n      emit lendingTransaction(\n        _loanId,\n        Constants.TXNCODE_ASSET_REDEEMED,\n        msg.sender,\n        itemsUnderLoan[_loanId].tokenId,\n        msg.value,\n        0,\n        itemsUnderLoan[_loanId].endDate,\n        block.timestamp\n      );\n    } else {\n      // Emit this payment event:\n      emit lendingTransaction(\n        _loanId,\n        Constants.TXNCODE_LOAN_PAYMENT_MADE,\n        msg.sender,\n        itemsUnderLoan[_loanId].tokenId,\n        msg.value,\n        0,\n        itemsUnderLoan[_loanId].endDate,\n        block.timestamp\n      );\n    }\n  }\n\n  // This function is called when the borrower extends a loan. The loan can be extended\n  // by the original term in days for payment of the extension fee (if allowed):\n  function extendLoan(uint128 _loanId)\n    external\n    payable\n    IsUnderLoan(_loanId)\n    OnlyItemBorrower(_loanId)\n    LoanWithinLoanTerm(_loanId)\n    LoanEligibleForExtension(_loanId)\n    whenNotPaused\n    whenSun\n  {\n    require(msg.value == extensionFee, \"Payment must equal the extension fee\");\n    // Extend the term, that's all we need to do\n    itemsUnderLoan[_loanId].endDate += (termInDays *\n      Constants.SECONDS_TO_DAYS_FACTOR);\n    // Emit the extension events:\n    emit lendingTransaction(\n      _loanId,\n      Constants.TXNCODE_ASSET_EXTENDED,\n      msg.sender,\n      itemsUnderLoan[_loanId].tokenId,\n      msg.value,\n      msg.value,\n      itemsUnderLoan[_loanId].endDate,\n      block.timestamp\n    );\n  }\n\n  // This function is called when an item is repossessed. This is ONLY possible when the\n  // loan has lapsed.\n  function repossessItem(uint128 _loanId) public IsUnderLoan(_loanId) {\n    require(\n      itemsUnderLoan[_loanId].endDate < block.timestamp,\n      \"Loan term has not yet elapsed\"\n    );\n\n    _closeLoan(_loanId, repoAddress);\n\n    emit lendingTransaction(\n      _loanId,\n      Constants.TXNCODE_ASSET_REPOSSESSED,\n      itemsUnderLoan[_loanId].borrower,\n      itemsUnderLoan[_loanId].tokenId,\n      itemsUnderLoan[_loanId].currentBalance,\n      0,\n      itemsUnderLoan[_loanId].endDate,\n      block.timestamp\n    );\n  }\n\n  // Repossess eligible items in batches:\n  function repossessItems(uint128[] calldata repoItems) external {\n    for (uint256 i = 0; i < repoItems.length; i++) {\n      repossessItem(repoItems[i]);\n    }\n  }\n\n  // Handle loan closure and asset transfer:\n  function _closeLoan(uint128 _closeLoanId, address _tokenTransferTo) internal {\n    itemsUnderLoan[_closeLoanId].isCurrent = false;\n    tokenContract.safeTransferFrom(\n      address(this),\n      _tokenTransferTo,\n      itemsUnderLoan[_closeLoanId].tokenId\n    );\n  }\n}\n"
6     },
7     "@openzeppelin/contracts/access/Ownable.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
9     },
10     "@openzeppelin/contracts/security/Pausable.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
12     },
13     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
15     },
16     "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
18     },
19     "contracts/Sunsetable.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an sunset\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenSun` and `whenMoon`, which can be applied to\n * the functions of your contract. Note that they will not be useable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Sunsetable is Context {\n    /**\n     * @dev Emitted when the sunset is triggered by `account`.\n     */\n    event Sunset(address account);\n\n    /**\n     * @dev Emitted when the sunrise is triggered by `account`.\n     */\n    event Sunrise(address account);\n\n    bool private _sunsetModeActive;\n\n    /**\n     * @dev Initializes the contract in sunrised state.\n     */\n    constructor() {\n        _sunsetModeActive = false;\n    }\n\n    /**\n     * @dev Returns true if the sun has set, and false otherwise.\n     */\n    function sunsetModeActive() public view virtual returns (bool) {\n        return _sunsetModeActive;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the sun is up.\n     *\n     * Requirements:\n     *\n     * - The contract must not be in sunset mode.\n     */\n    modifier whenSun() {\n        require(!sunsetModeActive(), \"Sunset: Sun has set on this contract\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the sun has set.\n     *\n     * Requirements:\n     *\n     * - The contract must be in sunset mode.\n     */\n    modifier whenMoon() {\n        require(sunsetModeActive(), \"Sunset: Sun has not set on this contract\");\n        _;\n    }\n\n    /**\n     * @dev Triggers sunset state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be in sunset already.\n     */\n    function _sunset() internal virtual whenSun {\n        _sunsetModeActive = true;\n        emit Sunset(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be in sunset mode.\n     */\n    function _sunrise() internal virtual whenMoon {\n        _sunsetModeActive = false;\n        emit Sunrise(_msgSender());\n    }\n}\n"
21     },
22     "contracts/Constants.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nlibrary Constants {\n    // Transaction events\n    uint256 constant TXNCODE_LOAN_ADVANCED = 1000;\n    uint256 constant TXNCODE_LOAN_PAYMENT_MADE = 2000;\n    uint256 constant TXNCODE_ASSET_REDEEMED = 3000;\n    uint256 constant TXNCODE_ASSET_EXTENDED = 4000;\n    uint256 constant TXNCODE_ASSET_REPOSSESSED = 5000;\n    uint32 constant SECONDS_TO_DAYS_FACTOR = 86400;\n    uint128 constant LOAN_AMOUNT_MAX_INCREMENT = 300000000000000000;\n    uint64 constant FEE_MAX_INCREMENT = 30000000000000000;\n    uint16 constant LOAN_TERM_MAX = 180;\n    uint16 constant LOAN_TERM_MIN = 14;\n}\n"
24     },
25     "@openzeppelin/contracts/utils/Context.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
27     },
28     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
30     }
31   },
32   "settings": {
33     "optimizer": {
34       "enabled": false,
35       "runs": 200
36     },
37     "outputSelection": {
38       "*": {
39         "*": [
40           "evm.bytecode",
41           "evm.deployedBytecode",
42           "devdoc",
43           "userdoc",
44           "metadata",
45           "abi"
46         ]
47       }
48     },
49     "libraries": {}
50   }
51 }}