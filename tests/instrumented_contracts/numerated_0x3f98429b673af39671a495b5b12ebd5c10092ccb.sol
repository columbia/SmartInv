1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/pool/PreMiningPool.sol": {
5       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\nimport \"../interface/IERC20.sol\";\r\nimport \"../interface/ILToken.sol\";\r\nimport \"../interface/IMigratablePool.sol\";\r\nimport \"../interface/IPreMiningPool.sol\";\r\nimport \"../utils/SafeERC20.sol\";\r\nimport \"../math/MixedSafeMathWithUnit.sol\";\r\nimport \"./MigratablePool.sol\";\r\n\r\n/**\r\n * @title Deri Protocol PreMining PerpetualPool Implementation\r\n */\r\ncontract PreMiningPool is IMigratablePool, IPreMiningPool, MigratablePool {\r\n\r\n    using MixedSafeMathWithUnit for uint256;\r\n    using MixedSafeMathWithUnit for int256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Trading symbol\r\n    string private _symbol;\r\n\r\n    // Base token contract, all settlements are done in base token\r\n    IERC20  private _bToken;\r\n    // Base token decimals\r\n    uint256 private _bDecimals;\r\n    // Liquidity provider token contract\r\n    ILToken private _lToken;\r\n\r\n    // Minimum amount requirement when add liquidity\r\n    uint256 private _minAddLiquidity;\r\n    // Redemption fee ratio when removing liquidity\r\n    uint256 private _redemptionFeeRatio;\r\n\r\n    // Total liquidity pool holds\r\n    uint256 private _liquidity;\r\n\r\n    bool private _mutex;\r\n    // Locker to prevent reentry\r\n    modifier _lock_() {\r\n        require(!_mutex, \"PerpetualPool: reentry\");\r\n        _mutex = true;\r\n        _;\r\n        _mutex = false;\r\n    }\r\n\r\n    /**\r\n     * @dev A dummy constructor, which deos not initialize any storage variables\r\n     * A template will be deployed with no initialization and real pool will be cloned\r\n     * from this template (same as create_forwarder_to mechanism in Vyper),\r\n     * and use `initialize` to initialize all storage variables\r\n     */\r\n    constructor () {}\r\n\r\n    /**\r\n     * @dev See {IPreMiningPool}.{initialize}\r\n     */\r\n    function initialize(\r\n        string memory symbol_,\r\n        address[2] calldata addresses_,\r\n        uint256[2] calldata parameters_\r\n    ) public override {\r\n        require(\r\n            bytes(_symbol).length == 0 && _controller == address(0),\r\n            \"PerpetualPool: already initialized\"\r\n        );\r\n\r\n        _controller = msg.sender;\r\n        _symbol = symbol_;\r\n\r\n        _bToken = IERC20(addresses_[0]);\r\n        _bDecimals = _bToken.decimals();\r\n        _lToken = ILToken(addresses_[1]);\r\n\r\n        _minAddLiquidity = parameters_[0];\r\n        _redemptionFeeRatio = parameters_[1];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IMigratablePool}.{approveMigration}\r\n     */\r\n    function approveMigration() public override _controller_ {\r\n        require(\r\n            _migrationTimestamp != 0 && block.timestamp >= _migrationTimestamp,\r\n            \"PerpetualPool: migrationTimestamp not met yet\"\r\n        );\r\n        // approve new pool to pull all base tokens from this pool\r\n        _bToken.safeApprove(_migrationDestination, uint256(-1));\r\n        // set lToken to new pool, after redirecting lToken to new pool,\r\n        // this pool will stop functioning\r\n        _lToken.setPool(_migrationDestination);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IMigratablePool}.{executeMigration}\r\n     */\r\n    function executeMigration(address source) public override _controller_ {\r\n        uint256 migrationTimestamp_ = IPreMiningPool(source).migrationTimestamp();\r\n        address migrationDestination_ = IPreMiningPool(source).migrationDestination();\r\n        require(\r\n            migrationTimestamp_ != 0 && block.timestamp >= migrationTimestamp_,\r\n            \"PerpetualPool: migrationTimestamp not met yet\"\r\n        );\r\n        require(\r\n            migrationDestination_ == address(this),\r\n            \"PerpetualPool: executeMigration to not destination pool\"\r\n        );\r\n\r\n        // migrate base token\r\n        _bToken.safeTransferFrom(source, address(this), _bToken.balanceOf(source));\r\n        // migrate state values\r\n        _liquidity = IPreMiningPool(source).getStateValues();\r\n\r\n        emit ExecuteMigration(_migrationTimestamp, source, address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev See {IPreMiningPool}.{symbol}\r\n     */\r\n    function symbol() public view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IPreMiningPool}.{getAddresses}\r\n     */\r\n    function getAddresses() public view override returns (\r\n        address bToken,\r\n        address lToken\r\n    ) {\r\n        return (\r\n            address(_bToken),\r\n            address(_lToken)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev See {IPreMiningPool}.{getParameters}\r\n     */\r\n    function getParameters() public view override returns (\r\n        uint256 minAddLiquidity,\r\n        uint256 redemptionFeeRatio\r\n    ) {\r\n        return (\r\n            _minAddLiquidity,\r\n            _redemptionFeeRatio\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev See {IPreMiningPool}.{getStateValues}\r\n     */\r\n    function getStateValues() public view override returns (\r\n        uint256 liquidity\r\n    ) {\r\n        return _liquidity;\r\n    }\r\n\r\n\r\n    //================================================================================\r\n    // Pool interactions\r\n    //================================================================================\r\n\r\n    /**\r\n     * @dev See {IPreMiningPool}.{addLiquidity}\r\n     */\r\n    function addLiquidity(uint256 bAmount) public override {\r\n        _addLiquidity(bAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IPreMiningPool}.{removeLiquidity}\r\n     */\r\n    function removeLiquidity(uint256 lShares) public override {\r\n        _removeLiquidity(lShares);\r\n    }\r\n\r\n    //================================================================================\r\n    // Critical Logic\r\n    //================================================================================\r\n\r\n    /**\r\n     * @dev Low level addLiquidity implementation\r\n     */\r\n    function _addLiquidity(uint256 bAmount) internal _lock_ {\r\n        require(\r\n            bAmount >= _minAddLiquidity,\r\n            \"PerpetualPool: add liquidity less than minimum requirement\"\r\n        );\r\n        require(\r\n            bAmount.reformat(_bDecimals) == bAmount,\r\n            \"PerpetualPool: _addLiquidity bAmount not valid\"\r\n        );\r\n\r\n        bAmount = _deflationCompatibleSafeTransferFrom(msg.sender, address(this), bAmount);\r\n\r\n        uint256 poolDynamicEquity = _liquidity;\r\n        uint256 totalSupply = _lToken.totalSupply();\r\n        uint256 lShares;\r\n        if (totalSupply == 0) {\r\n            lShares = bAmount;\r\n        } else {\r\n            lShares = bAmount.mul(totalSupply).div(poolDynamicEquity);\r\n        }\r\n\r\n        _lToken.mint(msg.sender, lShares);\r\n        _liquidity = _liquidity.add(bAmount);\r\n\r\n        emit AddLiquidity(msg.sender, lShares, bAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Low level removeLiquidity implementation\r\n     */\r\n    function _removeLiquidity(uint256 lShares) internal _lock_ {\r\n        require(lShares > 0, \"PerpetualPool: remove 0 liquidity\");\r\n        uint256 balance = _lToken.balanceOf(msg.sender);\r\n        require(\r\n            lShares == balance || balance.sub(lShares) >= 10**18,\r\n            \"PerpetualPool: remaining liquidity shares must be 0 or at least 1\"\r\n        );\r\n\r\n        uint256 poolDynamicEquity = _liquidity;\r\n        uint256 totalSupply = _lToken.totalSupply();\r\n        uint256 bAmount = lShares.mul(poolDynamicEquity).div(totalSupply);\r\n        if (lShares < totalSupply) {\r\n            bAmount = bAmount.sub(bAmount.mul(_redemptionFeeRatio));\r\n        }\r\n        bAmount = bAmount.reformat(_bDecimals);\r\n\r\n        _liquidity = _liquidity.sub(bAmount);\r\n\r\n        _lToken.burn(msg.sender, lShares);\r\n        _bToken.safeTransfer(msg.sender, bAmount.rescale(_bDecimals));\r\n\r\n        emit RemoveLiquidity(msg.sender, lShares, bAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev safeTransferFrom for base token with deflation protection\r\n     * Returns the actual received amount in base token (as base 10**18)\r\n     */\r\n    function _deflationCompatibleSafeTransferFrom(address from, address to, uint256 amount) internal returns (uint256) {\r\n        uint256 preBalance = _bToken.balanceOf(to);\r\n        _bToken.safeTransferFrom(from, to, amount.rescale(_bDecimals));\r\n        uint256 curBalance = _bToken.balanceOf(to);\r\n\r\n        uint256 a = curBalance.sub(preBalance);\r\n        uint256 b = 10**18;\r\n        uint256 c = a * b;\r\n        require(c / b == a, \"PreMiningPool: _deflationCompatibleSafeTransferFrom multiplication overflows\");\r\n\r\n        uint256 actualReceivedAmount = c / (10 ** _bDecimals);\r\n        return actualReceivedAmount;\r\n    }\r\n\r\n}\r\n"
6     },
7     "contracts/interface/IERC20.sol": {
8       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `amount` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /**\r\n     * @dev Emitted when `amount` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `amount` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the name.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the allowance mechanism.\r\n     * `amount` is then deducted from the caller's allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n\r\n}\r\n"
9     },
10     "contracts/interface/ILToken.sol": {
11       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\n/**\r\n * @title Deri Protocol liquidity provider token interface\r\n */\r\ninterface ILToken is IERC20 {\r\n\r\n    /**\r\n     * @dev Set the pool address of this LToken\r\n     * pool is the only controller of this contract\r\n     * can only be called by current pool\r\n     */\r\n    function setPool(address newPool) external;\r\n\r\n    /**\r\n     * @dev Returns address of pool\r\n     */\r\n    function pool() external view returns (address);\r\n\r\n    /**\r\n     * @dev Mint LToken to `account` of `amount`\r\n     *\r\n     * Can only be called by pool\r\n     * `account` cannot be zero address\r\n     */\r\n    function mint(address account, uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Burn `amount` LToken of `account`\r\n     *\r\n     * Can only be called by pool\r\n     * `account` cannot be zero address\r\n     * `account` must owns at least `amount` LToken\r\n     */\r\n    function burn(address account, uint256 amount) external;\r\n\r\n}\r\n"
12     },
13     "contracts/interface/IMigratablePool.sol": {
14       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Deri Protocol migratable pool interface\r\n */\r\ninterface IMigratablePool {\r\n\r\n    /**\r\n     * @dev Emitted when migration is prepared\r\n     * `source` pool will be migrated to `target` pool after `migrationTimestamp`\r\n     */\r\n    event PrepareMigration(uint256 migrationTimestamp, address source, address target);\r\n\r\n    /**\r\n     * @dev Emmited when migration is executed\r\n     * `source` pool is migrated to `target` pool\r\n     */\r\n    event ExecuteMigration(uint256 migrationTimestamp, address source, address target);\r\n\r\n    /**\r\n     * @dev Set controller to `newController`\r\n     *\r\n     * can only be called by current controller or the controller has not been set\r\n     */\r\n    function setController(address newController) external;\r\n\r\n    /**\r\n     * @dev Returns address of current controller\r\n     */\r\n    function controller() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the migrationTimestamp of this pool, zero means not set\r\n     */\r\n    function migrationTimestamp() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the destination pool this pool will migrate to after grace period\r\n     * zero address means not set\r\n     */\r\n    function migrationDestination() external view returns (address);\r\n\r\n    /**\r\n     * @dev Prepare a migration from this pool to `newPool` with `graceDays` as grace period\r\n     * `graceDays` must be at least 3 days from now, allow users to verify the `newPool` code\r\n     *\r\n     * can only be called by controller\r\n     */\r\n    function prepareMigration(address newPool, uint256 graceDays) external;\r\n\r\n    /**\r\n     * @dev Approve migration to `newPool` when grace period ends\r\n     * after approvement, current pool will stop functioning\r\n     *\r\n     * can only be called by controller\r\n     */\r\n    function approveMigration() external;\r\n\r\n    /**\r\n     * @dev Called from the `newPool` to migrate from `source` pool\r\n     * the grace period of `source` pool must ends\r\n     * current pool must be the destination pool set before grace period in the `source` pool\r\n     *\r\n     * can only be called by controller\r\n     */\r\n    function executeMigration(address source) external;\r\n\r\n}\r\n"
15     },
16     "contracts/interface/IPreMiningPool.sol": {
17       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\nimport \"./IMigratablePool.sol\";\r\n\r\n/**\r\n * @title Deri Protocol PreMining PerpetualPool Interface\r\n */\r\ninterface IPreMiningPool is IMigratablePool {\r\n\r\n    /**\r\n     * @dev Emitted when `owner` add liquidity of `bAmount`,\r\n     * and receive `lShares` liquidity token\r\n     */\r\n    event AddLiquidity(address indexed owner, uint256 lShares, uint256 bAmount);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` burn `lShares` of liquidity token,\r\n     * and receive `bAmount` in base token\r\n     */\r\n    event RemoveLiquidity(address indexed owner, uint256 lShares, uint256 bAmount);\r\n\r\n    /**\r\n     * @dev Initialize pool\r\n     *\r\n     * addresses:\r\n     *      bToken\r\n     *      lToken\r\n     *\r\n     * parameters:\r\n     *      minAddLiquidity\r\n     *      redemptionFeeRatio\r\n     */\r\n    function initialize(\r\n        string memory symbol_,\r\n        address[2] calldata addresses_,\r\n        uint256[2] calldata parameters_\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns trading symbol\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns addresses of (bToken, pToken, lToken, oracle) in this pool\r\n     */\r\n    function getAddresses() external view returns (\r\n        address bToken,\r\n        address lToken\r\n    );\r\n\r\n    /**\r\n     * @dev Returns parameters of this pool\r\n     */\r\n    function getParameters() external view returns (\r\n        uint256 minAddLiquidity,\r\n        uint256 redemptionFeeRatio\r\n    );\r\n\r\n    /**\r\n     * @dev Returns currents state values of this pool\r\n     */\r\n    function getStateValues() external view returns (\r\n        uint256 liquidity\r\n    );\r\n\r\n    /**\r\n     * @dev Add liquidity of `bAmount` in base token\r\n     *\r\n     * New liquidity provider token will be issued to the provider\r\n     */\r\n    function addLiquidity(uint256 bAmount) external;\r\n\r\n    /**\r\n     * @dev Remove `lShares` of liquidity provider token\r\n     *\r\n     * The liquidity provider token will be burned and\r\n     * the corresponding amount in base token will be sent to provider\r\n     */\r\n    function removeLiquidity(uint256 lShares) external;\r\n\r\n}\r\n"
18     },
19     "contracts/utils/SafeERC20.sol": {
20       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nimport \"../interface/IERC20.sol\";\r\nimport \"../math/UnsignedSafeMath.sol\";\r\nimport \"./Address.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using UnsignedSafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n"
21     },
22     "contracts/math/MixedSafeMathWithUnit.sol": {
23       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @title Mixed safe math with base unit of 10**18\r\n */\r\nlibrary MixedSafeMathWithUnit {\r\n\r\n    uint256 constant UONE = 10**18;\r\n    uint256 constant UMAX = 2**255 - 1;\r\n\r\n    int256 constant IONE = 10**18;\r\n    int256 constant IMIN = -2**255;\r\n\r\n    //================================================================================\r\n    // Conversions\r\n    //================================================================================\r\n\r\n    /**\r\n     * @dev Convert uint256 to int256\r\n     */\r\n    function utoi(uint256 a) internal pure returns (int256) {\r\n        require(a <= UMAX, \"MixedSafeMathWithUnit: convert uint256 to int256 overflow\");\r\n        int256 b = int256(a);\r\n        return b;\r\n    }\r\n\r\n    /**\r\n     * @dev Convert int256 to uint256\r\n     */\r\n    function itou(int256 a) internal pure returns (uint256) {\r\n        require(a >= 0, \"MixedSafeMathWithUnit: convert int256 to uint256 overflow\");\r\n        uint256 b = uint256(a);\r\n        return b;\r\n    }\r\n\r\n    /**\r\n     * @dev Take abs of int256\r\n     */\r\n    function abs(int256 a) internal pure returns (int256) {\r\n        require(a != IMIN, \"MixedSafeMathWithUnit: int256 abs overflow\");\r\n        if (a >= 0) {\r\n            return a;\r\n        } else {\r\n            return -a;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Take negation of int256\r\n     */\r\n    function neg(int256 a) internal pure returns (int256) {\r\n        require(a != IMIN, \"MixedSafeMathWithUnit: int256 negate overflow\");\r\n        return -a;\r\n    }\r\n\r\n    //================================================================================\r\n    // Rescale and reformat\r\n    //================================================================================\r\n\r\n    function _rescale(uint256 a, uint256 decimals1, uint256 decimals2)\r\n        internal pure returns (uint256)\r\n    {\r\n        uint256 scale1 = 10 ** decimals1;\r\n        uint256 scale2 = 10 ** decimals2;\r\n        uint256 b = a * scale2;\r\n        require(b / scale2 == a, \"MixedSafeMathWithUnit: rescale uint256 overflow\");\r\n        uint256 c = b / scale1;\r\n        return c;\r\n    }\r\n\r\n    function _rescale(int256 a, uint256 decimals1, uint256 decimals2)\r\n        internal pure returns (int256)\r\n    {\r\n        int256 scale1 = utoi(10 ** decimals1);\r\n        int256 scale2 = utoi(10 ** decimals2);\r\n        int256 b = a * scale2;\r\n        require(b / scale2 == a, \"MixedSafeMathWithUnit: rescale int256 overflow\");\r\n        int256 c = b / scale1;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Rescales a value from 10**18 base to 10**decimals base\r\n     */\r\n    function rescale(uint256 a, uint256 decimals) internal pure returns (uint256) {\r\n        return _rescale(a, 18, decimals);\r\n    }\r\n\r\n    function rescale(int256 a, uint256 decimals) internal pure returns (int256) {\r\n        return _rescale(a, 18, decimals);\r\n    }\r\n\r\n    /**\r\n     * @dev Reformat a value to be a valid 10**decimals base value\r\n     * The formatted value is still in 10**18 base\r\n     */\r\n    function reformat(uint256 a, uint256 decimals) internal pure returns (uint256) {\r\n        return _rescale(_rescale(a, 18, decimals), decimals, 18);\r\n    }\r\n\r\n    function reformat(int256 a, uint256 decimals) internal pure returns (int256) {\r\n        return _rescale(_rescale(a, 18, decimals), decimals, 18);\r\n    }\r\n\r\n\r\n    //================================================================================\r\n    // Addition\r\n    //================================================================================\r\n\r\n    /**\r\n     * @dev Addition: uint256 + uint256\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"MixedSafeMathWithUnit: uint256 addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Addition: int256 + int256\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require(\r\n            (b >= 0 && c >= a) || (b < 0 && c < a),\r\n            \"MixedSafeMathWithUnit: int256 addition overflow\"\r\n        );\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Addition: uint256 + int256\r\n     * uint256(-b) will not overflow when b is IMIN\r\n     */\r\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\r\n        if (b >= 0) {\r\n            return add(a, uint256(b));\r\n        } else {\r\n            return sub(a, uint256(-b));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Addition: int256 + uint256\r\n     */\r\n    function add(int256 a, uint256 b) internal pure returns (int256) {\r\n        return add(a, utoi(b));\r\n    }\r\n\r\n    //================================================================================\r\n    // Subtraction\r\n    //================================================================================\r\n\r\n    /**\r\n     * @dev Subtraction: uint256 - uint256\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(a >= b, \"MixedSafeMathWithUnit: uint256 subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtraction: int256 - int256\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require(\r\n            (b >= 0 && c <= a) || (b < 0 && c > a),\r\n            \"MixedSafeMathWithUnit: int256 subtraction overflow\"\r\n        );\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtraction: uint256 - int256\r\n     * uint256(-b) will not overflow when b is IMIN\r\n     */\r\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\r\n        if (b >= 0) {\r\n            return sub(a, uint256(b));\r\n        } else {\r\n            return add(a, uint256(-b));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Subtraction: int256 - uint256\r\n     */\r\n    function sub(int256 a, uint256 b) internal pure returns (int256) {\r\n        return sub(a, utoi(b));\r\n    }\r\n\r\n    //================================================================================\r\n    // Multiplication\r\n    //================================================================================\r\n\r\n    /**\r\n     * @dev Multiplication: uint256 * uint256\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero,\r\n        // but the benefit is lost if 'b' is also tested\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MixedSafeMathWithUnit: uint256 multiplication overflow\");\r\n        return c / UONE;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplication: int256 * int256\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero,\r\n        // but the benefit is lost if 'b' is also tested\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        require(!(a == -1 && b == IMIN), \"MixedSafeMathWithUnit: int256 multiplication overflow\");\r\n        int256 c = a * b;\r\n        require(c / a == b, \"MixedSafeMathWithUnit: int256 multiplication overflow\");\r\n        return c / IONE;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplication: uint256 * int256\r\n     */\r\n    function mul(uint256 a, int256 b) internal pure returns (uint256) {\r\n        return mul(a, itou(b));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplication: int256 * uint256\r\n     */\r\n    function mul(int256 a, uint256 b) internal pure returns (int256) {\r\n        return mul(a, utoi(b));\r\n    }\r\n\r\n    //================================================================================\r\n    // Division\r\n    //================================================================================\r\n\r\n    /**\r\n     * @dev Division: uint256 / uint256\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"MixedSafeMathWithUnit: uint256 division by zero\");\r\n        uint256 c = a * UONE;\r\n        require(\r\n            c / UONE == a,\r\n            \"MixedSafeMathWithUnit: uint256 division internal multiplication overflow\"\r\n        );\r\n        uint256 d = c / b;\r\n        return d;\r\n    }\r\n\r\n    /**\r\n     * @dev Division: int256 / int256\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"MixedSafeMathWithUnit: int256 division by zero\");\r\n        int256 c = a * IONE;\r\n        require(\r\n            c / IONE == a,\r\n            \"MixedSafeMathWithUnit: int256 division internal multiplication overflow\"\r\n        );\r\n        require(!(c == IMIN && b == -1), \"MixedSafeMathWithUnit: int256 division overflow\");\r\n        int256 d = c / b;\r\n        return d;\r\n    }\r\n\r\n    /**\r\n     * @dev Division: uint256 / int256\r\n     */\r\n    function div(uint256 a, int256 b) internal pure returns (uint256) {\r\n        return div(a, itou(b));\r\n    }\r\n\r\n    /**\r\n     * @dev Division: int256 / uint256\r\n     */\r\n    function div(int256 a, uint256 b) internal pure returns (int256) {\r\n        return div(a, utoi(b));\r\n    }\r\n\r\n}\r\n"
24     },
25     "contracts/pool/MigratablePool.sol": {
26       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nimport \"../interface/IMigratablePool.sol\";\r\n\r\n/**\r\n * @dev Deri Protocol migratable pool implementation\r\n */\r\nabstract contract MigratablePool is IMigratablePool {\r\n\r\n    // Controller address\r\n    address _controller;\r\n\r\n    // Migration timestamp of this pool, zero means not set\r\n    // Migration timestamp can only be set with a grace period at least 3 days, and the\r\n    // `migrationDestination` pool address must be also set when setting migration timestamp,\r\n    // users can use this grace period to verify the `migrationDestination` pool code\r\n    uint256 _migrationTimestamp;\r\n\r\n    // The new pool this pool will migrate to after grace period, zero address means not set\r\n    address _migrationDestination;\r\n\r\n    modifier _controller_() {\r\n        require(msg.sender == _controller, \"can only be called by current controller\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IMigratablePool}.{setController}\r\n     */\r\n    function setController(address newController) public override {\r\n        require(newController != address(0), \"MigratablePool: setController to 0 address\");\r\n        require(\r\n            _controller == address(0) || msg.sender == _controller,\r\n            \"MigratablePool: setController can only be called by current controller or not set\"\r\n        );\r\n        _controller = newController;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IMigratablePool}.{controller}\r\n     */\r\n    function controller() public view override returns (address) {\r\n        return _controller;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IMigratablePool}.{migrationTimestamp}\r\n     */\r\n    function migrationTimestamp() public view override returns (uint256) {\r\n        return _migrationTimestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IMigratablePool}.{migrationDestination}\r\n     */\r\n    function migrationDestination() public view override returns (address) {\r\n        return _migrationDestination;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IMigratablePool}.{prepareMigration}\r\n     */\r\n    function prepareMigration(address newPool, uint256 graceDays) public override _controller_ {\r\n        require(newPool != address(0), \"MigratablePool: prepareMigration to 0 address\");\r\n        require(graceDays >= 3 && graceDays <= 365, \"MigratablePool: graceDays must be 3-365 days\");\r\n\r\n        _migrationTimestamp = block.timestamp + graceDays * 1 days;\r\n        _migrationDestination = newPool;\r\n\r\n        emit PrepareMigration(_migrationTimestamp, address(this), _migrationDestination);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IMigratablePool}.{approveMigration}\r\n     *\r\n     * This function will be implemented in inheriting contract\r\n     * This function will change if there is an upgrade to existent pool\r\n     */\r\n    // function approveMigration() public virtual override _controller_ {}\r\n\r\n    /**\r\n     * @dev See {IMigratablePool}.{executeMigration}\r\n     *\r\n     * This function will be implemented in inheriting contract\r\n     * This function will change if there is an upgrade to existent pool\r\n     */\r\n    // function executeMigration(address source) public virtual override _controller_ {}\r\n\r\n}\r\n"
27     },
28     "contracts/math/UnsignedSafeMath.sol": {
29       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @title Unsigned safe math\r\n */\r\nlibrary UnsignedSafeMath {\r\n\r\n    /**\r\n     * @dev Addition of unsigned integers, counterpart to `+`\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"UnsignedSafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtraction of unsigned integers, counterpart to `-`\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(a >= b, \"UnsignedSafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplication of unsigned integers, counterpart to `*`\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero,\r\n        // but the benefit is lost if 'b' is also tested\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"UnsignedSafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Division of unsigned integers, counterpart to `/`\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"UnsignedSafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Modulo of unsigned integers, counterpart to `%`\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"UnsignedSafeMath: modulo by zero\");\r\n        uint256 c = a % b;\r\n        return c;\r\n    }\r\n\r\n}\r\n"
30     },
31     "contracts/utils/Address.sol": {
32       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
33     }
34   },
35   "settings": {
36     "optimizer": {
37       "enabled": true,
38       "runs": 200
39     },
40     "outputSelection": {
41       "*": {
42         "*": [
43           "evm.bytecode",
44           "evm.deployedBytecode",
45           "abi"
46         ]
47       }
48     },
49     "libraries": {}
50   }
51 }}