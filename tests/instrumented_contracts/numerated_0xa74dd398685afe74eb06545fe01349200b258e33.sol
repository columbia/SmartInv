1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/controller/GameController.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../bloodbag/IBLOODBAG.sol\";\nimport \"../staking/ILair.sol\";\nimport \"../staking/IBloodFarm.sol\";\nimport \"../random/Random.sol\";\n\nimport \"../IVampireGameERC721.sol\";\n\ncontract GameController is ReentrancyGuard, Ownable, Pausable {\n    /// @notice the tax vampires charge in percentage (20%)\n    uint256 public constant BLOOD_CLAIM_TAX_PERCENTAGE = 20;\n\n    /// @notice amount of blood distributed when no vampires are staked\n    uint256 public unaccountedRewards = 0;\n\n    // Other contracts this caontract controls\n    IVampireGameERC721 public vgame;\n    IBLOODBAG public bloodbag;\n    ILair public lair;\n    IBloodFarm public bloodfarm;\n    IRandom public random;\n\n    /// ==== Constructor\n\n    constructor(\n        address _vgame,\n        address _bloodbag,\n        address _lair,\n        address _bloodfarm,\n        address _random\n    ) {\n        vgame = IVampireGameERC721(_vgame);\n        bloodbag = IBLOODBAG(_bloodbag);\n        lair = ILair(_lair);\n        bloodfarm = IBloodFarm(_bloodfarm);\n        random = IRandom(_random);\n    }\n\n    /// ==== Mixed Controls\n\n    /// @notice stake many vampire and human tokens\n    /// @param tokenIds the ids of tokens to be staked. The caller should own the tokens\n    function stakeManyTokens(uint16[] calldata tokenIds)\n        external\n        whenNotPaused\n        nonReentrant\n    {\n        IVampireGameERC721 vgameRef = vgame;\n        IBloodFarm bloodfarmRef = bloodfarm;\n        address sender = _msgSender();\n        for (uint16 i = 0; i < tokenIds.length; i++) {\n            uint16 tokenId = tokenIds[i];\n            require(vgameRef.isTokenRevealed(tokenId), \"NO_STAKING_COFFINS\");\n            if (_isVampire(vgameRef, tokenId)) {\n                _stakeVampire(vgameRef, lair, sender, tokenId);\n            } else {\n                _stakeHuman(vgameRef, bloodfarmRef, sender, tokenId);\n            }\n        }\n    }\n\n    /// @notice unstake many tokens.\n    /// - Vampires can be staked at any time\n    /// - Humans need to have a unstake request first\n    function unstakeManyTokens(\n        uint16[] calldata requestToUnstakeIds,\n        uint16[] calldata unstakeHumanIds,\n        uint16[] calldata unstakeVampireIds\n    ) external whenNotPaused nonReentrant {\n        uint256 totalOwed = 0;\n        uint256 totalTax = 0;\n        IVampireGameERC721 vgameRef = vgame;\n        IBloodFarm bloodfarmRef = bloodfarm;\n        ILair lairRef = lair;\n        address sender = _msgSender();\n\n        for (uint16 i = 0; i < unstakeHumanIds.length; i++) {\n            uint16 tokenId = unstakeHumanIds[i];\n            (uint256 owed, uint256 tax) = _unstakeHuman(\n                vgameRef,\n                bloodfarmRef,\n                sender,\n                tokenId\n            );\n            totalOwed += owed;\n            totalTax += tax;\n        }\n\n        for (uint16 i = 0; i < requestToUnstakeIds.length; i++) {\n            _requestToUnstakeHuman(\n                bloodfarmRef,\n                sender,\n                requestToUnstakeIds[i]\n            );\n        }\n\n        if (totalTax != 0) {\n            _addVampireTax(lairRef, totalTax);\n        }\n\n        for (uint16 i = 0; i < unstakeVampireIds.length; i++) {\n            totalOwed += _unstakeVampire(\n                vgameRef,\n                lairRef,\n                sender,\n                unstakeVampireIds[i]\n            );\n        }\n\n        if (totalOwed != 0) {\n            bloodbag.mint(sender, totalOwed);\n        }\n    }\n\n    /// @notice claim blood bags\n    /// @dev checks of ownersgip performed in Lair and BloodFarm\n    /// @param humans humans tokenIds\n    /// @param vampires vampires tokenIds\n    function claimBloodBags(\n        uint16[] calldata humans,\n        uint16[] calldata vampires\n    )\n        external\n        whenNotPaused\n        nonReentrant\n    {\n        uint256 owed = 0;\n        uint256 tax = 0;\n        address sender = _msgSender();\n        ILair lairRef = lair;\n        IBloodFarm bloodfarmRef = bloodfarm;\n\n        for (uint16 i = 0; i < humans.length; i++) {\n            uint256 _owed = bloodfarmRef.claimBloodBags(sender, humans[i]);\n            uint256 _tax = (_owed * BLOOD_CLAIM_TAX_PERCENTAGE) / 100;\n            tax += _tax;\n            owed += _owed - _tax;\n        }\n\n        if (tax != 0) {\n            _addVampireTax(lairRef, tax);\n        }\n\n        for (uint16 i = 0; i < vampires.length; i++) {\n            owed += lairRef.claimBloodBags(sender, vampires[i]);\n        }\n\n        bloodbag.mint(sender, owed);\n    }\n\n    /// ==== Human Controls\n\n    function _stakeHuman(\n        IVampireGameERC721 vgameRef,\n        IBloodFarm bloodfarmRef,\n        address sender,\n        uint16 tokenId\n    ) private {\n        bloodfarmRef.stakeHuman(sender, tokenId);\n        vgameRef.transferFrom(sender, address(bloodfarmRef), tokenId);\n    }\n\n    function _requestToUnstakeHuman(\n        IBloodFarm bloodfarmRef,\n        address sender,\n        uint16 tokenId\n    ) private {\n        bloodfarmRef.requestToUnstakeHuman(sender, tokenId);\n        random.submitHash(sender, tokenId);\n    }\n\n    function _unstakeHuman(\n        IVampireGameERC721 vgameRef,\n        IBloodFarm bloodfarmRef,\n        address sender,\n        uint16 tokenId\n    ) private returns (uint256 owed, uint256 tax) {\n        require(!_isVampire(vgameRef, tokenId), \"NOT_HUMAN\");\n        uint256 _owed = bloodfarmRef.unstakeHuman(sender, tokenId);\n\n        // Check if stolen\n        if (random.getRandomNumber(tokenId) & 1 == 1) {\n            tax += _owed;\n        } else {\n            tax += (_owed * BLOOD_CLAIM_TAX_PERCENTAGE) / 100;\n            owed += (_owed * (100 - BLOOD_CLAIM_TAX_PERCENTAGE)) / 100;\n        }\n\n        vgameRef.transferFrom(address(bloodfarmRef), sender, tokenId);\n    }\n\n    /// ==== Vampire Controls\n\n    /// @dev Stake one vapmire\n    /// - Calls Lair to update staking state (stake)\n    /// - Transfer the NFT from sender to the Lair\n    ///\n    /// - Ownership only checked here\n    function _stakeVampire(\n        IVampireGameERC721 vgameRef,\n        ILair lairRef,\n        address sender,\n        uint16 tokenId\n    ) private {\n        require(vgameRef.ownerOf(tokenId) == sender, \"NOT_VAMPIRE_OWNER\");\n        lairRef.stakeVampire(sender, tokenId);\n        vgameRef.transferFrom(sender, address(lairRef), tokenId);\n    }\n\n    /// @dev Unstake one vampire\n    ///\n    /// - Calls Lair to update staking state (unstake)\n    /// - Transfer the NFT from Lair to sender\n    ///\n    /// - Ownership is checked in Lair\n    function _unstakeVampire(\n        IVampireGameERC721 vgameRef,\n        ILair lairRef,\n        address sender,\n        uint16 tokenId\n    ) private returns (uint256 owed) {\n        require(_isVampire(vgameRef, tokenId), \"NOT_VAMPIRE\");\n        owed += lairRef.unstakeVampire(sender, tokenId);\n        vgameRef.transferFrom(address(lairRef), sender, tokenId);\n    }\n\n    /// ==== Helpers\n\n    function _addVampireTax(ILair lairRef, uint256 amount) private {\n        uint256 totalPredatorScoreStaked = lairRef\n            .getTotalPredatorScoreStaked();\n        uint256 _unaccountedRewards = unaccountedRewards;\n\n        if (totalPredatorScoreStaked == 0) {\n            _unaccountedRewards += amount;\n            return;\n        }\n\n        lairRef.addTaxToVampires(amount, _unaccountedRewards);\n        unaccountedRewards = 0;\n    }\n\n    function _isVampire(IVampireGameERC721 vgameRef, uint16 tokenId)\n        private\n        view\n        returns (bool)\n    {\n        return vgameRef.isTokenVampire(tokenId);\n    }\n\n    /// ==== pause/unpause\n\n    function upause() external onlyOwner {\n        _unpause();\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// ==== Update Parts\n\n    function setVgame(address _vgame) external onlyOwner {\n        vgame = IVampireGameERC721(_vgame);\n    }\n\n    function setBloodBag(address _bloodbag) external onlyOwner {\n        bloodbag = IBLOODBAG(_bloodbag);\n    }\n\n    function setLair(address _lair) external onlyOwner {\n        lair = ILair(_lair);\n    }\n\n    function setBloodFarm(address _bloodfarm) external onlyOwner {\n        bloodfarm = IBloodFarm(_bloodfarm);\n    }\n\n    function setRandom(address _random) external onlyOwner {\n        random = IRandom(_random);\n    }\n}\n"
6     },
7     "@openzeppelin/contracts/access/Ownable.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
9     },
10     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
12     },
13     "@openzeppelin/contracts/security/Pausable.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
15     },
16     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
18     },
19     "contracts/bloodbag/IBLOODBAG.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.6;\n\n/// @notice functions that can be called by a game controller\ninterface IBLOODBAG {\n    /// @notice make a $BLOODBAG transfusion from the gods to a specified address\n    /// @param to the addres getting the $BLOODBAG\n    /// @param amount the amount of $BLOODBAG to mint\n    function mint(address to, uint256 amount) external;\n\n    /// @notice flush some $BLOODBAG down the toilet (burn)\n    /// @param from the holder of the $BLOODBAG\n    /// @param amount the amount of $BLOODBAG to burn\n    function burn(address from, uint256 amount) external;\n}\n"
21     },
22     "contracts/staking/ILair.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.6;\n\n\ninterface ILair {\n    /// @notice returns the totalPredatorScoreStaked property\n    function getTotalPredatorScoreStaked() external view returns (uint24);\n\n    /// @notice returns the totalPredatorScoreStaked property\n    function getBloodbagPerPredatorScore() external view returns (uint256);\n\n    function ownerOf(uint16 tokenId, uint8 predatorIndex) external view returns (address);\n\n    /// @notice Stake one vampire\n    ///\n    /// What this does:\n    ///\n    /// - Update the state of the vault to contain the Vampire that the user wants to stake\n    ///\n    /// What the controller should do after this function returns:\n    ///\n    /// - Before calling this: Controller should check if the address implements onReceiveERC721.\n    /// - Then call transferFrom(_msgSender(), LAIR_ADDRESS, tokenId)\n    ///\n    /// Note: This is only called by controller, and the sender should be `_msgSender()`\n    ///\n    /// @param sender address of who's making this request, should be the vampire owner\n    /// @param tokenId ids of each vampire to stake\n    function stakeVampire(address sender, uint16 tokenId) external;\n\n    /// @notice update the vault state to as the owed amont fo the vampire was removed\n    ///\n    /// What this does:\n    ///\n    /// - Calculate and return the current amount owed to a vampire\n    /// - Reset the vampire stake info to as if they were staked now\n    ///\n    /// What the controller should do after this function returns:\n    ///\n    /// - Transfer the `owed` amount of $BLOODBAGs to `sender`.\n    ///\n    /// Note: This is only called by controller, and the sender should be `_msgSender()`\n    /// Note: We set all state first, and the do the transfers to avoid reentrancy\n    ///\n    /// @param sender address of who's making this request, should be the vampire owner\n    /// @param tokenId id of the vampire\n    /// @return owed amount of $BLOODBAGs owed to the vampire\n    function claimBloodBags(address sender, uint16 tokenId)\n        external\n        returns (uint256 owed);\n\n    /// @notice update the vault state to as the owed amont fo the vampire was removed\n    /// and the vampire was unstaked.\n    ///\n    /// What this does:\n    ///\n    /// - Calculate and return the current amount owed to a vampire\n    /// - Deletes the vampire info from staking structures\n    /// - Moves the last vampire staked to the current position of this vampire\n    ///\n    /// What the controller should do after this function returns:\n    ///\n    /// - Transfer the `owed` amount of $BLOODBAGs to `sender`.\n    /// - Transfer the NFT from this contract to `sender`\n    ///\n    /// Note: This is only called by controller, and the sender should be `_msgSender()`\n    /// Note: We set all state first, and the do the transfers to avoid reentrancy\n    ///\n    /// @param sender address of who's making this request, should be the vampire owner\n    /// @param tokenId id of the vampire\n    /// @return owed amount of $BLOODBAGs owed to the vampire\n    function unstakeVampire(address sender, uint16 tokenId)\n        external\n        returns (uint256 owed);\n\n    function addTaxToVampires(uint256 amount, uint256 unaccountedRewards) external;\n}"
24     },
25     "contracts/staking/IBloodFarm.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.6;\n\n/// @notice functions that can be called by a game controller\ninterface IBloodFarm {\n    function stakeHuman(address owner, uint16 tokenId) external;\n\n    function claimBloodBags(address sender, uint16 tokenId)\n        external\n        returns (uint256 owed);\n\n    function requestToUnstakeHuman(address sender, uint16 tokenId) external;\n\n    function unstakeHuman(\n        address sender,\n        uint16 tokenId\n    ) external returns (uint256 owed);\n\n    function isStaked(uint16 tokenId) external view returns (bool);\n\n    function hasRequestedToUnstake(uint16 tokenId) external view returns (bool);\n\n    function ownerOf(uint16 tokenId) external view returns (address);\n}\n"
27     },
28     "contracts/random/Random.sol": {
29       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./IRandom.sol\";\n\ncontract Random is IRandom, Ownable {\n    mapping(uint256 => bytes32) private hashes;\n    mapping(uint256 => uint256) private nonces;\n\n    mapping(address => bool) public controllers;\n\n    modifier onlyControllers() {\n        require(controllers[_msgSender()], \"ONLY_CONTROLLERS_ALLOWED\");\n        _;\n    }\n\n    constructor() {}\n\n    function submitHash(address sender, uint256 tokenId)\n        external\n        override\n        onlyControllers\n    {\n        require(hashes[tokenId].length == 0, \"ALREADY_SUBMITED\");\n        bytes32 newHash = keccak256(\n            abi.encodePacked(\n                sender,\n                tokenId,\n                nonces[tokenId],\n                \"bb\",\n                gasleft(),\n                blockhash(block.number - 1),\n                block.timestamp\n            )\n        );\n        hashes[tokenId] = newHash;\n        nonces[tokenId] += 1;\n    }\n\n    function getRandomNumber(uint256 tokenId)\n        external\n        override\n        onlyControllers\n        returns (uint256)\n    {\n        bytes32 _hash = hashes[tokenId];\n        require(_hash.length > 0, \"NO_HASH\");\n        delete hashes[tokenId];\n        return uint256(_hash);\n    }\n\n    /// @notice add a controller that will be able to call functions in this contract\n    /// @param controller the address that will be authorized\n    function addController(address controller) external onlyOwner {\n        controllers[controller] = true;\n    }\n\n    /// @notice remove a controller so it won't be able to call functions in this contract anymore\n    /// @param controller the address that will be unauthorized\n    function removeController(address controller) external onlyOwner {\n        controllers[controller] = false;\n    }\n}\n"
30     },
31     "contracts/IVampireGameERC721.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"./IVampireGame.sol\";\n\n/// @notice Interface composed by IVampireGame + IERC721\ninterface IVampireGameERC721 is IVampireGame, IERC721 {}"
33     },
34     "@openzeppelin/contracts/utils/Context.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
36     },
37     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
39     },
40     "contracts/random/IRandom.sol": {
41       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.6;\n\ninterface IRandom {\n  function submitHash(address sender, uint256 tokenId) external;\n  function getRandomNumber(uint256 tokenId) external returns (uint256);\n}\n"
42     },
43     "contracts/IVampireGame.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.6;\n\nimport \"./traits/TokenTraits.sol\";\n\n/// @notice Interface to interact with the VampireGame contract\ninterface IVampireGame {\n    /// @notice get the amount of tokens minted\n    function getTotalSupply() external view returns (uint16);\n\n    /// @notice get tthe amount of og supply\n    function getOGSupply() external view returns (uint16);\n\n    /// @notice get the total supply of gen-0\n    function getGenZeroSupply() external view returns (uint16);\n\n    /// @notice get the total supply of tokens\n    function getMaxSupply() external view returns (uint16);\n\n    /// @notice get the TokenTraits for a given tokenId\n    function getTokenTraits(uint16 tokenId) external view returns (TokenTraits memory);\n\n    /// @notice check if token id a vampire\n    function isTokenVampire(uint16 tokenId) external view returns (bool);\n\n    /// @notice get the Predator Index for a given tokenId\n    function getPredatorIndex(uint16 tokenId) external view returns (uint8);\n\n    /// @notice returns true if a token is aleady revealed\n    function isTokenRevealed(uint16 tokenId) external view returns (bool);\n}\n\n/// @notice Interface to control parts of the VampireGame ERC 721\ninterface IVampireGameControls {\n    /// @notice mint any amount of nft to any address\n    /// Requirements:\n    /// - message sender should be an allowed address (game contract)\n    /// - amount + totalSupply() has to be smaller than MAX_SUPPLY\n    function mintFromController(address receiver, uint16 amount) external;\n\n    /// @notice reveal a list of tokens using specific seeds for each\n    function controllerRevealTokens(uint16[] calldata tokenIds, uint256[] calldata seeds) external;\n}\n"
45     },
46     "contracts/traits/TokenTraits.sol": {
47       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.6;\n\nstruct TokenTraits {\n    bool isVampire;\n    // Shared Traits\n    uint8 skin;\n    uint8 face;\n    uint8 clothes;\n    // Human-only Traits\n    uint8 pants;\n    uint8 boots;\n    uint8 accessory;\n    uint8 hair;\n    // Vampire-only Traits\n    uint8 cape;\n    uint8 predatorIndex;\n}"
48     }
49   },
50   "settings": {
51     "optimizer": {
52       "enabled": true,
53       "runs": 200
54     },
55     "outputSelection": {
56       "*": {
57         "*": [
58           "evm.bytecode",
59           "evm.deployedBytecode",
60           "devdoc",
61           "userdoc",
62           "metadata",
63           "abi"
64         ]
65       }
66     },
67     "libraries": {}
68   }
69 }}