1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "istanbul",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "enabled": true,
12       "runs": 200
13     },
14     "remappings": [],
15     "outputSelection": {
16       "*": {
17         "*": [
18           "evm.bytecode",
19           "evm.deployedBytecode",
20           "abi"
21         ]
22       }
23     }
24   },
25   "sources": {
26     "@cartesi/util/contracts/CartesiMath.sol": {
27       "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title CartesiMath\n/// @author Felipe Argento\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nabstract contract CartesiMath {\n    using SafeMath for uint256;\n    mapping(uint256 => uint256) log2tableTimes1M;\n\n    constructor() {\n        log2tableTimes1M[1] = 0;\n        log2tableTimes1M[2] = 1000000;\n        log2tableTimes1M[3] = 1584962;\n        log2tableTimes1M[4] = 2000000;\n        log2tableTimes1M[5] = 2321928;\n        log2tableTimes1M[6] = 2584962;\n        log2tableTimes1M[7] = 2807354;\n        log2tableTimes1M[8] = 3000000;\n        log2tableTimes1M[9] = 3169925;\n        log2tableTimes1M[10] = 3321928;\n        log2tableTimes1M[11] = 3459431;\n        log2tableTimes1M[12] = 3584962;\n        log2tableTimes1M[13] = 3700439;\n        log2tableTimes1M[14] = 3807354;\n        log2tableTimes1M[15] = 3906890;\n        log2tableTimes1M[16] = 4000000;\n        log2tableTimes1M[17] = 4087462;\n        log2tableTimes1M[18] = 4169925;\n        log2tableTimes1M[19] = 4247927;\n        log2tableTimes1M[20] = 4321928;\n        log2tableTimes1M[21] = 4392317;\n        log2tableTimes1M[22] = 4459431;\n        log2tableTimes1M[23] = 4523561;\n        log2tableTimes1M[24] = 4584962;\n        log2tableTimes1M[25] = 4643856;\n        log2tableTimes1M[26] = 4700439;\n        log2tableTimes1M[27] = 4754887;\n        log2tableTimes1M[28] = 4807354;\n        log2tableTimes1M[29] = 4857980;\n        log2tableTimes1M[30] = 4906890;\n        log2tableTimes1M[31] = 4954196;\n        log2tableTimes1M[32] = 5000000;\n        log2tableTimes1M[33] = 5044394;\n        log2tableTimes1M[34] = 5087462;\n        log2tableTimes1M[35] = 5129283;\n        log2tableTimes1M[36] = 5169925;\n        log2tableTimes1M[37] = 5209453;\n        log2tableTimes1M[38] = 5247927;\n        log2tableTimes1M[39] = 5285402;\n        log2tableTimes1M[40] = 5321928;\n        log2tableTimes1M[41] = 5357552;\n        log2tableTimes1M[42] = 5392317;\n        log2tableTimes1M[43] = 5426264;\n        log2tableTimes1M[44] = 5459431;\n        log2tableTimes1M[45] = 5491853;\n        log2tableTimes1M[46] = 5523561;\n        log2tableTimes1M[47] = 5554588;\n        log2tableTimes1M[48] = 5584962;\n        log2tableTimes1M[49] = 5614709;\n        log2tableTimes1M[50] = 5643856;\n        log2tableTimes1M[51] = 5672425;\n        log2tableTimes1M[52] = 5700439;\n        log2tableTimes1M[53] = 5727920;\n        log2tableTimes1M[54] = 5754887;\n        log2tableTimes1M[55] = 5781359;\n        log2tableTimes1M[56] = 5807354;\n        log2tableTimes1M[57] = 5832890;\n        log2tableTimes1M[58] = 5857980;\n        log2tableTimes1M[59] = 5882643;\n        log2tableTimes1M[60] = 5906890;\n        log2tableTimes1M[61] = 5930737;\n        log2tableTimes1M[62] = 5954196;\n        log2tableTimes1M[63] = 5977279;\n        log2tableTimes1M[64] = 6000000;\n        log2tableTimes1M[65] = 6022367;\n        log2tableTimes1M[66] = 6044394;\n        log2tableTimes1M[67] = 6066089;\n        log2tableTimes1M[68] = 6087462;\n        log2tableTimes1M[69] = 6108524;\n        log2tableTimes1M[70] = 6129283;\n        log2tableTimes1M[71] = 6149747;\n        log2tableTimes1M[72] = 6169925;\n        log2tableTimes1M[73] = 6189824;\n        log2tableTimes1M[74] = 6209453;\n        log2tableTimes1M[75] = 6228818;\n        log2tableTimes1M[76] = 6247927;\n        log2tableTimes1M[77] = 6266786;\n        log2tableTimes1M[78] = 6285402;\n        log2tableTimes1M[79] = 6303780;\n        log2tableTimes1M[80] = 6321928;\n        log2tableTimes1M[81] = 6339850;\n        log2tableTimes1M[82] = 6357552;\n        log2tableTimes1M[83] = 6375039;\n        log2tableTimes1M[84] = 6392317;\n        log2tableTimes1M[85] = 6409390;\n        log2tableTimes1M[86] = 6426264;\n        log2tableTimes1M[87] = 6442943;\n        log2tableTimes1M[88] = 6459431;\n        log2tableTimes1M[89] = 6475733;\n        log2tableTimes1M[90] = 6491853;\n        log2tableTimes1M[91] = 6507794;\n        log2tableTimes1M[92] = 6523561;\n        log2tableTimes1M[93] = 6539158;\n        log2tableTimes1M[94] = 6554588;\n        log2tableTimes1M[95] = 6569855;\n        log2tableTimes1M[96] = 6584962;\n        log2tableTimes1M[97] = 6599912;\n        log2tableTimes1M[98] = 6614709;\n        log2tableTimes1M[99] = 6629356;\n        log2tableTimes1M[100] = 6643856;\n        log2tableTimes1M[101] = 6658211;\n        log2tableTimes1M[102] = 6672425;\n        log2tableTimes1M[103] = 6686500;\n        log2tableTimes1M[104] = 6700439;\n        log2tableTimes1M[105] = 6714245;\n        log2tableTimes1M[106] = 6727920;\n        log2tableTimes1M[107] = 6741466;\n        log2tableTimes1M[108] = 6754887;\n        log2tableTimes1M[109] = 6768184;\n        log2tableTimes1M[110] = 6781359;\n        log2tableTimes1M[111] = 6794415;\n        log2tableTimes1M[112] = 6807354;\n        log2tableTimes1M[113] = 6820178;\n        log2tableTimes1M[114] = 6832890;\n        log2tableTimes1M[115] = 6845490;\n        log2tableTimes1M[116] = 6857980;\n        log2tableTimes1M[117] = 6870364;\n        log2tableTimes1M[118] = 6882643;\n        log2tableTimes1M[119] = 6894817;\n        log2tableTimes1M[120] = 6906890;\n        log2tableTimes1M[121] = 6918863;\n        log2tableTimes1M[122] = 6930737;\n        log2tableTimes1M[123] = 6942514;\n        log2tableTimes1M[124] = 6954196;\n        log2tableTimes1M[125] = 6965784;\n        log2tableTimes1M[126] = 6977279;\n        log2tableTimes1M[127] = 6988684;\n        log2tableTimes1M[128] = 7000000;\n    }\n\n    /// @notice Approximates log2 * 1M\n    /// @param _num number to take log2 * 1M of\n    function log2ApproxTimes1M(uint256 _num) public view returns (uint256) {\n        require (_num > 0, \"Number cannot be zero\");\n        uint256 leading = 0;\n\n        if (_num == 1) return 0;\n\n        while (_num > 128) {\n           _num = _num >> 1;\n           leading += 1;\n       }\n       return (leading.mul(uint256(1000000))).add(log2tableTimes1M[_num]);\n    }\n}\n"
28     },
29     "@cartesi/util/contracts/Decorated.sol": {
30       "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity ^0.7.0;\n\n\ncontract Decorated {\n    // This contract defines several modifiers but does not use\n    // them - they will be used in derived contracts.\n    modifier onlyBy(address user) {\n        require(msg.sender == user, \"Cannot be called by user\");\n        _;\n    }\n\n    modifier onlyAfter(uint256 time) {\n        require(block.timestamp > time, \"Cannot be called now\");\n        _;\n    }\n}\n"
31     },
32     "@cartesi/util/contracts/Instantiator.sol": {
33       "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n\npragma solidity ^0.7.0;\n\n\ninterface Instantiator {\n\n    modifier onlyInstantiated(uint256 _index) virtual;\n\n    modifier onlyActive(uint256 _index) virtual;\n\n    modifier increasesNonce(uint256 _index) virtual;\n\n    function isActive(uint256 _index) external view returns (bool);\n\n    function getNonce(uint256 _index) external view returns (uint256);\n\n    function isConcerned(uint256 _index, address _user) external view returns (bool);\n\n    function getSubInstances(uint256 _index, address) external view returns (address[] memory _addresses, uint256[] memory _indices);\n}\n"
34     },
35     "@cartesi/util/contracts/InstantiatorImpl.sol": {
36       "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity ^0.7.0;\n\nimport \"./Instantiator.sol\";\n\nabstract contract InstantiatorImpl is Instantiator {\n    uint256 public currentIndex = 0;\n\n    mapping(uint256 => bool) internal active;\n    mapping(uint256 => uint256) internal nonce;\n\n    modifier onlyInstantiated(uint256 _index) override {\n        require(currentIndex > _index, \"Index not instantiated\");\n        _;\n    }\n\n    modifier onlyActive(uint256 _index) override {\n        require(currentIndex > _index, \"Index not instantiated\");\n        require(isActive(_index), \"Index inactive\");\n        _;\n    }\n\n    modifier increasesNonce(uint256 _index) override {\n        nonce[_index]++;\n        _;\n    }\n\n    function isActive(uint256 _index) public override view returns (bool) {\n        return (active[_index]);\n    }\n\n    function getNonce(uint256 _index)\n        public\n        override\n        view\n        onlyActive(_index)\n        returns (uint256 currentNonce)\n    {\n        return nonce[_index];\n    }\n\n    function deactivate(uint256 _index) internal {\n        active[_index] = false;\n        nonce[_index] = 0;\n    }\n}\n"
37     },
38     "@cartesi/util/contracts/WorkerAuthManager.sol": {
39       "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title WorkerAuthManager\n/// @author Danilo Tuler\npragma solidity ^0.7.0;\n\ninterface WorkerAuthManager {\n    /// @notice Gives worker permission to act on a DApp\n    /// @param _workerAddress address of the worker node to given permission\n    /// @param _dappAddress address of the dapp that permission will be given to\n    function authorize(address _workerAddress, address _dappAddress) external;\n\n    /// @notice Removes worker's permission to act on a DApp\n    /// @param _workerAddress address of the proxy that will lose permission\n    /// @param _dappAddresses addresses of dapps that will lose permission\n    function deauthorize(address _workerAddress, address _dappAddresses)\n        external;\n\n    /// @notice Returns is the dapp is authorized to be called by that worker\n    /// @param _workerAddress address of the worker\n    /// @param _dappAddress address of the DApp\n    function isAuthorized(address _workerAddress, address _dappAddress)\n        external\n        view\n        returns (bool);\n\n    /// @notice Get the owner of the worker node\n    /// @param workerAddress address of the worker node\n    function getOwner(address workerAddress) external view returns (address);\n\n    /// @notice A DApp has been authorized by a user for a worker\n    event Authorization(\n        address indexed user,\n        address indexed worker,\n        address indexed dapp\n    );\n\n    /// @notice A DApp has been deauthorized by a user for a worker\n    event Deauthorization(\n        address indexed user,\n        address indexed worker,\n        address indexed dapp\n    );\n}\n"
40     },
41     "@openzeppelin/contracts/GSN/Context.sol": {
42       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
43     },
44     "@openzeppelin/contracts/access/Ownable.sol": {
45       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
46     },
47     "@openzeppelin/contracts/math/SafeMath.sol": {
48       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
49     },
50     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
51       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
52     },
53     "contracts/BlockSelector.sol": {
54       "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Block Selector\n\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"@cartesi/util/contracts/CartesiMath.sol\";\nimport \"@cartesi/util/contracts/InstantiatorImpl.sol\";\nimport \"@cartesi/util/contracts/Decorated.sol\";\n\ncontract BlockSelector is InstantiatorImpl, Decorated, CartesiMath {\n    using SafeMath for uint256;\n\n    uint256 constant C_256 = 256; // 256 blocks\n    uint256 constant DIFFICULTY_BASE_MULTIPLIER = 256000000; //256 M\n    uint256 constant ADJUSTMENT_BASE = 1000000; // 1M\n\n    struct BlockSelectorCtx {\n        // @dev the order of variables are important for storage packing\n        // 32 bytes constants\n        uint256 minDifficulty; // lower bound for difficulty\n        // 32 bytes var\n        uint256 difficulty; // difficulty parameter defines how big the interval will be\n\n        // 20 bytes constants\n        address posManagerAddress;\n\n        // 4 bytes constants\n        uint32 difficultyAdjustmentParameter; // how fast the difficulty gets adjusted to reach the desired interval, number * 1000000\n        uint32 targetInterval; // desired block selection interval in ethereum blocks\n\n        // 4 bytes var\n        uint32 blockCount; // how many blocks have been created\n        uint32 ethBlockCheckpoint; // ethereum block number when current selection started\n    }\n\n    mapping(uint256 => BlockSelectorCtx) internal instance;\n\n    event BlockProduced(\n        uint256 indexed index,\n        address indexed producer,\n        uint32 blockNumber,\n        uint256 roundDuration,\n        uint256 difficulty\n    );\n\n    modifier onlyAfterGoalDefinition(uint256 _index){\n        // cannot produce if block selector goal hasnt been decided yet\n        // goal is defined the block after selection was reset\n        require(\n            block.number >= instance[_index].ethBlockCheckpoint + 1,\n            \"Goal for new block hasnt been decided yet\"\n        );\n        _;\n\n    }\n\n    /// @notice Instantiates a BlockSelector structure\n    /// @param _minDifficulty lower bound for difficulty parameter\n    /// @param _initialDifficulty starting difficulty\n    /// @param _difficultyAdjustmentParameter how quickly the difficulty gets updated\n    /// according to the difference between time passed and target interval.\n    /// @param _targetInterval how often we want produce noether blocks, in ethereum blocks\n    /// @param _posManagerAddress address of ProofOfStake that will use this instance\n    function instantiate(\n        uint256 _minDifficulty,\n        uint256 _initialDifficulty,\n        uint32 _difficultyAdjustmentParameter,\n        uint32 _targetInterval,\n        address _posManagerAddress\n    ) public returns (uint256)\n    {\n        instance[currentIndex].minDifficulty = _minDifficulty;\n        instance[currentIndex].difficulty = _initialDifficulty;\n        instance[currentIndex].difficultyAdjustmentParameter = _difficultyAdjustmentParameter;\n        instance[currentIndex].targetInterval = _targetInterval;\n        instance[currentIndex].posManagerAddress = _posManagerAddress;\n\n        instance[currentIndex].ethBlockCheckpoint = uint32(block.number); // first selection starts when the instance is created\n\n        active[currentIndex] = true;\n        return currentIndex++;\n    }\n\n    /// @notice Calculates the log of the random number between the goal and callers address\n    /// @param _index the index of the instance of block selector you want to interact with\n    /// @param _user address to calculate log of random\n    /// @return log of random number between goal and callers address * 1M\n    function getLogOfRandom(uint256 _index, address _user) internal view returns (uint256) {\n        // seed for goal takes a block in the future (+1) so it is harder to manipulate\n        bytes32 currentGoal = blockhash(\n            getSeed(uint256(instance[_index].ethBlockCheckpoint + 1), block.number)\n        );\n        bytes32 hashedAddress = keccak256(abi.encodePacked(_user));\n        uint256 distance = uint256(keccak256(abi.encodePacked(hashedAddress, currentGoal)));\n\n        return CartesiMath.log2ApproxTimes1M(distance);\n    }\n\n    /// @notice Produces a block\n    /// @param _index the index of the instance of block selector you want to interact with\n    /// @param _user address that has the right to produce block\n    /// @param _weight number that will weight the random number, will be the number of staked tokens\n    function produceBlock(\n        uint256 _index,\n        address _user,\n        uint256 _weight\n    )\n    public\n    onlyAfterGoalDefinition(_index)\n    returns (bool)\n    {\n        BlockSelectorCtx storage bsc = instance[_index];\n\n        require(_weight > 0, \"Caller can't have zero staked tokens\");\n        require(msg.sender == bsc.posManagerAddress, \"Function can only be called by pos address\");\n\n        if (canProduceBlock(_index, _user, _weight)) {\n            emit BlockProduced(\n                _index,\n                _user,\n                bsc.blockCount,\n                getSelectionBlockDuration(_index),\n                bsc.difficulty\n            );\n\n            return _blockProduced(_index);\n        }\n\n        return false;\n    }\n\n    /// @notice Check if address is allowed to produce block\n    /// @param _index the index of the instance of block selector you want to interact with\n    /// @param _user the address that is gonna get checked\n    /// @param _weight number that will weight the random number, most likely will be the number of staked tokens\n    function canProduceBlock(uint256 _index, address _user, uint256 _weight) public view returns (bool) {\n        BlockSelectorCtx storage bsc = instance[_index];\n\n        // cannot produce if block selector goal hasnt been decided yet\n        // goal is defined the block after selection was reset\n        if (block.number <= bsc.ethBlockCheckpoint + 1) {\n            return false;\n        }\n\n        uint256 blockDuration = getSelectionBlockDuration(_index);\n\n        return (\n            (_weight.mul(blockDuration)) > bsc.difficulty.mul((DIFFICULTY_BASE_MULTIPLIER - getLogOfRandom(_index, _user)))\n        );\n    }\n\n    /// @notice Block produced, declare producer and adjust difficulty\n    /// @param _index the index of the instance of block selector you want to interact with\n    function _blockProduced(uint256 _index) private returns (bool) {\n        BlockSelectorCtx storage bsc = instance[_index];\n\n        // adjust difficulty\n        bsc.difficulty = getNewDifficulty(\n            bsc.minDifficulty,\n            bsc.difficulty,\n            uint32((block.number).sub(uint256(bsc.ethBlockCheckpoint))),\n            bsc.targetInterval,\n            bsc.difficultyAdjustmentParameter\n        );\n\n        _reset(_index);\n        return true;\n    }\n\n    /// @notice Reset instance, advancing round and choosing new goal\n    /// @param _index the index of the instance of block selector you want to interact with\n    function _reset(uint256 _index) private {\n        BlockSelectorCtx storage bsc = instance[_index];\n\n        bsc.blockCount++;\n        bsc.ethBlockCheckpoint = uint32(block.number);\n    }\n\n    function getSeed(\n        uint256 _previousTarget,\n        uint256 _currentBlock\n    )\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 diff = _currentBlock.sub(_previousTarget);\n        uint256 res = diff.div(C_256);\n\n        // if difference is multiple of 256 (256, 512, 1024)\n        // preserve old target\n        if (diff % C_256 == 0) {\n            return _previousTarget.add((res - 1).mul(C_256));\n        }\n\n        return _previousTarget.add(res.mul(C_256));\n    }\n\n    /// @notice Calculates new difficulty parameter\n    /// @param _minDiff minimum difficulty of instance\n    /// @param _oldDiff is the difficulty of previous round\n    /// @param _blocksPassed how many ethereum blocks have passed\n    /// @param _targetInterval is how long a round is supposed to take\n    /// @param _adjustmentParam is how fast the difficulty gets adjusted,\n    ///         should be number * 1000000\n    function getNewDifficulty(\n        uint256 _minDiff,\n        uint256 _oldDiff,\n        uint32 _blocksPassed,\n        uint32 _targetInterval,\n        uint32 _adjustmentParam\n    )\n    internal\n    pure\n    returns (uint256)\n    {\n        // @dev to save gas on evaluation, instead of returning the _oldDiff when the target\n        // was exactly matched - we increase the difficulty.\n        if (_blocksPassed <= _targetInterval) {\n            return _oldDiff.add(_oldDiff.mul(_adjustmentParam).div(ADJUSTMENT_BASE) + 1);\n        }\n\n        uint256 newDiff = _oldDiff.sub(_oldDiff.mul(_adjustmentParam).div(ADJUSTMENT_BASE) + 1);\n\n        return newDiff > _minDiff ? newDiff : _minDiff;\n    }\n\n    /// @notice Returns the number of blocks\n    /// @param _index the index of the instance of block selector to be interact with\n    /// @return number of blocks\n    function getBlockCount(uint256 _index) public view returns (uint32) {\n        return instance[_index].blockCount;\n    }\n\n    /// @notice Returns current difficulty\n    /// @param _index the index of the instance of block selector to be interact with\n    /// @return difficulty of current selection\n    function getDifficulty(uint256 _index) public view returns (uint256) {\n        return instance[_index].difficulty;\n    }\n\n    /// @notice Returns min difficulty\n    /// @param _index the index of the instance of block selector to be interact with\n    /// @return min difficulty of instance\n    function getMinDifficulty(uint256 _index) public view returns (uint256) {\n        return instance[_index].minDifficulty;\n    }\n\n    /// @notice Returns difficulty adjustment parameter\n    /// @param _index the index of the instance of block selector to be interact with\n    /// @return difficulty adjustment parameter\n    function getDifficultyAdjustmentParameter(\n        uint256 _index\n    )\n    public\n    view\n    returns (uint32)\n    {\n        return instance[_index].difficultyAdjustmentParameter;\n    }\n\n    /// @notice Returns target interval\n    /// @param _index the index of the instance of block selector to be interact with\n    /// @return target interval\n    function getTargetInterval(uint256 _index) public view returns (uint32) {\n        return instance[_index].targetInterval;\n    }\n\n    /// @notice Returns time since last selection started, in ethereum blocks\n    /// @param _index the index of the instance of block selector to be interact with\n    /// @return number of etheereum blocks passed since last selection started\n    /// @dev block duration resets every 256 blocks\n    function getSelectionBlockDuration(uint256 _index)\n    public\n    view\n    returns (uint256)\n    {\n        BlockSelectorCtx storage bsc = instance[_index];\n\n        uint256 goalBlock = uint256(bsc.ethBlockCheckpoint + 1);\n\n        // target hasnt been set\n        if (goalBlock >= block.number) return 0;\n\n        uint256 blocksPassed = (block.number).sub(goalBlock);\n\n        // if blocksPassed is multiple of 256, 256 blocks have passed\n        // this avoids blocksPassed going to zero right before target change\n        if (blocksPassed % C_256 == 0) return C_256;\n\n        return blocksPassed % C_256;\n    }\n\n    function getState(uint256 _index, address _user)\n    public view returns (uint256[5] memory _uintValues) {\n        BlockSelectorCtx storage i = instance[_index];\n\n        uint256[5] memory uintValues = [\n            block.number,\n            i.ethBlockCheckpoint + 1, // initial selection goal\n            i.difficulty,\n            getSelectionBlockDuration(_index), // blocks passed\n            getLogOfRandom(_index, _user)\n        ];\n\n        return uintValues;\n    }\n\n    function isConcerned(uint256, address) public override pure returns (bool) {\n        return false; // isConcerned is only for the main concern (PoS)\n    }\n\n    function getSubInstances(uint256, address)\n        public override pure returns (address[] memory _addresses,\n            uint256[] memory _indices)\n    {\n        address[] memory a;\n        uint256[] memory i;\n\n        a = new address[](0);\n        i = new uint256[](0);\n\n        return (a, i);\n    }\n}\n"
55     },
56     "contracts/PoS.sol": {
57       "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Proof of Stake\n/// @author Felipe Argento\n\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"@cartesi/util/contracts/InstantiatorImpl.sol\";\nimport \"@cartesi/util/contracts/Decorated.sol\";\nimport \"@cartesi/util/contracts/WorkerAuthManager.sol\";\n\nimport \"./Staking.sol\";\nimport \"./BlockSelector.sol\";\nimport \"./RewardManager.sol\";\n\ncontract PoS is Ownable, InstantiatorImpl, Decorated {\n    using SafeMath for uint256;\n\n    struct PoSCtx {\n        uint256 blockSelectorIndex;\n        BlockSelector blockSelector;\n        Staking staking;\n        RewardManager rewardManager;\n        WorkerAuthManager workerAuth;\n    }\n\n    mapping(uint256 => PoSCtx) internal instance;\n\n    event Rewarded(\n        uint256 indexed index,\n        address indexed worker,\n        address indexed user,\n        uint256 reward\n    );\n\n    event NewChain (\n        uint256 indexed index,\n        address stakingAddress,\n        address blockSelectorAddress,\n        address workerAuthAddress,\n        uint256 minimumDifficulty,\n        uint256 initialDifficulty,\n        uint32 difficultyAdjustmentParameter,\n        uint32 targetInterval,\n        address ctsiAddress,\n        uint256 maxReward,\n        uint256 minReward,\n        uint256 distNumerator,\n        uint256 distDenominator\n    );\n    /// @notice Instantiates a Proof of Stake\n    /// @param _stakingAddress address of StakingInterface\n    /// @param _blockSelectorAddress address of blockSelector contract\n    /// @param _workerAuthAddress address of worker manager contract\n    /// @param _difficultyAdjustmentParameter how quickly the difficulty gets updated\n    /// according to the difference between time passed and desired draw time interval.\n    /// @param _targetInterval how often we want to elect a block producer\n    /// @param _ctsiAddress address of token instance being used\n    /// @param _maxReward maximum reward that this contract pays\n    /// @param _minReward minimum reward that this contract pays\n    /// @param _distNumerator multiplier factor to define reward amount\n    /// @param _distDenominator dividing factor to define reward amount\n    function instantiate(\n        address _stakingAddress,\n        address _blockSelectorAddress,\n        address _workerAuthAddress,\n        uint256 _minimumDifficulty,\n        uint256 _initialDifficulty,\n        uint32 _difficultyAdjustmentParameter,\n        uint32 _targetInterval,\n\n        // RewardManager constructor parameters\n        address _ctsiAddress,\n        uint256 _maxReward,\n        uint256 _minReward,\n        uint256 _distNumerator,\n        uint256 _distDenominator\n    ) public onlyOwner() returns (uint256) {\n\n        // index is incremented at the beggining to stop reentrancy possibilities\n        // TODO: study using ReentrancyGuard contract\n        currentIndex++;\n\n        instance[currentIndex - 1].staking = Staking(_stakingAddress);\n        instance[currentIndex - 1].blockSelector = BlockSelector(\n            _blockSelectorAddress\n        );\n\n        instance[currentIndex - 1].workerAuth = WorkerAuthManager(\n            _workerAuthAddress\n        );\n\n        active[currentIndex - 1] = true;\n\n        // there is no reentrancy because the bytecode is included in this contract\n        instance[currentIndex - 1].rewardManager = new RewardManager(\n            address(this),\n            _ctsiAddress,\n            _maxReward,\n            _minReward,\n            _distNumerator,\n            _distDenominator\n        );\n\n        instance[currentIndex - 1].blockSelectorIndex = instance[currentIndex -\n            1]\n            .blockSelector\n            .instantiate(\n            _minimumDifficulty,\n            _initialDifficulty,\n            _difficultyAdjustmentParameter,\n            _targetInterval,\n            address(this)\n        );\n\n        emit NewChain (\n            currentIndex - 1,\n            _stakingAddress,\n            _blockSelectorAddress,\n            _workerAuthAddress,\n            _minimumDifficulty,\n            _initialDifficulty,\n            _difficultyAdjustmentParameter,\n            _targetInterval,\n            _ctsiAddress,\n            _maxReward,\n            _minReward,\n            _distNumerator,\n            _distDenominator\n        );\n\n        return currentIndex - 1;\n    }\n\n    /// @notice Produce a block\n    /// @param _index the index of the instance of pos you want to interact with\n    /// @dev this function can only be called by a worker, user never calls it directly\n    function produceBlock(uint256 _index) public returns (bool) {\n        PoSCtx storage pos = instance[_index];\n\n        require(\n            pos.workerAuth.isAuthorized(msg.sender, address(this)),\n            \"msg.sender is not authorized to make this call\"\n        );\n\n        address user = pos.workerAuth.getOwner(msg.sender);\n\n        require(\n            pos.blockSelector.produceBlock(\n                pos.blockSelectorIndex,\n                user,\n                pos.staking.getStakedBalance(user)\n            ),\n            \"User couldnt produce a block successfully\"\n        );\n\n        uint256 currentReward = pos.rewardManager.getCurrentReward();\n\n        pos.rewardManager.reward(user, currentReward);\n        emit Rewarded(\n            _index,\n            msg.sender,\n            user,\n            currentReward\n        );\n\n        return true;\n    }\n\n    /// @notice Get reward manager address\n    /// @param _index index of instance\n    /// @return address of instance's RewardManager\n    function getRewardManagerAddress(uint256 _index)\n        public\n        view\n        returns (address)\n    {\n        return address(instance[_index].rewardManager);\n    }\n\n    /// @notice Get block selector address\n    /// @param _index index of instance\n    /// @return address of instance's block selector\n    function getBlockSelectorAddress(uint256 _index)\n        public\n        view\n        returns (address)\n    {\n        return address(instance[_index].blockSelector);\n    }\n\n    /// @notice Get block selector index\n    /// @param _index index of instance\n    /// @return index of instance's block selector\n    function getBlockSelectorIndex(uint256 _index)\n        public\n        view\n        returns (uint256)\n    {\n        return instance[_index].blockSelectorIndex;\n    }\n\n    /// @notice Get staking address\n    /// @param _index index of instance\n    /// @return address of instance's staking contract\n    function getStakingAddress(uint256 _index)\n        public\n        view\n        returns (address)\n    {\n        return address(instance[_index].staking);\n    }\n\n    /// @notice Get state of a particular instance\n    /// @param _index index of instance\n    /// @param _user address of user\n    /// @return bool if user is eligible to produce next block\n    /// @return address of user that was chosen to build the block\n    /// @return current reward paid by the network for that block\n    function getState(uint256 _index, address _user)\n        public\n        view\n        returns (\n            bool,\n            address,\n            uint256\n        )\n    {\n        PoSCtx storage pos = instance[_index];\n        return (\n            pos.blockSelector.canProduceBlock(\n                pos.blockSelectorIndex,\n                _user,\n                pos.staking.getStakedBalance(_user)\n            ),\n            _user,\n            pos.rewardManager.getCurrentReward()\n        );\n    }\n\n    function isConcerned(uint256 _index, address _user)\n        public\n        override\n        view\n        returns (bool)\n    {\n        PoSCtx storage pos = instance[_index];\n        return pos.staking.getStakedBalance(_user) > 0;\n    }\n\n    function getSubInstances(uint256 _index, address)\n        public\n        override\n        view\n        returns (address[] memory _addresses, uint256[] memory _indices)\n    {\n        PoSCtx storage pos = instance[_index];\n\n        address[] memory a;\n        uint256[] memory i;\n\n        a = new address[](1);\n        i = new uint256[](1);\n\n        a[0] = address(pos.blockSelector);\n        i[0] = pos.blockSelectorIndex;\n        return (a, i);\n    }\n\n    function terminate(uint256 _index) public onlyOwner() {\n        PoSCtx storage pos = instance[_index];\n        require(\n            pos.rewardManager.getCurrentReward() == 0,\n            \"RewardManager still holds funds\"\n        );\n        deactivate(_index);\n    }\n}\n"
58     },
59     "contracts/RewardManager.sol": {
60       "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title RewardManager\n/// @author Felipe Argento\n\n\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract RewardManager {\n    using SafeMath for uint256;\n\n    uint256 immutable minReward;\n    uint256 immutable maxReward;\n    uint256 immutable distNumerator;\n    uint256 immutable distDenominator;\n    address immutable operator;\n    IERC20 immutable ctsi;\n\n    /// @notice Creates contract\n    /// @param _operator address of the operator\n    /// @param _ctsiAddress address of token instance being used\n    /// @param _maxReward maximum reward that this contract pays\n    /// @param _minReward minimum reward that this contract pays\n    /// @param _distNumerator multiplier factor to define reward amount\n    /// @param _distDenominator dividing factor to define reward amount\n    constructor(\n        address _operator,\n        address _ctsiAddress,\n        uint256 _maxReward,\n        uint256 _minReward,\n        uint256 _distNumerator,\n        uint256 _distDenominator\n    ) {\n\n        operator = _operator;\n        ctsi = IERC20(_ctsiAddress);\n\n        minReward = _minReward;\n        maxReward = _maxReward;\n        distNumerator = _distNumerator;\n        distDenominator = _distDenominator;\n    }\n\n    /// @notice Rewards address\n    /// @param _address address be rewarded\n    /// @param _amount reward\n    /// @dev only the pos contract can call this\n    function reward(address _address, uint256 _amount) public {\n        require(msg.sender == operator, \"Only the operator contract can call this function\");\n\n        ctsi.transfer(_address, _amount);\n    }\n\n    /// @notice Get RewardManager's balance\n    function getBalance() public view returns (uint256) {\n        return ctsi.balanceOf(address(this));\n    }\n\n    /// @notice Get current reward amount\n    function getCurrentReward() public view returns (uint256) {\n        uint256 cReward = (getBalance().mul(distNumerator)).div(distDenominator);\n        cReward = cReward > minReward? cReward : minReward;\n        cReward = cReward > maxReward? maxReward : cReward;\n\n        return cReward > getBalance()? getBalance() : cReward;\n    }\n}\n"
61     },
62     "contracts/Staking.sol": {
63       "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Interface staking contract\npragma solidity ^0.7.0;\n\ninterface Staking {\n\n    /// @notice Returns total amount of tokens counted as stake\n    /// @param _userAddress user to retrieve staked balance from\n    /// @return finalized staked of _userAddress\n    function getStakedBalance(\n        address _userAddress) external view returns (uint256);\n\n    /// @notice Returns the timestamp when next deposit can be finalized\n    /// @return timestamp of when finalizeStakes() is callable\n    function getMaturingTimestamp(address _userAddress) external view returns (uint256);\n\n    /// @notice Returns the timestamp when next withdraw can be finalized\n    /// @return timestamp of when finalizeWithdraw() is callable\n    function getReleasingTimestamp(address _userAddress) external view returns (uint256);\n\n\n    /// @notice Returns the balance waiting/ready to be matured\n    /// @return amount that will get staked after finalization\n    function getMaturingBalance(address _userAddress) external view  returns (uint256);\n\n    /// @notice Returns the balance waiting/ready to be released\n    /// @return amount that will get withdrew after finalization\n    function getReleasingBalance(address _userAddress) external view  returns (uint256);\n\n\n    /// @notice Deposit CTSI to be staked. The money will turn into staked\n    ///         balance after timeToStake days\n    /// @param _amount The amount of tokens that are gonna be deposited.\n    function stake(uint256 _amount) external;\n\n    /// @notice Remove tokens from staked balance. The money can\n    ///         be released after timeToRelease seconds, if the\n    ///         function withdraw is called.\n    /// @param _amount The amount of tokens that are gonna be unstaked.\n    function unstake(uint256 _amount) external;\n\n    /// @notice Transfer tokens to user's wallet.\n    /// @param _amount The amount of tokens that are gonna be transferred.\n    function withdraw(uint256 _amount) external;\n\n    // events\n    /// @notice CTSI tokens were deposited, they count as stake after _maturationDate\n    /// @param user address of msg.sender\n    /// @param amount amount deposited for staking\n    /// @param maturationDate date when the stake can be finalized\n    event Stake(\n        address indexed user,\n        uint256 amount,\n        uint256 maturationDate\n    );\n\n    /// @notice Unstake tokens, moving them to releasing structure\n    /// @param user address of msg.sender\n    /// @param amount amount of tokens to be released\n    /// @param maturationDate date when the tokens can be withdrew\n    event Unstake(\n        address indexed user,\n        uint256 amount,\n        uint256 maturationDate\n    );\n\n    /// @notice Withdraw process was finalized\n    /// @param user address of msg.sender\n    /// @param amount amount of tokens withdrawn\n    event Withdraw(\n        address indexed user,\n        uint256 amount\n    );\n}\n\n"
64     }
65   }
66 }}