1 {{
2   "language": "Solidity",
3   "sources": {
4     "/Users/Elena/Source/argent-contracts/contracts/infrastructure/IAuthoriser.sol": {
5       "content": "// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.3;\n\ninterface IAuthoriser {\n    function isAuthorised(address _sender, address _spender, address _to, bytes calldata _data) external view returns (bool);\n    function areAuthorised(\n        address _spender,\n        address[] calldata _spenders,\n        address[] calldata _to,\n        bytes[] calldata _data\n    )\n        external\n        view\n        returns (bool);\n}"
6     },
7     "/Users/Elena/Source/argent-contracts/contracts/infrastructure/IModuleRegistry.sol": {
8       "content": "// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.9.0;\n\n/**\n * @title IModuleRegistry\n * @notice Interface for the registry of authorised modules.\n */\ninterface IModuleRegistry {\n    function registerModule(address _module, bytes32 _name) external;\n\n    function deregisterModule(address _module) external;\n\n    function registerUpgrader(address _upgrader, bytes32 _name) external;\n\n    function deregisterUpgrader(address _upgrader) external;\n\n    function recoverToken(address _token) external;\n\n    function moduleInfo(address _module) external view returns (bytes32);\n\n    function upgraderInfo(address _upgrader) external view returns (bytes32);\n\n    function isRegisteredModule(address _module) external view returns (bool);\n\n    function isRegisteredModule(address[] calldata _modules) external view returns (bool);\n\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool);\n}"
9     },
10     "/Users/Elena/Source/argent-contracts/contracts/infrastructure/storage/IGuardianStorage.sol": {
11       "content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.9.0;\n\ninterface IGuardianStorage {\n\n    /**\n     * @notice Lets an authorised module add a guardian to a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to add.\n     */\n    function addGuardian(address _wallet, address _guardian) external;\n\n    /**\n     * @notice Lets an authorised module revoke a guardian from a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to revoke.\n     */\n    function revokeGuardian(address _wallet, address _guardian) external;\n\n    /**\n     * @notice Checks if an account is a guardian for a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The account.\n     * @return true if the account is a guardian for a wallet.\n     */\n    function isGuardian(address _wallet, address _guardian) external view returns (bool);\n\n    function isLocked(address _wallet) external view returns (bool);\n\n    function getLock(address _wallet) external view returns (uint256);\n\n    function getLocker(address _wallet) external view returns (address);\n\n    function setLock(address _wallet, uint256 _releaseAfter) external;\n\n    function getGuardians(address _wallet) external view returns (address[] memory);\n\n    function guardianCount(address _wallet) external view returns (uint256);\n}"
12     },
13     "/Users/Elena/Source/argent-contracts/contracts/infrastructure/storage/ITransferStorage.sol": {
14       "content": "// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.9.0;\n\n/**\n * @title ITransferStorage\n * @notice TransferStorage interface\n */\ninterface ITransferStorage {\n    function setWhitelist(address _wallet, address _target, uint256 _value) external;\n\n    function getWhitelist(address _wallet, address _target) external view returns (uint256);\n}"
15     },
16     "/Users/Elena/Source/argent-contracts/contracts/modules/ArgentModule.sol": {
17       "content": "// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.3;\n\nimport \"./common/Utils.sol\";\nimport \"./common/BaseModule.sol\";\nimport \"./RelayerManager.sol\";\nimport \"./SecurityManager.sol\";\nimport \"./TransactionManager.sol\";\n\n/**\n * @title ArgentModule\n * @notice Single module for the Argent wallet.\n * @author Julien Niset - <julien@argent.xyz>\n */\ncontract ArgentModule is BaseModule, RelayerManager, SecurityManager, TransactionManager {\n\n    bytes32 constant public NAME = \"ArgentModule\";\n\n    constructor (\n        IModuleRegistry _registry,\n        IGuardianStorage _guardianStorage,\n        ITransferStorage _userWhitelist,\n        IAuthoriser _authoriser,\n        address _uniswapRouter,\n        uint256 _securityPeriod,\n        uint256 _securityWindow,\n        uint256 _recoveryPeriod,\n        uint256 _lockPeriod\n    )\n        BaseModule(_registry, _guardianStorage, _userWhitelist, _authoriser, NAME)\n        SecurityManager(_recoveryPeriod, _securityPeriod, _securityWindow, _lockPeriod)\n        TransactionManager(_securityPeriod)\n        RelayerManager(_uniswapRouter)\n    {\n        \n    }\n\n    /**\n     * @inheritdoc IModule\n     */\n    function init(address _wallet) external override onlyWallet(_wallet) {\n        enableDefaultStaticCalls(_wallet);\n    }\n\n    /**\n    * @inheritdoc IModule\n    */\n    function addModule(address _wallet, address _module) external override onlyWalletOwnerOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\n        require(registry.isRegisteredModule(_module), \"AM: module is not registered\");\n        IWallet(_wallet).authoriseModule(_module, true);\n    }\n    \n    /**\n     * @inheritdoc RelayerManager\n     */\n    function getRequiredSignatures(address _wallet, bytes calldata _data) public view override returns (uint256, OwnerSignature) {\n        bytes4 methodId = Utils.functionPrefix(_data);\n\n        if (methodId == TransactionManager.multiCall.selector ||\n            methodId == TransactionManager.addToWhitelist.selector ||\n            methodId == TransactionManager.removeFromWhitelist.selector ||\n            methodId == TransactionManager.enableERC1155TokenReceiver.selector ||\n            methodId == TransactionManager.clearSession.selector ||\n            methodId == ArgentModule.addModule.selector ||\n            methodId == SecurityManager.addGuardian.selector ||\n            methodId == SecurityManager.revokeGuardian.selector ||\n            methodId == SecurityManager.cancelGuardianAddition.selector ||\n            methodId == SecurityManager.cancelGuardianRevokation.selector)\n        {\n            // owner\n            return (1, OwnerSignature.Required);\n        }\n        if (methodId == TransactionManager.multiCallWithSession.selector) {\n            return (1, OwnerSignature.Session);\n        }\n        if (methodId == SecurityManager.executeRecovery.selector) {\n            // majority of guardians\n            uint numberOfSignaturesRequired = _majorityOfGuardians(_wallet);\n            require(numberOfSignaturesRequired > 0, \"AM: no guardians set on wallet\");\n            return (numberOfSignaturesRequired, OwnerSignature.Disallowed);\n        }\n        if (methodId == SecurityManager.cancelRecovery.selector) {\n            // majority of (owner + guardians)\n            uint numberOfSignaturesRequired = Utils.ceil(recoveryConfigs[_wallet].guardianCount + 1, 2);\n            return (numberOfSignaturesRequired, OwnerSignature.Optional);\n        }\n        if (methodId == TransactionManager.multiCallWithGuardians.selector ||\n            methodId == TransactionManager.multiCallWithGuardiansAndStartSession.selector ||\n            methodId == SecurityManager.transferOwnership.selector)\n        {\n            // owner + majority of guardians\n            uint majorityGuardians = _majorityOfGuardians(_wallet);\n            uint numberOfSignaturesRequired = majorityGuardians + 1;\n            return (numberOfSignaturesRequired, OwnerSignature.Required);\n        }\n        if (methodId == SecurityManager.finalizeRecovery.selector ||\n            methodId == SecurityManager.confirmGuardianAddition.selector ||\n            methodId == SecurityManager.confirmGuardianRevokation.selector)\n        {\n            // anyone\n            return (0, OwnerSignature.Anyone);\n        }\n        if (methodId == SecurityManager.lock.selector || methodId == SecurityManager.unlock.selector) {\n            // any guardian\n            return (1, OwnerSignature.Disallowed);\n        }\n        revert(\"SM: unknown method\");\n    }\n\n    function _majorityOfGuardians(address _wallet) internal view returns (uint) {\n        return Utils.ceil(guardianStorage.guardianCount(_wallet), 2);\n    }\n}"
18     },
19     "/Users/Elena/Source/argent-contracts/contracts/modules/RelayerManager.sol": {
20       "content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.3;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./common/Utils.sol\";\nimport \"./common/BaseModule.sol\";\nimport \"./common/SimpleOracle.sol\";\nimport \"../infrastructure/storage/IGuardianStorage.sol\";\n\n/**\n * @title RelayerManager\n * @notice Abstract Module to execute transactions signed by ETH-less accounts and sent by a relayer.\n * @author Julien Niset <julien@argent.xyz>, Olivier VDB <olivier@argent.xyz>\n */\nabstract contract RelayerManager is BaseModule, SimpleOracle {\n\n    uint256 constant internal BLOCKBOUND = 10000;\n\n    mapping (address => RelayerConfig) internal relayer;\n\n    struct RelayerConfig {\n        uint256 nonce;\n        mapping (bytes32 => bool) executedTx;\n    }\n\n    // Used to avoid stack too deep error\n    struct StackExtension {\n        uint256 requiredSignatures;\n        OwnerSignature ownerSignatureRequirement;\n        bytes32 signHash;\n        bool success;\n        bytes returnData;\n    }\n\n    event TransactionExecuted(address indexed wallet, bool indexed success, bytes returnData, bytes32 signedHash);\n    event Refund(address indexed wallet, address indexed refundAddress, address refundToken, uint256 refundAmount);\n\n    // *************** Constructor ************************ //\n\n    constructor(address _uniswapRouter) SimpleOracle(_uniswapRouter) {\n\n    }\n\n    /* ***************** External methods ************************* */\n\n    /**\n    * @notice Gets the number of valid signatures that must be provided to execute a\n    * specific relayed transaction.\n    * @param _wallet The target wallet.\n    * @param _data The data of the relayed transaction.\n    * @return The number of required signatures and the wallet owner signature requirement.\n    */\n    function getRequiredSignatures(address _wallet, bytes calldata _data) public view virtual returns (uint256, OwnerSignature);\n\n    /**\n    * @notice Executes a relayed transaction.\n    * @param _wallet The target wallet.\n    * @param _data The data for the relayed transaction\n    * @param _nonce The nonce used to prevent replay attacks.\n    * @param _signatures The signatures as a concatenated byte array.\n    * @param _gasPrice The max gas price (in token) to use for the gas refund.\n    * @param _gasLimit The max gas limit to use for the gas refund.\n    * @param _refundToken The token to use for the gas refund.\n    * @param _refundAddress The address refunded to prevent front-running.\n    */\n    function execute(\n        address _wallet,\n        bytes calldata _data,\n        uint256 _nonce,\n        bytes calldata _signatures,\n        uint256 _gasPrice,\n        uint256 _gasLimit,\n        address _refundToken,\n        address _refundAddress\n    )\n        external\n        returns (bool)\n    {\n        // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n        //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n        uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n        require(startGas >= _gasLimit, \"RM: not enough gas provided\");\n        require(verifyData(_wallet, _data), \"RM: Target of _data != _wallet\");\n\n        require(!_isLocked(_wallet) || _gasPrice == 0, \"RM: Locked wallet refund\");\n\n        StackExtension memory stack;\n        (stack.requiredSignatures, stack.ownerSignatureRequirement) = getRequiredSignatures(_wallet, _data);\n\n        require(stack.requiredSignatures > 0 || stack.ownerSignatureRequirement == OwnerSignature.Anyone, \"RM: Wrong signature requirement\");\n        require(stack.requiredSignatures * 65 == _signatures.length, \"RM: Wrong number of signatures\");\n        stack.signHash = getSignHash(\n            address(this),\n            0,\n            _data,\n            _nonce,\n            _gasPrice,\n            _gasLimit,\n            _refundToken,\n            _refundAddress);\n        require(checkAndUpdateUniqueness(\n            _wallet,\n            _nonce,\n            stack.signHash,\n            stack.requiredSignatures,\n            stack.ownerSignatureRequirement), \"RM: Duplicate request\");\n\n        if (stack.ownerSignatureRequirement == OwnerSignature.Session) {\n            require(validateSession(_wallet, stack.signHash, _signatures), \"RM: Invalid session\");\n        } else {\n            require(validateSignatures(_wallet, stack.signHash, _signatures, stack.ownerSignatureRequirement), \"RM: Invalid signatures\");\n        }\n        (stack.success, stack.returnData) = address(this).call(_data);\n        refund(\n            _wallet,\n            startGas,\n            _gasPrice,\n            _gasLimit,\n            _refundToken,\n            _refundAddress,\n            stack.requiredSignatures,\n            stack.ownerSignatureRequirement);\n        emit TransactionExecuted(_wallet, stack.success, stack.returnData, stack.signHash);\n        return stack.success;\n    }\n\n    /**\n    * @notice Gets the current nonce for a wallet.\n    * @param _wallet The target wallet.\n    */\n    function getNonce(address _wallet) external view returns (uint256 nonce) {\n        return relayer[_wallet].nonce;\n    }\n\n    /**\n    * @notice Checks if a transaction identified by its sign hash has already been executed.\n    * @param _wallet The target wallet.\n    * @param _signHash The sign hash of the transaction.\n    */\n    function isExecutedTx(address _wallet, bytes32 _signHash) external view returns (bool executed) {\n        return relayer[_wallet].executedTx[_signHash];\n    }\n\n    /**\n    * @notice Gets the last stored session for a wallet.\n    * @param _wallet The target wallet.\n    */\n    function getSession(address _wallet) external view returns (address key, uint64 expires) {\n        return (sessions[_wallet].key, sessions[_wallet].expires);\n    }\n\n    /* ***************** Internal & Private methods ************************* */\n\n    /**\n    * @notice Generates the signed hash of a relayed transaction according to ERC 1077.\n    * @param _from The starting address for the relayed transaction (should be the relayer module)\n    * @param _value The value for the relayed transaction.\n    * @param _data The data for the relayed transaction which includes the wallet address.\n    * @param _nonce The nonce used to prevent replay attacks.\n    * @param _gasPrice The max gas price (in token) to use for the gas refund.\n    * @param _gasLimit The max gas limit to use for the gas refund.\n    * @param _refundToken The token to use for the gas refund.\n    * @param _refundAddress The address refunded to prevent front-running.\n    */\n    function getSignHash(\n        address _from,\n        uint256 _value,\n        bytes memory _data,\n        uint256 _nonce,\n        uint256 _gasPrice,\n        uint256 _gasLimit,\n        address _refundToken,\n        address _refundAddress\n    )\n        internal\n        view\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(abi.encodePacked(\n                    bytes1(0x19),\n                    bytes1(0),\n                    _from,\n                    _value,\n                    _data,\n                    block.chainid,\n                    _nonce,\n                    _gasPrice,\n                    _gasLimit,\n                    _refundToken,\n                    _refundAddress))\n        ));\n    }\n\n    /**\n    * @notice Checks if the relayed transaction is unique. If yes the state is updated.\n    * For actions requiring 1 signature by the owner or a session key we use the incremental nonce.\n    * For all other actions we check/store the signHash in a mapping.\n    * @param _wallet The target wallet.\n    * @param _nonce The nonce.\n    * @param _signHash The signed hash of the transaction.\n    * @param requiredSignatures The number of signatures required.\n    * @param ownerSignatureRequirement The wallet owner signature requirement.\n    * @return true if the transaction is unique.\n    */\n    function checkAndUpdateUniqueness(\n        address _wallet,\n        uint256 _nonce,\n        bytes32 _signHash,\n        uint256 requiredSignatures,\n        OwnerSignature ownerSignatureRequirement\n    )\n        internal\n        returns (bool)\n    {\n        if (requiredSignatures == 1 &&\n            (ownerSignatureRequirement == OwnerSignature.Required || ownerSignatureRequirement == OwnerSignature.Session)) {\n            // use the incremental nonce\n            if (_nonce <= relayer[_wallet].nonce) {\n                return false;\n            }\n            uint256 nonceBlock = (_nonce & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;\n            if (nonceBlock > block.number + BLOCKBOUND) {\n                return false;\n            }\n            relayer[_wallet].nonce = _nonce;\n            return true;\n        } else {\n            // use the txHash map\n            if (relayer[_wallet].executedTx[_signHash] == true) {\n                return false;\n            }\n            relayer[_wallet].executedTx[_signHash] = true;\n            return true;\n        }\n    }\n\n    /**\n    * @notice Validates the signatures provided with a relayed transaction.\n    * @param _wallet The target wallet.\n    * @param _signHash The signed hash representing the relayed transaction.\n    * @param _signatures The signatures as a concatenated bytes array.\n    * @param _option An OwnerSignature enum indicating whether the owner is required, optional or disallowed.\n    * @return A boolean indicating whether the signatures are valid.\n    */\n    function validateSignatures(address _wallet, bytes32 _signHash, bytes memory _signatures, OwnerSignature _option) internal view returns (bool)\n    {\n        if (_signatures.length == 0) {\n            return true;\n        }\n        address lastSigner = address(0);\n        address[] memory guardians;\n        if (_option != OwnerSignature.Required || _signatures.length > 65) {\n            guardians = guardianStorage.getGuardians(_wallet); // guardians are only read if they may be needed\n        }\n        bool isGuardian;\n\n        for (uint256 i = 0; i < _signatures.length / 65; i++) {\n            address signer = Utils.recoverSigner(_signHash, _signatures, i);\n\n            if (i == 0) {\n                if (_option == OwnerSignature.Required) {\n                    // First signer must be owner\n                    if (_isOwner(_wallet, signer)) {\n                        continue;\n                    }\n                    return false;\n                } else if (_option == OwnerSignature.Optional) {\n                    // First signer can be owner\n                    if (_isOwner(_wallet, signer)) {\n                        continue;\n                    }\n                }\n            }\n            if (signer <= lastSigner) {\n                return false; // Signers must be different\n            }\n            lastSigner = signer;\n            (isGuardian, guardians) = Utils.isGuardianOrGuardianSigner(guardians, signer);\n            if (!isGuardian) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n    * @notice Validates the signature provided when a session key was used.\n    * @param _wallet The target wallet.\n    * @param _signHash The signed hash representing the relayed transaction.\n    * @param _signatures The signatures as a concatenated bytes array.\n    * @return A boolean indicating whether the signature is valid.\n    */\n    function validateSession(address _wallet, bytes32 _signHash, bytes calldata _signatures) internal view returns (bool) { \n        Session memory session = sessions[_wallet];\n        address signer = Utils.recoverSigner(_signHash, _signatures, 0);\n        return (signer == session.key && session.expires >= block.timestamp);\n    }\n\n    /**\n    * @notice Refunds the gas used to the Relayer.\n    * @param _wallet The target wallet.\n    * @param _startGas The gas provided at the start of the execution.\n    * @param _gasPrice The max gas price (in token) for the refund.\n    * @param _gasLimit The max gas limit for the refund.\n    * @param _refundToken The token to use for the gas refund.\n    * @param _refundAddress The address refunded to prevent front-running.\n    * @param _requiredSignatures The number of signatures required.\n    * @param _option An OwnerSignature enum indicating the signature requirement.\n    */\n    function refund(\n        address _wallet,\n        uint _startGas,\n        uint _gasPrice,\n        uint _gasLimit,\n        address _refundToken,\n        address _refundAddress,\n        uint256 _requiredSignatures,\n        OwnerSignature _option\n    )\n        internal\n    {\n        // Only refund when the owner is one of the signers or a session key was used\n        if (_gasPrice > 0 && (_option == OwnerSignature.Required || _option == OwnerSignature.Session)) {\n            address refundAddress = _refundAddress == address(0) ? msg.sender : _refundAddress;\n            if (_requiredSignatures == 1 && _option == OwnerSignature.Required) {\n                    // refundAddress must be whitelisted/authorised\n                    if (!authoriser.isAuthorised(_wallet, refundAddress, address(0), EMPTY_BYTES)) {\n                        uint whitelistAfter = userWhitelist.getWhitelist(_wallet, refundAddress);\n                        require(whitelistAfter > 0 && whitelistAfter < block.timestamp, \"RM: refund not authorised\");\n                    }\n            }\n            uint256 refundAmount;\n            if (_refundToken == ETH_TOKEN) {\n                // 23k as an upper bound to cover the rest of refund logic\n                uint256 gasConsumed = _startGas - gasleft() + 23000;\n                refundAmount = Math.min(gasConsumed, _gasLimit) * (Math.min(_gasPrice, tx.gasprice));\n                invokeWallet(_wallet, refundAddress, refundAmount, EMPTY_BYTES);\n            } else {\n                // 37.5k as an upper bound to cover the rest of refund logic\n                uint256 gasConsumed = _startGas - gasleft() + 37500;\n                uint256 tokenGasPrice = inToken(_refundToken, tx.gasprice);\n                refundAmount = Math.min(gasConsumed, _gasLimit) * (Math.min(_gasPrice, tokenGasPrice));\n                bytes memory methodData = abi.encodeWithSelector(ERC20.transfer.selector, refundAddress, refundAmount);\n                bytes memory transferSuccessBytes = invokeWallet(_wallet, _refundToken, 0, methodData);\n                // Check token refund is successful, when `transfer` returns a success bool result\n                if (transferSuccessBytes.length > 0) {\n                    require(abi.decode(transferSuccessBytes, (bool)), \"RM: Refund transfer failed\");\n                }\n            }\n            emit Refund(_wallet, refundAddress, _refundToken, refundAmount);    \n        }\n    }\n\n    /**\n    * @notice Checks that the wallet address provided as the first parameter of _data matches _wallet\n    * @return false if the addresses are different.\n    */\n    function verifyData(address _wallet, bytes calldata _data) internal pure returns (bool) {\n        require(_data.length >= 36, \"RM: Invalid dataWallet\");\n        address dataWallet = abi.decode(_data[4:], (address));\n        return dataWallet == _wallet;\n    }\n}"
21     },
22     "/Users/Elena/Source/argent-contracts/contracts/modules/SecurityManager.sol": {
23       "content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.3;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"./common/Utils.sol\";\nimport \"./common/BaseModule.sol\";\nimport \"../wallet/IWallet.sol\";\n\n/**\n * @title SecurityManager\n * @notice Abstract module implementing the key security features of the wallet: guardians, lock and recovery.\n * @author Julien Niset - <julien@argent.xyz>\n * @author Olivier Van Den Biggelaar - <olivier@argent.xyz>\n */\nabstract contract SecurityManager is BaseModule {\n\n    struct RecoveryConfig {\n        address recovery;\n        uint64 executeAfter;\n        uint32 guardianCount;\n    }\n\n    struct GuardianManagerConfig {\n        // The time at which a guardian addition or revokation will be confirmable by the owner\n        mapping (bytes32 => uint256) pending;\n    }\n\n    // Wallet specific storage for recovery\n    mapping (address => RecoveryConfig) internal recoveryConfigs;\n    // Wallet specific storage for pending guardian addition/revokation\n    mapping (address => GuardianManagerConfig) internal guardianConfigs;\n\n\n    // Recovery period\n    uint256 internal immutable recoveryPeriod;\n    // Lock period\n    uint256 internal immutable lockPeriod;\n    // The security period to add/remove guardians\n    uint256 internal immutable securityPeriod;\n    // The security window\n    uint256 internal immutable securityWindow;\n\n    // *************** Events *************************** //\n\n    event RecoveryExecuted(address indexed wallet, address indexed _recovery, uint64 executeAfter);\n    event RecoveryFinalized(address indexed wallet, address indexed _recovery);\n    event RecoveryCanceled(address indexed wallet, address indexed _recovery);\n    event OwnershipTransfered(address indexed wallet, address indexed _newOwner);\n    event Locked(address indexed wallet, uint64 releaseAfter);\n    event Unlocked(address indexed wallet);\n    event GuardianAdditionRequested(address indexed wallet, address indexed guardian, uint256 executeAfter);\n    event GuardianRevokationRequested(address indexed wallet, address indexed guardian, uint256 executeAfter);\n    event GuardianAdditionCancelled(address indexed wallet, address indexed guardian);\n    event GuardianRevokationCancelled(address indexed wallet, address indexed guardian);\n    event GuardianAdded(address indexed wallet, address indexed guardian);\n    event GuardianRevoked(address indexed wallet, address indexed guardian);\n    // *************** Modifiers ************************ //\n\n    /**\n     * @notice Throws if there is no ongoing recovery procedure.\n     */\n    modifier onlyWhenRecovery(address _wallet) {\n        require(recoveryConfigs[_wallet].executeAfter > 0, \"SM: no ongoing recovery\");\n        _;\n    }\n\n    /**\n     * @notice Throws if there is an ongoing recovery procedure.\n     */\n    modifier notWhenRecovery(address _wallet) {\n        require(recoveryConfigs[_wallet].executeAfter == 0, \"SM: ongoing recovery\");\n        _;\n    }\n\n    /**\n     * @notice Throws if the caller is not a guardian for the wallet or the module itself.\n     */\n    modifier onlyGuardianOrSelf(address _wallet) {\n        require(_isSelf(msg.sender) || isGuardian(_wallet, msg.sender), \"SM: must be guardian/self\");\n        _;\n    }\n\n    // *************** Constructor ************************ //\n\n    constructor(\n        uint256 _recoveryPeriod,\n        uint256 _securityPeriod,\n        uint256 _securityWindow,\n        uint256 _lockPeriod\n    ) {\n        // For the wallet to be secure we must have recoveryPeriod >= securityPeriod + securityWindow\n        // where securityPeriod and securityWindow are the security parameters of adding/removing guardians.\n        require(_lockPeriod >= _recoveryPeriod, \"SM: insecure lock period\");\n        require(_recoveryPeriod >= _securityPeriod + _securityWindow, \"SM: insecure security periods\");\n        recoveryPeriod = _recoveryPeriod;\n        lockPeriod = _lockPeriod;\n        securityWindow = _securityWindow;\n        securityPeriod = _securityPeriod;\n    }\n\n    // *************** External functions ************************ //\n\n    // *************** Recovery functions ************************ //\n\n    /**\n     * @notice Lets the guardians start the execution of the recovery procedure.\n     * Once triggered the recovery is pending for the security period before it can be finalised.\n     * Must be confirmed by N guardians, where N = ceil(Nb Guardians / 2).\n     * @param _wallet The target wallet.\n     * @param _recovery The address to which ownership should be transferred.\n     */\n    function executeRecovery(address _wallet, address _recovery) external onlySelf() notWhenRecovery(_wallet) {\n        validateNewOwner(_wallet, _recovery);\n        uint64 executeAfter = uint64(block.timestamp + recoveryPeriod);\n        recoveryConfigs[_wallet] = RecoveryConfig(_recovery, executeAfter, uint32(guardianStorage.guardianCount(_wallet)));\n        _setLock(_wallet, block.timestamp + lockPeriod, SecurityManager.executeRecovery.selector);\n        emit RecoveryExecuted(_wallet, _recovery, executeAfter);\n    }\n\n    /**\n     * @notice Finalizes an ongoing recovery procedure if the security period is over.\n     * The method is public and callable by anyone to enable orchestration.\n     * @param _wallet The target wallet.\n     */\n    function finalizeRecovery(address _wallet) external onlyWhenRecovery(_wallet) {\n        RecoveryConfig storage config = recoveryConfigs[_wallet];\n        require(uint64(block.timestamp) > config.executeAfter, \"SM: ongoing recovery period\");\n        address recoveryOwner = config.recovery;\n        delete recoveryConfigs[_wallet];\n\n        _clearSession(_wallet);\n\n        IWallet(_wallet).setOwner(recoveryOwner);\n        _setLock(_wallet, 0, bytes4(0));\n\n        emit RecoveryFinalized(_wallet, recoveryOwner);\n    }\n\n    /**\n     * @notice Lets the owner cancel an ongoing recovery procedure.\n     * Must be confirmed by N guardians, where N = ceil(Nb Guardian at executeRecovery + 1) / 2) - 1.\n     * @param _wallet The target wallet.\n     */\n    function cancelRecovery(address _wallet) external onlySelf() onlyWhenRecovery(_wallet) {\n        address recoveryOwner = recoveryConfigs[_wallet].recovery;\n        delete recoveryConfigs[_wallet];\n        _setLock(_wallet, 0, bytes4(0));\n\n        emit RecoveryCanceled(_wallet, recoveryOwner);\n    }\n\n    /**\n     * @notice Lets the owner transfer the wallet ownership. This is executed immediately.\n     * @param _wallet The target wallet.\n     * @param _newOwner The address to which ownership should be transferred.\n     */\n    function transferOwnership(address _wallet, address _newOwner) external onlySelf() onlyWhenUnlocked(_wallet) {\n        validateNewOwner(_wallet, _newOwner);\n        IWallet(_wallet).setOwner(_newOwner);\n\n        emit OwnershipTransfered(_wallet, _newOwner);\n    }\n\n    /**\n    * @notice Gets the details of the ongoing recovery procedure if any.\n    * @param _wallet The target wallet.\n    */\n    function getRecovery(address _wallet) external view returns(address _address, uint64 _executeAfter, uint32 _guardianCount) {\n        RecoveryConfig storage config = recoveryConfigs[_wallet];\n        return (config.recovery, config.executeAfter, config.guardianCount);\n    }\n\n    // *************** Lock functions ************************ //\n\n    /**\n     * @notice Lets a guardian lock a wallet.\n     * @param _wallet The target wallet.\n     */\n    function lock(address _wallet) external onlyGuardianOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\n        _setLock(_wallet, block.timestamp + lockPeriod, SecurityManager.lock.selector);\n        emit Locked(_wallet, uint64(block.timestamp + lockPeriod));\n    }\n\n    /**\n     * @notice Lets a guardian unlock a locked wallet.\n     * @param _wallet The target wallet.\n     */\n    function unlock(address _wallet) external onlyGuardianOrSelf(_wallet) onlyWhenLocked(_wallet) {\n        require(locks[_wallet].locker == SecurityManager.lock.selector, \"SM: cannot unlock\");\n        _setLock(_wallet, 0, bytes4(0));\n        emit Unlocked(_wallet);\n    }\n\n    /**\n     * @notice Returns the release time of a wallet lock or 0 if the wallet is unlocked.\n     * @param _wallet The target wallet.\n     * @return _releaseAfter The epoch time at which the lock will release (in seconds).\n     */\n    function getLock(address _wallet) external view returns(uint64 _releaseAfter) {\n        return _isLocked(_wallet) ? locks[_wallet].release : 0;\n    }\n\n    /**\n     * @notice Checks if a wallet is locked.\n     * @param _wallet The target wallet.\n     * @return _isLocked `true` if the wallet is locked otherwise `false`.\n     */\n    function isLocked(address _wallet) external view returns (bool) {\n        return _isLocked(_wallet);\n    }\n\n    // *************** Guardian functions ************************ //\n\n    /**\n     * @notice Lets the owner add a guardian to its wallet.\n     * The first guardian is added immediately. All following additions must be confirmed\n     * by calling the confirmGuardianAddition() method.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to add.\n     */\n    function addGuardian(address _wallet, address _guardian) external onlyWalletOwnerOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\n        require(!_isOwner(_wallet, _guardian), \"SM: guardian cannot be owner\");\n        require(!isGuardian(_wallet, _guardian), \"SM: duplicate guardian\");\n        // Guardians must either be an EOA or a contract with an owner()\n        // method that returns an address with a 25000 gas stipend.\n        // Note that this test is not meant to be strict and can be bypassed by custom malicious contracts.\n        (bool success,) = _guardian.call{gas: 25000}(abi.encodeWithSignature(\"owner()\"));\n        require(success, \"SM: must be EOA/Argent wallet\");\n\n        bytes32 id = keccak256(abi.encodePacked(_wallet, _guardian, \"addition\"));\n        GuardianManagerConfig storage config = guardianConfigs[_wallet];\n        require(\n            config.pending[id] == 0 || block.timestamp > config.pending[id] + securityWindow,\n            \"SM: duplicate pending addition\");\n        config.pending[id] = block.timestamp + securityPeriod;\n        emit GuardianAdditionRequested(_wallet, _guardian, block.timestamp + securityPeriod);\n    }\n\n    /**\n     * @notice Confirms the pending addition of a guardian to a wallet.\n     * The method must be called during the confirmation window and can be called by anyone to enable orchestration.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian.\n     */\n    function confirmGuardianAddition(address _wallet, address _guardian) external onlyWhenUnlocked(_wallet) {\n        bytes32 id = keccak256(abi.encodePacked(_wallet, _guardian, \"addition\"));\n        GuardianManagerConfig storage config = guardianConfigs[_wallet];\n        require(config.pending[id] > 0, \"SM: unknown pending addition\");\n        require(config.pending[id] < block.timestamp, \"SM: pending addition not over\");\n        require(block.timestamp < config.pending[id] + securityWindow, \"SM: pending addition expired\");\n        guardianStorage.addGuardian(_wallet, _guardian);\n        emit GuardianAdded(_wallet, _guardian);\n        delete config.pending[id];\n    }\n\n    /**\n     * @notice Lets the owner cancel a pending guardian addition.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian.\n     */\n    function cancelGuardianAddition(address _wallet, address _guardian) external onlyWalletOwnerOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\n        bytes32 id = keccak256(abi.encodePacked(_wallet, _guardian, \"addition\"));\n        GuardianManagerConfig storage config = guardianConfigs[_wallet];\n        require(config.pending[id] > 0, \"SM: unknown pending addition\");\n        delete config.pending[id];\n        emit GuardianAdditionCancelled(_wallet, _guardian);\n    }\n\n    /**\n     * @notice Lets the owner revoke a guardian from its wallet.\n     * @dev Revokation must be confirmed by calling the confirmGuardianRevokation() method.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to revoke.\n     */\n    function revokeGuardian(address _wallet, address _guardian) external onlyWalletOwnerOrSelf(_wallet) {\n        require(isGuardian(_wallet, _guardian), \"SM: must be existing guardian\");\n        bytes32 id = keccak256(abi.encodePacked(_wallet, _guardian, \"revokation\"));\n        GuardianManagerConfig storage config = guardianConfigs[_wallet];\n        require(\n            config.pending[id] == 0 || block.timestamp > config.pending[id] + securityWindow,\n            \"SM: duplicate pending revoke\"); // TODO need to allow if confirmation window passed\n        config.pending[id] = block.timestamp + securityPeriod;\n        emit GuardianRevokationRequested(_wallet, _guardian, block.timestamp + securityPeriod);\n    }\n\n    /**\n     * @notice Confirms the pending revokation of a guardian to a wallet.\n     * The method must be called during the confirmation window and can be called by anyone to enable orchestration.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian.\n     */\n    function confirmGuardianRevokation(address _wallet, address _guardian) external {\n        bytes32 id = keccak256(abi.encodePacked(_wallet, _guardian, \"revokation\"));\n        GuardianManagerConfig storage config = guardianConfigs[_wallet];\n        require(config.pending[id] > 0, \"SM: unknown pending revoke\");\n        require(config.pending[id] < block.timestamp, \"SM: pending revoke not over\");\n        require(block.timestamp < config.pending[id] + securityWindow, \"SM: pending revoke expired\");\n        guardianStorage.revokeGuardian(_wallet, _guardian);\n        emit GuardianRevoked(_wallet, _guardian);\n        delete config.pending[id];\n    }\n\n    /**\n     * @notice Lets the owner cancel a pending guardian revokation.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian.\n     */\n    function cancelGuardianRevokation(address _wallet, address _guardian) external onlyWalletOwnerOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\n        bytes32 id = keccak256(abi.encodePacked(_wallet, _guardian, \"revokation\"));\n        GuardianManagerConfig storage config = guardianConfigs[_wallet];\n        require(config.pending[id] > 0, \"SM: unknown pending revoke\");\n        delete config.pending[id];\n        emit GuardianRevokationCancelled(_wallet, _guardian);\n    }\n\n    /**\n     * @notice Checks if an address is a guardian for a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The address to check.\n     * @return _isGuardian `true` if the address is a guardian for the wallet otherwise `false`.\n     */\n    function isGuardian(address _wallet, address _guardian) public view returns (bool _isGuardian) {\n        return guardianStorage.isGuardian(_wallet, _guardian);\n    }\n\n    /**\n    * @notice Checks if an address is a guardian or an account authorised to sign on behalf of a smart-contract guardian.\n    * @param _wallet The target wallet.\n    * @param _guardian the address to test\n    * @return _isGuardian `true` if the address is a guardian for the wallet otherwise `false`.\n    */\n    function isGuardianOrGuardianSigner(address _wallet, address _guardian) external view returns (bool _isGuardian) {\n        (_isGuardian, ) = Utils.isGuardianOrGuardianSigner(guardianStorage.getGuardians(_wallet), _guardian);\n    }\n\n    /**\n     * @notice Counts the number of active guardians for a wallet.\n     * @param _wallet The target wallet.\n     * @return _count The number of active guardians for a wallet.\n     */\n    function guardianCount(address _wallet) external view returns (uint256 _count) {\n        return guardianStorage.guardianCount(_wallet);\n    }\n\n    /**\n     * @notice Get the active guardians for a wallet.\n     * @param _wallet The target wallet.\n     * @return _guardians the active guardians for a wallet.\n     */\n    function getGuardians(address _wallet) external view returns (address[] memory _guardians) {\n        return guardianStorage.getGuardians(_wallet);\n    }\n\n    // *************** Internal Functions ********************* //\n\n    function validateNewOwner(address _wallet, address _newOwner) internal view {\n        require(_newOwner != address(0), \"SM: new owner cannot be null\");\n        require(!isGuardian(_wallet, _newOwner), \"SM: new owner cannot be guardian\");\n    }\n\n    function _setLock(address _wallet, uint256 _releaseAfter, bytes4 _locker) internal {\n        locks[_wallet] = Lock(SafeCast.toUint64(_releaseAfter), _locker);\n    }\n}"
24     },
25     "/Users/Elena/Source/argent-contracts/contracts/modules/TransactionManager.sol": {
26       "content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.3;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"./common/Utils.sol\";\nimport \"./common/BaseModule.sol\";\nimport \"../../lib_0.5/other/ERC20.sol\";\n\n/**\n * @title TransactionManager\n * @notice Module to execute transactions in sequence to e.g. transfer tokens (ETH, ERC20, ERC721, ERC1155) or call third-party contracts.\n * @author Julien Niset - <julien@argent.xyz>\n */\nabstract contract TransactionManager is BaseModule {\n\n    // Static calls\n    bytes4 private constant ERC1271_IS_VALID_SIGNATURE = bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"));\n    bytes4 private constant ERC721_RECEIVED = bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n    bytes4 private constant ERC1155_RECEIVED = bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\n    bytes4 private constant ERC1155_BATCH_RECEIVED = bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"));\n    bytes4 private constant ERC165_INTERFACE = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n\n    struct Call {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    // The time delay for adding a trusted contact\n    uint256 internal immutable whitelistPeriod;\n\n    // *************** Events *************************** //\n\n    event AddedToWhitelist(address indexed wallet, address indexed target, uint64 whitelistAfter);\n    event RemovedFromWhitelist(address indexed wallet, address indexed target);\n    event SessionCreated(address indexed wallet, address sessionKey, uint64 expires);\n    event SessionCleared(address indexed wallet, address sessionKey);\n    // *************** Constructor ************************ //\n\n    constructor(uint256 _whitelistPeriod) {\n        whitelistPeriod = _whitelistPeriod;\n    }\n\n    // *************** External functions ************************ //\n\n    /**\n     * @notice Makes the target wallet execute a sequence of transactions authorised by the wallet owner.\n     * The method reverts if any of the inner transactions reverts.\n     * The method reverts if any of the inner transaction is not to a trusted contact or an authorised dapp.\n     * @param _wallet The target wallet.\n     * @param _transactions The sequence of transactions.\n     */\n    function multiCall(\n        address _wallet,\n        Call[] calldata _transactions\n    )\n        external\n        onlySelf()\n        onlyWhenUnlocked(_wallet)\n        returns (bytes[] memory)\n    {\n        bytes[] memory results = new bytes[](_transactions.length);\n        for(uint i = 0; i < _transactions.length; i++) {\n            address spender = Utils.recoverSpender(_transactions[i].to, _transactions[i].data);\n            require(\n                (_transactions[i].value == 0 || spender == _transactions[i].to) &&\n                (isWhitelisted(_wallet, spender) || authoriser.isAuthorised(_wallet, spender, _transactions[i].to, _transactions[i].data)),\n                \"TM: call not authorised\");\n            results[i] = invokeWallet(_wallet, _transactions[i].to, _transactions[i].value, _transactions[i].data);\n        }\n        return results;\n    }\n\n    /**\n     * @notice Makes the target wallet execute a sequence of transactions authorised by a session key.\n     * The method reverts if any of the inner transactions reverts.\n     * @param _wallet The target wallet.\n     * @param _transactions The sequence of transactions.\n     */\n    function multiCallWithSession(\n        address _wallet,\n        Call[] calldata _transactions\n    )\n        external\n        onlySelf()\n        onlyWhenUnlocked(_wallet)\n        returns (bytes[] memory)\n    {\n        return multiCallWithApproval(_wallet, _transactions);\n    }\n\n    /**\n     * @notice Makes the target wallet execute a sequence of transactions approved by a majority of guardians.\n     * The method reverts if any of the inner transactions reverts.\n     * @param _wallet The target wallet.\n     * @param _transactions The sequence of transactions.\n     */\n    function multiCallWithGuardians(\n        address _wallet,\n        Call[] calldata _transactions\n    )\n        external \n        onlySelf()\n        onlyWhenUnlocked(_wallet)\n        returns (bytes[] memory)\n    {\n        return multiCallWithApproval(_wallet, _transactions);\n    }\n\n    /**\n     * @notice Makes the target wallet execute a sequence of transactions approved by a majority of guardians.\n     * The method reverts if any of the inner transactions reverts.\n     * Upon success a new session is started.\n     * @param _wallet The target wallet.\n     * @param _transactions The sequence of transactions.\n     */\n    function multiCallWithGuardiansAndStartSession(\n        address _wallet,\n        Call[] calldata _transactions,\n        address _sessionUser,\n        uint64 _duration\n    )\n        external \n        onlySelf()\n        onlyWhenUnlocked(_wallet)\n        returns (bytes[] memory)\n    {\n        startSession(_wallet, _sessionUser, _duration);\n        return multiCallWithApproval(_wallet, _transactions);\n    }\n\n    /**\n    * @notice Clears the active session of a wallet if any.\n    * @param _wallet The target wallet.\n    */\n    function clearSession(address _wallet) external onlyWalletOwnerOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\n        emit SessionCleared(_wallet, sessions[_wallet].key);\n        _clearSession(_wallet);\n    }\n\n    /**\n     * @notice Adds an address to the list of trusted contacts.\n     * @param _wallet The target wallet.\n     * @param _target The address to add.\n     */\n    function addToWhitelist(address _wallet, address _target) external onlyWalletOwnerOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\n        require(_target != _wallet, \"TM: Cannot whitelist wallet\");\n        require(!registry.isRegisteredModule(_target), \"TM: Cannot whitelist module\");\n        require(!isWhitelisted(_wallet, _target), \"TM: target already whitelisted\");\n\n        uint256 whitelistAfter = block.timestamp + whitelistPeriod;\n        setWhitelist(_wallet, _target, whitelistAfter);\n        emit AddedToWhitelist(_wallet, _target, uint64(whitelistAfter));\n    }\n\n    /**\n     * @notice Removes an address from the list of trusted contacts.\n     * @param _wallet The target wallet.\n     * @param _target The address to remove.\n     */\n    function removeFromWhitelist(address _wallet, address _target) external onlyWalletOwnerOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\n        setWhitelist(_wallet, _target, 0);\n        emit RemovedFromWhitelist(_wallet, _target);\n    }\n\n    /**\n    * @notice Checks if an address is a trusted contact for a wallet.\n    * @param _wallet The target wallet.\n    * @param _target The address.\n    * @return _isWhitelisted true if the address is a trusted contact.\n    */\n    function isWhitelisted(address _wallet, address _target) public view returns (bool _isWhitelisted) {\n        uint whitelistAfter = userWhitelist.getWhitelist(_wallet, _target);\n        return whitelistAfter > 0 && whitelistAfter < block.timestamp;\n    }\n    \n    /*\n    * @notice Enable the static calls required to make the wallet compatible with the ERC1155TokenReceiver \n    * interface (see https://eips.ethereum.org/EIPS/eip-1155#erc-1155-token-receiver). This method only \n    * needs to be called for wallets deployed in version lower or equal to 2.4.0 as the ERC1155 static calls\n    * are not available by default for these versions of BaseWallet\n    * @param _wallet The target wallet.\n    */\n    function enableERC1155TokenReceiver(address _wallet) external onlyWalletOwnerOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\n        IWallet(_wallet).enableStaticCall(address(this), ERC165_INTERFACE);\n        IWallet(_wallet).enableStaticCall(address(this), ERC1155_RECEIVED);\n        IWallet(_wallet).enableStaticCall(address(this), ERC1155_BATCH_RECEIVED);\n    }\n\n    /**\n     * @inheritdoc IModule\n     */\n    function supportsStaticCall(bytes4 _methodId) external pure override returns (bool _isSupported) {\n        return _methodId == ERC1271_IS_VALID_SIGNATURE ||\n               _methodId == ERC721_RECEIVED ||\n               _methodId == ERC165_INTERFACE ||\n               _methodId == ERC1155_RECEIVED ||\n               _methodId == ERC1155_BATCH_RECEIVED;\n    }\n\n    /** ******************* Callbacks ************************** */\n\n    /**\n     * @notice Returns true if this contract implements the interface defined by\n     * `interfaceId` (see https://eips.ethereum.org/EIPS/eip-165).\n     */\n    function supportsInterface(bytes4 _interfaceID) external pure returns (bool) {\n        return  _interfaceID == ERC165_INTERFACE || _interfaceID == (ERC1155_RECEIVED ^ ERC1155_BATCH_RECEIVED);          \n    }\n\n    /**\n    * @notice Implementation of EIP 1271.\n    * Should return whether the signature provided is valid for the provided data.\n    * @param _msgHash Hash of a message signed on the behalf of address(this)\n    * @param _signature Signature byte array associated with _msgHash\n    */\n    function isValidSignature(bytes32 _msgHash, bytes memory _signature) external view returns (bytes4) {\n        require(_signature.length == 65, \"TM: invalid signature length\");\n        address signer = Utils.recoverSigner(_msgHash, _signature, 0);\n        require(_isOwner(msg.sender, signer), \"TM: Invalid signer\");\n        return ERC1271_IS_VALID_SIGNATURE;\n    }\n\n\n    fallback() external {\n        bytes4 methodId = Utils.functionPrefix(msg.data);\n        if(methodId == ERC721_RECEIVED || methodId == ERC1155_RECEIVED || methodId == ERC1155_BATCH_RECEIVED) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {                \n                calldatacopy(0, 0, 0x04)\n                return (0, 0x20)\n            }\n        }\n    }\n\n    // *************** Internal Functions ********************* //\n\n    function enableDefaultStaticCalls(address _wallet) internal {\n        // setup the static calls that are available for free for all wallets\n        IWallet(_wallet).enableStaticCall(address(this), ERC1271_IS_VALID_SIGNATURE);\n        IWallet(_wallet).enableStaticCall(address(this), ERC721_RECEIVED);\n    }\n\n    function multiCallWithApproval(address _wallet, Call[] calldata _transactions) internal returns (bytes[] memory) {\n        bytes[] memory results = new bytes[](_transactions.length);\n        for(uint i = 0; i < _transactions.length; i++) {\n            results[i] = invokeWallet(_wallet, _transactions[i].to, _transactions[i].value, _transactions[i].data);\n        }\n        return results;\n    }\n\n    function startSession(address _wallet, address _sessionUser, uint64 _duration) internal {\n        require(_sessionUser != address(0), \"TM: Invalid session user\");\n        require(_duration > 0, \"TM: Invalid session duration\");\n\n        uint64 expiry = SafeCast.toUint64(block.timestamp + _duration);\n        sessions[_wallet] = Session(_sessionUser, expiry);\n        emit SessionCreated(_wallet, _sessionUser, expiry);\n    }\n\n    function setWhitelist(address _wallet, address _target, uint256 _whitelistAfter) internal {\n        userWhitelist.setWhitelist(_wallet, _target, _whitelistAfter);\n    }\n}"
27     },
28     "/Users/Elena/Source/argent-contracts/contracts/modules/common/BaseModule.sol": {
29       "content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.3;\n\nimport \"../../wallet/IWallet.sol\";\nimport \"../../infrastructure/IModuleRegistry.sol\";\nimport \"../../infrastructure/storage/IGuardianStorage.sol\";\nimport \"../../infrastructure/IAuthoriser.sol\";\nimport \"../../infrastructure/storage/ITransferStorage.sol\";\nimport \"./IModule.sol\";\nimport \"../../../lib_0.5/other/ERC20.sol\";\n\n/**\n * @title BaseModule\n * @notice Base Module contract that contains methods common to all Modules.\n * @author Julien Niset - <julien@argent.xyz>, Olivier VDB - <olivier@argent.xyz>\n */\nabstract contract BaseModule is IModule {\n\n    // Empty calldata\n    bytes constant internal EMPTY_BYTES = \"\";\n    // Mock token address for ETH\n    address constant internal ETH_TOKEN = address(0);\n\n    // The module registry\n    IModuleRegistry internal immutable registry;\n    // The guardians storage\n    IGuardianStorage internal immutable guardianStorage;\n    // The trusted contacts storage\n    ITransferStorage internal immutable userWhitelist;\n    // The authoriser\n    IAuthoriser internal immutable authoriser;\n\n    event ModuleCreated(bytes32 name);\n\n    enum OwnerSignature {\n        Anyone,             // Anyone\n        Required,           // Owner required\n        Optional,           // Owner and/or guardians\n        Disallowed,         // Guardians only\n        Session             // Session only\n    }\n\n    struct Session {\n        address key;\n        uint64 expires;\n    }\n\n    // Maps wallet to session\n    mapping (address => Session) internal sessions;\n\n    struct Lock {\n        // the lock's release timestamp\n        uint64 release;\n        // the signature of the method that set the last lock\n        bytes4 locker;\n    }\n    \n    // Wallet specific lock storage\n    mapping (address => Lock) internal locks;\n\n    /**\n     * @notice Throws if the wallet is not locked.\n     */\n    modifier onlyWhenLocked(address _wallet) {\n        require(_isLocked(_wallet), \"BM: wallet must be locked\");\n        _;\n    }\n\n    /**\n     * @notice Throws if the wallet is locked.\n     */\n    modifier onlyWhenUnlocked(address _wallet) {\n        require(!_isLocked(_wallet), \"BM: wallet locked\");\n        _;\n    }\n\n    /**\n     * @notice Throws if the sender is not the module itself.\n     */\n    modifier onlySelf() {\n        require(_isSelf(msg.sender), \"BM: must be module\");\n        _;\n    }\n\n    /**\n     * @notice Throws if the sender is not the module itself or the owner of the target wallet.\n     */\n    modifier onlyWalletOwnerOrSelf(address _wallet) {\n        require(_isSelf(msg.sender) || _isOwner(_wallet, msg.sender), \"BM: must be wallet owner/self\");\n        _;\n    }\n\n    /**\n     * @dev Throws if the sender is not the target wallet of the call.\n     */\n    modifier onlyWallet(address _wallet) {\n        require(msg.sender == _wallet, \"BM: caller must be wallet\");\n        _;\n    }\n\n    constructor(\n        IModuleRegistry _registry,\n        IGuardianStorage _guardianStorage,\n        ITransferStorage _userWhitelist,\n        IAuthoriser _authoriser,\n        bytes32 _name\n    ) {\n        registry = _registry;\n        guardianStorage = _guardianStorage;\n        userWhitelist = _userWhitelist;\n        authoriser = _authoriser;\n        emit ModuleCreated(_name);\n    }\n\n    /**\n     * @notice Moves tokens that have been sent to the module by mistake.\n     * @param _token The target token.\n     */\n    function recoverToken(address _token) external {\n        uint total = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).transfer(address(registry), total);\n    }\n\n    function _clearSession(address _wallet) internal {\n        delete sessions[_wallet];\n    }\n    \n    /**\n     * @notice Helper method to check if an address is the owner of a target wallet.\n     * @param _wallet The target wallet.\n     * @param _addr The address.\n     */\n    function _isOwner(address _wallet, address _addr) internal view returns (bool) {\n        return IWallet(_wallet).owner() == _addr;\n    }\n\n    /**\n     * @notice Helper method to check if a wallet is locked.\n     * @param _wallet The target wallet.\n     */\n    function _isLocked(address _wallet) internal view returns (bool) {\n        return locks[_wallet].release > uint64(block.timestamp);\n    }\n\n    /**\n     * @notice Helper method to check if an address is the module itself.\n     * @param _addr The target address.\n     */\n    function _isSelf(address _addr) internal view returns (bool) {\n        return _addr == address(this);\n    }\n\n    /**\n     * @notice Helper method to invoke a wallet.\n     * @param _wallet The target wallet.\n     * @param _to The target address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function invokeWallet(address _wallet, address _to, uint256 _value, bytes memory _data) internal returns (bytes memory _res) {\n        bool success;\n        (success, _res) = _wallet.call(abi.encodeWithSignature(\"invoke(address,uint256,bytes)\", _to, _value, _data));\n        if (success && _res.length > 0) { //_res is empty if _wallet is an \"old\" BaseWallet that can't return output values\n            (_res) = abi.decode(_res, (bytes));\n        } else if (_res.length > 0) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        } else if (!success) {\n            revert(\"BM: wallet invoke reverted\");\n        }\n    }\n}"
30     },
31     "/Users/Elena/Source/argent-contracts/contracts/modules/common/IModule.sol": {
32       "content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.3;\n\n/**\n * @title IModule\n * @notice Interface for a Module.\n * @author Julien Niset - <julien@argent.xyz>, Olivier VDB - <olivier@argent.xyz>\n */\ninterface IModule {\n\n    /**\t\n     * @notice Adds a module to a wallet. Cannot execute when wallet is locked (or under recovery)\t\n     * @param _wallet The target wallet.\t\n     * @param _module The modules to authorise.\t\n     */\t\n    function addModule(address _wallet, address _module) external;\n\n    /**\n     * @notice Inits a Module for a wallet by e.g. setting some wallet specific parameters in storage.\n     * @param _wallet The wallet.\n     */\n    function init(address _wallet) external;\n\n\n    /**\n     * @notice Returns whether the module implements a callback for a given static call method.\n     * @param _methodId The method id.\n     */\n    function supportsStaticCall(bytes4 _methodId) external view returns (bool _isSupported);\n}"
33     },
34     "/Users/Elena/Source/argent-contracts/contracts/modules/common/SimpleOracle.sol": {
35       "content": "// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.3;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\ncontract SimpleOracle {\n\n    address internal immutable weth;\n    address internal immutable uniswapV2Factory;\n\n    constructor(address _uniswapRouter) {\n        weth = IUniswapV2Router01(_uniswapRouter).WETH();\n        uniswapV2Factory = IUniswapV2Router01(_uniswapRouter).factory();\n    }\n\n    function inToken(address _token, uint256 _ethAmount) internal view returns (uint256) {\n        (uint256 wethReserve, uint256 tokenReserve) = getReservesForTokenPool(_token);\n        return _ethAmount * tokenReserve / wethReserve;\n    }\n\n    function getReservesForTokenPool(address _token) internal view returns (uint256 wethReserve, uint256 tokenReserve) {\n        if (weth < _token) {\n            address pair = getPairForSorted(weth, _token);\n            (wethReserve, tokenReserve,) = IUniswapV2Pair(pair).getReserves();\n        } else {\n            address pair = getPairForSorted(_token, weth);\n            (tokenReserve, wethReserve,) = IUniswapV2Pair(pair).getReserves();\n        }\n        require(wethReserve != 0 && tokenReserve != 0, \"SO: no liquidity\");\n    }\n\n    function getPairForSorted(address tokenA, address tokenB) internal virtual view returns (address pair) {    \n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\n                hex'ff',\n                uniswapV2Factory,\n                keccak256(abi.encodePacked(tokenA, tokenB)),\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'\n            )))));\n    }\n}"
36     },
37     "/Users/Elena/Source/argent-contracts/contracts/modules/common/Utils.sol": {
38       "content": "// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.3;\n\n/**\n * @title Utils\n * @notice Common utility methods used by modules.\n */\nlibrary Utils {\n\n    // ERC20, ERC721 & ERC1155 transfers & approvals\n    bytes4 private constant ERC20_TRANSFER = bytes4(keccak256(\"transfer(address,uint256)\"));\n    bytes4 private constant ERC20_APPROVE = bytes4(keccak256(\"approve(address,uint256)\"));\n    bytes4 private constant ERC721_SET_APPROVAL_FOR_ALL = bytes4(keccak256(\"setApprovalForAll(address,bool)\"));\n    bytes4 private constant ERC721_TRANSFER_FROM = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM = bytes4(keccak256(\"safeTransferFrom(address,address,uint256)\"));\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM_BYTES = bytes4(keccak256(\"safeTransferFrom(address,address,uint256,bytes)\"));\n    bytes4 private constant ERC1155_SAFE_TRANSFER_FROM = bytes4(keccak256(\"safeTransferFrom(address,address,uint256,uint256,bytes)\"));\n\n    bytes4 private constant OWNER_SIG = 0x8da5cb5b;\n    /**\n    * @notice Helper method to recover the signer at a given position from a list of concatenated signatures.\n    * @param _signedHash The signed hash\n    * @param _signatures The concatenated signatures.\n    * @param _index The index of the signature to recover.\n    */\n    function recoverSigner(bytes32 _signedHash, bytes memory _signatures, uint _index) internal pure returns (address) {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        // we jump 32 (0x20) as the first slot of bytes contains the length\n        // we jump 65 (0x41) per signature\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\n        }\n        require(v == 27 || v == 28, \"Utils: bad v value in signature\");\n\n        address recoveredAddress = ecrecover(_signedHash, v, r, s);\n        require(recoveredAddress != address(0), \"Utils: ecrecover returned 0\");\n        return recoveredAddress;\n    }\n\n    /**\n    * @notice Helper method to recover the spender from a contract call. \n    * The method returns the contract unless the call is to a standard method of a ERC20/ERC721/ERC1155 token\n    * in which case the spender is recovered from the data.\n    * @param _to The target contract.\n    * @param _data The data payload.\n    */\n    function recoverSpender(address _to, bytes memory _data) internal pure returns (address spender) {\n        if(_data.length >= 68) {\n            bytes4 methodId;\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                methodId := mload(add(_data, 0x20))\n            }\n            if(\n                methodId == ERC20_TRANSFER ||\n                methodId == ERC20_APPROVE ||\n                methodId == ERC721_SET_APPROVAL_FOR_ALL) \n            {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    spender := mload(add(_data, 0x24))\n                }\n                return spender;\n            }\n            if(\n                methodId == ERC721_TRANSFER_FROM ||\n                methodId == ERC721_SAFE_TRANSFER_FROM ||\n                methodId == ERC721_SAFE_TRANSFER_FROM_BYTES ||\n                methodId == ERC1155_SAFE_TRANSFER_FROM)\n            {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    spender := mload(add(_data, 0x44))\n                }\n                return spender;\n            }\n        }\n\n        spender = _to;\n    }\n\n    /**\n    * @notice Helper method to parse data and extract the method signature.\n    */\n    function functionPrefix(bytes memory _data) internal pure returns (bytes4 prefix) {\n        require(_data.length >= 4, \"Utils: Invalid functionPrefix\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            prefix := mload(add(_data, 0x20))\n        }\n    }\n\n    /**\n    * @notice Checks if an address is a contract.\n    * @param _addr The address.\n    */\n    function isContract(address _addr) internal view returns (bool) {\n        uint32 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size > 0);\n    }\n\n    /**\n    * @notice Checks if an address is a guardian or an account authorised to sign on behalf of a smart-contract guardian\n    * given a list of guardians.\n    * @param _guardians the list of guardians\n    * @param _guardian the address to test\n    * @return true and the list of guardians minus the found guardian upon success, false and the original list of guardians if not found.\n    */\n    function isGuardianOrGuardianSigner(address[] memory _guardians, address _guardian) internal view returns (bool, address[] memory) {\n        if (_guardians.length == 0 || _guardian == address(0)) {\n            return (false, _guardians);\n        }\n        bool isFound = false;\n        address[] memory updatedGuardians = new address[](_guardians.length - 1);\n        uint256 index = 0;\n        for (uint256 i = 0; i < _guardians.length; i++) {\n            if (!isFound) {\n                // check if _guardian is an account guardian\n                if (_guardian == _guardians[i]) {\n                    isFound = true;\n                    continue;\n                }\n                // check if _guardian is the owner of a smart contract guardian\n                if (isContract(_guardians[i]) && isGuardianOwner(_guardians[i], _guardian)) {\n                    isFound = true;\n                    continue;\n                }\n            }\n            if (index < updatedGuardians.length) {\n                updatedGuardians[index] = _guardians[i];\n                index++;\n            }\n        }\n        return isFound ? (true, updatedGuardians) : (false, _guardians);\n    }\n\n    /**\n    * @notice Checks if an address is the owner of a guardian contract.\n    * The method does not revert if the call to the owner() method consumes more then 25000 gas.\n    * @param _guardian The guardian contract\n    * @param _owner The owner to verify.\n    */\n    function isGuardianOwner(address _guardian, address _owner) internal view returns (bool) {\n        address owner = address(0);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr,OWNER_SIG)\n            let result := staticcall(25000, _guardian, ptr, 0x20, ptr, 0x20)\n            if eq(result, 1) {\n                owner := mload(ptr)\n            }\n        }\n        return owner == _owner;\n    }\n\n    /**\n    * @notice Returns ceil(a / b).\n    */\n    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        if (a % b == 0) {\n            return c;\n        } else {\n            return c + 1;\n        }\n    }\n}\n"
39     },
40     "/Users/Elena/Source/argent-contracts/contracts/wallet/IWallet.sol": {
41       "content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.9.0;\n\n/**\n * @title IWallet\n * @notice Interface for the BaseWallet\n */\ninterface IWallet {\n    /**\n     * @notice Returns the wallet owner.\n     * @return The wallet owner address.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Returns the number of authorised modules.\n     * @return The number of authorised modules.\n     */\n    function modules() external view returns (uint);\n\n    /**\n     * @notice Sets a new owner for the wallet.\n     * @param _newOwner The new owner.\n     */\n    function setOwner(address _newOwner) external;\n\n    /**\n     * @notice Checks if a module is authorised on the wallet.\n     * @param _module The module address to check.\n     * @return `true` if the module is authorised, otherwise `false`.\n     */\n    function authorised(address _module) external view returns (bool);\n\n    /**\n     * @notice Returns the module responsible for a static call redirection.\n     * @param _sig The signature of the static call.\n     * @return the module doing the redirection\n     */\n    function enabled(bytes4 _sig) external view returns (address);\n\n    /**\n     * @notice Enables/Disables a module.\n     * @param _module The target module.\n     * @param _value Set to `true` to authorise the module.\n     */\n    function authoriseModule(address _module, bool _value) external;\n\n    /**\n    * @notice Enables a static method by specifying the target module to which the call must be delegated.\n    * @param _module The target module.\n    * @param _method The static method signature.\n    */\n    function enableStaticCall(address _module, bytes4 _method) external;\n}"
42     },
43     "/Users/Elena/Source/argent-contracts/lib_0.5/other/ERC20.sol": {
44       "content": "pragma solidity >=0.5.4 <0.9.0;\n\n/**\n * ERC20 contract interface.\n */\ninterface ERC20 {\n    function totalSupply() external view returns (uint);\n    function decimals() external view returns (uint);\n    function balanceOf(address tokenOwner) external view returns (uint balance);\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n    function transfer(address to, uint tokens) external returns (bool success);\n    function approve(address spender, uint tokens) external returns (bool success);\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n}"
45     },
46     "@openzeppelin/contracts/utils/math/Math.sol": {
47       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
48     },
49     "@openzeppelin/contracts/utils/math/SafeCast.sol": {
50       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
51     },
52     "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
53       "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
54     },
55     "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
56       "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
57     }
58   },
59   "settings": {
60     "remappings": [],
61     "optimizer": {
62       "enabled": true,
63       "runs": 300
64     },
65     "evmVersion": "istanbul",
66     "libraries": {
67       "": {}
68     },
69     "outputSelection": {
70       "*": {
71         "*": [
72           "evm.bytecode",
73           "evm.deployedBytecode",
74           "abi"
75         ]
76       }
77     }
78   }
79 }}