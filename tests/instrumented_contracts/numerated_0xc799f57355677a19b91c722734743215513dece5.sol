1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "london",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "details": {
12         "constantOptimizer": true,
13         "cse": true,
14         "deduplicate": true,
15         "inliner": true,
16         "jumpdestRemover": true,
17         "orderLiterals": true,
18         "peephole": true,
19         "yul": true,
20         "yulDetails": {
21           "optimizerSteps": "dhfoDgvulfnTUtnIf",
22           "stackAllocation": true
23         }
24       },
25       "runs": 2000
26     },
27     "remappings": [],
28     "outputSelection": {
29       "*": {
30         "*": [
31           "evm.bytecode",
32           "evm.deployedBytecode",
33           "devdoc",
34           "userdoc",
35           "metadata",
36           "abi"
37         ]
38       }
39     }
40   },
41   "sources": {
42     "@openzeppelin/contracts/security/Pausable.sol": {
43       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
44     },
45     "@openzeppelin/contracts/utils/Context.sol": {
46       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
47     },
48     "contracts/Colonist.sol": {
49       "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"./ERC721.sol\";\r\nimport \"./interfaces/IColonist.sol\";\r\nimport \"./interfaces/ITColonist.sol\";\r\nimport \"./interfaces/IHColonist.sol\";\r\nimport \"./interfaces/IEON.sol\";\r\nimport \"./interfaces/IPytheas.sol\";\r\nimport \"./interfaces/IRandomizer.sol\";\r\n\r\ncontract Colonist is IColonist, ERC721, Pausable {\r\n    /*///////////////////////////////////////////////////////\r\n                    Global STATE\r\n    ///////////////////////////////////////////////////////*/\r\n\r\n    event ColonistMinted(uint256 indexed tokenId);\r\n    event ColonistBurned(uint256 indexed tokenId);\r\n    event ColonistStolen(uint256 indexed tokenId);\r\n    event ColonistNamed(uint256 indexed tokenId, string newName);\r\n\r\n    // toggle naming\r\n    bool public namingActive;\r\n\r\n    // max number of tokens that can be minted - 60000\r\n    uint256 public MAX_TOKENS = 60000;\r\n\r\n    // number of ERC721s for sale in eth\r\n    uint256 public PAID_TOKENS = 10000;\r\n\r\n    // an arbatrary counter to dish out IDs\r\n    uint16 public override minted;\r\n\r\n    // counter of colonist in circulation\r\n    uint256 public override totalCir;\r\n\r\n    // counter of _mint to honors amount\r\n    uint256 public honorMints;\r\n\r\n    // max number of colonist to mint to honor members\r\n    uint256 public constant maxHonorMints = 450;\r\n\r\n    // cost to name\r\n    uint256 public constant costToName = 2000 ether;\r\n\r\n    // mapping from tokenId to a struct containing the colonist token's traits\r\n    mapping(uint256 => Colonist) public tokenTraitsColonist;\r\n\r\n    // mapping from tokenId to a stuct containing the honors colonist\r\n    mapping(uint256 => HColonist) public tokenTraitsHonors;\r\n    mapping(uint256 => bool) public isHonors;\r\n\r\n    // mapping from hashed(tokenTrait) to the tokenId it's associated with\r\n    // used to ensure there are no duplicates\r\n    mapping(uint256 => uint256) public existingCombinations;\r\n\r\n    // Mapping from token ID to name\r\n    mapping(uint256 => string) private _tokenName;\r\n    mapping(uint256 => bool) private _hasName;\r\n\r\n    // Mapping if certain name string has already been reserved\r\n    mapping(string => bool) private _nameReserved;\r\n\r\n    // address => used in allowing system communication between contracts\r\n    mapping(address => bool) private admins;\r\n\r\n    // list of probabilities for each trait type\r\n    uint8[][8] public rarities;\r\n    uint8[][8] public aliases;\r\n\r\n    // reference to the Pytheas for transfers without approval\r\n    IPytheas public pytheas;\r\n\r\n    // reference to Traits\r\n    ITColonist public traits;\r\n\r\n    // reference to honors traits\r\n    IHColonist public honorTraits;\r\n\r\n    //reference to Randomizer\r\n    IRandomizer public randomizer;\r\n\r\n    //reference to EON\r\n    IEON public EON;\r\n\r\n    address public pirateGames;\r\n\r\n    address private imperialGuildTreasury;\r\n\r\n    address public auth;\r\n\r\n    /**\r\n     * instantiates contract and rarity tables\r\n     */\r\n    constructor() ERC721(\"ShatteredEon\", \"Colonists\") {\r\n        auth = msg.sender;\r\n        admins[msg.sender] = true;\r\n\r\n        // Saves users gas by making lookup O(1)\r\n        // A.J. Walker's Alias Algorithm\r\n        // Credit to WolfGame devs\r\n        // colonist\r\n        // background\r\n        rarities[0] = [255, 255, 255, 255, 255];\r\n        aliases[0] = [4, 1, 0, 3, 2];\r\n        // body\r\n        rarities[1] = [255, 220, 210, 255, 220, 200];\r\n        aliases[1] = [0, 1, 2, 3, 4, 5];\r\n        // shirt\r\n        rarities[2] = [120, 150, 150, 120, 20, 200, 255, 255, 190, 255, 40];\r\n        aliases[2] = [6, 7, 6, 7, 9, 6, 7, 9, 0, 1, 0];\r\n        // jacket\r\n        rarities[3] = [\r\n            20,\r\n            100,\r\n            205,\r\n            185,\r\n            235,\r\n            195,\r\n            215,\r\n            190,\r\n            215,\r\n            130,\r\n            40,\r\n            30,\r\n            220,\r\n            255\r\n        ];\r\n        aliases[3] = [3, 13, 5, 13, 13, 9, 13, 7, 13, 3, 13, 13, 12, 13];\r\n        // jaw\r\n        rarities[4] = [255, 255, 100, 110, 250, 125, 245, 40, 200, 35, 255];\r\n        aliases[4] = [0, 1, 1, 6, 0, 2, 1, 6, 9, 2, 1];\r\n        // hair\r\n        rarities[5] = [\r\n            245,\r\n            245,\r\n            120,\r\n            245,\r\n            200,\r\n            245,\r\n            245,\r\n            122,\r\n            220,\r\n            225,\r\n            175,\r\n            40,\r\n            25,\r\n            233\r\n        ];\r\n        aliases[5] = [1, 4, 5, 8, 9, 13, 13, 9, 8, 5, 4, 1, 13, 1];\r\n        // eyes\r\n        rarities[6] = [60, 225, 200, 50, 90, 200, 145, 125, 50, 255];\r\n        aliases[6] = [2, 1, 9, 1, 9, 5, 1, 1, 9, 9];\r\n        //held\r\n        rarities[7] = [\r\n            220,\r\n            245,\r\n            139,\r\n            120,\r\n            120,\r\n            230,\r\n            190,\r\n            35,\r\n            40,\r\n            245,\r\n            190,\r\n            90,\r\n            134\r\n        ];\r\n        aliases[7] = [0, 1, 5, 4, 6, 10, 1, 0, 1, 5, 4, 1, 0];\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == auth);\r\n        _;\r\n    }\r\n\r\n    function setContracts(\r\n        address _traits,\r\n        address _honorTraits,\r\n        address _pytheas,\r\n        address _rand,\r\n        address _pirateGames,\r\n        address _eon\r\n    ) external onlyOwner {\r\n        traits = ITColonist(_traits);\r\n        honorTraits = IHColonist(_honorTraits);\r\n        pytheas = IPytheas(_pytheas);\r\n        randomizer = IRandomizer(_rand);\r\n        EON = IEON(_eon);\r\n        pirateGames = _pirateGames;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                    EXTERNAL\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /**\r\n     * Mint a token - any payment / game logic should be handled in the game contract.\r\n     * This will just generate random traits and mint a token to a designated address.\r\n     */\r\n    function _mintColonist(address recipient, uint256 seed) external override {\r\n        require(admins[msg.sender], \"Only Admins\");\r\n        require(minted + 1 <= MAX_TOKENS, \"All colonists deployed\");\r\n        minted++;\r\n        totalCir++;\r\n        generateColonist(minted, seed);\r\n        if (tx.origin != recipient && recipient != address(pytheas)) {\r\n            // Stolen!\r\n            emit ColonistStolen(minted);\r\n        }\r\n        _mint(recipient, minted);\r\n    }\r\n\r\n    function _mintHonors(address recipient, uint8 id) external whenNotPaused {\r\n        require(admins[msg.sender], \"Only Admins\");\r\n        require(minted + 1 <= MAX_TOKENS, \"All colonist deployed\");\r\n        minted++;\r\n        totalCir++;\r\n        generateHonors(minted, id);\r\n        _mint(recipient, minted);\r\n    }\r\n\r\n    function _mintToHonors(address recipient, uint256 seed) external override {\r\n        require(admins[msg.sender], \"Only Admins\");\r\n        require(minted + 1 <= MAX_TOKENS, \"All colonists deployed\");\r\n        require(\r\n            honorMints + 1 <= maxHonorMints,\r\n            \"All honor mints have been sent\"\r\n        );\r\n        minted++;\r\n        totalCir++;\r\n        generateColonist(minted, seed);\r\n        _mint(recipient, minted);\r\n    }\r\n\r\n    /**\r\n     * Burn a token - any game logic should be handled before this function.\r\n     */\r\n    function burn(uint256 tokenId) external override whenNotPaused {\r\n        require(admins[msg.sender]);\r\n        require(\r\n            ownerOf[tokenId] == tx.origin ||\r\n                msg.sender == address(pytheas) ||\r\n                msg.sender == address(pirateGames),\r\n            \"Colonist: Not Owner\"\r\n        );\r\n        totalCir--;\r\n        _burn(tokenId);\r\n        emit ColonistBurned(tokenId);\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id\r\n    ) public override(ERC721, IColonist) {\r\n        require(from == ownerOf[id], \"WRONG_FROM\");\r\n\r\n        require(to != address(0), \"INVALID_RECIPIENT\");\r\n        // allow admin contracts to send without approval\r\n        if (!admins[msg.sender]) {\r\n            require(\r\n                msg.sender == from ||\r\n                    msg.sender == getApproved[id] ||\r\n                    isApprovedForAll[from][msg.sender],\r\n                \"NOT_AUTHORIZED\"\r\n            );\r\n        }\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        unchecked {\r\n            balanceOf[from]--;\r\n\r\n            balanceOf[to]++;\r\n        }\r\n\r\n        ownerOf[id] = to;\r\n\r\n        delete getApproved[id];\r\n\r\n        emit Transfer(from, to, id);\r\n    }\r\n\r\n    function generateColonist(uint256 tokenId, uint256 seed)\r\n        internal\r\n        returns (Colonist memory t)\r\n    {\r\n        t = selectColTraits(tokenId, seed);\r\n        if (existingCombinations[structToHashCol(t)] == 0) {\r\n            tokenTraitsColonist[tokenId] = t;\r\n            existingCombinations[structToHashCol(t)] = tokenId;\r\n            emit ColonistMinted(tokenId);\r\n            return t;\r\n        }\r\n        return generateColonist(tokenId, randomizer.random(seed));\r\n    }\r\n\r\n    function generateHonors(uint256 tokenId, uint8 id)\r\n        internal\r\n        returns (HColonist memory q)\r\n    {\r\n        q.Legendary = id;\r\n        tokenTraitsHonors[minted] = q;\r\n        isHonors[minted] = true;\r\n        emit ColonistMinted(tokenId);\r\n        return q;\r\n    }\r\n\r\n    /**\r\n     * uses A.J. Walker's Alias algorithm for O(1) rarity table lookup\r\n     * ensuring O(1) instead of O(n) reduces mint cost by more than 50%\r\n     * probability & alias tables are generated off-chain beforehand\r\n     * @param seed portion of the 256 bit seed to remove trait correlation\r\n     * @param traitType the trait type to select a trait for\r\n     * @return the ID of the randomly selected trait\r\n     */\r\n    function selectTrait(uint16 seed, uint8 traitType)\r\n        internal\r\n        view\r\n        returns (uint8)\r\n    {\r\n        uint8 trait = uint8(seed) % uint8(rarities[traitType].length);\r\n        // If a selected random trait probability is selected (biased coin) return that trait\r\n        if (seed >> 8 < rarities[traitType][trait]) return trait;\r\n        return aliases[traitType][trait];\r\n    }\r\n\r\n    function selectGen(uint256 tokenId) internal pure returns (uint8 gen) {\r\n        if (tokenId <= (60000 / 6)) return 0; //0k-10k\r\n        if (tokenId <= (60000 * 8) / 24) return 1; //10k-20k\r\n        if (tokenId <= (60000 * 12) / 24) return 2; //20k-30k\r\n        if (tokenId <= (60000 * 16) / 24) return 3; //30k-40k\r\n        if (tokenId <= (60000 * 20) / 24) return 4; //40k-50k\r\n        if (tokenId <= (60000 * 22) / 24) return 5;\r\n        //50k-60k\r\n        else return 5;\r\n    }\r\n\r\n    /**\r\n     * selects the species and all of its traits based on the seed value\r\n     * @param seed a pseudorandom 256 bit number to derive traits from\r\n     * @return t -  a struct of randomly selected traits\r\n     */\r\n    function selectColTraits(uint256 tokenId, uint256 seed)\r\n        internal\r\n        view\r\n        returns (Colonist memory t)\r\n    {\r\n        t.isColonist = true;\r\n        seed >>= 16;\r\n        t.background = selectTrait(uint16(seed & 0xFFFF), 0);\r\n        seed >>= 16;\r\n        t.body = selectTrait(uint16(seed & 0xFFFF), 1);\r\n        seed >>= 16;\r\n        t.shirt = selectTrait(uint16(seed & 0xFFFF), 2);\r\n        seed >>= 16;\r\n        t.jacket = selectTrait(uint16(seed & 0xFFFF), 3);\r\n        seed >>= 16;\r\n        t.jaw = selectTrait(uint16(seed & 0xFFFF), 4);\r\n        seed >>= 16;\r\n        t.hair = selectTrait(uint16(seed & 0xFFFF), 5);\r\n        seed >>= 16;\r\n        t.eyes = selectTrait(uint16(seed & 0xFFFF), 6);\r\n        seed >>= 16;\r\n        t.held = selectTrait(uint16(seed & 0xFFFF), 7);\r\n        uint8 gen = selectGen(tokenId);\r\n        t.gen = gen;\r\n    }\r\n\r\n    function structToHashCol(Colonist memory s)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        s.background,\r\n                        s.body,\r\n                        s.shirt,\r\n                        s.jacket,\r\n                        s.jaw,\r\n                        s.hair,\r\n                        s.eyes,\r\n                        s.held,\r\n                        s.gen\r\n                    )\r\n                )\r\n            );\r\n    }\r\n\r\n    function tokenNameByIndex(uint256 index)\r\n        public\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return _tokenName[index];\r\n    }\r\n\r\n    function isNameReserved(string memory nameString)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _nameReserved[toLower(nameString)];\r\n    }\r\n\r\n    function hasBeenNamed(uint256 tokenId) public view returns (bool) {\r\n        return _hasName[tokenId];\r\n    }\r\n\r\n    function nameColonist(uint256 tokenId, string memory newName) public {\r\n        require(namingActive == true, \"naming not yet available\");\r\n        require(ownerOf[tokenId] == msg.sender, \"Not your colonist to name\");\r\n        require(hasBeenNamed(tokenId) == false, \"Colonist already named\");\r\n        require(validateName(newName) == true, \"Not a valid name\");\r\n        require(isNameReserved(newName) == false, \"Name already reserved\");\r\n\r\n        //   IERC20(_eonAddress).transferFrom(msg.sender, address(this), NAME_CHANGE_PRICE);\r\n\r\n        toggleReserveName(newName, true);\r\n        toggleHasName(tokenId, true);\r\n        _tokenName[tokenId] = newName;\r\n        EON.burn(_msgSender(), costToName);\r\n        emit ColonistNamed(tokenId, newName);\r\n    }\r\n\r\n    /**\r\n     * @dev Reserves the name if isReserve is set to true, de-reserves if set to false\r\n     */\r\n    function toggleReserveName(string memory str, bool isReserve) internal {\r\n        _nameReserved[toLower(str)] = isReserve;\r\n    }\r\n\r\n    function toggleHasName(uint256 tokenId, bool hasName) internal {\r\n        _hasName[tokenId] = hasName;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if the name string is valid (Alphanumeric and spaces without leading or trailing space)\r\n     */\r\n    function validateName(string memory str) public pure returns (bool) {\r\n        bytes memory b = bytes(str);\r\n        if (b.length < 1) return false;\r\n        if (b.length > 25) return false; // Cannot be longer than 25 characters\r\n        if (b[0] == 0x20) return false; // Leading space\r\n        if (b[b.length - 1] == 0x20) return false; // Trailing space\r\n\r\n        bytes1 lastChar = b[0];\r\n\r\n        for (uint256 i; i < b.length; i++) {\r\n            bytes1 char = b[i];\r\n\r\n            if (char == 0x20 && lastChar == 0x20) return false; // Cannot contain continous spaces\r\n\r\n            if (\r\n                !(char >= 0x30 && char <= 0x39) && //9-0\r\n                !(char >= 0x41 && char <= 0x5A) && //A-Z\r\n                !(char >= 0x61 && char <= 0x7A) && //a-z\r\n                !(char == 0x20) //space\r\n            ) return false;\r\n\r\n            lastChar = char;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts the string to lowercase\r\n     */\r\n    function toLower(string memory str) public pure returns (string memory) {\r\n        bytes memory bStr = bytes(str);\r\n        bytes memory bLower = new bytes(bStr.length);\r\n        for (uint256 i = 0; i < bStr.length; i++) {\r\n            // Uppercase character\r\n            if ((uint8(bStr[i]) >= 65) && (uint8(bStr[i]) <= 90)) {\r\n                bLower[i] = bytes1(uint8(bStr[i]) + 32);\r\n            } else {\r\n                bLower[i] = bStr[i];\r\n            }\r\n        }\r\n        return string(bLower);\r\n    }\r\n\r\n    function getMaxTokens() external view override returns (uint256) {\r\n        return MAX_TOKENS;\r\n    }\r\n\r\n    function getPaidTokens() external view override returns (uint256) {\r\n        return PAID_TOKENS;\r\n    }\r\n\r\n    /**\r\n     * enables owner to pause / unpause minting\r\n     */\r\n    function setPaused(bool _paused) external onlyOwner {\r\n        if (_paused) _pause();\r\n        else _unpause();\r\n    }\r\n\r\n    /**\r\n     * enables an address to mint / burn\r\n     * @param addr the address to enable\r\n     */\r\n    function addAdmin(address addr) external onlyOwner {\r\n        admins[addr] = true;\r\n    }\r\n\r\n    /**\r\n     * disables an address from minting / burning\r\n     * @param addr the address to disbale\r\n     */\r\n    function removeAdmin(address addr) external onlyOwner {\r\n        admins[addr] = false;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        auth = newOwner;\r\n    }\r\n\r\n    function toggleNameing(bool _namingActive) external onlyOwner {\r\n        namingActive = _namingActive;\r\n    }\r\n\r\n    function setImperialGuildTreasury(address _imperialTreasury)\r\n        external\r\n        onlyOwner\r\n    {\r\n        imperialGuildTreasury = _imperialTreasury;\r\n    }\r\n\r\n    /** Traits */\r\n\r\n    function getTokenTraitsColonist(uint256 tokenId)\r\n        external\r\n        view\r\n        override(IColonist)\r\n        returns (Colonist memory)\r\n    {\r\n        return tokenTraitsColonist[tokenId];\r\n    }\r\n\r\n    function getTokenTraitsHonors(uint256 tokenId)\r\n        external\r\n        view\r\n        override(IColonist)\r\n        returns (HColonist memory)\r\n    {\r\n        return tokenTraitsHonors[tokenId];\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        override\r\n        returns (string memory)\r\n    {\r\n        if (isHonors[tokenId]) {\r\n            return honorTraits.tokenURI(tokenId);\r\n        }\r\n        return traits.tokenURI(tokenId);\r\n    }\r\n\r\n    function isOwner(uint256 tokenId) public view returns (address) {\r\n        address addr = ownerOf[tokenId];\r\n        return addr;\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id\r\n    ) public override(ERC721, IColonist) {\r\n        transferFrom(from, to, id);\r\n\r\n        require(\r\n            to.code.length == 0 ||\r\n                ERC721TokenReceiver(to).onERC721Received(\r\n                    msg.sender,\r\n                    from,\r\n                    id,\r\n                    \"\"\r\n                ) ==\r\n                ERC721TokenReceiver.onERC721Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        bytes memory data\r\n    ) public override(ERC721, IColonist) {\r\n        transferFrom(from, to, id);\r\n\r\n        require(\r\n            to.code.length == 0 ||\r\n                ERC721TokenReceiver(to).onERC721Received(\r\n                    msg.sender,\r\n                    from,\r\n                    id,\r\n                    data\r\n                ) ==\r\n                ERC721TokenReceiver.onERC721Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    // For OpenSeas\r\n    function owner() public view virtual returns (address) {\r\n        return auth;\r\n    }\r\n}\r\n"
50     },
51     "contracts/ERC721.sol": {
52       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 indexed tokenId\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(uint256 => address) public ownerOf;\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = ownerOf[id];\n\n        require(\n            msg.sender == owner || isApprovedForAll[owner][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from ||\n                msg.sender == getApproved[id] ||\n                isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    id,\n                    \"\"\n                ) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    id,\n                    data\n                ) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        virtual\n        returns (bool)\n    {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = ownerOf[id];\n\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            balanceOf[owner]--;\n        }\n\n        delete ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
53     },
54     "contracts/interfaces/IColonist.sol": {
55       "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface IColonist {\r\n    // struct to store each Colonist's traits\r\n    struct Colonist {\r\n        bool isColonist;\r\n        uint8 background;\r\n        uint8 body;\r\n        uint8 shirt;\r\n        uint8 jacket;\r\n        uint8 jaw;\r\n        uint8 eyes;\r\n        uint8 hair;\r\n        uint8 held;\r\n        uint8 gen;\r\n    }\r\n\r\n    struct HColonist {\r\n        uint8 Legendary;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function isOwner(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function minted() external returns (uint16);\r\n\r\n    function totalCir() external returns (uint256);\r\n\r\n    function _mintColonist(address recipient, uint256 seed) external;\r\n\r\n    function _mintToHonors(address recipient, uint256 seed) external;\r\n\r\n    function _mintHonors(address recipient, uint8 id) external;\r\n\r\n    function burn(uint256 tokenId) external;\r\n\r\n    function getMaxTokens() external view returns (uint256);\r\n\r\n    function getPaidTokens() external view returns (uint256);\r\n\r\n    function getTokenTraitsColonist(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (Colonist memory);\r\n\r\n    function getTokenTraitsHonors(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (HColonist memory);\r\n\r\n    function tokenNameByIndex(uint256 index)\r\n        external\r\n        view\r\n        returns (string memory);\r\n\r\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\r\n\r\n    function nameColonist(uint256 tokenId, string memory newName) external;\r\n}\r\n"
56     },
57     "contracts/interfaces/IEON.sol": {
58       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IEON {\r\n    function mint(address to, uint256 amount) external;\r\n\r\n    function burn(address from, uint256 amount) external;\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n"
59     },
60     "contracts/interfaces/IHColonist.sol": {
61       "content": "// SPDX-License-Identifier: MIT LICENSE\npragma solidity ^0.8.0;\n\ninterface IHColonist {\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
62     },
63     "contracts/interfaces/IPytheas.sol": {
64       "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPytheas {\r\n    function addColonistToPytheas(address account, uint16[] calldata tokenIds)\r\n        external;\r\n\r\n    function claimColonistFromPytheas(address account, uint16[] calldata tokenIds, bool unstake)\r\n        external;\r\n\r\n    function getColonistMined(address account, uint16 tokenId)\r\n        external\r\n        returns (uint256);\r\n\r\n    function handleJoinPirates(address addr, uint16 tokenId) external;\r\n\r\n    function payUp(\r\n        uint16 tokenId,\r\n        uint256 amtMined,\r\n        address addr\r\n    ) external;\r\n}\r\n"
65     },
66     "contracts/interfaces/IRandomizer.sol": {
67       "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRandomizer {\r\n    function random(uint256) external returns (uint256);\r\n}\r\n"
68     },
69     "contracts/interfaces/ITColonist.sol": {
70       "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface ITColonist {\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n"
71     }
72   }
73 }}