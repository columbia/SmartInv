1 {{
2   "language": "Solidity",
3   "sources": {
4     "lib/ds-proxy/lib/ds-auth/src/auth.sol": {
5       "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.6.7;\n\ninterface DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) external view returns (bool);\n}\n\nabstract contract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        virtual\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        virtual\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) virtual internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n"
6     },
7     "lib/ds-proxy/lib/ds-note/src/note.sol": {
8       "content": "/// note.sol -- the `note' modifier, for logging calls as events\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint256           wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue()\n        }\n\n        _;\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n    }\n}\n"
9     },
10     "lib/ds-weth/lib/erc20/src/erc20.sol": {
11       "content": "/// erc20.sol -- API for the ERC20 token standard\n\n// See <https://github.com/ethereum/EIPs/issues/20>.\n\n// This file likely does not meet the threshold of originality\n// required for copyright to apply.  As a result, this is free and\n// unencumbered software belonging to the public domain.\n\npragma solidity >0.4.20;\n\nabstract contract ERC20Events {\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n}\n\nabstract contract ERC20 is ERC20Events {\n    function totalSupply() virtual public view returns (uint);\n    function balanceOf(address guy) virtual public view returns (uint);\n    function allowance(address src, address guy) virtual public view returns (uint);\n\n    function approve(address guy, uint wad) virtual public returns (bool);\n    function transfer(address dst, uint wad) virtual public returns (bool);\n    function transferFrom(\n        address src, address dst, uint wad\n    ) virtual public returns (bool);\n}\n"
12     },
13     "lib/esm/lib/ds-token/lib/ds-math/src/math.sol": {
14       "content": "/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >0.4.13;\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    //rounds to zero if x*y < WAD / 2\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    //rounds to zero if x*y < WAD / 2\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    //rounds to zero if x*y < WAD / 2\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    //rounds to zero if x*y < RAY / 2\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n"
15     },
16     "lib/esm/lib/ds-token/src/base.sol": {
17       "content": "/// base.sol -- basic ERC20 implementation\r\n\r\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.4.23 <0.7.0;\r\n\r\nimport \"erc20/erc20.sol\";\r\nimport \"ds-math/math.sol\";\r\n\r\ncontract DSTokenBase is ERC20, DSMath {\r\n    uint256                                            _supply;\r\n    mapping (address => uint256)                       _balances;\r\n    mapping (address => mapping (address => uint256))  _approvals;\r\n\r\n    constructor(uint supply) public {\r\n        _balances[msg.sender] = supply;\r\n        _supply = supply;\r\n    }\r\n\r\n    function totalSupply() override public view returns (uint) {\r\n        return _supply;\r\n    }\r\n    function balanceOf(address src) override public view returns (uint) {\r\n        return _balances[src];\r\n    }\r\n    function allowance(address src, address guy) override public view returns (uint) {\r\n        return _approvals[src][guy];\r\n    }\r\n\r\n    function transfer(address dst, uint wad) override public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        override\r\n        virtual\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender) {\r\n            require(_approvals[src][msg.sender] >= wad, \"ds-token-insufficient-approval\");\r\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\n        }\r\n\r\n        require(_balances[src] >= wad, \"ds-token-insufficient-balance\");\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address guy, uint wad) virtual override public returns (bool) {\r\n        _approvals[msg.sender][guy] = wad;\r\n\r\n        emit Approval(msg.sender, guy, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n"
18     },
19     "lib/esm/lib/ds-token/src/delegate.sol": {
20       "content": "pragma solidity >=0.5.13 <0.7.0;\r\n\r\nimport \"ds-stop/stop.sol\";\r\nimport \"./base.sol\";\r\n\r\ncontract DSDelegateToken is DSTokenBase(0), DSStop {\r\n    // --- Variables ---\r\n    // @notice The coin's symbol\r\n    string public symbol;\r\n    // @notice The coin's name\r\n    string public name;\r\n    /// @notice Standard token precision. Override to customize\r\n    uint256 public decimals = 18;\r\n    /// @notice A record of each accounts delegate\r\n    mapping (address => address) public delegates;\r\n    /// @notice A record of votes checkpoints for each account, by index\r\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\r\n    /// @notice The number of checkpoints for each account\r\n    mapping (address => uint32) public numCheckpoints;\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping (address => uint) public nonces;\r\n\r\n    // --- Structs ---\r\n    /// @notice A checkpoint for marking number of votes from a given block\r\n    struct Checkpoint {\r\n        uint256 fromBlock;\r\n        uint256 votes;\r\n    }\r\n\r\n    // --- Constants ---\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n    // --- Events ---\r\n    /// @notice An event that's emitted when the contract mints tokens\r\n    event Mint(address indexed guy, uint wad);\r\n    /// @notice An event that's emitted when the contract burns tokens\r\n    event Burn(address indexed guy, uint wad);\r\n    /// @notice An event that's emitted when an account changes its delegate\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n    /// @notice An event that's emitted when a delegate account's vote balance changes\r\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\r\n\r\n    constructor(string memory name_, string memory symbol_) public {\r\n        name   = name_;\r\n        symbol = symbol_;\r\n    }\r\n\r\n    // --- Functionality ---\r\n    /**\r\n     * @notice Approve an address to transfer all of your tokens\r\n     * @param guy The address to give approval to\r\n     */\r\n    function approve(address guy) public stoppable returns (bool) {\r\n        return super.approve(guy, uint(-1));\r\n    }\r\n    /**\r\n     * @notice Approve an address to transfer part of your tokens\r\n     * @param guy The address to give approval to\r\n     * @param wad The amount of tokens to approve\r\n     */\r\n    function approve(address guy, uint wad) override public stoppable returns (bool) {\r\n        return super.approve(guy, wad);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer tokens from src to dst\r\n     * @param src The address to transfer tokens from\r\n     * @param dst The address to transfer tokens to\r\n     * @param wad The amount of tokens to transfer\r\n     */\r\n    function transferFrom(address src, address dst, uint wad)\r\n        override\r\n        public\r\n        stoppable\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) {\r\n            require(_approvals[src][msg.sender] >= wad, \"ds-delegate-token-insufficient-approval\");\r\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\n        }\r\n\r\n        require(_balances[src] >= wad, \"ds-delegate-token-insufficient-balance\");\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        _moveDelegates(delegates[src], delegates[dst], wad);\r\n\r\n        return true;\r\n    }\r\n    /**\r\n     * @notice Transfer tokens to dst\r\n     * @param dst The address to transfer tokens to\r\n     * @param wad The amount of tokens to transfer\r\n     */\r\n    function push(address dst, uint wad) public {\r\n        transferFrom(msg.sender, dst, wad);\r\n    }\r\n    /**\r\n     * @notice Transfer tokens from src to yourself\r\n     * @param src The address to transfer tokens frpom\r\n     * @param wad The amount of tokens to transfer\r\n     */\r\n    function pull(address src, uint wad) public {\r\n        transferFrom(src, msg.sender, wad);\r\n    }\r\n    /**\r\n     * @notice Transfer tokens between two addresses\r\n     * @param src The address to transfer tokens from\r\n     * @param dst The address to transfer tokens to\r\n     * @param wad The amount of tokens to transfer\r\n     */\r\n    function move(address src, address dst, uint wad) public {\r\n        transferFrom(src, dst, wad);\r\n    }\r\n\r\n    /**\r\n     * @notice Mint tokens for yourself\r\n     * @param wad The amount of tokens to mint\r\n     */\r\n    function mint(uint wad) public {\r\n        mint(msg.sender, wad);\r\n    }\r\n    /**\r\n     * @notice Burn your own tokens\r\n     * @param wad The amount of tokens to burn\r\n     */\r\n    function burn(uint wad) public {\r\n        burn(msg.sender, wad);\r\n    }\r\n    /**\r\n     * @notice Mint tokens for guy\r\n     * @param guy The address to mint tokens for\r\n     * @param wad The amount of tokens to mint\r\n     */\r\n    function mint(address guy, uint wad) public auth stoppable {\r\n        _balances[guy] = add(_balances[guy], wad);\r\n        _supply = add(_supply, wad);\r\n        emit Mint(guy, wad);\r\n\r\n        _moveDelegates(delegates[address(0)], delegates[guy], wad);\r\n    }\r\n    /**\r\n     * @notice Burn guy's tokens\r\n     * @param guy The address to burn tokens from\r\n     * @param wad The amount of tokens to burn\r\n     */\r\n    function burn(address guy, uint wad) public auth stoppable {\r\n        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {\r\n            require(_approvals[guy][msg.sender] >= wad, \"ds-delegate-token-insufficient-approval\");\r\n            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);\r\n        }\r\n\r\n        require(_balances[guy] >= wad, \"ds-delegate-token-insufficient-balance\");\r\n        _balances[guy] = sub(_balances[guy], wad);\r\n        _supply = sub(_supply, wad);\r\n        emit Burn(guy, wad);\r\n\r\n        _moveDelegates(delegates[guy], delegates[address(0)], wad);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate votes from `msg.sender` to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     */\r\n    function delegate(address delegatee) public {\r\n        return _delegate(msg.sender, delegatee);\r\n    }\r\n    /**\r\n     * @notice Delegates votes from signatory to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     * @param nonce The contract state required to match the signature\r\n     * @param expiry The time at which to expire the signature\r\n     * @param v The recovery byte of the signature\r\n     * @param r Half of the ECDSA signature pair\r\n     * @param s Half of the ECDSA signature pair\r\n     */\r\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(abi.encodePacked(name)), getChainId(), address(this)));\r\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \"ds-delegate-token-invalid-signature\");\r\n        require(nonce == nonces[signatory]++, \"ds-delegate-token-invalid-nonce\");\r\n        require(now <= expiry, \"ds-delegate-token-signature-expired\");\r\n        return _delegate(signatory, delegatee);\r\n    }\r\n    /**\r\n     * @notice Internal function to delegate votes from `delegator` to `delegatee`\r\n     * @param delegator The address that delegates its votes\r\n     * @param delegatee The address to delegate votes to\r\n     */\r\n    function _delegate(address delegator, address delegatee) internal {\r\n        address currentDelegate = delegates[delegator];\r\n        delegates[delegator]    = delegatee;\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n\r\n        _moveDelegates(currentDelegate, delegatee, balanceOf(delegator));\r\n    }\r\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\r\n        if (srcRep != dstRep && amount > 0) {\r\n            if (srcRep != address(0)) {\r\n                uint32 srcRepNum  = numCheckpoints[srcRep];\r\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n                uint256 srcRepNew = sub(srcRepOld, amount);\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n            }\r\n\r\n            if (dstRep != address(0)) {\r\n                uint32 dstRepNum  = numCheckpoints[dstRep];\r\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n                uint256 dstRepNew = add(dstRepOld, amount);\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n            }\r\n        }\r\n    }\r\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint256 oldVotes, uint256 newVotes) internal {\r\n        uint blockNumber = block.number;\r\n\r\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\r\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n        } else {\r\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\r\n            numCheckpoints[delegatee] = nCheckpoints + 1;\r\n        }\r\n\r\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current votes balance for `account`\r\n     * @param account The address to get votes balance\r\n     * @return The number of current votes for `account`\r\n     */\r\n    function getCurrentVotes(address account) external view returns (uint256) {\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the prior number of votes for an account as of a block number\r\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\r\n     * @param account The address of the account to check\r\n     * @param blockNumber The block number to get the vote balance at\r\n     * @return The number of votes the account had as of the given block\r\n     */\r\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint256) {\r\n        require(blockNumber < block.number, \"ds-delegate-token-not-yet-determined\");\r\n\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // First check most recent balance\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\r\n            return checkpoints[account][nCheckpoints - 1].votes;\r\n        }\r\n\r\n        // Next check implicit zero balance\r\n        if (checkpoints[account][0].fromBlock > blockNumber) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlock < blockNumber) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return checkpoints[account][lower].votes;\r\n    }\r\n\r\n    /**\r\n    * @notice Fetch the chain ID\r\n    **/\r\n    function getChainId() internal pure returns (uint) {\r\n        uint256 chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n}\r\n"
21     },
22     "lib/geb-fsm/lib/ds-stop/src/stop.sol": {
23       "content": "/// stop.sol -- mixin for enable/disable functionality\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\nimport \"ds-auth/auth.sol\";\nimport \"ds-note/note.sol\";\n\ncontract DSStop is DSNote, DSAuth {\n    bool public stopped;\n\n    modifier stoppable {\n        require(!stopped, \"ds-stop-is-stopped\");\n        _;\n    }\n    function stop() public auth note {\n        stopped = true;\n    }\n    function start() public auth note {\n        stopped = false;\n    }\n\n}\n"
24     }
25   },
26   "settings": {
27     "remappings": [
28       "ds-auth/=lib/ds-proxy/lib/ds-auth/src/",
29       "ds-exec/=lib/ds-pause/lib/ds-spell/lib/ds-exec/src/",
30       "ds-guard/=lib/geb-deploy/lib/ds-guard/src/",
31       "ds-math/=lib/esm/lib/ds-token/lib/ds-math/src/",
32       "ds-note/=lib/ds-proxy/lib/ds-note/src/",
33       "ds-pause/=lib/ds-pause/src/",
34       "ds-proxy/=lib/ds-proxy/src/",
35       "ds-roles/=lib/ds-pause/lib/ds-vote-quorum/lib/ds-roles/src/",
36       "ds-spell/=lib/ds-pause/lib/ds-spell/src/",
37       "ds-stop/=lib/geb-fsm/lib/ds-stop/src/",
38       "ds-test/=lib/forge-std/lib/ds-test/src/",
39       "ds-thing/=lib/ds-value/lib/ds-thing/src/",
40       "ds-token/=lib/esm/lib/ds-token/src/",
41       "ds-value/=lib/ds-value/src/",
42       "ds-vote-quorum/=lib/ds-pause/lib/ds-vote-quorum/src/",
43       "ds-weth/=lib/ds-weth/",
44       "erc20/=lib/ds-weth/lib/erc20/src/",
45       "esm/=lib/esm/src/",
46       "forge-std/=lib/forge-std/src/",
47       "geb-basic-multisig/=lib/ds-pause/lib/geb-basic-multisig/src/",
48       "geb-chainlink-median/=lib/geb-chainlink-median/src/",
49       "geb-debt-popper-rewards/=lib/geb-debt-popper-rewards/src/",
50       "geb-deploy/=lib/geb-deploy/src/",
51       "geb-esm-threshold-setter/=lib/geb-esm-threshold-setter/src/",
52       "geb-fsm/=lib/geb-fsm/src/",
53       "geb-incentives/=lib/geb-proxy-actions/lib/geb-incentives/src/",
54       "geb-lender-first-resort/=lib/geb-lender-first-resort/src/",
55       "geb-pit/=lib/geb-pit/src/",
56       "geb-protocol-token-authority/=lib/geb-protocol-token-authority/src/",
57       "geb-proxy-actions/=lib/geb-proxy-actions/src/",
58       "geb-proxy-registry/=lib/geb-proxy-registry/src/",
59       "geb-rrfm-calculators/=lib/geb-rrfm-calculators/src/",
60       "geb-rrfm-rate-setter/=lib/geb-rrfm-rate-setter/src/",
61       "geb-safe-manager/=lib/geb-safe-manager/src/",
62       "geb-safe-saviours/=lib/geb-proxy-actions/lib/geb-safe-saviours/src/",
63       "geb-treasury-reimbursement/=lib/geb-debt-popper-rewards/lib/geb-treasury-reimbursement/src/",
64       "geb-uniswap-median/=lib/geb-uniswap-median/src/",
65       "geb/=lib/geb/src/",
66       "mgl-debt-minter-rewards/=lib/mgl-debt-minter-rewards/",
67       "mgl-emitter/=lib/mgl-emitter/src/",
68       "multicall/=lib/multicall/src/"
69     ],
70     "optimizer": {
71       "enabled": false,
72       "runs": 200
73     },
74     "metadata": {
75       "bytecodeHash": "ipfs"
76     },
77     "outputSelection": {
78       "*": {
79         "*": [
80           "evm.bytecode",
81           "evm.deployedBytecode",
82           "devdoc",
83           "userdoc",
84           "metadata",
85           "abi"
86         ]
87       }
88     },
89     "evmVersion": "istanbul",
90     "libraries": {}
91   }
92 }}