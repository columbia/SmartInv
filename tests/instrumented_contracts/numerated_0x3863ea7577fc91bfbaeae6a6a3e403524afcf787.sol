1 {{
2   "language": "Solidity",
3   "sources": {
4     "/Users/mrbitkoin/Projects/LindaCEOJonah/Repositories/Sparkle-Developers/XETH/xeth-v2-token/contracts/XplosiveEthereum.sol": {
5       "content": "// SPDX-License-Identifier: UNLICENSED\n/**\n *\n * ██╗  ██╗███████╗████████╗██╗  ██╗\n * ╚██╗██╔╝██╔════╝╚══██╔══╝██║  ██║\n *  ╚███╔╝ █████╗     ██║   ███████║\n *  ██╔██╗ ██╔══╝     ██║   ██╔══██║\n * ██╔╝ ██╗███████╗   ██║   ██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝\n *\n *    An Ethereum pegged\n * base-down, burn-up currency.\n *\n *  https://xEth.finance\n *\n *\n**/\n\n\n/// SWC-103:  Floating Pragma\npragma solidity 0.6.12;\n\nimport \"./XplosiveSafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport '@openzeppelin/contracts/utils/Pausable.sol';\nimport './XplosiveRebaser.sol';\n\ncontract XplosiveEthereum is Ownable, Pausable, Rebasable\n{\n    using XplosiveSafeMath for uint256;\n\n    event Transfer(address indexed from, address indexed to, uint amount);\n    event Approval(address indexed owner, address indexed spender, uint amount);\n\n    event Rebase(uint256 indexed epoch, uint256 scalingFactor);\n\n    event WhitelistFrom(address _addr, bool _whitelisted);\n    event WhitelistTo(address _addr, bool _whitelisted);\n    event WhitelistRebase(address _addr, bool _whitelisted);\n\n    string public name     = \"xETH-G\";\n    string public symbol   = \"xETH-G\";\n    uint8  public decimals = 18;\n\n    // address public rebaser;\n    address public rewardAddress;\n\n    /**\n     * @notice Internal decimals used to handle scaling factor\n     */\n    uint256 public constant internalDecimals = 10**24;\n\n    /**\n     * @notice Used for percentage maths\n     */\n    uint256 public constant BASE = 10**18;\n\n    /**\n     * @notice Scaling factor that adjusts everyone's balances\n     */\n    uint256 public xETHScalingFactor  = BASE;\n\n    mapping (address => uint256) internal _xETHBalances;\n    mapping (address => mapping (address => uint256)) internal _allowedFragments;\n\n    mapping(address => bool) public whitelistFrom;\n    mapping(address => bool) public whitelistTo;\n    mapping(address => bool) public whitelistRebase;\n\n    address public noRebaseAddress;\n\n    uint256 initSupply = 0;\n    uint256 _totalSupply = 0;\n    uint16 public SELL_FEE = 33;\n    uint16 public TX_FEE = 50;\n\n    constructor( uint256 initialSupply, address initialSupplyAddr )\n    public\n    Ownable()\n    Pausable()\n    Rebasable()\n    {\n        _mint(initialSupplyAddr,initialSupply);\n    }\n\n    function totalSupply()\n    public\n    view\n    returns (uint256)\n    {\n        return _totalSupply;\n    }\n\n    function getSellBurn(uint256 value)\n    public\n    view\n    whenNotPaused\n    returns (uint256)\n    {\n        uint256 nPercent = value.divRound(SELL_FEE);\n        return nPercent;\n    }\n\n    function getTxBurn(uint256 value)\n    public\n    view\n    whenNotPaused\n    returns (uint256)\n    {\n        uint256 nPercent = value.divRound(TX_FEE);\n        return nPercent;\n    }\n\n    function _isWhitelisted(address _from, address _to)\n    internal\n    view\n    returns (bool)\n    {\n        return whitelistFrom[_from]||whitelistTo[_to];\n    }\n\n    function _isRebaseWhitelisted(address _addr)\n    internal\n    view\n    returns (bool)\n    {\n        return whitelistRebase[_addr];\n    }\n\n    function setWhitelistedTo(address _addr, bool _whitelisted)\n    external\n    onlyOwner\n    {\n        emit WhitelistTo(_addr, _whitelisted);\n        whitelistTo[_addr] = _whitelisted;\n    }\n\n    function setTxFee(uint16 fee)\n    external\n    onlyRebaser\n    whenNotPaused\n    {\n        TX_FEE = fee;\n    }\n\n    function setSellFee(uint16 fee)\n    external\n    onlyRebaser\n    whenNotPaused\n    {\n        SELL_FEE = fee;\n    }\n\n    function setWhitelistedFrom(address _addr, bool _whitelisted)\n    external\n    onlyOwner\n    {\n        emit WhitelistFrom(_addr, _whitelisted);\n        whitelistFrom[_addr] = _whitelisted;\n    }\n\n    function setWhitelistedRebase(address _addr, bool _whitelisted)\n    external\n    onlyOwner\n    {\n        emit WhitelistRebase(_addr, _whitelisted);\n        whitelistRebase[_addr] = _whitelisted;\n    }\n\n    function setNoRebaseAddress(address _addr)\n    external\n    onlyOwner\n    {\n        noRebaseAddress = _addr;\n    }\n\n    /**\n    * @notice Computes the current max scaling factor\n    */\n    function maxScalingFactor()\n    external\n    view\n    whenNotPaused\n    returns (uint256)\n    {\n        return _maxScalingFactor();\n    }\n\n    function _maxScalingFactor()\n    internal\n    view\n    returns (uint256)\n    {\n        // scaling factor can only go up to 2**256-1 = initSupply * xETHScalingFactor\n        // this is used to check if xETHScalingFactor will be too high to compute balances when rebasing.\n        return uint256(-1) / initSupply;\n    }\n\n    function _mint(address to, uint256 amount)\n    internal\n    {\n      // increase totalSupply\n      _totalSupply = _totalSupply.add(amount);\n\n      // get underlying value\n      uint256 xETHValue = amount.mul(internalDecimals).div(xETHScalingFactor);\n\n      // increase initSupply\n      initSupply = initSupply.add(xETHValue);\n\n      // make sure the mint didnt push maxScalingFactor too low\n      require(xETHScalingFactor <= _maxScalingFactor(), \"max scaling factor too low\");\n\n      // add balance\n      _xETHBalances[to] = _xETHBalances[to].add(xETHValue);\n\n      emit Transfer(address(0),to,amount);\n    }\n\n    /* - ERC20 functionality - */\n\n    /**\n    * @dev Transfer tokens to a specified address.\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    * @return True on success, false otherwise.\n    */\n    function transfer(address to, uint256 value)\n    external\n    whenNotPaused\n    returns (bool)\n    {\n        // underlying balance is stored in xETH, so divide by current scaling factor\n\n        // note, this means as scaling factor grows, dust will be untransferrable.\n        // minimum transfer value == xETHScalingFactor / 1e24;\n\n        // get amount in underlying\n        //from noRebaseWallet\n        if(_isRebaseWhitelisted(msg.sender))\n        {\n            uint256 noReValue = value.mul(internalDecimals).div(BASE);\n            uint256 noReNextValue = noReValue.mul(BASE).div(xETHScalingFactor);\n            _xETHBalances[msg.sender] = _xETHBalances[msg.sender].sub(noReValue); //value==underlying\n            _xETHBalances[to] = _xETHBalances[to].add(noReNextValue);\n            emit Transfer(msg.sender, to, value);\n        }\n        else if(_isRebaseWhitelisted(to))\n        {\n            uint256 fee = getSellBurn(value);\n            uint256 tokensToBurn = fee/2;\n            uint256 tokensForRewards = fee-tokensToBurn;\n            uint256 tokensToTransfer = value-fee;\n\n            uint256 xETHValue = value.mul(internalDecimals).div(xETHScalingFactor);\n            uint256 xETHValueKeep = tokensToTransfer.mul(internalDecimals).div(xETHScalingFactor);\n            uint256 xETHValueReward = tokensForRewards.mul(internalDecimals).div(xETHScalingFactor);\n\n\n            uint256 xETHNextValue = xETHValueKeep.mul(xETHScalingFactor).div(BASE);\n\n            _totalSupply = _totalSupply-fee;\n            _xETHBalances[address(0)] = _xETHBalances[address(0)].add(fee/2);\n            _xETHBalances[msg.sender] = _xETHBalances[msg.sender].sub(xETHValue);\n            _xETHBalances[to] = _xETHBalances[to].add(xETHNextValue);\n            _xETHBalances[rewardAddress] = _xETHBalances[rewardAddress].add(xETHValueReward);\n            emit Transfer(msg.sender, to, tokensToTransfer);\n            emit Transfer(msg.sender, address(0), tokensToBurn);\n            emit Transfer(msg.sender, rewardAddress, tokensForRewards);\n        }\n        else\n        {\n            if(!_isWhitelisted(msg.sender, to))\n            {\n                uint256 fee = getTxBurn(value);\n                uint256 tokensToBurn = fee/2;\n                uint256 tokensForRewards = fee-tokensToBurn;\n                uint256 tokensToTransfer = value-fee;\n\n                uint256 xETHValue = value.mul(internalDecimals).div(xETHScalingFactor);\n                uint256 xETHValueKeep = tokensToTransfer.mul(internalDecimals).div(xETHScalingFactor);\n                uint256 xETHValueReward = tokensForRewards.mul(internalDecimals).div(xETHScalingFactor);\n\n                _totalSupply = _totalSupply-fee;\n                _xETHBalances[address(0)] = _xETHBalances[address(0)].add(fee/2);\n                _xETHBalances[msg.sender] = _xETHBalances[msg.sender].sub(xETHValue);\n                _xETHBalances[to] = _xETHBalances[to].add(xETHValueKeep);\n                _xETHBalances[rewardAddress] = _xETHBalances[rewardAddress].add(xETHValueReward);\n                emit Transfer(msg.sender, to, tokensToTransfer);\n                emit Transfer(msg.sender, address(0), tokensToBurn);\n                emit Transfer(msg.sender, rewardAddress, tokensForRewards);\n            }\n            else\n            {\n                uint256 xETHValue = value.mul(internalDecimals).div(xETHScalingFactor);\n\n                _xETHBalances[msg.sender] = _xETHBalances[msg.sender].sub(xETHValue);\n                _xETHBalances[to] = _xETHBalances[to].add(xETHValue);\n                emit Transfer(msg.sender, to, xETHValue);\n             }\n        }\n        return true;\n    }\n\n    /**\n    * @dev Transfer tokens from one address to another.\n    * @param from The address you want to send tokens from.\n    * @param to The address you want to transfer to.\n    * @param value The amount of tokens to be transferred.\n    */\n    function transferFrom(address from, address to, uint256 value)\n    external\n    whenNotPaused\n    returns (bool)\n    {\n        // decrease allowance\n        _allowedFragments[from][msg.sender] = _allowedFragments[from][msg.sender].sub(value);\n\n        if(_isRebaseWhitelisted(from))\n        {\n            uint256 noReValue = value.mul(internalDecimals).div(BASE);\n            uint256 noReNextValue = noReValue.mul(BASE).div(xETHScalingFactor);\n            _xETHBalances[from] = _xETHBalances[from].sub(noReValue); //value==underlying\n            _xETHBalances[to] = _xETHBalances[to].add(noReNextValue);\n            emit Transfer(from, to, value);\n        }\n        else if(_isRebaseWhitelisted(to))\n        {\n            uint256 fee = getSellBurn(value);\n            uint256 tokensForRewards = fee-(fee/2);\n            uint256 tokensToTransfer = value-fee;\n\n            uint256 xETHValue = value.mul(internalDecimals).div(xETHScalingFactor);\n            uint256 xETHValueKeep = tokensToTransfer.mul(internalDecimals).div(xETHScalingFactor);\n            uint256 xETHValueReward = tokensForRewards.mul(internalDecimals).div(xETHScalingFactor);\n            uint256 xETHNextValue = xETHValueKeep.mul(xETHScalingFactor).div(BASE);\n\n            _totalSupply = _totalSupply-fee;\n\n            _xETHBalances[from] = _xETHBalances[from].sub(xETHValue);\n            _xETHBalances[to] = _xETHBalances[to].add(xETHNextValue);\n            _xETHBalances[rewardAddress] = _xETHBalances[rewardAddress].add(xETHValueReward);\n            _xETHBalances[address(0)] = _xETHBalances[address(0)].add(fee/2);\n            emit Transfer(from, to, tokensToTransfer);\n            emit Transfer(from, address(0), fee/2);\n            emit Transfer(from, rewardAddress, tokensForRewards);\n        }\n        else\n        {\n            if(!_isWhitelisted(from, to))\n            {\n                uint256 fee = getTxBurn(value);\n                uint256 tokensToBurn = fee/2;\n                uint256 tokensForRewards = fee-tokensToBurn;\n                uint256 tokensToTransfer = value-fee;\n\n                uint256 xETHValue = value.mul(internalDecimals).div(xETHScalingFactor);\n                uint256 xETHValueKeep = tokensToTransfer.mul(internalDecimals).div(xETHScalingFactor);\n                uint256 xETHValueReward = tokensForRewards.mul(internalDecimals).div(xETHScalingFactor);\n\n                _totalSupply = _totalSupply-fee;\n                _xETHBalances[address(0)] = _xETHBalances[address(0)].add(fee/2);\n                _xETHBalances[from] = _xETHBalances[from].sub(xETHValue);\n                _xETHBalances[to] = _xETHBalances[to].add(xETHValueKeep);\n                _xETHBalances[rewardAddress] = _xETHBalances[rewardAddress].add(xETHValueReward);\n                emit Transfer(from, to, tokensToTransfer);\n                emit Transfer(from, address(0), tokensToBurn);\n                emit Transfer(from, rewardAddress, tokensForRewards);\n            }\n            else\n            {\n                uint256 xETHValue = value.mul(internalDecimals).div(xETHScalingFactor);\n\n                _xETHBalances[from] = _xETHBalances[from].sub(xETHValue);\n                _xETHBalances[to] = _xETHBalances[to].add(xETHValue);\n                emit Transfer(from, to, xETHValue);\n             }\n        }\n        return true;\n    }\n\n    /**\n    * @param who The address to query.\n    * @return The balance of the specified address.\n    */\n    function balanceOf(address who)\n    external\n    view\n    returns (uint256)\n    {\n        if(_isRebaseWhitelisted(who))\n        {\n            return _xETHBalances[who].mul(BASE).div(internalDecimals);\n        }\n        else\n        {\n            return _xETHBalances[who].mul(xETHScalingFactor).div(internalDecimals);\n        }\n    }\n\n    /** @notice Currently returns the internal storage amount\n    * @param who The address to query.\n    * @return The underlying balance of the specified address.\n    */\n    function balanceOfUnderlying(address who)\n    external\n    view\n    returns (uint256)\n    {\n        return _xETHBalances[who];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner has allowed to a spender.\n     * @param owner_ The address which owns the funds.\n     * @param spender The address which will spend the funds.\n     * @return The number of tokens still available for the spender.\n     */\n    function allowance(address owner_, address spender)\n    external\n    view\n    whenNotPaused\n    returns (uint256)\n    {\n        return _allowedFragments[owner_][spender];\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of\n     * msg.sender. This method is included for ERC20 compatibility.\n     * increaseAllowance and decreaseAllowance should be used instead.\n     * Changing an allowance with this method brings the risk that someone may transfer both\n     * the old and the new allowance - if they are both greater than zero - if a transfer\n     * transaction is mined before the later approve() call is mined.\n     *\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value)\n    external\n    whenNotPaused\n    returns (bool)\n    {\n        _allowedFragments[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner has allowed to a spender.\n     * This method should be used instead of approve() to avoid the double approval vulnerability\n     * described above.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n    external\n    whenNotPaused\n    returns (bool)\n    {\n        _allowedFragments[msg.sender][spender] = _allowedFragments[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner has allowed to a spender.\n     *\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n    external\n    whenNotPaused\n    returns (bool)\n    {\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\n        if (subtractedValue >= oldValue)\n        {\n            _allowedFragments[msg.sender][spender] = 0;\n        }\n        else\n        {\n            _allowedFragments[msg.sender][spender] = oldValue.sub(subtractedValue);\n        }\n\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\n        return true;\n    }\n\n    function _setRewardAddress(address rewards_)\n    external\n    onlyOwner\n    {\n        rewardAddress = rewards_;\n    }\n\n    /**\n    * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\n    *\n    * @dev The supply adjustment equals (totalSupply * DeviationFromTargetRate) / rebaseLag\n    *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\n    *      and targetRate is CpiOracleRate / baseCpi\n    */\n    function rebase(uint256 epoch, uint256 indexDelta, bool positive)\n    external\n    onlyRebaser\n    whenNotPaused\n    returns (uint256)\n    {\n        if (indexDelta == 0 || !positive)\n        {\n            emit Rebase(epoch, xETHScalingFactor);\n            return _totalSupply;\n        }\n\n        uint256 newScalingFactor = xETHScalingFactor.mul(BASE.add(indexDelta)).div(BASE);\n        if (newScalingFactor < _maxScalingFactor())\n        {\n            xETHScalingFactor = newScalingFactor;\n        }\n        else\n        {\n            xETHScalingFactor = _maxScalingFactor();\n        }\n\n        _totalSupply = ((initSupply.sub(_xETHBalances[address(0)]).sub(_xETHBalances[noRebaseAddress]))\n            .mul(xETHScalingFactor).div(internalDecimals))\n            .add(_xETHBalances[noRebaseAddress].mul(BASE).div(internalDecimals));\n\n        emit Rebase(epoch, xETHScalingFactor);\n        return _totalSupply;\n    }\n\n}\n"
6     },
7     "/Users/mrbitkoin/Projects/LindaCEOJonah/Repositories/Sparkle-Developers/XETH/xeth-v2-token/contracts/XplosiveRebaser.sol": {
8       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Rebasable is Ownable {\n  address private _rebaser;\n\n  event TransferredRebasership(address indexed previousRebaser, address indexed newRebaser);\n\n  constructor() internal {\n    address msgSender = _msgSender();\n    _rebaser = msgSender;\n    emit TransferredRebasership(address(0), msgSender);\n  }\n\n  function Rebaser() public view returns(address) {\n    return _rebaser;\n  }\n\n  modifier onlyRebaser() {\n    require(_rebaser == _msgSender(), \"caller is not rebaser\");\n    _;\n  }\n\n  function transferRebasership(address newRebaser) public virtual onlyOwner {\n    require(newRebaser != address(0), \"new rebaser is address zero\");\n    emit TransferredRebasership(_rebaser, newRebaser);\n    _rebaser = newRebaser;\n  }\n}\n"
9     },
10     "/Users/mrbitkoin/Projects/LindaCEOJonah/Repositories/Sparkle-Developers/XETH/xeth-v2-token/contracts/XplosiveSafeMath.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary XplosiveSafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256)\n    {\n        uint256 c = add(a,m);\n        uint256 d = sub(c,1);\n        return mul(div(d,m),m);\n    }\n\n    function divRound(uint256 x, uint256 y) internal pure returns (uint256) {\n        require(y != 0, \"Div by zero\");\n        uint256 r = x / y;\n        if (x % y != 0) {\n            r = r + 1;\n        }\n\n        return r;\n    }\n}\n"
12     },
13     "@openzeppelin/contracts/GSN/Context.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
15     },
16     "@openzeppelin/contracts/access/Ownable.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
18     },
19     "@openzeppelin/contracts/utils/Pausable.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
21     }
22   },
23   "settings": {
24     "remappings": [],
25     "optimizer": {
26       "enabled": true,
27       "runs": 200
28     },
29     "evmVersion": "petersburg",
30     "libraries": {
31       "": {}
32     },
33     "outputSelection": {
34       "*": {
35         "*": [
36           "evm.bytecode",
37           "evm.deployedBytecode",
38           "abi"
39         ]
40       }
41     }
42   }
43 }}