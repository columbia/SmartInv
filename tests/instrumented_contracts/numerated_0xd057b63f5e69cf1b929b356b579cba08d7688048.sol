1 {{
2   "language": "Solidity",
3   "sources": {
4     "src/contracts/CowProtocolVirtualToken.sol": {
5       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"./mixins/NonTransferrableErc20.sol\";\nimport \"./mixins/Vesting.sol\";\nimport \"./mixins/Claiming.sol\";\nimport \"./mixins/MerkleDistributor.sol\";\nimport \"./vendored/mixins/StorageAccessible.sol\";\n\n/// @dev The token that manages how the CoW Protocol governance token is\n/// distributed to all different types of investors.\n/// @title CoW Protocol Virtual Token\n/// @author CoW Protocol Developers\ncontract CowProtocolVirtualToken is\n    NonTransferrableErc20,\n    Vesting,\n    Claiming,\n    MerkleDistributor,\n    StorageAccessible\n{\n    string private constant ERC20_SYMBOL = \"vCOW\";\n    string private constant ERC20_NAME = \"CoW Protocol Virtual Token\";\n\n    constructor(\n        bytes32 merkleRoot,\n        address cowToken,\n        address payable communityFundsTarget,\n        address investorFundsTarget,\n        address usdcToken,\n        uint256 usdcPrice,\n        address gnoToken,\n        uint256 gnoPrice,\n        address wrappedNativeToken,\n        uint256 nativeTokenPrice,\n        address teamController\n    )\n        NonTransferrableErc20(ERC20_NAME, ERC20_SYMBOL)\n        Claiming(\n            cowToken,\n            communityFundsTarget,\n            investorFundsTarget,\n            usdcToken,\n            usdcPrice,\n            gnoToken,\n            gnoPrice,\n            wrappedNativeToken,\n            nativeTokenPrice,\n            teamController\n        )\n        MerkleDistributor(merkleRoot)\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n\n    /// @dev Returns the sum of tokens that are either held as\n    /// instantlySwappableBalance or will be vested in the future\n    /// @param user The user for whom the balance is calculated\n    /// @return Balance of the user\n    function balanceOf(address user) public view returns (uint256) {\n        return\n            instantlySwappableBalance[user] +\n            fullAllocation[user] -\n            vestedAllocation[user];\n    }\n\n    /// @dev Returns the balance of a user assuming all vested tokens would\n    /// have been converted into virtual tokens\n    /// @param user The user for whom the balance is calculated\n    /// @return Balance the user would have after calling `swapAll`\n    function swappableBalanceOf(address user) public view returns (uint256) {\n        return instantlySwappableBalance[user] + newlyVestedBalance(user);\n    }\n}\n"
6     },
7     "src/contracts/mixins/NonTransferrableErc20.sol": {
8       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"../vendored/interfaces/IERC20.sol\";\n\n/// @dev A contract of an ERC20 token that cannot be transferred.\n/// @title Non-Transferrable ERC20\n/// @author CoW Protocol Developers\nabstract contract NonTransferrableErc20 is IERC20 {\n    /// @dev The ERC20 name of the token\n    string public name;\n    /// @dev The ERC20 symbol of the token\n    string public symbol;\n    /// @dev The ERC20 number of decimals of the token\n    uint8 public constant decimals = 18; // solhint-disable const-name-snakecase\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /// @dev This error is fired when trying to perform an action that is not\n    /// supported by the contract, like transfers and approvals. These actions\n    /// will never be supported.\n    error NotSupported();\n\n    /// @dev All types of transfers are permanently disabled.\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public pure returns (bool) {\n        revert NotSupported();\n    }\n\n    /// @dev All types of transfers are permanently disabled.\n    function transfer(address, uint256) public pure returns (bool) {\n        revert NotSupported();\n    }\n\n    /// @dev All types of approvals are permanently disabled to reduce code\n    /// size.\n    function approve(address, uint256) public pure returns (bool) {\n        revert NotSupported();\n    }\n\n    /// @dev Approvals cannot be set, so allowances are always zero.\n    function allowance(address, address) public pure returns (uint256) {\n        return 0;\n    }\n}\n"
9     },
10     "src/contracts/mixins/Vesting.sol": {
11       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"../vendored/libraries/Math.sol\";\n\nimport \"../interfaces/VestingInterface.sol\";\n\n/// @dev The vesting logic for distributing the COW token\n/// @title Vesting Logic\n/// @author CoW Protocol Developers\ncontract Vesting is VestingInterface {\n    /// @dev The timestamp of the official vesting start. This value is shared\n    /// between all participants.\n    uint256 public immutable vestingStart;\n    /// @dev How long it will take for all vesting to be completed. It is set to\n    /// four years.\n    uint256 public constant VESTING_PERIOD_IN_SECONDS = 4 * 365 days + 1 days;\n\n    /// @dev Stores the amount of vesting that the user has already vested.\n    mapping(address => uint256) public vestedAllocation;\n    /// @dev Stores the maximum amount of vesting available to each user. This\n    /// is exactly the total amount of vesting that can be converted after the\n    /// vesting period is completed.\n    mapping(address => uint256) public fullAllocation;\n\n    /// @dev Stores a bit indicating whether a vesting is cancelable\n    /// Important: This implementaiton implies that there can not be a\n    /// cancelable and non-cancelable vesting in parallel\n    mapping(address => bool) public isCancelable;\n\n    /// @dev Event emitted when a new vesting position is added. The amount is\n    /// the additional amount that can be vested at the end of the\n    /// claiming period.\n    event VestingAdded(address indexed user, uint256 amount, bool isCancelable);\n    /// @dev Event emitted when a vesting position is canceled. The amount is\n    /// the number of remaining vesting that will be given to the beneficiary.\n    event VestingStopped(\n        address indexed user,\n        address freedVestingBeneficiary,\n        uint256 amount\n    );\n    /// @dev Event emitted when the users claims (also partially) a vesting\n    /// position.\n    event Vested(address indexed user, uint256 amount);\n\n    /// @dev Error returned when trying to stop a claim that is not cancelable.\n    error VestingNotCancelable();\n\n    constructor() {\n        vestingStart = block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    /// @inheritdoc VestingInterface\n    function addVesting(\n        address user,\n        uint256 vestingAmount,\n        bool isCancelableFlag\n    ) internal override {\n        if (isCancelableFlag) {\n            // if one cancelable vesting is made, it converts all vestings into cancelable ones\n            isCancelable[user] = isCancelableFlag;\n        }\n        fullAllocation[user] += vestingAmount;\n        emit VestingAdded(user, vestingAmount, isCancelableFlag);\n    }\n\n    /// @inheritdoc VestingInterface\n    function shiftVesting(address user, address freedVestingBeneficiary)\n        internal\n        override\n        returns (uint256 accruedVesting)\n    {\n        if (!isCancelable[user]) {\n            revert VestingNotCancelable();\n        }\n        accruedVesting = vest(user);\n        uint256 userFullAllocation = fullAllocation[user];\n        uint256 userVestedAllocation = vestedAllocation[user];\n        fullAllocation[user] = 0;\n        vestedAllocation[user] = 0;\n        fullAllocation[freedVestingBeneficiary] += userFullAllocation;\n        vestedAllocation[freedVestingBeneficiary] += userVestedAllocation;\n        emit VestingStopped(\n            user,\n            freedVestingBeneficiary,\n            userFullAllocation - userVestedAllocation\n        );\n    }\n\n    /// @inheritdoc VestingInterface\n    function vest(address user)\n        internal\n        override\n        returns (uint256 newlyVested)\n    {\n        newlyVested = newlyVestedBalance(user);\n        vestedAllocation[user] += newlyVested;\n        emit Vested(user, newlyVested);\n    }\n\n    /// @dev Assuming no conversions has been done by the user, calculates how\n    /// much vesting can be converted at this point in time.\n    /// @param user The user for whom the result is being calculated.\n    /// @return How much vesting can be converted if no conversions had been\n    /// done before.\n    function cumulativeVestedBalance(address user)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            (Math.min(\n                block.timestamp - vestingStart, // solhint-disable-line not-rely-on-time\n                VESTING_PERIOD_IN_SECONDS\n            ) * fullAllocation[user]) / (VESTING_PERIOD_IN_SECONDS);\n    }\n\n    /// @dev Calculates how much vesting can be converted at this point in time.\n    /// Unlike `cumulativeVestedBalance`, this function keeps track of previous\n    /// conversions.\n    /// @param user The user for whom the result is being calculated.\n    /// @return How much vesting can be converted.\n    function newlyVestedBalance(address user) public view returns (uint256) {\n        return cumulativeVestedBalance(user) - vestedAllocation[user];\n    }\n}\n"
12     },
13     "src/contracts/mixins/Claiming.sol": {
14       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\n\npragma solidity ^0.8.10;\n\nimport \"../vendored/interfaces/IERC20.sol\";\nimport \"../vendored/libraries/SafeERC20.sol\";\n\nimport \"../interfaces/ClaimingInterface.sol\";\nimport \"../interfaces/VestingInterface.sol\";\n\n/// @dev The logic behind the claiming of virtual tokens and the swapping to\n/// real tokens.\n/// @title COW Virtual Token Claiming Logic\n/// @author CoW Protocol Developers\nabstract contract Claiming is ClaimingInterface, VestingInterface, IERC20 {\n    using SafeERC20 for IERC20;\n\n    /// @dev Prices are represented as fractions. For readability, the\n    /// denominator is one unit of the virtual token (assuming it has 18\n    /// decimals), in this way the numerator of a price is the number of atoms\n    /// that have the same value as a unit of virtual token.\n    uint256 internal constant PRICE_DENOMINATOR = 10**18;\n    /// @dev Price numerator for the COW/USDC price. This is the number of USDC\n    /// atoms required to obtain a full unit of virtual token from an option.\n    uint256 public immutable usdcPrice;\n    /// @dev Price numerator for the COW/GNO price. This is the number of GNO\n    /// atoms required to obtain a full unit of virtual token from an option.\n    uint256 public immutable gnoPrice;\n    /// @dev Price numerator for the COW/native-token price. This is the number\n    /// of native token wei required to obtain a full unit of virtual token from\n    /// an option.\n    uint256 public immutable nativeTokenPrice;\n\n    /// @dev The proceeds from selling options to the community will be sent to,\n    /// this address.\n    address payable public immutable communityFundsTarget;\n    /// @dev All proceeds from known investors will be sent to this address.\n    address public immutable investorFundsTarget;\n\n    /// @dev Address of the real COW token. Tokens claimed by this contract can\n    /// be converted to this token if this contract stores some balance of it.\n    IERC20 public immutable cowToken;\n    /// @dev Address of the USDC token. It is a form of payment for investors.\n    IERC20 public immutable usdcToken;\n    /// @dev Address of the GNO token. It is a form of payment for users who\n    /// claim the options derived from holding GNO.\n    IERC20 public immutable gnoToken;\n    /// @dev Address of the wrapped native token. It is a form of payment for\n    /// users who claim the options derived from being users of the CoW\n    /// Protocol.\n    IERC20 public immutable wrappedNativeToken;\n\n    /// @dev Address representing the CoW Protocol/CowSwap team. It is the only\n    /// address that is allowed to stop the vesting of a claim, and exclusively\n    /// for team claims.\n    address public immutable teamController;\n\n    /// @dev Time at which this contract was deployed.\n    uint256 public immutable deploymentTimestamp;\n\n    /// @dev Returns the amount of virtual tokens in existence, including those\n    /// that have yet to be vested.\n    uint256 public totalSupply;\n\n    /// @dev How many tokens can be immediately swapped in exchange for real\n    /// tokens for each user.\n    mapping(address => uint256) public instantlySwappableBalance;\n\n    /// @dev Error presented to a user trying to claim virtual tokens after the\n    /// claiming period has ended.\n    error ClaimingExpired();\n    /// @dev Error presented to anyone but the team controller to stop a\n    /// cancelable vesting position (i.e., only team vesting).\n    error OnlyTeamController();\n    /// @dev Error resulting from sending an incorrect amount of native to the\n    /// contract.\n    error InvalidNativeTokenAmount();\n    /// @dev Error caused by an unsuccessful attempt to transfer native tokens.\n    error FailedNativeTokenTransfer();\n    /// @dev Error resulting from sending native tokens for a claim that cannot\n    /// be redeemed with native tokens.\n    error CannotSendNativeToken();\n\n    constructor(\n        address _cowToken,\n        address payable _communityFundsTarget,\n        address _investorFundsTarget,\n        address _usdcToken,\n        uint256 _usdcPrice,\n        address _gnoToken,\n        uint256 _gnoPrice,\n        address _wrappedNativeToken,\n        uint256 _nativeTokenPrice,\n        address _teamController\n    ) {\n        cowToken = IERC20(_cowToken);\n        communityFundsTarget = _communityFundsTarget;\n        investorFundsTarget = _investorFundsTarget;\n        usdcToken = IERC20(_usdcToken);\n        usdcPrice = _usdcPrice;\n        gnoToken = IERC20(_gnoToken);\n        gnoPrice = _gnoPrice;\n        wrappedNativeToken = IERC20(_wrappedNativeToken);\n        nativeTokenPrice = _nativeTokenPrice;\n        teamController = _teamController;\n\n        // solhint-disable-next-line not-rely-on-time\n        deploymentTimestamp = block.timestamp;\n    }\n\n    /// @dev Allows the decorated function only to be executed before the\n    /// contract deployment date plus the input amount of seconds.\n    /// @param durationSinceDeployment Number of seconds after contract\n    /// deployment before which the function can be executed anymore. The\n    /// function reverts afterwards.\n    modifier before(uint256 durationSinceDeployment) {\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp > deploymentTimestamp + durationSinceDeployment) {\n            revert ClaimingExpired();\n        }\n        _;\n    }\n\n    /// @dev The decorated function can only be executed by the team controller.\n    modifier onlyTeamController() {\n        if (msg.sender != teamController) {\n            revert OnlyTeamController();\n        }\n        _;\n    }\n\n    /// @inheritdoc ClaimingInterface\n    function performClaim(\n        ClaimType claimType,\n        address payer,\n        address claimant,\n        uint256 amount,\n        uint256 sentNativeTokens\n    ) internal override {\n        if (claimType == ClaimType.Airdrop) {\n            claimAirdrop(claimant, amount, sentNativeTokens);\n        } else if (claimType == ClaimType.GnoOption) {\n            claimGnoOption(claimant, amount, payer, sentNativeTokens);\n        } else if (claimType == ClaimType.UserOption) {\n            claimUserOption(claimant, amount, payer, sentNativeTokens);\n        } else if (claimType == ClaimType.Investor) {\n            claimInvestor(claimant, amount, payer, sentNativeTokens);\n        } else if (claimType == ClaimType.Team) {\n            claimTeam(claimant, amount, sentNativeTokens);\n        } else {\n            // claimType == ClaimType.Advisor\n            claimAdvisor(claimant, amount, sentNativeTokens);\n        }\n\n        // Each claiming operation results in the creation of `amount` virtual\n        // tokens.\n        totalSupply += amount;\n        emit Transfer(address(0), claimant, amount);\n    }\n\n    /// @dev Stops all vesting claims of a user. This is only applicable for\n    /// claims that are cancellable, i.e., team claims.\n    /// @param user The user whose vesting claims should be canceled.\n    function stopClaim(address user) external onlyTeamController {\n        uint256 accruedVesting = shiftVesting(user, teamController);\n        instantlySwappableBalance[user] += accruedVesting;\n    }\n\n    /// @dev Transfers all ETH stored in the contract to the community funds\n    // target.\n    function withdrawEth() external {\n        // We transfer ETH using .call instead of .transfer as not to restrict\n        // the amount of gas sent to the target address during the transfer.\n        // This is particularly relevant for sending ETH to smart contracts:\n        // since EIP 2929, if a contract sends eth using `.transfer` then the\n        // transaction proposed to the node needs to specify an _access list_,\n        // which is currently not well supported by some wallet implementations.\n        // There is no reentrancy risk as this call does not touch any storage\n        // slot and the contract balance is not used in other logic.\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = communityFundsTarget.call{\n            value: address(this).balance\n        }(\"\");\n        if (!success) {\n            revert FailedNativeTokenTransfer();\n        }\n    }\n\n    /// @dev Performs an airdrop-type claim for the user.\n    /// @param account The user for which the claim is performed.\n    /// @param amount The full amount claimed by the user.\n    /// @param sentNativeTokens Amount of ETH sent along to the transaction.\n    function claimAirdrop(\n        address account,\n        uint256 amount,\n        uint256 sentNativeTokens\n    ) private before(6 weeks) {\n        if (sentNativeTokens != 0) {\n            revert CannotSendNativeToken();\n        }\n        instantlySwappableBalance[account] += amount;\n    }\n\n    /// @dev Claims a Gno option for the user.\n    /// @param account The user for which the claim is performed.\n    /// @param amount The full amount claimed by the user after vesting.\n    /// @param payer The address that pays the amount required by the claim.\n    /// @param sentNativeTokens Amount of ETH sent along to the transaction.\n    function claimGnoOption(\n        address account,\n        uint256 amount,\n        address payer,\n        uint256 sentNativeTokens\n    ) private before(2 weeks) {\n        if (sentNativeTokens != 0) {\n            revert CannotSendNativeToken();\n        }\n        collectPayment(gnoToken, gnoPrice, payer, communityFundsTarget, amount);\n        addVesting(account, amount, false);\n    }\n\n    /// @dev Claims a native-token-based option for the user.\n    /// @param account The user for which the claim is performed.\n    /// @param amount The full amount claimed by the user after vesting.\n    /// @param payer The address that pays the amount required by the claim.\n    /// @param sentNativeTokens Amount of ETH sent along to the transaction.\n    function claimUserOption(\n        address account,\n        uint256 amount,\n        address payer,\n        uint256 sentNativeTokens\n    ) private before(2 weeks) {\n        if (sentNativeTokens != 0) {\n            collectNativeTokenPayment(amount, sentNativeTokens);\n        } else {\n            collectPayment(\n                wrappedNativeToken,\n                nativeTokenPrice,\n                payer,\n                communityFundsTarget,\n                amount\n            );\n        }\n        addVesting(account, amount, false);\n    }\n\n    /// @dev Claims an investor option.\n    /// @param account The user for which the claim is performed.\n    /// @param amount The full amount claimed by the user after vesting.\n    /// @param payer The address that pays the amount required by the claim.\n    /// @param sentNativeTokens Amount of ETH sent along to the transaction.\n    function claimInvestor(\n        address account,\n        uint256 amount,\n        address payer,\n        uint256 sentNativeTokens\n    ) private before(2 weeks) {\n        if (sentNativeTokens != 0) {\n            revert CannotSendNativeToken();\n        }\n        collectPayment(\n            usdcToken,\n            usdcPrice,\n            payer,\n            investorFundsTarget,\n            amount\n        );\n        addVesting(account, amount, false);\n    }\n\n    /// @dev Claims a team option. Team options are granted without any payment\n    /// but can be canceled.\n    /// @param account The user for which the claim is performed.\n    /// @param amount The full amount claimed by the user after vesting.\n    /// @param sentNativeTokens Amount of ETH sent along to the transaction.\n    function claimTeam(\n        address account,\n        uint256 amount,\n        uint256 sentNativeTokens\n    ) private before(6 weeks) {\n        if (sentNativeTokens != 0) {\n            revert CannotSendNativeToken();\n        }\n        addVesting(account, amount, true);\n    }\n\n    /// @dev Claims an adviser option. Team options are granted without any\n    /// payment and cannot be canceled.\n    /// @param account The user for which the claim is performed.\n    /// @param amount The full amount claimed by the user after vesting.\n    /// @param sentNativeTokens Amount of ETH sent along to the transaction.\n    function claimAdvisor(\n        address account,\n        uint256 amount,\n        uint256 sentNativeTokens\n    ) private before(6 weeks) {\n        if (sentNativeTokens != 0) {\n            revert CannotSendNativeToken();\n        }\n        addVesting(account, amount, false);\n    }\n\n    /// @dev Executes a transfer from the user to the target. The transfered\n    /// amount is based on the input COW price and amount of COW bought.\n    /// @param token The token used for the payment.\n    /// @param price The number of atoms of the input token that are equivalent\n    /// to one atom of COW multiplied by PRICE_DENOMINATOR.\n    /// @param from The address from which to take the funds.\n    /// @param to The address to which to send the funds.\n    /// @param amount The amount of COW atoms that will be paid for.\n    function collectPayment(\n        IERC20 token,\n        uint256 price,\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        uint256 tokenEquivalent = convertCowAmountAtPrice(amount, price);\n        token.safeTransferFrom(from, to, tokenEquivalent);\n    }\n\n    /// @dev Transfers native tokens from this contract to the target, assuming\n    /// that the amount of native tokens sent coincides with the expected amount\n    /// of native tokens. This amount is based on the price of the native token\n    /// and amount of COW bought.\n    /// @param amount The amount of COW atoms that will be paid for.\n    /// @param sentNativeTokens Amount of ETH sent along to the transaction.\n    function collectNativeTokenPayment(uint256 amount, uint256 sentNativeTokens)\n        private\n        view\n    {\n        uint256 nativeTokenEquivalent = convertCowAmountAtPrice(\n            amount,\n            nativeTokenPrice\n        );\n        if (sentNativeTokens != nativeTokenEquivalent) {\n            revert InvalidNativeTokenAmount();\n        }\n    }\n\n    /// @dev Converts input amount in COW token atoms to an amount in token\n    /// atoms at the specified price.\n    /// @param amount Amount of tokens to convert.\n    /// @param price The number of atoms of the input token that are equivalent\n    /// to one atom of COW *multiplied by PRICE_DENOMINATOR*.\n    function convertCowAmountAtPrice(uint256 amount, uint256 price)\n        private\n        pure\n        returns (uint256)\n    {\n        return (amount * price) / PRICE_DENOMINATOR;\n    }\n\n    /// @dev Converts an amount of (virtual) tokens from this contract to real\n    /// tokens based on the claims previously performed by the caller.\n    /// @param amount How many virtual tokens to convert into real tokens.\n    function swap(uint256 amount) external {\n        makeVestingSwappable();\n        _swap(amount);\n    }\n\n    /// @dev Converts all available (virtual) tokens from this contract to real\n    /// tokens based on the claims previously performed by the caller.\n    /// @return swappedBalance The full amount that was swapped (i.e., virtual\n    /// tokens burnt as well as real tokens received).\n    function swapAll() external returns (uint256 swappedBalance) {\n        swappedBalance = makeVestingSwappable();\n        _swap(swappedBalance);\n    }\n\n    /// @dev Transfers real tokens to the message sender and reduces the balance\n    /// of virtual tokens available. Note that this function assumes that the\n    /// current contract stores enough real tokens to fulfill this swap request.\n    /// @param amount How many virtual tokens to convert into real tokens.\n    function _swap(uint256 amount) private {\n        instantlySwappableBalance[msg.sender] -= amount;\n        totalSupply -= amount;\n        cowToken.safeTransfer(msg.sender, amount);\n        emit Transfer(msg.sender, address(0), amount);\n    }\n\n    /// @dev Adds the currently vested amount to the immediately swappable\n    /// balance.\n    /// @return swappableBalance The maximum balance that can be swapped at\n    /// this point in time by the caller.\n    function makeVestingSwappable() private returns (uint256 swappableBalance) {\n        swappableBalance =\n            instantlySwappableBalance[msg.sender] +\n            vest(msg.sender);\n        instantlySwappableBalance[msg.sender] = swappableBalance;\n    }\n}\n"
15     },
16     "src/contracts/mixins/MerkleDistributor.sol": {
17       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\n\n// This contract is based on Uniswap's MekleDistributor, which can be found at:\n// https://github.com/Uniswap/merkle-distributor/blob/0d478d722da2e5d95b7292fd8cbdb363d98e9a93/contracts/MerkleDistributor.sol\n//\n// The changes between the original contract and this are:\n//  - the claim function doesn't trigger a transfer on a successful proof, but\n//    it executes a dedicated (virtual) function.\n//  - added a claimMany function for bundling multiple claims in a transaction\n//  - supported sending an amount of native tokens along with the claim\n//  - added the option of claiming less than the maximum amount\n//  - gas optimizations in the packing and unpacking of the claimed bit\n//  - bumped Solidity version\n//  - code formatting\n\npragma solidity ^0.8.10;\n\nimport \"../vendored/interfaces/IERC20.sol\";\nimport \"../vendored/libraries/MerkleProof.sol\";\n\nimport \"../interfaces/ClaimingInterface.sol\";\n\nabstract contract MerkleDistributor is ClaimingInterface {\n    bytes32 public immutable merkleRoot;\n\n    /// @dev Event fired if a claim was successfully performed.\n    event Claimed(\n        uint256 index,\n        ClaimType claimType,\n        address claimant,\n        uint256 claimableAmount,\n        uint256 claimedAmount\n    );\n\n    /// @dev Error caused by a user trying to call the claim function for a\n    /// claim that has already been used before.\n    error AlreadyClaimed();\n    /// @dev Error caused by a user trying to claim a larger amount than the\n    /// maximum allowed in the claim.\n    error ClaimingMoreThanMaximum();\n    /// @dev Error caused by the caller trying to perform a partial claim while\n    /// not being the owner of the claim.\n    error OnlyOwnerCanClaimPartially();\n    /// @dev Error caused by calling the claim function with an invalid proof.\n    error InvalidProof();\n    /// @dev Error caused by calling claimMany with a transaction value that is\n    /// different from the required one.\n    error InvalidNativeTokenValue();\n\n    /// @dev Packed array of booleans that stores if a claim is available.\n    mapping(uint256 => uint256) private claimedBitMap;\n\n    constructor(bytes32 merkleRoot_) {\n        merkleRoot = merkleRoot_;\n    }\n\n    /// @dev Checks if the claim at the provided index has already been claimed.\n    /// @param index The index to check.\n    /// @return Whether the claim at the given index has already been claimed.\n    function isClaimed(uint256 index) public view returns (bool) {\n        uint256 claimedWordIndex = index >> 8;\n        uint256 claimedBitIndex = index & 0xff;\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask != 0;\n    }\n\n    /// @dev Mark the provided index as having been claimed.\n    /// @param index The index that was claimed.\n    function _setClaimed(uint256 index) private {\n        uint256 claimedWordIndex = index >> 8;\n        uint256 claimedBitIndex = index & 0xff;\n        claimedBitMap[claimedWordIndex] =\n            claimedBitMap[claimedWordIndex] |\n            (1 << claimedBitIndex);\n    }\n\n    /// @dev This function verifies the provided input proof based on the\n    /// provided input. If the proof is valid, the function [`performClaim`] is\n    /// called for the claimed amount.\n    /// @param index The index that identifies the input claim.\n    /// @param claimType See [`performClaim`].\n    /// @param claimant See [`performClaim`].\n    /// @param claimableAmount The maximum amount that the claimant can claim\n    /// for this claim. Should not be smaller than claimedAmount.\n    /// @param claimedAmount See [`performClaim`].\n    /// @param merkleProof A proof that the input claim belongs to the unique\n    /// Merkle root associated to this contract.\n    function claim(\n        uint256 index,\n        ClaimType claimType,\n        address claimant,\n        uint256 claimableAmount,\n        uint256 claimedAmount,\n        bytes32[] calldata merkleProof\n    ) external payable {\n        _claim(\n            index,\n            claimType,\n            claimant,\n            claimableAmount,\n            claimedAmount,\n            merkleProof,\n            msg.value\n        );\n    }\n\n    /// @dev This function verifies and executes multiple claims in the same\n    /// transaction.\n    /// @param indices A vector of indices. See [`claim`] for details.\n    /// @param claimTypes A vector of claim types. See [`performClaim`] for\n    /// details.\n    /// @param claimants A vector of claimants. See [`performClaim`] for\n    /// details.\n    /// @param claimableAmounts A vector of claimable amounts. See [`claim`] for\n    /// details.\n    /// @param claimedAmounts A vector of claimed amounts. See [`performClaim`]\n    /// for details.\n    /// @param merkleProofs A vector of merkle proofs. See [`claim`] for\n    /// details.\n    /// @param sentNativeTokens A vector of native token amounts. See\n    /// [`performClaim`] for details.\n    function claimMany(\n        uint256[] memory indices,\n        ClaimType[] memory claimTypes,\n        address[] calldata claimants,\n        uint256[] calldata claimableAmounts,\n        uint256[] calldata claimedAmounts,\n        bytes32[][] calldata merkleProofs,\n        uint256[] calldata sentNativeTokens\n    ) external payable {\n        uint256 sumSentNativeTokens;\n        for (uint256 i = 0; i < indices.length; i++) {\n            sumSentNativeTokens += sentNativeTokens[i];\n            _claim(\n                indices[i],\n                claimTypes[i],\n                claimants[i],\n                claimableAmounts[i],\n                claimedAmounts[i],\n                merkleProofs[i],\n                sentNativeTokens[i]\n            );\n        }\n        if (sumSentNativeTokens != msg.value) {\n            revert InvalidNativeTokenValue();\n        }\n    }\n\n    /// @dev This function verifies the provided input proof based on the\n    /// provided input. If the proof is valid, the function [`performClaim`] is\n    /// called for the claimed amount.\n    /// @param index See [`claim`].\n    /// @param claimType See [`performClaim`].\n    /// @param claimant See [`performClaim`].\n    /// @param claimableAmount See [`claim`].\n    /// @param claimedAmount See [`performClaim`].\n    /// @param merkleProof See [`claim`].\n    /// @param sentNativeTokens See [`performClaim`].\n    function _claim(\n        uint256 index,\n        ClaimType claimType,\n        address claimant,\n        uint256 claimableAmount,\n        uint256 claimedAmount,\n        bytes32[] calldata merkleProof,\n        uint256 sentNativeTokens\n    ) private {\n        if (isClaimed(index)) {\n            revert AlreadyClaimed();\n        }\n        if (claimedAmount > claimableAmount) {\n            revert ClaimingMoreThanMaximum();\n        }\n        if ((claimedAmount < claimableAmount) && (msg.sender != claimant)) {\n            revert OnlyOwnerCanClaimPartially();\n        }\n\n        // Note: all types used inside `encodePacked` should have fixed length,\n        // otherwise the same proof could be used in different claims.\n        bytes32 node = keccak256(\n            abi.encodePacked(index, claimType, claimant, claimableAmount)\n        );\n        if (!MerkleProof.verify(merkleProof, merkleRoot, node)) {\n            revert InvalidProof();\n        }\n\n        _setClaimed(index);\n\n        performClaim(\n            claimType,\n            msg.sender,\n            claimant,\n            claimedAmount,\n            sentNativeTokens\n        );\n\n        emit Claimed(\n            index,\n            claimType,\n            claimant,\n            claimableAmount,\n            claimedAmount\n        );\n    }\n}\n"
18     },
19     "src/contracts/vendored/mixins/StorageAccessible.sol": {
20       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n// Vendored from Gnosis utility contracts, see:\n// <https://raw.githubusercontent.com/gnosis/gp-v2-contracts/40c349d52d14f8f3c9f787fe2fca5a496bb10ea9/src/contracts/mixins/StorageAccessible.sol>\n// The following changes were made:\n// - Modified Solidity version\n// - Formatted code\n\npragma solidity ^0.8.10;\n\n/// @title ViewStorageAccessible - Interface on top of StorageAccessible base class to allow simulations from view functions\ninterface ViewStorageAccessible {\n    /**\n     * @dev Same as `simulateDelegatecall` on StorageAccessible. Marked as view so that it can be called from external contracts\n     * that want to run simulations from within view functions. Will revert if the invoked simulation attempts to change state.\n     */\n    function simulateDelegatecall(\n        address targetContract,\n        bytes memory calldataPayload\n    ) external view returns (bytes memory);\n\n    /**\n     * @dev Same as `getStorageAt` on StorageAccessible. This method allows reading aribtrary ranges of storage.\n     */\n    function getStorageAt(uint256 offset, uint256 length)\n        external\n        view\n        returns (bytes memory);\n}\n\n/// @title StorageAccessible - generic base contract that allows callers to access all internal storage.\ncontract StorageAccessible {\n    /**\n     * @dev Reads `length` bytes of storage in the currents contract\n     * @param offset - the offset in the current contract's storage in words to start reading from\n     * @param length - the number of words (32 bytes) of data to read\n     * @return the bytes that were read.\n     */\n    function getStorageAt(uint256 offset, uint256 length)\n        external\n        view\n        returns (bytes memory)\n    {\n        bytes memory result = new bytes(length * 32);\n        for (uint256 index = 0; index < length; index++) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let word := sload(add(offset, index))\n                mstore(add(add(result, 0x20), mul(index, 0x20)), word)\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Performs a delegetecall on a targetContract in the context of self.\n     * Internally reverts execution to avoid side effects (making it static). Catches revert and returns encoded result as bytes.\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulateDelegatecall(\n        address targetContract,\n        bytes memory calldataPayload\n    ) public returns (bytes memory response) {\n        bytes memory innerCall = abi.encodeWithSelector(\n            this.simulateDelegatecallInternal.selector,\n            targetContract,\n            calldataPayload\n        );\n        // solhint-disable-next-line avoid-low-level-calls\n        (, response) = address(this).call(innerCall);\n        bool innerSuccess = response[response.length - 1] == 0x01;\n        setLength(response, response.length - 1);\n        if (innerSuccess) {\n            return response;\n        } else {\n            revertWith(response);\n        }\n    }\n\n    /**\n     * @dev Performs a delegetecall on a targetContract in the context of self.\n     * Internally reverts execution to avoid side effects (making it static). Returns encoded result as revert message\n     * concatenated with the success flag of the inner call as a last byte.\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulateDelegatecallInternal(\n        address targetContract,\n        bytes memory calldataPayload\n    ) external returns (bytes memory response) {\n        bool success;\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, response) = targetContract.delegatecall(calldataPayload);\n        revertWith(abi.encodePacked(response, success));\n    }\n\n    function revertWith(bytes memory response) internal pure {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            revert(add(response, 0x20), mload(response))\n        }\n    }\n\n    function setLength(bytes memory buffer, uint256 length) internal pure {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(buffer, length)\n        }\n    }\n}\n"
21     },
22     "src/contracts/vendored/interfaces/IERC20.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin Contracts v4.4.0, see:\n// <https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.4.0/contracts/token/ERC20/IERC20.sol>\n\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
24     },
25     "src/contracts/vendored/libraries/Math.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin Contracts v4.4.0, see:\n// <https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.4.0/contracts/utils/math/Math.sol>\n\n// OpenZeppelin Contracts v4.4.0 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
27     },
28     "src/contracts/interfaces/VestingInterface.sol": {
29       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\n\npragma solidity ^0.8.10;\n\n/// @dev The contract functions that are shared between the `Vesting` and\n/// `Claiming` contracts. The two components are handled and tested\n/// separately and are linked to each other by the functions in this contract.\n/// This contracs is for all intents and purposes an interface, however actual\n/// interfaces cannot declare internal functions.\n/// @title COW token vesting interface.\n/// @author CoW Protocol Developers\nabstract contract VestingInterface {\n    /// @dev Adds an amount that will be vested over time.\n    /// Should be called from the parent contract on redeeming a vested claim.\n    /// @param user The user for whom the vesting is performed.\n    /// @param vestingAmount The (added) amount to be vested in time.\n    /// @param isCancelableFlag Flag whether the vesting is cancelable\n    function addVesting(\n        address user,\n        uint256 vestingAmount,\n        bool isCancelableFlag\n    ) internal virtual;\n\n    /// @dev Computes the current vesting from the total vested amount and marks\n    /// that amount as converted. This is called by the parent contract every\n    /// time virtual tokens from a vested claim are swapped into real tokens.\n    /// @param user The user for which the amount is vested.\n    /// @return Amount converted.\n    function vest(address user) internal virtual returns (uint256);\n\n    /// @dev Transfers a cancelable vesting of a user to another address.\n    /// Returns the amount of token that is not yet converted.\n    /// @param user The user for whom the vesting is removed.\n    /// @param freedVestingBeneficiary The address to which to assign the amount\n    /// that remains to be vested.\n    /// @return accruedVesting The total number of tokens that remain to be\n    /// converted\n    function shiftVesting(address user, address freedVestingBeneficiary)\n        internal\n        virtual\n        returns (uint256 accruedVesting);\n}\n"
30     },
31     "src/contracts/vendored/libraries/SafeERC20.sol": {
32       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\n\n// Vendored from GPv2 contracts v1.1.2, see:\n// <https://raw.githubusercontent.com/gnosis/gp-v2-contracts/7fb88982021e9a274d631ffb598694e6d9b30089/src/contracts/libraries/GPv2SafeERC20.sol>\n// The following changes were made:\n// - Bumped up Solidity version and checked that the assembly is still valid.\n// - Use own vendored IERC20 instead of custom implementation.\n// - Removed \"GPv2\" from contract name.\n// - Modified revert messages, including length.\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IERC20.sol\";\n\n/// @title Gnosis Protocol v2 Safe ERC20 Transfer Library\n/// @author Gnosis Developers\n/// @dev Gas-efficient version of Openzeppelin's SafeERC20 contract.\nlibrary SafeERC20 {\n    /// @dev Wrapper around a call to the ERC20 function `transfer` that reverts\n    /// also when the token returns `false`.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        bytes4 selector_ = token.transfer.selector;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, selector_)\n            mstore(\n                add(freeMemoryPointer, 4),\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            mstore(add(freeMemoryPointer, 36), value)\n\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        require(getLastTransferResult(token), \"SafeERC20: failed transfer\");\n    }\n\n    /// @dev Wrapper around a call to the ERC20 function `transferFrom` that\n    /// reverts also when the token returns `false`.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        bytes4 selector_ = token.transferFrom.selector;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, selector_)\n            mstore(\n                add(freeMemoryPointer, 4),\n                and(from, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            mstore(\n                add(freeMemoryPointer, 36),\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            mstore(add(freeMemoryPointer, 68), value)\n\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        require(getLastTransferResult(token), \"SafeERC20: failed transferFrom\");\n    }\n\n    /// @dev Verifies that the last return was a successful `transfer*` call.\n    /// This is done by checking that the return data is either empty, or\n    /// is a valid ABI encoded boolean.\n    function getLastTransferResult(IERC20 token)\n        private\n        view\n        returns (bool success)\n    {\n        // NOTE: Inspecting previous return data requires assembly. Note that\n        // we write the return data to memory 0 in the case where the return\n        // data size is 32, this is OK since the first 64 bytes of memory are\n        // reserved by Solidy as a scratch space that can be used within\n        // assembly blocks.\n        // <https://docs.soliditylang.org/en/v0.8.10/internals/layout_in_memory.html>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            /// @dev Revert with an ABI encoded Solidity error with a message\n            /// that fits into 32-bytes.\n            ///\n            /// An ABI encoded Solidity error has the following memory layout:\n            ///\n            /// ------------+----------------------------------\n            ///  byte range | value\n            /// ------------+----------------------------------\n            ///  0x00..0x04 |        selector(\"Error(string)\")\n            ///  0x04..0x24 |      string offset (always 0x20)\n            ///  0x24..0x44 |                    string length\n            ///  0x44..0x64 | string value, padded to 32-bytes\n            function revertWithMessage(length, message) {\n                mstore(0x00, \"\\x08\\xc3\\x79\\xa0\")\n                mstore(0x04, 0x20)\n                mstore(0x24, length)\n                mstore(0x44, message)\n                revert(0x00, 0x64)\n            }\n\n            switch returndatasize()\n            // Non-standard ERC20 transfer without return.\n            case 0 {\n                // NOTE: When the return data size is 0, verify that there\n                // is code at the address. This is done in order to maintain\n                // compatibility with Solidity calling conventions.\n                // <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#external-function-calls>\n                if iszero(extcodesize(token)) {\n                    revertWithMessage(25, \"SafeERC20: not a contract\")\n                }\n\n                success := 1\n            }\n            // Standard ERC20 transfer returning boolean success value.\n            case 32 {\n                returndatacopy(0, 0, returndatasize())\n\n                // NOTE: For ABI encoding v1, any non-zero value is accepted\n                // as `true` for a boolean. In order to stay compatible with\n                // OpenZeppelin's `SafeERC20` library which is known to work\n                // with the existing ERC20 implementation we care about,\n                // make sure we return success for any non-zero return value\n                // from the `transfer*` call.\n                success := iszero(iszero(mload(0)))\n            }\n            default {\n                revertWithMessage(30, \"SafeERC20: bad transfer result\")\n            }\n        }\n    }\n}\n"
33     },
34     "src/contracts/interfaces/ClaimingInterface.sol": {
35       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\n\npragma solidity ^0.8.10;\n\n/// @dev The contract functions that are shared between the `Claiming` and\n/// `MerkleDistributor` contracts. The two components are handled and tested\n/// separately and are linked to each other by the functions in this contract.\n/// This contracs is for all intents and purposes an interface, however actual\n/// interfaces cannot declare internal functions.\n/// @title COW token claiming interface.\n/// @author CoW Protocol Developers\nabstract contract ClaimingInterface {\n    /// @dev Exhaustive list of the different branches of the claiming logic.\n    enum ClaimType {\n        Airdrop,\n        GnoOption,\n        UserOption,\n        Investor,\n        Team,\n        Advisor\n    }\n\n    /// @dev This function is executed when a valid proof of the claim is\n    /// provided and executes all steps required for each claim type.\n    /// @param claimType Which claim will be performed. See [`ClaimType`] for\n    /// an exausting list.\n    /// @param payer The address that will pay if the claim to be performed\n    /// requires a payment.\n    /// @param claimant The account to which the claim is assigned and which\n    /// will receive the corresponding virtual tokens.\n    /// @param claimedAmount The amount that the user decided to claim (after\n    /// vesting if it applies).\n    /// @param sentNativeTokens The amount of native tokens that the user sent\n    /// along with the transaction.\n    function performClaim(\n        ClaimType claimType,\n        address payer,\n        address claimant,\n        uint256 claimedAmount,\n        uint256 sentNativeTokens\n    ) internal virtual;\n}\n"
36     },
37     "src/contracts/vendored/libraries/MerkleProof.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin Contracts v4.4.0, see:\n// <https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.4.0/contracts/utils/cryptography/MerkleProof.sol>\n\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(\n                    abi.encodePacked(computedHash, proofElement)\n                );\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(\n                    abi.encodePacked(proofElement, computedHash)\n                );\n            }\n        }\n        return computedHash;\n    }\n}\n"
39     }
40   },
41   "settings": {
42     "optimizer": {
43       "enabled": true,
44       "runs": 1000000
45     },
46     "outputSelection": {
47       "*": {
48         "*": [
49           "evm.bytecode",
50           "evm.deployedBytecode",
51           "devdoc",
52           "userdoc",
53           "metadata",
54           "abi"
55         ]
56       }
57     },
58     "libraries": {}
59   }
60 }}