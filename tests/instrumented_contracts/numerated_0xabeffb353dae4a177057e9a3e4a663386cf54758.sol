1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/inft/NFTStaking.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../utils/AccessControl.sol\";\n\n/**\n * @title NFT Staking\n *\n * @notice Enables NFT staking for a given NFT smart contract defined on deployment\n *\n * @notice Doesn't introduce any rewards, just tracks the stake/unstake dates for each\n *      token/owner, this data will be used later on to process the rewards\n */\ncontract NFTStaking is AccessControl {\n\t/**\n\t * @dev Main staking data structure keeping track of a stake,\n\t *      used in `tokenStakes` array mapping\n\t */\n\tstruct StakeData {\n\t\t/**\n\t\t * @dev Who owned and staked the token, who will be the token\n\t\t *      returned to once unstaked\n\t\t */\n\t\taddress owner;\n\n\t\t/**\n\t\t * @dev When the token was staked and transferred from the owner,\n\t\t *      unix timestamp\n\t\t */\n\t\tuint32 stakedOn;\n\n\t\t/**\n\t\t * @dev When token was unstaked and returned back to the owner,\n\t\t *      unix timestamp\n\t\t * @dev Zero value means the token is still staked\n\t\t */\n\t\tuint32 unstakedOn;\n\t}\n\n\t/**\n\t * @dev Auxiliary data structure to help iterate over NFT owner stakes,\n\t *      used in `userStakes` array mapping\n\t */\n\tstruct StakeIndex {\n\t\t/**\n\t\t * @dev Staked token ID\n\t\t */\n\t\tuint32 tokenId;\n\n\t\t/**\n\t\t * @dev Where to look for main staking data `StakeData`\n\t\t *      in `tokenStakes` array mapping\n\t\t */\n\t\tuint32 index;\n\t}\n\n\t/**\n\t * @dev NFT smart contract to stake/unstake tokens of\n\t */\n\taddress public immutable targetContract;\n\n\t/**\n\t * @notice For each token ID stores the history of its stakes,\n\t *      last element of the history may be \"open\" (unstakedOn = 0),\n\t *      meaning the token is still staked and is ot be returned to the `owner`\n\t *\n\t * @dev Maps token ID => StakeData[]\n\t */\n\tmapping(uint32 => StakeData[]) public tokenStakes;\n\n\t/**\n\t * @notice For each owner address stores the links to its stakes,\n\t *      the link is represented as StakeIndex data struct\n\t *\n\t * @dev Maps owner address => StakeIndex[]\n\t */\n\tmapping(address => StakeIndex[]) public userStakes;\n\n\t/**\n\t * @dev Enables staking, stake(), stakeBatch()\n\t */\n\tuint32 public constant FEATURE_STAKING = 0x0000_0001;\n\n\t/**\n\t * @dev Enables unstaking, unstake(), unstakeBatch()\n\t */\n\tuint32 public constant FEATURE_UNSTAKING = 0x0000_0002;\n\n\t/**\n\t * @notice People do mistake and may send tokens by mistake; since\n\t *      staking contract is not designed to accept the tokens directly,\n\t *      it allows the rescue manager to \"rescue\" such lost tokens\n\t *\n\t * @notice Rescue manager is responsible for \"rescuing\" ERC20/ERC721 tokens\n\t *      accidentally sent to the smart contract\n\t *\n\t * @dev Role ROLE_RESCUE_MANAGER allows withdrawing non-staked ERC20/ERC721\n\t *      tokens stored on the smart contract balance\n\t */\n\tuint32 public constant ROLE_RESCUE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @dev Fired in stake(), stakeBatch()\n\t *\n\t * @param _by token owner, tx executor\n\t * @param _tokenId token ID staked and transferred into the smart contract\n\t * @param _when unix timestamp of when staking happened\n\t */\n\tevent Staked(address indexed _by, uint32 indexed _tokenId, uint32 _when);\n\n\t/**\n\t * @dev Fired in unstake(), unstakeBatch()\n\t *\n\t * @param _by token owner, tx executor\n\t * @param _tokenId token ID unstaked and transferred back to owner\n\t * @param _when unix timestamp of when unstaking happened\n\t */\n\tevent Unstaked(address indexed _by, uint32 indexed _tokenId, uint32 _when);\n\n\t/**\n\t * @dev Creates/deploys NFT staking contract bound to the already deployed\n\t *      target NFT ERC721 smart contract to be staked\n\t *\n\t * @param _nft address of the deployed NFT smart contract instance\n\t */\n\tconstructor(address _nft) {\n\t\t// verify input is set\n\t\trequire(_nft != address(0), \"target contract is not set\");\n\n\t\t// verify input is valid smart contract of the expected interface\n\t\trequire(ERC165(_nft).supportsInterface(type(ERC721).interfaceId), \"unexpected target type\");\n\n\t\t// setup smart contract internal state\n\t\ttargetContract = _nft;\n\t}\n\n\t/**\n\t * @notice How many times a particular token was staked\n\t *\n\t * @dev Used to iterate `tokenStakes(tokenId, i)`, `i < numStakes(tokenId)`\n\t *\n\t * @param tokenId token ID to query number of times staked for\n\t * @return number of times token was staked\n\t */\n\tfunction numStakes(uint32 tokenId) public view returns(uint256) {\n\t\t// just read the array length and return it\n\t\treturn tokenStakes[tokenId].length;\n\t}\n\n\t/**\n\t * @notice How many stakes a particular address has done\n\t *\n\t * @dev Used to iterate `userStakes(owner, i)`, `i < numStakes(owner)`\n\t *\n\t * @param owner an address to query number of times it staked\n\t * @return number of times a particular address has staked\n\t */\n\tfunction numStakes(address owner) public view returns(uint256) {\n\t\t// just read the array length and return it\n\t\treturn userStakes[owner].length;\n\t}\n\n\t/**\n\t * @notice Determines if the token is currently staked or not\n\t *\n\t * @param tokenId token ID to check state for\n\t * @return true if token is staked, false otherwise\n\t */\n\tfunction isStaked(uint32 tokenId) public view returns(bool) {\n\t\t// get an idea of current stakes for the token\n\t\tuint256 n = tokenStakes[tokenId].length;\n\n\t\t// evaluate based on the last stake element in the array\n\t\treturn n > 0 && tokenStakes[tokenId][n - 1].unstakedOn == 0;\n\t}\n\n\t/**\n\t * @notice Stakes the NFT; the token is transferred from its owner to the staking contract;\n\t *      token must be owned by the tx executor and be transferable by staking contract\n\t *\n\t * @param tokenId token ID to stake\n\t */\n\tfunction stake(uint32 tokenId) public {\n\t\t// verify staking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_STAKING), \"staking is disabled\");\n\n\t\t// get an idea of current stakes for the token\n\t\tuint256 n = tokenStakes[tokenId].length;\n\n\t\t// verify the token is not currently staked\n\t\trequire(n == 0 || tokenStakes[tokenId][n - 1].unstakedOn != 0, \"already staked\");\n\n\t\t// verify token belongs to the address which executes staking\n\t\trequire(ERC721(targetContract).ownerOf(tokenId) == msg.sender, \"access denied\");\n\n\t\t// transfer the token from owner into the staking contract\n\t\tERC721(targetContract).transferFrom(msg.sender, address(this), tokenId);\n\n\t\t// current timestamp to be set as `stakedOn`\n\t\tuint32 stakedOn = now32();\n\n\t\t// save token stake data\n\t\ttokenStakes[tokenId].push(StakeData({\n\t\t\towner: msg.sender,\n\t\t\tstakedOn: stakedOn,\n\t\t\tunstakedOn: 0\n\t\t}));\n\n\t\t// save token stake index\n\t\tuserStakes[msg.sender].push(StakeIndex({\n\t\t\ttokenId: tokenId,\n\t\t\tindex: uint32(n)\n\t\t}));\n\n\t\t// emit an event\n\t\temit Staked(msg.sender, tokenId, stakedOn);\n\t}\n\n\t/**\n\t * @notice Stakes several NFTs; tokens are transferred from their owner to the staking contract;\n\t *      tokens must be owned by the tx executor and be transferable by staking contract\n\t *\n\t * @param tokenIds token IDs to stake\n\t */\n\tfunction stakeBatch(uint32[] memory tokenIds) public {\n\t\t// iterate the collection passed\n\t\tfor(uint256 i = 0; i < tokenIds.length; i++) {\n\t\t\t// and stake each token one by one\n\t\t\tstake(tokenIds[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Unstakes the NFT; the token is transferred from staking contract back\n\t *      its previous owner\n\t *\n\t * @param tokenId token ID to unstake\n\t */\n\tfunction unstake(uint32 tokenId) public {\n\t\t// verify staking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_UNSTAKING), \"unstaking is disabled\");\n\n\t\t// get an idea of current stakes for the token\n\t\tuint256 n = tokenStakes[tokenId].length;\n\n\t\t// verify the token is not currently staked\n\t\trequire(n != 0, \"not staked\");\n\t\trequire(tokenStakes[tokenId][n - 1].unstakedOn == 0, \"already unstaked\");\n\n\t\t// verify token belongs to the address which executes unstaking\n\t\trequire(tokenStakes[tokenId][n - 1].owner == msg.sender, \"access denied\");\n\n\t\t// current timestamp to be set as `unstakedOn`\n\t\tuint32 unstakedOn = now32();\n\n\t\t// update token stake data\n\t\ttokenStakes[tokenId][n - 1].unstakedOn = unstakedOn;\n\n\t\t// transfer the token back to owner\n\t\tERC721(targetContract).transferFrom(address(this), msg.sender, tokenId);\n\n\t\t// emit an event\n\t\temit Unstaked(msg.sender, tokenId, unstakedOn);\n\t}\n\n\t/**\n\t * @notice Unstakes several NFTs; tokens are transferred from staking contract back\n\t *      their previous owner\n\t *\n\t * @param tokenIds token IDs to unstake\n\t */\n\tfunction unstakeBatch(uint32[] memory tokenIds) public {\n\t\t// iterate the collection passed\n\t\tfor(uint256 i = 0; i < tokenIds.length; i++) {\n\t\t\t// and unstake each token one by one\n\t\t\tunstake(tokenIds[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Restricted access function to rescue accidentally sent ERC20 tokens,\n\t *      the tokens are rescued via `transfer` function call on the\n\t *      contract address specified and with the parameters specified:\n\t *      `_contract.transfer(_to, _value)`\n\t *\n\t * @dev Requires executor to have `ROLE_RESCUE_MANAGER` permission\n\t *\n\t * @param _contract smart contract address to execute `transfer` function on\n\t * @param _to to address in `transfer(_to, _value)`\n\t * @param _value value to transfer in `transfer(_to, _value)`\n\t */\n\tfunction rescueErc20(address _contract, address _to, uint256 _value) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_RESCUE_MANAGER), \"access denied\");\n\n\t\t// perform the transfer as requested, without any checks\n\t\tERC20(_contract).transfer(_to, _value);\n\t}\n\n\t/**\n\t * @dev Restricted access function to rescue accidentally sent ERC721 tokens,\n\t *      the tokens are rescued via `transferFrom` function call on the\n\t *      contract address specified and with the parameters specified:\n\t *      `_contract.transferFrom(this, _to, _tokenId)`\n\t *\n\t * @dev Requires executor to have `ROLE_RESCUE_MANAGER` permission\n\t *\n\t * @param _contract smart contract address to execute `transferFrom` function on\n\t * @param _to to address in `transferFrom(this, _to, _tokenId)`\n\t * @param _tokenId token ID to transfer in `transferFrom(this, _to, _tokenId)`\n\t */\n\tfunction rescueErc721(address _contract, address _to, uint256 _tokenId) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_RESCUE_MANAGER), \"access denied\");\n\n\t\t// verify the NFT is not staked\n\t\trequire(_contract != targetContract || !isStaked(uint32(_tokenId)), \"token is staked\");\n\n\t\t// perform the transfer as requested, without any checks\n\t\tERC721(_contract).transferFrom(address(this), _to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Testing time-dependent functionality may be difficult;\n\t *      we override time in the helper test smart contract (mock)\n\t *\n\t * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n\t */\n\tfunction now32() public view virtual returns (uint32) {\n\t\t// return current block timestamp\n\t\treturn uint32(block.timestamp);\n\t}\n}\n"
6     },
7     "contracts/interfaces/ERC20Spec.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\n/**\n * @title EIP-20: ERC-20 Token Standard\n *\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\n *\n * @notice It provides functionalities like to transfer tokens from one account to another,\n *      to get the current token balance of an account and also the total supply of the token available on the network.\n *      Besides these it also has some other functionalities like to approve that an amount of\n *      token from an account can be spent by a third party account.\n *\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\n *\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\n * @notice See https://eips.ethereum.org/EIPS/eip-20\n */\ninterface ERC20 {\n\t/**\n\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\n\t *\n\t * @param from an address tokens were consumed from\n\t * @param to an address tokens were sent to\n\t * @param value number of tokens transferred\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in approve() to indicate an approval event happened\n\t *\n\t * @param owner an address which granted a permission to transfer\n\t *      tokens on its behalf\n\t * @param spender an address which received a permission to transfer\n\t *      tokens on behalf of the owner `_owner`\n\t * @param value amount of tokens granted to transfer on behalf\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n\t/**\n\t * @return name of the token (ex.: USD Coin)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function name() external view returns (string memory);\n\n\t/**\n\t * @return symbol of the token (ex.: USDC)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the number of decimals used to get its user representation.\n\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\n\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\t *\n\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\n\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\n\t *      overridden;\n\t *\n\t * @dev NOTE: This information is only used for _display_ purposes: it in\n\t *      no way affects any of the arithmetic of the contract, including\n\t *      {IERC20-balanceOf} and {IERC20-transfer}.\n\t *\n\t * @return token decimals\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function decimals() external view returns (uint8);\n\n\t/**\n\t * @return the amount of tokens in existence\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @notice Gets the balance of a particular address\n\t *\n\t * @param _owner the address to query the the balance for\n\t * @return balance an amount of tokens owned by the address specified\n\t */\n\tfunction balanceOf(address _owner) external view returns (uint256 balance);\n\n\t/**\n\t * @notice Transfers some tokens to an external address or a smart contract\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * self address or\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transfer(address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to`\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner (transaction sender)\n\t *\n\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approve(address _spender, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\n\t *\n\t * @dev A function to check an amount of tokens owner approved\n\t *      to transfer on its behalf by some other address called \"spender\"\n\t *\n\t * @param _owner an address which approves transferring some tokens on its behalf\n\t * @param _spender an address approved to transfer some tokens on behalf\n\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\n\t *      of token owner `_owner`\n\t */\n\tfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);\n}\n"
9     },
10     "contracts/interfaces/ERC721Spec.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"./ERC165Spec.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev Solidity issue #3412: The ERC721 interfaces include explicit mutability guarantees for each function.\n *      Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure.\n *      Implementation MUST meet the mutability guarantee in this interface and MAY meet a stronger guarantee.\n *      For example, a payable function in this interface may be implemented as nonpayable\n *      (no state mutability specified) in implementing contract.\n *      It is expected a later Solidity release will allow stricter contract to inherit from this interface,\n *      but current workaround is that we edit this interface to add stricter mutability before inheriting:\n *      we have removed all \"payable\" modifiers.\n *\n * @dev The ERC-165 identifier for this interface is 0x80ac58cd.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721 is ERC165 {\n\t/// @dev This emits when ownership of any NFT changes by any mechanism.\n\t///  This event emits when NFTs are created (`from` == 0) and destroyed\n\t///  (`to` == 0). Exception: during contract creation, any number of NFTs\n\t///  may be created and assigned without emitting Transfer. At the time of\n\t///  any transfer, the approved address for that NFT (if any) is reset to none.\n\tevent Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n\t/// @dev This emits when the approved address for an NFT is changed or\n\t///  reaffirmed. The zero address indicates there is no approved address.\n\t///  When a Transfer event emits, this also indicates that the approved\n\t///  address for that NFT (if any) is reset to none.\n\tevent Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n\t/// @dev This emits when an operator is enabled or disabled for an owner.\n\t///  The operator can manage all NFTs of the owner.\n\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n\t/// @notice Count all NFTs assigned to an owner\n\t/// @dev NFTs assigned to the zero address are considered invalid, and this\n\t///  function throws for queries about the zero address.\n\t/// @param _owner An address for whom to query the balance\n\t/// @return The number of NFTs owned by `_owner`, possibly zero\n\tfunction balanceOf(address _owner) external view returns (uint256);\n\n\t/// @notice Find the owner of an NFT\n\t/// @dev NFTs assigned to zero address are considered invalid, and queries\n\t///  about them do throw.\n\t/// @param _tokenId The identifier for an NFT\n\t/// @return The address of the owner of the NFT\n\tfunction ownerOf(uint256 _tokenId) external view returns (address);\n\n\t/// @notice Transfers the ownership of an NFT from one address to another address\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\n\t///  operator, or the approved address for this NFT. Throws if `_from` is\n\t///  not the current owner. Throws if `_to` is the zero address. Throws if\n\t///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n\t///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t///  `onERC721Received` on `_to` and throws if the return value is not\n\t///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\t/// @param _data Additional data with no specified format, sent in call to `_to`\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external /*payable*/;\n\n\t/// @notice Transfers the ownership of an NFT from one address to another address\n\t/// @dev This works identically to the other function with an extra data parameter,\n\t///  except this function just sets data to \"\".\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n\t///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n\t///  THEY MAY BE PERMANENTLY LOST\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\n\t///  operator, or the approved address for this NFT. Throws if `_from` is\n\t///  not the current owner. Throws if `_to` is the zero address. Throws if\n\t///  `_tokenId` is not a valid NFT.\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Change or reaffirm the approved address for an NFT\n\t/// @dev The zero address indicates there is no approved address.\n\t///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n\t///  operator of the current owner.\n\t/// @param _approved The new approved NFT controller\n\t/// @param _tokenId The NFT to approve\n\tfunction approve(address _approved, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Enable or disable approval for a third party (\"operator\") to manage\n\t///  all of `msg.sender`'s assets\n\t/// @dev Emits the ApprovalForAll event. The contract MUST allow\n\t///  multiple operators per owner.\n\t/// @param _operator Address to add to the set of authorized operators\n\t/// @param _approved True if the operator is approved, false to revoke approval\n\tfunction setApprovalForAll(address _operator, bool _approved) external;\n\n\t/// @notice Get the approved address for a single NFT\n\t/// @dev Throws if `_tokenId` is not a valid NFT.\n\t/// @param _tokenId The NFT to find the approved address for\n\t/// @return The approved address for this NFT, or the zero address if there is none\n\tfunction getApproved(uint256 _tokenId) external view returns (address);\n\n\t/// @notice Query if an address is an authorized operator for another address\n\t/// @param _owner The address that owns the NFTs\n\t/// @param _operator The address that acts on behalf of the owner\n\t/// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface ERC721TokenReceiver {\n\t/// @notice Handle the receipt of an NFT\n\t/// @dev The ERC721 smart contract calls this function on the recipient\n\t///  after a `transfer`. This function MAY throw to revert and reject the\n\t///  transfer. Return of other than the magic value MUST result in the\n\t///  transaction being reverted.\n\t///  Note: the contract address is always the message sender.\n\t/// @param _operator The address which called `safeTransferFrom` function\n\t/// @param _from The address which previously owned the token\n\t/// @param _tokenId The NFT identifier which is being transferred\n\t/// @param _data Additional data with no specified format\n\t/// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n\t///  unless throwing\n\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev The ERC-165 identifier for this interface is 0x5b5e139f.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721Metadata is ERC721 {\n\t/// @notice A descriptive name for a collection of NFTs in this contract\n\tfunction name() external view returns (string memory _name);\n\n\t/// @notice An abbreviated name for NFTs in this contract\n\tfunction symbol() external view returns (string memory _symbol);\n\n\t/// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n\t/// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n\t///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n\t///  Metadata JSON Schema\".\n\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev The ERC-165 identifier for this interface is 0x780e9d63.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721Enumerable is ERC721 {\n\t/// @notice Count NFTs tracked by this contract\n\t/// @return A count of valid NFTs tracked by this contract, where each one of\n\t///  them has an assigned and queryable owner not equal to the zero address\n\tfunction totalSupply() external view returns (uint256);\n\n\t/// @notice Enumerate valid NFTs\n\t/// @dev Throws if `_index` >= `totalSupply()`.\n\t/// @param _index A counter less than `totalSupply()`\n\t/// @return The token identifier for the `_index`th NFT,\n\t///  (sort order not specified)\n\tfunction tokenByIndex(uint256 _index) external view returns (uint256);\n\n\t/// @notice Enumerate NFTs assigned to an owner\n\t/// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n\t///  `_owner` is the zero address, representing invalid NFTs.\n\t/// @param _owner An address where we are interested in NFTs owned by them\n\t/// @param _index A counter less than `balanceOf(_owner)`\n\t/// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n\t///   (sort order not specified)\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
12     },
13     "contracts/utils/AccessControl.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\n/**\n * @title Access Control List\n *\n * @notice Access control smart contract provides an API to check\n *      if specific operation is permitted globally and/or\n *      if particular user has a permission to execute it.\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable specific\n *      functions (public functions) of the smart contract for everyone.\n * @notice User roles are designed to restrict access to specific\n *      functions (restricted functions) of the smart contract to some users.\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n */\ncontract AccessControl {\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n\t/**\n\t * @notice Privileged addresses with defined roles/permissions\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t */\n\tmapping(address => uint256) public userRoles;\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param _by operator which called the function\n\t * @param _to address which was granted/revoked permissions\n\t * @param _requested permissions requested\n\t * @param _actual permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\n\n\t/**\n\t * @notice Creates an access control instance,\n\t *      setting contract creator to have full privileges\n\t */\n\tconstructor() {\n\t\t// contract creator has full privileges\n\t\tuserRoles[msg.sender] = FULL_PRIVILEGES_MASK;\n\t}\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns(uint256) {\n\t\t// features are stored in 'this' address  mapping of `userRoles` structure\n\t\treturn userRoles[address(this)];\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for or zero\n\t *      to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\n\n\t\t// evaluate the role and reassign it\n\t\tuserRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\n\n\t\t// fire an event\n\t\temit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns(uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = userRoles[operator];\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction isFeatureEnabled(uint256 required) public view returns(bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isSenderInRole(uint256 required) public view returns(bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isOperatorInRole(address operator, uint256 required) public view returns(bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(userRoles[operator], required);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) internal pure returns(bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n}\n"
15     },
16     "contracts/interfaces/ERC165Spec.sol": {
17       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\n/**\n * @title ERC-165 Standard Interface Detection\n *\n * @dev Interface of the ERC165 standard, as defined in the\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * @dev Implementers can declare support of contract interfaces,\n *      which can then be queried by others.\n *\n * @author Christian Reitwie√üner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\n */\ninterface ERC165 {\n\t/**\n\t * @notice Query if a contract implements an interface\n\t *\n\t * @dev Interface identification is specified in ERC-165.\n\t *      This function uses less than 30,000 gas.\n\t *\n\t * @param interfaceID The interface identifier, as specified in ERC-165\n\t * @return `true` if the contract implements `interfaceID` and\n\t *      `interfaceID` is not 0xffffffff, `false` otherwise\n\t */\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
18     }
19   },
20   "settings": {
21     "optimizer": {
22       "enabled": true,
23       "runs": 200
24     },
25     "outputSelection": {
26       "*": {
27         "*": [
28           "evm.bytecode",
29           "evm.deployedBytecode",
30           "devdoc",
31           "userdoc",
32           "metadata",
33           "abi"
34         ]
35       }
36     },
37     "libraries": {}
38   }
39 }}