1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/interfaces/IERC1155TokenReceiver.sol": {
5       "content": "pragma solidity >=0.5.0;\r\n\r\n\r\ninterface IERC1155TokenReceiver {\r\n\r\n  /**\r\n   * @notice Handle the receipt of a single ERC1155 token type\r\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\r\n   * This function MAY throw to revert and reject the transfer\r\n   * Return of other amount than the magic value MUST result in the transaction being reverted\r\n   * Note: The token contract address is always the message sender\r\n   * @param _operator  The address which called the `safeTransferFrom` function\r\n   * @param _from      The address which previously owned the token\r\n   * @param _id        The id of the token being transferred\r\n   * @param _amount    The amount of tokens being transferred\r\n   * @param _data      Additional data with no specified format\r\n   * @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n   */\r\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\r\n\r\n  /**\r\n   * @notice Handle the receipt of multiple ERC1155 token types\r\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\r\n   * This function MAY throw to revert and reject the transfer\r\n   * Return of other amount than the magic value WILL result in the transaction being reverted\r\n   * Note: The token contract address is always the message sender\r\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\r\n   * @param _from      The address which previously owned the token\r\n   * @param _ids       An array containing ids of each token being transferred\r\n   * @param _amounts   An array containing amounts of each token being transferred\r\n   * @param _data      Additional data with no specified format\r\n   * @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n   */\r\n  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\r\n}"
6     },
7     "contracts/MonetCardToken.sol": {
8       "content": "pragma solidity =0.5.16;\r\n\r\nimport \"./libraries/Address.sol\";\r\nimport \"./libraries/SafeMath.sol\";\r\nimport \"./interfaces/IERC1155TokenReceiver.sol\";\r\nimport \"./Minter.sol\";\r\n\r\ncontract MonetCardToken is Minter {\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n\r\n    bytes4 private constant ERC1155_RECEIVED_VALUE = 0xf23a6e61;\r\n    bytes4 private constant ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\r\n    bytes4 private constant ERC1155_INTERFACE_ID = 0xd9b67a26;\r\n\r\n    mapping(address => mapping(uint256 => uint256)) internal _balances;\r\n    mapping(address => mapping(address => bool)) internal _operators;\r\n    mapping(uint256 => uint256) internal _totalSupplies;\r\n\r\n    // VIEW\r\n\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n        return _operators[_owner][_operator];\r\n    }\r\n\r\n    function totalSupply(uint256 _id) public view returns (uint256) {\r\n        return _totalSupplies[_id];\r\n    }\r\n\r\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256) {\r\n        return _balances[_owner][_id];\r\n    }\r\n\r\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory) {\r\n        require(_owners.length == _ids.length, \"INVALID_ARRAY_LENGTH\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](_owners.length);\r\n        for (uint256 i = 0; i < _owners.length; i++) {\r\n            batchBalances[i] = _balances[_owners[i]][_ids[i]];\r\n        }\r\n        return batchBalances;\r\n    }\r\n\r\n    function cardsNumOf(address _owner, uint256 _level,uint256 _carry) public view returns (uint256 nums) {\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            uint256 num = _balances[_owner][_level.mul(10).add(i)];\r\n            nums = nums.add((_carry**(3 - i)).mul(num));\r\n        }\r\n        return nums;\r\n    }\r\n\r\n    function cardsNumOfAll(address _owner, uint256 _carry) public view returns (uint256[10] memory nums) {\r\n        uint256 levelMax = 10;\r\n        for (uint256 i = 0; i < levelMax; i++) {\r\n            nums[i] = cardsNumOf(_owner, levelMax.sub(i), _carry);\r\n        }\r\n    }\r\n\r\n    function cardsTotalSupply() public view returns (uint256[40] memory nums) {\r\n        uint256 idx;\r\n        for (uint256 i = 10; i > 0; i--) {\r\n            for (uint256 j = 0; j < 4; j++) {\r\n                nums[idx++] = _totalSupplies[i.mul(10).add(j)];\r\n            }\r\n        }\r\n    }\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external pure returns (bool) {\r\n        return _interfaceID == ERC1155_INTERFACE_ID;\r\n    }\r\n\r\n    // PRIVATE\r\n    function _mintBatch(address _to, uint256[] memory _ids, uint256[] memory _values) private {\r\n        require(_to != address(0), \"INVALID_RECIPIENT\");\r\n\r\n        uint256 size = _ids.length;\r\n        for (uint256 i = 0; i < size; i++) {\r\n            _totalSupplies[_ids[i]] = _totalSupplies[_ids[i]].add(_values[i]);\r\n            _balances[_to][_ids[i]] = _balances[_to][_ids[i]].add(_values[i]);\r\n        }\r\n        emit TransferBatch(msg.sender, address(0), _to, _ids, _values);\r\n    }\r\n\r\n    function _safeBatchBurnFrom(address _from, uint256[] memory _ids, uint256[] memory _values ) private {\r\n        require(_ids.length == _values.length, \"INVALID_ARRAYS_LENGTH\");\r\n\r\n        uint256 size = _ids.length;\r\n        for (uint256 i = 0; i < size; i++) {\r\n            _balances[_from][_ids[i]] = _balances[_from][_ids[i]].sub(\r\n                _values[i]\r\n            );\r\n            _totalSupplies[_ids[i]] = _totalSupplies[_ids[i]].sub(_values[i]);\r\n        }\r\n\r\n        emit TransferBatch(msg.sender, _from, address(0), _ids, _values);\r\n    }\r\n\r\n    function _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount) private {\r\n        _balances[_from][_id] = _balances[_from][_id].sub(_amount); // Subtract amount\r\n        _balances[_to][_id] = _balances[_to][_id].add(_amount); // Add amount\r\n\r\n        emit TransferSingle(msg.sender, _from, _to, _id, _amount);\r\n    }\r\n\r\n    function _safeBatchTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256[] memory _ids,\r\n        uint256[] memory _amounts\r\n    ) private {\r\n        require(_ids.length == _amounts.length, \"INVALID_ARRAYS_LENGTH\");\r\n\r\n        uint256 size = _ids.length;\r\n        for (uint256 i = 0; i < size; i++) {\r\n            _balances[_from][_ids[i]] = _balances[_from][_ids[i]].sub(\r\n                _amounts[i]\r\n            );\r\n            _balances[_to][_ids[i]] = _balances[_to][_ids[i]].add(_amounts[i]);\r\n        }\r\n\r\n        emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\r\n    }\r\n\r\n    function _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data) private {\r\n        if (_to.isContract()) {\r\n            bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received(msg.sender, _from, _id, _amount, _data);\r\n            require(retval == ERC1155_RECEIVED_VALUE, \"INVALID_ON_RECEIVE_MESSAGE\");\r\n        }\r\n    }\r\n\r\n    function _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data) private {\r\n        if (_to.isContract()) {\r\n            bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived(msg.sender, _from, _ids, _amounts, _data );\r\n            require(retval == ERC1155_BATCH_RECEIVED_VALUE, \"INVALID_ON_RECEIVE_MESSAGE\");\r\n        }\r\n    }\r\n\r\n    // EXTERNAL\r\n    function safeBatchMint(address _to, uint256[] calldata _ids, uint256[] calldata _values) external onlyMinter {\r\n        require(_ids.length == _values.length, \"INVALID_ARRAYS_LENGTH\");\r\n        _mintBatch(_to, _ids, _values);\r\n    }\r\n\r\n    function safeBatchBurnFrom(address _from, uint256[] calldata _ids, uint256[] calldata _amounts) external {\r\n        require((msg.sender == _from) || isApprovedForAll(_from, msg.sender));\r\n\r\n        _safeBatchBurnFrom(_from, _ids, _amounts);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external {\r\n        require((msg.sender == _from) || isApprovedForAll(_from, msg.sender));\r\n        require(_to != address(0), \"INVALID_RECIPIENT\");\r\n\r\n        _safeTransferFrom(_from, _to, _id, _amount);\r\n        _callonERC1155Received(_from, _to, _id, _amount, _data);\r\n    }\r\n\r\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external {\r\n        require((msg.sender == _from) || isApprovedForAll(_from, msg.sender));\r\n        require(_to != address(0), \"INVALID_RECIPIENT\");\r\n\r\n        _safeBatchTransferFrom(_from, _to, _ids, _amounts);\r\n        _callonERC1155BatchReceived(_from, _to, _ids, _amounts, _data);\r\n    }\r\n\r\n    function cardsBatchMint(address _to, uint256[] calldata _cards) external onlyMinter {\r\n        uint256[] memory _ids = new uint256[](_cards.length);\r\n        uint256[] memory _values = new uint256[](_cards.length);\r\n        for (uint256 i = 0; i < _cards.length; i++) {\r\n            _ids[i] = _cards[i] % 1000;\r\n            _values[i] = _cards[i] / 1000;\r\n        }\r\n        _mintBatch(_to, _ids, _values);\r\n    }\r\n\r\n    function cardsBatchBurnFrom(address _from, uint256[] calldata _cards) external {\r\n        require((msg.sender == _from) || isApprovedForAll(_from, msg.sender));\r\n\r\n        uint256[] memory _ids = new uint256[](_cards.length);\r\n        uint256[] memory _values = new uint256[](_cards.length);\r\n        for (uint256 i = 0; i < _cards.length; i++) {\r\n            _ids[i] = _cards[i] % 1000;\r\n            _values[i] = _cards[i] / 1000;\r\n        }\r\n\r\n        _safeBatchBurnFrom(_from, _ids, _values);\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        _operators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    // EVENT\r\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\r\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    event URI(string _amount, uint256 indexed _id);\r\n}\r\n"
9     },
10     "contracts/libraries/Address.sol": {
11       "content": "pragma solidity =0.5.16;\r\n\r\nlibrary Address {\r\n\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n}"
12     },
13     "contracts/libraries/SafeMath.sol": {
14       "content": "pragma solidity =0.5.16;\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n    \r\n    function div(uint a, uint b) internal pure returns (uint z) {\r\n        require(b > 0);\r\n        return a / b;\r\n    }\r\n}\r\n"
15     },
16     "contracts/Minter.sol": {
17       "content": "pragma solidity =0.5.16;\n\nimport './Ownable.sol';\n\ncontract Minter is Ownable {\n    \n    mapping(address => bool) private _minters;\n    \n    event MinterChanged(address indexed minter, bool approved);\n\n\n    modifier onlyMinter {\n        require(isMinter(), \"Minter: caller is not the minter\");\n        _;\n    }\n\n    function isMinter() public view returns (bool){\n        return _minters[msg.sender];\n    }\n    \n    function setMinter(address _minter,bool _approved) external onlyOwner {\n        _minters[_minter] = _approved;\n        emit MinterChanged(_minter,_approved);\n    }\n\n}"
18     },
19     "contracts/Ownable.sol": {
20       "content": "pragma solidity =0.5.16;\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n"
21     }
22   },
23   "settings": {
24     "optimizer": {
25       "enabled": true,
26       "runs": 200
27     },
28     "outputSelection": {
29       "*": {
30         "*": [
31           "evm.bytecode",
32           "evm.deployedBytecode",
33           "abi"
34         ]
35       }
36     },
37     "libraries": {}
38   }
39 }}