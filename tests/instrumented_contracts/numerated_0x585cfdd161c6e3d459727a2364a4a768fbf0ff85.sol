1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "london",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "details": {
12         "constantOptimizer": true,
13         "cse": true,
14         "deduplicate": true,
15         "inliner": true,
16         "jumpdestRemover": true,
17         "orderLiterals": true,
18         "peephole": true,
19         "yul": true,
20         "yulDetails": {
21           "optimizerSteps": "dhfoDgvulfnTUtnIf",
22           "stackAllocation": true
23         }
24       },
25       "runs": 2000
26     },
27     "remappings": [],
28     "outputSelection": {
29       "*": {
30         "*": [
31           "evm.bytecode",
32           "evm.deployedBytecode",
33           "devdoc",
34           "userdoc",
35           "metadata",
36           "abi"
37         ]
38       }
39     }
40   },
41   "sources": {
42     "@openzeppelin/contracts/security/Pausable.sol": {
43       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
44     },
45     "@openzeppelin/contracts/utils/Context.sol": {
46       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
47     },
48     "contracts/ERC721.sol": {
49       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 indexed tokenId\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) internal balanceOf;\n\n    mapping(uint256 => address) public ownerOf;\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = ownerOf[id];\n\n        require(\n            msg.sender == owner || isApprovedForAll[owner][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from ||\n                msg.sender == getApproved[id] ||\n                isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    id,\n                    \"\"\n                ) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    id,\n                    data\n                ) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        virtual\n        returns (bool)\n    {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = ownerOf[id];\n\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            balanceOf[owner]--;\n        }\n\n        delete ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
50     },
51     "contracts/Pirates.sol": {
52       "content": "// SPDX-License-Identifier: MIT LICENSE\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./ERC721.sol\";\nimport \"./interfaces/IPirates.sol\";\nimport \"./interfaces/ITPirates.sol\";\nimport \"./interfaces/IHPirates.sol\";\nimport \"./interfaces/IOrbitalBlockade.sol\";\nimport \"./interfaces/IRandomizer.sol\";\nimport \"./interfaces/IEON.sol\";\n\ncontract Pirates is IPirates, ERC721, Pausable {\n    struct LastWrite {\n        uint64 time;\n        uint64 blockNum;\n    }\n\n    event PirateNamed(uint256 indexed tokenId, string newName);\n    event PirateMinted(uint256 indexed tokenId);\n    event PirateStolen(uint256 indexed tokenId);\n\n    // tally of the number of pirates that have been minted\n    uint16 public override piratesMinted;\n\n    // an arbatrary counter to dish out IDs\n    uint16 public override minted;\n    //\n    uint256 public migrated;\n\n    // toggle naming\n    bool public namingActive;\n\n    // number of max pirates that can exist with the total minted to keep a 10:1 ratio\n\n    uint256 public constant MAX_PIRATES = 6000;\n\n    // cost to name\n    uint256 public constant costToName = 2000 ether; //2000 EON\n\n    // mapping from tokenId to a struct containing the colonist token's traits\n    mapping(uint256 => Pirate) public tokenTraitsPirate;\n\n    // mapping from tokenId to a stuct containing the honors pirates\n    mapping(uint256 => HPirates) public tokenTraitsHonors;\n    mapping(uint256 => bool) public isHonors;\n\n    // mapping from hashed(tokenTrait) to the tokenId it's associated with\n    // used to ensure there are no duplicates\n    mapping(uint256 => uint256) public existingCombinations;\n\n    // Mapping from token ID to name\n    mapping(uint256 => string) private _tokenName;\n\n    mapping(uint256 => bool) private _hasName;\n\n    // Mapping if certain name string has already been reserved\n    mapping(string => bool) private _nameReserved;\n\n    // Tracks the last block and timestamp that a caller has written to state.\n    // Disallow some access to functions if they occur while a change is being written.\n    mapping(address => LastWrite) private lastWriteAddress;\n    mapping(uint256 => LastWrite) private lastWriteToken;\n\n    // list of probabilities for each trait type\n    uint8[][9] public rarities;\n    uint8[][9] public aliases;\n\n    // reference to the orbital for transfers without approval\n    IOrbitalBlockade public orbital;\n\n    // reference to Traits\n    ITPirates public traits;\n\n    // reference to honors traits\n    IHPirates public honorTraits;\n\n    //reference to Randomizer\n    IRandomizer public randomizer;\n\n    //referenve to EON\n    IEON public EON;\n\n    //reference to the original pirates contract\n    IPirates public originalPirates;\n\n    address public auth;\n\n    // address => used in allowing system communication between contracts\n    mapping(address => bool) private admins;\n\n    // Imperial Guild Treasury\n    address private imperialGuildTreasury;\n\n    /**\n     * instantiates contract and rarity tables\n     */\n    constructor() ERC721(\"ShatteredEon\", \"Pirates Migrated\") {\n        minted = 151;\n        piratesMinted = 151;\n        _pause();\n        \n        auth = msg.sender;\n        admins[msg.sender] = true;\n\n        //PIRATES\n        //sky\n        rarities[0] = [200, 200, 200, 200, 200, 255];\n        aliases[0] = [1, 2, 0, 4, 3, 5];\n        //cockpit\n        rarities[1] = [255];\n        aliases[1] = [0];\n        //base\n        rarities[2] = [\n            255,\n            255,\n            255,\n            255,\n            200,\n            200,\n            200,\n            200,\n            40,\n            40,\n            40,\n            40,\n            150,\n            150,\n            150,\n            150,\n            255,\n            255,\n            255,\n            255\n        ];\n        aliases[2] = [\n            16,\n            17,\n            18,\n            19,\n            7,\n            6,\n            5,\n            4,\n            3,\n            2,\n            1,\n            0,\n            16,\n            17,\n            18,\n            19,\n            0,\n            1,\n            2,\n            3\n        ];\n        //engine\n        rarities[3] = [\n            150,\n            150,\n            150,\n            150,\n            255,\n            255,\n            255,\n            255,\n            100,\n            100,\n            100,\n            100,\n            255,\n            255,\n            255,\n            255,\n            40,\n            40,\n            40,\n            40\n        ];\n        aliases[3] = [\n            8,\n            9,\n            10,\n            11,\n            12,\n            13,\n            14,\n            15,\n            15,\n            14,\n            13,\n            12,\n            7,\n            6,\n            5,\n            4,\n            8,\n            9,\n            10,\n            11\n        ];\n        //nose\n        rarities[4] = [\n            255,\n            255,\n            255,\n            255,\n            150,\n            150,\n            150,\n            150,\n            255,\n            255,\n            255,\n            255,\n            120,\n            120,\n            120,\n            120,\n            40,\n            40,\n            40,\n            40\n        ];\n        aliases[4] = [\n            0,\n            1,\n            2,\n            3,\n            15,\n            14,\n            13,\n            12,\n            11,\n            10,\n            9,\n            8,\n            3,\n            2,\n            1,\n            0,\n            12,\n            13,\n            14,\n            15\n        ];\n        //wing\n        rarities[5] = [\n            120,\n            120,\n            120,\n            120,\n            40,\n            40,\n            40,\n            40,\n            150,\n            150,\n            150,\n            150,\n            255,\n            255,\n            255,\n            255,\n            255,\n            255,\n            255,\n            255\n        ];\n        aliases[5] = [\n            19,\n            18,\n            17,\n            16,\n            3,\n            2,\n            1,\n            0,\n            0,\n            1,\n            2,\n            3,\n            19,\n            18,\n            17,\n            16,\n            15,\n            14,\n            13,\n            12\n        ];\n        //weapon1\n        rarities[6] = [255, 150, 220, 220, 120, 30];\n        aliases[6] = [0, 0, 0, 0, 0, 0];\n        //weapon2\n        rarities[7] = [255, 150, 30, 100, 20, 200];\n        aliases[7] = [0, 0, 0, 0, 0, 0];\n        //rank\n        rarities[8] = [12, 160, 73, 255];\n        aliases[8] = [2, 3, 3, 3];\n    }\n\n    modifier requireContractsSet() {\n        require(\n            address(traits) != address(0) &&\n                address(orbital) != address(0) &&\n                address(randomizer) != address(0)\n        );\n        _;\n    }\n\n      modifier blockIfChangingAddress() {\n        require(admins[msg.sender] || lastWriteAddress[tx.origin].blockNum < block.number, \"Your trying the cheat\");\n        _;\n    }\n\n     modifier blockIfChangingToken(uint256 tokenId) {\n        require(admins[msg.sender] || lastWriteToken[tokenId].blockNum < block.number, \"Your trying the cheat\");\n        _;\n    }\n\n\n    modifier onlyOwner() {\n        require(msg.sender == auth);\n        _;\n    }\n\n    function setContracts(\n        address _traits,\n        address _honorTraits,\n        address _orbital,\n        address _rand,\n        address _eon,\n        address _originalPirates\n    ) external onlyOwner {\n        traits = ITPirates(_traits);\n        honorTraits = IHPirates(_honorTraits);\n        orbital = IOrbitalBlockade(_orbital);\n        randomizer = IRandomizer(_rand);\n        EON = IEON(_eon);\n        originalPirates = IPirates(_originalPirates);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    EXTERNAL\n    //////////////////////////////////////////////////////////////*/\n\n    function _mintPirate(address recipient, uint256 seed)\n        external\n        override\n        whenNotPaused\n    {\n        require(admins[msg.sender], \"Only Admins\");\n        require(piratesMinted + 1 <= MAX_PIRATES, \"Pirate forces are full\");\n        minted++;\n        piratesMinted++;\n        generatePirate(minted, seed);\n        if (tx.origin != recipient && recipient != address(orbital)) {\n            // Stolen!\n            emit PirateStolen(minted);\n        }\n        _mint(recipient, minted);\n    }\n\n    function _mintHonors(address recipient, uint8 id)\n        external\n        whenNotPaused\n        onlyOwner\n    {\n        require(minted + 1 <= MAX_PIRATES, \"All Pirates Minted\");\n        minted++;\n        piratesMinted++;\n        generateHonors(minted, id);\n        _mint(recipient, minted);\n    }\n\n    /**\n     * Burn a token - any game logic should be handled before this function.\n     */\n    function burn(uint256 tokenId) external override whenNotPaused {\n        require(admins[msg.sender]);\n        require(ownerOf[tokenId] == tx.origin, \"not owner\");\n        _burn(tokenId);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override(ERC721, IPirates) {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n        // allow admin contracts to send without approval\n        if (!admins[msg.sender]) {\n            require(\n                msg.sender == from ||\n                    msg.sender == getApproved[id] ||\n                    isApprovedForAll[from][msg.sender],\n                \"NOT_AUTHORIZED\"\n            );\n        }\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function generatePirate(uint256 tokenId, uint256 seed)\n        internal\n        returns (Pirate memory p)\n    {\n        p = selectPiTraits(seed);\n        if (existingCombinations[structToHashPi(p)] == 0) {\n            tokenTraitsPirate[tokenId] = p;\n            existingCombinations[structToHashPi(p)] = tokenId;\n            emit PirateMinted(tokenId);\n            return p;\n        }\n        return generatePirate(tokenId, randomizer.random(seed));\n    }\n\n    function generateHonors(uint256 tokenId, uint8 id)\n        internal\n        returns (HPirates memory r)\n    {\n        r.Legendary = id;\n        tokenTraitsHonors[minted] = r;\n        isHonors[minted] = true;\n        emit PirateMinted(tokenId);\n        return r;\n    }\n\n    /**\n     * uses A.J. Walker's Alias algorithm for O(1) rarity table lookup\n     * ensuring O(1) instead of O(n) reduces mint cost by more than 50%\n     * probability & alias tables are generated off-chain beforehand\n     * @param seed portion of the 256 bit seed to remove trait correlation\n     * @param traitType the trait type to select a trait for\n     * @return the ID of the randomly selected trait\n     */\n    function selectTrait(uint16 seed, uint8 traitType)\n        internal\n        view\n        returns (uint8)\n    {\n        uint8 trait = uint8(seed) % uint8(rarities[traitType].length);\n        // If a selected random trait probability is selected (biased coin) return that trait\n        if (seed >> 8 < rarities[traitType][trait]) return trait;\n        return aliases[traitType][trait];\n    }\n\n    function selectPiTraits(uint256 seed)\n        internal\n        view\n        returns (Pirate memory p)\n    {\n        p.isPirate = true;\n        seed >>= 16;\n        p.sky = selectTrait(uint16(seed & 0xFFFF), 0);\n        seed >>= 16;\n        p.cockpit = selectTrait(uint16(seed & 0xFFFF), 1);\n        seed >>= 16;\n        p.base = selectTrait(uint16(seed & 0xFFFF), 2);\n        seed >>= 16;\n        p.engine = selectTrait(uint16(seed & 0xFFFF), 3);\n        seed >>= 16;\n        p.nose = selectTrait(uint16(seed & 0xFFFF), 4);\n        seed >>= 16;\n        p.wing = selectTrait(uint16(seed & 0xFFFF), 5);\n        seed >>= 16;\n        p.weapon1 = selectTrait(uint16(seed & 0xFFFF), 6);\n        seed >>= 16;\n        p.weapon2 = selectTrait(uint16(seed & 0xFFFF), 7);\n        seed >>= 16;\n        p.rank = selectTrait(uint16(seed & 0xFFFF), 8);\n    }\n\n    function structToHashPi(Pirate memory q) internal pure returns (uint256) {\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        q.sky,\n                        q.cockpit,\n                        q.base,\n                        q.engine,\n                        q.nose,\n                        q.wing,\n                        q.weapon1,\n                        q.weapon2,\n                        q.rank\n                    )\n                )\n            );\n    }\n\n        \n    function updateOriginAccess(uint16[] memory tokenIds) external override {\n        require(admins[_msgSender()], \"Only admins can call this\");\n        uint64 blockNum = uint64(block.number);\n        uint64 time = uint64(block.timestamp);\n        lastWriteAddress[tx.origin] = LastWrite(time, blockNum);\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            lastWriteToken[tokenIds[i]] = LastWrite(time, blockNum);\n        }\n    }\n\n    function tokenNameByIndex(uint256 index)\n        public\n        view\n        returns (string memory)\n    {\n        return _tokenName[index];\n    }\n\n    function isNameReserved(string memory nameString)\n        public\n        view\n        returns (bool)\n    {\n        return _nameReserved[toLower(nameString)];\n    }\n\n    function hasBeenNamed(uint256 tokenId) public view returns (bool) {\n        return _hasName[tokenId];\n    }\n\n    function namePirate(uint256 tokenId, string memory newName) public {\n        require(namingActive == true, \"naming not yet availanle\");\n        require(ownerOf[tokenId] == msg.sender, \"Not your pirate to name\");\n        require(hasBeenNamed(tokenId) == false, \"Pirate already named\");\n        require(validateName(newName) == true, \"Not a valid name\");\n        require(isNameReserved(newName) == false, \"Name already reserved\");\n\n        //   IERC20(_eonAddress).transferFrom(msg.sender, address(this), NAME_CHANGE_PRICE);\n\n        toggleReserveName(newName, true);\n        toggleHasName(tokenId, true);\n        _tokenName[tokenId] = newName;\n        EON.burn(msg.sender, costToName);\n        emit PirateNamed(tokenId, newName);\n    }\n\n    /**\n     * @dev Reserves the name if isReserve is set to true, de-reserves if set to false\n     */\n    function toggleReserveName(string memory str, bool isReserve) internal {\n        _nameReserved[toLower(str)] = isReserve;\n    }\n\n    function toggleHasName(uint256 tokenId, bool hasName) internal {\n        _hasName[tokenId] = hasName;\n    }\n\n    /**\n     * @dev Check if the name string is valid (Alphanumeric and spaces without leading or trailing space)\n     */\n    function validateName(string memory str) public pure returns (bool) {\n        bytes memory b = bytes(str);\n        if (b.length < 1) return false;\n        if (b.length > 25) return false; // Cannot be longer than 25 characters\n        if (b[0] == 0x20) return false; // Leading space\n        if (b[b.length - 1] == 0x20) return false; // Trailing space\n\n        bytes1 lastChar = b[0];\n\n        for (uint256 i; i < b.length; i++) {\n            bytes1 char = b[i];\n\n            if (char == 0x20 && lastChar == 0x20) return false; // Cannot contain continous spaces\n\n            if (\n                !(char >= 0x30 && char <= 0x39) && //9-0\n                !(char >= 0x41 && char <= 0x5A) && //A-Z\n                !(char >= 0x61 && char <= 0x7A) && //a-z\n                !(char == 0x20) //space\n            ) return false;\n\n            lastChar = char;\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Converts the string to lowercase\n     */\n    function toLower(string memory str) public pure returns (string memory) {\n        bytes memory bStr = bytes(str);\n        bytes memory bLower = new bytes(bStr.length);\n        for (uint256 i = 0; i < bStr.length; i++) {\n            // Uppercase character\n            if ((uint8(bStr[i]) >= 65) && (uint8(bStr[i]) <= 90)) {\n                bLower[i] = bytes1(uint8(bStr[i]) + 32);\n            } else {\n                bLower[i] = bStr[i];\n            }\n        }\n        return string(bLower);\n    }\n\n      /**\n   * creates identical tokens in the new contract\n   * and burns any original tokens\n   * @param tokenIds the ids of the tokens to migrate\n   */\n  function migrate(uint16[] calldata tokenIds) external whenNotPaused {\n    for (uint16 i = 0; i < tokenIds.length; i++) {\n      require(originalPirates.isOwner(tokenIds[i]) == msg.sender, \"THIEF!\");\n       tokenTraitsPirate[tokenIds[i]] = originalPirates.getTokenTraitsPirate(tokenIds[i]);\n      originalPirates.burn(tokenIds[i]);\n      _mint(address(orbital), tokenIds[i]);\n      migrated++;\n    }\n    orbital.addPiratesToCrew(msg.sender, tokenIds); \n\n  }\n\n    /**\n     * enables owner to pause / unpause minting\n     */\n    function setPaused(bool _paused) external requireContractsSet onlyOwner {\n        if (_paused) _pause();\n        else _unpause();\n    }\n\n    function getBalance(address tokenOwner)\n        public\n        view\n        returns (uint256)\n        \n    {\n        //Prevent chencking balance in the same block it's being modified..\n        require(\n            admins[msg.sender] ||\n                lastWriteAddress[tokenOwner].blockNum < block.number,\n            \"no checking balance in the same block it's being modified\"\n        );\n        return balanceOf[tokenOwner];\n    }\n\n      function getTokenWriteBlock(uint256 tokenId) external view override returns(uint64) {\n        require(\n            admins[msg.sender], \n            \"Only admins can call this\"\n            );\n        return lastWriteToken[tokenId].blockNum;\n    }\n\n    /**\n     * enables an address to mint / burn\n     * @param addr the address to enable\n     */\n    function addAdmin(address addr) external onlyOwner {\n        admins[addr] = true;\n    }\n\n    /**\n     * disables an address from minting / burning\n     * @param addr the address to disbale\n     */\n    function removeAdmin(address addr) external onlyOwner {\n        admins[addr] = false;\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        auth = newOwner;\n    }\n\n    function toggleNameing(bool _namingActive) external onlyOwner {\n        namingActive = _namingActive;\n    }\n\n    function setImperialGuildTreasury(address _imperialTreasury)\n        external\n        onlyOwner\n    {\n        imperialGuildTreasury = _imperialTreasury;\n    }\n\n    /** Traits */\n\n    function getTokenTraitsPirate(uint256 tokenId)\n        external\n        view\n        override\n        blockIfChangingAddress blockIfChangingToken (tokenId) \n        returns (Pirate memory)\n    {\n        return tokenTraitsPirate[tokenId];\n    }\n\n    function getTokenTraitsHonors(uint256 tokenId) \n        external\n        view\n        override\n        returns (HPirates memory)\n    {\n        return tokenTraitsHonors[tokenId];\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override\n        blockIfChangingAddress blockIfChangingToken (tokenId) \n        returns (string memory)\n    {\n        if (isHonors[tokenId]) {\n            return honorTraits.tokenURI(tokenId);\n        }\n        return traits.tokenURI(tokenId);\n    }\n\n    function isOwner(uint256 tokenId) blockIfChangingToken(tokenId) public view returns (address) {\n        address addr = ownerOf[tokenId];\n        return addr;\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override(ERC721, IPirates) blockIfChangingToken(id) {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    id,\n                    \"\"\n                ) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public override(ERC721, IPirates) blockIfChangingToken(id) {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    id,\n                    data\n                ) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    // For OpenSeas\n    function owner() public view virtual returns (address) {\n        return auth;\n    }\n    }\n\n"
53     },
54     "contracts/interfaces/IEON.sol": {
55       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IEON {\r\n    function mint(address to, uint256 amount) external;\r\n\r\n    function burn(address from, uint256 amount) external;\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n"
56     },
57     "contracts/interfaces/IHPirates.sol": {
58       "content": "// SPDX-License-Identifier: MIT LICENSE\npragma solidity ^0.8.0;\n\ninterface IHPirates {\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
59     },
60     "contracts/interfaces/IOrbitalBlockade.sol": {
61       "content": "// SPDX-License-Identifier: MIT LICENSE\n\npragma solidity ^0.8.0;\n\ninterface IOrbitalBlockade {\n    function addPiratesToCrew(address account, uint16[] calldata tokenIds)\n        external;\n    \n    function claimPiratesFromCrew(address account, uint16[] calldata tokenIds, bool unstake)\n        external;\n\n    function payPirateTax(uint256 amount) external;\n\n    function randomPirateOwner(uint256 seed) external view returns (address);\n}\n"
62     },
63     "contracts/interfaces/IPirates.sol": {
64       "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPirates {\r\n    // struct to store each Colonist's traits\r\n    struct Pirate {\r\n        bool isPirate;\r\n        uint8 sky;\r\n        uint8 cockpit;\r\n        uint8 base;\r\n        uint8 engine;\r\n        uint8 nose;\r\n        uint8 wing;\r\n        uint8 weapon1;\r\n        uint8 weapon2;\r\n        uint8 rank;\r\n    }\r\n\r\n    struct HPirates {\r\n        uint8 Legendary;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) external;\r\n\r\n    function minted() external returns (uint16);\r\n\r\n    function piratesMinted() external returns (uint16);\r\n\r\n    function isOwner(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function _mintPirate(address recipient, uint256 seed) external;\r\n\r\n    function burn(uint256 tokenId) external;\r\n\r\n    function getTokenTraitsPirate(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (Pirate memory);\r\n\r\n    function getTokenTraitsHonors(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (HPirates memory);\r\n\r\n    function tokenNameByIndex(uint256 index)\r\n        external\r\n        view\r\n        returns (string memory);\r\n    \r\n    function isHonors(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function updateOriginAccess(uint16[] memory tokenIds) external;\r\n\r\n    function getTokenWriteBlock(uint256 tokenId) \r\n    external \r\n    view  \r\n    returns(uint64);\r\n\r\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\r\n\r\n    function namePirate(uint256 tokenId, string memory newName) external;\r\n}\r\n"
65     },
66     "contracts/interfaces/IRandomizer.sol": {
67       "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRandomizer {\r\n    function random(uint256) external returns (uint256);\r\n}\r\n"
68     },
69     "contracts/interfaces/ITPirates.sol": {
70       "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface ITPirates {\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n"
71     }
72   }
73 }}