1 {{
2   "language": "Solidity",
3   "sources": {
4     "/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/OtokenFactory.sol": {
5       "content": "pragma solidity =0.6.10;\n\nimport {OtokenSpawner} from \"./OtokenSpawner.sol\";\nimport {SafeMath} from \"./packages/oz/SafeMath.sol\";\nimport {AddressBookInterface} from \"./interfaces/AddressBookInterface.sol\";\nimport {OtokenInterface} from \"./interfaces/OtokenInterface.sol\";\nimport {WhitelistInterface} from \"./interfaces/WhitelistInterface.sol\";\n\n/**\n * SPDX-License-Identifier: UNLICENSED\n * @title A factory to create Opyn oTokens\n * @author Opyn Team\n * @notice Create new oTokens and keep track of all created tokens\n * @dev Calculate contract address before each creation with CREATE2\n * and deploy eip-1167 minimal proxies for oToken logic contract\n */\ncontract OtokenFactory is OtokenSpawner {\n    using SafeMath for uint256;\n    /// @notice Opyn AddressBook contract that records the address of the Whitelist module and the Otoken impl address. */\n    address public addressBook;\n\n    /// @notice array of all created otokens */\n    address[] public otokens;\n\n    /// @dev mapping from parameters hash to its deployed address\n    mapping(bytes32 => address) private idToAddress;\n\n    /// @dev max expiry that BokkyPooBahsDateTimeLibrary can handle. (2345/12/31)\n    uint256 private constant MAX_EXPIRY = 11865398400;\n\n    constructor(address _addressBook) public {\n        addressBook = _addressBook;\n    }\n\n    /// @notice emitted when the factory creates a new Option\n    event OtokenCreated(\n        address tokenAddress,\n        address creator,\n        address indexed underlying,\n        address indexed strike,\n        address indexed collateral,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    );\n\n    /**\n     * @notice create new oTokens\n     * @dev deploy an eip-1167 minimal proxy with CREATE2 and register it to the whitelist module\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return newOtoken address of the newly created option\n     */\n    function createOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external returns (address) {\n        require(_expiry > now, \"OtokenFactory: Can't create expired option\");\n        require(_expiry < MAX_EXPIRY, \"OtokenFactory: Can't create option with expiry > 2345/12/31\");\n        // 8 hours = 3600 * 8 = 28800 seconds\n        require(_expiry.sub(28800).mod(86400) == 0, \"OtokenFactory: Option has to expire 08:00 UTC\");\n        bytes32 id = _getOptionId(_underlyingAsset, _strikeAsset, _collateralAsset, _strikePrice, _expiry, _isPut);\n        require(idToAddress[id] == address(0), \"OtokenFactory: Option already created\");\n\n        address whitelist = AddressBookInterface(addressBook).getWhitelist();\n        require(\n            WhitelistInterface(whitelist).isWhitelistedProduct(\n                _underlyingAsset,\n                _strikeAsset,\n                _collateralAsset,\n                _isPut\n            ),\n            \"OtokenFactory: Unsupported Product\"\n        );\n\n        require(!_isPut || _strikePrice > 0, \"OtokenFactory: Can't create a $0 strike put option\");\n\n        address otokenImpl = AddressBookInterface(addressBook).getOtokenImpl();\n\n        bytes memory initializationCalldata = abi.encodeWithSelector(\n            OtokenInterface(otokenImpl).init.selector,\n            addressBook,\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n\n        address newOtoken = _spawn(otokenImpl, initializationCalldata);\n\n        idToAddress[id] = newOtoken;\n        otokens.push(newOtoken);\n        WhitelistInterface(whitelist).whitelistOtoken(newOtoken);\n\n        emit OtokenCreated(\n            newOtoken,\n            msg.sender,\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n\n        return newOtoken;\n    }\n\n    /**\n     * @notice get the total oTokens created by the factory\n     * @return length of the oTokens array\n     */\n    function getOtokensLength() external view returns (uint256) {\n        return otokens.length;\n    }\n\n    /**\n     * @notice get the oToken address for an already created oToken, if no oToken has been created with these parameters, it will return address(0)\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return the address of target otoken.\n     */\n    function getOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address) {\n        bytes32 id = _getOptionId(_underlyingAsset, _strikeAsset, _collateralAsset, _strikePrice, _expiry, _isPut);\n        return idToAddress[id];\n    }\n\n    /**\n     * @notice get the address at which a new oToken with these parameters would be deployed\n     * @dev return the exact address that will be deployed at with _computeAddress\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return targetAddress the address this oToken would be deployed at\n     */\n    function getTargetOtokenAddress(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address) {\n        address otokenImpl = AddressBookInterface(addressBook).getOtokenImpl();\n        bytes memory initializationCalldata = abi.encodeWithSelector(\n            OtokenInterface(otokenImpl).init.selector,\n            addressBook,\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n        return _computeAddress(otokenImpl, initializationCalldata);\n    }\n\n    /**\n     * @dev hash oToken parameters and return a unique option id\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return id the unique id of an oToken\n     */\n    function _getOptionId(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(_underlyingAsset, _strikeAsset, _collateralAsset, _strikePrice, _expiry, _isPut)\n            );\n    }\n}\n"
6     },
7     "/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/OtokenSpawner.sol": {
8       "content": "/* SPDX-License-Identifier: UNLICENSED */\n\npragma solidity =0.6.10;\n\nimport {Spawn} from \"./packages/Spawn.sol\";\nimport {Create2} from \"./packages/oz/Create2.sol\";\n\n/**\n * @title OtokenSpawner\n * @author Opyn Team\n * @notice This contract spawns and initializes eip-1167 minimal proxies that\n * point to existing logic contracts.\n * @notice This contract was modified from Spawner.sol\n * https://github.com/0age/Spawner/blob/master/contracts/Spawner.sol to fit into OtokenFactory\n */\ncontract OtokenSpawner {\n    // fixed salt value because we will only deploy an oToken with the same init value once\n    bytes32 private constant SALT = bytes32(0);\n\n    /**\n     * @notice internal function for spawning an eip-1167 minimal proxy using `CREATE2`\n     * @param logicContract address of the logic contract\n     * @param initializationCalldata calldata that will be supplied to the `DELEGATECALL`\n     * from the spawned contract to the logic contract during contract creation\n     * @return spawnedContract the address of the newly-spawned contract\n     */\n    function _spawn(address logicContract, bytes memory initializationCalldata) internal returns (address) {\n        // place the creation code and constructor args of the contract to spawn in memory\n        bytes memory initCode = abi.encodePacked(\n            type(Spawn).creationCode,\n            abi.encode(logicContract, initializationCalldata)\n        );\n\n        // spawn the contract using `CREATE2`\n        return Create2.deploy(0, SALT, initCode);\n    }\n\n    /**\n     * @notice internal view function for finding the address of the standard\n     * eip-1167 minimal proxy created using `CREATE2` with a given logic contract\n     * and initialization calldata payload\n     * @param logicContract address of the logic contract\n     * @param initializationCalldata calldata that will be supplied to the `DELEGATECALL`\n     * from the spawned contract to the logic contract during contract creation\n     * @return target address of the next spawned minimal proxy contract with the\n     * given parameters.\n     */\n    function _computeAddress(address logicContract, bytes memory initializationCalldata)\n        internal\n        view\n        returns (address target)\n    {\n        // place the creation code and constructor args of the contract to spawn in memory\n        bytes memory initCode = abi.encodePacked(\n            type(Spawn).creationCode,\n            abi.encode(logicContract, initializationCalldata)\n        );\n        // get target address using the constructed initialization code\n        bytes32 initCodeHash = keccak256(initCode);\n\n        target = Create2.computeAddress(SALT, initCodeHash);\n    }\n}\n"
9     },
10     "/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/interfaces/AddressBookInterface.sol": {
11       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\ninterface AddressBookInterface {\n    /* Getters */\n\n    function getOtokenImpl() external view returns (address);\n\n    function getOtokenFactory() external view returns (address);\n\n    function getWhitelist() external view returns (address);\n\n    function getController() external view returns (address);\n\n    function getOracle() external view returns (address);\n\n    function getMarginPool() external view returns (address);\n\n    function getMarginCalculator() external view returns (address);\n\n    function getLiquidationManager() external view returns (address);\n\n    function getAddress(bytes32 _id) external view returns (address);\n\n    /* Setters */\n\n    function setOtokenImpl(address _otokenImpl) external;\n\n    function setOtokenFactory(address _factory) external;\n\n    function setOracleImpl(address _otokenImpl) external;\n\n    function setWhitelist(address _whitelist) external;\n\n    function setController(address _controller) external;\n\n    function setMarginPool(address _marginPool) external;\n\n    function setMarginCalculator(address _calculator) external;\n\n    function setLiquidationManager(address _liquidationManager) external;\n\n    function setAddress(bytes32 _id, address _newImpl) external;\n}\n"
12     },
13     "/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/interfaces/OtokenInterface.sol": {
14       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\ninterface OtokenInterface {\n    function addressBook() external view returns (address);\n\n    function underlyingAsset() external view returns (address);\n\n    function strikeAsset() external view returns (address);\n\n    function collateralAsset() external view returns (address);\n\n    function strikePrice() external view returns (uint256);\n\n    function expiryTimestamp() external view returns (uint256);\n\n    function isPut() external view returns (bool);\n\n    function init(\n        address _addressBook,\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external;\n\n    function mintOtoken(address account, uint256 amount) external;\n\n    function burnOtoken(address account, uint256 amount) external;\n}\n"
15     },
16     "/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/interfaces/WhitelistInterface.sol": {
17       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\ninterface WhitelistInterface {\n    /* View functions */\n\n    function addressBook() external view returns (address);\n\n    function isWhitelistedProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external view returns (bool);\n\n    function isWhitelistedCollateral(address _collateral) external view returns (bool);\n\n    function isWhitelistedOtoken(address _otoken) external view returns (bool);\n\n    function isWhitelistedCallee(address _callee) external view returns (bool);\n\n    /* Admin / factory only functions */\n    function whitelistProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external;\n\n    function blacklistProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external;\n\n    function whitelistCollateral(address _collateral) external;\n\n    function blacklistCollateral(address _collateral) external;\n\n    function whitelistOtoken(address _otoken) external;\n\n    function blacklistOtoken(address _otoken) external;\n\n    function whitelistCallee(address _callee) external;\n\n    function blacklistCallee(address _callee) external;\n}\n"
18     },
19     "/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/packages/Spawn.sol": {
20       "content": "/* solhint-disable avoid-low-level-calls, indent, no-inline-assembly */\n/* This contract is copied from Spawner package: https://github.com/0age/Spawner */\npragma solidity =0.6.10;\n\n/**\n * @title Spawn\n * @author 0age\n * @notice This contract provides creation code that is used by Spawner in order\n * to initialize and deploy eip-1167 minimal proxies for a given logic contract.\n * SPDX-License-Identifier: MIT\n */\ncontract Spawn {\n    constructor(address logicContract, bytes memory initializationCalldata) public payable {\n        // delegatecall into the logic contract to perform initialization.\n        (bool ok, ) = logicContract.delegatecall(initializationCalldata);\n        if (!ok) {\n            // pass along failure message from delegatecall and revert.\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // place eip-1167 runtime code in memory.\n        bytes memory runtimeCode = abi.encodePacked(\n            bytes10(0x363d3d373d3d3d363d73),\n            logicContract,\n            bytes15(0x5af43d82803e903d91602b57fd5bf3)\n        );\n\n        // return eip-1167 code to write it to spawned contract runtime.\n        assembly {\n            return(add(0x20, runtimeCode), 45) // eip-1167 runtime code, length\n        }\n    }\n}\n"
21     },
22     "/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/packages/oz/Create2.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable */\n\npragma solidity =0.6.10;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address) {\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\n        return address(uint256(_data));\n    }\n}\n"
24     },
25     "/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/packages/oz/SafeMath.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable */\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
27     }
28   },
29   "settings": {
30     "remappings": [],
31     "optimizer": {
32       "enabled": true,
33       "runs": 200
34     },
35     "evmVersion": "istanbul",
36     "libraries": {
37       "": {}
38     },
39     "outputSelection": {
40       "*": {
41         "*": [
42           "evm.bytecode",
43           "evm.deployedBytecode",
44           "abi"
45         ]
46       }
47     }
48   }
49 }}