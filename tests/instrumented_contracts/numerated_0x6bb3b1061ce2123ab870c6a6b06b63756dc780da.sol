1 {"ACOAssetHelper.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\nlibrary ACOAssetHelper {\r\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    /**\r\n     * @dev Internal function to get if the address is for Ethereum (0x0).\r\n     * @param _address Address to be checked.\r\n     * @return Whether the address is for Ethereum.\r\n     */ \r\n    function _isEther(address _address) internal pure returns(bool) {\r\n        return _address == address(0);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to approve ERC20 tokens.\r\n     * @param token Address of the token.\r\n     * @param spender Authorized address.\r\n     * @param amount Amount to authorize.\r\n     */\r\n    function _callApproveERC20(address token, address spender, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x095ea7b3, spender, amount));\r\n        require(success \u0026\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \"approve\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to transfer ERC20 tokens.\r\n     * @param token Address of the token.\r\n     * @param recipient Address of the transfer destination.\r\n     * @param amount Amount to transfer.\r\n     */\r\n    function _callTransferERC20(address token, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, amount));\r\n        require(success \u0026\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \"transfer\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to call transferFrom on ERC20 tokens.\r\n     * @param token Address of the token.\r\n     * @param sender Address of the sender.\r\n     * @param recipient Address of the transfer destination.\r\n     * @param amount Amount to transfer.\r\n     */\r\n     function _callTransferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount));\r\n        require(success \u0026\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \"transferFrom\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset symbol.\r\n     * @param asset Address of the asset.\r\n     * @return The asset symbol.\r\n     */\r\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\r\n        if (_isEther(asset)) {\r\n            return \"ETH\";\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));\r\n            require(success, \"symbol\");\r\n            return abi.decode(returndata, (string));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset decimals.\r\n     * @param asset Address of the asset.\r\n     * @return The asset decimals.\r\n     */\r\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\r\n        if (_isEther(asset)) {\r\n            return uint8(18);\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x313ce567));\r\n            require(success, \"decimals\");\r\n            return abi.decode(returndata, (uint8));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to the asset name.\r\n     * @param asset Address of the asset.\r\n     * @return The asset name.\r\n     */\r\n    function _getAssetName(address asset) internal view returns(string memory) {\r\n        if (_isEther(asset)) {\r\n            return \"Ethereum\";\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x06fdde03));\r\n            require(success, \"name\");\r\n            return abi.decode(returndata, (string));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset balance of an account.\r\n     * @param asset Address of the asset.\r\n     * @param account Address of the account.\r\n     * @return The account balance.\r\n     */\r\n    function _getAssetBalanceOf(address asset, address account) internal view returns(uint256) {\r\n        if (_isEther(asset)) {\r\n            return account.balance;\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, account));\r\n            require(success, \"balanceOf\");\r\n            return abi.decode(returndata, (uint256));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset allowance between two addresses.\r\n     * @param asset Address of the asset.\r\n     * @param owner Address of the owner of the tokens.\r\n     * @param spender Address of the spender authorized.\r\n     * @return The owner allowance for the spender.\r\n     */\r\n    function _getAssetAllowance(address asset, address owner, address spender) internal view returns(uint256) {\r\n        if (_isEther(asset)) {\r\n            return 0;\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0xdd62ed3e, owner, spender));\r\n            require(success, \"allowance\");\r\n            return abi.decode(returndata, (uint256));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer an asset. \r\n     * @param asset Address of the asset to be transferred.\r\n     * @param to Address of the destination.\r\n     * @param amount The amount to be transferred.\r\n     */\r\n    function _transferAsset(address asset, address to, uint256 amount) internal {\r\n        if (_isEther(asset)) {\r\n            (bool success,) = to.call{value:amount}(new bytes(0));\r\n            require(success, \"send\");\r\n        } else {\r\n            _callTransferERC20(asset, to, amount);\r\n        }\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to receive an asset. \r\n     * @param asset Address of the asset to be received.\r\n     * @param amount The amount to be received.\r\n     */\r\n    function _receiveAsset(address asset, uint256 amount) internal {\r\n        if (_isEther(asset)) {\r\n            require(msg.value == amount, \"Invalid ETH amount\");\r\n        } else {\r\n            require(msg.value == 0, \"No payable\");\r\n            _callTransferFromERC20(asset, msg.sender, address(this), amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to check asset allowance and set to Infinity if necessary.\r\n     * @param asset Address of the asset.\r\n     * @param owner Address of the owner of the tokens.\r\n     * @param spender Address of the spender authorized.\r\n     * @param amount Amount to check allowance.\r\n     */\r\n    function _setAssetInfinityApprove(address asset, address owner, address spender, uint256 amount) internal {\r\n        if (_getAssetAllowance(asset, owner, spender) \u003c amount) {\r\n            _callApproveERC20(asset, spender, MAX_UINT);\r\n        }\r\n    }\r\n}"},"ACORewards.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\nimport \u0027./Ownable.sol\u0027;\r\nimport \u0027./SafeMath.sol\u0027;\r\nimport \u0027./ACOAssetHelper.sol\u0027;\r\nimport \u0027./IACOToken.sol\u0027;\r\n\r\n\r\ncontract ACORewards is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event RewardPaid(address indexed user, uint256 indexed pid, address indexed aco, uint256 reward);\r\n    event SetLPTokenAllocPoint(uint256 indexed pid, address indexed lpToken, uint256 allocPoint);\r\n\tevent SetCurrentReward(address indexed aco, uint256 rewardRate);\r\n\tevent WithdrawStuckToken(address indexed token, address indexed destination, uint256 amount);\r\n\t\r\n\tstruct CurrentRewardData {\r\n\t\taddress aco;               // Address of the ACO to be distributed.\r\n\t\tuint256 rewardRate;        // ACOs te be reward per second.\r\n\t}\r\n\t\r\n\tstruct PoolInfo {\r\n\t\taddress lpToken;           // Address of LP token contract.\r\n\t\tuint256 allocPoint;        // How many allocation points assigned to this LP token.\r\n\t}\r\n\t\r\n    struct ACORewardData {\r\n\t\tuint256 lastUpdateTime;    // Last timestamp that ACO distribution was updated.\r\n\t\tuint256 accRewardPerShare; // Accumulated ACO per share, times 1e18.\r\n\t}\r\n\t\r\n\tstruct UserACORewardData {\r\n\t\tuint256 pendingRewardStored;        // Pending reward stored.\r\n\t\tuint256 accAcoRewardPerShareStored; // Last accumulated ACO per share, times 1e18, since last user interaction with the SC.\r\n\t}\r\n\r\n\t// Total allocation poitns. Must be the sum of all allocation points in all pools.\r\n\tuint256 public totalAllocPoint;\r\n\t \r\n\t// The current reward data. See CurrentRewardData struct.\r\n\tCurrentRewardData public currentReward;\r\n\t\r\n\t// Info of each pool.\r\n    PoolInfo[] public poolInfo;\r\n\r\n    // Array with all ACOs used to reward and that it is still not expired.\r\n\taddress[] public acos;\r\n\t\r\n\t// LP token index =\u003e ACO =\u003e ACO reward data. See ACORewardData struct.\r\n\tmapping(uint256 =\u003e mapping(address =\u003e ACORewardData)) public acosRewardDataPerLP;\r\n\r\n\t// LP token index =\u003e User =\u003e How many LP tokens the user has provided.\r\n    mapping(uint256 =\u003e mapping(address =\u003e uint256)) public balanceOf;\r\n\t\r\n\t// LP token index =\u003e User =\u003e ACO =\u003e User reward data. See UserACORewardData struct.\r\n    mapping(uint256 =\u003e mapping(address =\u003e mapping(address =\u003e UserACORewardData))) public usersAcoRewardData; \r\n    \r\n    constructor() public {\r\n        super.init();\r\n    }\r\n    \r\n    ////////////////////// VIEW FUNCTIONS //////////////////////\r\n    \r\n    function poolLength() external view returns(uint256) {\r\n        return poolInfo.length;\r\n    }\r\n    \r\n    function acosLength() external view returns(uint256) {\r\n        return acos.length;\r\n    }\r\n    \r\n    // External function to be used on the front-end to list the pending ACOs rewards for an account and a LP token. \r\n    function pendingReward(uint256 _pid, address account) external view returns (address[] memory _acos, uint256[] memory _amounts) {\r\n        PoolInfo storage info = poolInfo[_pid];\r\n\t\tuint256 share = balanceOf[_pid][account];\r\n        uint256 totalLPSupply = ACOAssetHelper._getAssetBalanceOf(info.lpToken, address(this));\r\n        \r\n        uint256 qty = 0;\r\n        for (uint256 i = 0; i \u003c acos.length; ++i) {\r\n            uint256 pending = _getPendingReward(\r\n                _pid,\r\n\t\t\t\tinfo.allocPoint, \r\n\t            totalLPSupply,\r\n\t            account,\r\n\t            share,\r\n\t            acos[i]);\r\n                \r\n            if (pending \u003e 0) {\r\n                ++qty;\r\n            }\r\n        }\r\n        \r\n        _acos = new address[](qty);\r\n        _amounts = new uint256[](qty);\r\n        \r\n\t\tif (qty \u003e 0) {\r\n\t\t\tuint256 index = 0;\r\n\t\t\tfor (uint256 i = 0; i \u003c acos.length; ++i) {\r\n\t\t\t\tuint256 pending = _getPendingReward(\r\n\t\t\t\t\t_pid,\r\n\t\t\t\t\tinfo.allocPoint,\r\n\t\t\t\t\ttotalLPSupply,\r\n\t\t\t\t\taccount,\r\n\t\t\t\t\tshare,\r\n\t\t\t\t\tacos[i]);\r\n\t\t\t\t\t\r\n\t\t\t\tif (pending \u003e 0) {\r\n\t\t\t\t\t_acos[index] = acos[i];\r\n\t\t\t\t\t_amounts[index] = pending;\r\n\t\t\t\t\t++index;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n    \r\n    ////////////////////// USERS FUNCTIONS //////////////////////\r\n\r\n    function deposit(uint256 _pid, uint256 amount) external {\r\n\t\tCurrentRewardData storage _currentReward = currentReward;\r\n\t\tPoolInfo storage info = poolInfo[_pid];\r\n\t\trequire(info.allocPoint \u003e 0 \u0026\u0026 _currentReward.rewardRate \u003e 0, \"LP token is forbidden\");\r\n        require(amount \u003e 0, \"Invalid amount\");\r\n\t\t\r\n\t\t_setCurrentAcoRewardAccPerShare(_pid, _currentReward);\r\n\t\t_getUserAcoReward(_pid, true); // Claim available rewards.\r\n\r\n\t\tACOAssetHelper._callTransferFromERC20(info.lpToken, msg.sender, address(this), amount);\r\n\r\n        balanceOf[_pid][msg.sender] = amount.add(balanceOf[_pid][msg.sender]);\r\n        \r\n        emit Deposit(msg.sender, _pid, amount);\r\n    }\r\n\r\n    function withdraw(uint256 _pid, uint256 amount) external {\r\n\t\tuint256 totalUserBalance = balanceOf[_pid][msg.sender];\r\n        require(amount \u003e 0 \u0026\u0026 totalUserBalance \u003e= amount, \"Invalid amount\");\r\n\r\n\t\t_setCurrentAcoRewardAccPerShare(_pid, currentReward);\r\n\t\t_getUserAcoReward(_pid, true); // Claim available rewards.\r\n\t\t\r\n        balanceOf[_pid][msg.sender] = totalUserBalance.sub(amount);\r\n        \r\n        ACOAssetHelper._callTransferERC20(poolInfo[_pid].lpToken, msg.sender, amount);\r\n        \r\n\t\temit Withdraw(msg.sender, _pid, amount);\r\n    }\r\n\r\n    function claimReward(uint256 _pid) public {\r\n\t\tPoolInfo storage info = poolInfo[_pid];\r\n        require(info.lpToken != address(0), \"Invalid LP token\");\r\n\t\t\r\n\t\t_setCurrentAcoRewardAccPerShare(_pid, currentReward);\r\n\t\t_getUserAcoReward(_pid, false);\r\n    }\r\n\r\n\tfunction claimRewards(uint256[] calldata _pids) external {\r\n\t\tfor (uint256 i = 0; i \u003c _pids.length; ++i) {\r\n\t\t\tclaimReward(_pids[i]);\r\n\t\t}\r\n    }\r\n\t\r\n\t// Withdraw without caring about rewards. EMERGENCY ONLY!\r\n    function emergencyWithdraw(uint256 _pid) external {\r\n        uint256 totalUserBalance = balanceOf[_pid][msg.sender];\r\n        require(totalUserBalance \u003e 0, \"No balance\");\r\n\r\n\t\t_setCurrentAcoRewardAccPerShare(_pid, currentReward);\r\n\r\n\t\tbalanceOf[_pid][msg.sender] = 0;\r\n        ACOAssetHelper._callTransferERC20(poolInfo[_pid].lpToken, msg.sender, totalUserBalance);\r\n\r\n        emit EmergencyWithdraw(msg.sender, _pid, totalUserBalance);\r\n    }\r\n    \r\n    ////////////////////// INTERNAL FUNCTIONS //////////////////////\r\n\t\r\n\t/*\r\n\t * Calculate the pending rewards and transfers them to the user.\r\n\t * The math is basically, any point in time, the amount of ACOs entitled to a user but is pending to be distributed is:\r\n     *\r\n     * pending reward = user.share * (aco.accRewardPerShare - user.AccAcoRewardPerShareStored)\r\n     *\r\n     * Whenever a user deposit or withdraws for a LP token or even a reward claim:\r\n     *  1. The current ACOs accRewardPerShare and `lastUpdateTime get updated. `_setCurrentAcoRewardAccPerShare` function.\r\n     *  2. User receives the pending reward sent to his/her address.\r\n     *  3. userAccAcoRewardPerShareStored gets updated with the current ACO accRewardPerShare.\r\n\t */\r\n\tfunction _getUserAcoReward(uint256 _pid, bool ignoreIfNoBalance) internal {\r\n\t\tuint256 share = balanceOf[_pid][msg.sender];\r\n\t\tfor (uint256 i = acos.length; i \u003e 0; --i) {\r\n\t\t\taddress aco = acos[i - 1];\r\n\t\t\t\r\n\t\t\tif (IACOToken(aco).expiryTime() \u003c= block.timestamp) { // ACO is expired.\r\n\t\t\t\t_removeAco(i - 1);\r\n\t\t\t} else {\r\n\t\t\t\tuint256 acoAccRewardPerShare = acosRewardDataPerLP[_pid][aco].accRewardPerShare;\r\n\t\t\t\t\r\n\t\t\t\tUserACORewardData storage userAcoRewardData = usersAcoRewardData[_pid][msg.sender][aco];\r\n\t\t\t\t\r\n\t\t\t\tuint256 pending = _earned(share, acoAccRewardPerShare, userAcoRewardData.accAcoRewardPerShareStored);\r\n\t\t\t\tpending = pending.add(userAcoRewardData.pendingRewardStored);\r\n\r\n\t\t\t\tuserAcoRewardData.pendingRewardStored = pending;\r\n\t\t\t\tuserAcoRewardData.accAcoRewardPerShareStored = acoAccRewardPerShare;\r\n\t\t\t\t\r\n\t\t\t\tif (pending \u003e 0) {\r\n\t\t\t\t    // If for some reason the current ACO on the SC has not enough balance, the respective reward could be skipped to be paid later and this way avoids an error. (This is true on withdraw and deposit).\r\n\t\t\t\t    if (ignoreIfNoBalance) {\r\n\t\t\t\t        uint256 acoBalance = ACOAssetHelper._getAssetBalanceOf(aco, address(this));\r\n\t\t\t\t        if (acoBalance \u003c pending) {\r\n\t\t\t\t            continue;\r\n\t\t\t\t        }\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t    userAcoRewardData.pendingRewardStored = 0; // All ACO reward was paid.\r\n\t\t\t\t\tACOAssetHelper._callTransferERC20(aco, msg.sender, pending);\r\n\t\t\t\t\temit RewardPaid(msg.sender, _pid, aco, pending);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Update the current ACO accRewardPerShare and lastUpdateTime for the active LP token.\r\n\tfunction _setCurrentAcoRewardAccPerShare(uint256 _pid, CurrentRewardData storage _currentReward) internal {\r\n\t\tPoolInfo storage info = poolInfo[_pid];\r\n\t\tif (info.allocPoint \u003e 0) {\r\n\t\t\tuint256 totalLPSupply = ACOAssetHelper._getAssetBalanceOf(info.lpToken, address(this));\r\n\t\t\tACORewardData storage currentAcoData = acosRewardDataPerLP[_pid][_currentReward.aco];\r\n\t\t\tcurrentAcoData.accRewardPerShare = _getAccRewardPerAco(totalLPSupply, info.allocPoint, _currentReward.aco, _currentReward.rewardRate, _currentReward.aco, currentAcoData);\r\n\t\t\tcurrentAcoData.lastUpdateTime = block.timestamp;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/*\r\n\t * Get the accumulated reward per share for an ACO.\r\n\t * For the current ACO rewarding: \r\n\t * previous accRewardPerShare + [rewardRate * (now - lastUpdateTime) * lpAllocPoint / totalAllocPoint] * 1e18 / totalSupply\r\n\t * lpAllocPoint / totalAllocPoint is to get the weight for the respective LP token on the ACO reward.\r\n\t * The value is multiplied by 1e18 for no losing precision. Hereafter it will be divided by 1e18.\r\n\t */\r\n\tfunction _getAccRewardPerAco(\r\n\t\tuint256 totalSupply,\r\n\t\tuint256\tallocPoint,\t\r\n\t\taddress currentAco, \r\n\t\tuint256 currentAcoRewardRate,\r\n\t\taddress aco, \r\n\t\tACORewardData storage acoRewardData\r\n\t) internal view returns (uint256) {\r\n        if (currentAco != aco || totalSupply == 0 || allocPoint == 0 || currentAcoRewardRate == 0) {\r\n            return acoRewardData.accRewardPerShare;\r\n        } else {\r\n\t\t\tuint256 acoReward = block.timestamp.sub(acoRewardData.lastUpdateTime).mul(currentAcoRewardRate).mul(allocPoint).div(totalAllocPoint);\r\n\t\t\treturn acoReward.mul(1e18).div(totalSupply).add(acoRewardData.accRewardPerShare);\r\n\t\t}\r\n    }\r\n\t\r\n\t// user.share * (aco.accRewardPerShare - user.accAcoRewardPerShareStored) / 1e18 (the division per 1e18 is because all \"per share\" data is multiplied by 1e18)\r\n\tfunction _earned(\r\n\t\tuint256 accountShare, \r\n\t\tuint256 acoAccRewardPerShare,\r\n\t\tuint256 userAccAcoRewardPerShareStored\r\n\t) internal pure returns (uint256) {\r\n        return accountShare.mul(acoAccRewardPerShare.sub(userAccAcoRewardPerShareStored)).div(1e18);\r\n    }\r\n\t\r\n\t/*\r\n\t * To remove an expired ACO that expired condition already was checked.\r\n\t * Useful to save gas on next txs.\r\n\t */\r\n\tfunction _removeAco(uint256 acoIndex) internal {\r\n\t\tuint256 lastIndex = acos.length - 1;\r\n\t\tif (lastIndex != acoIndex) {\r\n\t\t\taddress last = acos[lastIndex];\r\n\t\t\tacos[acoIndex] = last;\r\n\t\t}\r\n\t\tacos.pop();\r\n\t}\r\n\t\r\n\t// Used only on the pending reward external view function.\r\n\tfunction _getPendingReward(\r\n\t    uint256 _pid, \r\n\t\tuint256 allocPoint,\r\n\t    uint256 totalLPSupply,\r\n\t    address account,\r\n\t    uint256 accountShare,\r\n\t    address aco\r\n    ) internal view returns(uint256 pending) {\r\n\t    pending = 0;\r\n\t    if (IACOToken(aco).expiryTime() \u003e block.timestamp) {\r\n                \r\n    \t    uint256 accRewardPerShare = _getAccRewardPerAco(\r\n    \t        totalLPSupply, \r\n    \t        allocPoint, \r\n    \t        currentReward.aco, \r\n    \t        currentReward.rewardRate, \r\n    \t        aco, \r\n    \t        acosRewardDataPerLP[_pid][aco]\r\n            );\r\n            \r\n            UserACORewardData storage userAcoRewardData = usersAcoRewardData[_pid][account][aco];\r\n\t\t\tpending = _earned(accountShare, accRewardPerShare, userAcoRewardData.accAcoRewardPerShareStored);\r\n\t\t\tpending = pending.add(userAcoRewardData.pendingRewardStored);\r\n        }\r\n\t}\r\n\t\r\n\t////////////////////// PUBLIC FUNCTIONS //////////////////////\r\n\t\r\n\t\r\n\t// Update all accumulated per share value for the current ACO rewarding on all active LP tokens.\r\n\tfunction setAllLPTokensCurrentAcoRewardAccPerShare() internal {\r\n\t\tCurrentRewardData storage _currentReward = currentReward;\r\n\t\tfor (uint256 i = 0; i \u003c poolInfo.length; ++i) {\r\n\t\t\t_setCurrentAcoRewardAccPerShare(i, _currentReward);\r\n\t\t}\r\n\t}\r\n\r\n    // Remove expired ACOs from the array. To save gas on the next txs.\r\n\tfunction setValidAcos() public {\r\n\t\tfor (uint256 i = acos.length; i \u003e 0; --i) {\r\n            address aco = acos[i - 1];\r\n\t\t\tif (IACOToken(aco).expiryTime() \u003c= block.timestamp) {\r\n\t\t\t\t_removeAco(i - 1);\r\n\t\t\t}\r\n        }\r\n\t}\r\n\t\r\n\t////////////////////// ADMIN FUNCTIONS //////////////////////\r\n\r\n    /*\r\n\t * Function to the admin sets new LP tokens or change the allocation points.\r\n\t * When an allocation point is set to zero the respective LP token is inactivated.\r\n\t * If the LP token is inactived there is no reward and the respective deposit is also forbidden.\r\n\t * However, withdrawals and previous rewards claims keep working.\r\n\t */\r\n\tfunction setLPTokens(address[] calldata lpTokens, uint256[] calldata allocPoints) external onlyOwner {\r\n\t\trequire(lpTokens.length == allocPoints.length, \"Invalid arguments\");\r\n\t\t\r\n\t\tsetAllLPTokensCurrentAcoRewardAccPerShare();\r\n\t\tsetValidAcos();\r\n\t\t\r\n\t\taddress _currentAco = currentReward.aco;\r\n\t\tfor (uint256 i = 0; i \u003c lpTokens.length; ++i) {\r\n\t\t\trequire(allocPoints[i] \u003c= 1e18, \"Invalid alloc point\"); // To avoid overflow.\r\n\r\n\t\t\tbool isNew = true;\r\n\t\t\tuint256 _pid;\r\n\t\t\tfor (uint256 j = 0; j \u003c poolInfo.length; ++j) {\r\n\r\n\t\t\t\tPoolInfo storage info = poolInfo[j];\r\n\t\t\t\tif (info.lpToken == lpTokens[i]) {\r\n\t\t\t\t\t_pid = j;\r\n\t\t\t\t\ttotalAllocPoint = totalAllocPoint.sub(info.allocPoint).add(allocPoints[i]);\r\n\t\t\t\t\tinfo.allocPoint = allocPoints[i];\r\n\t\t\t\t\tisNew = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (isNew) { // It is new LP token.\r\n\t\t\t\t_pid = poolInfo.length;\r\n\t\t\t\tpoolInfo.push(PoolInfo(lpTokens[i], allocPoints[i]));\r\n\t\t\t\ttotalAllocPoint = totalAllocPoint.add(allocPoints[i]);\r\n\t\t\t}\r\n\r\n\t\t\t// Sets the current ACO timestamp as \"now\" for the new LP token configuration.\r\n\t\t\tacosRewardDataPerLP[_pid][_currentAco].lastUpdateTime = block.timestamp;\r\n\r\n\t\t\temit SetLPTokenAllocPoint(_pid, lpTokens[i], allocPoints[i]);\r\n\t\t}\r\n\t}\r\n\t\r\n\t/*\r\n\t * Function to the admin sets the ACO to the current reward.\r\n\t * The rewardRate is ACO per second.\r\n\t */\r\n\tfunction setCurrentReward(address aco, uint256 rewardRate) external onlyOwner {\r\n\t\trequire(rewardRate \u003c= 1e40, \"The reward rate is too big\"); // To avoid overflow.\r\n\r\n\t\tsetAllLPTokensCurrentAcoRewardAccPerShare();\r\n\t\tsetValidAcos();\r\n\t\t\r\n\t\tbool isNew = true;\r\n\t\tfor (uint256 i = 0; i \u003c acos.length; ++i) {\r\n\t\t\tif (acos[i] == aco) {\r\n\t\t\t\tisNew = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (isNew) {\r\n\t\t\tacos.push(aco);\r\n\t\t}\r\n\t\t\r\n\t\tCurrentRewardData storage _currentReward = currentReward;\r\n\t\t_currentReward.aco = aco;\r\n\t\t_currentReward.rewardRate = rewardRate;\r\n\t\t\r\n\t\t/*\r\n\t\t * Set the lastUpdateTime as now for all active LP tokens.\r\n\t\t * This timestamp is used to calculate the accumulated per share value.\r\n\t\t * So new current ACO timestamp is set for all LP tokens as \"now\".\r\n\t\t */\r\n\t\tfor (uint256 i = 0; i \u003c poolInfo.length; ++i) {\r\n\t\t\tif (poolInfo[i].allocPoint \u003e 0) {\r\n\t\t\t\tacosRewardDataPerLP[i][aco].lastUpdateTime = block.timestamp;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\temit SetCurrentReward(aco, rewardRate);\r\n\t}\r\n\t\r\n\t/*\r\n\t * Function to the admin withdraws a stuck token if necessary. \r\n\t * For example, an ACO rewarded and that is not being used anymore.\r\n\t * Withdraw any LP token is FORBIDDEN.\r\n\t */\r\n    function withdrawStuckToken(address token, uint256 amount, address destination) external onlyOwner {\r\n\t\t// To guarantee the deny for withdrawing a LP token.\r\n\t\tfor (uint256 i = 0; i \u003c poolInfo.length; ++i) {\r\n\t\t\trequire(poolInfo[i].lpToken != token, \"Forbidden!\");\r\n\t\t}\r\n\t\t\r\n\t\tuint256 tokenBalance = ACOAssetHelper._getAssetBalanceOf(token, address(this));\r\n\t\tif (amount \u003e tokenBalance) {\r\n\t\t\tamount = tokenBalance;\r\n\t\t}\r\n\t\tif (amount \u003e 0) {\r\n\t\t    ACOAssetHelper._callTransferERC20(token, destination, amount);\r\n\t\t\temit WithdrawStuckToken(token, destination, amount);\r\n\t\t}\r\n    }\r\n}"},"IACOToken.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ninterface IACOToken is IERC20 {\r\n\tfunction init(address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime, uint256 _acoFee, address payable _feeDestination, uint256 _maxExercisedAccounts) external;\r\n    function name() external view returns(string memory);\r\n    function symbol() external view returns(string memory);\r\n    function decimals() external view returns(uint8);\r\n    function underlying() external view returns (address);\r\n    function strikeAsset() external view returns (address);\r\n    function feeDestination() external view returns (address);\r\n    function isCall() external view returns (bool);\r\n    function strikePrice() external view returns (uint256);\r\n    function expiryTime() external view returns (uint256);\r\n    function totalCollateral() external view returns (uint256);\r\n    function acoFee() external view returns (uint256);\r\n\tfunction maxExercisedAccounts() external view returns (uint256);\r\n    function underlyingSymbol() external view returns (string memory);\r\n    function strikeAssetSymbol() external view returns (string memory);\r\n    function underlyingDecimals() external view returns (uint8);\r\n    function strikeAssetDecimals() external view returns (uint8);\r\n    function currentCollateral(address account) external view returns(uint256);\r\n    function unassignableCollateral(address account) external view returns(uint256);\r\n    function assignableCollateral(address account) external view returns(uint256);\r\n    function currentCollateralizedTokens(address account) external view returns(uint256);\r\n    function unassignableTokens(address account) external view returns(uint256);\r\n    function assignableTokens(address account) external view returns(uint256);\r\n    function getCollateralAmount(uint256 tokenAmount) external view returns(uint256);\r\n    function getTokenAmount(uint256 collateralAmount) external view returns(uint256);\r\n    function getBaseExerciseData(uint256 tokenAmount) external view returns(address, uint256);\r\n    function numberOfAccountsWithCollateral() external view returns(uint256);\r\n    function getCollateralOnExercise(uint256 tokenAmount) external view returns(uint256, uint256);\r\n    function collateral() external view returns(address);\r\n    function mintPayable() external payable returns(uint256);\r\n    function mintToPayable(address account) external payable returns(uint256);\r\n    function mint(uint256 collateralAmount) external returns(uint256);\r\n    function mintTo(address account, uint256 collateralAmount) external returns(uint256);\r\n    function burn(uint256 tokenAmount) external returns(uint256);\r\n    function burnFrom(address account, uint256 tokenAmount) external returns(uint256);\r\n    function redeem() external returns(uint256);\r\n    function redeemFrom(address account) external returns(uint256);\r\n    function exercise(uint256 tokenAmount, uint256 salt) external payable returns(uint256);\r\n    function exerciseFrom(address account, uint256 tokenAmount, uint256 salt) external payable returns(uint256);\r\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\r\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\r\n    function transferCollateralOwnership(address recipient, uint256 tokenCollateralizedAmount) external;\r\n}"},"IERC20.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// Adapted from OpenZeppelin\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function init() internal {\r\n        require(_owner == address(0), \"Ownable: Contract initialized\");\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}"},"SafeMath.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"}}