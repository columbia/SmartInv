1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/HolyPaladinToken.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./open-zeppelin/ERC20.sol\";\nimport \"./open-zeppelin/interfaces/IERC20.sol\";\nimport \"./open-zeppelin/libraries/SafeERC20.sol\";\nimport \"./open-zeppelin/utils/Math.sol\";\nimport \"./utils/Owner.sol\";\nimport \"./utils/SmartWalletChecker.sol\";\n\n/** @title Holy Paladin Token (hPAL) contract  */\n/// @author Paladin\ncontract HolyPaladinToken is ERC20(\"Holy Paladin Token\", \"hPAL\"), Owner {\n    using SafeERC20 for IERC20;\n\n\n    /** @notice Seconds in a Week */\n    uint256 public constant WEEK = 604800;\n    /** @notice Seconds in a Month */\n    uint256 public constant MONTH = 2628000;\n    /** @notice 1e18 scale */\n    uint256 public constant UNIT = 1e18;\n    /** @notice Max BPS value (100%) */\n    uint256 public constant MAX_BPS = 10000;\n    /** @notice Seconds in a Year */\n    uint256 public constant ONE_YEAR = 31536000;\n\n    /** @notice  Period to wait before unstaking tokens  */\n    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days\n    /** @notice  Duration of the unstaking period\n    After that period, unstaking cooldown is expired  */\n    uint256 public constant UNSTAKE_PERIOD = 172800; // 2 days\n\n    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */\n    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks\n\n    /** @notice Minimum duration of a Lock  */\n    uint256 public constant MIN_LOCK_DURATION = 7884000; // 3 months\n    /** @notice Maximum duration of a Lock  */\n    uint256 public constant MAX_LOCK_DURATION = 63072000; // 2 years\n\n    /** @notice Address of the PAL token  */\n    IERC20 public immutable pal;\n\n    /** @notice Struct of the Lock of an user  */\n    struct UserLock {\n        // Amount of locked balance\n        uint128 amount; // safe because PAL max supply is 10M tokens\n        // Start of the Lock\n        uint48 startTimestamp;\n        // Duration of the Lock\n        uint48 duration;\n        // BlockNumber for the Lock\n        uint32 fromBlock; // because we want to search by block number\n    }\n\n    /** @notice Array of all user Locks, ordered from oldest to newest  */\n    mapping(address => UserLock[]) public userLocks;\n\n    /** @notice Struct tracking the total amount locked  */\n    struct TotalLock {\n        // Total locked Supply\n        uint224 total;\n        // BlockNumber for the last update\n        uint32 fromBlock;\n    }\n\n    /** @notice Current Total locked Supply  */\n    uint256 public currentTotalLocked;\n    /** @notice List of TotalLocks, ordered from oldest to newest  */\n    TotalLock[] public totalLocks;\n\n    /** @notice User Cooldowns  */\n    mapping(address => uint256) public cooldowns;\n\n    /** @notice Checkpoints for users votes  */\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    /** @notice Checkpoints for users Delegates  */\n    struct DelegateCheckpoint {\n        uint32 fromBlock;\n        address delegate;\n    }\n\n    /** @notice mapping tracking the Delegator for each Delegatee  */\n    mapping(address => address) public delegates;\n\n    /** @notice List of Vote checkpoints for each user  */\n    mapping(address => Checkpoint[]) public checkpoints;\n\n    /** @notice List of Delegate checkpoints for each user  */\n    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;\n\n    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */\n    uint256 public kickRatioPerWeek = 100;\n\n    /** @notice Ratio of bonus votes applied on user locked balance  */\n    uint256 public constant bonusLockVoteRatio = 0.5e18;\n\n    /** @notice Allow emergency withdraws  */\n    bool public emergency = false;\n\n    /** @notice Address of the vault holding the PAL rewards  */\n    address public immutable rewardsVault;\n\n    /** @notice Struct of Reward State (global or user)  */\n    struct RewardState {\n        // Reward Index\n        uint128 index;\n        // Timestamp last update for reward state\n        uint128 lastUpdate;\n    }\n\n    /** @notice Global reward state  */\n    RewardState public globalRewards;\n\n    /** @notice Amount of rewards distributed per second at the start  */\n    uint256 public immutable startDropPerSecond;\n    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */\n    uint256 public endDropPerSecond;\n    /** @notice Current amount of rewards distriubted per second  */\n    uint256 public currentDropPerSecond;\n    /** @notice Timestamp of last update for currentDropPerSecond  */\n    uint256 public lastDropUpdate;\n    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */\n    uint256 public immutable dropDecreaseDuration;\n    /** @notice Timestamp: start of the DropPerSecond decrease period  */\n    uint256 public immutable startDropTimestamp;\n\n    /** @notice Reward state for each user  */\n    mapping(address => RewardState) public userRewardStates;\n    /** @notice Current amount of rewards claimable for the user  */\n    mapping(address => uint256) public claimableRewards;\n\n    /** @notice Base reward multiplier for lock  */\n    uint256 public immutable baseLockBonusRatio;\n    /** @notice Minimum reward multiplier for minimum lock duration  */\n    uint256 public immutable minLockBonusRatio;\n    /** @notice Maximum reward multiplier for maximum duration  */\n    uint256 public immutable maxLockBonusRatio;\n\n    /** @notice Last updated Bonus Ratio for rewards  */\n    mapping(address => uint256) public userCurrentBonusRatio;\n    /** @notice Value by which user Bonus Ratio decrease each second  */\n    mapping(address => uint256) public userBonusRatioDecrease;\n    \n    /** @notice Address of the currect SmartWalletChecker  */\n    address public smartWalletChecker;\n    /** @notice Address of the future SmartWalletChecker  */\n    address public futureSmartWalletChecker;\n\n    error NoBalance();\n    error NullAmount();\n    error IncorrectAmount();\n    error AddressZero();\n    error AvailableBalanceTooLow();\n    error NoLock();\n    error EmptyLock();\n    error InvalidBlockNumber();\n    error InsufficientCooldown();\n    error UnstakePeriodExpired();\n    error AmountExceedBalance();\n    error DurationOverMax();\n    error DurationUnderMin();\n    error SmallerAmount();\n    error SmallerDuration();\n    error LockNotExpired();\n    error LockNotKickable();\n    error CannotSelfKick();\n    error NotEmergency();\n    /** @notice Error raised if contract is turned in emergency mode */\n    error EmergencyBlock();\n    error ContractNotAllowed(); \n\n    // Event\n\n    /** @notice Emitted when an user stake PAL in the contract */\n    event Stake(address indexed user, uint256 amount);\n    /** @notice Emitted when an user burns hPAL to withdraw PAL */\n    event Unstake(address indexed user, uint256 amount);\n    /** @notice Emitted when an user triggers the cooldown period */\n    event Cooldown(address indexed user);\n    /** @notice Emitted when an user creates or update its Lock */\n    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);\n    /** @notice Emitted when an user exits the Lock */\n    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);\n    /** @notice Emitted when an user is kicked out of the Lock */\n    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);\n    /** @notice Emitted when an user claim the rewards */\n    event ClaimRewards(address indexed user, uint256 amount);\n    /** @notice Emitted when the delegate of an address changes */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    /** @notice Emitted when the votes of a delegate is updated */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n    /** @notice Emitted when un user withdraw through the emergency method */\n    event EmergencyUnstake(address indexed user, uint256 amount);\n\n    constructor(\n        address _palToken,\n        address _admin,\n        address _rewardsVault,\n        address _smartWalletChecker,\n        uint256 _startDropPerSecond,\n        uint256 _endDropPerSecond,\n        uint256 _dropDecreaseDuration,\n        uint256 _baseLockBonusRatio,\n        uint256 _minLockBonusRatio,\n        uint256 _maxLockBonusRatio\n    ){\n        require(_palToken != address(0));\n        require(_admin != address(0));\n        require(_rewardsVault != address(0));\n\n        pal = IERC20(_palToken);\n\n        _transferOwnership(_admin);\n\n        // Set the smartWalletChecker (can be address 0 if we don't want a checker at 1st)\n        smartWalletChecker = _smartWalletChecker;\n\n        totalLocks.push(TotalLock(\n            0,\n            safe32(block.number)\n        ));\n        // Set the immutable variables\n        rewardsVault = _rewardsVault;\n\n        // Prevent future underflow\n        require(_startDropPerSecond >= endDropPerSecond);\n\n        startDropPerSecond = _startDropPerSecond;\n        endDropPerSecond = _endDropPerSecond;\n\n        currentDropPerSecond = _startDropPerSecond;\n\n        dropDecreaseDuration = _dropDecreaseDuration;\n\n        require(_baseLockBonusRatio != 0);\n        require(_minLockBonusRatio >= _baseLockBonusRatio);\n        require(_maxLockBonusRatio >= _minLockBonusRatio);\n        baseLockBonusRatio = _baseLockBonusRatio;\n        minLockBonusRatio = _minLockBonusRatio;\n        maxLockBonusRatio = _maxLockBonusRatio;\n\n        // Set all update timestamp as contract creation timestamp\n        globalRewards.lastUpdate = safe128(block.timestamp);\n        lastDropUpdate = block.timestamp;\n        // Start the reward distribution & DropPerSecond decrease\n        startDropTimestamp = block.timestamp;\n    }\n\n\n    /**\n     * @notice Deposits PAL & mints hPAL tokens\n     * @param amount amount to stake\n     * @return uint256 : amount of hPAL minted\n     */\n    function stake(uint256 amount) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _stake(msg.sender, amount);\n    }\n\n    /**\n     * @notice Updates the Cooldown for the caller\n     */\n    function cooldown() external {\n        if(emergency) revert EmergencyBlock();\n        if(balanceOf(msg.sender) == 0) revert NoBalance();\n\n        // Set the current timestamp as start of the user cooldown\n        cooldowns[msg.sender] = block.timestamp;\n\n        emit Cooldown(msg.sender);\n    }\n\n    /**\n     * @notice Burns hPAL & withdraws PAL\n     * @param amount amount ot withdraw\n     * @param receiver address to receive the withdrawn PAL\n     * @return uint256 : amount withdrawn\n     */\n    function unstake(uint256 amount, address receiver) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _unstake(msg.sender, amount, receiver);\n    }\n\n    /**\n     * @notice Locks hPAL for a given duration\n     * @param amount amount of the hPAL balance to lock\n     * @param duration duration of the Lock (in seconds)\n     */\n    function lock(uint256 amount, uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        //Check if caller is allowed\n        _assertNotContract(msg.sender);\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        if(delegates[msg.sender] == address(0)){\n            // If the user does not deelegate currently, automatically self-delegate\n            _delegate(msg.sender, msg.sender);\n        }\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n    }\n\n    /**\n     * @notice Increase the user current Lock duration (& restarts the Lock)\n     * @param duration new duration for the Lock (in seconds)\n     */\n    function increaseLockDuration(uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        //Check if caller is allowed\n        _assertNotContract(msg.sender);\n        if(userLocks[msg.sender].length == 0) revert NoLock();\n        // Find the current Lock\n        UserLock storage currentUserLock = userLocks[msg.sender][userLocks[msg.sender].length - 1];\n        if(currentUserLock.amount == 0) revert EmptyLock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current amount, and the new duration\n        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);\n    }\n\n    /**\n     * @notice Increase the amount of hPAL locked for the user\n     * @param amount new amount of hPAL to be locked (in total)\n     */\n    function increaseLock(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        //Check if caller is allowed\n        _assertNotContract(msg.sender);\n        if(userLocks[msg.sender].length == 0) revert NoLock();\n        // Find the current Lock\n        UserLock storage currentUserLock = userLocks[msg.sender][userLocks[msg.sender].length - 1];\n        if(currentUserLock.amount == 0) revert EmptyLock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current duration, and the new amount\n        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);\n    }\n\n    /**\n     * @notice Removes the user Lock after expiration\n     */\n    function unlock() external {\n        if(emergency) revert EmergencyBlock();\n        if(userLocks[msg.sender].length == 0) revert NoLock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        _unlock(msg.sender);\n    }\n\n    /**\n     * @notice Removes an user Lock if too long after expiry, and applies a penalty\n     * @param user address of the user to kick out of a Lock\n     */\n    function kick(address user) external {\n        if(emergency) revert EmergencyBlock();\n        if(msg.sender == user) revert CannotSelfKick();\n        // Update user rewards before any change on their balance (staked and locked)\n        // For both the user and the kicker\n        _updateUserRewards(user);\n        _updateUserRewards(msg.sender);\n        _kick(user, msg.sender);\n    }\n\n    /**\n     * @notice Staked PAL to get hPAL, and locks it for the given duration\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     */\n    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        //Check if caller is allowed\n        _assertNotContract(msg.sender);\n        // Stake the given amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it's done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // And then lock it\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n        return stakedAmount;\n    }\n\n    /**\n     * @notice Stake more PAL into hPAL & add them to the current user Lock\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     */\n    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        //Check if caller is allowed\n        _assertNotContract(msg.sender);\n        if(userLocks[msg.sender].length == 0) revert NoLock();\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;\n        if(previousLockAmount == 0) revert EmptyLock();\n        // Stake the new amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it's done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // Then update the lock with the new increased amount\n        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);\n        } else {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);\n        }\n        return stakedAmount;\n    }\n\n    /**\n     * @notice Delegates the caller voting power to another address\n     * @param delegatee address to delegate to\n     */\n    function delegate(address delegatee) external virtual {\n        if(emergency) revert EmergencyBlock();\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Claim the given amount of rewards for the caller\n     * @param amount amount to claim\n     */\n    function claim(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n\n        if(amount == 0) revert IncorrectAmount();\n\n        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards\n        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];\n\n        // Nothing to claim\n        if(claimAmount == 0) return;\n\n        // remove the claimed amount from the claimable mapping for the user, \n        // and transfer the PAL from the rewardsVault to the user\n        unchecked{ claimableRewards[msg.sender] -= claimAmount; }\n\n        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);\n\n        emit ClaimRewards(msg.sender, claimAmount);\n    }\n\n    /**\n     * @notice Updates the global Reward State for the contract\n     */\n    function updateRewardState() external {\n        if(emergency) revert EmergencyBlock();\n        _updateRewardState();\n    }\n\n    /**\n     * @notice Updates the given user Reward State\n     * @param user address of the user to update\n     */\n    function updateUserRewardState(address user) external {\n        if(emergency) revert EmergencyBlock();\n        _updateUserRewards(user);\n    }\n\n    // ---------------\n\n    /**\n     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer\n     * @param sender address of the sender\n     * @param receiver address fo the receiver\n     * @param amount amount ot transfer\n     * @return uint256 : new cooldown\n     */\n    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {\n        return _getNewReceiverCooldown(\n            cooldowns[sender],\n            amount,\n            receiver,\n            balanceOf(receiver)\n        );\n    }\n\n    /**\n     * @notice Get the total number of Locks for an user\n     * @param user address of the user\n     * @return uint256 : total number of Locks\n     */\n    function getUserLockCount(address user) external view returns(uint256) {\n        return userLocks[user].length;\n    }\n\n    /**\n     * @notice Get the current user Lock\n     * @param user address of the user\n     * @return UserLock : user Lock\n     */\n    function getUserLock(address user) external view returns(UserLock memory) {\n        //If the contract is blocked (emergency mode)\n        //Or if the user does not have a Lock yet\n        //Return an empty lock\n        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);\n        return userLocks[user][userLocks[user].length - 1];\n    }\n\n    /**\n     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return UserLock : user past Lock\n     */\n    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {\n        //If the contract is blocked (emergency mode)\n        //Return an empty lock\n        if(emergency) return UserLock(0, 0, 0, 0);\n        return _getPastLock(user, blockNumber);\n    }\n\n    /**\n     * @notice Get the total count of TotalLock\n     * @return uint256 : total count\n     */\n    function getTotalLockLength() external view returns(uint256){\n        return totalLocks.length;\n    }\n\n    /**\n     * @notice Get the latest TotalLock\n     * @return TotalLock : current TotalLock\n     */\n    function getCurrentTotalLock() external view returns(TotalLock memory){\n        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked\n        return totalLocks[totalLocks.length - 1];\n    }\n\n    /**\n     * @notice Get the TotalLock at a given block\n     * @param blockNumber block number\n     * @return TotalLock : past TotalLock\n     */\n    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {\n        if(blockNumber >= block.number) revert InvalidBlockNumber();\n\n        TotalLock memory emptyLock = TotalLock(\n            0,\n            0\n        );\n\n        uint256 nbCheckpoints = totalLocks.length;\n\n        // last checkpoint check\n        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {\n            return totalLocks[nbCheckpoints - 1];\n        }\n\n        // no checkpoint old enough\n        if (totalLocks[0].fromBlock > blockNumber) {\n            return emptyLock;\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low;\n        uint256 mid;\n        while (low < high) {\n            mid = Math.average(low, high);\n            if (totalLocks[mid].fromBlock == blockNumber) {\n                return totalLocks[mid];\n            }\n            if (totalLocks[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : totalLocks[high - 1];\n    }\n\n    /**\n     * @notice Get the user available balance (staked - locked)\n     * @param user address of the user\n     * @return uint256 : available balance\n     */\n    function availableBalanceOf(address user) external view returns(uint256) {\n        return _availableBalanceOf(user);\n    }\n\n    /**\n     * @notice Get all user balances\n     * @param user address of the user\n     * @return staked : staked balance\n     * @return locked : locked balance\n     * @return available : available balance (staked - locked)\n     */\n    function allBalancesOf(address user) external view returns(\n        uint256 staked,\n        uint256 locked,\n        uint256 available\n    ) {\n        uint256 userBalance = balanceOf(user);\n        // If the contract was blocked (emergency mode) or\n        // If the user has no Lock\n        // then available == staked\n        if(emergency || userLocks[user].length == 0) {\n            return(\n                userBalance,\n                0,\n                userBalance\n            );\n        }\n        // If a Lock exists\n        // Then return\n        // total staked balance\n        // locked balance\n        // available balance (staked - locked)\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return(\n            userBalance,\n            uint256(userLocks[user][lastUserLockIndex].amount),\n            userBalance - uint256(userLocks[user][lastUserLockIndex].amount)\n        );\n    }\n\n    /**\n     * @notice Get the estimated current amount of rewards claimable by the user\n     * @param user address of the user\n     * @return uint256 : estimated amount of rewards to claim\n     */\n    function estimateClaimableRewards(address user) external view returns(uint256) {\n        // no rewards for address 0x0\n        // & in case of emergency mode, show 0\n        if(emergency || user == address(0)) return 0;\n        // If the user rewards where updated on that block, then return the last updated value\n        RewardState memory currentUserRewardState = userRewardStates[user];\n        if(currentUserRewardState.lastUpdate == block.timestamp) return claimableRewards[user];\n\n        // Get the user current claimable amount\n        uint256 estimatedClaimableRewards = claimableRewards[user];\n        // Get the last updated reward index\n        uint256 currentRewardIndex = currentUserRewardState.index;\n\n        if(currentUserRewardState.lastUpdate < block.timestamp){\n            // If needed, update the reward index\n            currentRewardIndex = _getNewIndex(currentDropPerSecond);\n        }\n\n        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentUserRewardState, currentRewardIndex);\n\n        estimatedClaimableRewards += accruedRewards;\n\n        return estimatedClaimableRewards;\n    }\n\n    function rewardIndex() external view returns (uint256) {\n        return globalRewards.index;\n    }\n\n    function lastRewardUpdate() external view returns (uint256) {\n        return globalRewards.lastUpdate;\n    }\n\n    function userRewardIndex(address user) external view returns (uint256) {\n        return userRewardStates[user].index;\n    }\n\n    function rewardsLastUpdate(address user) external view returns (uint256) {\n        return userRewardStates[user].lastUpdate;\n    }\n\n    /**\n     * @notice Current number of vote checkpoints for the user\n     * @param account address of the user\n     * @return uint256 : number of checkpoints\n     */\n    function numCheckpoints(address account) external view virtual returns (uint256){\n        return checkpoints[account].length;\n    }\n\n    /**\n     * @notice Get the user current voting power (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @return uint256 : user current voting power\n     */\n    function getCurrentVotes(address user) external view returns (uint256) {\n        if(emergency) return 0; //If emergency mode, do not show voting power\n\n        uint256 nbCheckpoints = checkpoints[user].length;\n        // current votes with delegation\n        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;\n\n        // check if user has a lock\n        uint256 nbLocks = userLocks[user].length;\n\n        if(nbLocks == 0) return currentVotes;\n\n        // and if there is a lock, and user self-delegate, add the bonus voting power \n        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;\n        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;\n\n        return currentVotes + bonusVotes;\n    }\n\n    /**\n     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return uint256 : user past voting power\n     */\n    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {\n        // votes with delegation for the given block\n        uint256 votes = _getPastVotes(user, blockNumber);\n\n\n        // check if user has a lock at that block\n        UserLock memory pastLock = _getPastLock(user, blockNumber);\n        // and if there is a lock, and user self-delegated, add the bonus voting power \n        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;\n\n        return votes + bonusVotes;\n    }\n\n    /**\n     * @notice Get the user delegate at a given block\n     * @param account address of the user\n     * @param blockNumber block number\n     * @return address : delegate\n     */\n    function getPastDelegate(address account, uint256 blockNumber)\n        public\n        view\n        returns (address)\n    {\n        if(blockNumber >= block.number) revert InvalidBlockNumber();\n\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {\n            return address(0);\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low;\n        uint256 mid;\n        while (low < high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n\n    // ----------------\n\n    // Check if caller is not a smart contract\n    // If it is a contract, check if the contract is allowed by SmartWalletChecker\n    // Revert if not allowed\n    function _assertNotContract(address addr) internal {\n        if(addr != tx.origin){\n            address checker = smartWalletChecker;\n            if(checker != address(0)){\n                if(SmartWalletChecker(checker).check(addr)){\n                    return;\n                }\n                revert ContractNotAllowed();\n            }\n        }\n    }\n\n    // Find the user available balance (staked - locked) => the balance that can be transfered\n    function _availableBalanceOf(address user) internal view returns(uint256) {\n        if(userLocks[user].length == 0) return balanceOf(user);\n        return balanceOf(user) - uint256(userLocks[user][userLocks[user].length - 1].amount);\n    }\n\n    // Update dropPerSecond value\n    function _updateDropPerSecond() internal returns (uint256){\n        // If no more need for monthly updates => decrease duration is over\n        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {\n            // Set the current DropPerSecond as the end value\n            // Plus allows to be updated if the end value is later updated\n            if(currentDropPerSecond != endDropPerSecond) {\n                currentDropPerSecond = endDropPerSecond;\n                lastDropUpdate = block.timestamp;\n                // Here we set the current timestamp isntead of increasing by a number of month,\n                // since we exceeded the dropDecreaseDuration, and the value could be updated\n                // outside a monthly process\n            }\n\n            return endDropPerSecond;\n        }\n\n        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month\n\n        uint256 dropDecreasePerMonth = ((startDropPerSecond - endDropPerSecond) * MONTH) / (dropDecreaseDuration);\n        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;\n\n        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;\n\n        // We calculate the new dropPerSecond value\n        // We don't want to go under the endDropPerSecond\n        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;\n    \n        currentDropPerSecond = newDropPerSecond;\n        lastDropUpdate = lastDropUpdate + (nbMonthEllapsed * MONTH);\n\n        return newDropPerSecond;\n    }\n\n    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){\n        // Get the current total Supply\n        uint256 currentTotalSupply = totalSupply();\n        // and the current global Reward State\n        RewardState memory currentRewardState = globalRewards;\n\n        // DropPerSeond without any multiplier => the base dropPerSecond for stakers\n        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.\n        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;\n\n        // total base reward (without multiplier) to be distributed since last update\n        uint256 accruedBaseAmount = (block.timestamp - currentRewardState.lastUpdate) * baseDropPerSecond;\n\n         // calculate the ratio to add to the index\n        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;\n\n        return currentRewardState.index + ratio;\n    }\n\n    // Update global reward state internal\n    function _updateRewardState() internal returns (uint256){\n        RewardState storage globalRewardState = globalRewards;\n        if(globalRewardState.lastUpdate == block.timestamp) return globalRewardState.index; // Already updated for this block\n\n        // Update (if needed) & get the current DropPerSecond\n        uint256 _currentDropPerSecond = _updateDropPerSecond();\n\n        // Update the index\n        uint256 newIndex = _getNewIndex(_currentDropPerSecond);\n        globalRewardState.index = safe128(newIndex);\n        globalRewardState.lastUpdate = safe128(block.timestamp);\n\n        return newIndex;\n    }\n\n    function _getUserAccruedRewards(\n        address user,\n        RewardState memory userRewardState,\n        uint256 currentRewardsIndex\n    ) internal view returns(\n        uint256 accruedRewards,\n        uint256 newBonusRatio\n    ) {\n        // Find the user last index & current balances\n        uint256 userLastIndex = userRewardState.index;\n        uint256 userStakedBalance = _availableBalanceOf(user);\n        uint256 userLockedBalance;\n\n        if(userLastIndex != currentRewardsIndex){\n\n            if(balanceOf(user) != 0){\n                // calculate the base rewards for the user staked balance\n                // (using avaialable balance to count the locked balance with the multiplier later in this function)\n                uint256 indexDiff = currentRewardsIndex - userLastIndex;\n\n                uint256 lockingRewards;\n\n                if(userLocks[user].length != 0){\n\n                    // and if an user has a lock, calculate the locked rewards\n                    uint256 lastUserLockIndex = userLocks[user].length - 1;\n\n                    // using the locked balance, and the lock duration\n                    userLockedBalance = uint256(userLocks[user][lastUserLockIndex].amount);\n\n                    // Check that the user's Lock is not empty\n                    if(userLockedBalance != 0 && userLocks[user][lastUserLockIndex].duration != 0){\n                        uint256 previousBonusRatio = userCurrentBonusRatio[user];\n\n                        if(previousBonusRatio > 0){\n                            uint256 userRatioDecrease = userBonusRatioDecrease[user];\n                            // Find the new multiplier for user:\n                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update\n                            uint256 bonusRatioDecrease = (block.timestamp - userRewardState.lastUpdate) * userRatioDecrease;\n                            \n                            newBonusRatio = bonusRatioDecrease >= previousBonusRatio ? 0 : previousBonusRatio - bonusRatioDecrease;\n\n                            if(bonusRatioDecrease >= previousBonusRatio){\n                                // Since the last update, bonus ratio decrease under 0\n                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0\n                                bonusRatioDecrease = previousBonusRatio;\n                                // In the case this update is made far after the end of the lock, this method would mean\n                                // the user could get a multiplier for longer than expected\n                                // We count on the Kick logic to avoid that scenario\n                            }\n\n                            // and calculate the locking rewards based on the locked balance & \n                            // a ratio based on the rpevious one and the newly calculated one\n                            uint256 periodBonusRatio = newBonusRatio + ((userRatioDecrease + bonusRatioDecrease) / 2);\n                            lockingRewards = ((userLockedBalance * (indexDiff * periodBonusRatio)) / UNIT) / UNIT;\n                        }\n                    }\n\n                }\n                // calculate the staking rewards\n                // sum it up with locking rewards, and return it\n                accruedRewards = ((userStakedBalance * indexDiff) / UNIT) + lockingRewards;\n            }\n        }\n    }\n\n    // Update user reward state internal\n    function _updateUserRewards(address user) internal {\n        // In emergency mode, do not accrue rewards for users anymore\n        if(emergency) return();\n\n        // Update the global reward state and get the latest index\n        uint256 newIndex = _updateRewardState();\n\n        // Called for minting & burning, but we don't want to update for address 0x0\n        if(user == address(0)) return;\n\n        RewardState storage userRewardState = userRewardStates[user];\n\n        if(userRewardState.lastUpdate == block.timestamp) return; // Already updated for this block\n\n        // Update the user claimable rewards\n        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, userRewardState, newIndex);\n        claimableRewards[user] += accruedRewards;\n        // Store the new Bonus Ratio\n        userCurrentBonusRatio[user] = newBonusRatio;\n        \n        // and set the current timestamp for last update, and the last used index for the user rewards\n        userRewardState.lastUpdate = safe128(block.timestamp);\n        userRewardState.index = safe128(newIndex);\n\n    }\n\n    /** @dev Hook called before any transfer */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if(from != address(0)) { //check must be skipped on minting\n            // Only allow the balance that is unlocked to be transfered\n            if(amount > _availableBalanceOf(from)) revert AvailableBalanceTooLow();\n        }\n\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(from);\n\n        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 \n        \n        if(from != to) {\n            // Update user rewards before any change on their balance (staked and locked)\n            _updateUserRewards(to);\n            // => we don't want a self-transfer to double count new claimable rewards\n            // + no need to update the cooldown on a self-transfer\n\n            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, balanceOf(to));\n\n            // If from transfer all of its balance, reset the cooldown to 0\n            if(balanceOf(from) == amount && fromCooldown != 0) {\n                cooldowns[from] = 0;\n            }\n        }\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        // update delegation for the sender & the receiver if they delegate\n        _moveDelegates(delegates[from], delegates[to], amount);\n    }\n\n    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {\n        if(blockNumber >= block.number) revert InvalidBlockNumber();\n\n        UserLock memory emptyLock = UserLock(\n            0,\n            0,\n            0,\n            0\n        );\n\n        // no checkpoints written\n        uint256 nbCheckpoints = userLocks[account].length;\n        if (nbCheckpoints == 0) return emptyLock;\n\n        // last checkpoint check\n        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {\n            return userLocks[account][nbCheckpoints - 1];\n        }\n\n        // no checkpoint old enough\n        if (userLocks[account][0].fromBlock > blockNumber) {\n            return emptyLock;\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low;\n        uint256 mid;\n        while (low < high) {\n            mid = Math.average(low, high);\n            if (userLocks[account][mid].fromBlock == blockNumber) {\n                return userLocks[account][mid];\n            }\n            if (userLocks[account][mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : userLocks[account][high - 1];\n    }\n\n    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){\n        if(blockNumber >= block.number) revert InvalidBlockNumber();\n\n        // no checkpoints written\n        uint256 nbCheckpoints = checkpoints[account].length;\n        if (nbCheckpoints == 0) return 0;\n\n        // last checkpoint check\n        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nbCheckpoints - 1].votes;\n        }\n\n        // no checkpoint old enough\n        if (checkpoints[account][0].fromBlock > blockNumber) return 0;\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low;\n        uint256 mid;\n        while (low < high) {\n            mid = Math.average(low, high);\n            if (checkpoints[account][mid].fromBlock == blockNumber) {\n                return checkpoints[account][mid].votes;\n            }\n            if (checkpoints[account][mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : checkpoints[account][high - 1].votes;\n    }\n\n    function _moveDelegates(address from, address to, uint256 amount) internal {\n        if (from != to && amount != 0) {\n            if (from != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[from].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes - amount;\n                _writeCheckpoint(from, newVotes);\n                emit DelegateVotesChanged(from, oldVotes, newVotes);\n            }\n\n            if (to != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[to].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes + amount;\n                _writeCheckpoint(to, newVotes);\n                emit DelegateVotesChanged(to, oldVotes, newVotes);\n            }\n        }\n    }\n\n    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {\n        // write a new checkpoint for an user\n        uint pos = checkpoints[delegatee].length;\n\n        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {\n            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);\n        } else {\n            uint32 blockNumber = safe32(block.number);\n            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));\n        }\n    }\n\n    function _writeUserLock(\n        address user,\n        uint256 amount,\n        uint256 startTimestamp,\n        uint256 duration\n    ) internal {\n        uint256 pos = userLocks[user].length;\n        if (pos > 0 && userLocks[user][pos - 1].fromBlock == block.number) {\n            UserLock storage currentUserLock = userLocks[user][pos - 1];\n            currentUserLock.amount = safe128(amount);\n            currentUserLock.duration = safe48(duration);\n            currentUserLock.startTimestamp = safe48(startTimestamp);\n        } else {\n            userLocks[user].push(\n                UserLock(\n                    safe128(amount),\n                    safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                )\n            );\n        }\n    }\n\n    function _writeTotalLocked(uint256 newTotalLocked) internal {\n        uint256 pos = totalLocks.length;\n        if (pos > 0 && totalLocks[pos - 1].fromBlock == block.number) {\n            totalLocks[pos - 1].total = safe224(newTotalLocked);\n        } else {\n            totalLocks.push(TotalLock(\n                safe224(newTotalLocked),\n                safe32(block.number)\n            ));\n        }\n    }\n\n    // -----------------\n\n    function _stake(address user, uint256 amount) internal returns(uint256) {\n        if(amount == 0) revert NullAmount();\n\n        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()\n        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    \n\n        _mint(user, amount); //We mint hPAL 1:1 with PAL\n\n        // Pull the PAL into this contract\n        pal.safeTransferFrom(user, address(this), amount);\n\n        emit Stake(user, amount);\n\n        return amount;\n    }\n\n    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {\n        if(amount == 0) revert NullAmount();\n        if(receiver == address(0)) revert AddressZero();\n\n        // Check if user in inside the allowed period base on its cooldown\n        uint256 userCooldown = cooldowns[user];\n        if(block.timestamp <= (userCooldown + COOLDOWN_PERIOD)) revert InsufficientCooldown();\n        if(block.timestamp - (userCooldown + COOLDOWN_PERIOD) > UNSTAKE_PERIOD) revert UnstakePeriodExpired();\n\n        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()\n\n        // Can only unstake was is available, need to unlock before\n        uint256 userAvailableBalance = _availableBalanceOf(user);\n        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;\n\n        if(burnAmount == 0) revert AvailableBalanceTooLow();\n\n        // Burn the hPAL 1:1 with PAL\n        _burn(user, burnAmount);\n\n        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()\n\n        // Then transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n\n        emit Unstake(user, burnAmount);\n\n        return burnAmount;\n    }\n\n    // Get the new cooldown for an user receiving hPAL (mint or transfer),\n    // based on receiver cooldown and sender cooldown\n    // Inspired by stkAAVE cooldown system\n    function _getNewReceiverCooldown(\n        uint256 senderCooldown,\n        uint256 amount,\n        address receiver,\n        uint256 receiverBalance\n    ) internal view returns(uint256) {\n        uint256 receiverCooldown = cooldowns[receiver];\n\n        // If amount is 0, there is not transfer, no need to change the receiver cooldown\n        if(amount == 0) return receiverCooldown;\n\n        // If receiver has no cooldown, no need to set a new one\n        if(receiverCooldown == 0) return 0;\n\n        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);\n\n        // If last receiver cooldown is expired, set it back to 0\n        if(receiverCooldown < minValidCooldown) return 0;\n\n        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)\n        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;\n\n        // If the sender cooldown is better, we keep the receiver cooldown\n        if(_senderCooldown < receiverCooldown) return receiverCooldown;\n\n        // Default new cooldown, weighted average based on the amount and the previous balance\n        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);\n\n    }\n\n    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }\n\n    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        if(amount == 0) revert NullAmount();\n        uint256 userBalance = balanceOf(user);\n        if(amount > userBalance) revert AmountExceedBalance();\n        if(duration < MIN_LOCK_DURATION) revert DurationUnderMin();\n        if(duration > MAX_LOCK_DURATION) revert DurationOverMax();\n\n        if(userLocks[user].length == 0){\n            //User 1st Lock\n\n            userLocks[user].push(UserLock(\n                safe128(amount),\n                safe48(block.timestamp),\n                safe48(duration),\n                safe32(block.number)\n            ));\n\n            // find the reward multiplier based on the user lock duration\n            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n\n            userCurrentBonusRatio[user] = userLockBonusRatio;\n            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n\n            // Update total locked supply\n            currentTotalLocked += amount;\n            _writeTotalLocked(currentTotalLocked);\n\n            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);\n        } \n        else {\n            // Get the current user Lock\n            UserLock memory currentUserLock = userLocks[user][userLocks[user].length - 1];\n            // Calculate the end of the user current lock\n            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n            uint256 startTimestamp = block.timestamp;\n\n            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { \n                // User locked, and then unlocked\n                // or user lock expired\n\n                _writeUserLock(user, amount, startTimestamp, duration);\n            }\n            else {\n                // Update of the current Lock : increase amount or increase duration\n                // or renew with the same parameters, but starting at the current timestamp\n                if(amount <  currentUserLock.amount) revert SmallerAmount();\n                if(duration <  currentUserLock.duration) revert SmallerDuration();\n\n                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock\n                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;\n                _writeUserLock(user, amount, startTimestamp, duration);\n            }\n\n            // If the duration is updated, re-calculate the multiplier for the Lock\n            if(action != LockAction.INCREASE_AMOUNT){\n                // find the reward multiplier based on the user lock duration\n                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n\n                userCurrentBonusRatio[user] = userLockBonusRatio;\n                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n            }\n            \n            // Update total locked supply\n            if(amount != currentUserLock.amount){\n\n                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;\n                \n                currentTotalLocked += amount;\n                _writeTotalLocked(currentTotalLocked);\n            }\n\n            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);\n        }\n    }\n\n    function _unlock(address user) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        if(userLocks[user].length == 0) revert NoLock();\n\n        // Get the user current Lock\n        // And calculate the end of the Lock\n        UserLock memory currentUserLock = userLocks[user][userLocks[user].length - 1];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n        if(block.timestamp <= userCurrentLockEnd) revert LockNotExpired();\n        if(currentUserLock.amount == 0) revert EmptyLock();\n\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        _writeTotalLocked(currentTotalLocked);\n\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n\n        // Set the user Lock as an empty Lock\n        _writeUserLock(user, 0, block.timestamp, 0);\n\n        emit Unlock(user, currentUserLock.amount, currentTotalLocked);\n    }\n\n    function _kick(address user, address kicker) internal {\n        if(user == address(0) || kicker == address(0)) revert AddressZero();\n        if(userLocks[user].length == 0) revert NoLock();\n\n        // Get the user to kick current Lock\n        // and calculate the end of the Lock\n        UserLock memory currentUserLock = userLocks[user][userLocks[user].length - 1];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n        if(block.timestamp <= userCurrentLockEnd) revert LockNotExpired();\n        if(currentUserLock.amount == 0) revert EmptyLock();\n\n        if(block.timestamp <= userCurrentLockEnd + UNLOCK_DELAY) revert LockNotKickable();\n\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        _writeTotalLocked(currentTotalLocked);\n\n        // Set an empty Lock for the user\n        _writeUserLock(user, 0, block.timestamp, 0);\n\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n\n        // Calculate the penalty for the Lock\n        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;\n        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;\n        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? \n            currentUserLock.amount : \n            (currentUserLock.amount * penaltyPercent) / MAX_BPS;\n\n        // Send penalties to the kicker\n        _transfer(user, kicker, penaltyAmount);\n\n        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        // Move delegation from the old delegate to the given delegate\n        address oldDelegatee = delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator);\n        delegates[delegator] = delegatee;\n\n        // update the the Delegate chekpoint for the delegatee\n        uint pos = delegateCheckpoints[delegator].length;\n\n        if (pos > 0 && delegateCheckpoints[delegator][pos - 1].fromBlock == block.number) {\n            delegateCheckpoints[delegator][pos - 1].delegate = delegatee;\n        } else {\n            delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));\n        }\n\n        emit DelegateChanged(delegator, oldDelegatee, delegatee);\n\n        // and write the checkpoints for Votes\n        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);\n    }\n\n    /**\n     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency\n     * @param amount amount to withdraw\n     * @param receiver address to receive the withdrawn funds\n     * @return uint256 : amount withdrawn\n     */\n    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {\n\n        if(!emergency) revert NotEmergency();\n\n        if(amount == 0) revert NullAmount();\n        if(receiver == address(0)) revert AddressZero();\n\n        if(userLocks[msg.sender].length != 0){\n            // Check if the user has a Lock, and if so, fetch it\n            UserLock storage currentUserLock = userLocks[msg.sender][userLocks[msg.sender].length - 1];\n\n            // No need to remove the last Lock if already empty\n            if(currentUserLock.amount != 0 && currentUserLock.duration > 0){\n                // To remove the Lock and update the total locked\n                currentTotalLocked -= currentUserLock.amount;\n                totalLocks.push(TotalLock(\n                    safe224(currentTotalLocked),\n                    safe32(block.number)\n                ));\n\n                userLocks[msg.sender].push(UserLock(\n                    safe128(0),\n                    safe48(block.timestamp),\n                    safe48(0),\n                    safe32(block.number)\n                    ));\n\n                // Remove the bonus multiplier\n                userCurrentBonusRatio[msg.sender] = 0;\n                userBonusRatioDecrease[msg.sender] = 0;\n            }\n        }\n\n        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger\n        uint256 userAvailableBalance = balanceOf(msg.sender);\n        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;\n\n        _burn(msg.sender, burnAmount);\n\n        // Transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n\n        emit EmergencyUnstake(msg.sender, burnAmount);\n\n        return burnAmount;\n\n    }\n\n    // Utils\n\n    error Exceed224Bits(); \n    error Exceed128Bits(); \n    error Exceed48Bits(); \n    error Exceed32Bits(); \n\n    function safe32(uint n) internal pure returns (uint32) {\n        if(n > type(uint32).max) revert Exceed32Bits();\n        return uint32(n);\n    }\n\n    function safe48(uint n) internal pure returns (uint48) {\n        if(n > type(uint48).max) revert Exceed48Bits();\n        return uint48(n);\n    }\n\n    function safe128(uint n) internal pure returns (uint128) {\n        if(n > type(uint128).max) revert Exceed128Bits();\n        return uint128(n);\n    }\n\n    function safe224(uint n) internal pure returns (uint224) {\n        if(n > type(uint224).max) revert Exceed224Bits();\n        return uint224(n);\n    }\n\n    // Admin methods\n\n    error IncorrectParameters();\n    error DecreaseDurationNotOver();\n\n    /**\n     * @notice Updates the ratio of penalty applied for each week after boost expiry\n     * @param newKickRatioPerWeek new kick ratio (in BPS)\n     */\n    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {\n        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();\n        kickRatioPerWeek = newKickRatioPerWeek;\n    }\n\n    /**\n     * @notice Triggers the emergency mode on the smart contract (admin method)\n     * @param trigger True to set the emergency mode\n     */\n    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {\n        emergency = trigger;\n    }\n\n    /**\n     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)\n     * @param newEndDropPerSecond new amount of PAL to distribute per second\n     */\n    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {\n        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();\n        endDropPerSecond = newEndDropPerSecond;\n    }\n\n\n    function commitSmartWalletChecker(address newSmartWalletChecker) external onlyOwner {\n        futureSmartWalletChecker = newSmartWalletChecker;\n    }\n\n\n    function applySmartWalletChecker() external onlyOwner {\n        smartWalletChecker = futureSmartWalletChecker;\n    }\n}"
6     },
7     "contracts/open-zeppelin/ERC20.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IERC20Metadata.sol\";\nimport \"./utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}"
9     },
10     "contracts/open-zeppelin/interfaces/IERC20.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
12     },
13     "contracts/open-zeppelin/libraries/SafeERC20.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"
15     },
16     "contracts/open-zeppelin/utils/Math.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}"
18     },
19     "contracts/utils/Owner.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"../open-zeppelin/utils/Ownable.sol\";\n\n/** @title Extend OZ Ownable contract  */\n/// @author Paladin\n\ncontract Owner is Ownable {\n\n    address public pendingOwner;\n\n    event NewPendingOwner(address indexed previousPendingOwner, address indexed newPendingOwner);\n\n    error CannotBeOwner();\n    error CallerNotPendingOwner();\n    error ZeroAddress();\n\n    function transferOwnership(address newOwner) public override virtual onlyOwner {\n        if(newOwner == address(0)) revert ZeroAddress();\n        if(newOwner == owner()) revert CannotBeOwner();\n        address oldPendingOwner = pendingOwner;\n\n        pendingOwner = newOwner;\n\n        emit NewPendingOwner(oldPendingOwner, newOwner);\n    }\n\n    function acceptOwnership() public virtual {\n        if(pendingOwner == address(0)) revert ZeroAddress();\n        if(msg.sender != pendingOwner) revert CallerNotPendingOwner();\n        address newOwner = pendingOwner;\n        _transferOwnership(pendingOwner);\n        pendingOwner = address(0);\n\n        emit NewPendingOwner(newOwner, address(0));\n    }\n\n}"
21     },
22     "contracts/utils/SmartWalletChecker.sol": {
23       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n\n/// @notice Interface of the `SmartWalletChecker` contracts of the protocol\ninterface SmartWalletChecker {\n    function check(address) external view returns (bool);\n}"
24     },
25     "contracts/open-zeppelin/interfaces/IERC20Metadata.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}"
27     },
28     "contracts/open-zeppelin/utils/Context.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"
30     },
31     "contracts/open-zeppelin/utils/Address.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}"
33     },
34     "contracts/open-zeppelin/utils/Ownable.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"
36     }
37   },
38   "settings": {
39     "optimizer": {
40       "enabled": true,
41       "runs": 200
42     },
43     "outputSelection": {
44       "*": {
45         "*": [
46           "evm.bytecode",
47           "evm.deployedBytecode",
48           "devdoc",
49           "userdoc",
50           "metadata",
51           "abi"
52         ]
53       }
54     },
55     "libraries": {}
56   }
57 }}