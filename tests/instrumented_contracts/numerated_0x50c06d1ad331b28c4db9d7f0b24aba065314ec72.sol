1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/presale-pool/PreSalePool.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"../libraries/TransferHelper.sol\";\nimport \"../libraries/Ownable.sol\";\nimport \"../libraries/ReentrancyGuard.sol\";\nimport \"../libraries/SafeMath.sol\";\nimport \"../libraries/Pausable.sol\";\nimport \"../extensions/RedKiteWhitelist.sol\";\n\ncontract PreSalePool is Ownable, ReentrancyGuard, Pausable, RedKiteWhitelist {\n    using SafeMath for uint256;\n\n    struct OfferedCurrency {\n        uint256 decimals;\n        uint256 rate;\n    }\n\n    // The token being sold\n    IERC20 public token;\n\n    // The address of factory contract\n    address public factory;\n\n    // The address of signer account\n    address public signer;\n\n    // Address where funds are collected\n    address public fundingWallet;\n\n    // Timestamps when token started to sell\n    uint256 public openTime = block.timestamp;\n\n    // Timestamps when token stopped to sell\n    uint256 public closeTime;\n\n    // Amount of wei raised\n    uint256 public weiRaised = 0;\n\n    // Amount of token sold\n    uint256 public tokenSold = 0;\n\n    // Amount of token sold\n    uint256 public totalUnclaimed = 0;\n\n    // Number of token user purchased\n    mapping(address => uint256) public userPurchased;\n\n    // Number of token user claimed\n    mapping(address => uint256) public userClaimed;\n\n    // Number of token user purchased\n    mapping(address => mapping (address => uint)) public investedAmountOf;\n\n    // Get offered currencies\n    mapping(address => OfferedCurrency) public offeredCurrencies;\n\n    // Pool extensions\n    bool public useWhitelist = true;\n\n    // -----------------------------------------\n    // Lauchpad Starter's event\n    // -----------------------------------------\n    event PresalePoolCreated(\n        address token,\n        uint256 openTime,\n        uint256 closeTime,\n        address offeredCurrency,\n        uint256 offeredCurrencyDecimals,\n        uint256 offeredCurrencyRate,\n        address wallet,\n        address owner\n    );\n    event TokenPurchaseByEther(\n        address indexed purchaser,\n        address indexed beneficiary,\n        uint256 value,\n        uint256 amount\n    );\n    event TokenPurchaseByToken(\n        address indexed purchaser,\n        address indexed beneficiary,\n        address token,\n        uint256 value,\n        uint256 amount\n    );\n\n    event TokenClaimed(address user, uint256 amount);\n    event RefundedIcoToken(address wallet, uint256 amount);\n    event PoolStatsChanged();\n\n    // -----------------------------------------\n    // Constructor\n    // -----------------------------------------\n    constructor() {\n        factory = msg.sender;\n    }\n\n    // -----------------------------------------\n    // Red Kite external interface\n    // -----------------------------------------\n\n    /**\n     * @dev fallback function\n     */\n    fallback() external {\n        revert();\n    }\n\n    /**\n     * @dev fallback function\n     */\n    receive() external payable {\n        revert();\n    }\n\n    /**\n     * @param _token Address of the token being sold\n     * @param _duration Duration of ICO Pool\n     * @param _openTime When ICO Started\n     * @param _offeredCurrency Address of offered token\n     * @param _offeredCurrencyDecimals Decimals of offered token\n     * @param _offeredRate Number of currency token units a buyer gets\n     * @param _wallet Address where collected funds will be forwarded to\n     * @param _signer Address where collected funds will be forwarded to\n     */\n    function initialize(\n        address _token,\n        uint256 _duration,\n        uint256 _openTime,\n        address _offeredCurrency,\n        uint256 _offeredRate,\n        uint256 _offeredCurrencyDecimals,\n        address _wallet,\n        address _signer\n    ) external {\n        require(msg.sender == factory, \"POOL::UNAUTHORIZED\");\n\n        token = IERC20(_token);\n        openTime = _openTime;\n        closeTime = _openTime.add(_duration);\n        fundingWallet = _wallet;\n        owner = tx.origin;\n        paused = false;\n        signer = _signer;\n\n        offeredCurrencies[_offeredCurrency] = OfferedCurrency({\n            rate: _offeredRate,\n            decimals: _offeredCurrencyDecimals\n        });\n\n        emit PresalePoolCreated(\n            _token,\n            _openTime,\n            closeTime,\n            _offeredCurrency,\n            _offeredCurrencyDecimals,\n            _offeredRate,\n            _wallet,\n            owner\n        );\n    }\n\n    /**\n     * @notice Returns the conversion rate when user buy by offered token\n     * @return Returns only a fixed number of rate.\n     */\n    function getOfferedCurrencyRate(address _token) public view returns (uint256) {\n        return offeredCurrencies[_token].rate;\n    }\n\n    /**\n     * @notice Returns the conversion rate decimals when user buy by offered token\n     * @return Returns only a fixed number of decimals.\n     */\n    function getOfferedCurrencyDecimals(address _token) public view returns (uint256) {\n        return offeredCurrencies[_token].decimals;\n    }\n\n    /**\n     * @notice Return the available tokens for purchase\n     * @return availableTokens Number of total available\n     */\n    function getAvailableTokensForSale() public view returns (uint256 availableTokens) {\n        return token.balanceOf(address(this)).sub(totalUnclaimed);\n    }\n\n    /**\n     * @notice Owner can set the offered token conversion rate. Receiver tokens = tradeTokens * tokenRate / 10 ** etherConversionRateDecimals\n     * @param _rate Fixed number of ether rate\n     * @param _decimals Fixed number of ether rate decimals\n     */\n    function setOfferedCurrencyRateAndDecimals(address _token, uint256 _rate, uint256 _decimals)\n        external\n        onlyOwner\n    {\n        offeredCurrencies[_token].rate = _rate;\n        offeredCurrencies[_token].decimals = _decimals;\n        emit PoolStatsChanged();\n    }\n\n    /**\n     * @notice Owner can set the offered token conversion rate. Receiver tokens = tradeTokens * tokenRate / 10 ** etherConversionRateDecimals\n     * @param _rate Fixed number of rate\n     */\n    function setOfferedCurrencyRate(address _token, uint256 _rate) external onlyOwner {\n        require(offeredCurrencies[_token].rate != _rate, \"POOL::RATE_INVALID\");\n        offeredCurrencies[_token].rate = _rate;\n        emit PoolStatsChanged();\n    }\n\n    /**\n     * @notice Owner can set the offered token conversion rate. Receiver tokens = tradeTokens * tokenRate / 10 ** etherConversionRateDecimals\n     * @param _newSigner Address of new signer\n     */\n    function setNewSigner(address _newSigner) external onlyOwner {\n        require(signer != _newSigner, \"POOL::SIGNER_INVALID\");\n        signer = _newSigner;\n    }\n\n    /**\n     * @notice Owner can set the offered token conversion rate. Receiver tokens = tradeTokens * tokenRate / 10 ** etherConversionRateDecimals\n     * @param _decimals Fixed number of decimals\n     */\n    function setOfferedCurrencyDecimals(address _token, uint256 _decimals) external onlyOwner {\n        require(offeredCurrencies[_token].decimals != _decimals, \"POOL::RATE_INVALID\");\n        offeredCurrencies[_token].decimals = _decimals;\n        emit PoolStatsChanged();\n    }\n\n    /**\n     * @notice Owner can set the close time (time in seconds). User can buy before close time.\n     * @param _closeTime Value in uint256 determine when we stop user to by tokens\n     */\n    function setCloseTime(uint256 _closeTime) external onlyOwner() {\n        require(_closeTime >= block.timestamp, \"POOL::INVALID_TIME\");\n        closeTime = _closeTime;\n        emit PoolStatsChanged();\n    }\n\n    /**\n     * @notice Owner can set the open time (time in seconds). User can buy after open time.\n     * @param _openTime Value in uint256 determine when we allow user to by tokens\n     */\n    function setOpenTime(uint256 _openTime) external onlyOwner() {\n        openTime = _openTime;\n        emit PoolStatsChanged();\n    }\n\n    /**\n     * @notice Owner can set extentions.\n     * @param _whitelist Value in bool. True if using whitelist\n     */\n    function setPoolExtentions(bool _whitelist) external onlyOwner() {\n        useWhitelist = _whitelist;\n        emit PoolStatsChanged();\n    }\n\n    function buyTokenByEtherWithPermission(\n        address _beneficiary,\n        address _candidate,\n        uint256 _maxAmount,\n        uint256 _minAmount,\n        bytes memory _signature\n    ) public payable whenNotPaused nonReentrant {\n        uint256 weiAmount = msg.value;\n\n        require(offeredCurrencies[address(0)].rate != 0, \"POOL::PURCHASE_METHOD_NOT_ALLOWED\");\n\n        _preValidatePurchase(_beneficiary, weiAmount);\n\n        require(_validPurchase(), \"POOL::ENDED\");\n        require(_verifyWhitelist(_candidate, _maxAmount, _minAmount, _signature), \"POOL:INVALID_SIGNATURE\");\n\n        // calculate token amount to be created\n        uint256 tokens = _getOfferedCurrencyToTokenAmount(address(0), weiAmount);\n        require(getAvailableTokensForSale() >= tokens, \"POOL::NOT_ENOUGHT_TOKENS_FOR_SALE\");\n        require(tokens >= _minAmount || userPurchased[_candidate].add(tokens) >= _minAmount, \"POOL::MIN_AMOUNT_UNREACHED\");\n        require(userPurchased[_candidate].add(tokens) <= _maxAmount, \"POOL::PURCHASE_AMOUNT_EXCEED_ALLOWANCE\");\n\n        _forwardFunds(weiAmount);\n\n        _updatePurchasingState(weiAmount, tokens);\n\n        investedAmountOf[address(0)][_candidate] = investedAmountOf[address(0)][_candidate].add(weiAmount);\n\n        emit TokenPurchaseByEther(msg.sender, _beneficiary, weiAmount, tokens);\n    }\n\n    function buyTokenByTokenWithPermission(\n        address _beneficiary,\n        address _token,\n        uint256 _amount,\n        address _candidate,\n        uint256 _maxAmount,\n        uint256 _minAmount,\n        bytes memory _signature\n    ) public whenNotPaused nonReentrant {\n        require(offeredCurrencies[_token].rate != 0, \"POOL::PURCHASE_METHOD_NOT_ALLOWED\");\n        require(_validPurchase(), \"POOL::ENDED\");\n        require(_verifyWhitelist(_candidate, _maxAmount, _minAmount, _signature), \"POOL:INVALID_SIGNATURE\");\n\n        _preValidatePurchase(_beneficiary, _amount);\n\n        uint256 tokens = _getOfferedCurrencyToTokenAmount(_token, _amount);\n        require(getAvailableTokensForSale() >= tokens, \"POOL::NOT_ENOUGHT_TOKENS_FOR_SALE\");\n        require(tokens >= _minAmount || userPurchased[_candidate].add(tokens) >= _minAmount, \"POOL::MIN_AMOUNT_UNREACHED\");\n        require(userPurchased[_candidate].add(tokens) <= _maxAmount, \"POOL:PURCHASE_AMOUNT_EXCEED_ALLOWANCE\");\n\n        _forwardTokenFunds(_token, _amount);\n\n        _updatePurchasingState(_amount, tokens);\n\n        investedAmountOf[_token][_candidate] = investedAmountOf[address(0)][_candidate].add(_amount);\n\n        emit TokenPurchaseByToken(\n            msg.sender,\n            _beneficiary,\n            _token,\n            _amount,\n            tokens\n        );\n    }\n\n    /**\n     * @notice Return true if pool has ended\n     * @dev User cannot purchase / trade tokens when isFinalized == true\n     * @return true if the ICO Ended.\n     */\n    function isFinalized() public view returns (bool) {\n        return block.timestamp >= closeTime;\n    }\n\n    /**\n     * @notice Owner can receive their remaining tokens when ICO Ended\n     * @dev  Can refund remainning token if the ico ended\n     * @param _wallet Address wallet who receive the remainning tokens when Ico end\n     */\n    function refundRemainingTokens(address _wallet)\n        external\n        onlyOwner\n    {\n        require(isFinalized(), \"POOL::ICO_NOT_ENDED\");\n        require(token.balanceOf(address(this)) > 0, \"POOL::EMPTY_BALANCE\");\n\n        uint256 remainingTokens = getAvailableTokensForSale();\n        _deliverTokens(_wallet, remainingTokens);\n        emit RefundedIcoToken(_wallet, remainingTokens);\n    }\n\n    /**\n     * @notice User can receive their tokens when pool finished\n     */\n    function claimTokens(address _candidate, uint256 _amount, bytes memory _signature) nonReentrant public {\n        require(_verifyClaimToken(_candidate, _amount, _signature), \"POOL::NOT_ALLOW_TO_CLAIM\");\n        require(isFinalized(), \"POOL::NOT_FINALIZED\");\n        require(_amount >= userClaimed[_candidate], \"POOL::AMOUNT_MUST_GREATER_THAN_CLAIMED\");\n\n        uint256 maxClaimAmount = userPurchased[_candidate].sub(userClaimed[_candidate]);\n\n        uint claimAmount = _amount.sub(userClaimed[_candidate]);\n\n        if (claimAmount > maxClaimAmount) {\n            claimAmount = maxClaimAmount;\n        }\n\n        userClaimed[_candidate] = userClaimed[_candidate].add(claimAmount);\n\n        _deliverTokens(msg.sender, claimAmount);\n\n        totalUnclaimed = totalUnclaimed.sub(claimAmount);\n\n        emit TokenClaimed(msg.sender, claimAmount);\n    }\n\n    /**\n     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\n     * @param _beneficiary Address performing the token purchase\n     * @param _weiAmount Value in wei involved in the purchase\n     */\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount)\n        internal\n        pure\n    {\n        require(_beneficiary != address(0), \"POOL::INVALID_BENEFICIARY\");\n        require(_weiAmount != 0, \"POOL::INVALID_WEI_AMOUNT\");\n    }\n\n    /**\n     * @dev Override to extend the way in which ether is converted to tokens.\n     * @param _amount Value in wei to be converted into tokens\n     * @return Number of tokens that can be purchased with the specified _weiAmount\n     */\n    function _getOfferedCurrencyToTokenAmount(address _token, uint256 _amount)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 rate = getOfferedCurrencyRate(_token);\n        uint256 decimals = getOfferedCurrencyDecimals(_token);\n        return _amount.mul(rate).div(10**decimals);\n    }\n\n    /**\n     * @dev Source of tokens. Transfer / mint\n     * @param _beneficiary Address performing the token purchase\n     * @param _tokenAmount Number of tokens to be emitted\n     */\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount)\n        internal\n    {\n        token.transfer(_beneficiary, _tokenAmount);\n    }\n\n    /**\n     * @dev Determines how ETH is stored/forwarded on purchases.\n     */\n    function _forwardFunds(uint256 _value) internal {\n        address payable wallet = address(uint160(fundingWallet));\n        (bool success, ) = wallet.call{value: _value}(\"\");\n        require(success, \"POOL::WALLET_TRANSFER_FAILED\");\n    }\n\n    /**\n     * @dev Determines how Token is stored/forwarded on purchases.\n     */\n    function _forwardTokenFunds(address _token, uint256 _amount) internal {\n        TransferHelper.safeTransferFrom(_token, msg.sender, fundingWallet, _amount);\n    }\n\n    /**\n     * @param _tokens Value of sold tokens\n     * @param _weiAmount Value in wei involved in the purchase\n     */\n    function _updatePurchasingState(uint256 _weiAmount, uint256 _tokens)\n        internal\n    {\n        weiRaised = weiRaised.add(_weiAmount);\n        tokenSold = tokenSold.add(_tokens);\n        userPurchased[msg.sender] = userPurchased[msg.sender].add(_tokens);\n        totalUnclaimed = totalUnclaimed.add(_tokens);\n    }\n\n    // @return true if the transaction can buy tokens\n    function _validPurchase() internal view returns (bool) {\n        bool withinPeriod =\n            block.timestamp >= openTime && block.timestamp <= closeTime;\n        return withinPeriod;\n    }\n\n    /**\n     * @dev Transfer eth to an address\n     * @param _to Address receiving the eth\n     * @param _amount Amount of wei to transfer\n     */\n    function _transfer(address _to, uint256 _amount) private {\n        address payable payableAddress = address(uint160(_to));\n        (bool success, ) = payableAddress.call{value: _amount}(\"\");\n        require(success, \"POOL::TRANSFER_FEE_FAILED\");\n    }\n\n    /**\n     * @dev Verify permission of purchase\n     * @param _candidate Address of buyer\n     * @param _maxAmount max token can buy\n     * @param _minAmount min token can buy\n     * @param _signature Signature of signers\n     */\n    function _verifyWhitelist(\n        address _candidate,\n        uint256 _maxAmount,\n        uint256 _minAmount,\n        bytes memory _signature\n    ) private view returns (bool) {\n        require(msg.sender == _candidate, \"POOL::WRONG_CANDIDATE\");\n\n        if (useWhitelist) {\n            return (verify(signer, _candidate, _maxAmount, _minAmount, _signature));\n        }\n        return true;\n    }\n\n    /**\n     * @dev Verify permission of purchase\n     * @param _candidate Address of buyer\n     * @param _amount claimable amount\n     * @param _signature Signature of signers\n     */\n    function _verifyClaimToken(\n        address _candidate,\n        uint256 _amount,\n        bytes memory _signature\n    ) private view returns (bool) {\n        require(msg.sender == _candidate, \"POOL::WRONG_CANDIDATE\");\n\n        return (verifyClaimToken(signer, _candidate, _amount, _signature));\n    }\n}\n"
6     },
7     "contracts/interfaces/IERC20.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
9     },
10     "contracts/interfaces/IPoolFactory.sol": {
11       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.1;\n\ninterface IPoolFactory {\n    function getTier() external view returns (address);\n}\n"
12     },
13     "contracts/libraries/TransferHelper.sol": {
14       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n}"
15     },
16     "contracts/libraries/Ownable.sol": {
17       "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n"
18     },
19     "contracts/libraries/ReentrancyGuard.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
21     },
22     "contracts/libraries/SafeMath.sol": {
23       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
24     },
25     "contracts/libraries/Pausable.sol": {
26       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.1;\n\n\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused, \"CONTRACT_PAUSED\");\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused, \"CONTRACT_NOT_PAUSED\");\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}"
27     },
28     "contracts/extensions/RedKiteWhitelist.sol": {
29       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\n\n// Signature Verification\n/// @title RedKite Whitelists - Implement off-chain whitelist and on-chain verification\n/// @author Thang Nguyen Quy <thang.nguyen5@sotatek.com>\n\ncontract RedKiteWhitelist {\n    // Using Openzeppelin ECDSA cryptography library\n    function getMessageHash(\n        address _candidate,\n        uint256 _maxAmount,\n        uint256 _minAmount\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_candidate, _maxAmount, _minAmount));\n    }\n\n    function getClaimMessageHash(\n        address _candidate,\n        uint256 _amount\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_candidate, _amount));\n    }\n\n    // Verify signature function\n    function verify(\n        address _signer,\n        address _candidate,\n        uint256 _maxAmount,\n        uint256 _minAmount,\n        bytes memory signature\n    ) public pure returns (bool) {\n        bytes32 messageHash = getMessageHash(_candidate, _maxAmount, _minAmount);\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\n\n        return getSignerAddress(ethSignedMessageHash, signature) == _signer;\n    }\n\n    // Verify signature function\n    function verifyClaimToken(\n        address _signer,\n        address _candidate,\n        uint256 _amount,\n        bytes memory signature\n    ) public pure returns (bool) {\n        bytes32 messageHash = getClaimMessageHash(_candidate, _amount);\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\n\n        return getSignerAddress(ethSignedMessageHash, signature) == _signer;\n    }\n\n    function getSignerAddress(bytes32 _messageHash, bytes memory _signature) public pure returns(address signer) {\n        return ECDSA.recover(_messageHash, _signature);\n    }\n\n    // Split signature to r, s, v\n    function splitSignature(bytes memory _signature)\n        public\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        require(_signature.length == 65, \"invalid signature length\");\n\n        assembly {\n            r := mload(add(_signature, 32))\n            s := mload(add(_signature, 64))\n            v := byte(0, mload(add(_signature, 96)))\n        }\n    }\n\n    function getEthSignedMessageHash(bytes32 _messageHash)\n        public\n        pure\n        returns (bytes32)\n    {\n        return ECDSA.toEthSignedMessageHash(_messageHash);\n    }\n}\n"
30     },
31     "openzeppelin-solidity/contracts/cryptography/ECDSA.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
33     }
34   },
35   "settings": {
36     "optimizer": {
37       "enabled": true,
38       "runs": 1000
39     },
40     "outputSelection": {
41       "*": {
42         "*": [
43           "evm.bytecode",
44           "evm.deployedBytecode",
45           "abi"
46         ]
47       }
48     },
49     "libraries": {}
50   }
51 }}