1 {{
2   "language": "Solidity",
3   "sources": {
4     "@openzeppelin/contracts/access/Ownable.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
6     },
7     "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
9     },
10     "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Snapshot.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Arrays.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\n * total supply at the time are recorded for later access.\n *\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\n * In naive implementations it's possible to perform a \"double spend\" attack by reusing the same balance from different\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\n * used to create an efficient ERC20 forking mechanism.\n *\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\n * and the account address.\n *\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\n * return `block.number` will trigger the creation of snapshot at the begining of each new block. When overridding this\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\n *\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\n * alternative consider {ERC20Votes}.\n *\n * ==== Gas Costs\n *\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\n *\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\n * transfers will have normal cost until the next snapshot, and so on.\n */\n\nabstract contract ERC20Snapshot is ERC20 {\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\n    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\n\n    using Arrays for uint256[];\n    using Counters for Counters.Counter;\n\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\n    // Snapshot struct, but that would impede usage of functions that work on an array.\n    struct Snapshots {\n        uint256[] ids;\n        uint256[] values;\n    }\n\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\n    Snapshots private _totalSupplySnapshots;\n\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\n    Counters.Counter private _currentSnapshotId;\n\n    /**\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\n     */\n    event Snapshot(uint256 id);\n\n    /**\n     * @dev Creates a new snapshot and returns its snapshot id.\n     *\n     * Emits a {Snapshot} event that contains the same id.\n     *\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\n     *\n     * [WARNING]\n     * ====\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\n     * you must consider that it can potentially be used by attackers in two ways.\n     *\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\n     * section above.\n     *\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\n     * ====\n     */\n    function _snapshot() internal virtual returns (uint256) {\n        _currentSnapshotId.increment();\n\n        uint256 currentId = _getCurrentSnapshotId();\n        emit Snapshot(currentId);\n        return currentId;\n    }\n\n    /**\n     * @dev Get the current snapshotId\n     */\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\n        return _currentSnapshotId.current();\n    }\n\n    /**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\n\n        return snapshotted ? value : balanceOf(account);\n    }\n\n    /**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\n\n        return snapshotted ? value : totalSupply();\n    }\n\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from == address(0)) {\n            // mint\n            _updateAccountSnapshot(to);\n            _updateTotalSupplySnapshot();\n        } else if (to == address(0)) {\n            // burn\n            _updateAccountSnapshot(from);\n            _updateTotalSupplySnapshot();\n        } else {\n            // transfer\n            _updateAccountSnapshot(from);\n            _updateAccountSnapshot(to);\n        }\n    }\n\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\n        require(snapshotId > 0, \"ERC20Snapshot: id is 0\");\n        require(snapshotId <= _getCurrentSnapshotId(), \"ERC20Snapshot: nonexistent id\");\n\n        // When a valid snapshot is queried, there are three possibilities:\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\n        //  to this id is the current one.\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\n        //  requested id, and its value is the one to return.\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\n        //  larger than the requested one.\n        //\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\n        // exactly this.\n\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\n\n        if (index == snapshots.ids.length) {\n            return (false, 0);\n        } else {\n            return (true, snapshots.values[index]);\n        }\n    }\n\n    function _updateAccountSnapshot(address account) private {\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\n    }\n\n    function _updateTotalSupplySnapshot() private {\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\n    }\n\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\n        uint256 currentId = _getCurrentSnapshotId();\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\n            snapshots.ids.push(currentId);\n            snapshots.values.push(currentValue);\n        }\n    }\n\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\n        if (ids.length == 0) {\n            return 0;\n        } else {\n            return ids[ids.length - 1];\n        }\n    }\n}\n"
12     },
13     "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
15     },
16     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
18     },
19     "@openzeppelin/contracts/utils/Arrays.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Arrays.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (array[mid] > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && array[low - 1] == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n}\n"
21     },
22     "@openzeppelin/contracts/utils/Context.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
24     },
25     "@openzeppelin/contracts/utils/Counters.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
27     },
28     "@openzeppelin/contracts/utils/math/Math.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
30     },
31     "@openzeppelin/contracts/utils/math/SafeCast.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
33     },
34     "@openzeppelin/contracts/utils/math/SafeMath.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
36     },
37     "@openzeppelin/contracts/utils/math/SignedSafeMath.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
39     },
40     "contracts/common/implementation/ExpandedERC20.sol": {
41       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./MultiRole.sol\";\nimport \"../interfaces/ExpandedIERC20.sol\";\n\n/**\n * @title An ERC20 with permissioned burning and minting. The contract deployer will initially\n * be the owner who is capable of adding new roles.\n */\ncontract ExpandedERC20 is ExpandedIERC20, ERC20, MultiRole {\n    enum Roles {\n        // Can set the minter and burner.\n        Owner,\n        // Addresses that can mint new tokens.\n        Minter,\n        // Addresses that can burn tokens that address owns.\n        Burner\n    }\n\n    uint8 _decimals;\n\n    /**\n     * @notice Constructs the ExpandedERC20.\n     * @param _tokenName The name which describes the new token.\n     * @param _tokenSymbol The ticker abbreviation of the name. Ideally < 5 chars.\n     * @param _tokenDecimals The number of decimals to define token precision.\n     */\n    constructor(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        uint8 _tokenDecimals\n    ) ERC20(_tokenName, _tokenSymbol) {\n        _decimals = _tokenDecimals;\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\n        _createSharedRole(uint256(Roles.Minter), uint256(Roles.Owner), new address[](0));\n        _createSharedRole(uint256(Roles.Burner), uint256(Roles.Owner), new address[](0));\n    }\n\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Mints `value` tokens to `recipient`, returning true on success.\n     * @param recipient address to mint to.\n     * @param value amount of tokens to mint.\n     * @return True if the mint succeeded, or False.\n     */\n    function mint(address recipient, uint256 value)\n        external\n        override\n        onlyRoleHolder(uint256(Roles.Minter))\n        returns (bool)\n    {\n        _mint(recipient, value);\n        return true;\n    }\n\n    /**\n     * @dev Burns `value` tokens owned by `msg.sender`.\n     * @param value amount of tokens to burn.\n     */\n    function burn(uint256 value) external override onlyRoleHolder(uint256(Roles.Burner)) {\n        _burn(msg.sender, value);\n    }\n\n    /**\n     * @dev Burns `value` tokens owned by `recipient`.\n     * @param recipient address to burn tokens from.\n     * @param value amount of tokens to burn.\n     * @return True if the burn succeeded, or False.\n     */\n    function burnFrom(address recipient, uint256 value)\n        external\n        override\n        onlyRoleHolder(uint256(Roles.Burner))\n        returns (bool)\n    {\n        _burn(recipient, value);\n        return true;\n    }\n\n    /**\n     * @notice Add Minter role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The address to which the Minter role is added.\n     */\n    function addMinter(address account) external virtual override {\n        addMember(uint256(Roles.Minter), account);\n    }\n\n    /**\n     * @notice Add Burner role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The address to which the Burner role is added.\n     */\n    function addBurner(address account) external virtual override {\n        addMember(uint256(Roles.Burner), account);\n    }\n\n    /**\n     * @notice Reset Owner role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The new holder of the Owner role.\n     */\n    function resetOwner(address account) external virtual override {\n        resetMember(uint256(Roles.Owner), account);\n    }\n}\n"
42     },
43     "contracts/common/implementation/FixedPoint.sol": {
44       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\n/**\n * @title Library for fixed point arithmetic on uints\n */\nlibrary FixedPoint {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For unsigned values:\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\n    uint256 private constant FP_SCALING_FACTOR = 10**18;\n\n    // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\n    struct Unsigned {\n        uint256 rawValue;\n    }\n\n    /**\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.\n     * @param a uint to convert into a FixedPoint.\n     * @return the converted FixedPoint.\n     */\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return add(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return sub(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return sub(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as a uint256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\n        if (mod != 0) {\n            return Unsigned(mulFloor.add(1));\n        } else {\n            return Unsigned(mulFloor);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Since b is an uint, there is no risk of truncation and we can just mul it normally\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as a uint256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a uint256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return div(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\n        uint256 divFloor = aScaled.div(b.rawValue);\n        uint256 mod = aScaled.mod(b.rawValue);\n        if (mod != 0) {\n            return Unsigned(divFloor.add(1));\n        } else {\n            return Unsigned(divFloor);\n        }\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Unsigned(a.rawValue.div(b))\"\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\n        // This creates the possibility of overflow if b is very large.\n        return divCeil(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\n        output = fromUnscaledUint(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n\n    // ------------------------------------------------- SIGNED -------------------------------------------------------------\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For signed values:\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\n    int256 private constant SFP_SCALING_FACTOR = 10**18;\n\n    struct Signed {\n        int256 rawValue;\n    }\n\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\n        require(a.rawValue >= 0, \"Negative value provided\");\n        return Unsigned(uint256(a.rawValue));\n    }\n\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\n        require(a.rawValue <= uint256(type(int256).max), \"Unsigned too large\");\n        return Signed(int256(a.rawValue));\n    }\n\n    /**\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.\n     * @param a int to convert into a FixedPoint.Signed.\n     * @return the converted FixedPoint.Signed.\n     */\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\n        return Signed(a.mul(SFP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a int256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return add(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return sub(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return sub(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as an int256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(mulTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(mulTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as an int256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a an int256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return div(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\n        int256 divTowardsZero = aScaled.div(b.rawValue);\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = aScaled % b.rawValue;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(divTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(divTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Signed(a.rawValue.div(b))\"\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\n        // This creates the possibility of overflow if b is very large.\n        return divAwayFromZero(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint.Signed.\n     * @param b a uint256 (negative exponents are not allowed).\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\n        output = fromUnscaledInt(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n}\n"
45     },
46     "contracts/common/implementation/Lockable.sol": {
47       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\n */\ncontract Lockable {\n    bool private _notEntered;\n\n    constructor() {\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\n        // refund coming into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant` function is not supported. It is possible to\n     * prevent this from happening by making the `nonReentrant` function external, and making it call a `private`\n     * function that does the actual state modification.\n     */\n    modifier nonReentrant() {\n        _preEntranceCheck();\n        _preEntranceSet();\n        _;\n        _postEntranceReset();\n    }\n\n    /**\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\n     */\n    modifier nonReentrantView() {\n        _preEntranceCheck();\n        _;\n    }\n\n    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\n    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being\n    // re-entered. Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and\n    // then call `_postEntranceReset()`.\n    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\n    function _preEntranceCheck() internal view {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n    }\n\n    function _preEntranceSet() internal {\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n    }\n\n    function _postEntranceReset() internal {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n\n    // These functions are intended to be used by child contracts to temporarily disable and re-enable the guard.\n    // Intended use:\n    // _startReentrantGuardDisabled();\n    // ...\n    // _endReentrantGuardDisabled();\n    //\n    // IMPORTANT: these should NEVER be used in a method that isn't inside a nonReentrant block. Otherwise, it's\n    // possible to permanently lock your contract.\n    function _startReentrantGuardDisabled() internal {\n        _notEntered = true;\n    }\n\n    function _endReentrantGuardDisabled() internal {\n        _notEntered = false;\n    }\n}\n"
48     },
49     "contracts/common/implementation/MultiCaller.sol": {
50       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// This contract is taken from Uniswap's multi call implementation (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol)\n// and was modified to be solidity 0.8 compatible. Additionally, the method was restricted to only work with msg.value\n// set to 0 to avoid any nasty attack vectors on function calls that use value sent with deposits.\n\n/// @title MultiCaller\n/// @notice Enables calling multiple methods in a single call to the contract\ncontract MultiCaller {\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}\n"
51     },
52     "contracts/common/implementation/MultiRole.sol": {
53       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nlibrary Exclusive {\n    struct RoleMembership {\n        address member;\n    }\n\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\n        return roleMembership.member == memberToCheck;\n    }\n\n    function resetMember(RoleMembership storage roleMembership, address newMember) internal {\n        require(newMember != address(0x0), \"Cannot set an exclusive role to 0x0\");\n        roleMembership.member = newMember;\n    }\n\n    function getMember(RoleMembership storage roleMembership) internal view returns (address) {\n        return roleMembership.member;\n    }\n\n    function init(RoleMembership storage roleMembership, address initialMember) internal {\n        resetMember(roleMembership, initialMember);\n    }\n}\n\nlibrary Shared {\n    struct RoleMembership {\n        mapping(address => bool) members;\n    }\n\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\n        return roleMembership.members[memberToCheck];\n    }\n\n    function addMember(RoleMembership storage roleMembership, address memberToAdd) internal {\n        require(memberToAdd != address(0x0), \"Cannot add 0x0 to a shared role\");\n        roleMembership.members[memberToAdd] = true;\n    }\n\n    function removeMember(RoleMembership storage roleMembership, address memberToRemove) internal {\n        roleMembership.members[memberToRemove] = false;\n    }\n\n    function init(RoleMembership storage roleMembership, address[] memory initialMembers) internal {\n        for (uint256 i = 0; i < initialMembers.length; i++) {\n            addMember(roleMembership, initialMembers[i]);\n        }\n    }\n}\n\n/**\n * @title Base class to manage permissions for the derived class.\n */\nabstract contract MultiRole {\n    using Exclusive for Exclusive.RoleMembership;\n    using Shared for Shared.RoleMembership;\n\n    enum RoleType { Invalid, Exclusive, Shared }\n\n    struct Role {\n        uint256 managingRole;\n        RoleType roleType;\n        Exclusive.RoleMembership exclusiveRoleMembership;\n        Shared.RoleMembership sharedRoleMembership;\n    }\n\n    mapping(uint256 => Role) private roles;\n\n    event ResetExclusiveMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\n    event AddedSharedMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\n    event RemovedSharedMember(uint256 indexed roleId, address indexed oldMember, address indexed manager);\n\n    /**\n     * @notice Reverts unless the caller is a member of the specified roleId.\n     */\n    modifier onlyRoleHolder(uint256 roleId) {\n        require(holdsRole(roleId, msg.sender), \"Sender does not hold required role\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the caller is a member of the manager role for the specified roleId.\n     */\n    modifier onlyRoleManager(uint256 roleId) {\n        require(holdsRole(roles[roleId].managingRole, msg.sender), \"Can only be called by a role manager\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the roleId represents an initialized, exclusive roleId.\n     */\n    modifier onlyExclusive(uint256 roleId) {\n        require(roles[roleId].roleType == RoleType.Exclusive, \"Must be called on an initialized Exclusive role\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the roleId represents an initialized, shared roleId.\n     */\n    modifier onlyShared(uint256 roleId) {\n        require(roles[roleId].roleType == RoleType.Shared, \"Must be called on an initialized Shared role\");\n        _;\n    }\n\n    /**\n     * @notice Whether `memberToCheck` is a member of roleId.\n     * @dev Reverts if roleId does not correspond to an initialized role.\n     * @param roleId the Role to check.\n     * @param memberToCheck the address to check.\n     * @return True if `memberToCheck` is a member of `roleId`.\n     */\n    function holdsRole(uint256 roleId, address memberToCheck) public view returns (bool) {\n        Role storage role = roles[roleId];\n        if (role.roleType == RoleType.Exclusive) {\n            return role.exclusiveRoleMembership.isMember(memberToCheck);\n        } else if (role.roleType == RoleType.Shared) {\n            return role.sharedRoleMembership.isMember(memberToCheck);\n        }\n        revert(\"Invalid roleId\");\n    }\n\n    /**\n     * @notice Changes the exclusive role holder of `roleId` to `newMember`.\n     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an\n     * initialized, ExclusiveRole.\n     * @param roleId the ExclusiveRole membership to modify.\n     * @param newMember the new ExclusiveRole member.\n     */\n    function resetMember(uint256 roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {\n        roles[roleId].exclusiveRoleMembership.resetMember(newMember);\n        emit ResetExclusiveMember(roleId, newMember, msg.sender);\n    }\n\n    /**\n     * @notice Gets the current holder of the exclusive role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.\n     * @param roleId the ExclusiveRole membership to check.\n     * @return the address of the current ExclusiveRole member.\n     */\n    function getMember(uint256 roleId) public view onlyExclusive(roleId) returns (address) {\n        return roles[roleId].exclusiveRoleMembership.getMember();\n    }\n\n    /**\n     * @notice Adds `newMember` to the shared role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n     * managing role for `roleId`.\n     * @param roleId the SharedRole membership to modify.\n     * @param newMember the new SharedRole member.\n     */\n    function addMember(uint256 roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.addMember(newMember);\n        emit AddedSharedMember(roleId, newMember, msg.sender);\n    }\n\n    /**\n     * @notice Removes `memberToRemove` from the shared role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n     * managing role for `roleId`.\n     * @param roleId the SharedRole membership to modify.\n     * @param memberToRemove the current SharedRole member to remove.\n     */\n    function removeMember(uint256 roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\n        emit RemovedSharedMember(roleId, memberToRemove, msg.sender);\n    }\n\n    /**\n     * @notice Removes caller from the role, `roleId`.\n     * @dev Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an\n     * initialized, SharedRole.\n     * @param roleId the SharedRole membership to modify.\n     */\n    function renounceMembership(uint256 roleId) public onlyShared(roleId) onlyRoleHolder(roleId) {\n        roles[roleId].sharedRoleMembership.removeMember(msg.sender);\n        emit RemovedSharedMember(roleId, msg.sender, msg.sender);\n    }\n\n    /**\n     * @notice Reverts if `roleId` is not initialized.\n     */\n    modifier onlyValidRole(uint256 roleId) {\n        require(roles[roleId].roleType != RoleType.Invalid, \"Attempted to use an invalid roleId\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if `roleId` is initialized.\n     */\n    modifier onlyInvalidRole(uint256 roleId) {\n        require(roles[roleId].roleType == RoleType.Invalid, \"Cannot use a pre-existing role\");\n        _;\n    }\n\n    /**\n     * @notice Internal method to initialize a shared role, `roleId`, which will be managed by `managingRoleId`.\n     * `initialMembers` will be immediately added to the role.\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\n     * initialized.\n     */\n    function _createSharedRole(\n        uint256 roleId,\n        uint256 managingRoleId,\n        address[] memory initialMembers\n    ) internal onlyInvalidRole(roleId) {\n        Role storage role = roles[roleId];\n        role.roleType = RoleType.Shared;\n        role.managingRole = managingRoleId;\n        role.sharedRoleMembership.init(initialMembers);\n        require(\n            roles[managingRoleId].roleType != RoleType.Invalid,\n            \"Attempted to use an invalid role to manage a shared role\"\n        );\n    }\n\n    /**\n     * @notice Internal method to initialize an exclusive role, `roleId`, which will be managed by `managingRoleId`.\n     * `initialMember` will be immediately added to the role.\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\n     * initialized.\n     */\n    function _createExclusiveRole(\n        uint256 roleId,\n        uint256 managingRoleId,\n        address initialMember\n    ) internal onlyInvalidRole(roleId) {\n        Role storage role = roles[roleId];\n        role.roleType = RoleType.Exclusive;\n        role.managingRole = managingRoleId;\n        role.exclusiveRoleMembership.init(initialMember);\n        require(\n            roles[managingRoleId].roleType != RoleType.Invalid,\n            \"Attempted to use an invalid role to manage an exclusive role\"\n        );\n    }\n}\n"
54     },
55     "contracts/common/interfaces/ExpandedIERC20.sol": {
56       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title ERC20 interface that includes burn and mint methods.\n */\nabstract contract ExpandedIERC20 is IERC20 {\n    /**\n     * @notice Burns a specific amount of the caller's tokens.\n     * @dev Only burns the caller's tokens, so it is safe to leave this method permissionless.\n     */\n    function burn(uint256 value) external virtual;\n\n    /**\n     * @dev Burns `value` tokens owned by `recipient`.\n     * @param recipient address to burn tokens from.\n     * @param value amount of tokens to burn.\n     */\n    function burnFrom(address recipient, uint256 value) external virtual returns (bool);\n\n    /**\n     * @notice Mints tokens and adds them to the balance of the `to` address.\n     * @dev This method should be permissioned to only allow designated parties to mint tokens.\n     */\n    function mint(address to, uint256 value) external virtual returns (bool);\n\n    function addMinter(address account) external virtual;\n\n    function addBurner(address account) external virtual;\n\n    function resetOwner(address account) external virtual;\n}\n"
57     },
58     "contracts/data-verification-mechanism/implementation/Constants.sol": {
59       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Stores common interface names used throughout the DVM by registration in the Finder.\n */\nlibrary OracleInterfaces {\n    bytes32 public constant Oracle = \"Oracle\";\n    bytes32 public constant IdentifierWhitelist = \"IdentifierWhitelist\";\n    bytes32 public constant Store = \"Store\";\n    bytes32 public constant FinancialContractsAdmin = \"FinancialContractsAdmin\";\n    bytes32 public constant Registry = \"Registry\";\n    bytes32 public constant CollateralWhitelist = \"CollateralWhitelist\";\n    bytes32 public constant OptimisticOracle = \"OptimisticOracle\";\n    bytes32 public constant OptimisticOracleV2 = \"OptimisticOracleV2\";\n    bytes32 public constant OptimisticOracleV3 = \"OptimisticOracleV3\";\n    bytes32 public constant Bridge = \"Bridge\";\n    bytes32 public constant GenericHandler = \"GenericHandler\";\n    bytes32 public constant SkinnyOptimisticOracle = \"SkinnyOptimisticOracle\";\n    bytes32 public constant ChildMessenger = \"ChildMessenger\";\n    bytes32 public constant OracleHub = \"OracleHub\";\n    bytes32 public constant OracleSpoke = \"OracleSpoke\";\n}\n\n/**\n * @title Commonly re-used values for contracts associated with the OptimisticOracle.\n */\nlibrary OptimisticOracleConstraints {\n    // Any price request submitted to the OptimisticOracle must contain ancillary data no larger than this value.\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` constant value otherwise it is possible\n    // that a price can be requested to the OptimisticOracle successfully, but cannot be resolved by the DVM which\n    // refuses to accept a price request made with ancillary data length over a certain size.\n    uint256 public constant ancillaryBytesLimit = 8192;\n}\n"
60     },
61     "contracts/data-verification-mechanism/implementation/ResultComputationV2.sol": {
62       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\n/**\n * @title Computes vote results.\n * @dev The result is the mode of the added votes. Otherwise, the vote is unresolved.\n */\nlibrary ResultComputationV2 {\n    /****************************************\n     *   INTERNAL LIBRARY DATA STRUCTURE    *\n     ****************************************/\n\n    struct Data {\n        mapping(int256 => uint128) voteFrequency; // Maps price to number of tokens that voted for that price.\n        uint128 totalVotes; // The total votes that have been added.\n        int256 currentMode; // The price that is the current mode, i.e., the price with the highest frequency.\n    }\n\n    /****************************************\n     *            VOTING FUNCTIONS          *\n     ****************************************/\n\n    /**\n     * @notice Adds a new vote to be used when computing the result.\n     * @param data contains information to which the vote is applied.\n     * @param votePrice value specified in the vote for the given `numberTokens`.\n     * @param numberTokens number of tokens that voted on the `votePrice`.\n     */\n    function addVote(\n        Data storage data,\n        int256 votePrice,\n        uint128 numberTokens\n    ) internal {\n        data.totalVotes += numberTokens;\n        data.voteFrequency[votePrice] += numberTokens;\n        if (votePrice != data.currentMode && data.voteFrequency[votePrice] > data.voteFrequency[data.currentMode])\n            data.currentMode = votePrice;\n    }\n\n    /****************************************\n     *        VOTING STATE GETTERS          *\n     ****************************************/\n\n    /**\n     * @notice Returns whether the result is resolved, and if so, what value it resolved to.\n     * @dev `price` should be ignored if `isResolved` is false.\n     * @param data contains information against which the `minTotalVotes` and `minModalVotes` thresholds are applied.\n     * @param minTotalVotes min (exclusive) number of tokens that must have voted (in any direction) for the result\n     * to be valid. Used to enforce a minimum voter participation rate, regardless of how the votes are distributed.\n     * @param minModalVotes min (exclusive) number of tokens that must have voted for the modal outcome for it to result\n     * in a resolution. This is used to avoid cases where the mode is a very small plurality.\n     * @return isResolved indicates if the price has been resolved correctly.\n     * @return price the price that the dvm resolved to.\n     */\n    function getResolvedPrice(\n        Data storage data,\n        uint128 minTotalVotes,\n        uint128 minModalVotes\n    ) internal view returns (bool isResolved, int256 price) {\n        if (data.totalVotes > minTotalVotes && data.voteFrequency[data.currentMode] > minModalVotes) {\n            isResolved = true; // minTotalVotes and minModalVotes are exceeded, so the resolved price is the mode.\n            price = data.currentMode;\n        }\n    }\n\n    /**\n     * @notice Checks whether a `voteHash` is considered correct.\n     * @dev Should only be called after a vote is resolved, i.e., via `getResolvedPrice`.\n     * @param data contains information against which the `voteHash` is checked.\n     * @param voteHash committed hash submitted by the voter.\n     * @return bool true if the vote was correct.\n     */\n    function wasVoteCorrect(Data storage data, bytes32 voteHash) internal view returns (bool) {\n        return voteHash == keccak256(abi.encode(data.currentMode));\n    }\n\n    /**\n     * @notice Gets the total number of tokens whose votes are considered correct.\n     * @dev Should only be called after a vote is resolved, i.e., via `getResolvedPrice`.\n     * @param data contains all votes against which the correctly voted tokens are counted.\n     * @return uint128 which indicates the frequency of the correctly voted tokens.\n     */\n    function getTotalCorrectlyVotedTokens(Data storage data) internal view returns (uint128) {\n        return data.voteFrequency[data.currentMode];\n    }\n}\n"
63     },
64     "contracts/data-verification-mechanism/implementation/Staker.sol": {
65       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/implementation/MultiCaller.sol\";\n\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\nimport \"../interfaces/StakerInterface.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * @title Staking contract enabling UMA to be locked up by stakers to earn a pro rata share of a fixed emission rate.\n * @dev Handles the staking, unstaking and reward retrieval logic.\n */\nabstract contract Staker is StakerInterface, Ownable, Lockable, MultiCaller {\n    /****************************************\n     *             STAKING STATE            *\n     ****************************************/\n\n    // Identifies a \"stake\" for a given voter. Each staker has an instance of this struct.\n    struct VoterStake {\n        uint128 stake; // UMA staked by the staker.\n        uint128 pendingUnstake; // UMA in unstake cooldown period, waiting to be unstaked.\n        mapping(uint32 => uint128) pendingStakes; // If a voter stakes during an active reveal, stake is pending.\n        uint128 rewardsPaidPerToken; // Internal tracker used in the calculation of pro-rata share of rewards.\n        uint128 outstandingRewards; // Accumulated rewards that have not yet been claimed.\n        int128 unappliedSlash; // Used to track unapplied slashing in the case of bisected rounds.\n        uint64 nextIndexToProcess; // The next request index that a staker is susceptible to be slashed on.\n        uint64 unstakeTime; // Time that a staker can unstake. Used to determine if cooldown has passed.\n        address delegate; // Address a staker has delegated to. The delegate can commit/reveal/claimRestake rewards.\n    }\n\n    mapping(address => VoterStake) public voterStakes; // Each voter is mapped to staker struct for their position.\n\n    mapping(address => address) public delegateToStaker; // Mapping of delegates to their delegators (staker).\n\n    uint128 public emissionRate; // Number of UMA emitted per second to incentivize stakers.\n\n    uint128 public cumulativeStake; // Total number of UMA staked within the system.\n\n    uint128 public rewardPerTokenStored; // Tracker used to allocate pro-rata share of rewards to stakers.\n\n    uint64 public unstakeCoolDown; // Delay, in seconds, a staker must wait when trying to unstake their UMA.\n\n    uint64 public lastUpdateTime; // Tracks the last time the reward rate was updated, used in reward allocation.\n\n    ExpandedIERC20 public immutable votingToken; // An instance of the UMA voting token to mint rewards for stakers\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event Staked(\n        address indexed voter,\n        address indexed from,\n        uint128 amount,\n        uint128 voterStake,\n        uint128 voterPendingUnstake,\n        uint128 cumulativeStake\n    );\n\n    event RequestedUnstake(address indexed voter, uint128 amount, uint64 unstakeTime, uint128 voterStake);\n\n    event ExecutedUnstake(address indexed voter, uint128 tokensSent, uint128 voterStake);\n\n    event WithdrawnRewards(address indexed voter, address indexed delegate, uint128 tokensWithdrawn);\n\n    event UpdatedReward(address indexed voter, uint128 newReward, uint64 lastUpdateTime);\n\n    event SetNewEmissionRate(uint128 newEmissionRate);\n\n    event SetNewUnstakeCoolDown(uint64 newUnstakeCoolDown);\n\n    event DelegateSet(address indexed delegator, address indexed delegate);\n\n    event DelegatorSet(address indexed delegate, address indexed delegator);\n\n    /**\n     * @notice Construct the Staker contract\n     * @param _emissionRate amount of voting tokens that are emitted per second, split pro rata to stakers.\n     * @param _unstakeCoolDown time that a voter must wait to unstake after requesting to unstake.\n     * @param _votingToken address of the UMA token contract used to commit votes.\n     */\n    constructor(\n        uint128 _emissionRate,\n        uint64 _unstakeCoolDown,\n        address _votingToken\n    ) {\n        setEmissionRate(_emissionRate);\n        setUnstakeCoolDown(_unstakeCoolDown);\n        votingToken = ExpandedIERC20(_votingToken);\n    }\n\n    /****************************************\n     *           STAKER FUNCTIONS           *\n     ****************************************/\n\n    /**\n     * @notice Pulls tokens from the sender's wallet and stakes them on his behalf.\n     * @param amount the amount of tokens to stake.\n     */\n    function stake(uint128 amount) external {\n        _stakeTo(msg.sender, msg.sender, amount);\n    }\n\n    /**\n     * @notice Pulls tokens from the sender's wallet and stakes them for the recipient.\n     * @param recipient the recipient address.\n     * @param amount the amount of tokens to stake.\n     */\n    function stakeTo(address recipient, uint128 amount) external {\n        _stakeTo(msg.sender, recipient, amount);\n    }\n\n    // Pull an amount of votingToken from the from address and stakes them for the recipient address.\n    // If we are in an active reveal phase the stake amount will be added to the pending stake.\n    // If not, the stake amount will be added to the stake.\n    function _stakeTo(\n        address from,\n        address recipient,\n        uint128 amount\n    ) internal {\n        require(amount > 0, \"Cannot stake 0\");\n\n        VoterStake storage voterStake = voterStakes[recipient];\n\n        // If the staker has a cumulative staked balance of 0 then we can shortcut their nextIndexToProcess to\n        // the most recent index. This means we don't need to traverse requests where the staker was not staked.\n        // _getStartingIndexForStaker returns the appropriate index to start at.\n        if (voterStake.stake == 0) voterStake.nextIndexToProcess = _getStartingIndexForStaker();\n        _updateTrackers(recipient);\n\n        // Compute pending stakes when needed.\n        _computePendingStakes(recipient, amount);\n\n        voterStake.stake += amount;\n        cumulativeStake += amount;\n\n        // Tokens are pulled from the from address and sent to this contract.\n        // During withdrawAndRestake, from is the same as the address of this contract, so there is no need to transfer.\n        if (from != address(this)) votingToken.transferFrom(from, address(this), amount);\n        emit Staked(recipient, from, amount, voterStake.stake, voterStake.pendingUnstake, cumulativeStake);\n    }\n\n    /**\n     * @notice Request a certain number of tokens to be unstaked. After the unstake time expires, the user may execute\n     * the unstake. Tokens requested to unstake are not slashable nor subject to earning rewards.\n     * This function cannot be called during an active reveal phase.\n     * Note there is no way to cancel an unstake request, you must wait until after unstakeTime and re-stake.\n     * @param amount the amount of tokens to request to be unstaked.\n     */\n    function requestUnstake(uint128 amount) external nonReentrant() {\n        require(!_inActiveReveal(), \"In an active reveal phase\");\n        require(amount > 0, \"Cannot unstake 0\");\n        _updateTrackers(msg.sender);\n        VoterStake storage voterStake = voterStakes[msg.sender];\n\n        require(voterStake.stake >= amount && voterStake.pendingUnstake == 0, \"Bad amount or pending unstake\");\n\n        cumulativeStake -= amount;\n        voterStake.pendingUnstake = amount;\n        voterStake.stake -= amount;\n        voterStake.unstakeTime = uint64(getCurrentTime()) + unstakeCoolDown;\n\n        emit RequestedUnstake(msg.sender, amount, voterStake.unstakeTime, voterStake.stake);\n    }\n\n    /**\n     * @notice  Execute a previously requested unstake. Requires the unstake time to have passed.\n     * @dev If a staker requested an unstake and time > unstakeTime then send funds to staker. If unstakeCoolDown is\n     * set to 0 then the unstake can be executed immediately.\n     */\n    function executeUnstake() external nonReentrant() {\n        VoterStake storage voterStake = voterStakes[msg.sender];\n        require(\n            voterStake.unstakeTime != 0 && (getCurrentTime() >= voterStake.unstakeTime || unstakeCoolDown == 0),\n            \"Unstake time not passed\"\n        );\n        uint128 tokensToSend = voterStake.pendingUnstake;\n\n        if (tokensToSend > 0) {\n            voterStake.pendingUnstake = 0;\n            voterStake.unstakeTime = 0;\n            votingToken.transfer(msg.sender, tokensToSend);\n        }\n\n        emit ExecutedUnstake(msg.sender, tokensToSend, voterStake.stake);\n    }\n\n    /**\n     * @notice Send accumulated rewards to the voter. Note that these rewards do not include slashing balance changes.\n     * @return uint128 the amount of tokens sent to the voter.\n     */\n    function withdrawRewards() external returns (uint128) {\n        return _withdrawRewards(msg.sender, msg.sender);\n    }\n\n    // Withdraws rewards for a given voter and sends them to the recipient.\n    function _withdrawRewards(address voter, address recipient) internal returns (uint128) {\n        _updateTrackers(voter);\n        VoterStake storage voterStake = voterStakes[voter];\n\n        uint128 tokensToMint = voterStake.outstandingRewards;\n        if (tokensToMint > 0) {\n            voterStake.outstandingRewards = 0;\n            require(votingToken.mint(recipient, tokensToMint), \"Voting token issuance failed\");\n            emit WithdrawnRewards(voter, msg.sender, tokensToMint);\n        }\n        return tokensToMint;\n    }\n\n    /**\n     * @notice Stake accumulated rewards. This is merely a convenience mechanism that combines the voter's withdrawal\n     * and stake in the same transaction if requested by a delegate or the voter.\n     * @dev The rewarded tokens simply pass through this contract before being staked on the voter's behalf.\n     *  The balance of the delegate remains unchanged.\n     * @return uint128 the amount of tokens that the voter is staking.\n     */\n    function withdrawAndRestake() external returns (uint128) {\n        address voter = getVoterFromDelegate(msg.sender);\n        uint128 rewards = _withdrawRewards(voter, address(this));\n        _stakeTo(address(this), voter, rewards);\n        return rewards;\n    }\n\n    /**\n     * @notice Sets the delegate of a voter. This delegate can vote on behalf of the staker. The staker will still own\n     * all staked balances, receive rewards and be slashed based on the actions of the delegate. Intended use is using a\n     * low-security available wallet for voting while keeping access to staked amounts secure by a more secure wallet.\n     * @param delegate the address of the delegate.\n     */\n    function setDelegate(address delegate) external {\n        voterStakes[msg.sender].delegate = delegate;\n        emit DelegateSet(msg.sender, delegate);\n    }\n\n    /**\n     * @notice Sets the delegator of a voter. Acts to accept a delegation. The delegate can only vote for the delegator\n     * if the delegator also selected the delegate to do so (two-way relationship needed).\n     * @param delegator the address of the delegator.\n     */\n    function setDelegator(address delegator) external {\n        delegateToStaker[msg.sender] = delegator;\n        emit DelegatorSet(msg.sender, delegator);\n    }\n\n    /****************************************\n     *        OWNER ADMIN FUNCTIONS         *\n     ****************************************/\n\n    /**\n     * @notice  Set the token's emission rate, the number of voting tokens that are emitted per second.\n     * @param newEmissionRate the new amount of voting tokens that are emitted per second, split pro rata to stakers.\n     */\n    function setEmissionRate(uint128 newEmissionRate) public onlyOwner {\n        _updateReward(address(0));\n        emissionRate = newEmissionRate;\n        emit SetNewEmissionRate(newEmissionRate);\n    }\n\n    /**\n     * @notice  Set the amount of time a voter must wait to unstake after submitting a request to do so.\n     * @param newUnstakeCoolDown the new duration of the cool down period in seconds.\n     */\n    function setUnstakeCoolDown(uint64 newUnstakeCoolDown) public onlyOwner {\n        unstakeCoolDown = newUnstakeCoolDown;\n        emit SetNewUnstakeCoolDown(newUnstakeCoolDown);\n    }\n\n    // Updates an account internal trackers.\n    function _updateTrackers(address voter) internal virtual {\n        _updateReward(voter);\n    }\n\n    /****************************************\n     *            VIEW FUNCTIONS            *\n     ****************************************/\n\n    /**\n     * @notice Gets the pending stake for a voter for a given round.\n     * @param voter the voter address.\n     * @param roundId round id.\n     * @return uint128 amount of the pending stake.\n     */\n    function getVoterPendingStake(address voter, uint32 roundId) external view returns (uint128) {\n        return voterStakes[voter].pendingStakes[roundId];\n    }\n\n    /**\n     * @notice Gets the voter from the delegate.\n     * @param caller caller of the function or the address to check in the mapping between a voter and their delegate.\n     * @return address voter that corresponds to the delegate.\n     */\n    function getVoterFromDelegate(address caller) public view returns (address) {\n        address delegator = delegateToStaker[caller];\n        // The delegate chose to be a delegate for the staker.\n        if (delegator != address(0) && voterStakes[delegator].delegate == caller) return delegator;\n        else return caller; // The staker chose the delegate.\n    }\n\n    /**\n     * @notice  Determine the number of outstanding token rewards that can be withdrawn by a voter.\n     * @param voter the address of the voter.\n     * @return uint256 the outstanding rewards.\n     */\n    function outstandingRewards(address voter) public view returns (uint256) {\n        VoterStake storage voterStake = voterStakes[voter];\n\n        return\n            ((voterStake.stake * (rewardPerToken() - voterStake.rewardsPaidPerToken)) / 1e18) +\n            voterStake.outstandingRewards;\n    }\n\n    /**\n     * @notice  Calculate the reward per token based on the last time the reward was updated.\n     * @return uint256 the reward per token.\n     */\n    function rewardPerToken() public view returns (uint256) {\n        if (cumulativeStake == 0) return rewardPerTokenStored;\n        return rewardPerTokenStored + ((getCurrentTime() - lastUpdateTime) * emissionRate * 1e18) / cumulativeStake;\n    }\n\n    /**\n     * @notice Returns the total amount of tokens staked by the voter, after applying updateTrackers. Specifically used\n     * by offchain apps to simulate the cumulative stake + unapplied slashing updates without sending a transaction.\n     * @param voter the address of the voter.\n     * @return uint128 the total stake.\n     */\n    function getVoterStakePostUpdate(address voter) external returns (uint128) {\n        _updateTrackers(voter);\n        return voterStakes[voter].stake;\n    }\n\n    /**\n     * @notice Returns the current block timestamp.\n     * @dev Can be overridden to control contract time.\n     * @return the current block timestamp.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /****************************************\n     *          INTERNAL FUNCTIONS          *\n     ****************************************/\n\n    // This function must be called before any tokens are staked. Update the voter's pending stakes when necessary.\n    // The contract that inherits from Staker (e.g. VotingV2) must implement this logic by overriding this function.\n    function _computePendingStakes(address voter, uint128 amount) internal virtual;\n\n    // Add a new stake amount to the voter's pending stake for a specific round id.\n    function _incrementPendingStake(\n        address voter,\n        uint32 roundId,\n        uint128 amount\n    ) internal {\n        voterStakes[voter].pendingStakes[roundId] += amount;\n    }\n\n    // Determine if we are in an active reveal phase. This function should be overridden by the child contract.\n    function _inActiveReveal() internal view virtual returns (bool) {\n        return false;\n    }\n\n    // Returns the starting index for a staker. This function should be overridden by the implementing contract.\n    function _getStartingIndexForStaker() internal virtual returns (uint64) {\n        return 0;\n    }\n\n    // Calculate the reward per token based on last time the reward was updated.\n    function _updateReward(address voter) internal {\n        uint128 newRewardPerToken = uint128(rewardPerToken());\n        rewardPerTokenStored = newRewardPerToken;\n        lastUpdateTime = uint64(getCurrentTime());\n        if (voter != address(0)) {\n            VoterStake storage voterStake = voterStakes[voter];\n            voterStake.outstandingRewards = uint128(outstandingRewards(voter));\n            voterStake.rewardsPaidPerToken = newRewardPerToken;\n        }\n        emit UpdatedReward(voter, newRewardPerToken, lastUpdateTime);\n    }\n}\n"
66     },
67     "contracts/data-verification-mechanism/implementation/VoteTiming.sol": {
68       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../interfaces/VotingInterface.sol\";\n\n/**\n * @title Library to compute rounds and phases for an equal length commit-reveal voting cycle.\n */\nlibrary VoteTiming {\n    struct Data {\n        uint256 phaseLength;\n    }\n\n    /**\n     * @notice Initializes the data object. Sets the phase length based on the input.\n     * @param data reference to the this library's data object.\n     * @param phaseLength length of voting phase in seconds.\n     */\n    function init(Data storage data, uint256 phaseLength) internal {\n        // This should have a require message but this results in an internal Solidity error.\n        require(phaseLength > 0);\n        data.phaseLength = phaseLength;\n    }\n\n    /**\n     * @notice Computes the roundID based off the current time as floor(timestamp/roundLength).\n     * @dev The round ID depends on the global timestamp but not on the lifetime of the system.\n     * The consequence is that the initial round ID starts at an arbitrary number (that increments, as expected, for subsequent rounds) instead of zero or one.\n     * @param data input data object.\n     * @param currentTime input unix timestamp used to compute the current roundId.\n     * @return roundId defined as a function of the currentTime and `phaseLength` from `data`.\n     */\n    function computeCurrentRoundId(Data storage data, uint256 currentTime) internal view returns (uint256) {\n        uint256 roundLength = data.phaseLength * uint256(VotingAncillaryInterface.Phase.NUM_PHASES);\n        return currentTime / roundLength;\n    }\n\n    /**\n     * @notice compute the round end time as a function of the round Id.\n     * @param data input data object.\n     * @param roundId uniquely identifies the current round.\n     * @return timestamp unix time of when the current round will end.\n     */\n    function computeRoundEndTime(Data storage data, uint256 roundId) internal view returns (uint256) {\n        uint256 roundLength = data.phaseLength * uint256(VotingAncillaryInterface.Phase.NUM_PHASES);\n        return roundLength * (roundId + 1);\n    }\n\n    /**\n     * @notice Computes the current phase based only on the current time.\n     * @param data input data object.\n     * @param currentTime input unix timestamp used to compute the current roundId.\n     * @return current voting phase based on current time and vote phases configuration.\n     */\n    function computeCurrentPhase(Data storage data, uint256 currentTime)\n        internal\n        view\n        returns (VotingAncillaryInterface.Phase)\n    {\n        // This employs some hacky casting. We could make this an if-statement if we're worried about type safety.\n        return\n            VotingAncillaryInterface.Phase(\n                (currentTime / data.phaseLength) % uint256(VotingAncillaryInterface.Phase.NUM_PHASES)\n            );\n    }\n}\n"
69     },
70     "contracts/data-verification-mechanism/implementation/VotingToken.sol": {
71       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../../common/implementation/ExpandedERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\";\n\n/**\n * @title Ownership of this token allows a voter to respond to price requests.\n * @dev Supports snapshotting and allows the Oracle to mint new tokens as rewards.\n */\ncontract VotingToken is ExpandedERC20, ERC20Snapshot {\n    /**\n     * @notice Constructs the VotingToken.\n     */\n    constructor() ExpandedERC20(\"UMA Voting Token v1\", \"UMA\", 18) ERC20Snapshot() {}\n\n    function decimals() public view virtual override(ERC20, ExpandedERC20) returns (uint8) {\n        return super.decimals();\n    }\n\n    /**\n     * @notice Creates a new snapshot ID.\n     * @return uint256 Thew new snapshot ID.\n     */\n    function snapshot() external returns (uint256) {\n        return _snapshot();\n    }\n\n    // _transfer, _mint and _burn are ERC20 internal methods that are overridden by ERC20Snapshot,\n    // therefore the compiler will complain that VotingToken must override these methods\n    // because the two base classes (ERC20 and ERC20Snapshot) both define the same functions\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal override(ERC20) {\n        super._transfer(from, to, value);\n    }\n\n    function _mint(address account, uint256 value) internal virtual override(ERC20) {\n        super._mint(account, value);\n    }\n\n    function _burn(address account, uint256 value) internal virtual override(ERC20) {\n        super._burn(account, value);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Snapshot) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
72     },
73     "contracts/data-verification-mechanism/implementation/VotingV2.sol": {
74       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./ResultComputationV2.sol\";\nimport \"./Staker.sol\";\nimport \"./VoteTiming.sol\";\nimport \"./Constants.sol\";\n\nimport \"../interfaces/MinimumVotingAncillaryInterface.sol\";\nimport \"../interfaces/FinderInterface.sol\";\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../interfaces/OracleAncillaryInterface.sol\";\nimport \"../interfaces/OracleGovernanceInterface.sol\";\nimport \"../interfaces/OracleInterface.sol\";\nimport \"../interfaces/VotingV2Interface.sol\";\nimport \"../interfaces/RegistryInterface.sol\";\nimport \"../interfaces/SlashingLibraryInterface.sol\";\n\n/**\n * @title VotingV2 contract for the UMA DVM.\n * @dev Handles receiving and resolving price requests via a commit-reveal voting schelling scheme.\n */\n\ncontract VotingV2 is Staker, OracleInterface, OracleAncillaryInterface, OracleGovernanceInterface, VotingV2Interface {\n    using VoteTiming for VoteTiming.Data;\n    using ResultComputationV2 for ResultComputationV2.Data;\n\n    /****************************************\n     *        VOTING DATA STRUCTURES        *\n     ****************************************/\n\n    // Identifies a unique price request. Tracks ongoing votes as well as the result of the vote.\n    struct PriceRequest {\n        uint32 lastVotingRound; // Last round that this price request was voted on. Updated when a request is rolled.\n        bool isGovernance; // Denotes whether this is a governance request or not.\n        uint64 time; // Timestamp used when evaluating the request.\n        uint32 rollCount; // The number of rounds that a price request has rolled. Informs if a request can be deleted.\n        bytes32 identifier; // Identifier that defines how the voters should resolve the request.\n        mapping(uint32 => VoteInstance) voteInstances; // A map containing all votes for this price in various rounds.\n        bytes ancillaryData; // Additional data used to resolve the request.\n    }\n\n    struct VoteInstance {\n        mapping(address => VoteSubmission) voteSubmissions; // Maps (voter) to their submission.\n        ResultComputationV2.Data results; // The data structure containing the computed voting results.\n    }\n\n    struct VoteSubmission {\n        bytes32 commit; // A bytes32 of 0 indicates no commit or a commit that was already revealed.\n        bytes32 revealHash; // The hash of the value that was revealed. This is only used for computation of rewards.\n    }\n\n    struct Round {\n        SlashingLibraryInterface slashingLibrary; // Slashing library used to compute voter participation slash at this round.\n        uint128 minParticipationRequirement; // Minimum staked tokens that must vote to resolve a request.\n        uint128 minAgreementRequirement; // Minimum staked tokens that must agree on an outcome to resolve a request.\n        uint128 cumulativeStakeAtRound; // Total staked tokens at the start of the round.\n        uint32 numberOfRequestsToVote; // The number of requests to vote in this round.\n    }\n\n    struct SlashingTracker {\n        uint256 wrongVoteSlashPerToken; // The amount of tokens slashed per token staked for a wrong vote.\n        uint256 noVoteSlashPerToken; // The amount of tokens slashed per token staked for a no vote.\n        uint256 totalSlashed; // The total amount of tokens slashed for a given request.\n        uint256 totalCorrectVotes; // The total number of correct votes for a given request.\n        uint32 lastVotingRound; // The last round that this request was voted on (when it resolved).\n    }\n\n    enum VoteParticipation {\n        DidNotVote, // Voter did not vote.\n        WrongVote, // Voter voted against the resolved price.\n        CorrectVote // Voter voted with the resolved price.\n    }\n\n    // Represents the status a price request has.\n    enum RequestStatus {\n        NotRequested, // Was never requested.\n        Active, // Is being voted on in the current round.\n        Resolved, // Was resolved in a previous round.\n        Future, // Is scheduled to be voted on in a future round.\n        ToDelete // Is scheduled to be deleted.\n    }\n\n    // Only used as a return value in view methods -- never stored in the contract.\n    struct RequestState {\n        RequestStatus status;\n        uint32 lastVotingRound;\n    }\n\n    /****************************************\n     *            VOTING STATE              *\n     ****************************************/\n\n    uint32 public lastRoundIdProcessed; // The last round pendingPriceRequestsIds were traversed in.\n\n    uint64 public nextPendingIndexToProcess; // Next pendingPriceRequestsIds index to process in lastRoundIdProcessed.\n\n    FinderInterface public immutable finder; // Reference to the UMA Finder contract, used to find other UMA contracts.\n\n    SlashingLibraryInterface public slashingLibrary; // Reference to Slashing Library, used to compute slashing amounts.\n\n    VoteTiming.Data public voteTiming; // Vote timing library used to compute round timing related logic.\n\n    OracleAncillaryInterface public immutable previousVotingContract; // Previous voting contract, if migrated.\n\n    mapping(uint256 => Round) public rounds; // Maps round numbers to the rounds.\n\n    mapping(bytes32 => PriceRequest) public priceRequests; // Maps price request IDs to the PriceRequest struct.\n\n    bytes32[] public resolvedPriceRequestIds; // Array of resolved price requestIds. Used to track resolved requests.\n\n    bytes32[] public pendingPriceRequestsIds; // Array of pending price requestIds. Can be resolved in the future.\n\n    uint32 public maxRolls; // The maximum number of times a request can roll before it is deleted automatically.\n\n    uint32 public maxRequestsPerRound; // The maximum number of requests that can be enqueued in a single round.\n\n    address public migratedAddress; // If non-zero, this contract has been migrated to this address.\n\n    uint128 public gat; // GAT: A minimum number of tokens that must participate to resolve a vote.\n\n    uint64 public spat; // SPAT: Minimum percentage of staked tokens that must agree on the answer to resolve a vote.\n\n    uint64 public constant UINT64_MAX = type(uint64).max; // Max value of an unsigned integer.\n\n    uint256 public constant ANCILLARY_BYTES_LIMIT = 8192; // Max length in bytes of ancillary data.\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event VoteCommitted(\n        address indexed voter,\n        address indexed caller,\n        uint32 roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        bytes ancillaryData\n    );\n\n    event EncryptedVote(\n        address indexed caller,\n        uint32 indexed roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        bytes ancillaryData,\n        bytes encryptedVote\n    );\n\n    event VoteRevealed(\n        address indexed voter,\n        address indexed caller,\n        uint32 roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        bytes ancillaryData,\n        int256 price,\n        uint128 numTokens\n    );\n\n    event RequestAdded(\n        address indexed requester,\n        uint32 indexed roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        bytes ancillaryData,\n        bool isGovernance\n    );\n\n    event RequestResolved(\n        uint32 indexed roundId,\n        uint256 indexed resolvedPriceRequestIndex,\n        bytes32 indexed identifier,\n        uint256 time,\n        bytes ancillaryData,\n        int256 price\n    );\n\n    event VotingContractMigrated(address newAddress);\n\n    event RequestDeleted(bytes32 indexed identifier, uint256 indexed time, bytes ancillaryData, uint32 rollCount);\n\n    event RequestRolled(bytes32 indexed identifier, uint256 indexed time, bytes ancillaryData, uint32 rollCount);\n\n    event GatAndSpatChanged(uint128 newGat, uint64 newSpat);\n\n    event SlashingLibraryChanged(address newAddress);\n\n    event MaxRollsChanged(uint32 newMaxRolls);\n\n    event MaxRequestsPerRoundChanged(uint32 newMaxRequestsPerRound);\n\n    event VoterSlashApplied(address indexed voter, int128 slashedTokens, uint128 postStake);\n\n    event VoterSlashed(address indexed voter, uint256 indexed requestIndex, int128 slashedTokens);\n\n    /**\n     * @notice Construct the VotingV2 contract.\n     * @param _emissionRate amount of voting tokens that are emitted per second, split prorate between stakers.\n     * @param _unstakeCoolDown time that a voter must wait to unstake after requesting to unstake.\n     * @param _phaseLength length of the voting phases in seconds.\n     * @param _maxRolls number of times a vote must roll to be auto deleted by the DVM.\n     * @param _maxRequestsPerRound maximum number of requests that can be enqueued in a single round.\n     * @param _gat number of tokens that must participate to resolve a vote.\n     * @param _spat percentage of staked tokens that must agree on the result to resolve a vote.\n     * @param _votingToken address of the UMA token contract used to commit votes.\n     * @param _finder keeps track of all contracts within the system based on their interfaceName.\n     * @param _slashingLibrary contract used to calculate voting slashing penalties based on voter participation.\n     * @param _previousVotingContract previous voting contract address.\n     */\n    constructor(\n        uint128 _emissionRate,\n        uint64 _unstakeCoolDown,\n        uint64 _phaseLength,\n        uint32 _maxRolls,\n        uint32 _maxRequestsPerRound,\n        uint128 _gat,\n        uint64 _spat,\n        address _votingToken,\n        address _finder,\n        address _slashingLibrary,\n        address _previousVotingContract\n    ) Staker(_emissionRate, _unstakeCoolDown, _votingToken) {\n        voteTiming.init(_phaseLength);\n        finder = FinderInterface(_finder);\n        previousVotingContract = OracleAncillaryInterface(_previousVotingContract);\n        setGatAndSpat(_gat, _spat);\n        setSlashingLibrary(_slashingLibrary);\n        setMaxRequestPerRound(_maxRequestsPerRound);\n        setMaxRolls(_maxRolls);\n    }\n\n    /***************************************\n                    MODIFIERS\n    ****************************************/\n\n    modifier onlyRegisteredContract() {\n        _requireRegisteredContract();\n        _;\n    }\n\n    modifier onlyIfNotMigrated() {\n        _requireNotMigrated();\n        _;\n    }\n\n    /****************************************\n     *  PRICE REQUEST AND ACCESS FUNCTIONS  *\n     ****************************************/\n\n    /**\n     * @notice Enqueues a request (if a request isn't already present) for the identifier, time and ancillary data.\n     * @dev Time must be in the past and the identifier must be supported. The length of the ancillary data is limited.\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public override nonReentrant onlyIfNotMigrated onlyRegisteredContract {\n        _requestPrice(identifier, time, ancillaryData, false);\n    }\n\n    /**\n     * @notice Enqueues a governance action request (if not already present) for identifier, time and ancillary data.\n     * @dev Only the owner of the Voting contract can call this. In normal operation this is the Governor contract.\n     * @param identifier uniquely identifies the price requested. E.g. Admin 0 (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     */\n    function requestGovernanceAction(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) external override onlyOwner onlyIfNotMigrated {\n        _requestPrice(identifier, time, ancillaryData, true);\n    }\n\n    /**\n     * @notice Enqueues a request (if a request isn't already present) for the identifier, time pair.\n     * @dev Overloaded method to enable short term backwards compatibility when ancillary data is not included.\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     */\n    function requestPrice(bytes32 identifier, uint256 time) external override {\n        requestPrice(identifier, time, \"\");\n    }\n\n    // Enqueues a request (if a request isn't already present) for the given identifier, time and ancillary data.\n    function _requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bool isGovernance\n    ) internal {\n        require(time <= getCurrentTime(), \"Can only request in past\");\n        require(isGovernance || _getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier\");\n        require(ancillaryData.length <= ANCILLARY_BYTES_LIMIT, \"Invalid ancillary data\");\n\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, ancillaryData);\n        PriceRequest storage priceRequest = priceRequests[priceRequestId];\n\n        // Price has never been requested.\n        uint32 currentRoundId = getCurrentRoundId();\n        if (_getRequestStatus(priceRequest, currentRoundId) == RequestStatus.NotRequested) {\n            uint32 roundIdToVoteOn = getRoundIdToVoteOnRequest(currentRoundId + 1);\n            ++rounds[roundIdToVoteOn].numberOfRequestsToVote;\n            priceRequest.identifier = identifier;\n            priceRequest.time = uint64(time);\n            priceRequest.ancillaryData = ancillaryData;\n            priceRequest.lastVotingRound = roundIdToVoteOn;\n            if (isGovernance) priceRequest.isGovernance = isGovernance;\n\n            pendingPriceRequestsIds.push(priceRequestId);\n            emit RequestAdded(msg.sender, roundIdToVoteOn, identifier, time, ancillaryData, isGovernance);\n        }\n    }\n\n    /**\n     * @notice Gets the round ID that a request should be voted on.\n     * @param targetRoundId round ID to start searching for a round to vote on.\n     * @return uint32 round ID that a request should be voted on.\n     */\n    function getRoundIdToVoteOnRequest(uint32 targetRoundId) public view returns (uint32) {\n        while (rounds[targetRoundId].numberOfRequestsToVote >= maxRequestsPerRound) ++targetRoundId;\n        return targetRoundId;\n    }\n\n    /**\n     * @notice Returns whether the price for identifier, time and ancillary data is available.\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp of the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @return bool if the DVM has resolved to a price for the given identifier, timestamp and ancillary data.\n     */\n    function hasPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override onlyRegisteredContract returns (bool) {\n        (bool _hasPrice, , ) = _getPriceOrError(identifier, time, ancillaryData);\n        return _hasPrice;\n    }\n\n    /**\n     * @notice Whether the price for identifier and time is available.\n     * @dev Overloaded method to enable short term backwards compatibility when ancillary data is not included.\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp of the price request.\n     * @return bool if the DVM has resolved to a price for the given identifier and timestamp.\n     */\n    function hasPrice(bytes32 identifier, uint256 time) external view override returns (bool) {\n        return hasPrice(identifier, time, \"\");\n    }\n\n    /**\n     * @notice Gets the price for identifier, time and ancillary data if it has already been requested and resolved.\n     * @dev If the price is not available, the method reverts.\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp of the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @return int256 representing the resolved price for the given identifier, timestamp and ancillary data.\n     */\n    function getPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override onlyRegisteredContract returns (int256) {\n        (bool _hasPrice, int256 price, string memory message) = _getPriceOrError(identifier, time, ancillaryData);\n\n        // If the price wasn't available, revert with the provided message.\n        require(_hasPrice, message);\n        return price;\n    }\n\n    /**\n     * @notice Gets the price for identifier and time if it has already been requested and resolved.\n     * @dev Overloaded method to enable short term backwards compatibility when ancillary data is not included.\n     * @dev If the price is not available, the method reverts.\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp of the price request.\n     * @return int256 representing the resolved price for the given identifier and timestamp.\n     */\n    function getPrice(bytes32 identifier, uint256 time) external view override returns (int256) {\n        return getPrice(identifier, time, \"\");\n    }\n\n    /**\n     * @notice Gets the status of a list of price requests, identified by their identifier, time and ancillary data.\n     * @dev If the status for a particular request is NotRequested, the lastVotingRound will always be 0.\n     * @param requests array of pending requests which includes identifier, timestamp & ancillary data for the requests.\n     * @return requestStates a list, in the same order as the input list, giving the status of the specified requests.\n     */\n    function getPriceRequestStatuses(PendingRequestAncillary[] memory requests)\n        public\n        view\n        returns (RequestState[] memory)\n    {\n        RequestState[] memory requestStates = new RequestState[](requests.length);\n        uint32 currentRoundId = getCurrentRoundId();\n        for (uint256 i = 0; i < requests.length; i = unsafe_inc(i)) {\n            PriceRequest storage priceRequest =\n                _getPriceRequest(requests[i].identifier, requests[i].time, requests[i].ancillaryData);\n\n            RequestStatus status = _getRequestStatus(priceRequest, currentRoundId);\n\n            // If it's an active request, its true lastVotingRound is the current one, even if it hasn't been updated.\n            if (status == RequestStatus.Active) requestStates[i].lastVotingRound = currentRoundId;\n            else requestStates[i].lastVotingRound = priceRequest.lastVotingRound;\n            requestStates[i].status = status;\n        }\n        return requestStates;\n    }\n\n    /****************************************\n     *          VOTING FUNCTIONS            *\n     ****************************************/\n\n    /**\n     * @notice Commit a vote for a price request for identifier at time.\n     * @dev identifier, time must correspond to a price request that's currently in the commit phase.\n     * Commits can be changed.\n     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the systems\n     * expected behavior, voters should never reuse salts. If someone else is able to guess the voted price and knows\n     * that a salt will be reused, then they can determine the vote pre-reveal.\n     * @param identifier uniquely identifies the committed vote. E.g. BTC/USD price pair.\n     * @param time unix timestamp of the price being voted on.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param hash keccak256 hash of the price, salt, voter address, time, ancillaryData, current roundId, identifier.\n     */\n    function commitVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash\n    ) public override nonReentrant {\n        uint32 currentRoundId = getCurrentRoundId();\n        address voter = getVoterFromDelegate(msg.sender);\n        _updateTrackers(voter);\n\n        require(hash != bytes32(0), \"Invalid commit hash\");\n        require(getVotePhase() == Phase.Commit, \"Cannot commit in reveal phase\");\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time, ancillaryData);\n        require(_getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active, \"Request must be active\");\n\n        priceRequest.voteInstances[currentRoundId].voteSubmissions[voter].commit = hash;\n\n        emit VoteCommitted(voter, msg.sender, currentRoundId, identifier, time, ancillaryData);\n    }\n\n    /**\n     * @notice Reveal a previously committed vote for identifier at time.\n     * @dev The revealed price, salt, voter address, time, ancillaryData, current roundId, identifier must hash to the\n     * latest hash that commitVote() was called with. Only the committer can reveal their vote.\n     * @param identifier voted on in the commit phase. E.g. BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price being voted on.\n     * @param price voted on during the commit phase.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param salt value used to hide the commitment price during the commit phase.\n     */\n    function revealVote(\n        bytes32 identifier,\n        uint256 time,\n        int256 price,\n        bytes memory ancillaryData,\n        int256 salt\n    ) public override nonReentrant {\n        uint32 currentRoundId = getCurrentRoundId();\n        _freezeRoundVariables(currentRoundId);\n        VoteInstance storage voteInstance =\n            _getPriceRequest(identifier, time, ancillaryData).voteInstances[currentRoundId];\n        address voter = getVoterFromDelegate(msg.sender);\n        VoteSubmission storage voteSubmission = voteInstance.voteSubmissions[voter];\n\n        require(getVotePhase() == Phase.Reveal, \"Reveal phase has not started yet\"); // Can only reveal in reveal phase.\n\n        // Zero hashes are blocked in commit; they indicate a different error: voter did not commit or already revealed.\n        require(voteSubmission.commit != bytes32(0), \"Invalid hash reveal\");\n\n        // Check that the hash that was committed matches to the one that was revealed. Note that if the voter had\n        // then they must reveal with the same account they had committed with.\n        require(\n            keccak256(abi.encodePacked(price, salt, voter, time, ancillaryData, uint256(currentRoundId), identifier)) ==\n                voteSubmission.commit,\n            \"Revealed data != commit hash\"\n        );\n\n        delete voteSubmission.commit; // Small gas refund for clearing up storage.\n        voteSubmission.revealHash = keccak256(abi.encode(price)); // Set the voter's submission.\n\n        // Calculate the voters effective stake for this round as the difference between their stake and pending stake.\n        // This allows for the voter to have staked during this reveal phase and not consider their pending stake.\n        uint128 effectiveStake = voterStakes[voter].stake - voterStakes[voter].pendingStakes[currentRoundId];\n        voteInstance.results.addVote(price, effectiveStake); // Add vote to the results.\n        emit VoteRevealed(voter, msg.sender, currentRoundId, identifier, time, ancillaryData, price, effectiveStake);\n    }\n\n    /**\n     * @notice Commits a vote and logs an event with a data blob, typically an encrypted version of the vote\n     * @dev An encrypted version of the vote is emitted in an event EncryptedVote to allow off-chain infrastructure to\n     * retrieve the commit. The contents of encryptedVote are never used on chain: it is purely for convenience.\n     * @param identifier unique price pair identifier. E.g. BTC/USD price pair.\n     * @param time unix timestamp of the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param hash keccak256 hash of the price you want to vote for and a int256 salt.\n     * @param encryptedVote offchain encrypted blob containing the voter's amount, time and salt.\n     */\n    function commitAndEmitEncryptedVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash,\n        bytes memory encryptedVote\n    ) public override {\n        commitVote(identifier, time, ancillaryData, hash);\n        emit EncryptedVote(msg.sender, getCurrentRoundId(), identifier, time, ancillaryData, encryptedVote);\n    }\n\n    /****************************************\n     *        VOTING GETTER FUNCTIONS       *\n     ****************************************/\n\n    /**\n     * @notice Gets the requests that are being voted on this round.\n     * @dev This view method returns requests with Active status that may be ahead of the stored contract state as this\n     * also filters out requests that would be resolvable or deleted if the resolvable requests were processed with the\n     * processResolvablePriceRequests() method.\n     * @return pendingRequests array containing identifiers of type PendingRequestAncillaryAugmented.\n     */\n    function getPendingRequests() public view override returns (PendingRequestAncillaryAugmented[] memory) {\n        // Solidity memory arrays aren't resizable (and reading storage is expensive). Hence this hackery to filter\n        // pendingPriceRequestsIds only to those requests that have an Active RequestStatus.\n        PendingRequestAncillaryAugmented[] memory unresolved =\n            new PendingRequestAncillaryAugmented[](pendingPriceRequestsIds.length);\n        uint256 numUnresolved = 0;\n        uint32 currentRoundId = getCurrentRoundId();\n\n        for (uint256 i = 0; i < pendingPriceRequestsIds.length; i = unsafe_inc(i)) {\n            PriceRequest storage priceRequest = priceRequests[pendingPriceRequestsIds[i]];\n            if (_getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active) {\n                unresolved[numUnresolved] = PendingRequestAncillaryAugmented({\n                    lastVotingRound: priceRequest.lastVotingRound,\n                    isGovernance: priceRequest.isGovernance,\n                    time: priceRequest.time,\n                    rollCount: _getActualRollCount(priceRequest, currentRoundId),\n                    identifier: priceRequest.identifier,\n                    ancillaryData: priceRequest.ancillaryData\n                });\n                numUnresolved++;\n            }\n        }\n\n        PendingRequestAncillaryAugmented[] memory pendingRequests =\n            new PendingRequestAncillaryAugmented[](numUnresolved);\n        for (uint256 i = 0; i < numUnresolved; i = unsafe_inc(i)) pendingRequests[i] = unresolved[i];\n\n        return pendingRequests;\n    }\n\n    /**\n     * @notice Checks if there are current active requests.\n     * @return bool true if there are active requests, false otherwise.\n     */\n    function currentActiveRequests() public view returns (bool) {\n        uint32 currentRoundId = getCurrentRoundId();\n        for (uint256 i = 0; i < pendingPriceRequestsIds.length; i = unsafe_inc(i))\n            if (_getRequestStatus(priceRequests[pendingPriceRequestsIds[i]], currentRoundId) == RequestStatus.Active)\n                return true;\n\n        return false;\n    }\n\n    /**\n     * @notice Returns the current voting phase, as a function of the current time.\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES }.\n     */\n    function getVotePhase() public view override returns (Phase) {\n        return Phase(uint256(voteTiming.computeCurrentPhase(getCurrentTime())));\n    }\n\n    /**\n     * @notice Returns the current round ID, as a function of the current time.\n     * @return uint32 the unique round ID.\n     */\n    function getCurrentRoundId() public view override returns (uint32) {\n        return uint32(voteTiming.computeCurrentRoundId(getCurrentTime()));\n    }\n\n    /**\n     * @notice Returns the round end time, as a function of the round number.\n     * @param roundId representing the unique round ID.\n     * @return uint256 representing the round end time.\n     */\n    function getRoundEndTime(uint256 roundId) external view returns (uint256) {\n        return voteTiming.computeRoundEndTime(roundId);\n    }\n\n    /**\n     * @notice Returns the number of current pending price requests to be voted and the number of resolved price\n       requests over all time.\n     * @dev This method might return stale values if the state of the contract has changed since the last time\n       `processResolvablePriceRequests()` was called. To get the most up-to-date values, call\n       `getNumberOfPriceRequestsPostUpdate()` instead.\n     * @return numberPendingPriceRequests the total number of pending prices requests.\n     * @return numberResolvedPriceRequests the total number of prices resolved over all time.\n     */\n    function getNumberOfPriceRequests()\n        public\n        view\n        returns (uint256 numberPendingPriceRequests, uint256 numberResolvedPriceRequests)\n    {\n        return (pendingPriceRequestsIds.length, resolvedPriceRequestIds.length);\n    }\n\n    /**\n     * @notice Returns the number of current pending price requests to be voted and the number of resolved price\n       requests over all time after processing any resolvable price requests.\n     * @return numberPendingPriceRequests the total number of pending prices requests.\n     * @return numberResolvedPriceRequests the total number of prices resolved over all time.\n     */\n    function getNumberOfPriceRequestsPostUpdate()\n        external\n        returns (uint256 numberPendingPriceRequests, uint256 numberResolvedPriceRequests)\n    {\n        processResolvablePriceRequests();\n        return getNumberOfPriceRequests();\n    }\n\n    /**\n     * @notice Returns aggregate slashing trackers for a given request index.\n     * @param requestIndex requestIndex the index of the request to fetch slashing trackers for.\n     * @return SlashingTracker Tracker object contains the slashed UMA per staked UMA per wrong vote and no vote, the\n     * total UMA slashed in the round and the total number of correct votes in the round.\n     */\n    function requestSlashingTrackers(uint256 requestIndex) public view returns (SlashingTracker memory) {\n        PriceRequest storage priceRequest = priceRequests[resolvedPriceRequestIds[requestIndex]];\n        uint32 lastVotingRound = priceRequest.lastVotingRound;\n        VoteInstance storage voteInstance = priceRequest.voteInstances[lastVotingRound];\n\n        uint256 totalVotes = voteInstance.results.totalVotes;\n        uint256 totalCorrectVotes = voteInstance.results.getTotalCorrectlyVotedTokens();\n        uint256 totalStaked = rounds[lastVotingRound].cumulativeStakeAtRound;\n\n        (uint256 wrongVoteSlash, uint256 noVoteSlash) =\n            rounds[lastVotingRound].slashingLibrary.calcSlashing(\n                totalStaked,\n                totalVotes,\n                totalCorrectVotes,\n                requestIndex,\n                priceRequest.isGovernance\n            );\n\n        uint256 totalSlashed =\n            ((noVoteSlash * (totalStaked - totalVotes)) + (wrongVoteSlash * (totalVotes - totalCorrectVotes))) / 1e18;\n\n        return SlashingTracker(wrongVoteSlash, noVoteSlash, totalSlashed, totalCorrectVotes, lastVotingRound);\n    }\n\n    /**\n     * @notice Returns the voter's participation in the vote for a given request index.\n     * @param requestIndex requestIndex the index of the request to fetch slashing trackers for.\n     * @param lastVotingRound the round to get voter participation for.\n     * @param voter the voter to get participation for.\n     * @return VoteParticipation enum representing the voter's participation in the vote.\n     */\n    function getVoterParticipation(\n        uint256 requestIndex,\n        uint32 lastVotingRound,\n        address voter\n    ) public view returns (VoteParticipation) {\n        VoteInstance storage voteInstance =\n            priceRequests[resolvedPriceRequestIds[requestIndex]].voteInstances[lastVotingRound];\n        bytes32 revealHash = voteInstance.voteSubmissions[voter].revealHash;\n        if (revealHash == bytes32(0)) return VoteParticipation.DidNotVote;\n        if (voteInstance.results.wasVoteCorrect(revealHash)) return VoteParticipation.CorrectVote;\n        return VoteParticipation.WrongVote;\n    }\n\n    /****************************************\n     *        OWNER ADMIN FUNCTIONS         *\n     ****************************************/\n\n    /**\n     * @notice Disables this Voting contract in favor of the migrated one.\n     * @dev Can only be called by the contract owner.\n     * @param newVotingAddress the newly migrated contract address.\n     */\n    function setMigrated(address newVotingAddress) external override onlyOwner {\n        migratedAddress = newVotingAddress;\n        emit VotingContractMigrated(newVotingAddress);\n    }\n\n    /**\n     * @notice Sets the maximum number of rounds to roll a request can have before the DVM auto deletes it.\n     * @dev Can only be called by the contract owner.\n     * @param newMaxRolls the new number of rounds to roll a request before the DVM auto deletes it.\n     */\n    function setMaxRolls(uint32 newMaxRolls) public override onlyOwner {\n        // Changes to max rolls can impact unresolved requests. To protect against this process requests first.\n        processResolvablePriceRequests();\n        maxRolls = newMaxRolls;\n        emit MaxRollsChanged(newMaxRolls);\n    }\n\n    /**\n     * @notice Sets the maximum number of requests that can be made in a single round. Used to bound the maximum\n     * sequential slashing that can be applied within a single round.\n     * @dev Can only be called by the contract owner.\n     * @param newMaxRequestsPerRound the new maximum number of requests that can be made in a single round.\n     */\n    function setMaxRequestPerRound(uint32 newMaxRequestsPerRound) public override onlyOwner {\n        require(newMaxRequestsPerRound > 0);\n        maxRequestsPerRound = newMaxRequestsPerRound;\n        emit MaxRequestsPerRoundChanged(newMaxRequestsPerRound);\n    }\n\n    /**\n     * @notice Resets the GAT number and SPAT percentage. GAT is the minimum number of tokens that must participate in a\n     * vote for it to resolve (quorum number). SPAT is the minimum percentage of tokens that must agree on a result\n     * for it to resolve (percentage of staked tokens) This change only applies to subsequent rounds.\n     * @param newGat sets the next round's GAT and going forward.\n     * @param newSpat sets the next round's SPAT and going forward.\n     */\n    function setGatAndSpat(uint128 newGat, uint64 newSpat) public override onlyOwner {\n        require(newGat < votingToken.totalSupply() && newGat > 0);\n        require(newSpat > 0 && newSpat < 1e18);\n        gat = newGat;\n        spat = newSpat;\n\n        emit GatAndSpatChanged(newGat, newSpat);\n    }\n\n    /**\n     * @notice Changes the slashing library used by this contract.\n     * @param _newSlashingLibrary new slashing library address.\n     */\n    function setSlashingLibrary(address _newSlashingLibrary) public override onlyOwner {\n        slashingLibrary = SlashingLibraryInterface(_newSlashingLibrary);\n        emit SlashingLibraryChanged(_newSlashingLibrary);\n    }\n\n    /****************************************\n     *          STAKING FUNCTIONS           *\n     ****************************************/\n\n    /**\n     * @notice Updates the voter's trackers for staking and slashing. Applies all unapplied slashing to given staker.\n     * @dev Can be called by anyone, but it is not necessary for the contract to function is run the other functions.\n     * @param voter address of the voter to update the trackers for.\n     */\n    function updateTrackers(address voter) external {\n        _updateTrackers(voter);\n    }\n\n    /**\n     * @notice Updates the voter's trackers for staking and voting, specifying a maximum number of resolved requests to\n     * traverse. This function can be used in place of updateTrackers to process the trackers in batches, hence avoiding\n     * potential issues if the number of elements to be processed is large and the associated gas cost is too high.\n     * @param voter address of the voter to update the trackers for.\n     * @param maxTraversals maximum number of resolved requests to traverse in this call.\n     */\n    function updateTrackersRange(address voter, uint64 maxTraversals) external {\n        processResolvablePriceRequests();\n        _updateAccountSlashingTrackers(voter, maxTraversals);\n    }\n\n    // Updates the global and selected wallet's trackers for staking and voting. Note that the order of these calls is\n    // very important due to the interplay between slashing and inactive/active liquidity.\n    function _updateTrackers(address voter) internal override {\n        processResolvablePriceRequests();\n        _updateAccountSlashingTrackers(voter, UINT64_MAX);\n        super._updateTrackers(voter);\n    }\n\n    /**\n     * @notice Process and resolve all resolvable price requests. This function traverses all pending price requests and\n     *  resolves them if they are resolvable. It also rolls and deletes requests, if required.\n     */\n    function processResolvablePriceRequests() public {\n        _processResolvablePriceRequests(UINT64_MAX);\n    }\n\n    /**\n     * @notice Process and resolve all resolvable price requests. This function traverses all pending price requests and\n     * resolves them if they are resolvable. It also rolls and deletes requests, if required. This function can be used\n     * in place of processResolvablePriceRequests to process the requests in batches, hence avoiding potential issues if\n     * the number of elements to be processed is large and the associated gas cost is too high.\n     * @param maxTraversals maximum number of resolved requests to traverse in this call.\n     */\n    function processResolvablePriceRequestsRange(uint64 maxTraversals) external {\n        _processResolvablePriceRequests(maxTraversals);\n    }\n\n    // Starting index for a staker is the first value that nextIndexToProcess is set to and defines the first index that\n    // a staker is suspectable to receiving slashing on. This is set to current length of the resolvedPriceRequestIds.\n    // Note first call processResolvablePriceRequests to ensure that the resolvedPriceRequestIds array is up to date.\n    function _getStartingIndexForStaker() internal override returns (uint64) {\n        processResolvablePriceRequests();\n        return SafeCast.toUint64(resolvedPriceRequestIds.length);\n    }\n\n    // Checks if we are in an active voting reveal phase (currently revealing votes). This impacts if a new staker's\n    // stake should be activated immediately or if it should be frozen until the end of the reveal phase.\n    function _inActiveReveal() internal view override returns (bool) {\n        return (currentActiveRequests() && getVotePhase() == Phase.Reveal);\n    }\n\n    // This function must be called before any tokens are staked. It updates the voter's pending stakes to reflect the\n    // new amount to stake. These updates are only made if we are in an active reveal. This is required to appropriately\n    // calculate a voter's trackers and avoid slashing them for amounts staked during an active reveal phase.\n    function _computePendingStakes(address voter, uint128 amount) internal override {\n        if (_inActiveReveal()) {\n            uint32 currentRoundId = getCurrentRoundId();\n            // Freeze round variables to prevent cumulativeActiveStakeAtRound from changing based on the stakes during\n            // the active reveal phase. This will happen if the first action within the reveal is someone staking.\n            _freezeRoundVariables(currentRoundId);\n            // Increment pending stake for voter by amount. With the omission of stake from cumulativeActiveStakeAtRound\n            // for this round, ensure that the pending stakes is not included in the slashing calculation for this round.\n            _incrementPendingStake(voter, currentRoundId, amount);\n        }\n    }\n\n    // Updates the slashing trackers of a given account based on previous voting activity. This traverses all resolved\n    // requests for each voter and for each request checks if the voter voted correctly or not. Based on the voters\n    // voting activity the voters balance is updated accordingly. The caller can provide a maxTraversals parameter to\n    // limit the number of resolved requests to traverse in this call to bound the gas used. Note each iteration of\n    // this function re-uses a fresh slash variable to produce useful logs on the amount a voter is slashed.\n    function _updateAccountSlashingTrackers(address voter, uint64 maxTraversals) internal {\n        VoterStake storage voterStake = voterStakes[voter];\n        uint64 requestIndex = voterStake.nextIndexToProcess; // Traverse all requests from the last considered request.\n\n        // Traverse all elements within the resolvedPriceRequestIds array and update the voter's trackers according to\n        // their voting activity. Bound the number of iterations to the maxTraversals parameter to cap the gas used.\n        while (requestIndex < resolvedPriceRequestIds.length && maxTraversals > 0) {\n            maxTraversals = unsafe_dec_64(maxTraversals); // reduce the number of traversals left & re-use the prop.\n\n            // Get the slashing for this request. This comes from the slashing library and informs to the voter slash.\n            SlashingTracker memory trackers = requestSlashingTrackers(requestIndex);\n\n            // Use the effective stake as the difference between the current stake and pending stake. The staker will\n            //have a pending stake if they staked during an active reveal for the voting round in question.\n            uint256 effectiveStake = voterStake.stake - voterStake.pendingStakes[trackers.lastVotingRound];\n            int256 slash; // The amount to slash the voter by for this request. Reset on each entry to emit useful logs.\n\n            // Get the voter participation for this request. This informs if the voter voted correctly or not.\n            VoteParticipation participation = getVoterParticipation(requestIndex, trackers.lastVotingRound, voter);\n\n            // The voter did not reveal or did not commit. Slash at noVote rate.\n            if (participation == VoteParticipation.DidNotVote)\n                slash = -int256(Math.ceilDiv(effectiveStake * trackers.noVoteSlashPerToken, 1e18));\n\n                // The voter did not vote with the majority. Slash at wrongVote rate.\n            else if (participation == VoteParticipation.WrongVote)\n                slash = -int256(Math.ceilDiv(effectiveStake * trackers.wrongVoteSlashPerToken, 1e18));\n\n                // Else, the voter voted correctly. Receive a pro-rate share of the other voters slash.\n            else slash = int256((effectiveStake * trackers.totalSlashed) / trackers.totalCorrectVotes);\n\n            emit VoterSlashed(voter, requestIndex, int128(slash));\n            voterStake.unappliedSlash += int128(slash);\n\n            // If the next round is different to the current considered round, apply the slash to the voter.\n            if (isNextRequestRoundDifferent(requestIndex)) _applySlashToVoter(voterStake, voter);\n\n            requestIndex = unsafe_inc_64(requestIndex); // Increment the request index.\n        }\n\n        // Set the account's nextIndexToProcess to the requestIndex so the next entry starts where we left off.\n        voterStake.nextIndexToProcess = requestIndex;\n    }\n\n    // Applies a given slash to a given voter's stake. In the event the sum of the slash and the voter's stake is less\n    // than 0, the voter's stake is set to 0 to prevent the voter's stake from going negative. unappliedSlash tracked\n    // all slashing the staker has received but not yet applied to their stake. Apply it then set it to zero.\n    function _applySlashToVoter(VoterStake storage voterStake, address voter) internal {\n        if (voterStake.unappliedSlash + int128(voterStake.stake) > 0)\n            voterStake.stake = uint128(int128(voterStake.stake) + voterStake.unappliedSlash);\n        else voterStake.stake = 0;\n        emit VoterSlashApplied(voter, voterStake.unappliedSlash, voterStake.stake);\n        voterStake.unappliedSlash = 0;\n    }\n\n    // Checks if the next round (index+1) is different to the current round (index).\n    function isNextRequestRoundDifferent(uint64 index) internal view returns (bool) {\n        if (index + 1 >= resolvedPriceRequestIds.length) return true;\n\n        return\n            priceRequests[resolvedPriceRequestIds[index]].lastVotingRound !=\n            priceRequests[resolvedPriceRequestIds[index + 1]].lastVotingRound;\n    }\n\n    /****************************************\n     *      MIGRATION SUPPORT FUNCTIONS     *\n     ****************************************/\n\n    /**\n     * @notice Enable retrieval of rewards on a previously migrated away from voting contract. This function is intended\n     * on being removed from future versions of the Voting contract and aims to solve a short term migration pain point.\n     * @param voter voter for which rewards will be retrieved. Does not have to be the caller.\n     * @param roundId the round from which voting rewards will be retrieved from.\n     * @param toRetrieve array of PendingRequests which rewards are retrieved from.\n     * @return uint256 the amount of rewards.\n     */\n    function retrieveRewardsOnMigratedVotingContract(\n        address voter,\n        uint256 roundId,\n        MinimumVotingAncillaryInterface.PendingRequestAncillary[] memory toRetrieve\n    ) external returns (uint256) {\n        uint256 rewards =\n            MinimumVotingAncillaryInterface(address(previousVotingContract))\n                .retrieveRewards(voter, roundId, toRetrieve)\n                .rawValue;\n        return rewards;\n    }\n\n    /****************************************\n     *    PRIVATE AND INTERNAL FUNCTIONS    *\n     ****************************************/\n\n    // Deletes a request from the pending requests array, based on index. Swap and pop.\n    function _removeRequestFromPendingPriceRequestsIds(uint64 pendingRequestIndex) internal {\n        pendingPriceRequestsIds[pendingRequestIndex] = pendingPriceRequestsIds[pendingPriceRequestsIds.length - 1];\n        pendingPriceRequestsIds.pop();\n    }\n\n    // Returns the price for a given identifier. Three params are returns: bool if there was an error, int to represent\n    // the resolved price and a string which is filled with an error message, if there was an error or \"\".\n    // This method considers actual request status that might be ahead of the stored contract state that gets updated\n    // only after processResolvablePriceRequests() is called.\n    function _getPriceOrError(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    )\n        internal\n        view\n        returns (\n            bool,\n            int256,\n            string memory\n        )\n    {\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time, ancillaryData);\n        uint32 currentRoundId = getCurrentRoundId();\n        RequestStatus requestStatus = _getRequestStatus(priceRequest, currentRoundId);\n\n        if (requestStatus == RequestStatus.Active) return (false, 0, \"Current voting round not ended\");\n        if (requestStatus == RequestStatus.Resolved) {\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n            (, int256 resolvedPrice) = _getResolvedPrice(voteInstance, priceRequest.lastVotingRound);\n            return (true, resolvedPrice, \"\");\n        }\n\n        if (requestStatus == RequestStatus.Future) return (false, 0, \"Price is still to be voted on\");\n        if (requestStatus == RequestStatus.ToDelete) return (false, 0, \"Price will be deleted\");\n        (bool previouslyResolved, int256 previousPrice) =\n            _getPriceFromPreviousVotingContract(identifier, time, ancillaryData);\n        if (previouslyResolved) return (true, previousPrice, \"\");\n        return (false, 0, \"Price was never requested\");\n    }\n\n    // Check the previousVotingContract to see if a given price request was resolved.\n    // Returns true or false, and the resolved price or zero, depending on whether it was found or not.\n    function _getPriceFromPreviousVotingContract(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) private view returns (bool, int256) {\n        if (address(previousVotingContract) == address(0)) return (false, 0);\n        if (previousVotingContract.hasPrice(identifier, time, ancillaryData))\n            return (true, previousVotingContract.getPrice(identifier, time, ancillaryData));\n        return (false, 0);\n    }\n\n    // Returns a price request object for a given identifier, time and ancillary data.\n    function _getPriceRequest(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) private view returns (PriceRequest storage) {\n        return priceRequests[_encodePriceRequest(identifier, time, ancillaryData)];\n    }\n\n    // Returns an encoded bytes32 representing a price request. Used when storing/referencing price requests.\n    function _encodePriceRequest(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) private pure returns (bytes32) {\n        return keccak256(abi.encode(identifier, time, ancillaryData));\n    }\n\n    // Stores (\"freezes\") variables that should not shift within an active voting round. Called on reveal but only makes\n    // a state change if and only if the this is the first reveal.\n    function _freezeRoundVariables(uint256 roundId) private {\n        // Only freeze the round if this is the first request in the round.\n        if (rounds[roundId].minParticipationRequirement == 0) {\n            rounds[roundId].slashingLibrary = slashingLibrary;\n\n            // The minimum required participation for a vote to settle within this round is the GAT (fixed number).\n            rounds[roundId].minParticipationRequirement = gat;\n\n            // The minimum votes on the modal outcome for the vote to settle within this round is the SPAT (percentage).\n            rounds[roundId].minAgreementRequirement = uint128((spat * uint256(cumulativeStake)) / 1e18);\n            rounds[roundId].cumulativeStakeAtRound = cumulativeStake; // Store the cumulativeStake to work slashing.\n        }\n    }\n\n    // Traverse pending price requests and resolve any that are resolvable. If requests are rollable (they did not\n    // resolve in the previous round and are to be voted in a subsequent round) then roll them. If requests can be\n    // deleted (they have been rolled up to the maxRolls counter) then delete them. The caller can pass in maxTraversals\n    // to limit the number of requests that are resolved in a single call to bound the total gas used by this function.\n    // Note that the resolved index is stores for each round. This means that only the first caller of this function\n    // per round needs to traverse the pending requests. After that subsequent calls to this are a no-op for that round.\n    function _processResolvablePriceRequests(uint64 maxTraversals) private {\n        uint32 currentRoundId = getCurrentRoundId();\n\n        // Load in the last resolved index for this round to continue off from where the last caller left.\n        uint64 requestIndex = lastRoundIdProcessed == currentRoundId ? nextPendingIndexToProcess : 0;\n        // Traverse pendingPriceRequestsIds array and update the requests status according to the state of the request\n        //(i.e settle, roll or delete request). Bound iterations to the maxTraversals parameter to cap the gas used.\n        while (requestIndex < pendingPriceRequestsIds.length && maxTraversals > 0) {\n            maxTraversals = unsafe_dec_64(maxTraversals);\n            PriceRequest storage request = priceRequests[pendingPriceRequestsIds[requestIndex]];\n\n            // If the last voting round is greater than or equal to the current round then this request is currently\n            // being voted on or is enqueued for the next round. In this case, skip it and increment the request index.\n            if (request.lastVotingRound >= currentRoundId) {\n                requestIndex = unsafe_inc_64(requestIndex);\n                continue; // Continue to the next request.\n            }\n\n            // Else, we are dealing with a request that can either be: a) deleted, b) rolled or c) resolved.\n            VoteInstance storage voteInstance = request.voteInstances[request.lastVotingRound];\n            (bool isResolvable, int256 resolvedPrice) = _getResolvedPrice(voteInstance, request.lastVotingRound);\n\n            if (isResolvable) {\n                // If resolvable, resolve. This involves a) moving the requestId from pendingPriceRequestsIds array to\n                // resolvedPriceRequestIds array and b) removing requestId from pendingPriceRequestsIds. Don't need to\n                // increment requestIndex as from pendingPriceRequestsIds amounts to decreasing the while loop bound.\n                resolvedPriceRequestIds.push(pendingPriceRequestsIds[requestIndex]);\n                _removeRequestFromPendingPriceRequestsIds(requestIndex);\n                emit RequestResolved(\n                    request.lastVotingRound,\n                    resolvedPriceRequestIds.length - 1,\n                    request.identifier,\n                    request.time,\n                    request.ancillaryData,\n                    resolvedPrice\n                );\n                continue; // Continue to the next request.\n            }\n            // If not resolvable, but the round has passed its voting round, then it must be deleted or rolled. First,\n            // increment the rollCount. Use the difference between the current round and the last voting round to\n            // accommodate the contract not being touched for any number of rounds during the roll.\n            request.rollCount += currentRoundId - request.lastVotingRound;\n\n            // If the roll count exceeds the threshold and the request is not governance then it is deletable.\n            if (_shouldDeleteRequest(request.rollCount, request.isGovernance)) {\n                emit RequestDeleted(request.identifier, request.time, request.ancillaryData, request.rollCount);\n                delete priceRequests[pendingPriceRequestsIds[requestIndex]];\n                _removeRequestFromPendingPriceRequestsIds(requestIndex);\n                continue;\n            }\n            // Else, the request should be rolled. This involves only moving forward the lastVotingRound.\n            request.lastVotingRound = getRoundIdToVoteOnRequest(currentRoundId);\n            ++rounds[request.lastVotingRound].numberOfRequestsToVote;\n            emit RequestRolled(request.identifier, request.time, request.ancillaryData, request.rollCount);\n            requestIndex = unsafe_inc_64(requestIndex);\n        }\n\n        lastRoundIdProcessed = currentRoundId; // Store the roundId that was processed.\n        nextPendingIndexToProcess = requestIndex; // Store the index traversed up to for this round.\n    }\n\n    // Returns a price request status. A request is either: NotRequested, Active, Resolved, Future or ToDelete.\n    function _getRequestStatus(PriceRequest storage priceRequest, uint32 currentRoundId)\n        private\n        view\n        returns (RequestStatus)\n    {\n        if (priceRequest.lastVotingRound == 0) return RequestStatus.NotRequested;\n        if (priceRequest.lastVotingRound < currentRoundId) {\n            // Check if the request has already been resolved\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n            (bool isResolved, ) = _getResolvedPrice(voteInstance, priceRequest.lastVotingRound);\n            if (isResolved) return RequestStatus.Resolved;\n            if (_shouldDeleteRequest(_getActualRollCount(priceRequest, currentRoundId), priceRequest.isGovernance))\n                return RequestStatus.ToDelete;\n            return RequestStatus.Active;\n        }\n        if (priceRequest.lastVotingRound == currentRoundId) return RequestStatus.Active;\n\n        return RequestStatus.Future; // Means than priceRequest.lastVotingRound > currentRoundId\n    }\n\n    function _getResolvedPrice(VoteInstance storage voteInstance, uint256 lastVotingRound)\n        internal\n        view\n        returns (bool isResolved, int256 price)\n    {\n        return\n            voteInstance.results.getResolvedPrice(\n                rounds[lastVotingRound].minParticipationRequirement,\n                rounds[lastVotingRound].minAgreementRequirement\n            );\n    }\n\n    // Gas optimized uint256 increment.\n    function unsafe_inc(uint256 x) internal pure returns (uint256) {\n        unchecked { return x + 1; }\n    }\n\n    // Gas optimized uint64 increment.\n    function unsafe_inc_64(uint64 x) internal pure returns (uint64) {\n        unchecked { return x + 1; }\n    }\n\n    // Gas optimized uint64 decrement.\n    function unsafe_dec_64(uint64 x) internal pure returns (uint64) {\n        unchecked { return x - 1; }\n    }\n\n    // Returns the registered identifier whitelist, stored in the finder.\n    function _getIdentifierWhitelist() private view returns (IdentifierWhitelistInterface) {\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\n    }\n\n    // Reverts if the contract has been migrated. Used in a modifier, defined as a private function for gas savings.\n    function _requireNotMigrated() private view {\n        require(migratedAddress == address(0), \"Contract migrated\");\n    }\n\n    // Enforces that a calling contract is registered.\n    function _requireRegisteredContract() private view {\n        RegistryInterface registry = RegistryInterface(finder.getImplementationAddress(OracleInterfaces.Registry));\n        require(registry.isContractRegistered(msg.sender) || msg.sender == migratedAddress, \"Caller not registered\");\n    }\n\n    // Checks if a request should be deleted. A non-gevernance request should be deleted if it has been rolled more than\n    // the maxRolls.\n    function _shouldDeleteRequest(uint256 rollCount, bool isGovernance) private view returns (bool) {\n        return rollCount > maxRolls && !isGovernance;\n    }\n\n    // Returns the actual roll count of a request. This is the roll count plus the number of rounds that have passed\n    // since the last voting round.\n    function _getActualRollCount(PriceRequest storage priceRequest, uint32 currentRoundId)\n        private\n        view\n        returns (uint32)\n    {\n        if (currentRoundId <= priceRequest.lastVotingRound) return priceRequest.rollCount;\n        return priceRequest.rollCount + currentRoundId - priceRequest.lastVotingRound;\n    }\n}\n"
75     },
76     "contracts/data-verification-mechanism/interfaces/FinderInterface.sol": {
77       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Provides addresses of the live contracts implementing certain interfaces.\n * @dev Examples are the Oracle or Store interfaces.\n */\ninterface FinderInterface {\n    /**\n     * @notice Updates the address of the contract that implements `interfaceName`.\n     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\n     * @param implementationAddress address of the deployed contract that implements the interface.\n     */\n    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;\n\n    /**\n     * @notice Gets the address of the contract that implements the given `interfaceName`.\n     * @param interfaceName queried interface.\n     * @return implementationAddress address of the deployed contract that implements the interface.\n     */\n    function getImplementationAddress(bytes32 interfaceName) external view returns (address);\n}\n"
78     },
79     "contracts/data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol": {
80       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Interface for whitelists of supported identifiers that the oracle can provide prices for.\n */\ninterface IdentifierWhitelistInterface {\n    /**\n     * @notice Adds the provided identifier as a supported identifier.\n     * @dev Price requests using this identifier will succeed after this call.\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n     */\n    function addSupportedIdentifier(bytes32 identifier) external;\n\n    /**\n     * @notice Removes the identifier from the whitelist.\n     * @dev Price requests using this identifier will no longer succeed after this call.\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n     */\n    function removeSupportedIdentifier(bytes32 identifier) external;\n\n    /**\n     * @notice Checks whether an identifier is on the whitelist.\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n     * @return bool if the identifier is supported (or not).\n     */\n    function isIdentifierSupported(bytes32 identifier) external view returns (bool);\n}\n"
81     },
82     "contracts/data-verification-mechanism/interfaces/MinimumVotingAncillaryInterface.sol": {
83       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\ninterface MinimumVotingAncillaryInterface {\n    struct Unsigned {\n        uint256 rawValue;\n    }\n\n    struct PendingRequestAncillary {\n        bytes32 identifier;\n        uint256 time;\n        bytes ancillaryData;\n    }\n\n    function retrieveRewards(\n        address voterAddress,\n        uint256 roundId,\n        PendingRequestAncillary[] memory toRetrieve\n    ) external returns (Unsigned memory);\n}\n"
84     },
85     "contracts/data-verification-mechanism/interfaces/OracleAncillaryInterface.sol": {
86       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Financial contract facing Oracle interface.\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n */\nabstract contract OracleAncillaryInterface {\n    /**\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\n     * @dev Time must be in the past and the identifier must be supported.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param time unix timestamp for the price request.\n     */\n\n    function requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public virtual;\n\n    /**\n     * @notice Whether the price for `identifier` and `time` is available.\n     * @dev Time must be in the past and the identifier must be supported.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @return bool if the DVM has resolved to a price for the given identifier and timestamp.\n     */\n    function hasPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view virtual returns (bool);\n\n    /**\n     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\n     * @dev If the price is not available, the method reverts.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @return int256 representing the resolved price for the given identifier and timestamp.\n     */\n\n    function getPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view virtual returns (int256);\n}\n"
87     },
88     "contracts/data-verification-mechanism/interfaces/OracleGovernanceInterface.sol": {
89       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./OracleInterface.sol\";\nimport \"./OracleAncillaryInterface.sol\";\n\n/**\n * @title Financial contract facing extending the Oracle interface with governance actions.\n * @dev Interface used by financial contracts to interact with the Oracle extending governance actions. Voters will use a different interface.\n */\nabstract contract OracleGovernanceInterface is OracleInterface, OracleAncillaryInterface {\n    /**\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\n     * @dev Time must be in the past and the identifier must be supported.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param time unix timestamp for the price request.\n     */\n    function requestGovernanceAction(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) external virtual;\n}\n"
90     },
91     "contracts/data-verification-mechanism/interfaces/OracleInterface.sol": {
92       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Financial contract facing Oracle interface.\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n */\nabstract contract OracleInterface {\n    /**\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\n     * @dev Time must be in the past and the identifier must be supported.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     */\n    function requestPrice(bytes32 identifier, uint256 time) external virtual;\n\n    /**\n     * @notice Whether the price for `identifier` and `time` is available.\n     * @dev Time must be in the past and the identifier must be supported.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     * @return bool if the DVM has resolved to a price for the given identifier and timestamp.\n     */\n    function hasPrice(bytes32 identifier, uint256 time) external view virtual returns (bool);\n\n    /**\n     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\n     * @dev If the price is not available, the method reverts.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     * @return int256 representing the resolved price for the given identifier and timestamp.\n     */\n    function getPrice(bytes32 identifier, uint256 time) external view virtual returns (int256);\n}\n"
93     },
94     "contracts/data-verification-mechanism/interfaces/RegistryInterface.sol": {
95       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Interface for a registry of contracts and contract creators.\n */\ninterface RegistryInterface {\n    /**\n     * @notice Registers a new contract.\n     * @dev Only authorized contract creators can call this method.\n     * @param parties an array of addresses who become parties in the contract.\n     * @param contractAddress defines the address of the deployed contract.\n     */\n    function registerContract(address[] calldata parties, address contractAddress) external;\n\n    /**\n     * @notice Returns whether the contract has been registered with the registry.\n     * @dev If it is registered, it is an authorized participant in the UMA system.\n     * @param contractAddress address of the contract.\n     * @return bool indicates whether the contract is registered.\n     */\n    function isContractRegistered(address contractAddress) external view returns (bool);\n\n    /**\n     * @notice Returns a list of all contracts that are associated with a particular party.\n     * @param party address of the party.\n     * @return an array of the contracts the party is registered to.\n     */\n    function getRegisteredContracts(address party) external view returns (address[] memory);\n\n    /**\n     * @notice Returns all registered contracts.\n     * @return all registered contract addresses within the system.\n     */\n    function getAllRegisteredContracts() external view returns (address[] memory);\n\n    /**\n     * @notice Adds a party to the calling contract.\n     * @dev msg.sender must be the contract to which the party member is added.\n     * @param party address to be added to the contract.\n     */\n    function addPartyToContract(address party) external;\n\n    /**\n     * @notice Removes a party member to the calling contract.\n     * @dev msg.sender must be the contract to which the party member is added.\n     * @param party address to be removed from the contract.\n     */\n    function removePartyFromContract(address party) external;\n\n    /**\n     * @notice checks if an address is a party in a contract.\n     * @param party party to check.\n     * @param contractAddress address to check against the party.\n     * @return bool indicating if the address is a party of the contract.\n     */\n    function isPartyMemberOfContract(address party, address contractAddress) external view returns (bool);\n}\n"
96     },
97     "contracts/data-verification-mechanism/interfaces/SlashingLibraryInterface.sol": {
98       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\ninterface SlashingLibraryInterface {\n    /**\n     * @notice Calculates the wrong vote slash per token.\n     * @param totalStaked The total amount of tokens staked.\n     * @param totalVotes The total amount of votes.\n     * @param totalCorrectVotes The total amount of correct votes.\n     * @param priceRequestIndex The price request index within the resolvedPriceRequestIds array.\n     * @return uint256 The amount of tokens to slash per token staked.\n     */\n    function calcWrongVoteSlashPerToken(\n        uint256 totalStaked,\n        uint256 totalVotes,\n        uint256 totalCorrectVotes,\n        uint256 priceRequestIndex\n    ) external view returns (uint256);\n\n    /**\n     * @notice Calculates the wrong vote slash per token for governance requests.\n     * @param totalStaked The total amount of tokens staked.\n     * @param totalVotes The total amount of votes.\n     * @param totalCorrectVotes The total amount of correct votes.\n     * @param priceRequestIndex The price request index within the resolvedPriceRequestIds array.\n     * @return uint256 The amount of tokens to slash per token staked.\n     */\n    function calcWrongVoteSlashPerTokenGovernance(\n        uint256 totalStaked,\n        uint256 totalVotes,\n        uint256 totalCorrectVotes,\n        uint256 priceRequestIndex\n    ) external view returns (uint256);\n\n    /**\n     * @notice Calculates the no vote slash per token.\n     * @param totalStaked The total amount of tokens staked.\n     * @param totalVotes The total amount of votes.\n     * @param totalCorrectVotes The total amount of correct votes.\n     * @param priceRequestIndex The price request index within the resolvedPriceRequestIds array.\n     * @return uint256 The amount of tokens to slash per token staked.\n     */\n    function calcNoVoteSlashPerToken(\n        uint256 totalStaked,\n        uint256 totalVotes,\n        uint256 totalCorrectVotes,\n        uint256 priceRequestIndex\n    ) external view returns (uint256);\n\n    /**\n     * @notice Calculates all slashing trackers in one go to decrease cross-contract calls needed.\n     * @param totalStaked The total amount of tokens staked.\n     * @param totalVotes The total amount of votes.\n     * @param totalCorrectVotes The total amount of correct votes.\n     * @param priceRequestIndex The price request index within the resolvedPriceRequestIds array.\n     * @param isGovernance Whether the request is a governance request.\n     * @return wrongVoteSlashPerToken The amount of tokens to slash for voting wrong.\n     * @return noVoteSlashPerToken The amount of tokens to slash for not voting.\n     */\n    function calcSlashing(\n        uint256 totalStaked,\n        uint256 totalVotes,\n        uint256 totalCorrectVotes,\n        uint256 priceRequestIndex,\n        bool isGovernance\n    ) external view returns (uint256 wrongVoteSlashPerToken, uint256 noVoteSlashPerToken);\n}\n"
99     },
100     "contracts/data-verification-mechanism/interfaces/StakerInterface.sol": {
101       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nimport \"../implementation/VotingToken.sol\";\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\n\ninterface StakerInterface {\n    function votingToken() external returns (ExpandedIERC20);\n\n    function stake(uint128 amount) external;\n\n    function requestUnstake(uint128 amount) external;\n\n    function executeUnstake() external;\n\n    function withdrawRewards() external returns (uint128);\n\n    function withdrawAndRestake() external returns (uint128);\n\n    function setEmissionRate(uint128 newEmissionRate) external;\n\n    function setUnstakeCoolDown(uint64 newUnstakeCoolDown) external;\n\n    /**\n     * @notice Sets the delegate of a voter. This delegate can vote on behalf of the staker. The staker will still own\n     * all staked balances, receive rewards and be slashed based on the actions of the delegate. Intended use is using a\n     * low-security available wallet for voting while keeping access to staked amounts secure by a more secure wallet.\n     * @param delegate the address of the delegate.\n     */\n    function setDelegate(address delegate) external virtual;\n\n    /**\n     * @notice Sets the delegator of a voter. Acts to accept a delegation. The delegate can only vote for the delegator\n     * if the delegator also selected the delegate to do so (two-way relationship needed).\n     * @param delegator the address of the delegator.\n     */\n    function setDelegator(address delegator) external virtual;\n}\n"
102     },
103     "contracts/data-verification-mechanism/interfaces/VotingAncillaryInterface.sol": {
104       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../../common/implementation/FixedPoint.sol\";\n\n/**\n * @title Interface that voters must use to Vote on price request resolutions.\n */\nabstract contract VotingAncillaryInterface {\n    struct PendingRequestAncillary {\n        bytes32 identifier;\n        uint256 time;\n        bytes ancillaryData;\n    }\n\n    // Captures the necessary data for making a commitment.\n    // Used as a parameter when making batch commitments.\n    // Not used as a data structure for storage.\n    struct CommitmentAncillary {\n        bytes32 identifier;\n        uint256 time;\n        bytes ancillaryData;\n        bytes32 hash;\n        bytes encryptedVote;\n    }\n\n    // Captures the necessary data for revealing a vote.\n    // Used as a parameter when making batch reveals.\n    // Not used as a data structure for storage.\n    struct RevealAncillary {\n        bytes32 identifier;\n        uint256 time;\n        int256 price;\n        bytes ancillaryData;\n        int256 salt;\n    }\n\n    // Note: the phases must be in order. Meaning the first enum value must be the first phase, etc.\n    // `NUM_PHASES` is to get the number of phases. It isn't an actual phase, and it should always be last.\n    enum Phase { Commit, Reveal, NUM_PHASES }\n\n    /**\n     * @notice Commit a vote for a price request for `identifier` at `time`.\n     * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.\n     * Commits can be changed.\n     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the systems expected behavior,\n     * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then\n     * they can determine the vote pre-reveal.\n     * @param identifier uniquely identifies the committed vote. E.G. BTC/USD price pair.\n     * @param time unix timestamp of the price being voted on.\n     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.\n     */\n    function commitVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash\n    ) public virtual;\n\n    /**\n     * @notice Submit a batch of commits in a single transaction.\n     * @dev Using `encryptedVote` is optional. If included then commitment is stored on chain.\n     * Look at `project-root/common/Constants.js` for the tested maximum number of\n     * commitments that can fit in one transaction.\n     * @param commits array of structs that encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.\n     */\n    function batchCommit(CommitmentAncillary[] memory commits) public virtual;\n\n    /**\n     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote\n     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to\n     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.\n     * @param identifier unique price pair identifier. E.g. BTC/USD price pair.\n     * @param time unix timestamp of for the price request.\n     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.\n     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\n     */\n    function commitAndEmitEncryptedVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash,\n        bytes memory encryptedVote\n    ) public virtual;\n\n    /**\n     * @notice snapshot the current round's token balances and lock in the inflation rate and GAT.\n     * @dev This function can be called multiple times but each round will only every have one snapshot at the\n     * time of calling `_freezeRoundVariables`.\n     * @param signature  signature required to prove caller is an EOA to prevent flash loans from being included in the\n     * snapshot.\n     */\n    function snapshotCurrentRound(bytes calldata signature) external virtual;\n\n    /**\n     * @notice Reveal a previously committed vote for `identifier` at `time`.\n     * @dev The revealed `price`, `salt`, `address`, `time`, `roundId`, and `identifier`, must hash to the latest `hash`\n     * that `commitVote()` was called with. Only the committer can reveal their vote.\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price is being voted on.\n     * @param price voted on during the commit phase.\n     * @param salt value used to hide the commitment price during the commit phase.\n     */\n    function revealVote(\n        bytes32 identifier,\n        uint256 time,\n        int256 price,\n        bytes memory ancillaryData,\n        int256 salt\n    ) public virtual;\n\n    /**\n     * @notice Reveal multiple votes in a single transaction.\n     * Look at `project-root/common/Constants.js` for the tested maximum number of reveals.\n     * that can fit in one transaction.\n     * @dev For more information on reveals, review the comment for `revealVote`.\n     * @param reveals array of the Reveal struct which contains an identifier, time, price and salt.\n     */\n    function batchReveal(RevealAncillary[] memory reveals) public virtual;\n\n    /**\n     * @notice Gets the queries that are being voted on this round.\n     * @return pendingRequests `PendingRequest` array containing identifiers\n     * and timestamps for all pending requests.\n     */\n    function getPendingRequests() external view virtual returns (PendingRequestAncillary[] memory);\n\n    /**\n     * @notice Returns the current voting phase, as a function of the current time.\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES }.\n     */\n    function getVotePhase() external view virtual returns (Phase);\n\n    /**\n     * @notice Returns the current round ID, as a function of the current time.\n     * @return uint256 representing the unique round ID.\n     */\n    function getCurrentRoundId() external view virtual returns (uint256);\n\n    /**\n     * @notice Retrieves rewards owed for a set of resolved price requests.\n     * @dev Can only retrieve rewards if calling for a valid round and if the\n     * call is done within the timeout threshold (not expired).\n     * @param voterAddress voter for which rewards will be retrieved. Does not have to be the caller.\n     * @param roundId the round from which voting rewards will be retrieved from.\n     * @param toRetrieve array of PendingRequests which rewards are retrieved from.\n     * @return total amount of rewards returned to the voter.\n     */\n    function retrieveRewards(\n        address voterAddress,\n        uint256 roundId,\n        PendingRequestAncillary[] memory toRetrieve\n    ) public virtual returns (FixedPoint.Unsigned memory);\n\n    // Voting Owner functions.\n\n    /**\n     * @notice Disables this Voting contract in favor of the migrated one.\n     * @dev Can only be called by the contract owner.\n     * @param newVotingAddress the newly migrated contract address.\n     */\n    function setMigrated(address newVotingAddress) external virtual;\n\n    /**\n     * @notice Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.\n     * @dev This method is public because calldata structs are not currently supported by solidity.\n     * @param newInflationRate sets the next round's inflation rate.\n     */\n    function setInflationRate(FixedPoint.Unsigned memory newInflationRate) public virtual;\n\n    /**\n     * @notice Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.\n     * @dev This method is public because calldata structs are not currently supported by solidity.\n     * @param newGatPercentage sets the next round's Gat percentage.\n     */\n    function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage) public virtual;\n\n    /**\n     * @notice Resets the rewards expiration timeout.\n     * @dev This change only applies to rounds that have not yet begun.\n     * @param NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.\n     */\n    function setRewardsExpirationTimeout(uint256 NewRewardsExpirationTimeout) public virtual;\n}\n"
105     },
106     "contracts/data-verification-mechanism/interfaces/VotingInterface.sol": {
107       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../../common/implementation/FixedPoint.sol\";\nimport \"./VotingAncillaryInterface.sol\";\n\n/**\n * @title Interface that voters must use to Vote on price request resolutions.\n */\nabstract contract VotingInterface {\n    struct PendingRequest {\n        bytes32 identifier;\n        uint256 time;\n    }\n\n    // Captures the necessary data for making a commitment.\n    // Used as a parameter when making batch commitments.\n    // Not used as a data structure for storage.\n    struct Commitment {\n        bytes32 identifier;\n        uint256 time;\n        bytes32 hash;\n        bytes encryptedVote;\n    }\n\n    // Captures the necessary data for revealing a vote.\n    // Used as a parameter when making batch reveals.\n    // Not used as a data structure for storage.\n    struct Reveal {\n        bytes32 identifier;\n        uint256 time;\n        int256 price;\n        int256 salt;\n    }\n\n    /**\n     * @notice Commit a vote for a price request for `identifier` at `time`.\n     * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.\n     * Commits can be changed.\n     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the systems expected behavior,\n     * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then\n     * they can determine the vote pre-reveal.\n     * @param identifier uniquely identifies the committed vote. EG BTC/USD price pair.\n     * @param time unix timestamp of the price being voted on.\n     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.\n     */\n    function commitVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes32 hash\n    ) external virtual;\n\n    /**\n     * @notice Submit a batch of commits in a single transaction.\n     * @dev Using `encryptedVote` is optional. If included then commitment is stored on chain.\n     * Look at `project-root/common/Constants.js` for the tested maximum number of\n     * commitments that can fit in one transaction.\n     * @param commits array of structs that encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.\n     */\n    function batchCommit(Commitment[] memory commits) public virtual;\n\n    /**\n     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote\n     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to\n     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.\n     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.\n     * @param time unix timestamp of for the price request.\n     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.\n     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\n     */\n    function commitAndEmitEncryptedVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes32 hash,\n        bytes memory encryptedVote\n    ) public virtual;\n\n    /**\n     * @notice snapshot the current round's token balances and lock in the inflation rate and GAT.\n     * @dev This function can be called multiple times but each round will only every have one snapshot at the\n     * time of calling `_freezeRoundVariables`.\n     * @param signature  signature required to prove caller is an EOA to prevent flash loans from being included in the\n     * snapshot.\n     */\n    function snapshotCurrentRound(bytes calldata signature) external virtual;\n\n    /**\n     * @notice Reveal a previously committed vote for `identifier` at `time`.\n     * @dev The revealed `price`, `salt`, `address`, `time`, `roundId`, and `identifier`, must hash to the latest `hash`\n     * that `commitVote()` was called with. Only the committer can reveal their vote.\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price is being voted on.\n     * @param price voted on during the commit phase.\n     * @param salt value used to hide the commitment price during the commit phase.\n     */\n    function revealVote(\n        bytes32 identifier,\n        uint256 time,\n        int256 price,\n        int256 salt\n    ) public virtual;\n\n    /**\n     * @notice Reveal multiple votes in a single transaction.\n     * Look at `project-root/common/Constants.js` for the tested maximum number of reveals.\n     * that can fit in one transaction.\n     * @dev For more information on reveals, review the comment for `revealVote`.\n     * @param reveals array of the Reveal struct which contains an identifier, time, price and salt.\n     */\n    function batchReveal(Reveal[] memory reveals) public virtual;\n\n    /**\n     * @notice Gets the queries that are being voted on this round.\n     * @return pendingRequests `PendingRequest` array containing identifiers\n     * and timestamps for all pending requests.\n     */\n    function getPendingRequests()\n        external\n        view\n        virtual\n        returns (VotingAncillaryInterface.PendingRequestAncillary[] memory);\n\n    /**\n     * @notice Returns the current voting phase, as a function of the current time.\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES }.\n     */\n    function getVotePhase() external view virtual returns (VotingAncillaryInterface.Phase);\n\n    /**\n     * @notice Returns the current round ID, as a function of the current time.\n     * @return uint256 representing the unique round ID.\n     */\n    function getCurrentRoundId() external view virtual returns (uint256);\n\n    /**\n     * @notice Retrieves rewards owed for a set of resolved price requests.\n     * @dev Can only retrieve rewards if calling for a valid round and if the\n     * call is done within the timeout threshold (not expired).\n     * @param voterAddress voter for which rewards will be retrieved. Does not have to be the caller.\n     * @param roundId the round from which voting rewards will be retrieved from.\n     * @param toRetrieve array of PendingRequests which rewards are retrieved from.\n     * @return total amount of rewards returned to the voter.\n     */\n    function retrieveRewards(\n        address voterAddress,\n        uint256 roundId,\n        PendingRequest[] memory toRetrieve\n    ) public virtual returns (FixedPoint.Unsigned memory);\n\n    // Voting Owner functions.\n\n    /**\n     * @notice Disables this Voting contract in favor of the migrated one.\n     * @dev Can only be called by the contract owner.\n     * @param newVotingAddress the newly migrated contract address.\n     */\n    function setMigrated(address newVotingAddress) external virtual;\n\n    /**\n     * @notice Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.\n     * @dev This method is public because calldata structs are not currently supported by solidity.\n     * @param newInflationRate sets the next round's inflation rate.\n     */\n    function setInflationRate(FixedPoint.Unsigned memory newInflationRate) public virtual;\n\n    /**\n     * @notice Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.\n     * @dev This method is public because calldata structs are not currently supported by solidity.\n     * @param newGatPercentage sets the next round's Gat percentage.\n     */\n    function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage) public virtual;\n\n    /**\n     * @notice Resets the rewards expiration timeout.\n     * @dev This change only applies to rounds that have not yet begun.\n     * @param NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.\n     */\n    function setRewardsExpirationTimeout(uint256 NewRewardsExpirationTimeout) public virtual;\n}\n"
108     },
109     "contracts/data-verification-mechanism/interfaces/VotingV2Interface.sol": {
110       "content": "// TODO: add staking/snapshot interfaces to this interface file.\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\n/**\n * @title Interface that voters must use to Vote on price request resolutions.\n */\nabstract contract VotingV2Interface {\n    struct PendingRequest {\n        bytes32 identifier;\n        uint256 time;\n    }\n\n    struct PendingRequestAncillary {\n        bytes32 identifier;\n        uint256 time;\n        bytes ancillaryData;\n    }\n\n    struct PendingRequestAncillaryAugmented {\n        uint32 lastVotingRound;\n        bool isGovernance;\n        uint64 time;\n        uint32 rollCount;\n        bytes32 identifier;\n        bytes ancillaryData;\n    }\n\n    // Captures the necessary data for making a commitment.\n    // Used as a parameter when making batch commitments.\n    // Not used as a data structure for storage.\n    struct Commitment {\n        bytes32 identifier;\n        uint256 time;\n        bytes32 hash;\n        bytes encryptedVote;\n    }\n\n    // Captures the necessary data for revealing a vote.\n    // Used as a parameter when making batch reveals.\n    // Not used as a data structure for storage.\n    struct Reveal {\n        bytes32 identifier;\n        uint256 time;\n        int256 price;\n        int256 salt;\n    }\n\n    // Captures the necessary data for making a commitment.\n    // Used as a parameter when making batch commitments.\n    // Not used as a data structure for storage.\n    struct CommitmentAncillary {\n        bytes32 identifier;\n        uint256 time;\n        bytes ancillaryData;\n        bytes32 hash;\n        bytes encryptedVote;\n    }\n\n    // Captures the necessary data for revealing a vote.\n    // Used as a parameter when making batch reveals.\n    // Not used as a data structure for storage.\n    struct RevealAncillary {\n        bytes32 identifier;\n        uint256 time;\n        int256 price;\n        bytes ancillaryData;\n        int256 salt;\n    }\n\n    // Note: the phases must be in order. Meaning the first enum value must be the first phase, etc.\n    // `NUM_PHASES` is to get the number of phases. It isn't an actual phase, and it should always be last.\n    enum Phase { Commit, Reveal, NUM_PHASES }\n\n    /**\n     * @notice Commit a vote for a price request for `identifier` at `time`.\n     * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.\n     * Commits can be changed.\n     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the systems expected behavior,\n     * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then\n     * they can determine the vote pre-reveal.\n     * @param identifier uniquely identifies the committed vote. EG BTC/USD price pair.\n     * @param time unix timestamp of the price being voted on.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.\n     */\n    function commitVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash\n    ) public virtual;\n\n    /**\n     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote\n     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to\n     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.\n     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.\n     * @param time unix timestamp of for the price request.\n     * @param ancillaryData  arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.\n     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\n     */\n    function commitAndEmitEncryptedVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash,\n        bytes memory encryptedVote\n    ) external virtual;\n\n    /**\n     * @notice Reveal a previously committed vote for `identifier` at `time`.\n     * @dev The revealed `price`, `salt`, `address`, `time`, `roundId`, and `identifier`, must hash to the latest `hash`\n     * that `commitVote()` was called with. Only the committer can reveal their vote.\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price is being voted on.\n     * @param price voted on during the commit phase.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param salt value used to hide the commitment price during the commit phase.\n     */\n    function revealVote(\n        bytes32 identifier,\n        uint256 time,\n        int256 price,\n        bytes memory ancillaryData,\n        int256 salt\n    ) public virtual;\n\n    /**\n     * @notice Gets the requests that are being voted on this round.\n     * @return pendingRequests array containing identifiers of type PendingRequestAncillaryAugmented.\n     */\n    function getPendingRequests() external virtual returns (PendingRequestAncillaryAugmented[] memory);\n\n    /**\n     * @notice Returns the current voting phase, as a function of the current time.\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES }.\n     */\n    function getVotePhase() external view virtual returns (Phase);\n\n    /**\n     * @notice Returns the current round ID, as a function of the current time.\n     * @return uint256 representing the unique round ID.\n     */\n    function getCurrentRoundId() external view virtual returns (uint32);\n\n    // Voting Owner functions.\n\n    /**\n     * @notice Disables this Voting contract in favor of the migrated one.\n     * @dev Can only be called by the contract owner.\n     * @param newVotingAddress the newly migrated contract address.\n     */\n    function setMigrated(address newVotingAddress) external virtual;\n\n    /**\n     * @notice Sets the maximum number of rounds to roll a request can have before the DVM auto deletes it.\n     * @dev Can only be called by the contract owner.\n     * @param newMaxRolls the new number of rounds to roll a request before the DVM auto deletes it.\n     */\n    function setMaxRolls(uint32 newMaxRolls) external virtual;\n\n    /**\n     * @notice Sets the maximum number of requests that can be made in a single round. Used to bound the maximum\n     * sequential slashing that can be applied within a single round.\n     * @dev Can only be called by the contract owner.\n     * @param newMaxRequestsPerRound the new maximum number of requests that can be made in a single round.\n     */\n    function setMaxRequestPerRound(uint32 newMaxRequestsPerRound) external virtual;\n\n    /**\n     * @notice Resets the GAT number and SPAT percentage. The GAT is the minimum number of tokens that must participate\n     * in a vote for it to resolve (quorum number). The SPAT is is the minimum percentage of tokens that must agree\n     * in a vote for it to resolve (percentage of staked tokens) Note: this change only applies to rounds that\n     * have not yet begun.\n     * @param newGat sets the next round's GAT and going forward.\n     * @param newSpat sets the next round's SPAT and going forward.\n     */\n    function setGatAndSpat(uint128 newGat, uint64 newSpat) external virtual;\n\n    /**\n     * @notice Changes the slashing library used by this contract.\n     * @param _newSlashingLibrary new slashing library address.\n     */\n    function setSlashingLibrary(address _newSlashingLibrary) external virtual;\n}\n"
111     }
112   },
113   "settings": {
114     "optimizer": {
115       "enabled": true,
116       "runs": 200
117     },
118     "outputSelection": {
119       "*": {
120         "*": [
121           "evm.bytecode",
122           "evm.deployedBytecode",
123           "devdoc",
124           "userdoc",
125           "metadata",
126           "abi"
127         ]
128       }
129     },
130     "libraries": {}
131   }
132 }}