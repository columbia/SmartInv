1 {{
2   "language": "Solidity",
3   "sources": {
4     "/contracts/MintedTokenCappedCrowdsaleExtv1.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\npragma solidity 0.7.6;\n\nimport \"./MintedTokenCappedCrowdsaleExt.sol\";\n\n\n/**\n * ICO crowdsale contract that is capped by amout of tokens.\n *\n * - Tokens are dynamically created during the crowdsale\n *\n *\n */\ncontract MintedTokenCappedCrowdsaleExtv1 is MintedTokenCappedCrowdsaleExt {\n\n    address[] public investedAmountOfAddresses;\n    MintedTokenCappedCrowdsaleExtv1 public mintedTokenCappedCrowdsaleExt;\n\n    constructor(\n        string memory _name,\n        address _token,\n        PricingStrategy _pricingStrategy,\n        address _multisigWallet,\n        uint _start, uint _end,\n        uint _minimumFundingGoal,\n        uint _maximumSellableTokens,\n        bool _isUpdatable,\n        bool _isWhiteListed,\n        address _tokenVestingAddress,\n        MintedTokenCappedCrowdsaleExtv1 _oldMintedTokenCappedCrowdsaleExtAddress\n    )  MintedTokenCappedCrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end,\n    _minimumFundingGoal, _maximumSellableTokens, _isUpdatable, _isWhiteListed, _tokenVestingAddress) {\n        \n        mintedTokenCappedCrowdsaleExt = _oldMintedTokenCappedCrowdsaleExtAddress;\n        tokensSold = mintedTokenCappedCrowdsaleExt.tokensSold();\n        //weiRaised = mintedTokenCappedCrowdsaleExt.weiRaised();\n        investorCount = mintedTokenCappedCrowdsaleExt.investorCount();        \n\n        //\n        //for (uint i = 0; i < mintedTokenCappedCrowdsaleExt.whitelistedParticipantsLength(); i++) {\n        //  address whitelistAddress = mintedTokenCappedCrowdsaleExt.whitelistedParticipants(i);\n\t\t//\n        //  whitelistedParticipants.push(whitelistAddress);\n\t\t//\n        //  uint256 tokenAmount = mintedTokenCappedCrowdsaleExt.tokenAmountOf(whitelistAddress);\n        //  if (tokenAmount != 0){               \n        //    tokenAmountOf[whitelistAddress] = tokenAmount;               \n        //  }\n\t\t//\n        //  uint256 investedAmount = mintedTokenCappedCrowdsaleExt.investedAmountOf(whitelistAddress);\n        //   if (investedAmount != 0){\n        //       investedAmountOf[whitelistAddress] = investedAmount;               \n        //   }\n\t\t//\n        //   setEarlyParticipantWhitelist(whitelistAddress, true, 1000000000000000000, 1000000000000000000000);\n        //}\n\t\t//\n    }\n    \n}\n"
6     },
7     "/contracts/TokenVesting.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./ERC20.sol\";\nimport \"./SafeMathLibExt.sol\";\nimport \"./Allocatable.sol\";\n\n\n/**\n * Contract to enforce Token Vesting\n */\ncontract TokenVesting is Allocatable {\n\n    using SafeMathLibExt for uint;\n\n    address public crowdSaleTokenAddress;\n\n    /** keep track of total tokens yet to be released, \n     * this should be less than or equal to UTIX tokens held by this contract. \n     */\n    uint256 public totalUnreleasedTokens;\n\n    // default vesting parameters\n    uint256 private startAt = 0;\n    uint256 private cliff = 1;\n    uint256 private duration = 4; \n    uint256 private step = 300; //15778463;  //2592000;\n    bool private changeFreezed = false;\n\n    struct VestingSchedule {\n        uint256 startAt;\n        uint256 cliff;\n        uint256 duration;\n        uint256 step;\n        uint256 amount;\n        uint256 amountReleased;\n        bool changeFreezed;\n    }\n\n    mapping (address => VestingSchedule) public vestingMap;\n\n    address[] public vestedWallets;\n\n    event VestedTokensReleased(address _adr, uint256 _amount);\n    \n    constructor(address _tokenAddress) {\n        require(_tokenAddress != address(0), \"Token Address cannot be Null Address\");\n        crowdSaleTokenAddress = _tokenAddress;\n    }\n\n    /** Modifier to check if changes to vesting is freezed  */\n    modifier changesToVestingFreezed(address _adr) {\n        require(vestingMap[_adr].changeFreezed);\n        _;\n    }\n\n    /** Modifier to check if changes to vesting is not freezed yet  */\n    modifier changesToVestingNotFreezed(address adr) {\n        require(!vestingMap[adr].changeFreezed); // if vesting not set then also changeFreezed will be false\n        _;\n    }\n\n    /** Function to set default vesting schedule parameters. */\n    function setDefaultVestingParameters(\n        uint256 _startAt, uint256 _cliff, uint256 _duration,\n        uint256 _step, bool _changeFreezed) public onlyAllocateAgent {\n\n        // data validation\n        require(_step != 0);\n        require(_duration != 0);\n        require(_cliff <= _duration);\n\n        startAt = _startAt;\n        cliff = _cliff;\n        duration = _duration; \n        step = _step;\n        changeFreezed = _changeFreezed;\n\n    }\n\n    /** Function to set vesting with default schedule. */\n    function setVestingWithDefaultSchedule(address _adr, uint256 _amount) \n    public \n    changesToVestingNotFreezed(_adr) onlyAllocateAgent {\n       require(_adr != address(0), \"Cannot set Vesting to Null Address\");\n       setVesting(_adr, startAt, cliff, duration, step, _amount, changeFreezed);\n    }    \n\n    /** Function to set/update vesting schedule. PS - Amount cannot be changed once set */\n    function setVesting(\n        address _adr,\n        uint256 _startAt,\n        uint256 _cliff,\n        uint256 _duration,\n        uint256 _step,\n        uint256 _amount,\n        bool _changeFreezed) \n    public changesToVestingNotFreezed(_adr) onlyAllocateAgent {\n        require(_adr!=address(0), \"Cannot set Null Address\");\n        VestingSchedule storage vestingSchedule = vestingMap[_adr];\n\n        // data validation\n        require(_step != 0);\n        require(_amount != 0 || vestingSchedule.amount > 0);\n        require(_duration != 0);\n        require(_cliff <= _duration);\n\n        //if startAt is zero, set current time as start time.\n        if (_startAt == 0) \n            _startAt = block.timestamp;\n\n        vestingSchedule.startAt = _startAt;\n        vestingSchedule.cliff = _cliff;\n        vestingSchedule.duration = _duration;\n        vestingSchedule.step = _step;\n\n        // special processing for first time vesting setting\n        if (vestingSchedule.amount == 0) {\n            // check if enough tokens are held by this contract\n            ERC20 token = ERC20(crowdSaleTokenAddress);\n            require(token.balanceOf(address(this)) >= totalUnreleasedTokens.plus(_amount));\n            totalUnreleasedTokens = totalUnreleasedTokens.plus(_amount);\n            vestingSchedule.amount = _amount; \n        }\n\n        vestingSchedule.amountReleased = 0;\n        vestingSchedule.changeFreezed = _changeFreezed;\n\n        vestedWallets.push(_adr);\n    }\n\n    function isVestingSet(address adr) public view returns (bool isSet) {\n        return vestingMap[adr].amount != 0;\n    }\n\n    function freezeChangesToVesting(address _adr) public changesToVestingNotFreezed(_adr) onlyAllocateAgent {\n        require(isVestingSet(_adr)); // first check if vesting is set\n        vestingMap[_adr].changeFreezed = true;\n    }\n    \n    /** Release tokens to all the vested wallets */\n    function releaseAllVestedTokens() public onlyOwner{\n        for(uint256 i = 0; i < vestedWallets.length; i++){\n            releaseVestedTokens(vestedWallets[i]);\n        }\n    }\n\n    /** Release tokens as per vesting schedule, called by anyone  */\n    function releaseVestedTokens(address _adr) internal changesToVestingFreezed(_adr) {\n        VestingSchedule storage vestingSchedule = vestingMap[_adr];\n        \n        // check if all tokens are not vested\n        require(vestingSchedule.amount.minus(vestingSchedule.amountReleased) > 0);\n        \n        // calculate total vested tokens till now\n        uint256 totalTime = block.timestamp.minus(vestingSchedule.startAt);\n        uint256 totalSteps = totalTime.divides(vestingSchedule.step);\n\n        // check if cliff is passed\n        require(vestingSchedule.cliff <= totalSteps);\n\n        uint256 tokensPerStep = vestingSchedule.amount.divides(vestingSchedule.duration);\n        // check if amount is divisble by duration\n        if (tokensPerStep.times(vestingSchedule.duration) != vestingSchedule.amount) tokensPerStep.plus(1);\n\n        uint256 totalReleasableAmount = tokensPerStep.times(totalSteps);\n\n        // handle the case if user has not claimed even after vesting period is over or amount was not divisible\n        if (totalReleasableAmount > vestingSchedule.amount) totalReleasableAmount = vestingSchedule.amount;\n\n        uint256 amountToRelease = totalReleasableAmount.minus(vestingSchedule.amountReleased);\n        vestingSchedule.amountReleased = vestingSchedule.amountReleased.plus(amountToRelease);\n\n        // transfer vested tokens\n        ERC20 token = ERC20(crowdSaleTokenAddress);\n        token.transfer(_adr, amountToRelease);\n        // decrement overall unreleased token count\n        totalUnreleasedTokens = totalUnreleasedTokens.minus(amountToRelease);\n        emit VestedTokensReleased(_adr, amountToRelease);\n    }\n\n    /**\n    * Allow to (re)set Token.\n    */\n    function setCrowdsaleTokenExtv1(address _token) public onlyAllocateAgent {    \n        require(_token != address(0), \"Token Address cannot set to Null Address\");   \n        crowdSaleTokenAddress = _token;\n    }\n}"
9     },
10     "/contracts/StandardToken.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\npragma solidity 0.7.6;\n\n\nimport \"./ERC20.sol\";\nimport \"./SafeMathLibExt.sol\";\n\n\n/**\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n *\n * Based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20 {\n\n    using SafeMathLibExt for uint256;\n\n    /* Token supply got increased and a new owner received these tokens */\n    event Minted(address receiver, uint256 amount);\n\n    /* Actual balances of token holders */\n    mapping(address => uint256) public balances;\n\n    /* approve() allowances */\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    /* Interface declaration */\n    function isToken() public pure returns (bool weAre) {\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) public virtual override returns (bool success) {\n        balances[msg.sender] = balances[msg.sender].minus(_value);\n        balances[_to] = balances[_to].plus(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public virtual override returns (bool success) {\n        uint256 _allowance = allowed[_from][msg.sender];\n\n        balances[_to] = balances[_to].plus(_value);\n        balances[_from] = balances[_from].minus(_value);\n        allowed[_from][msg.sender] = _allowance.minus(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public view virtual override returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public  virtual override returns (bool success) {\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        // if ((_addedValue != 0) && (allowed[msg.sender][_spender] != 0)) revert();\n        if(_value == 0 ) revert(\"Cannot approve 0 value\");\n        if(_spender == address(0)) revert(\"Cannot approve for Null aDDRESS\");\n        if(allowed[msg.sender][_spender] == 0 ) revert(\"Spender already approved,instead increase/decrease allowance\");\n\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function increaseAllowance(address _spender, uint256 _addedValue) public virtual returns (bool) {\n        if(_addedValue == 0 ) revert(\"Cannot add 0 allowance value\");\n        if(_spender == address(0)) revert(\"Cannot allow for Null address\");\n\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].plus(allowed[msg.sender][_spender]);\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender].plus(allowed[msg.sender][_spender]));\n        return true;\n    }\n\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public virtual returns (bool) {\n        if(_subtractedValue == 0 ) revert(\"Cannot add 0 decrease value\");\n        if(_spender == address(0)) revert(\"Cannot allow for Null address\");\n        require(_subtractedValue <= allowed[msg.sender][_spender], \"Cannot remove more than allowance!\");\n        \n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].minus(allowed[msg.sender][_spender]);\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender].minus(allowed[msg.sender][_spender]));\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view virtual override returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n}\n"
12     },
13     "/contracts/SafeMathLibExt.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\npragma solidity 0.7.6;\n\n\n/**\n * Safe unsigned safe math.\n *\n * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\n *\n * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol\n *\n * Maintained here until merged to mainline zeppelin-solidity.\n *\n */\nlibrary SafeMathLibExt {\n\n    function times(uint a, uint b) public pure returns (uint) {\n        uint c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function divides(uint a, uint b) public pure returns (uint) {\n        assert(b > 0);\n        uint c = a / b;\n        assert(a == b * c + a % b);\n        return c;\n    }\n\n    function minus(uint a, uint b) public pure returns (uint) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function plus(uint a, uint b) public pure returns (uint) {\n        uint c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n}\n"
15     },
16     "/contracts/PricingStrategy.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\npragma solidity 0.7.6;\n\n\n/**\n * Interface for defining crowdsale pricing.\n */\nabstract contract PricingStrategy {\n\n    address public tier;\n\n    /** Interface declaration. */\n    function isPricingStrategy() public pure returns (bool) {\n        return true;\n    }\n\n    /** Self check if all references are correctly set.\n    *\n    * Checks that pricing strategy matches crowdsale parameters.\n    */\n    function isSane() public pure returns (bool) {\n        return true;\n    }\n\n    /**\n    * @dev Pricing tells if this is a presale purchase or not.  \n      @return False by default, true if a presale purchaser\n    */\n    function isPresalePurchase() public pure returns (bool) {\n        return false;\n    }\n\n    /* How many weis one token costs */\n    function updateRate(uint oneTokenInCents) external virtual;\n\n    /**\n    * When somebody tries to buy tokens for X eth, calculate how many tokens they get.\n    *\n    *\n    * @param value - What is the value of the transaction send in as wei\n    * @param tokensSold - how much tokens have been sold this far\n    * @param decimals - how many decimal units the token has\n    * @return tokenAmount Amount of tokens the investor receives\n    */\n    function calculatePrice(uint value, uint tokensSold, uint decimals) external view virtual returns (uint tokenAmount);\n\n    function oneTokenInWei(uint tokensSold, uint decimals) external view virtual returns (uint);\n}\n"
18     },
19     "/contracts/Ownable.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n    * account.\n    */\n    constructor ()  {\n        owner = msg.sender;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}"
21     },
22     "/contracts/MintedTokenCappedCrowdsaleExt.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\npragma solidity 0.7.6;\n\nimport \"./CrowdsaleExt.sol\";\nimport \"./MintableTokenExt.sol\";\nimport \"./SafeMathLibExt.sol\";\n\n\n/**\n * ICO crowdsale contract that is capped by amout of tokens.\n *\n * - Tokens are dynamically created during the crowdsale\n *\n *\n */\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n    using SafeMathLibExt for uint;\n    /* Maximum amount of tokens this crowdsale can sell. */\n    uint public maximumSellableTokens;\n\n    constructor(\n        string memory _name,\n        address _token,\n        PricingStrategy _pricingStrategy,\n        address _multisigWallet,\n        uint _start, uint _end,\n        uint _minimumFundingGoal,\n        uint _maximumSellableTokens,\n        bool _isUpdatable,\n        bool _isWhiteListed,\n        address _tokenVestingAddress\n    )  CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end,\n    _minimumFundingGoal, _isUpdatable, _isWhiteListed, _tokenVestingAddress) {\n        maximumSellableTokens = _maximumSellableTokens;\n    }\n\n    // Crowdsale maximumSellableTokens has been changed\n    event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n\n    /**\n    * Called from invest() to confirm if the curret investment does not break our cap rule.\n    */\n    function isBreakingCap(uint tokensSoldTotal) public view override returns (bool limitBroken) {\n        return tokensSoldTotal > maximumSellableTokens;\n    }\n\n    function isBreakingInvestorCap(address addr, uint weiAmount) public view override returns (bool limitBroken) {\n        assert(isWhiteListed);\n        uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n        return (investedAmountOf[addr].plus(weiAmount)) > maxCap;\n    }\n\n    function isCrowdsaleFull() public view override returns (bool) {\n        return tokensSold >= maximumSellableTokens;\n    }\n\n    function setMaximumSellableTokens(uint tokens) public onlyOwner {\n        assert(!finalized);\n        assert(isUpdatable);\n        assert(block.timestamp <= startsAt);\n\n        CrowdsaleExt lastTierCntrct = CrowdsaleExt(payable(getLastTier()));\n        assert(!lastTierCntrct.finalized());\n\n        maximumSellableTokens = tokens;\n        emit MaximumSellableTokensChanged(maximumSellableTokens);\n    }\n\n    function updateRate(uint oneTokenInCents) public onlyOwner {\n        assert(!finalized);\n        assert(isUpdatable);\n        assert(block.timestamp <= startsAt);\n\n        CrowdsaleExt lastTierCntrct = CrowdsaleExt(payable(getLastTier()));\n        assert(!lastTierCntrct.finalized());\n\n        pricingStrategy.updateRate(oneTokenInCents);\n    }\n\n    /**\n    * Dynamically create tokens and assign them to the investor.\n    */\n    function assignTokens(address receiver, uint tokenAmount) internal override {\n        MintableTokenExt mintableToken = MintableTokenExt(address(token));\n        mintableToken.mint(receiver, tokenAmount);\n    }    \n}\n"
24     },
25     "/contracts/MintableTokenExt.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\npragma solidity 0.7.6;\n\nimport \"./SafeMathLibExt.sol\";\nimport \"./ERC20.sol\";\nimport \"./Ownable.sol\";\nimport \"./StandardToken.sol\";\n\n\n/**\n * A token that can increase its supply by another contract.\n *\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\n *\n */\ncontract MintableTokenExt is StandardToken, Ownable {\n\n    using SafeMathLibExt for uint;\n\n    bool public mintingFinished = false;\n\n    /** List of agents that are allowed to create new tokens */\n    mapping (address => bool) public mintAgents;\n\n    event MintingAgentChanged(address addr, bool state  );\n    event ReversedTokenListMultipleSet(uint length);\n    event FinalizedReversedAddress(address addr);\n\n    /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals.\n    * For example, for reserved tokens in percents 2.54%\n    * inPercentageUnit = 254\n    * inPercentageDecimals = 2\n    */\n    struct ReservedTokensData {\n        uint inTokens;\n        uint inPercentageUnit;\n        uint inPercentageDecimals;\n        bool isReserved;\n        bool isDistributed;\n        bool isVested;\n    }\n\n    mapping (address => ReservedTokensData) public reservedTokensList;\n    address[] public reservedTokensDestinations;\n    uint public reservedTokensDestinationsLen = 0;\n    bool private reservedTokensDestinationsAreSet = false;\n\n    modifier onlyMintAgent() {\n        // Only crowdsale contracts are allowed to mint new tokens\n        if (!mintAgents[msg.sender]) {\n            revert(\"Only crowdsale contracts are allowed to mint new tokens\");\n        }\n        _;\n    }\n\n    /** Make sure we are not done yet. */\n    modifier canMint() {\n        if (mintingFinished) revert();\n        _;\n    }\n\n    function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n        ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n        reservedTokensData.isDistributed = true;\n\n        emit FinalizedReversedAddress(addr);\n    }\n\n    function isAddressReserved(address addr)  public  view virtual returns (bool isReserved) {\n        return reservedTokensList[addr].isReserved;\n    }\n\n    function areTokensDistributedForAddress(address addr) public view returns (bool isDistributed) {\n        return reservedTokensList[addr].isDistributed;\n    }\n\n    function getReservedTokens(address addr) public view returns (uint inTokens) {\n        return reservedTokensList[addr].inTokens;\n    }\n\n    function getReservedPercentageUnit(address addr) public view returns (uint inPercentageUnit) {\n        return reservedTokensList[addr].inPercentageUnit;\n    }\n\n    function getReservedPercentageDecimals(address addr) public view returns (uint inPercentageDecimals) {\n        return reservedTokensList[addr].inPercentageDecimals;\n    }\n\n    function getReservedIsVested(address addr) public view returns (bool isVested) {\n        return reservedTokensList[addr].isVested;\n    }\n\n    function setReservedTokensListMultiple(\n        address[] memory addrs, \n        uint[] memory inTokens, \n        uint[] memory inPercentageUnit, \n        uint[] memory inPercentageDecimals,\n        bool[] memory isVested\n        ) public canMint onlyOwner {\n        assert(!reservedTokensDestinationsAreSet);\n        assert(addrs.length == inTokens.length);\n        assert(inTokens.length == inPercentageUnit.length);\n        assert(inPercentageUnit.length == inPercentageDecimals.length);\n        for (uint iterator = 0; iterator < addrs.length; iterator++) {\n            if (addrs[iterator] != address(0)) {\n                setReservedTokensList(\n                    addrs[iterator],\n                    inTokens[iterator],\n                    inPercentageUnit[iterator],\n                    inPercentageDecimals[iterator],\n                    isVested[iterator]\n                    );\n            }\n        }\n        reservedTokensDestinationsAreSet = true;\n\n        emit ReversedTokenListMultipleSet(addrs.length);\n    }\n\n    /**\n    * Create new tokens and allocate them to an address..\n    *\n    * Only callably by a crowdsale contract (mint agent).\n    */\n    function mint(address receiver, uint amount) public onlyMintAgent canMint {\n        require(receiver != address(0), \"Receiver cannot be the Null Address\");\n        totalSupply = totalSupply.plus(amount);\n        balances[receiver] = balances[receiver].plus(amount);\n\n        // This will make the mint transaction apper in EtherScan.io\n        // We can remove this after there is a standardized minting event\n        emit Transfer(address(0), receiver, amount);\n    }\n\n    /**\n    * Owner can allow a crowdsale contract to mint new tokens.\n    */\n    function setMintAgent(address addr, bool state) public onlyOwner canMint {\n        require(addr != address(0), \"Mint Agent Cannot be Null Address\");\n        mintAgents[addr] = state;\n        emit MintingAgentChanged(addr, state);\n    }\n\n    function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals,bool isVested) \n    private canMint onlyOwner {\n        assert(addr != address(0));\n        if (!isAddressReserved(addr)) {\n            reservedTokensDestinations.push(addr);\n            reservedTokensDestinationsLen.plus(1);\n        }\n\n        reservedTokensList[addr] = ReservedTokensData({\n            inTokens: inTokens,\n            inPercentageUnit: inPercentageUnit,\n            inPercentageDecimals: inPercentageDecimals,\n            isReserved: true,\n            isDistributed: false,\n            isVested:isVested\n        });\n    }\n}"
27     },
28     "/contracts/Haltable.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\npragma solidity 0.7.6;\n\nimport \"./Ownable.sol\";\n\n\n/*\n * Haltable\n *\n * Abstract contract that allows children to implement an\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\n *\n *\n * Originally envisioned in FirstBlood ICO contract.\n */\ncontract Haltable is Ownable {\n    bool public halted;\n\n    modifier stopInEmergency {\n        if (halted) \n            revert(\"Halted\");\n        _;\n    }\n\n    modifier stopNonOwnersInEmergency {\n        if (halted && msg.sender != owner) \n            revert(\"Stop Non Owners In Emergency\");\n        _;\n    }\n\n    modifier onlyInEmergency {\n        if (!halted) \n            revert(\"Not Halted\");\n        _;\n    }\n\n    // called by the owner on emergency, triggers stopped state\n    function halt() external onlyOwner {\n        halted = true;\n    }\n\n    // called by the owner on end of emergency, returns to normal state\n    function unhalt() external onlyOwner onlyInEmergency {\n        halted = false;\n    }\n\n}\n"
30     },
31     "/contracts/FractionalERC20Ext.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\npragma solidity 0.7.6;\n\nimport \"./ERC20.sol\";\n\n\n/**\n * A token that defines fractional units as decimals.\n */\nabstract contract FractionalERC20Ext is ERC20 {\n    uint public decimals;\n    uint256 public minCap;\n}\n"
33     },
34     "/contracts/FinalizeAgent.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\npragma solidity 0.7.6;\n\n\n/**\n * Finalize agent defines what happens at the end of succeseful crowdsale.\n *\n * - Allocate tokens for founders, bounties and community\n * - Make tokens transferable\n * - etc.\n */\nabstract contract FinalizeAgent {\n\n    bool public reservedTokensAreDistributed = false;\n\n    function isFinalizeAgent() public pure returns(bool) {\n        return true;\n    }\n\n    /** Return true if we can run finalizeCrowdsale() properly.\n    *\n    * This is a safety check function that doesn't allow crowdsale to begin\n    * unless the finalizer has been set up properly.\n    */\n    function isSane() public view virtual returns (bool);\n\n    function distributeReservedTokens(uint256 reservedTokensDistributionBatch) public virtual;\n\n    /** Called once by crowdsale finalize() if the sale was success. */\n    function finalizeCrowdsale() public virtual;\n    \n    /**\n    * Allow to (re)set Token.\n    */\n    function setCrowdsaleTokenExtv1(address _token) public virtual;\n}"
36     },
37     "/contracts/ERC20Basic.sol": {
38       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\nabstract contract ERC20Basic {\n    uint256 public totalSupply;\n    function balanceOf(address who) public view virtual returns (uint256);\n    function transfer(address to, uint256 value) public virtual returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n"
39     },
40     "/contracts/ERC20.sol": {
41       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\n\nimport \"./ERC20Basic.sol\";\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\nabstract contract ERC20 is ERC20Basic {\n    function allowance(address owner, address spender) public view virtual returns (uint256);\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\n    function approve(address spender, uint256 value) public virtual returns (bool);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
42     },
43     "/contracts/CrowdsaleExt.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n\n\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\npragma solidity 0.7.6;\n\nimport \"./SafeMathLibExt.sol\";\nimport \"./Haltable.sol\";\nimport \"./PricingStrategy.sol\";\nimport \"./FinalizeAgent.sol\";\nimport \"./FractionalERC20Ext.sol\";\nimport \"./TokenVesting.sol\";\nimport \"./Allocatable.sol\";\n\n\n/**\n * Abstract base contract for token sales.\n *\n * Handle\n * - start and end dates\n * - accepting investments\n * - minimum funding goal and refund\n * - various statistics during the crowdfund\n * - different pricing strategies\n * - different investment policies (require server side customer id, allow only whitelisted addresses)\n *\n */\nabstract contract CrowdsaleExt is Allocatable, Haltable {\n\n    /* Max investment count when we are still allowed to change the multisig address */\n    uint public constant MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n\n    using SafeMathLibExt for uint256;\n    using SafeMathLibExt for uint8;\n\n    /* The token we are selling */\n    FractionalERC20Ext public token;\n\n    /* How we are going to price our offering */\n    PricingStrategy public pricingStrategy;\n\n    /* Post-success callback */\n    FinalizeAgent public finalizeAgent;\n\n    TokenVesting public tokenVesting;\n\n    /* name of the crowdsale tier */\n    string public name;\n\n    /* tokens will be transfered from this address */\n    address public multisigWallet;\n\n    /* if the funding goal is not reached, investors may withdraw their funds */\n    uint256 public minimumFundingGoal;\n\n    /* current withdrawn, amount already withdrawn for the contract to multisig */\n    uint256 public currentRaisedFundWithdrawn;\n\n    /* the UNIX timestamp start date of the crowdsale */\n    uint256 public startsAt;\n\n    /* the UNIX timestamp end date of the crowdsale */\n    uint256 public endsAt;\n\n    /* the number of tokens already sold through this contract*/\n    uint256 public tokensSold = 0;\n\n    /* How many wei of funding we have raised */\n    uint256 public weiRaised = 0;\n\n    /* How many distinct addresses have invested */\n    uint256 public investorCount = 0;\n\n    /* Has this crowdsale been finalized */\n    bool public finalized;\n\n    bool public isWhiteListed;\n\n      /* Token Vesting Contract */\n    address public tokenVestingAddress;\n\n    address[] public joinedCrowdsales;\n    uint8 public joinedCrowdsalesLen = 0;\n    uint8 public constant joinedCrowdsalesLenMax = 50;\n\n    struct JoinedCrowdsaleStatus {\n        bool isJoined;\n        uint8 position;\n    }\n\n    mapping (address => JoinedCrowdsaleStatus) public joinedCrowdsaleState;\n\n    /** How much ETH each address has invested to this crowdsale */\n    mapping (address => uint256) public investedAmountOf;\n\n    /** How much tokens this crowdsale has credited for each investor address */\n    mapping (address => uint256) public tokenAmountOf;\n\n    struct WhiteListData {\n        bool status;\n        uint256 minCap;\n        uint256 maxCap;\n    }\n\n    //is crowdsale updatable\n    bool public isUpdatable;\n\n    /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */\n    mapping (address => WhiteListData) public earlyParticipantWhitelist;\n\n    /** List of whitelisted addresses */\n    address[] public whitelistedParticipants;\n\n    /** This is for manul testing for the interaction from owner wallet. \n    You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */\n    uint256 public ownerTestValue;\n\n    /** State machine\n    *\n    * - Preparing: All contract initialization calls and variables have not been set yet\n    * - Prefunding: We have not passed start time yet\n    * - Funding: Active crowdsale\n    * - Success: Minimum funding goal reached\n    * - Failure: Minimum funding goal not reached before ending time\n    * - Finalized: The finalized has been called and succesfully executed\n    */\n    enum State { Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized }\n\n    // A new investment was made\n    event Invested(address investor, uint256 weiAmount, uint256 tokenAmount, uint128 customerId);\n\n    // Address early participation whitelist status changed\n    event Whitelisted(address addr, bool status, uint256 minCap, uint256 maxCap);\n    event WhitelistItemChanged(address addr, bool status, uint256 minCap, uint256 maxCap);\n\n    // Crowdsale start time has been changed\n    event StartsAtChanged(uint256 newStartsAt);\n\n    // Crowdsale end time has been changed\n    event EndsAtChanged(uint256 newEndsAt);\n\n    // Fund Withdrawn for contract to the Multisig Wallet\n    event FundWithdrawnToMultiSigWallet(uint256 amount, uint256 time);\n\n    constructor(\n        string memory _name, \n        address _token, \n        PricingStrategy _pricingStrategy, \n        address _multisigWallet, \n        uint256 _start, \n        uint256 _end, \n        uint256 _minimumFundingGoal, \n        bool _isUpdatable, \n        bool _isWhiteListed, \n        address _tokenVestingAddress\n    ) {\n\n        require(_multisigWallet != address(0), \"Multisig Wallet set to Null Address\");\n        require(_token != address(0), \"Token set to Null Address\");\n        require(_tokenVestingAddress != address(0), \"Token Vesting Address set to Null Address\");\n\n        owner = msg.sender;\n\n        name = _name;\n\n        tokenVestingAddress = _tokenVestingAddress;\n\n        token = FractionalERC20Ext(_token);\n\n        setPricingStrategy(_pricingStrategy);\n\n        multisigWallet = _multisigWallet;\n        // if (multisigWallet == 0) {\n        //     revert();\n        // }\n\n        if (_start == 0) {\n            revert(\"Start Cannot be zero\");\n        }\n\n        startsAt = _start;\n\n        if (_end == 0) {\n            revert(\"End Cannot be zero\");\n        }\n\n        endsAt = _end;\n\n        // Don't mess the dates\n        if (startsAt >= endsAt) {\n            revert(\"Start should be greater or equal to end time\");\n        }\n\n        // Minimum funding goal can be zero\n        minimumFundingGoal = _minimumFundingGoal;\n\n        isUpdatable = _isUpdatable;\n\n        isWhiteListed = _isWhiteListed;\n    }\n\n    /**\n    * Don't expect to just send in money and get tokens.\n    */\n    // function() external payable {\n    //     buy();\n    // }\n    receive() external payable {\n        buy();\n    }\n\n    /**\n    * The basic entry point to participate the crowdsale process.\n    *\n    * Pay for funding, get invested tokens back in the sender address.\n    */\n    function buy() public payable {\n        invest(msg.sender);\n    }\n\n    /**\n    * Allow anonymous contributions to this crowdsale.\n    */\n    function invest(address addr) public payable {\n        investInternal(addr, 0);\n    }\n\n    /**\n    * Make an investment.\n    *\n    * Crowdsale must be running for one to invest.\n    * We must have not pressed the emergency brake.\n    *\n    * @param receiver The Ethereum address who receives the tokens\n    * @param customerId (optional) UUID v4 to track the successful payments on the server side\n    *\n    */\n    function investInternal(address receiver, uint128 customerId) private stopInEmergency {\n\n        // Determine if it's a good time to accept investment from this participant\n        if (getState() == State.PreFunding) {\n            // Are we whitelisted for early deposit\n            revert(\"Prefund State Error\");\n        } else if (getState() == State.Funding) {\n            // Retail participants can only come in when the crowdsale is running\n            // pass\n            if (isWhiteListed) {\n                if (!earlyParticipantWhitelist[receiver].status) {\n                    revert(\"Participant not whitelist\");\n                }\n            }\n        } else {\n            // Unwanted state\n            revert(\"Invalid state\");\n        }\n\n        uint256 weiAmount = msg.value;\n\n        // Account presale sales separately, so that they do not count against pricing tranches\n        uint256 tokenAmount = pricingStrategy.calculatePrice(weiAmount, tokensSold, token.decimals());\n\n        if (tokenAmount == 0) {\n          // Dust transaction\n            revert(\"Zero Token Amount\");\n        }\n\n        if (isWhiteListed) {\n            if (weiAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n              // weiAmount < minCap for investor\n                revert(\"MinCap not meet\");\n            }\n\n            // Check that we did not bust the investor's cap\n            if (isBreakingInvestorCap(receiver, weiAmount)) {\n                revert(\"Breaking Investor Cap\");\n            }\n\n            updateInheritedEarlyParticipantWhitelist(receiver, weiAmount);\n        } else {\n            if (weiAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n                revert(\"Less than Minimum Cap and Receiver Amount 0\");\n            }\n        }\n\n        if (investedAmountOf[receiver] == 0) {\n          // A new investor\n            investorCount.plus(1);\n        }\n\n        // Update investor\n        investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n        tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n\n        // Update totals\n        weiRaised = weiRaised.plus(weiAmount);\n        tokensSold = tokensSold.plus(tokenAmount);\n\n        // Check that we did not bust the cap\n        if (isBreakingCap(tokensSold)) {\n            revert(\"Breaking Cap\");\n        }\n\n        assignTokens(receiver, tokenAmount);\n\n        // Send the token if wei raised is greater than the minimum funding goal\n        if(weiRaised >= minimumFundingGoal){\n            if(currentRaisedFundWithdrawn == 0){\n                //update the current raised fund withdraw amount\n                currentRaisedFundWithdrawn = weiRaised;\n                withdrawContractFund(weiRaised);\n            }else{\n                //update the current raised fund withdraw amount\n                currentRaisedFundWithdrawn += weiAmount;\n                withdrawContractFund(weiAmount);\n            }\n        }\n\n        // Tell us invest was success\n        emit Invested(receiver, weiAmount, tokenAmount, customerId);\n    }\n\n    /** \n    * Withdraw investment If minimum funding goal is reached\n    * \n    * Crowdsale should get more than minimum fuding for eth released by the contract\n    * to the multisig wallet \n    *\n    * Owner can call this function\n    * \n    */\n    function withdrawContractFund(uint256 withdrawAmount) internal {\n        //check if multi sig wallet is not contract address\n        // bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // bytes32 codehash;\n        uint32 size;\n\n        address walletAddress = multisigWallet;\n\n        assembly {\n            size := extcodesize(walletAddress)\n            // codehash := extcodehash(walletAddress)\n        }\n        require(size == 0, \"Multi Sig Wallet not contract address\");\n        // require(size == 0 && (codehash == 0x0 || codehash == accountHash), \"Multi Sig Wallet not contract address\");\n                \n        // Pocket the money\n        (bool success, ) = payable(multisigWallet).call{value: withdrawAmount}(\"\");\n        require(success, \"Transfer failed to Multisig Wallet\");\n        // if (!multisigWallet.send(weiAmount)) revert();\n\n        emit FundWithdrawnToMultiSigWallet(withdrawAmount, block.timestamp);\n    }\n\n\n\n    /**\n    * allocate tokens for the early investors.\n    *\n    * Preallocated tokens have been sold before the actual crowdsale opens.\n    * This function mints the tokens and moves the crowdsale needle.\n    *\n    * Investor count is not handled; it is assumed this goes for multiple investors\n    * and the token distribution happens outside the smart contract flow.\n    *\n    * No money is exchanged, as the crowdsale team already have received the payment.\n    *\n    * param weiPrice Price of a single full token in wei\n    *\n    */\n    function allocate(address receiver, uint256 tokenAmount, uint128 customerId, uint256 lockedTokenAmount) external onlyAllocateAgent {\n        require(receiver != address(0), \"Receiver Address set to 0 address\");\n      // cannot lock more than total tokens\n        require(lockedTokenAmount <= tokenAmount, \"Locked token amount must be equal or smaller than token amount\");\n        uint256 weiPrice = pricingStrategy.oneTokenInWei(tokensSold, token.decimals());\n        // This can be also 0, we give out tokens for free\n        uint256 weiAmount = (weiPrice.times(tokenAmount))/10**uint256(token.decimals());         \n\n        weiRaised = weiRaised.plus(weiAmount);\n        tokensSold = tokensSold.plus(tokenAmount);\n\n        investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n        tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n\n        // assign locked token to Vesting contract\n        if (lockedTokenAmount > 0) {\n            tokenVesting = TokenVesting(tokenVestingAddress);\n            // to prevent minting of tokens which will be useless as vesting amount cannot be updated\n            require(!tokenVesting.isVestingSet(receiver), \"Token Vesting Amount Already Set\");\n            assignTokens(tokenVestingAddress, lockedTokenAmount);\n            // set vesting with default schedule\n            tokenVesting.setVestingWithDefaultSchedule(receiver, lockedTokenAmount); \n        }\n\n        // assign remaining tokens to contributor\n        if (tokenAmount - lockedTokenAmount > 0) {\n            assignTokens(receiver, tokenAmount - lockedTokenAmount);\n        }\n\n        // Tell us invest was success\n        emit Invested(receiver, weiAmount, tokenAmount, customerId);\n    }\n\n    //\n    // Modifiers\n    //\n    /** Modified allowing execution only if the crowdsale is currently running.  */\n\n    modifier inState(State state) {\n        if (getState() != state) \n            revert(\"Crowd Sale is not Running\");\n        _;\n    }\n\n    function distributeReservedTokens(uint256 reservedTokensDistributionBatch) \n    external inState(State.Success) onlyOwner stopInEmergency {\n      // Already finalized\n        if (finalized) {\n            revert(\"Already Finalized\");\n        }\n\n        // Finalizing is optional. We only call it if we are given a finalizing agent.\n        if (address(finalizeAgent) != address(0)) {\n            finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n        }\n    }\n\n    function areReservedTokensDistributed() public view returns (bool) {\n        return finalizeAgent.reservedTokensAreDistributed();\n    }\n\n    function canDistributeReservedTokens() external view returns(bool) {\n        CrowdsaleExt lastTierCntrct = CrowdsaleExt(payable(getLastTier()));\n        if ((lastTierCntrct.getState() == State.Success) &&\n        !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed())\n            return true;\n        return false;\n    }\n\n    /**\n    * Finalize a succcesful crowdsale.\n    *\n    * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.\n    */\n    function finalize() external inState(State.Success) onlyOwner stopInEmergency {\n\n      // Already finalized\n        if (finalized) {\n            revert(\"Already Finalized\");\n        }\n\n      // Finalizing is optional. We only call it if we are given a finalizing agent.\n        if (address(finalizeAgent) != address(0)) {\n            finalizeAgent.finalizeCrowdsale();\n        }\n\n        finalized = true;\n    }\n\n    /**\n    * Allow to (re)set finalize agent.\n    *\n    * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.\n    */\n    function setFinalizeAgent(FinalizeAgent addr) external onlyOwner {\n        assert(address(addr) != address(0));\n        assert(address(finalizeAgent) == address(0));\n        finalizeAgent = addr;\n\n        // Don't allow setting bad agent\n        if (!finalizeAgent.isFinalizeAgent()) {\n            revert(\"Agent Already Finalized\");\n        }\n    }\n\n    /**\n    * Allow addresses to do early participation.\n    */\n    function setEarlyParticipantWhitelist(address addr, bool status, uint256 minCap, uint256 maxCap) public onlyOwner {\n        if (!isWhiteListed) revert(\"Already Whitelisted\");\n        assert(addr != address(0));\n        assert(maxCap > 0);\n        assert(minCap <= maxCap);\n        assert(block.timestamp <= endsAt);\n\n        if (!isAddressWhitelisted(addr)) {\n            whitelistedParticipants.push(addr);\n            emit Whitelisted(addr, status, minCap, maxCap);\n        } else {\n            emit WhitelistItemChanged(addr, status, minCap, maxCap);\n        }\n\n        earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n    }\n\n    function setEarlyParticipantWhitelistMultiple(address[] memory addrs, bool[] memory statuses, uint256[] memory minCaps, uint256[] memory maxCaps) \n    external onlyOwner {\n        if (!isWhiteListed) revert(\"Already Whitelisted\");\n        assert(block.timestamp <= endsAt);\n        assert(addrs.length == statuses.length);\n        assert(statuses.length == minCaps.length);\n        assert(minCaps.length == maxCaps.length);\n        for (uint256 iterator = 0; iterator < addrs.length; iterator++) {\n            setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n        }\n    }\n\n    function decreaseEarlyParticipantWhitelistMaxCap(address addr, uint256 weiAmount) public {\n        if (!isWhiteListed) revert(\"Already Whitelisted\");\n        assert(addr != address(0));\n        assert(block.timestamp <= endsAt);\n        assert(isTierJoined(msg.sender));\n        if (weiAmount < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) revert(\"Cannot update Early Paricipant Whitelist\");\n        //if (addr != msg.sender && contractAddr != msg.sender) throw;\n        uint256 newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n        newMaxCap = newMaxCap.minus(weiAmount);\n        earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n    }\n\n    function updateInheritedEarlyParticipantWhitelist(address reciever, uint256 weiAmount) private {\n        if (!isWhiteListed) revert(\"Not Whitelisted\");\n        if (weiAmount < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) revert(\"Cannot update Early Paricipant Whitelist\");\n\n        uint8 tierPosition = getTierPosition(address(this));\n\n        for (uint8 j = tierPosition+1; j < joinedCrowdsalesLen; j++) {\n            CrowdsaleExt crowdsale = CrowdsaleExt(payable(joinedCrowdsales[j]));\n            crowdsale.decreaseEarlyParticipantWhitelistMaxCap(reciever, weiAmount);\n        }\n    }\n\n    function isAddressWhitelisted(address addr) public view returns(bool) {\n        for (uint256 i = 0; i < whitelistedParticipants.length; i++) {\n            if (whitelistedParticipants[i] == addr) {\n                return true;\n                break;\n            }\n        }\n\n        return false;\n    }\n\n    function whitelistedParticipantsLength() external view returns (uint256) {\n        return whitelistedParticipants.length;\n    }\n\n    function isTierJoined(address addr) public view returns(bool) {\n        return joinedCrowdsaleState[addr].isJoined;\n    }\n\n    function getTierPosition(address addr) public view returns(uint8) {\n        return joinedCrowdsaleState[addr].position;\n    }\n\n    function getLastTier() public view returns(address) {\n        if (joinedCrowdsalesLen > 0){\n            return joinedCrowdsales[joinedCrowdsalesLen.minus(1)];\n        }\n        else\n            return address(0);\n    }\n\n    function setJoinedCrowdsales(address addr) private onlyOwner {\n        assert(addr != address(0));\n        assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n        assert(!isTierJoined(addr));\n        joinedCrowdsales.push(addr);\n        joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n            isJoined: true,\n            position: joinedCrowdsalesLen\n        });\n        joinedCrowdsalesLen.plus(1);\n    }\n\n    function updateJoinedCrowdsalesMultiple(address[] memory addrs) external onlyOwner {\n        assert(addrs.length > 0);\n        assert(joinedCrowdsalesLen == 0);\n        assert(addrs.length <= joinedCrowdsalesLenMax);\n        for (uint8 iter = 0; iter < addrs.length; iter++) {\n            setJoinedCrowdsales(addrs[iter]);\n        }\n    }\n\n    function setStartsAt(uint256 time) external onlyOwner {\n        assert(!finalized);\n        assert(isUpdatable);\n        assert(block.timestamp <= time); // Don't change past\n        assert(time <= endsAt);\n        assert(block.timestamp <= startsAt);\n\n        CrowdsaleExt lastTierCntrct = CrowdsaleExt(payable(getLastTier()));\n        if (lastTierCntrct.finalized()) revert(\"Last Tier Contract Finalized\");\n\n        uint8 tierPosition = getTierPosition(address(this));\n\n        //start time should be greater then end time of previous tiers\n        for (uint8 j = 0; j < tierPosition; j++) {\n            CrowdsaleExt crowdsale = CrowdsaleExt(payable(joinedCrowdsales[j]));\n            assert(time >= crowdsale.endsAt());\n        }\n\n        startsAt = time;\n        emit StartsAtChanged(startsAt);\n    }\n\n    /**\n    * Allow crowdsale owner to close early or extend the crowdsale.\n    *\n    * This is useful e.g. for a manual soft cap implementation:\n    * - after X amount is reached determine manual closing\n    *\n    * This may put the crowdsale to an invalid state,\n    * but we trust owners know what they are doing.\n    *\n    */\n    function setEndsAt(uint256 time) external onlyOwner {\n        assert(!finalized);\n        assert(isUpdatable);\n        assert(block.timestamp <= time);// Don't change past\n        assert(startsAt <= time);\n        assert(block.timestamp <= endsAt);\n\n        CrowdsaleExt lastTierCntrct = CrowdsaleExt(payable(getLastTier()));\n        if (lastTierCntrct.finalized()) revert(\"Last Tier Contract Finalized\");\n\n\n        uint8 tierPosition = getTierPosition(address(this));\n\n        for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n            CrowdsaleExt crowdsale = CrowdsaleExt(payable(joinedCrowdsales[j]));\n            assert(time <= crowdsale.startsAt());\n        }\n\n        endsAt = time;\n        emit EndsAtChanged(endsAt);\n    }\n\n    /**\n    * Allow to (re)set pricing strategy.\n    *\n    * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.\n    */\n    function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n        assert(address(_pricingStrategy) != address(0));\n        pricingStrategy = _pricingStrategy;\n\n        // Don't allow setting bad agent\n        if (!pricingStrategy.isPricingStrategy()) {\n            revert(\"Cannot Set Bad Pricing Strategy\");\n        }\n    }\n\n    /**\n    * Allow to (re)set Token.\n    * @param _token upgraded token address\n    */\n    function setCrowdsaleTokenExtv1(address _token) external onlyOwner {\n        assert(_token != address(0));\n        token = FractionalERC20Ext(_token);\n        \n        if (address(finalizeAgent) != address(0)) {\n            finalizeAgent.setCrowdsaleTokenExtv1(_token);\n        }\n    }\n\n    /**\n    * Allow to change the team multisig address in the case of emergency.\n    *\n    * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun\n    * (we have done only few test transactions). After the crowdsale is going\n    * then multisig address stays locked for the safety reasons.\n    */\n    function setMultisig(address addr) external onlyOwner {\n        require(addr != address(0), \"Multi Sig Wallet Cannot be Null Address\");\n      // Change\n        if (investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n            revert(\"Investor count greater than Max nvestments\");\n        }\n\n        multisigWallet = addr;\n    }\n\n    /**\n    * Return true if the crowdsale has raised enough money to be a successful.\n    */\n    function isMinimumGoalReached() public view returns (bool reached) {\n        return weiRaised >= minimumFundingGoal;\n    }\n\n    /**\n    * Check if the contract relationship looks good.\n    */\n    function isFinalizerSane() external view returns (bool sane) {\n        return finalizeAgent.isSane();\n    }\n\n    /**\n    * Check if the contract relationship looks good.\n    */\n    function isPricingSane() external view returns (bool sane) {\n        return pricingStrategy.isSane();\n    }\n\n    /**\n    * Crowdfund state machine management.\n    *\n    * We make it a function and do not assign the result to a variable, \n    * so there is no chance of the variable being stale.\n    */\n    function getState() public view returns (State) {\n        if(finalized) return State.Finalized;\n        else if (address(finalizeAgent) == address(0)) return State.Preparing;\n        else if (!finalizeAgent.isSane()) return State.Preparing;\n        else if (!pricingStrategy.isSane()) return State.Preparing;\n        else if (block.timestamp < startsAt) return State.PreFunding;\n        else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n        else if (isMinimumGoalReached()) return State.Success;\n        else return State.Failure;\n    }\n\n    /** Interface marker. */\n    function isCrowdsale() external pure returns (bool) {\n        return true;\n    }\n\n    //\n    // Abstract functions\n    //\n\n    /**\n    * Check if the current invested breaks our cap rules.\n    *\n    *\n    * The child contract must define their own cap setting rules.\n    * We allow a lot of flexibility through different capping strategies (ETH, token count)\n    * Called from invest().\n    *  \n    * @param tokensSoldTotal What would be our total sold tokens count after this transaction\n    *\n    * @return limitBroken true if taking this investment would break our cap rules\n    */\n    function isBreakingCap(uint256 tokensSoldTotal) public view virtual returns (bool limitBroken);\n\n    function isBreakingInvestorCap(address receiver, uint256 tokenAmount) public view virtual returns (bool limitBroken);\n\n    /**\n    * Check if the current crowdsale is full and we can no longer sell any tokens.\n    */\n    function isCrowdsaleFull() public view virtual returns (bool);\n\n    /**\n    * Create new tokens or transfer issued tokens to the investor depending on the cap model.\n    */\n    function assignTokens(address receiver, uint256 tokenAmount) internal virtual;\n}\n"
45     },
46     "/contracts/Allocatable.sol": {
47       "content": "// SPDX-License-Identifier: MIT\n\n\npragma solidity 0.7.6;\n\nimport \"./Ownable.sol\";\n\n\ncontract Allocatable is Ownable {\n\n  /** List of agents that are allowed to allocate new tokens */\n    mapping (address => bool) public allocateAgents;\n\n    event AllocateAgentChanged(address addr, bool state  );\n\n  /**\n   * Owner can allow a crowdsale contract to allocate new tokens.\n   */\n    function setAllocateAgent(address addr, bool state) public onlyOwner  \n    {\n        allocateAgents[addr] = state;\n        emit AllocateAgentChanged(addr, state);\n    }\n\n    modifier onlyAllocateAgent() {\n        //Only crowdsale contracts are allowed to allocate new tokens\n        require(allocateAgents[msg.sender]);\n        _;\n    }\n}"
48     }
49   },
50   "settings": {
51     "remappings": [],
52     "optimizer": {
53       "enabled": true,
54       "runs": 200
55     },
56     "evmVersion": "istanbul",
57     "libraries": {
58       "/contracts/SafeMathLibExt.sol": {
59         "SafeMathLibExt": "0x3ca260383F7b05C49Aaf72906e8Ec1Da4Bb1CdC6"
60       }
61     },
62     "outputSelection": {
63       "*": {
64         "*": [
65           "evm.bytecode",
66           "evm.deployedBytecode",
67           "devdoc",
68           "userdoc",
69           "metadata",
70           "abi"
71         ]
72       }
73     }
74   }
75 }}