1 {{
2   "language": "Solidity",
3   "sources": {
4     "temp-contracts/BMath.sol": {
5       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\nimport \"./BNum.sol\";\n\n\ncontract BMath is BNum {\n  function calcSingleInGivenPoolOut(\n    uint256 tokenBalanceIn,\n    uint256 tokenWeightIn,\n    uint256 poolSupply,\n    uint256 totalWeight,\n    uint256 poolAmountOut,\n    uint256 swapFee\n  ) internal pure returns (uint256 tokenAmountIn) {\n    uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n    uint256 newPoolSupply = badd(poolSupply, poolAmountOut);\n    uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\n\n    //uint newBalTi = poolRatio^(1/weightTi) * balTi;\n    uint256 boo = bdiv(BONE, normalizedWeight);\n    uint256 tokenInRatio = bpow(poolRatio, boo);\n    uint256 newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\n    uint256 tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\n    // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\n    //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\n    //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\n    uint256 zar = bmul(bsub(BONE, normalizedWeight), swapFee);\n    tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\n    return tokenAmountIn;\n  }\n}"
6     },
7     "temp-contracts/BNum.sol": {
8       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\ncontract BNum {\n  uint256 internal constant BONE = 1e18;\n  uint256 internal constant MIN_BPOW_BASE = 1 wei;\n  uint256 internal constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n  uint256 internal constant BPOW_PRECISION = BONE / 10**10;\n  uint256 internal constant MIN_WEIGHT = BONE / 4;\n\n  function btoi(uint256 a) internal pure returns (uint256) {\n    return a / BONE;\n  }\n\n  function bfloor(uint256 a) internal pure returns (uint256) {\n    return btoi(a) * BONE;\n  }\n\n  function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"ERR_ADD_OVERFLOW\");\n    return c;\n  }\n\n  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n    (uint256 c, bool flag) = bsubSign(a, b);\n    require(!flag, \"ERR_SUB_UNDERFLOW\");\n    return c;\n  }\n\n  function bsubSign(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256, bool)\n  {\n    if (a >= b) {\n      return (a - b, false);\n    } else {\n      return (b - a, true);\n    }\n  }\n\n  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c0 = a * b;\n    require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n    uint256 c1 = c0 + (BONE / 2);\n    require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n    uint256 c2 = c1 / BONE;\n    return c2;\n  }\n\n  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"ERR_DIV_ZERO\");\n    uint256 c0 = a * BONE;\n    require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n    uint256 c1 = c0 + (b / 2);\n    require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n    uint256 c2 = c1 / b;\n    return c2;\n  }\n\n  // DSMath.wpow\n  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n    uint256 z = n % 2 != 0 ? a : BONE;\n\n    for (n /= 2; n != 0; n /= 2) {\n      a = bmul(a, a);\n\n      if (n % 2 != 0) {\n        z = bmul(z, a);\n      }\n    }\n    return z;\n  }\n\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\n  // of approximation of b^0.w\n  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n    require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n    require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n    uint256 whole = bfloor(exp);\n    uint256 remain = bsub(exp, whole);\n\n    uint256 wholePow = bpowi(base, btoi(whole));\n\n    if (remain == 0) {\n      return wholePow;\n    }\n\n    uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n    return bmul(wholePow, partialResult);\n  }\n\n  function bpowApprox(\n    uint256 base,\n    uint256 exp,\n    uint256 precision\n  ) internal pure returns (uint256) {\n    // term 0:\n    uint256 a = exp;\n    (uint256 x, bool xneg) = bsubSign(base, BONE);\n    uint256 term = BONE;\n    uint256 sum = term;\n    bool negative = false;\n\n    // term(k) = numer / denom\n    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n    // each iteration, multiply previous term by (a-(k-1)) * x / k\n    // continue until term is less than precision\n    for (uint256 i = 1; term >= precision; i++) {\n      uint256 bigK = i * BONE;\n      (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n      term = bmul(term, bmul(c, x));\n      term = bdiv(term, bigK);\n      if (term == 0) break;\n\n      if (xneg) negative = !negative;\n      if (cneg) negative = !negative;\n      if (negative) {\n        sum = bsub(sum, term);\n      } else {\n        sum = badd(sum, term);\n      }\n    }\n\n    return sum;\n  }\n}\n"
9     },
10     "temp-contracts/IndexedUniswapRouterMinter.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IERC20.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IWETH.sol\";\n\nimport \"@indexed-finance/indexed-core/contracts/interfaces/IIndexPool.sol\";\n\nimport \"./libraries/UniswapV2Library.sol\";\nimport \"./BMath.sol\";\n\n\ncontract IndexedUniswapRouterMinter is BMath {\n  address public immutable factory;\n  address public immutable weth;\n\n  constructor(address factory_, address weth_) public {\n    factory = factory_;\n    weth = weth_;\n  }\n\n  receive() external payable {\n    require(msg.sender == weth, \"IndexedUniswapRouterMinter: RECEIVED_ETHER\");\n  }\n\n  // requires the initial amount to have already been sent to the first pair\n  function _swap(uint[] memory amounts, address[] memory path) internal {\n    for (uint i; i < path.length - 1; i++) {\n      (address input, address output) = (path[i], path[i + 1]);\n      (address token0, address token1) = UniswapV2Library.sortTokens(input, output);\n      uint amountOut = amounts[i + 1];\n      (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n      address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : address(this);\n      IUniswapV2Pair(UniswapV2Library.calculatePair(factory, token0, token1)).swap(\n        amount0Out, amount1Out, to, new bytes(0)\n      );\n    }\n  }\n\n  function _mintTokenAmountIn(\n    address tokenIn,\n    uint amountIn,\n    address indexPool,\n    uint minPoolAmountOut\n  ) internal returns (uint poolAmountOut) {\n    TransferHelper.safeApprove(tokenIn, indexPool, amountIn);\n    poolAmountOut = IIndexPool(indexPool).joinswapExternAmountIn(\n      tokenIn,\n      amountIn,\n      minPoolAmountOut\n    );\n    TransferHelper.safeTransfer(indexPool, msg.sender, poolAmountOut);\n  }\n\n  function _mintPoolAmountOut(\n    address tokenIn,\n    uint amountIn,\n    address indexPool,\n    uint poolAmountOut\n  ) internal {\n    TransferHelper.safeApprove(tokenIn, indexPool, amountIn);\n    IIndexPool(indexPool).joinswapPoolAmountOut(\n      tokenIn,\n      poolAmountOut,\n      amountIn\n    );\n    TransferHelper.safeTransfer(indexPool, msg.sender, poolAmountOut);\n  }\n\n  function _tokenInGivenPoolOut(\n    address indexPool,\n    address tokenIn,\n    uint256 poolAmountOut\n  ) internal view returns (uint256 amountIn) {\n    IIndexPool.Record memory record = IIndexPool(indexPool).getTokenRecord(tokenIn);\n    if (!record.ready) {\n      uint256 minimumBalance = IIndexPool(indexPool).getMinimumBalance(tokenIn);\n      uint256 realToMinRatio = bdiv(\n        bsub(minimumBalance, record.balance),\n        minimumBalance\n      );\n      uint256 weightPremium = bmul(MIN_WEIGHT / 10, realToMinRatio);\n      record.balance = minimumBalance;\n      record.denorm = uint96(badd(MIN_WEIGHT, weightPremium));\n    }\n\n    uint256 totalSupply = IERC20(indexPool).totalSupply();\n    uint256 totalWeight = IIndexPool(indexPool).getTotalDenormalizedWeight();\n    uint256 swapFee = IIndexPool(indexPool).getSwapFee();\n\n    return calcSingleInGivenPoolOut(\n      record.balance,\n      record.denorm,\n      totalSupply,\n      totalWeight,\n      poolAmountOut,\n      swapFee\n    );\n  }\n\n  /**\n   * @dev Swaps ether for each token in `path` using their Uniswap pairs,\n   * then mints at least `minPoolAmountOut` pool tokens from `indexPool`.\n   *\n   * @param path Array of tokens to swap using the Uniswap router.\n   * @param indexPool Address of the index pool to mint tokens from.\n   * @param minPoolAmountOut Amount of pool tokens that must be received to not revert.\n   */\n  function swapExactETHForTokensAndMint(\n    address[] calldata path,\n    address indexPool,\n    uint minPoolAmountOut\n  ) external payable returns (uint poolAmountOut) {\n    require(path[0] == weth, 'IndexedUniswapRouterMinter: INVALID_PATH');\n    uint[] memory amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n\n    IWETH(weth).deposit{value: amounts[0]}();\n    require(\n      IWETH(weth).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]),\n      \"IndexedUniswapRouterMinter: WETH_TRANSFER_FAIL\"\n    );\n    _swap(amounts, path);\n\n    uint amountOut =  amounts[amounts.length - 1];\n    return _mintTokenAmountIn(\n      path[path.length - 1],\n      amountOut,\n      indexPool,\n      minPoolAmountOut\n    );\n  }\n\n  /**\n   * @dev Swaps a token for each other token in `path` using their Uniswap pairs,\n   * then mints at least `minPoolAmountOut` pool tokens from `indexPool`.\n   *\n   * @param amountIn Amount of the first token in `path` to swap.\n   * @param path Array of tokens to swap using the Uniswap router.\n   * @param indexPool Address of the index pool to mint tokens from.\n   * @param minPoolAmountOut Amount of pool tokens that must be received to not revert.\n   */\n  function swapExactTokensForTokensAndMint(\n    uint amountIn,\n    address[] calldata path,\n    address indexPool,\n    uint minPoolAmountOut\n  ) external returns (uint poolAmountOut) {\n    uint[] memory amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    TransferHelper.safeTransferFrom(\n      path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n    );\n    _swap(amounts, path);\n    uint amountOut = amounts[amounts.length - 1];\n\n    return _mintTokenAmountIn(\n      path[path.length - 1],\n      amountOut,\n      indexPool,\n      minPoolAmountOut\n    );\n  }\n\n  /**\n   * @dev Swaps ether for each token in `path` through Uniswap,\n   * then mints `poolAmountOut` pool tokens from `indexPool`.\n   *\n   * @param path Array of tokens to swap using the Uniswap router.\n   * @param indexPool Address of the index pool to mint tokens from.\n   * @param poolAmountOut Amount of pool tokens that must be received to not revert.\n   */\n  function swapETHForTokensAndMintExact(\n    address[] calldata path,\n    address indexPool,\n    uint poolAmountOut\n  ) external payable {\n    address swapTokenOut = path[path.length - 1];\n    uint amountOut = _tokenInGivenPoolOut(indexPool, swapTokenOut, poolAmountOut);\n    require(path[0] == weth, 'IndexedUniswapRouterMinter: INVALID_PATH');\n\n    uint[] memory amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    require(amounts[0] <= msg.value, 'IndexedUniswapRouterMinter: EXCESSIVE_INPUT_AMOUNT');\n\n    IWETH(weth).deposit{value: amounts[0]}();\n    require(\n      IWETH(weth).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]),\n      \"IndexedUniswapRouterMinter: WETH_TRANSFER_FAIL\"\n    );\n    _swap(amounts, path);\n\n    // refund dust eth, if any\n    if (msg.value > amounts[0]) {\n      TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    return _mintPoolAmountOut(\n      swapTokenOut,\n      amountOut,\n      indexPool,\n      poolAmountOut\n    );\n  }\n\n  /**\n   * @dev Swaps a token for each other token in `path` through Uniswap,\n   * then mints at least `poolAmountOut` pool tokens from `indexPool`.\n   *\n   * @param amountInMax Maximum amount of the first token in `path` to give.\n   * @param path Array of tokens to swap using the Uniswap router.\n   * @param indexPool Address of the index pool to mint tokens from.\n   * @param poolAmountOut Amount of pool tokens that must be received to not revert.\n   */\n  function swapTokensForTokensAndMintExact(\n    uint amountInMax,\n    address[] calldata path,\n    address indexPool,\n    uint poolAmountOut\n  ) external {\n    address swapTokenOut = path[path.length - 1];\n    uint amountOut = _tokenInGivenPoolOut(indexPool, swapTokenOut, poolAmountOut);\n    uint[] memory amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    require(amounts[0] <= amountInMax, 'IndexedUniswapRouterMinter: EXCESSIVE_INPUT_AMOUNT');\n    TransferHelper.safeTransferFrom(\n      path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n    );\n    _swap(amounts, path);\n    _mintPoolAmountOut(\n      swapTokenOut,\n      amountOut,\n      indexPool,\n      poolAmountOut\n    );\n  }\n\n  function _getSwapAmountsForJoin(\n    address indexPool,\n    address intermediate,\n    address poolToken,\n    address[] memory path,\n    uint256 poolRatio\n  ) internal view returns (uint[] memory amounts) {\n    if (intermediate == address(0)) {\n      // If no intermediate token is given, set path length to 2 so the other\n      // functions will not use the 3rd address.\n      assembly { mstore(path, 2) }\n      path[1] = poolToken;\n    } else {\n      // If an intermediary is given, set path length to 3 so the other\n      // functions will use all addresses.\n      assembly { mstore(path, 3) }\n      path[1] = intermediate;\n      path[2] = poolToken;\n    }\n    uint256 usedBalance = IIndexPool(indexPool).getUsedBalance(poolToken);\n    uint256 amountToPool = bmul(poolRatio, usedBalance);\n    amounts = UniswapV2Library.getAmountsIn(factory, amountToPool, path);\n  }\n\n  /**\n   * @dev Swaps an input token for every underlying token in an index pool,\n   * then mints `poolAmountOut` pool tokens from the pool.\n   *\n   * Up to one intermediary token may be provided in `intermediaries` for each\n   * underlying token in the index pool.\n   *\n   * If a null address is provided as an intermediary, the input token will be\n   * swapped directly for the output token.\n   */\n  function swapTokensForAllTokensAndMintExact(\n    address tokenIn,\n    uint256 amountInMax,\n    address[] calldata intermediaries,\n    address indexPool,\n    uint256 poolAmountOut\n  ) external returns (uint256 amountInTotal) {\n    address[] memory tokens = IIndexPool(indexPool).getCurrentTokens();\n    require(\n      tokens.length == intermediaries.length,\n      \"IndexedUniswapRouterMinter: BAD_ARRAY_LENGTH\"\n    );\n    uint256[] memory amountsToPool = new uint256[](tokens.length);\n\n    uint256 ratio = bdiv(poolAmountOut, IERC20(indexPool).totalSupply());\n\n    // Reserve 3 slots in memory for the addresses\n    address[] memory path = new address[](3);\n    path[0] = tokenIn;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      uint[] memory amounts = _getSwapAmountsForJoin(\n        indexPool,\n        intermediaries[i],\n        tokens[i],\n        path,\n        ratio\n      );\n      amountInMax = SafeMath.sub(amountInMax, amounts[0], \"IndexedUniswapRouterMinter: EXCESSIVE_INPUT_AMOUNT\");\n\n      TransferHelper.safeTransferFrom(\n        path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n      );\n      _swap(amounts, path);\n\n      uint amountToPool = amounts[amounts.length - 1];\n      amountsToPool[i] = amountToPool;\n      amountInTotal = SafeMath.add(amountInTotal, amounts[0]);\n      TransferHelper.safeApprove(tokens[i], indexPool, amountToPool);\n    }\n    IIndexPool(indexPool).joinPool(poolAmountOut, amountsToPool);\n    TransferHelper.safeTransfer(indexPool, msg.sender, poolAmountOut);\n  }\n\n  /**\n   * @dev Swaps ether for every underlying token in an index pool,\n   * then mints `poolAmountOut` pool tokens from the pool.\n   *\n   * Up to one intermediary token may be provided in `intermediaries` for each\n   * underlying token in the index pool.\n   *\n   * If a null address is provided as an intermediary, the input token will be\n   * swapped directly for the output token.\n   */\n  function swapETHForAllTokensAndMintExact(\n    address indexPool,\n    address[] calldata intermediaries,\n    uint256 poolAmountOut\n  ) external payable returns (uint amountInTotal) {\n    uint256 amountInMax = msg.value;\n    IWETH(weth).deposit{value: msg.value}();\n    address[] memory tokens = IIndexPool(indexPool).getCurrentTokens();\n    require(\n      tokens.length == intermediaries.length,\n      \"IndexedUniswapRouterMinter: BAD_ARRAY_LENGTH\"\n    );\n    uint256[] memory amountsToPool = new uint256[](tokens.length);\n\n    uint256 ratio = bdiv(poolAmountOut, IERC20(indexPool).totalSupply());\n\n    // Reserve 3 slots in memory for the addresses\n    address[] memory path = new address[](3);\n    path[0] = weth;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      uint[] memory amounts = _getSwapAmountsForJoin(\n        indexPool,\n        intermediaries[i],\n        tokens[i],\n        path,\n        ratio\n      );\n      amountInMax = SafeMath.sub(amountInMax, amounts[0], \"IndexedUniswapRouterMinter: EXCESSIVE_INPUT_AMOUNT\");\n\n      require(\n        IWETH(weth).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]),\n        \"IndexedUniswapRouterMinter: WETH_TRANSFER_FAIL\"\n      );\n      _swap(amounts, path);\n\n      uint amountToPool = amounts[amounts.length - 1];\n      amountsToPool[i] = amountToPool;\n      amountInTotal = SafeMath.add(amountInTotal, amounts[0]);\n      TransferHelper.safeApprove(tokens[i], indexPool, amountToPool);\n    }\n    IIndexPool(indexPool).joinPool(poolAmountOut, amountsToPool);\n    TransferHelper.safeTransfer(indexPool, msg.sender, poolAmountOut);\n\n    if (msg.value > amountInTotal) {\n      uint256 remainder = msg.value - amountInTotal;\n      IWETH(weth).withdraw(remainder);\n      TransferHelper.safeTransferETH(msg.sender, remainder);\n    }\n  }\n}"
12     },
13     "@uniswap/lib/contracts/libraries/TransferHelper.sol": {
14       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n"
15     },
16     "@uniswap/v2-periphery/contracts/interfaces/IERC20.sol": {
17       "content": "pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
18     },
19     "@uniswap/v2-periphery/contracts/interfaces/IWETH.sol": {
20       "content": "pragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n"
21     },
22     "@indexed-finance/indexed-core/contracts/interfaces/IIndexPool.sol": {
23       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n\ninterface IIndexPool {\n  /**\n   * @dev Token record data structure\n   * @param bound is token bound to pool\n   * @param ready has token been initialized\n   * @param lastDenormUpdate timestamp of last denorm change\n   * @param denorm denormalized weight\n   * @param desiredDenorm desired denormalized weight (used for incremental changes)\n   * @param index index of address in tokens array\n   * @param balance token balance\n   */\n  struct Record {\n    bool bound;\n    bool ready;\n    uint40 lastDenormUpdate;\n    uint96 denorm;\n    uint96 desiredDenorm;\n    uint8 index;\n    uint256 balance;\n  }\n\n  event LOG_SWAP(\n    address indexed caller,\n    address indexed tokenIn,\n    address indexed tokenOut,\n    uint256 tokenAmountIn,\n    uint256 tokenAmountOut\n  );\n\n  event LOG_JOIN(\n    address indexed caller,\n    address indexed tokenIn,\n    uint256 tokenAmountIn\n  );\n\n  event LOG_EXIT(\n    address indexed caller,\n    address indexed tokenOut,\n    uint256 tokenAmountOut\n  );\n\n  event LOG_DENORM_UPDATED(address indexed token, uint256 newDenorm);\n\n  event LOG_DESIRED_DENORM_SET(address indexed token, uint256 desiredDenorm);\n\n  event LOG_TOKEN_REMOVED(address token);\n\n  event LOG_TOKEN_ADDED(\n    address indexed token,\n    uint256 desiredDenorm,\n    uint256 minimumBalance\n  );\n\n  event LOG_MINIMUM_BALANCE_UPDATED(address token, uint256 minimumBalance);\n\n  event LOG_TOKEN_READY(address indexed token);\n\n  event LOG_PUBLIC_SWAP_ENABLED();\n\n  event LOG_MAX_TOKENS_UPDATED(uint256 maxPoolTokens);\n\n  event LOG_SWAP_FEE_UPDATED(uint256 swapFee);\n\n  function configure(\n    address controller,\n    string calldata name,\n    string calldata symbol\n  ) external;\n\n  function initialize(\n    address[] calldata tokens,\n    uint256[] calldata balances,\n    uint96[] calldata denorms,\n    address tokenProvider,\n    address unbindHandler\n  ) external;\n\n  function setMaxPoolTokens(uint256 maxPoolTokens) external;\n\n  function setSwapFee(uint256 swapFee) external;\n\n  function reweighTokens(\n    address[] calldata tokens,\n    uint96[] calldata desiredDenorms\n  ) external;\n\n  function reindexTokens(\n    address[] calldata tokens,\n    uint96[] calldata desiredDenorms,\n    uint256[] calldata minimumBalances\n  ) external;\n\n  function setMinimumBalance(address token, uint256 minimumBalance) external;\n\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n\n  function joinswapExternAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    uint256 minPoolAmountOut\n  ) external returns (uint256/* poolAmountOut */);\n\n  function joinswapPoolAmountOut(\n    address tokenIn,\n    uint256 poolAmountOut,\n    uint256 maxAmountIn\n  ) external returns (uint256/* tokenAmountIn */);\n\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n\n  function exitswapPoolAmountIn(\n    address tokenOut,\n    uint256 poolAmountIn,\n    uint256 minAmountOut\n  )\n    external returns (uint256/* tokenAmountOut */);\n\n  function exitswapExternAmountOut(\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPoolAmountIn\n  ) external returns (uint256/* poolAmountIn */);\n\n  function gulp(address token) external;\n\n  function flashBorrow(\n    address recipient,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n\n  function swapExactAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    address tokenOut,\n    uint256 minAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256/* tokenAmountOut */, uint256/* spotPriceAfter */);\n\n  function swapExactAmountOut(\n    address tokenIn,\n    uint256 maxAmountIn,\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256 /* tokenAmountIn */, uint256 /* spotPriceAfter */);\n\n  function isPublicSwap() external view returns (bool);\n\n  function getSwapFee() external view returns (uint256/* swapFee */);\n\n  function getController() external view returns (address);\n\n  function getMaxPoolTokens() external view returns (uint256);\n\n  function isBound(address t) external view returns (bool);\n\n  function getNumTokens() external view returns (uint256);\n\n  function getCurrentTokens() external view returns (address[] memory tokens);\n\n  function getCurrentDesiredTokens() external view returns (address[] memory tokens);\n\n  function getDenormalizedWeight(address token) external view returns (uint256/* denorm */);\n\n  function getTokenRecord(address token) external view returns (Record memory record);\n\n  function extrapolatePoolValueFromToken() external view returns (address/* token */, uint256/* extrapolatedValue */);\n\n  function getTotalDenormalizedWeight() external view returns (uint256);\n\n  function getBalance(address token) external view returns (uint256);\n\n  function getMinimumBalance(address token) external view returns (uint256);\n\n  function getUsedBalance(address token) external view returns (uint256);\n\n  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256);\n}"
24     },
25     "temp-contracts/libraries/UniswapV2Library.sol": {
26       "content": "pragma solidity >=0.5.0;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\nlibrary UniswapV2Library {\n  using SafeMath for uint256;\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB)\n    internal\n    pure\n    returns (address token0, address token1)\n  {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  function calculatePair(\n    address factory,\n    address token0,\n    address token1\n  ) internal pure returns (address pair) {\n    pair = address(\n      uint256(\n        keccak256(\n          abi.encodePacked(\n            hex\"ff\",\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n          )\n        )\n      )\n    );\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = calculatePair(factory, token0, token1);\n  }\n\n  // fetches and sorts the reserves for a pair\n  function getReserves(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal view returns (uint256 reserveA, uint256 reserveB) {\n    (address token0, ) = sortTokens(tokenA, tokenB);\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n    (reserveA, reserveB) = tokenA == token0\n      ? (reserve0, reserve1)\n      : (reserve1, reserve0);\n  }\n\n  // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) internal pure returns (uint256 amountB) {\n    require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n    require(\n      reserveA > 0 && reserveB > 0,\n      \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n    );\n    amountB = amountA.mul(reserveB) / reserveA;\n  }\n\n  // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountOut) {\n    require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n    require(\n      reserveIn > 0 && reserveOut > 0,\n      \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n    );\n    uint256 amountInWithFee = amountIn.mul(997);\n    uint256 numerator = amountInWithFee.mul(reserveOut);\n    uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n    amountOut = numerator / denominator;\n  }\n\n  // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountIn) {\n    require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n    require(\n      reserveIn > 0 && reserveOut > 0,\n      \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n    );\n    uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n    uint256 denominator = reserveOut.sub(amountOut).mul(997);\n    amountIn = (numerator / denominator).add(1);\n  }\n\n  // performs chained getAmountOut calculations on any number of pairs\n  function getAmountsOut(\n    address factory,\n    uint256 amountIn,\n    address[] memory path\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[0] = amountIn;\n    for (uint256 i; i < path.length - 1; i++) {\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n    }\n  }\n\n  // performs chained getAmountIn calculations on any number of pairs\n  function getAmountsIn(\n    address factory,\n    uint256 amountOut,\n    address[] memory path\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[amounts.length - 1] = amountOut;\n    for (uint256 i = path.length - 1; i > 0; i--) {\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n    }\n  }\n}\n"
27     },
28     "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
29       "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
30     },
31     "@openzeppelin/contracts/math/SafeMath.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
33     }
34   },
35   "settings": {
36     "metadata": {
37       "useLiteralContent": false
38     },
39     "optimizer": {
40       "enabled": true,
41       "runs": 200
42     },
43     "outputSelection": {
44       "*": {
45         "*": [
46           "evm.bytecode",
47           "evm.deployedBytecode",
48           "abi"
49         ]
50       }
51     },
52     "libraries": {}
53   }
54 }}