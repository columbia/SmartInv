1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/AccessControl.sol": {
5       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract AccessControl {\r\n  address internal _admin;\r\n  address internal _owner;\r\n\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == _admin, \"unauthorized\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == _owner, \"unauthorized\");\r\n    _;\r\n  }\r\n\r\n  function changeAdmin(address newAdmin) external onlyOwner {\r\n    _admin = newAdmin;\r\n  }\r\n\r\n  function changeOwner(address newOwner) external onlyOwner {\r\n    _owner = newOwner;\r\n  }\r\n\r\n  function owner() external view returns (address) {\r\n    return _owner;\r\n  }\r\n}\r\n"
6     },
7     "contracts/NFTCollectionV1.sol": {
8       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./AccessControl.sol\";\r\nimport \"./interfaces/IERC165.sol\";\r\nimport \"./interfaces/IERC721.sol\";\r\nimport \"./interfaces/IERC721Metadata.sol\";\r\nimport \"./interfaces/IERC721Receiver.sol\";\r\n\r\nabstract contract NFTCollectionV1 is AccessControl, IERC165, IERC721, IERC721Metadata {\r\n  /** @dev IERC721 Fields */\r\n\r\n  mapping(address => uint256) internal _balances;\r\n  mapping(address => mapping(address => bool)) internal _operatorApprovals;\r\n  mapping(uint256 => address) internal _owners;\r\n  mapping(uint256 => address) internal _tokenApprovals;\r\n\r\n  /** @dev IERC721Enumerable */\r\n\r\n  uint256 internal _totalSupply;\r\n  uint256 internal _totalSupplyLimit;\r\n\r\n  string internal _baseURI;\r\n\r\n  /** @dev IERC165 Views */\r\n\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\r\n    return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC721Metadata).interfaceId;\r\n  }\r\n\r\n  /** @dev IERC721 Views */\r\n\r\n  /**\r\n   * @dev Returns the number of tokens in ``owner``'s account.\r\n   */\r\n  function balanceOf(address owner_) external view override returns (uint256 balance) {\r\n    return _balances[owner_];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the account approved for `tokenId` token.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function getApproved(uint256 tokenId) external view override returns (address operator) {\r\n    return _tokenApprovals[tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n   *\r\n   * See {setApprovalForAll}\r\n   */\r\n  function isApprovedForAll(address owner_, address operator) external view override returns (bool) {\r\n    return _operatorApprovals[owner_][operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the owner of the `tokenId` token.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function ownerOf(uint256 tokenId) external view override returns (address) {\r\n    return _owners[tokenId];\r\n  }\r\n\r\n  /** @dev IERC721 Mutators */\r\n\r\n  /**\r\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n   * The approval is cleared when the token is transferred.\r\n   *\r\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The caller must own the token or be an approved operator.\r\n   * - `tokenId` must exist.\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address to, uint256 tokenId) external override {\r\n    address owner_ = _owners[tokenId];\r\n\r\n    require(to != owner_, \"caller may not approve themself\");\r\n    require(msg.sender == owner_ || _operatorApprovals[owner_][msg.sender], \"unauthorized\");\r\n\r\n    _approve(to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) external override {\r\n    _ensureApprovedOrOwner(msg.sender, tokenId);\r\n    _transfer(from, to, tokenId);\r\n\r\n    if (_isContract(to)) {\r\n      IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, \"\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes calldata data\r\n  ) external override {\r\n    _ensureApprovedOrOwner(msg.sender, tokenId);\r\n    _transfer(from, to, tokenId);\r\n\r\n    if (_isContract(to)) {\r\n      IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Approve or remove `operator` as an operator for the caller.\r\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The `operator` cannot be the caller.\r\n   *\r\n   * Emits an {ApprovalForAll} event.\r\n   */\r\n  function setApprovalForAll(address operator, bool approved) external override {\r\n    require(operator != msg.sender, \"caller may not approve themself\");\r\n\r\n    _operatorApprovals[msg.sender][operator] = approved;\r\n\r\n    emit ApprovalForAll(msg.sender, operator, approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers `tokenId` token from `from` to `to`.\r\n   *\r\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must be owned by `from`.\r\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) external override {\r\n    _ensureApprovedOrOwner(msg.sender, tokenId);\r\n    _transfer(from, to, tokenId);\r\n  }\r\n\r\n  /** IERC721Metadata Views */\r\n\r\n  function tokenURI(uint256 tokenId) external view override returns (string memory) {\r\n    return string(abi.encodePacked(_baseURI, _toString(tokenId), \".json\"));\r\n  }\r\n\r\n  /** Useful Methods */\r\n\r\n  function changeBaseURI(string memory newURI) external onlyAdmin {\r\n    _baseURI = newURI;\r\n  }\r\n\r\n  function totalSupply() external view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /** Helpers */\r\n\r\n  /**\r\n   * @dev Approve `to` to operate on `tokenId`\r\n   *\r\n   * Emits a {Approval} event.\r\n   */\r\n  function _approve(address to, uint256 tokenId) private {\r\n    _tokenApprovals[tokenId] = to;\r\n\r\n    emit Approval(_owners[tokenId], to, tokenId);\r\n  }\r\n\r\n  function _ensureApprovedOrOwner(address spender, uint256 tokenId) private view {\r\n    address owner_ = _owners[tokenId];\r\n\r\n    require(\r\n      spender == owner_ || spender == _tokenApprovals[tokenId] || _operatorApprovals[owner_][spender],\r\n      \"unauthorized\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n   */\r\n  function _toString(uint256 value) internal pure returns (string memory) {\r\n    if (value == 0) {\r\n      return \"0\";\r\n    }\r\n    uint256 temp = value;\r\n    uint256 digits;\r\n    while (temp != 0) {\r\n      digits++;\r\n      temp /= 10;\r\n    }\r\n    bytes memory buffer = new bytes(digits);\r\n    while (value != 0) {\r\n      digits -= 1;\r\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n      value /= 10;\r\n    }\r\n    return string(buffer);\r\n  }\r\n\r\n  function _isContract(address account) internal view returns (bool) {\r\n    // This method relies on extcodesize, which returns 0 for contracts in\r\n    // construction, since the code is only stored at the end of the\r\n    // constructor execution.\r\n\r\n    uint256 size;\r\n\r\n    assembly {\r\n      size := extcodesize(account)\r\n    }\r\n\r\n    return size > 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers `tokenId` from `from` to `to`.\r\n   *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must be owned by `from`.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function _transfer(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) private {\r\n    require(_owners[tokenId] == from, \"transfer of token that is not own\");\r\n    require(to != address(0), \"transfer to the zero address\");\r\n\r\n    // Clear approvals from the previous owner\r\n    _approve(address(0), tokenId);\r\n\r\n    _balances[from] -= 1;\r\n    _balances[to] += 1;\r\n    _owners[tokenId] = to;\r\n\r\n    emit Transfer(from, to, tokenId);\r\n  }\r\n}\r\n"
9     },
10     "contracts/interfaces/IERC165.sol": {
11       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n  /**\r\n   * @dev Returns true if this contract implements the interface defined by\r\n   * `interfaceId`. See the corresponding\r\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n   * to learn more about how these ids are created.\r\n   *\r\n   * This function call must use less than 30 000 gas.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n"
12     },
13     "contracts/interfaces/IERC721.sol": {
14       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 {\r\n  /** Events */\r\n\r\n  /**\r\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n  /**\r\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n   */\r\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n  /**\r\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n   */\r\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n  /** Views */\r\n\r\n  /**\r\n   * @dev Returns the number of tokens in ``owner``'s account.\r\n   */\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n  /**\r\n   * @dev Returns the account approved for `tokenId` token.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n  /**\r\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n   *\r\n   * See {setApprovalForAll}\r\n   */\r\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the owner of the `tokenId` token.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n  /** Mutators */\r\n\r\n  /**\r\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n   * The approval is cleared when the token is transferred.\r\n   *\r\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The caller must own the token or be an approved operator.\r\n   * - `tokenId` must exist.\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address to, uint256 tokenId) external;\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Approve or remove `operator` as an operator for the caller.\r\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The `operator` cannot be the caller.\r\n   *\r\n   * Emits an {ApprovalForAll} event.\r\n   */\r\n  function setApprovalForAll(address operator, bool approved) external;\r\n\r\n  /**\r\n   * @dev Transfers `tokenId` token from `from` to `to`.\r\n   *\r\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must be owned by `from`.\r\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) external;\r\n}\r\n"
15     },
16     "contracts/interfaces/IERC721Metadata.sol": {
17       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata {\r\n  /**\r\n   * @dev Returns the token collection name.\r\n   */\r\n  function name() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the token collection symbol.\r\n   */\r\n  function symbol() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n   */\r\n  function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n"
18     },
19     "contracts/interfaces/IERC721Receiver.sol": {
20       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n  /**\r\n   * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n   * by `operator` from `from`, this function is called.\r\n   *\r\n   * It must return its Solidity selector to confirm the token transfer.\r\n   * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n   *\r\n   * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n   */\r\n  function onERC721Received(\r\n    address operator,\r\n    address from,\r\n    uint256 tokenId,\r\n    bytes calldata data\r\n  ) external returns (bytes4);\r\n}\r\n"
21     },
22     "contracts/MetafansCollection.sol": {
23       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.9;\r\n\r\nimport \"./Authorized.sol\";\r\nimport \"./NFTCollectionV1.sol\";\r\n\r\ncontract MetafansCollection is NFTCollectionV1, Authorized {\r\n  /** @dev Immutable */\r\n  uint256 private constant _launchLimit = 10;\r\n  uint256 private constant _mintCooldown = 10 minutes;\r\n  uint256 private constant _presaleLimit = 3;\r\n\r\n  address private immutable _partnerA;\r\n  address private immutable _partnerB;\r\n  uint256 private immutable _promoQuantity;\r\n\r\n  /** @dev Fields */\r\n\r\n  uint256 private _launchAt;\r\n  mapping(address => uint256) private _lastMintAt;\r\n  uint256 private _partnerARevenue;\r\n  uint256 private _partnerBRevenue;\r\n  uint256 private _presaleAt;\r\n  mapping(address => uint256) private _presaleClaimed;\r\n  uint256 private _price;\r\n\r\n  constructor(\r\n    string memory baseURI_,\r\n    uint256 launchAt_,\r\n    address partnerA,\r\n    address partnerB,\r\n    uint256 presaleAt_,\r\n    uint256 price,\r\n    uint256 promoQuantity_,\r\n    uint256 totalSupplyLimit_\r\n  ) {\r\n    _admin = msg.sender;\r\n    _authority = msg.sender;\r\n    _owner = msg.sender;\r\n\r\n    _baseURI = baseURI_;\r\n    _launchAt = launchAt_;\r\n    _partnerA = partnerA;\r\n    _partnerB = partnerB;\r\n    _presaleAt = presaleAt_;\r\n    _price = price;\r\n    _promoQuantity = promoQuantity_;\r\n    _totalSupplyLimit = totalSupplyLimit_;\r\n\r\n    _totalSupply = _promoQuantity;\r\n  }\r\n\r\n  /** @dev IERC721Metadata Views */\r\n\r\n  /**\r\n   * @dev Returns the token collection name.\r\n   */\r\n  function name() external pure override returns (string memory) {\r\n    return \"Metafans Collection\";\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the token collection symbol.\r\n   */\r\n  function symbol() external pure override returns (string memory) {\r\n    return \"MFC\";\r\n  }\r\n\r\n  /** @dev General Views */\r\n\r\n  function lastMintAt(address wallet) external view returns (uint256) {\r\n    return _lastMintAt[wallet];\r\n  }\r\n\r\n  function launchAt() external view returns (uint256) {\r\n    return _launchAt;\r\n  }\r\n\r\n  function presaleAt() external view returns (uint256) {\r\n    return _presaleAt;\r\n  }\r\n\r\n  function presaleClaimed(address wallet) external view returns (uint256) {\r\n    return _presaleClaimed[wallet];\r\n  }\r\n\r\n  /** @dev Admin Mutators */\r\n\r\n  function changeLaunchAt(uint256 value) external onlyAdmin {\r\n    _launchAt = value;\r\n  }\r\n\r\n  function changePresaleAt(uint256 value) external onlyAdmin {\r\n    _presaleAt = value;\r\n  }\r\n\r\n  function changePrice(uint256 value) external onlyAdmin {\r\n    _price = value;\r\n  }\r\n\r\n  /** @dev Mint Mutators */\r\n\r\n  function launchMint(uint256 quantity) external payable {\r\n    require(_launchAt < block.timestamp, \"launch has not begun\");\r\n    require(msg.value == _price * quantity, \"incorrect ETH\");\r\n    require(quantity <= _launchLimit, \"over limit\");\r\n    require(block.timestamp - _lastMintAt[msg.sender] > _mintCooldown, \"cooling down\");\r\n\r\n    _partnerShare();\r\n    _mint(quantity);\r\n  }\r\n\r\n  function presaleMint(\r\n    uint256 quantity,\r\n    uint256 deadline,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external payable authorized(msg.sender, deadline, v, r, s) {\r\n    require(_presaleAt < block.timestamp, \"presale has not begun\");\r\n    require(block.timestamp < _launchAt, \"presale has ended\");\r\n    require(block.timestamp < deadline, \"past deadline\");\r\n    require(msg.value == _price * quantity, \"incorrect ETH\");\r\n    require((_presaleClaimed[msg.sender] += quantity) <= _presaleLimit, \"over limit\");\r\n\r\n    _partnerShare();\r\n    _mint(quantity);\r\n  }\r\n\r\n  function promoMint(uint256 tokenId, address to) external onlyAdmin {\r\n    require(tokenId < _promoQuantity, \"over promo limit\");\r\n    require(_owners[tokenId] == address(0), \"already minted\");\r\n\r\n    _balances[to] += 1;\r\n    _owners[tokenId] = to;\r\n\r\n    emit Transfer(address(0), to, tokenId);\r\n  }\r\n\r\n  /** @dev Partner Views */\r\n\r\n  function partnerRevenue(address wallet) external view returns (uint256) {\r\n    if (wallet == _partnerA) {\r\n      return _partnerARevenue;\r\n    }\r\n\r\n    if (wallet == _partnerB) {\r\n      return _partnerBRevenue;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  /** @dev Partner Mutators */\r\n\r\n  function claimRevenue() external {\r\n    uint256 amount;\r\n\r\n    if (msg.sender == _partnerA) {\r\n      amount = _partnerARevenue;\r\n      _partnerARevenue = 0;\r\n    } else if (msg.sender == _partnerB) {\r\n      amount = _partnerBRevenue;\r\n      _partnerBRevenue = 0;\r\n    } else {\r\n      revert(\"unauthorized\");\r\n    }\r\n\r\n    (bool send, ) = msg.sender.call{value: amount}(\"\");\r\n\r\n    require(send, \"failed to send partner funds\");\r\n  }\r\n\r\n  /** @dev Helpers */\r\n\r\n  function _mint(uint256 quantity) private {\r\n    require(_totalSupply + quantity <= _totalSupplyLimit, \"over total supply limit\");\r\n\r\n    for (uint256 i = 0; i < quantity; i++) {\r\n      _owners[_totalSupply + i] = msg.sender;\r\n\r\n      emit Transfer(address(0), msg.sender, _totalSupply + i);\r\n    }\r\n\r\n    _balances[msg.sender] += quantity;\r\n    _totalSupply += quantity;\r\n    _lastMintAt[msg.sender] = block.timestamp;\r\n  }\r\n\r\n  function _partnerShare() private {\r\n    uint256 shareB = msg.value / 10;\r\n    uint256 shareA = msg.value - shareB;\r\n\r\n    _partnerARevenue += shareA;\r\n    _partnerBRevenue += shareB;\r\n  }\r\n}\r\n"
24     },
25     "contracts/Authorized.sol": {
26       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Authorized {\r\n  bytes32 internal immutable _domainSeparator;\r\n\r\n  address internal _authority;\r\n\r\n  constructor() {\r\n    bytes32 typeHash = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\r\n\r\n    _domainSeparator = keccak256(\r\n      abi.encode(typeHash, keccak256(bytes(\"MetaFans\")), keccak256(bytes(\"1.0.0\")), block.chainid, address(this))\r\n    );\r\n  }\r\n\r\n  modifier authorized(\r\n    address account,\r\n    uint256 deadline,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) {\r\n    bytes32 hash = keccak256(abi.encode(keccak256(\"Presale(address to,uint256 deadline)\"), account, deadline));\r\n\r\n    require(verify(hash, v, r, s), \"unauthorized\");\r\n\r\n    _;\r\n  }\r\n\r\n  function verify(\r\n    bytes32 hash,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal view returns (bool) {\r\n    return _authority == ecrecover(keccak256(abi.encodePacked(\"\\x19\\x01\", _domainSeparator, hash)), v, r, s);\r\n  }\r\n}\r\n"
27     }
28   },
29   "settings": {
30     "optimizer": {
31       "enabled": true,
32       "runs": 10000
33     },
34     "outputSelection": {
35       "*": {
36         "*": [
37           "evm.bytecode",
38           "evm.deployedBytecode",
39           "abi"
40         ]
41       }
42     }
43   }
44 }}