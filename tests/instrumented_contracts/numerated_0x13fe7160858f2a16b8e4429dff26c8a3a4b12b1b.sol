1 {{
2   "language": "Solidity",
3   "sources": {
4     "/contracts/TokenReleaser.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// We'll actually use ERC777, but any IERC20 instance (including ERC777)\n// is supported.\nimport 'openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\n\n\ncontract TokenReleaser {\n\n\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////\n    // This smart contract is divided into 3 parts: \n    //\n    // - The first part defines the different types of releases (i.e token release for seed round investor,\n    //   token release for team and advisor ...etc). Here we define the `ReleaseType` and `ReleaseSchedule`\n    //   types, and the function `setTokenomics` which associate to each ReleaseType its associated \n    //   `ReleaseSchedule`. The association between the type of release and its schedule is what we call\n    //   the `tokenomic`. Notice `setTokenomics` is called only once, therefore `tokenomic` behaves like\n    //   a constant (unfortunately, due to solidity limitations it couldn't get declared as such).\n    //\n    // - Second part defines the `Beneficiary`, which represent an user (or more generally an address),\n    //   that got some tokens booked; and the external function `releaseToken`. A beneficiary will call\n    //   `releaseToken` to receive tokens, which will be sent according to the Beneficiary's release\n    //   schedule type. Notice `releaseToken` is the only public function a non-admin user can call. \n    //\n    // - The third part defines the admins, and the action they control. Each of these actions\n    //   is represented by a function and an Event. For security and simplicity reason, we've decide\n    //   to keep a fixed max number of admins, 3 of them specifically (though by default we only enable 2 \n    //   of them). At any time, any admin can modify the list of admins. \n    //\n    // Types, variables and events are defined right before they are mentioned on code. \n\n    IERC20  public tokenContract;\n    \n    constructor(address _adminA, address _adminB, IERC20 _contract, uint256 avaliableTokens){\n        tokenContract  = _contract;\n        adminA         = _adminA;\n        adminB         = _adminB;\n        setTokenomics(avaliableTokens);\n    }\n\n\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////\n    // First part:\n\n\n    enum ReleaseType\n      { SEED_ROUND\n      , PRIVATE_ROUND\n      , STRATEGIC_ROUND\n      , PUBLIC_SALE\n      , COMPANY_RESERVE\n      , TEAM_AND_ADVISORS\n      , STRATEGIC_PARTNERS\n      , FOUNDERS_AND_EARLY_CONTRIBUTORS\n      , MINING_RESERVE\n      }\n\n    // Information about how an specific ReleaseType will be scheduled.\n    struct ReleaseSchedule\n     {  uint256 tokenLockTime             ; // lockup time after the release time starts.\n\n        uint256 tokenReleaseDuration      ; // vesting time during which the token will be gradually released.\n                                            // if 0, it means everything available at once. \n\n        uint256 immediateAccessTimeWindow ; // When the release time starts, the beneficiary will have immediate access to \n     }                                      // all the tokens to be released to him during the his `immediateAccessTimeWindow`.\n\n\n    mapping(ReleaseType => ReleaseSchedule) public tokenomic;\n    uint256 public avaliableTokensToRelease;\n    \n\n    // Defines the total amount of tokens available to get release, and how the schedule\n    // for each type of release will be. \n    function setTokenomics(uint256 avaliableTokens) private{\n\n        // NOTICE: we take a month to be equivalent to 30 days, regardless of actual calendar months.\n        // In particular, 12 month would not sum up a whole year, but 360 days.\n\n        tokenomic[ ReleaseType.SEED_ROUND                     ] = ReleaseSchedule\n         ({ tokenLockTime             :  0 * 30 days\n          , tokenReleaseDuration      : 24 * 30 days \n          , immediateAccessTimeWindow :  1 * 30 days\n          }\n         );\n\n        tokenomic[ ReleaseType.PRIVATE_ROUND                  ] = ReleaseSchedule\n         ({ tokenLockTime             :  0 * 30 days\n          , tokenReleaseDuration      : 12 * 30 days\n          , immediateAccessTimeWindow :  1 * 30 days\n          }\n         );\n\n        tokenomic[ ReleaseType.STRATEGIC_ROUND                ] = ReleaseSchedule\n         ({ tokenLockTime             :  0 * 30 days\n          , tokenReleaseDuration      : 12 * 30 days\n          , immediateAccessTimeWindow :  1 * 30 days\n          }\n         );\n\n        tokenomic[ ReleaseType.PUBLIC_SALE                    ] = ReleaseSchedule\n         ({ tokenLockTime             :  0 * 30 days\n          , tokenReleaseDuration      :  0 * 30 days\n          , immediateAccessTimeWindow :  0 * 30 days \n          } // as `tokenReleaseDuration == 0` everything is available as soon as the release time starts. \n         );\n\n        tokenomic[ ReleaseType.COMPANY_RESERVE                ] = ReleaseSchedule\n         ({ tokenLockTime             :  0 * 30 days\n          , tokenReleaseDuration      : 36 * 30 days\n          , immediateAccessTimeWindow :  1 * 30 days\n          }\n         );\n\n        tokenomic[ ReleaseType.TEAM_AND_ADVISORS              ] = ReleaseSchedule\n         ({ tokenLockTime             : 12 * 30 days\n          , tokenReleaseDuration      : 36 * 30 days\n          , immediateAccessTimeWindow :  0 * 30 days\n          }\n         );\n\n        tokenomic[ ReleaseType.STRATEGIC_PARTNERS             ] = ReleaseSchedule\n         ({ tokenLockTime             : 12 * 30 days\n          , tokenReleaseDuration      : 36 * 30 days\n          , immediateAccessTimeWindow :  0 * 30 days\n          }\n         );\n\n        tokenomic[ ReleaseType.FOUNDERS_AND_EARLY_CONTRIBUTORS] = ReleaseSchedule\n         ({ tokenLockTime             : 12 * 30 days\n          , tokenReleaseDuration      : 48 * 30 days\n          , immediateAccessTimeWindow :  0 * 30 days\n          }\n         );\n\n        tokenomic[ ReleaseType.MINING_RESERVE                 ] = ReleaseSchedule\n         ({ tokenLockTime             :  6 * 30 days\n          , tokenReleaseDuration      : 60 * 30 days\n          , immediateAccessTimeWindow :  0 * 30 days\n          }\n         );\n\n        avaliableTokensToRelease = avaliableTokens;\n    }\n    \n    \n    //////////////////////////////////////////////////////////////////////////////////////////\n    // Second Part:\n\n    struct Beneficiary\n     {  ReleaseType releaseSchedule       ;     // public sale, seed round ...\n        uint256     tokensAlreadyReleased ;\n        uint256     tokenBookedAmount     ;\n     }\n\n    uint256 public releaseStartTime;\n    mapping(address => Beneficiary) public beneficiaries;\n\n    function releaseToken() external{\n        \n        require( releaseStartTime > 0\n               , 'Release time has not started yet'\n               )\n        ;\n\n        Beneficiary memory beneficiary = beneficiaries[msg.sender];\n        \n        require( beneficiary.tokenBookedAmount != 0\n               , 'Address doesnt belong to a beneficiary set by an admin.'\n               )\n        ;\n\n\n        ReleaseSchedule memory releaseSchedule    = tokenomic[beneficiary.releaseSchedule];\n        \n        // Date the tokens locktime finish for the beneficiary. \n        uint256 startTime = releaseSchedule.tokenLockTime + releaseStartTime;\n        \n        // After the locktime has finished, there's a time window defined as `tokenReleaseDuration`. \n        // `timeCompleted` is how much of that time window has been completed.\n        // A beneficiary can only release a fraction of his token proportional to how much of this time window\n        // has been completed (or the totality of them if it is completed).\n        uint256 timeCompleted  = 0;\n        uint256 unlockedTokens = 0;\n\n        if (block.timestamp >= startTime){\n            timeCompleted = block.timestamp - startTime;\n\n            // Time completed is the maximum between the time it has passed since start, and \n            // the immediateAccessTimeWindow, capped to a max of tokenReleaseDuration.\n            if (timeCompleted < releaseSchedule.immediateAccessTimeWindow){\n                timeCompleted = releaseSchedule.immediateAccessTimeWindow;\n            }\n        \n            if (timeCompleted >= releaseSchedule.tokenReleaseDuration){\n                timeCompleted = releaseSchedule.tokenReleaseDuration;\n            }\n\n            // `tokenReleaseDuration == 0` means everything is available right after the release lock time\n            if (releaseSchedule.tokenReleaseDuration == 0){\n                unlockedTokens = beneficiary.tokenBookedAmount;\n            } else {\n                unlockedTokens = (timeCompleted * beneficiary.tokenBookedAmount) / releaseSchedule.tokenReleaseDuration;\n            }\n        }\n\n        uint256 toRelease      =  unlockedTokens - beneficiary.tokensAlreadyReleased;\n        \n        beneficiaries[msg.sender].tokensAlreadyReleased += toRelease;\n        \n        tokenContract.transfer( msg.sender, toRelease );\n        \n    }\n    \n    //////////////////////////////////////////////////////////////////////////////////////////\n    address public adminA; // active admin\n    address public adminB; // backup admin\n    address public adminT; // temporary admin, only used during key rotation for one of the other admins.\n    \n    modifier adminOnly(){\n        require( (msg.sender == adminA) || (msg.sender == adminB) || (msg.sender == adminT) \n               , 'Only admins allowed'\n               )\n        ;\n        _;\n    }\n\n    event NewAdminA(address adminA );\n    \n    function changeAdminA(address newAdminA) external adminOnly{\n        if (adminA != newAdminA){\n           emit NewAdminA(newAdminA);\n           adminA = newAdminA;\n        }\n        // Notice we don't fail when there's not a NewAdminX defined,\n        // this is on purpose, so the function becomes idempotent and\n        // it is easier to programatically interact with while\n        // deployed on testnet.  \n    }\n\n    event NewAdminB(address adminB );\n    \n    function changeAdminB(address newAdminB) external adminOnly{\n        if (adminB != newAdminB){\n           emit NewAdminB(newAdminB);\n           adminB = newAdminB;\n        }\n    }\n\n    event NewAdminT(address adminT );\n    \n    function changeAdminT(address newAdminT) external adminOnly{\n        if (adminT != newAdminT){\n           emit NewAdminT(newAdminT);\n           adminT = newAdminT;\n        }\n    }\n\n    event TokensBook(address beneficiary , uint256 tokenAmount, ReleaseType releaseSchedule); \n\n    function bookTokensFor( address beneficiary , uint256 tokenAmount, ReleaseType releaseSchedule) external adminOnly{\n        require( avaliableTokensToRelease >= tokenAmount \n               , 'Not enough token to book'\n               )\n        ;\n        require( beneficiaries[beneficiary].tokenBookedAmount == 0\n               , 'Beneficiaries can only be set once'\n               )\n        ;\n        require( tokenAmount > 0\n               , 'More than 0 token needs to be booked to set a beneficiary'\n               )\n        ;\n        avaliableTokensToRelease -= tokenAmount;\n        \n        emit TokensBook(beneficiary, tokenAmount, releaseSchedule);\n        beneficiaries[beneficiary] = Beneficiary(releaseSchedule,0,tokenAmount);\n\n    }\n\n    event ReleaseTimeStarted();\n    \n\n    function startReleaseTime() external adminOnly{\n        require( releaseStartTime == 0\n               , 'Release time has already started'\n               )\n        ;\n        releaseStartTime = block.timestamp;\n        emit ReleaseTimeStarted();\n    }\n\n    event ImmediateTokensSent(address beneficiary, uint256 amount);\n\n    // Release tokens immediately without a release schedule.\n    function immediateSendTokens(address beneficiary, uint256 amount) external adminOnly{\n\n        require( avaliableTokensToRelease >= amount \n               , 'Not enough token avaliable'\n               )\n        ;\n\n        avaliableTokensToRelease -= amount;\n        emit ImmediateTokensSent(beneficiary, amount);\n        \n        tokenContract.transfer( beneficiary, amount );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////\n    \n\n}\n\n\n\n\n"
6     },
7     "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
9     }
10   },
11   "settings": {
12     "remappings": [],
13     "optimizer": {
14       "enabled": true,
15       "runs": 2000
16     },
17     "evmVersion": "london",
18     "libraries": {},
19     "outputSelection": {
20       "*": {
21         "*": [
22           "evm.bytecode",
23           "evm.deployedBytecode",
24           "devdoc",
25           "userdoc",
26           "metadata",
27           "abi"
28         ]
29       }
30     }
31   }
32 }}