1 {"RakeFinanceTokenCrowdsale.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \u0027./RakeToken.sol\u0027;\n\ncontract RakeFinanceTokenCrowdsale {\n     using SafeMath for uint256;\n    \n    /**\n   * Event for RakeFinanceToken purchase logging\n   * @param purchaser who paid for the tokens\n   * @param beneficiary who got the tokens\n   * @param value weis paid for purchase\n   * @param amount amount of tokens purchased\n   */\n    event TokenPurchase(\n        address indexed purchaser,\n        address indexed beneficiary,\n        uint256 value,\n        uint256 amount\n    );\n\n   bool public isEnded = false;\n\n   event Ended(uint256 totalWeiRaisedInCrowdsale,uint256 unsoldTokensTransferredToOwner);\n   \n   uint256 public rate;     //Tokens per wei \n   address payable public ethBeneficiaryAccount;\n   ERC20Burnable public RakeFinanceToken;\n   \n  // ICO Stage\n  // ============\n  enum CrowdsaleStage { PreICO, ICO }\n  CrowdsaleStage public stage;      //0 for PreICO \u0026 1 for ICO Stage\n  // =============\n\n  // RakeFinanceToken Distribution\n  // =============================\n  uint256 public totalTokensForSale = 5000*(1e18); // 5000 RAK will be sold during hole Crowdsale\n  uint256 public totalTokensForSaleDuringPreICO = 2500*(1e18); // 2500 RAK will be sold during PreICO\n  uint256 public totalTokensForSaleDuringICO = 2500*(1e18); // 2500 RAK will be sold during ICO\n  // ==============================\n\n  // Amount of wei raised in Crowdsale\n  // ==================\n  uint256 public totalWeiRaisedDuringPreICO;\n  uint256 public totalWeiRaisedDuringICO;\n  // ===================\n\n  // RakeFinanceToken Amount remaining to Purchase\n  // ==================\n  uint256 public tokenRemainingForSaleInPreICO = 2500*(1e18);\n  uint256 public tokenRemainingForSaleInICO = 2500*(1e18);\n  // ===================\n\n\n  // Events\n  event EthTransferred(string text);\n  \n  //Modifier\n    address public owner;    \n    modifier onlyOwner() {\n        require (msg.sender == owner);\n        _;\n    }\n\n  // Constructor\n  // ============\n  constructor(uint256 initialRate,address payable wallet) public\n  {   \n      ethBeneficiaryAccount = wallet;\n      setCurrentRate(initialRate);\n      owner = msg.sender;\n      stage = CrowdsaleStage.PreICO; // By default it\u0027s PreICO\n      RakeFinanceToken = new RakeToken(owner); // RakeFinanceToken Deployment\n  }\n  // =============\n\n  // Crowdsale Stage Management\n  // =========================================================\n\n  // Change Crowdsale Stage. Available Options: PreICO, ICO\n  function switchToICOStage() public onlyOwner {\n      require(stage == CrowdsaleStage.PreICO);\n      stage = CrowdsaleStage.ICO;\n      setCurrentRate(5);\n  }\n\n  // Change the current rate\n  function setCurrentRate(uint256 _rate) private {\n      rate = _rate;                     \n  }\n\n  // ================ Stage Management Over =====================\n  \n   /**\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\n   * @param _beneficiary Address performing the RakeFinanceToken purchase\n   * @param _weiAmount Value in wei involved in the purchase\n   */\n  function _preValidatePurchase(\n    address _beneficiary,\n    uint256 _weiAmount\n  )\n    internal pure\n  {\n    require(_beneficiary != address(0));\n    require(_weiAmount \u003e= 1e17 wei,\"Minimum amount to invest: 0.1 ETH\");\n  }\n\n  /**\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n   * @param _beneficiary Address performing the RakeFinanceToken purchase\n   * @param _tokenAmount Number of tokens to be emitted\n   */\n  function _deliverTokens(\n    address _beneficiary,\n    uint256 _tokenAmount\n  )\n    internal\n  {\n    RakeFinanceToken.transfer(_beneficiary, _tokenAmount);\n  }\n\n  /**\n   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n   * @param _beneficiary Address receiving the tokens\n   * @param _tokenAmount Number of tokens to be purchased\n   */\n  function _processPurchase(\n    address _beneficiary,\n    uint256 _tokenAmount\n  )\n    internal\n  {\n    _deliverTokens(_beneficiary, _tokenAmount);\n  }\n\n  /**\n   * @dev Override to extend the way in which ether is converted to tokens.\n   * @param _weiAmount Value in wei to be converted into tokens\n   * @return Number of tokens that can be purchased with the specified _weiAmount\n   */\n  function _getTokenAmount(uint256 _weiAmount)\n    internal view returns (uint256)\n  {\n    return _weiAmount.mul(rate);\n  }\n\n  /**\n   * @dev Determines how ETH is stored/forwarded on purchases.\n   */\n  function _forwardFunds() internal {\n    ethBeneficiaryAccount.transfer(msg.value);\n    emit EthTransferred(\"Forwarding funds to ETH Beneficiary Account\");\n  }\n  \n  // RakeFinanceToken Purchase\n  // =========================\n  function() external payable{\n      if(isEnded){\n          revert(); //Block Incoming ETH Deposits if Crowdsale has ended\n      }\n      buyRAKToken(msg.sender);\n  }\n  \n  function buyRAKToken(address _beneficiary) public payable {\n      uint256 weiAmount = msg.value;\n      if(isEnded){\n        revert();\n      }\n      _preValidatePurchase(_beneficiary, weiAmount);\n      uint256 tokensToBePurchased = weiAmount.mul(rate);\n      if ((stage == CrowdsaleStage.PreICO) \u0026\u0026 (tokensToBePurchased \u003e tokenRemainingForSaleInPreICO)) {\n         revert();  //Block Incoming ETH Deposits for PreICO stage if tokens to be purchased, exceeds remaining tokens for sale in Pre ICO\n      }\n      \n      else if ((stage == CrowdsaleStage.ICO) \u0026\u0026 (tokensToBePurchased \u003e tokenRemainingForSaleInICO)) {\n        revert();  //Block Incoming ETH Deposits for ICO stage if tokens to be purchased, exceeds remaining tokens for sale in ICO\n      }\n      \n       // calculate RakeFinanceToken amount to be created\n       uint256 tokens = _getTokenAmount(weiAmount);\n        _processPurchase(_beneficiary, tokens);\n        emit TokenPurchase(\n          msg.sender,\n          _beneficiary,\n          weiAmount,\n          tokens\n        );\n        \n      _forwardFunds();\n      \n      if (stage == CrowdsaleStage.PreICO) {\n          totalWeiRaisedDuringPreICO = totalWeiRaisedDuringPreICO.add(weiAmount);\n          tokenRemainingForSaleInPreICO = tokenRemainingForSaleInPreICO.sub(tokensToBePurchased);\n          if(tokenRemainingForSaleInPreICO == 0){       // Switch to ICO Stage when all tokens allocated for PreICO stage are being sold out\n              switchToICOStage();\n          }\n      }\n      else if (stage == CrowdsaleStage.ICO) {\n          totalWeiRaisedDuringICO = totalWeiRaisedDuringICO.add(weiAmount);\n          tokenRemainingForSaleInICO = tokenRemainingForSaleInICO.sub(tokensToBePurchased);\n          if(tokenRemainingForSaleInICO == 0 \u0026\u0026 tokenRemainingForSaleInPreICO == 0){       // End Crowdsale when all tokens allocated for For Sale are being sold out\n              endCrowdsale();\n          }\n      }\n  }\n  \n  // Finish: Finalizing the Crowdsale.\n  // ====================================================================\n\n  function endCrowdsale() public onlyOwner {\n      require(!isEnded \u0026\u0026 stage == CrowdsaleStage.ICO,\"Should be at ICO Stage to Finalize the Crowdsale\");\n      uint256 unsoldTokens = tokenRemainingForSaleInPreICO.add(tokenRemainingForSaleInICO);\n      if (unsoldTokens \u003e 0) {\n          tokenRemainingForSaleInICO = 0;\n          tokenRemainingForSaleInPreICO = 0;\n          RakeFinanceToken.transfer(owner,unsoldTokens);\n      }\n      emit Ended(totalWeiRaised(),unsoldTokens);\n      isEnded = true;\n  }\n  // ===============================\n    \n    function balanceOf(address tokenHolder) external view returns(uint256 balance){\n        return RakeFinanceToken.balanceOf(tokenHolder);\n    }\n    \n    function totalWeiRaised() public view returns(uint256){\n        return totalWeiRaisedDuringPreICO.add(totalWeiRaisedDuringICO);\n    }\n    \n}"},"RakeToken.sol":{"content":"pragma solidity ^0.5.0;\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n\n    function _msgSender() internal view  returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view  returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view  returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view  returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public   returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view   returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public   returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`\u0027s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public   returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public  returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public  returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal  {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal  {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal  {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal  {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n   \n}\n\ncontract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller\u0027s\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``\u0027s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n}\n\ncontract RakeToken is  ERC20Burnable {\n\n    string public constant name = \"Rake Finance\";\n    string public constant symbol = \"RAK\";\n    uint8 public constant decimals = 18;  \n    \n    using SafeMath for uint256;\n\n   constructor(address owner) public {  \n     //7500 RAK Token Total Supply\n    \n      uint256 allocatedForCrowdsale = 5000;\n      uint256 ownerFunds = 2500;\n      \n      _mint(owner, ownerFunds.mul(1e18));  //2500 RAK Token to Owner\n      _mint(msg.sender, allocatedForCrowdsale.mul(1e18)); //5000 RAK Token to Crowdsale contract\n    }\n}"}}