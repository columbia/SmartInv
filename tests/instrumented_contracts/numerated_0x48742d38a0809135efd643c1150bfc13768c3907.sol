1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/minter-suite/MinterSetPriceERC20V0.sol": {
5       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"../interfaces/0.8.x/IGenArt721CoreContractV1.sol\";\nimport \"../interfaces/0.8.x/IMinterFilterV0.sol\";\nimport \"../interfaces/0.8.x/IFilteredMinterV0.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\npragma solidity 0.8.9;\n\n/**\n * @title Filtered Minter contract that allows tokens to be minted with ETH\n * or any ERC-20 token.\n * @author Art Blocks Inc.\n */\ncontract MinterSetPriceERC20V0 is ReentrancyGuard, IFilteredMinterV0 {\n    /// Core contract address this minter interacts with\n    address public immutable genArt721CoreAddress;\n\n    /// This contract handles cores with interface IV1\n    IGenArt721CoreContractV1 private immutable genArtCoreContract;\n\n    /// Minter filter address this minter interacts with\n    address public immutable minterFilterAddress;\n\n    /// Minter filter this minter may interact with.\n    IMinterFilterV0 private immutable minterFilter;\n\n    /// minterType for this minter\n    string public constant minterType = \"MinterSetPriceERC20V0\";\n\n    uint256 constant ONE_MILLION = 1_000_000;\n\n    /// projectId => are contracts allowed to mint?\n    mapping(uint256 => bool) public contractMintable;\n    /// projectId => are tokens allowed to be minted to other addresses?\n    mapping(uint256 => bool) public purchaseToDisabled;\n    /// purchaser address => projectId => number of mints purchased\n    mapping(address => mapping(uint256 => uint256)) public projectMintCounter;\n    /// projectId => maximum number of mints a given address may invoke\n    mapping(uint256 => uint256) public projectMintLimit;\n    /// projectId => has project reached its maximum number of invocations?\n    mapping(uint256 => bool) public projectMaxHasBeenInvoked;\n    /// projectId => project's maximum number of invocations\n    mapping(uint256 => uint256) public projectMaxInvocations;\n    /// projectId => price per token in wei - supersedes any defined core price\n    mapping(uint256 => uint256) private projectIdToPricePerTokenInWei;\n    /// projectId => price per token has been configured on this minter\n    mapping(uint256 => bool) private projectIdToPriceIsConfigured;\n    /// projectId => currency symbol - supersedes any defined core value\n    mapping(uint256 => string) private projectIdToCurrencySymbol;\n    /// projectId => currency address - supersedes any defined core value\n    mapping(uint256 => address) private projectIdToCurrencyAddress;\n\n    modifier onlyCoreWhitelisted() {\n        require(\n            genArtCoreContract.isWhitelisted(msg.sender),\n            \"Only Core whitelisted\"\n        );\n        _;\n    }\n\n    modifier onlyArtist(uint256 _projectId) {\n        require(\n            msg.sender ==\n                genArtCoreContract.projectIdToArtistAddress(_projectId),\n            \"Only Artist\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Initializes contract to be a Filtered Minter for\n     * `_minterFilter`, integrated with Art Blocks core contract\n     * at address `_genArt721Address`.\n     * @param _genArt721Address Art Blocks core contract for which this\n     * contract will be a minter.\n     * @param _minterFilter Minter filter for which\n     * this will a filtered minter.\n     */\n    constructor(address _genArt721Address, address _minterFilter)\n        ReentrancyGuard()\n    {\n        genArt721CoreAddress = _genArt721Address;\n        genArtCoreContract = IGenArt721CoreContractV1(_genArt721Address);\n        minterFilterAddress = _minterFilter;\n        minterFilter = IMinterFilterV0(_minterFilter);\n        require(\n            minterFilter.genArt721CoreAddress() == _genArt721Address,\n            \"Illegal contract pairing\"\n        );\n    }\n\n    /**\n     * @notice Gets your balance of the ERC-20 token currently set\n     * as the payment currency for project `_projectId`.\n     * @param _projectId Project ID to be queried.\n     * @return balance Balance of ERC-20\n     */\n    function getYourBalanceOfProjectERC20(uint256 _projectId)\n        external\n        view\n        returns (uint256 balance)\n    {\n        balance = IERC20(projectIdToCurrencyAddress[_projectId]).balanceOf(\n            msg.sender\n        );\n        return balance;\n    }\n\n    /**\n     * @notice Gets your allowance for this minter of the ERC-20\n     * token currently set as the payment currency for project\n     * `_projectId`.\n     * @param _projectId Project ID to be queried.\n     * @return remaining Remaining allowance of ERC-20\n     */\n    function checkYourAllowanceOfProjectERC20(uint256 _projectId)\n        external\n        view\n        returns (uint256 remaining)\n    {\n        remaining = IERC20(projectIdToCurrencyAddress[_projectId]).allowance(\n            msg.sender,\n            address(this)\n        );\n        return remaining;\n    }\n\n    /**\n     * @notice Sets the mint limit of a single purchaser for project\n     * `_projectId` to `_limit`.\n     * @param _projectId Project ID to set the mint limit for.\n     * @param _limit Number of times a given address may mint the\n     * project's tokens.\n     */\n    function setProjectMintLimit(uint256 _projectId, uint8 _limit)\n        external\n        onlyCoreWhitelisted\n    {\n        projectMintLimit[_projectId] = _limit;\n    }\n\n    /**\n     * @notice Sets the maximum invocations of project `_projectId` based\n     * on the value currently defined in the core contract.\n     * @param _projectId Project ID to set the maximum invocations for.\n     * @dev also checks and may refresh projectMaxHasBeenInvoked for project\n     * @dev this enables gas reduction after maxInvocations have been reached -\n     * core contracts shall still enforce a maxInvocation check during mint.\n     */\n    function setProjectMaxInvocations(uint256 _projectId)\n        external\n        onlyCoreWhitelisted\n    {\n        uint256 invocations;\n        uint256 maxInvocations;\n        (, , invocations, maxInvocations, , , , , ) = genArtCoreContract\n            .projectTokenInfo(_projectId);\n        // update storage with results\n        projectMaxInvocations[_projectId] = maxInvocations;\n        if (invocations < maxInvocations) {\n            projectMaxHasBeenInvoked[_projectId] = false;\n        }\n    }\n\n    /**\n     * @notice Toggles if contracts are allowed to mint tokens for\n     * project `_projectId`.\n     * @param _projectId Project ID to be toggled.\n     */\n    function toggleContractMintable(uint256 _projectId)\n        external\n        onlyCoreWhitelisted\n    {\n        contractMintable[_projectId] = !contractMintable[_projectId];\n    }\n\n    /**\n     * @notice Toggles if purchases to other address are enabled for\n     * project `_projectId`.\n     * @param _projectId Project ID to be toggled.\n     */\n    function togglePurchaseToDisabled(uint256 _projectId)\n        external\n        onlyCoreWhitelisted\n    {\n        purchaseToDisabled[_projectId] = !purchaseToDisabled[_projectId];\n        emit PurchaseToDisabledUpdated(\n            _projectId,\n            purchaseToDisabled[_projectId]\n        );\n    }\n\n    /**\n     * @notice Updates this minter's price per token of project `_projectId`\n     * to be '_pricePerTokenInWei`, in Wei.\n     * This price supersedes any legacy core contract price per token value.\n     */\n    function updatePricePerTokenInWei(\n        uint256 _projectId,\n        uint256 _pricePerTokenInWei\n    ) external onlyArtist(_projectId) {\n        projectIdToPricePerTokenInWei[_projectId] = _pricePerTokenInWei;\n        projectIdToPriceIsConfigured[_projectId] = true;\n        emit PricePerTokenInWeiUpdated(_projectId, _pricePerTokenInWei);\n    }\n\n    /**\n     * @notice Updates payment currency of project `_projectId` to be\n     * `_currencySymbol` at address `_currencyAddress`.\n     * @param _projectId Project ID to update.\n     * @param _currencySymbol Currency symbol.\n     * @param _currencyAddress Currency address.\n     */\n    function updateProjectCurrencyInfo(\n        uint256 _projectId,\n        string memory _currencySymbol,\n        address _currencyAddress\n    ) external onlyArtist(_projectId) {\n        // require null address if symbol is \"ETH\"\n        require(\n            (keccak256(abi.encodePacked(_currencySymbol)) ==\n                keccak256(abi.encodePacked(\"ETH\"))) ==\n                (_currencyAddress == address(0)),\n            \"ETH is only null address\"\n        );\n        projectIdToCurrencySymbol[_projectId] = _currencySymbol;\n        projectIdToCurrencyAddress[_projectId] = _currencyAddress;\n        emit ProjectCurrencyInfoUpdated(\n            _projectId,\n            _currencyAddress,\n            _currencySymbol\n        );\n    }\n\n    /**\n     * @notice Purchases a token from project `_projectId`.\n     * @param _projectId Project ID to mint a token on.\n     * @return tokenId Token ID of minted token\n     */\n    function purchase(uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId)\n    {\n        tokenId = purchaseTo(msg.sender, _projectId);\n        return tokenId;\n    }\n\n    /**\n     * @notice Purchases a token from project `_projectId` and sets\n     * the token's owner to `_to`.\n     * @param _to Address to be the new token's owner.\n     * @param _projectId Project ID to mint a token on.\n     * @return tokenId Token ID of minted token\n     */\n    function purchaseTo(address _to, uint256 _projectId)\n        public\n        payable\n        nonReentrant\n        returns (uint256 tokenId)\n    {\n        // CHECKS\n        require(\n            !projectMaxHasBeenInvoked[_projectId],\n            \"Maximum number of invocations reached\"\n        );\n\n        // require artist to have configured price of token on this minter\n        require(\n            projectIdToPriceIsConfigured[_projectId],\n            \"Price not configured\"\n        );\n\n        // if contract filter is off, allow calls from another contract\n        if (!contractMintable[_projectId]) {\n            require(msg.sender == tx.origin, \"No Contract Buys\");\n        }\n\n        // if purchaseTo is disabled, enforce purchase destination to be the TX\n        // sending address.\n        if (purchaseToDisabled[_projectId]) {\n            require(msg.sender == _to, \"No `purchaseTo` Allowed\");\n        }\n\n        // limit mints per address by project\n        if (projectMintLimit[_projectId] > 0) {\n            require(\n                projectMintCounter[msg.sender][_projectId] <\n                    projectMintLimit[_projectId],\n                \"Reached minting limit\"\n            );\n            // EFFECTS\n            projectMintCounter[msg.sender][_projectId]++;\n        }\n\n        tokenId = minterFilter.mint(_to, _projectId, msg.sender);\n        // what if projectMaxInvocations[_projectId] is 0 (default value)?\n        // that is intended, so that by default the minter allows infinite transactions,\n        // allowing the artblocks contract to stop minting\n        // uint256 tokenInvocation = tokenId % ONE_MILLION;\n        if (\n            projectMaxInvocations[_projectId] > 0 &&\n            tokenId % ONE_MILLION == projectMaxInvocations[_projectId] - 1\n        ) {\n            projectMaxHasBeenInvoked[_projectId] = true;\n        }\n\n        // INTERACTIONS\n        if (projectIdToCurrencyAddress[_projectId] != address(0)) {\n            require(\n                msg.value == 0,\n                \"this project accepts a different currency and cannot accept ETH\"\n            );\n            require(\n                IERC20(projectIdToCurrencyAddress[_projectId]).allowance(\n                    msg.sender,\n                    address(this)\n                ) >= projectIdToPricePerTokenInWei[_projectId],\n                \"Insufficient Funds Approved for TX\"\n            );\n            require(\n                IERC20(projectIdToCurrencyAddress[_projectId]).balanceOf(\n                    msg.sender\n                ) >= projectIdToPricePerTokenInWei[_projectId],\n                \"Insufficient balance.\"\n            );\n            _splitFundsERC20(_projectId);\n        } else {\n            require(\n                msg.value >= projectIdToPricePerTokenInWei[_projectId],\n                \"Must send minimum value to mint!\"\n            );\n            _splitFundsETH(_projectId);\n        }\n\n        return tokenId;\n    }\n\n    /**\n     * @dev splits ETH funds between sender (if refund), foundation,\n     * artist, and artist's additional payee for a token purchased on\n     * project `_projectId`.\n     * @dev utilizes transfer() to send ETH, so access lists may need to be\n     * populated when purchasing tokens.\n     */\n    function _splitFundsETH(uint256 _projectId) internal {\n        if (msg.value > 0) {\n            uint256 pricePerTokenInWei = projectIdToPricePerTokenInWei[\n                _projectId\n            ];\n            uint256 refund = msg.value - pricePerTokenInWei;\n            if (refund > 0) {\n                (bool success_, ) = msg.sender.call{value: refund}(\"\");\n                require(success_, \"Refund failed\");\n            }\n            uint256 foundationAmount = (pricePerTokenInWei *\n                genArtCoreContract.artblocksPercentage()) / 100;\n            if (foundationAmount > 0) {\n                (bool success_, ) = genArtCoreContract.artblocksAddress().call{\n                    value: foundationAmount\n                }(\"\");\n                require(success_, \"Foundation payment failed\");\n            }\n            uint256 projectFunds = pricePerTokenInWei - foundationAmount;\n            uint256 additionalPayeeAmount;\n            if (\n                genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                    _projectId\n                ) > 0\n            ) {\n                additionalPayeeAmount =\n                    (projectFunds *\n                        genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                            _projectId\n                        )) /\n                    100;\n                if (additionalPayeeAmount > 0) {\n                    (bool success_, ) = genArtCoreContract\n                        .projectIdToAdditionalPayee(_projectId)\n                        .call{value: additionalPayeeAmount}(\"\");\n                    require(success_, \"Additional payment failed\");\n                }\n            }\n            uint256 creatorFunds = projectFunds - additionalPayeeAmount;\n            if (creatorFunds > 0) {\n                (bool success_, ) = genArtCoreContract\n                    .projectIdToArtistAddress(_projectId)\n                    .call{value: creatorFunds}(\"\");\n                require(success_, \"Artist payment failed\");\n            }\n        }\n    }\n\n    /**\n     * @dev splits ERC-20 funds between foundation, artist, and artist's\n     * additional payee, for a token purchased on project `_projectId`.\n     */\n    function _splitFundsERC20(uint256 _projectId) internal {\n        uint256 pricePerTokenInWei = projectIdToPricePerTokenInWei[_projectId];\n        uint256 foundationAmount = (pricePerTokenInWei *\n            genArtCoreContract.artblocksPercentage()) / 100;\n        if (foundationAmount > 0) {\n            IERC20(projectIdToCurrencyAddress[_projectId]).transferFrom(\n                msg.sender,\n                genArtCoreContract.artblocksAddress(),\n                foundationAmount\n            );\n        }\n        uint256 projectFunds = pricePerTokenInWei - foundationAmount;\n        uint256 additionalPayeeAmount;\n        if (\n            genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                _projectId\n            ) > 0\n        ) {\n            additionalPayeeAmount =\n                (projectFunds *\n                    genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                        _projectId\n                    )) /\n                100;\n            if (additionalPayeeAmount > 0) {\n                IERC20(projectIdToCurrencyAddress[_projectId]).transferFrom(\n                    msg.sender,\n                    genArtCoreContract.projectIdToAdditionalPayee(_projectId),\n                    additionalPayeeAmount\n                );\n            }\n        }\n        uint256 creatorFunds = projectFunds - additionalPayeeAmount;\n        if (creatorFunds > 0) {\n            IERC20(projectIdToCurrencyAddress[_projectId]).transferFrom(\n                msg.sender,\n                genArtCoreContract.projectIdToArtistAddress(_projectId),\n                creatorFunds\n            );\n        }\n    }\n\n    /**\n     * @notice Gets if price of token is configured, price of minting a\n     * token on project `_projectId`, and currency symbol and address to be\n     * used as payment. Supersedes any core contract price information.\n     * @param _projectId Project ID to get price information for.\n     * @return isConfigured true only if token price has been configured on\n     * this minter\n     * @return tokenPriceInWei current price of token on this minter - invalid\n     * if price has not yet been configured\n     * @return currencySymbol currency symbol for purchases of project on this\n     * minter. \"ETH\" reserved for ether.\n     * @return currencyAddress currency address for purchases of project on\n     * this minter. Null address reserved for ether.\n     */\n    function getPriceInfo(uint256 _projectId)\n        external\n        view\n        returns (\n            bool isConfigured,\n            uint256 tokenPriceInWei,\n            string memory currencySymbol,\n            address currencyAddress\n        )\n    {\n        isConfigured = projectIdToPriceIsConfigured[_projectId];\n        tokenPriceInWei = projectIdToPricePerTokenInWei[_projectId];\n        currencyAddress = projectIdToCurrencyAddress[_projectId];\n        if (currencyAddress == address(0)) {\n            // defaults to ETH\n            currencySymbol = \"ETH\";\n        } else {\n            currencySymbol = projectIdToCurrencySymbol[_projectId];\n        }\n    }\n}\n"
6     },
7     "contracts/interfaces/0.8.x/IGenArt721CoreContractV1.sol": {
8       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IGenArt721CoreContractV1 {\n    event Mint(\n        address indexed _to,\n        uint256 indexed _tokenId,\n        uint256 indexed _projectId\n    );\n\n    // getter function of public variable\n    function admin() external view returns (address);\n\n    // getter function of public variable\n    function nextProjectId() external view returns (uint256);\n\n    // getter function of public mapping\n    function tokenIdToProjectId(uint256 tokenId)\n        external\n        view\n        returns (uint256 projectId);\n\n    function isWhitelisted(address sender) external view returns (bool);\n\n    // @dev this is not available in V0\n    function isMintWhitelisted(address minter) external view returns (bool);\n\n    function projectIdToArtistAddress(uint256 _projectId)\n        external\n        view\n        returns (address payable);\n\n    function projectIdToAdditionalPayee(uint256 _projectId)\n        external\n        view\n        returns (address payable);\n\n    function projectIdToAdditionalPayeePercentage(uint256 _projectId)\n        external\n        view\n        returns (uint256);\n\n    function projectTokenInfo(uint256 _projectId)\n        external\n        view\n        returns (\n            address,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            address,\n            uint256,\n            string memory,\n            address\n        );\n\n    function artblocksAddress() external view returns (address payable);\n\n    function artblocksPercentage() external view returns (uint256);\n\n    function mint(\n        address _to,\n        uint256 _projectId,\n        address _by\n    ) external returns (uint256 tokenId);\n\n    function getRoyaltyData(uint256 _tokenId)\n        external\n        view\n        returns (\n            address artistAddress,\n            address additionalPayee,\n            uint256 additionalPayeePercentage,\n            uint256 royaltyFeeByID\n        );\n}\n"
9     },
10     "contracts/interfaces/0.8.x/IMinterFilterV0.sol": {
11       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IMinterFilterV0 {\n    /**\n     * @notice Approved minter `_minterAddress`.\n     */\n    event MinterApproved(address indexed _minterAddress, string _minterType);\n\n    /**\n     * @notice Revoked approval for minter `_minterAddress`\n     */\n    event MinterRevoked(address indexed _minterAddress);\n\n    /**\n     * @notice Minter `_minterAddress` of type `_minterType`\n     * registered for project `_projectId`.\n     */\n    event ProjectMinterRegistered(\n        uint256 indexed _projectId,\n        address indexed _minterAddress,\n        string _minterType\n    );\n\n    /**\n     * @notice Any active minter removed for project `_projectId`.\n     */\n    event ProjectMinterRemoved(uint256 indexed _projectId);\n\n    function genArt721CoreAddress() external returns (address);\n\n    function setMinterForProject(uint256, address) external;\n\n    function removeMinterForProject(uint256) external;\n\n    function mint(\n        address _to,\n        uint256 _projectId,\n        address sender\n    ) external returns (uint256);\n\n    function getMinterForProject(uint256) external view returns (address);\n\n    function projectHasMinter(uint256) external view returns (bool);\n}\n"
12     },
13     "contracts/interfaces/0.8.x/IFilteredMinterV0.sol": {
14       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IFilteredMinterV0 {\n    /**\n     * @notice Price per token in wei updated for project `_projectId` to\n     * `_pricePerTokenInWei`.\n     */\n    event PricePerTokenInWeiUpdated(\n        uint256 indexed _projectId,\n        uint256 indexed _pricePerTokenInWei\n    );\n\n    /**\n     * @notice Currency updated for project `_projectId` to symbol\n     * `_currencySymbol` and address `_currencyAddress`.\n     */\n    event ProjectCurrencyInfoUpdated(\n        uint256 indexed _projectId,\n        address indexed _currencyAddress,\n        string _currencySymbol\n    );\n\n    /// togglePurchaseToDisabled updated\n    event PurchaseToDisabledUpdated(\n        uint256 indexed _projectId,\n        bool _purchaseToDisabled\n    );\n\n    // getter function of public variable\n    function minterType() external view returns (string memory);\n\n    function genArt721CoreAddress() external returns (address);\n\n    function minterFilterAddress() external returns (address);\n\n    // Triggers a purchase of a token from the desired project, to the\n    // TX-sending address.\n    function purchase(uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId);\n\n    // Triggers a purchase of a token from the desired project, to the specified\n    // receiving address.\n    function purchaseTo(address _to, uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId);\n\n    // Toggles the ability for `purchaseTo` to be called directly with a\n    // specified receiving address that differs from the TX-sending address.\n    function togglePurchaseToDisabled(uint256 _projectId) external;\n\n    // Called to make the minter contract aware of the max invocations for a\n    // given project.\n    function setProjectMaxInvocations(uint256 _projectId) external;\n\n    // Gets if token price is configured, token price in wei, currency symbol,\n    // and currency address, assuming this is project's minter.\n    // Supersedes any defined core price.\n    function getPriceInfo(uint256 _projectId)\n        external\n        view\n        returns (\n            bool isConfigured,\n            uint256 tokenPriceInWei,\n            string memory currencySymbol,\n            address currencyAddress\n        );\n}\n"
15     },
16     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
18     },
19     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
21     }
22   },
23   "settings": {
24     "optimizer": {
25       "enabled": true,
26       "runs": 100
27     },
28     "outputSelection": {
29       "*": {
30         "*": [
31           "evm.bytecode",
32           "evm.deployedBytecode",
33           "devdoc",
34           "userdoc",
35           "metadata",
36           "abi"
37         ]
38       }
39     },
40     "libraries": {}
41   }
42 }}