1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "london",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "details": {
12         "constantOptimizer": true,
13         "cse": true,
14         "deduplicate": true,
15         "inliner": true,
16         "jumpdestRemover": true,
17         "orderLiterals": true,
18         "peephole": true,
19         "yul": true,
20         "yulDetails": {
21           "optimizerSteps": "dhfoDgvulfnTUtnIf",
22           "stackAllocation": true
23         }
24       },
25       "runs": 2000
26     },
27     "remappings": [],
28     "outputSelection": {
29       "*": {
30         "*": [
31           "evm.bytecode",
32           "evm.deployedBytecode",
33           "devdoc",
34           "userdoc",
35           "metadata",
36           "abi"
37         ]
38       }
39     }
40   },
41   "sources": {
42     "@openzeppelin/contracts/security/Pausable.sol": {
43       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
44     },
45     "@openzeppelin/contracts/utils/Context.sol": {
46       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
47     },
48     "contracts/Refinery.sol": {
49       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"./interfaces/IERC1155TokenReceiver.sol\";\r\nimport \"./interfaces/IRefinery.sol\";\r\nimport \"./interfaces/IImperialGuild.sol\";\r\nimport \"./interfaces/IEON.sol\";\r\nimport \"./interfaces/IRAW.sol\";\r\n\r\ncontract Refinery is IRefinery, IERC1155TokenReceiver, Pausable {\r\n    struct UserInfo {\r\n        uint256 amount; // how many raw materials has this user added\r\n        uint256 refineEndBlock; // block your refining will be refined\r\n        uint256 lastClaimBlock; // block of your last claim\r\n    }\r\n\r\n    /* ERC1155 Refineries what they take in and what they output at what rate\r\n\r\n    struct RefineryInfo {\r\n        uint8 inputType; // raw input typeID\r\n        uint8 outputType; // refined resourse typeID\r\n        uint8 burnRate; // rate of input burn to refined per block\r\n        uint8 refineRate; // rate cut of raw to refined\r\n    }\r\n*/\r\n    uint256 public constant multiplier = 10**18;\r\n\r\n    // keys for each refinery in operation\r\n    RefineryInfo[] public refineryInfo;\r\n\r\n    address public auth;\r\n\r\n    // mapping(uint256 => Refinery) public RefineryInfo;\r\n    //maps refineries to users\r\n    mapping(uint256 => mapping(address => UserInfo)) public userRefines;\r\n\r\n    // address => allowedToCallFunctions\r\n    mapping(address => bool) private admins;\r\n\r\n    // Deposits to specified refinery\r\n    event DepositRaw(address indexed user, uint256 indexed rid, uint256 amount);\r\n\r\n    // Withdraws of unrefined\r\n    event WithdrawRaw(\r\n        address indexed user,\r\n        uint256 indexed rid,\r\n        uint256 amount\r\n    );\r\n    event EmergencyWithdrawRaw(\r\n        address indexed user,\r\n        uint256 indexed rid,\r\n        uint256 amount\r\n    );\r\n\r\n    IRAW public raw;\r\n\r\n    IEON public eon;\r\n\r\n    // emergency withdraw to allow removing unrefined without no care for the refined amount\r\n    bool public emergencyActivated;\r\n\r\n    constructor() {\r\n        _pause();\r\n        auth = msg.sender;\r\n        admins[msg.sender] = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == auth);\r\n        _;\r\n    }\r\n\r\n    modifier requireContractsSet() {\r\n        require(\r\n            address(raw) != address(0) && address(eon) != address(0),\r\n            \"Contracts not set\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier noCheaters() {\r\n        uint256 size = 0;\r\n        address acc = msg.sender;\r\n        assembly {\r\n            size := extcodesize(acc)\r\n        }\r\n\r\n        require(\r\n            admins[msg.sender] || (msg.sender == tx.origin && size == 0),\r\n            \"you're trying to cheat!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setContracts(address _raw, address _eon) external onlyOwner {\r\n        raw = IRAW(_raw);\r\n        eon = IEON(_eon);\r\n    }\r\n\r\n    /**\r\n   * store information on the types of refineries\r\n   * available to this refinery\r\n   @param _inputType the RAW ERC1155 typeId resource\r\n   @param _outputType refined output typeId\r\n   * ATTENTION reserve outputType 0 for EON ERC20\r\n   * non 0 outputType points to RAW ERC1155\r\n   @param _burnRate inputType burn rate multiplied by block time dif\r\n   @param _refineRate outputType rate\r\n   */\r\n    function addRefinery(\r\n        uint8 _inputType,\r\n        uint8 _outputType,\r\n        uint8 _burnRate,\r\n        uint8 _refineRate\r\n    ) external onlyOwner {\r\n        refineryInfo.push(\r\n            RefineryInfo({\r\n                inputType: _inputType,\r\n                outputType: _outputType,\r\n                burnRate: _burnRate,\r\n                refineRate: _refineRate\r\n            })\r\n        );\r\n    }\r\n\r\n    // update a refinery if needed\r\n    function updateRefineryInfo(\r\n        uint8 _rid,\r\n        uint8 _inputType,\r\n        uint8 _outputType,\r\n        uint8 _burnRate,\r\n        uint8 _refineRate\r\n    ) external onlyOwner {\r\n        refineryInfo[_rid].inputType = _inputType;\r\n        refineryInfo[_rid].outputType = _outputType;\r\n        refineryInfo[_rid].burnRate = _burnRate;\r\n        refineryInfo[_rid].refineRate = _refineRate;\r\n    }\r\n\r\n    function getRefineryInfo(uint256 _rid)\r\n        external\r\n        view\r\n        returns (RefineryInfo memory)\r\n    {\r\n        return refineryInfo[_rid];\r\n    }\r\n\r\n    // how long has the raw resource been refining for\r\n    function getTimeDif(uint256 _current, uint256 _lastClaim)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (_current - _lastClaim);\r\n    }\r\n\r\n    // how much of the raw resource has been refined thus far\r\n    // and what is the expected output of the refined\r\n    function pendingRefine(uint256 _rid, address _user)\r\n        external\r\n        view\r\n        returns (uint256 refining, uint256 refined)\r\n    {\r\n        RefineryInfo memory refinery = refineryInfo[_rid];\r\n        UserInfo storage user = userRefines[_rid][_user];\r\n\r\n        if (block.number < user.refineEndBlock) {\r\n            uint256 timeDif = getTimeDif(block.number, user.lastClaimBlock);\r\n            uint256 burnAmt = refinery.burnRate * timeDif;\r\n            uint256 remaining = user.amount - burnAmt;\r\n            uint256 refineRateCut = (refinery.refineRate * burnAmt) / 100;\r\n            uint256 userRefined = (burnAmt - refineRateCut);\r\n            return (remaining, userRefined);\r\n        } else if (block.number > user.refineEndBlock) {\r\n            uint256 burnAmt = user.amount;\r\n            uint256 refineRateCut = (refinery.refineRate * burnAmt) / 100;\r\n            uint256 userRefined = (burnAmt - refineRateCut);\r\n            return (0, userRefined);\r\n        }\r\n    }\r\n\r\n    // updating a refinery to check amounts still refining and\r\n    // the output of the refined, this function is called any time\r\n    // a deposit or claim is made by the user\r\n    function updateRefined(\r\n        uint256 _rid,\r\n        uint256 _amount,\r\n        address refiner\r\n    ) private returns (uint256 burn, uint256 refined) {\r\n        RefineryInfo memory refinery = refineryInfo[_rid];\r\n        UserInfo storage user = userRefines[_rid][refiner];\r\n        if (block.number < user.refineEndBlock) {\r\n            uint256 timeDif = getTimeDif(block.number, user.lastClaimBlock);\r\n            uint256 burnAmt = refinery.burnRate * timeDif;\r\n            uint256 refineRateCut = (refinery.refineRate * burnAmt) / 100;\r\n            uint256 refinedAmt = (burnAmt - refineRateCut);\r\n            uint256 updatedRefining = (user.amount - burnAmt) + _amount;\r\n            user.lastClaimBlock = block.number;\r\n            user.refineEndBlock =\r\n                (updatedRefining / refinery.burnRate) +\r\n                block.number;\r\n            user.amount = updatedRefining;\r\n            return (burnAmt, refinedAmt);\r\n        } else if (block.number > user.refineEndBlock && user.amount != 0) {\r\n            uint256 burnAmt = user.amount;\r\n            uint256 refineRateCut = ((refinery.refineRate * burnAmt) / 100);\r\n            uint256 refinedAmt = (burnAmt - refineRateCut);\r\n            user.lastClaimBlock = block.number;\r\n            user.amount = _amount;\r\n            user.refineEndBlock = (_amount / refinery.burnRate) + block.number;\r\n            return (burnAmt, refinedAmt);\r\n        }\r\n    }\r\n\r\n    /* Deposit ERC1155s to the refinery\r\n     * Claims any already refined amounts for user\r\n     * within this refinery id (_rid)\r\n     * token id needs to be the raw.typeId of the input\r\n     */\r\n    function depositRaw(\r\n        uint256 _rid,\r\n        uint256 _tokenId,\r\n        uint256 _amount\r\n    ) external whenNotPaused noCheaters {\r\n        require(tx.origin == msg.sender, \"Only EOA\");\r\n        RefineryInfo memory refinery = refineryInfo[_rid];\r\n        UserInfo storage user = userRefines[_rid][msg.sender];\r\n        uint256 typeId = refinery.inputType;\r\n        uint256 outputId = refinery.outputType;\r\n        //claim\r\n        if (user.amount > 0) {\r\n            (uint256 burnAmt, uint256 refinedAmt) = updateRefined(\r\n                _rid,\r\n                _amount,\r\n                msg.sender\r\n            );\r\n            raw.burn(typeId, burnAmt, address(this));\r\n            if ((outputId == 0)) {\r\n                uint256 mint = refinedAmt * multiplier;\r\n                eon.mint(msg.sender, mint);\r\n            } else {\r\n                raw.mint(outputId, refinedAmt, msg.sender);\r\n            }\r\n        }\r\n        require(_tokenId == refinery.inputType);\r\n        //transfer the raw ERC1155s to this contract\r\n        raw.safeTransferFrom(\r\n            address(msg.sender),\r\n            address(this),\r\n            (refinery.inputType),\r\n            _amount,\r\n            \"\"\r\n        );\r\n\r\n        //Initiate Deposit\r\n        if (user.amount == 0) {\r\n            // if the first depoist\r\n            user.refineEndBlock = (_amount / refinery.burnRate) + block.number;\r\n            user.lastClaimBlock = block.number;\r\n            user.amount += _amount;\r\n        }\r\n        emit DepositRaw(msg.sender, _rid, _amount);\r\n    }\r\n\r\n    /* withdraw UNREFINED erc1155s\r\n     * will withdraw the full unrefined input of user\r\n     * will also claim all refined\r\n     */\r\n    function withdrawRaw(uint256 _rid) external whenNotPaused noCheaters {\r\n        require(tx.origin == msg.sender, \"Only EOA\");\r\n        RefineryInfo memory refinery = refineryInfo[_rid];\r\n        UserInfo storage user = userRefines[_rid][msg.sender];\r\n        uint256 typeId = refinery.inputType;\r\n        uint256 outputId = refinery.outputType;\r\n        uint8 eonType = 0;\r\n        if (user.amount > 0) {\r\n            (uint256 burnAmt, uint256 refinedAmt) = updateRefined(\r\n                _rid,\r\n                0,\r\n                msg.sender\r\n            );\r\n            uint256 unrefined = (user.amount - burnAmt);\r\n            user.amount = 0;\r\n            raw.safeTransferFrom(\r\n                address(this),\r\n                msg.sender,\r\n                typeId,\r\n                unrefined,\r\n                \"\"\r\n            );\r\n            if (burnAmt > 0 && refinedAmt > 0) {\r\n                raw.burn(typeId, burnAmt, address(this));\r\n                if ((outputId == eonType)) {\r\n                    eon.mint(msg.sender, refinedAmt);\r\n                } else {\r\n                    raw.mint(outputId, refinedAmt, msg.sender);\r\n                }\r\n            }\r\n            emit WithdrawRaw(msg.sender, _rid, unrefined);\r\n        }\r\n    }\r\n\r\n    // Withdraw RAW resources without caring about the refined amount. EMERGENCY ONLY\r\n    // Add a rescue pause enabled modifier\r\n    function emergencyWithdraw(uint256 _rid) external {\r\n        require(emergencyActivated, \"THIS IS NOT AN EMERGENCY SITUATION\");\r\n        RefineryInfo memory refinery = refineryInfo[_rid];\r\n        UserInfo storage user = userRefines[_rid][msg.sender];\r\n        uint256 typeId = refinery.inputType;\r\n        uint256 unrefined = user.amount;\r\n\r\n        raw.safeTransferFrom(address(this), msg.sender, typeId, unrefined, \"\");\r\n        // user.amount.safeTransfer(address(msg.sender), user.amount);\r\n        user.amount = 0;\r\n        user.lastClaimBlock = block.number;\r\n    }\r\n\r\n    /** admin\r\n     * enables owner to active \"emergency mode\"\r\n     * thus allow users to withdraw unrefined resouces without the refined gained\r\n     */\r\n\r\n    function activateEmergency(bool _enabled) external onlyOwner {\r\n        emergencyActivated = _enabled;\r\n    }\r\n\r\n    /**\r\n     * enables owner to pause / unpause minting\r\n     */\r\n    function setPaused(bool _paused) external requireContractsSet onlyOwner {\r\n        if (_paused) _pause();\r\n        else _unpause();\r\n    }\r\n\r\n    /**\r\n     * enables an address to mint / burn\r\n     * @param addr the address to enable\r\n     */\r\n    function addAdmin(address addr) external onlyOwner {\r\n        admins[addr] = true;\r\n    }\r\n\r\n    /**\r\n     * disables an address from minting / burning\r\n     * @param addr the address to disbale\r\n     */\r\n    function removeAdmin(address addr) external onlyOwner {\r\n        admins[addr] = false;\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes calldata\r\n    ) external pure override returns (bytes4) {\r\n        return IERC1155TokenReceiver.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] calldata,\r\n        uint256[] calldata,\r\n        bytes calldata\r\n    ) external pure override returns (bytes4) {\r\n        return IERC1155TokenReceiver.onERC1155Received.selector;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\r\n        return\r\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\r\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\r\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\r\n    }\r\n}\r\n"
50     },
51     "contracts/interfaces/IEON.sol": {
52       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IEON {\r\n    function mint(address to, uint256 amount) external;\r\n\r\n    function burn(address from, uint256 amount) external;\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n"
53     },
54     "contracts/interfaces/IERC1155TokenReceiver.sol": {
55       "content": "// SPDX-License-Identifier: MIT LICENSE\npragma solidity >=0.8.0;\n\ninterface IERC1155TokenReceiver {\n   \n   function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external returns (bytes4);\n   }"
56     },
57     "contracts/interfaces/IImperialGuild.sol": {
58       "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface IImperialGuild {\r\n\r\n    function getBalance(\r\n        address account,\r\n        uint256 id\r\n    ) external returns(uint256);\r\n\r\n    function mint(\r\n        uint256 typeId,\r\n        uint256 paymentId,\r\n        uint16 qty,\r\n        address recipient\r\n    ) external;\r\n\r\n    function burn(\r\n        uint256 typeId,\r\n        uint16 qty,\r\n        address burnFrom\r\n    ) external;\r\n\r\n    function handlePayment(uint256 amount) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external;\r\n}\r\n"
59     },
60     "contracts/interfaces/IRAW.sol": {
61       "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRAW {\r\n\r\n    function getBalance(\r\n        address account,\r\n        uint256 id\r\n    ) external returns(uint256);\r\n\r\n    function mint(\r\n        uint256 typeId,\r\n        uint256 qty,\r\n        address recipient\r\n    ) external;\r\n\r\n    function burn(\r\n        uint256 typeId,\r\n        uint256 qty,\r\n        address burnFrom\r\n    ) external;\r\n\r\n    function updateMintBurns(\r\n        uint256 typeId,\r\n        uint256 mintQty,\r\n        uint256 burnQty\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external;\r\n\r\n}\r\n"
62     },
63     "contracts/interfaces/IRefinery.sol": {
64       "content": "// SPDX-License-Identifier: MIT LICENSE\npragma solidity ^0.8.0;\n\ninterface IRefinery {\n    \n     struct RefineryInfo {\n        uint8 inputType; // raw input typeID\n        uint8 outputType; // refined resourse typeID\n        uint8 burnRate; // rate of input burn to refined per block\n        uint8 refineRate; // rate cut of raw to refined\n    }\n    \n    function getRefineryInfo(uint256 _rid) \n    external \n    view \n    returns(RefineryInfo memory);\n\n    function pendingRefine(uint256 _rid, address _user)\n        external\n        returns (uint256 refining, uint256 refined);\n\n    function depositRaw(\n        uint256 _rid,\n        uint256 _tokenId,\n        uint256 _amount\n    ) external;\n\n    function withdrawRaw(uint256 _rid) external;\n}\n"
65     }
66   }
67 }}