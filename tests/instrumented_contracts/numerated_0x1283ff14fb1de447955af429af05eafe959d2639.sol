1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/producers/scrap/Heroes.sol": {
5       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.6;\n\ninterface IMirrorWriteRaceOracle {\n    function verify(\n        address account,\n        uint256 index,\n        bytes32[] calldata merkleProof\n    ) external returns (bool);\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/**\n * @title Heroes\n * @author MirrorXYZ\n * A example of a sybil-resistant fair-mint NFT, using merkle proofs.\n * Inspired by Loot (https://etherscan.io/address/0xff9c1b15b16263c61d017ee9f65c50e4ae0113d7)\n */\ncontract Heroes {\n    string public constant name = \"Heroes\";\n    string public constant symbol = \"HEROES\";\n    // The address of the $WRITE Race Oracle for identity.\n    address immutable oracle;\n    mapping(address => bool) public claimed;\n    uint256 nextTokenId = 1;\n    string[] private firstNames = [\n        \"Orie\",\n        \"Guadalupe\",\n        \"Nyx\",\n        \"Gertrude\",\n        \"Queenie\",\n        \"Nathaniel\",\n        \"Joyce\",\n        \"Claudine\",\n        \"Olin\",\n        \"Aeneas\",\n        \"Elige\",\n        \"Jackson\",\n        \"Euclid\",\n        \"Myrtie\",\n        \"Turner\",\n        \"Neal\",\n        \"Wilmer\",\n        \"Nat\",\n        \"Euna\",\n        \"Aline\",\n        \"Iris\",\n        \"Sofia\",\n        \"Morpheus\",\n        \"Curtis\",\n        \"Claire\",\n        \"Apinya\",\n        \"Lefteris\",\n        \"Alice\",\n        \"Hector\",\n        \"Malee\",\n        \"Geo\",\n        \"Murry\",\n        \"Anastasia\",\n        \"Kahlil\",\n        \"Paris\",\n        \"Noble\",\n        \"Clara\",\n        \"Besse\",\n        \"Wilhelmina\",\n        \"Napoleon\",\n        \"Phillip\",\n        \"Isaiah\",\n        \"Alexander\",\n        \"Lea\",\n        \"Verner\",\n        \"Verla\",\n        \"Beatrice\",\n        \"Willie\",\n        \"William\",\n        \"Elvira\",\n        \"Mildred\",\n        \"Sula\",\n        \"Dido\",\n        \"Adaline\",\n        \"Jean\",\n        \"Inez\",\n        \"Reta\",\n        \"Isidore\",\n        \"Liza\",\n        \"Rollin\",\n        \"Beverly\",\n        \"Theron\",\n        \"Moses\",\n        \"Abbie\",\n        \"Emanuel\",\n        \"Buck\",\n        \"Alphonso\",\n        \"Everett\",\n        \"Ruth\",\n        \"Easter\",\n        \"Cecil\",\n        \"Ivy\",\n        \"Mariah\",\n        \"Lottie\",\n        \"Barney\",\n        \"Adeline\",\n        \"Hazel\",\n        \"Sterling\",\n        \"Kathrine\",\n        \"Mina\",\n        \"Eva\",\n        \"Francisco\",\n        \"Neva\",\n        \"Myrle\",\n        \"Hector\",\n        \"Velva\",\n        \"Dewey\",\n        \"Manda\",\n        \"Mathilda\",\n        \"Pallas\",\n        \"Zollie\",\n        \"Lella\",\n        \"Hiram\",\n        \"Orval\",\n        \"Marcia\",\n        \"Leda\",\n        \"Patricia\",\n        \"Ellie\",\n        \"Riley\",\n        \"Evie\",\n        \"Zelia\",\n        \"Leota\",\n        \"Camilla\",\n        \"Mat\",\n        \"Helen\",\n        \"Letha\",\n        \"Thomas\",\n        \"Osie\",\n        \"Stella\",\n        \"Bernice\",\n        \"Daisy\",\n        \"Hosea\",\n        \"Frederick\",\n        \"Reese\",\n        \"Adah\",\n        \"Nettie\",\n        \"Wade\",\n        \"Hugo\",\n        \"Sipho\",\n        \"Ollie\",\n        \"Zola\",\n        \"Arlie\",\n        \"Iyana\",\n        \"Webster\",\n        \"Rae\",\n        \"Alden\",\n        \"Juno\",\n        \"Luetta\",\n        \"Raphael\",\n        \"Eura\",\n        \"Cupid\",\n        \"Priam\",\n        \"Kame\",\n        \"Louis\",\n        \"Hana\",\n        \"Lyra\",\n        \"Kholo\",\n        \"Gunnar\",\n        \"Olafur\",\n        \"Anatolia\",\n        \"Lelia\",\n        \"Agatha\",\n        \"Helga\",\n        \"Rossie\",\n        \"Katsu\",\n        \"Toku\",\n        \"Verdie\",\n        \"Nandi\",\n        \"Anna\",\n        \"Maksim\",\n        \"Mihlali\",\n        \"Aloysius\",\n        \"Mittie\",\n        \"Olive\",\n        \"Virgie\",\n        \"Gregory\",\n        \"Leah\",\n        \"Maudie\",\n        \"Fanny\",\n        \"Andres\",\n        \"Mava\",\n        \"Ines\",\n        \"Clovis\",\n        \"Clint\",\n        \"Scarlett\",\n        \"Porter\",\n        \"Isabelle\",\n        \"Mahlon\",\n        \"Elsie\",\n        \"Seth\",\n        \"Irma\",\n        \"Annis\",\n        \"Pearle\",\n        \"Dumo\",\n        \"Lamar\",\n        \"Fay\",\n        \"Olga\",\n        \"Billie\",\n        \"Maybelle\",\n        \"Santiago\",\n        \"Ludie\",\n        \"Salvador\",\n        \"Adem\",\n        \"Emir\",\n        \"Hamza\",\n        \"Emre\"\n    ];\n    string[] private lastNames = [\n        \"Galway\",\n        \"Wheeler\",\n        \"Hotty\",\n        \"Mae\",\n        \"Beale\",\n        \"Zabu\",\n        \"Robins\",\n        \"Farrell\",\n        \"Goslan\",\n        \"Garnier\",\n        \"Tow\",\n        \"Chai\",\n        \"Seong\",\n        \"Ross\",\n        \"Barbary\",\n        \"Burress\",\n        \"McLean\",\n        \"Kennedy\",\n        \"Murphy\",\n        \"Cortez\",\n        \"Aku\",\n        \"Middlemiss\",\n        \"Saxon\",\n        \"Dupont\",\n        \"Sullivan\",\n        \"Hunter\",\n        \"Gibb\",\n        \"Ali\",\n        \"Holmes\",\n        \"Griffin\",\n        \"Patel\",\n        \"Kabble\",\n        \"Brown\",\n        \"Guillan\",\n        \"Thompson\",\n        \"Doolan\",\n        \"Brownhill\",\n        \"de la Mancha\",\n        \"Crogan\",\n        \"Fitzgerald\",\n        \"Flaubert\",\n        \"Salander\",\n        \"Park\",\n        \"Singh\",\n        \"Hassan\",\n        \"Peri\",\n        \"Horgan\",\n        \"Tolin\",\n        \"Kim\",\n        \"Beckham\",\n        \"Shackley\",\n        \"Lobb\",\n        \"Yoon\",\n        \"Blanchet\",\n        \"Wang\",\n        \"Ames\",\n        \"Liu\",\n        \"Raghavan\",\n        \"Morgan\",\n        \"Xiao\",\n        \"Mills\",\n        \"Yang\",\n        \"Pabst\",\n        \"Duffey\",\n        \"Monaghan\",\n        \"Bu\",\n        \"Teague\",\n        \"Obi\",\n        \"Abberton\",\n        \"Corbin\",\n        \"Zhang\",\n        \"Kildare\",\n        \"Okoro\",\n        \"Eze\",\n        \"Rovelli\",\n        \"Garcia\",\n        \"Wareham\",\n        \"Sun\",\n        \"Langhorne\",\n        \"Liu\",\n        \"Popov\",\n        \"Howlett\"\n    ];\n    string[] private prefixes = [\n        \"President\",\n        \"General\",\n        \"Captain\",\n        \"Dr\",\n        \"Professor\",\n        \"Chancellor\",\n        \"The Honourable\",\n        \"Venerable\",\n        \"Barrister\",\n        \"Prophet\",\n        \"Evangelist\",\n        \"Senpai\",\n        \"Senator\",\n        \"Speaker\",\n        \"Sama\",\n        \"Chief\",\n        \"Ambassador\",\n        \"Nari\",\n        \"Lion-hearted\",\n        \"Tireless\",\n        \"Poet\",\n        \"Beloved\",\n        \"Godlike\",\n        \"All-Powerful\",\n        \"Sweet-spoken\",\n        \"Wise Old\",\n        \"Peerless\",\n        \"Gentle\",\n        \"Swift-footed\",\n        \"Mysterious\",\n        \"Dear\",\n        \"Revered\",\n        \"Adored\"\n    ];\n    string[] private suffixes = [\n        \"I\",\n        \"II\",\n        \"III\",\n        \"the Thoughtful\",\n        \"of the Sword\",\n        \"the Illustrious\",\n        \"from the North\",\n        \"from the South\",\n        \"the Younger\",\n        \"the Elder\",\n        \"the Wise\",\n        \"the Mighty\",\n        \"the Great\",\n        \"the Hero\",\n        \"the Adventurer\",\n        \"the Beautiful\",\n        \"the Conqueror\",\n        \"the Courageous\",\n        \"the Valiant\",\n        \"the Fair\",\n        \"the Magnificent\",\n        \"the Pious\",\n        \"the Just\",\n        \"the Peaceful\",\n        \"the Rich\",\n        \"the Learned\",\n        \"the Bold\",\n        \"the Giant\",\n        \"the Deep-minded\",\n        \"the Brilliant\",\n        \"the Joyful\",\n        \"the Famous\",\n        \"the Bard\",\n        \"the Knowing\",\n        \"the Sophisticated\",\n        \"the Enlightened\"\n    ];\n\n    mapping(uint256 => address) internal _owners;\n    mapping(address => uint256) internal _balances;\n    mapping(uint256 => address) internal _tokenApprovals;\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    constructor(address oracle_) {\n        oracle = oracle_;\n    }\n\n    // Allows any of the WRITE Race candidates to claim.\n    function claim(\n        address account,\n        uint256 index,\n        bytes32[] calldata merkleProof\n    ) public {\n        // Only one claimed per account.\n        require(!claimed[account], \"already claimed\");\n        claimed[account] = true;\n        // Prove $WRITE Race Identity.\n        require(\n            IMirrorWriteRaceOracle(oracle).verify(account, index, merkleProof),\n            \"must prove oracle\"\n        );\n        // Mint a character for this account.\n        _safeMint(account, nextTokenId);\n        // Increment the next token ID.\n        nextTokenId += 1;\n    }\n\n    // ============ Building Token URI ============\n\n    // Mostly looted from Loot: https://etherscan.io/address/0xff9c1b15b16263c61d017ee9f65c50e4ae0113d7#code\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        require(_exists(tokenId), \"nonexistent token\");\n\n        string[3] memory parts;\n        parts[\n            0\n        ] = '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 350 350\"><style>.base { fill: white; font-family: serif; font-size: 14px; }</style><rect width=\"100%\" height=\"100%\" fill=\"black\" /><text x=\"10\" y=\"20\" class=\"base\">';\n        parts[1] = getFullName(tokenId);\n        parts[2] = \"</text></svg>\";\n\n        string memory output = string(\n            abi.encodePacked(parts[0], parts[1], parts[2])\n        );\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"name\": \"Hero #',\n                        toString(tokenId),\n                        '\", \"description\": \"Heroes\", \"image\": \"data:image/svg+xml;base64,',\n                        Base64.encode(bytes(output)),\n                        '\"}'\n                    )\n                )\n            )\n        );\n        output = string(\n            abi.encodePacked(\"data:application/json;base64,\", json)\n        );\n        return output;\n    }\n\n    function getFullName(uint256 tokenId) public view returns (string memory) {\n        require(_exists(tokenId), \"nonexistent token\");\n\n        uint256 randFirst = random(\n            string(abi.encodePacked(\"f\", toString(tokenId)))\n        );\n        uint256 randLast = random(\n            string(abi.encodePacked(\"l\", toString(tokenId)))\n        );\n        uint256 randPrefix = random(\n            string(abi.encodePacked(\"p\", toString(tokenId)))\n        );\n        uint256 randSuffix = random(\n            string(abi.encodePacked(\"s\", toString(tokenId)))\n        );\n\n        bool hasPrefix = randPrefix % 21 > 13;\n        bool hasSuffix = randSuffix % 21 > 13;\n\n        string memory fullName = string(\n            abi.encodePacked(\n                firstNames[randFirst % firstNames.length],\n                \" \",\n                lastNames[randLast % lastNames.length]\n            )\n        );\n\n        if (hasPrefix) {\n            fullName = string(\n                abi.encodePacked(\n                    prefixes[randPrefix % prefixes.length],\n                    \" \",\n                    fullName\n                )\n            );\n        }\n\n        if (hasSuffix) {\n            fullName = string(\n                abi.encodePacked(\n                    fullName,\n                    \" \",\n                    suffixes[randSuffix % suffixes.length]\n                )\n            );\n        }\n\n        return fullName;\n    }\n\n    // ============ NFT Methods ============\n\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\n        return interfaceId == 0x780e9d63;\n    }\n\n    function balanceOf(address owner_) public view returns (uint256) {\n        require(owner_ != address(0), \"balance query for the zero address\");\n\n        return _balances[owner_];\n    }\n\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        address _owner = _owners[tokenId];\n\n        require(_owner != address(0), \"owner query for nonexistent token\");\n\n        return _owner;\n    }\n\n    function burn(uint256 tokenId) public {\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId),\n            \"transfer caller is not owner nor approved\"\n        );\n\n        _burn(tokenId);\n    }\n\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    function _burn(uint256 tokenId) internal {\n        address owner_ = ownerOf(tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner_] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner_, address(0), tokenId);\n    }\n\n    function approve(address to, uint256 tokenId) public virtual {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"approval to current owner\");\n\n        require(\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\n            \"approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId)\n        public\n        view\n        virtual\n        returns (address)\n    {\n        require(_exists(tokenId), \"nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address approver, bool approved) public virtual {\n        require(approver != msg.sender, \"approve to caller\");\n\n        _operatorApprovals[msg.sender][approver] = approved;\n        emit ApprovalForAll(msg.sender, approver, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId),\n            \"transfer caller is not owner nor approved\"\n        );\n\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual {\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId),\n            \"transfer caller is not owner nor approved\"\n        );\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(\n            _checkOnERC721Received(from, to, tokenId, _data),\n            \"transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        require(_exists(tokenId), \"operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"transfer to non ERC721Receiver\"\n        );\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"mint to the zero address\");\n        require(!_exists(tokenId), \"token already minted\");\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ownerOf(tokenId) == from, \"transfer of token that is not own\");\n        require(\n            to != address(0),\n            \"transfer to the zero address (use burn instead)\"\n        );\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n\n        _owners[tokenId] = to;\n        _balances[to] += 1;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (isContract(to)) {\n            try\n                IERC721Receiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    tokenId,\n                    _data\n                )\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"transfer to non ERC721Receiver implementer\");\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7f6a1666fac8ecff5dd467d0938069bc221ea9e0/contracts/utils/Address.sol\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function random(string memory input) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(input)));\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT license\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n\n/// [MIT License]\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\nlibrary Base64 {\n    bytes internal constant TABLE =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /// @notice Encodes some bytes to the base64 representation\n    function encode(bytes memory data) internal pure returns (string memory) {\n        uint256 len = data.length;\n        if (len == 0) return \"\";\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((len + 2) / 3);\n\n        // Add some extra buffer at the end\n        bytes memory result = new bytes(encodedLen + 32);\n\n        bytes memory table = TABLE;\n\n        assembly {\n            let tablePtr := add(table, 1)\n            let resultPtr := add(result, 32)\n\n            for {\n                let i := 0\n            } lt(i, len) {\n\n            } {\n                i := add(i, 3)\n                let input := and(mload(add(data, i)), 0xffffff)\n\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF)\n                )\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF)\n                )\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(input, 0x3F))), 0xFF)\n                )\n                out := shl(224, out)\n\n                mstore(resultPtr, out)\n\n                resultPtr := add(resultPtr, 4)\n            }\n\n            switch mod(len, 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n\n            mstore(result, encodedLen)\n        }\n\n        return string(result);\n    }\n}\n"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": true,
11       "runs": 2000
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "abi"
19         ]
20       }
21     },
22     "libraries": {}
23   }
24 }}