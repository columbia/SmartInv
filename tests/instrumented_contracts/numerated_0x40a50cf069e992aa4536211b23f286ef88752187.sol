1 {{
2   "language": "Solidity",
3   "sources": {
4     "src/CoWSwapEthFlow.sol": {
5       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\nimport \"./libraries/EthFlowOrder.sol\";\nimport \"./interfaces/ICoWSwapSettlement.sol\";\nimport \"./interfaces/ICoWSwapEthFlow.sol\";\nimport \"./interfaces/IWrappedNativeToken.sol\";\nimport \"./mixins/CoWSwapOnchainOrders.sol\";\nimport \"./vendored/GPv2EIP1271.sol\";\n\n/// @title CoW Swap ETH Flow\n/// @author CoW Swap Developers\ncontract CoWSwapEthFlow is\n    CoWSwapOnchainOrders,\n    EIP1271Verifier,\n    ICoWSwapEthFlow\n{\n    using EthFlowOrder for EthFlowOrder.Data;\n    using GPv2Order for GPv2Order.Data;\n    using GPv2Order for bytes;\n\n    /// @dev The address of the CoW Swap settlement contract that will be used to settle orders created by this\n    /// contract.\n    ICoWSwapSettlement public immutable cowSwapSettlement;\n\n    /// @dev The address of the contract representing the default native token in the current chain (e.g., WETH for\n    /// Ethereum mainnet).\n    IWrappedNativeToken public immutable wrappedNativeToken;\n\n    /// @dev Each ETH flow order as described in [`EthFlowOrder.Data`] can be converted to a CoW Swap order. Distinct\n    /// CoW Swap orders have non-colliding order hashes. This mapping associates some extra data to a specific CoW Swap\n    /// order. This data is stored onchain and is used to verify the ownership and validity of an ETH flow order.\n    /// An ETH flow order can be settled onchain only if converting it to a CoW Swap order and hashing yields valid\n    /// onchain data.\n    mapping(bytes32 => EthFlowOrder.OnchainData) public orders;\n\n    /// @param _cowSwapSettlement The CoW Swap settlement contract.\n    /// @param _wrappedNativeToken The default native token in the current chain (e.g., WETH on mainnet).\n    constructor(\n        ICoWSwapSettlement _cowSwapSettlement,\n        IWrappedNativeToken _wrappedNativeToken\n    ) CoWSwapOnchainOrders(address(_cowSwapSettlement)) {\n        cowSwapSettlement = _cowSwapSettlement;\n        wrappedNativeToken = _wrappedNativeToken;\n\n        _wrappedNativeToken.approve(\n            cowSwapSettlement.vaultRelayer(),\n            type(uint256).max\n        );\n    }\n\n    // The contract needs to be able to receive native tokens when unwrapping.\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    /// @inheritdoc ICoWSwapEthFlow\n    function wrapAll() external {\n        wrap(address(this).balance);\n    }\n\n    /// @inheritdoc ICoWSwapEthFlow\n    function wrap(uint256 amount) public {\n        // The fallback implementation of the standard WETH9 contract just calls `deposit`. Using the fallback instead\n        // of directly calling `deposit` is slightly cheaper in terms of gas.\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = payable(address(wrappedNativeToken)).call{\n            value: amount\n        }(\"\");\n        // The success value is intentionally disregarded. The callback of the standard WETH9 contract has no revert\n        // path in the code, so it could only revert if the internal call runs out of gas. This is not considered a\n        // security risk since a reverting internal call would just mean that calling this function has no effect.\n        success;\n    }\n\n    /// @inheritdoc ICoWSwapEthFlow\n    function unwrap(uint256 amount) external {\n        wrappedNativeToken.withdraw(amount);\n    }\n\n    /// @inheritdoc ICoWSwapEthFlow\n    function createOrder(EthFlowOrder.Data calldata order)\n        external\n        payable\n        returns (bytes32 orderHash)\n    {\n        if (msg.value != order.sellAmount + order.feeAmount) {\n            revert IncorrectEthAmount();\n        }\n\n        if (0 == order.sellAmount) {\n            revert NotAllowedZeroSellAmount();\n        }\n\n        // solhint-disable-next-line not-rely-on-time\n        if (order.validTo < block.timestamp) {\n            revert OrderIsAlreadyExpired();\n        }\n\n        EthFlowOrder.OnchainData memory onchainData = EthFlowOrder.OnchainData(\n            msg.sender,\n            order.validTo\n        );\n\n        OnchainSignature memory signature = OnchainSignature(\n            OnchainSigningScheme.Eip1271,\n            abi.encodePacked(address(this))\n        );\n\n        // The data event field includes extra information needed to settle orders with the CoW Swap API.\n        bytes memory data = abi.encodePacked(\n            order.quoteId,\n            onchainData.validTo\n        );\n\n        orderHash = broadcastOrder(\n            onchainData.owner,\n            order.toCoWSwapOrder(wrappedNativeToken),\n            signature,\n            data\n        );\n\n        if (orders[orderHash].owner != EthFlowOrder.NO_OWNER) {\n            revert OrderIsAlreadyOwned(orderHash);\n        }\n\n        orders[orderHash] = onchainData;\n    }\n\n    /// @inheritdoc ICoWSwapEthFlow\n    function invalidateOrdersIgnoringNotAllowed(\n        EthFlowOrder.Data[] calldata orderArray\n    ) external {\n        for (uint256 i = 0; i < orderArray.length; i++) {\n            _invalidateOrder(orderArray[i], false);\n        }\n    }\n\n    /// @inheritdoc ICoWSwapEthFlow\n    function invalidateOrder(EthFlowOrder.Data calldata order) public {\n        _invalidateOrder(order, true);\n    }\n\n    /// @dev Performs the same tasks as `invalidateOrder` (see documentation in `ICoWSwapEthFlow`), but also allows the\n    /// caller to ignore the revert condition `NotAllowedToInvalidateOrder`. Instead of reverting, it stops execution\n    /// without causing any state change.\n    ///\n    /// @param order order to be invalidated.\n    /// @param revertOnInvalidDeletion controls whether the function call should revert or just return.\n    function _invalidateOrder(\n        EthFlowOrder.Data calldata order,\n        bool revertOnInvalidDeletion\n    ) internal {\n        GPv2Order.Data memory cowSwapOrder = order.toCoWSwapOrder(\n            wrappedNativeToken\n        );\n        bytes32 orderHash = cowSwapOrder.hash(cowSwapDomainSeparator);\n\n        EthFlowOrder.OnchainData memory orderData = orders[orderHash];\n\n        // solhint-disable-next-line not-rely-on-time\n        bool isTradable = orderData.validTo >= block.timestamp;\n        if (\n            orderData.owner == EthFlowOrder.INVALIDATED_OWNER ||\n            orderData.owner == EthFlowOrder.NO_OWNER ||\n            (isTradable && orderData.owner != msg.sender)\n        ) {\n            if (revertOnInvalidDeletion) {\n                revert NotAllowedToInvalidateOrder(orderHash);\n            } else {\n                return;\n            }\n        }\n\n        orders[orderHash].owner = EthFlowOrder.INVALIDATED_OWNER;\n\n        bytes memory orderUid = new bytes(GPv2Order.UID_LENGTH);\n        orderUid.packOrderUidParams(\n            orderHash,\n            address(this),\n            cowSwapOrder.validTo\n        );\n\n        // solhint-disable-next-line not-rely-on-time\n        if (isTradable) {\n            // Order is valid but its owner decided to invalidate it.\n            emit OrderInvalidation(orderUid);\n        } else {\n            // The order cannot be traded anymore, so this transaction is likely triggered to get back the ETH. We are\n            // interested in knowing who is the source of the refund.\n            emit OrderRefund(orderUid, msg.sender);\n        }\n\n        uint256 filledAmount = cowSwapSettlement.filledAmount(orderUid);\n\n        // This comment argues that a CoW Swap trader does not pay more fees if a partially fillable order is\n        // (partially) settled in multiple batches rather than in one single batch of the combined size.\n        // This also means that we can refund the user assuming the worst case of settling the filled amount in a single\n        // batch without risking giving out more funds than available in the contract because of rounding issues.\n        // A CoW Swap trader is always charged exactly the amount of fees that is proportional to the filled amount\n        // rounded down to the smaller integer. The code is here:\n        // https://github.com/cowprotocol/contracts/blob/d4e0fcd58367907bf1aff54d182222eeaee793dd/src/contracts/GPv2Settlement.sol#L385-L387\n        // We show that a trader pays less in fee to CoW Swap when settiling a partially fillable order in two\n        // executions rather than a single one for the combined amount; by induction this proves our original statement.\n        // Our previous statement is equivalent to `floor(a/c) + floor(b/c) ≤ floor((a+b)/c)`. Writing a and b in terms\n        // of reminders (`a = ad*c+ar`, `b = bd*c+br`) the equation becomes `ad + bd ≤ ad + bd + floor((ar+br)/c)`,\n        // which is immediately true.\n        uint256 refundAmount;\n        unchecked {\n            // - Multiplication overflow: since this smart contract never invalidates orders on CoW Swap,\n            //   `filledAmount <= sellAmount`. Also, `feeAmount + sellAmount` is an amount of native tokens that was\n            //   originally sent by the user. As such, it cannot be larger than the amount of native tokens available,\n            //   which is smaller than 2¹²⁸/10¹⁸ ≈ 10²⁰ in all networks supported by CoW Swap so far. Since both values\n            //    are smaller than 2¹²⁸, their product does not overflow a uint256.\n            // - Subtraction underflow: again `filledAmount ≤ sellAmount`, meaning:\n            //   feeAmount * filledAmount / sellAmount ≤ feeAmount\n            uint256 feeRefundAmount = cowSwapOrder.feeAmount -\n                ((cowSwapOrder.feeAmount * filledAmount) /\n                    cowSwapOrder.sellAmount);\n\n            // - Subtraction underflow: as noted before, filledAmount ≤ sellAmount.\n            // - Addition overflow: as noted before, the user already sent feeAmount + sellAmount native tokens, which\n            //   did not overflow.\n            refundAmount =\n                cowSwapOrder.sellAmount -\n                filledAmount +\n                feeRefundAmount;\n        }\n\n        // If not enough native token is available in the contract, unwrap the needed amount.\n        if (address(this).balance < refundAmount) {\n            uint256 withdrawAmount;\n            unchecked {\n                withdrawAmount = refundAmount - address(this).balance;\n            }\n            wrappedNativeToken.withdraw(withdrawAmount);\n        }\n\n        // Using low level calls to perform the transfer avoids setting arbitrary limits to the amount of gas used in a\n        // call. Reentrancy is avoided thanks to the `nonReentrant` function modifier.\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = payable(orderData.owner).call{value: refundAmount}(\n            \"\"\n        );\n        if (!success) {\n            revert EthTransferFailed();\n        }\n    }\n\n    /// @inheritdoc ICoWSwapEthFlow\n    function isValidSignature(bytes32 orderHash, bytes memory)\n        external\n        view\n        override(EIP1271Verifier, ICoWSwapEthFlow)\n        returns (bytes4)\n    {\n        // Note: the signature parameter is ignored since all information needed to verify the validity of the order is\n        // already available onchain.\n        EthFlowOrder.OnchainData memory orderData = orders[orderHash];\n        if (\n            (orderData.owner != EthFlowOrder.NO_OWNER) &&\n            (orderData.owner != EthFlowOrder.INVALIDATED_OWNER) &&\n            // solhint-disable-next-line not-rely-on-time\n            (orderData.validTo >= block.timestamp)\n        ) {\n            return GPv2EIP1271.MAGICVALUE;\n        } else {\n            return bytes4(type(uint32).max);\n        }\n    }\n}\n"
6     },
7     "src/interfaces/ICoWSwapEthFlow.sol": {
8       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\nimport \"../libraries/EthFlowOrder.sol\";\n\n/// @title CoW Swap ETH Flow Event Interface\n/// @author CoW Swap Developers\ninterface ICoWSwapEthFlowEvents {\n    /// @dev Event emitted to notify that an order was refunded. Note that this event is not fired every time the order\n    /// is invalidated (even though the user receives all unspent ETH back). This is because we want to differenciate\n    /// the case where the user invalidates a valid order and when the user receives back the funds from an expired\n    /// order.\n    ///\n    /// @param orderUid CoW Swap's unique order identifier of the order that has been invalidated (and refunded).\n    /// @param refunder The address that triggered the order refund.\n    event OrderRefund(bytes orderUid, address indexed refunder);\n}\n\n/// @title CoW Swap ETH Flow Interface\n/// @author CoW Swap Developers\ninterface ICoWSwapEthFlow is ICoWSwapEthFlowEvents {\n    /// @dev Error thrown when trying to create a new order whose order hash is the same as an order hash that was\n    /// already assigned.\n    error OrderIsAlreadyOwned(bytes32 orderHash);\n\n    /// @dev Error thrown when trying to create an order that would be expired at the time of creation\n    error OrderIsAlreadyExpired();\n\n    /// @dev Error thrown when trying to create an order without sending the expected amount of ETH to this contract.\n    error IncorrectEthAmount();\n\n    /// @dev Error thrown when trying to create an order with a sell amount == 0\n    error NotAllowedZeroSellAmount();\n\n    /// @dev Error thrown if trying to invalidate an order while not allowed.\n    error NotAllowedToInvalidateOrder(bytes32 orderHash);\n\n    /// @dev Error thrown when unsuccessfully sending ETH to an address.\n    error EthTransferFailed();\n\n    /// @dev Function that creates and broadcasts an ETH flow order that sells native ETH. The order is paid for when\n    /// the caller sends out the transaction. The caller takes ownership of the new order.\n    ///\n    /// @param order The data describing the order to be created. See [`EthFlowOrder.Data`] for extra information on\n    /// each parameter.\n    /// @return orderHash The hash of the CoW Swap order that is created to settle the new ETH order.\n    function createOrder(EthFlowOrder.Data calldata order)\n        external\n        payable\n        returns (bytes32 orderHash);\n\n    /// @dev Marks existing ETH-flow orders as invalid and, for each order, refunds the ETH that hasn't been traded yet.\n    /// The function call will not revert, if some orders are not refundable. It will silently ignore these orders.\n    /// Note that some parameters of the orders are ignored, as for example the order expiration date and the quote id.\n    ///\n    /// @param orderArray Array of orders to be invalidated.\n    function invalidateOrdersIgnoringNotAllowed(\n        EthFlowOrder.Data[] calldata orderArray\n    ) external;\n\n    /// @dev Marks an existing ETH-flow order as invalid and refunds the ETH that hasn't been traded yet.\n    /// Note that some parameters of the orders are ignored, as for example the order expiration date and the quote id.\n    ///\n    /// @param order Order to be invalidated.\n    function invalidateOrder(EthFlowOrder.Data calldata order) external;\n\n    /// @dev EIP1271-compliant onchain signature verification function.\n    /// This function is used by the CoW Swap settlement contract to determine if an order that is signed with an\n    /// EIP1271 signature is valid. As this contract has approved the vault relayer contract, a valid signature for an\n    /// order means that the order can be traded on CoW Swap.\n    ///\n    /// @param orderHash Hash of the order to be signed. This is the EIP-712 signing hash for the specified order as\n    /// defined in the CoW Swap settlement contract.\n    /// @param signature Signature byte array. This parameter is unused since as all information needed to verify if an\n    /// order is already available onchain.\n    /// @return magicValue Either the EIP-1271 \"magic value\" indicating success (0x1626ba7e) or a different value\n    /// indicating failure (0xffffffff).\n    function isValidSignature(bytes32 orderHash, bytes memory signature)\n        external\n        view\n        returns (bytes4 magicValue);\n\n    /// @dev This function reads the  chain's native token balance of this contract (e.g., ETH for mainnet) and converts\n    // the entire amount to its wrapped version (e.g., WETH).\n    function wrapAll() external;\n\n    /// @dev This function takes the specified amount of the chain's native token (e.g., ETH for mainnet) stored by this\n    /// contract and converts it to its wrapped version (e.g., WETH).\n    ///\n    /// @param amount The amount of native tokens to convert to wrapped native tokens.\n    function wrap(uint256 amount) external;\n\n    /// @dev This function takes the specified amount of the chain's wrapped native token (e.g., WETH for mainnet)\n    /// and converts it to its unwrapped version (e.g., ETH).\n    ///\n    /// @param amount The amount of wrapped native tokens to convert to native tokens.\n    function unwrap(uint256 amount) external;\n}\n"
9     },
10     "src/interfaces/ICoWSwapOnchainOrders.sol": {
11       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\nimport \"../vendored/GPv2Order.sol\";\n\n/// @title CoW Swap Onchain Order Creator Interface\n/// @author CoW Swap Developers\ninterface ICoWSwapOnchainOrders {\n    /// @dev List of signature schemes that are supported by this contract to create orders onchain.\n    enum OnchainSigningScheme {\n        Eip1271,\n        PreSign\n    }\n\n    /// @dev Struct containing information on the signign scheme used plus the corresponding signature.\n    struct OnchainSignature {\n        /// @dev The signing scheme used by the signature data.\n        OnchainSigningScheme scheme;\n        /// @dev The data used as an order signature.\n        bytes data;\n    }\n\n    /// @dev Event emitted to broadcast an order onchain.\n    ///\n    /// @param sender The user who triggered the creation of the order. Note that this address does *not* need to be\n    /// the actual owner of the order and does not need to be related to the order or signature in any way.\n    /// For example, if a smart contract creates orders on behalf of the user, then the sender would be the user who\n    /// triggers the creation of the order, while the actual owner of the order would be the smart contract that\n    /// creates it.\n    /// @param order Information on the order that is created in this transacion. The order is expected to be a valid\n    /// order for the CoW Swap settlement contract and contain all information needed to settle it in a batch.\n    /// @param signature The signature that can be used to verify the newly created order. Note that it is always\n    /// possible to recover the owner of the order from a valid signature.\n    /// @param data Any extra data that should be passed along with the order. This will be used by the services that\n    /// collects onchain orders and no specific encoding is enforced on this field. It is supposed to encode extra\n    /// information that is not included in the order data so that it can be passed along when decoding an onchain\n    /// order. As an example, a contract that creates orders on behalf of a user could set a different expiration date\n    /// than the one specified in the order.\n    event OrderPlacement(\n        address indexed sender,\n        GPv2Order.Data order,\n        OnchainSignature signature,\n        bytes data\n    );\n\n    /// @dev Event emitted to notify that an order was invalidated.\n    ///\n    /// @param orderUid CoW Swap's unique order identifier of the order that has been invalidated.\n    event OrderInvalidation(bytes orderUid);\n}\n"
12     },
13     "src/interfaces/ICoWSwapSettlement.sol": {
14       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\n/// @title CoW Swap Settlement Contract Interface\n/// @author CoW Swap Developers\n/// @dev This interface collects the functions of the CoW Swap settlement contract that are used by the ETH flow\n/// contract.\ninterface ICoWSwapSettlement {\n    /// @dev Map each user order by UID to the amount that has been filled so\n    /// far. If this amount is larger than or equal to the amount traded in the\n    /// order (amount sold for sell orders, amount bought for buy orders) then\n    /// the order cannot be traded anymore. If the order is fill or kill, then\n    /// this value is only used to determine whether the order has already been\n    /// executed.\n    /// @param orderUid The uinique identifier to use to retrieve the filled amount.\n    function filledAmount(bytes memory orderUid) external returns (uint256);\n\n    /// @dev The address of the vault relayer: the contract that handles withdrawing tokens from the user to the\n    /// settlement contract. A user who wants to sell a token on CoW Swap must approve this contract to spend the token.\n    function vaultRelayer() external returns (address);\n}\n"
15     },
16     "src/interfaces/IWrappedNativeToken.sol": {
17       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\nimport \"../vendored/IERC20.sol\";\n\n/// @title CoW Swap Wrapped Native Token Interface\n/// @author CoW Swap Developers\ninterface IWrappedNativeToken is IERC20 {\n    /// @dev Deposit native token in exchange for wrapped netive tokens.\n    function deposit() external payable;\n\n    /// @dev Burn wrapped native tokens in exchange for native tokens.\n    /// @param amount Amount of wrapped tokens to exchange for native tokens.\n    function withdraw(uint256 amount) external;\n}\n"
18     },
19     "src/libraries/CoWSwapEip712.sol": {
20       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\n/// @title CoW Swap EIP-712 Encoding Library\n/// @author CoW Swap Developers\n/// @dev The code in this contract was largely taken from:\n/// <https://raw.githubusercontent.com/cowprotocol/contracts/v1.0.0/src/contracts/mixins/GPv2Signing.sol>\nlibrary CoWSwapEip712 {\n    /// @dev The EIP-712 domain type hash used for computing the domain separator.\n    bytes32 private constant DOMAIN_TYPE_HASH =\n        keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n\n    /// @dev The EIP-712 domain name used for computing the domain separator.\n    bytes32 private constant DOMAIN_NAME = keccak256(\"Gnosis Protocol\");\n\n    /// @dev The EIP-712 domain version used for computing the domain separator.\n    bytes32 private constant DOMAIN_VERSION = keccak256(\"v2\");\n\n    /// @dev Computes the EIP-712 domain separator of the CoW Swap settlement contract on the current network.\n    ///\n    /// @param cowSwapAddress The address of the CoW Swap settlement contract for which to compute the domain separator.\n    /// Note that there are no checks to verify that the input address points to an actual contract.\n    /// @return The domain separator of the settlement contract for the input address as computed by the settlement\n    /// contract internally.\n    function domainSeparator(address cowSwapAddress)\n        internal\n        view\n        returns (bytes32)\n    {\n        // NOTE: Currently, the only way to get the chain ID in solidity is using assembly.\n        uint256 chainId;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n\n        return\n            keccak256(\n                abi.encode(\n                    DOMAIN_TYPE_HASH,\n                    DOMAIN_NAME,\n                    DOMAIN_VERSION,\n                    chainId,\n                    cowSwapAddress\n                )\n            );\n    }\n}\n"
21     },
22     "src/libraries/EthFlowOrder.sol": {
23       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\nimport \"../vendored/GPv2Order.sol\";\nimport \"../vendored/IERC20.sol\";\n\n/// @title CoW Swap ETH Flow Order Library\n/// @author CoW Swap Developers\nlibrary EthFlowOrder {\n    /// @dev Struct collecting all parameters of an ETH flow order that need to be stored onchain.\n    struct OnchainData {\n        /// @dev The address of the user whom the order belongs to.\n        address owner;\n        /// @dev The latest timestamp in seconds when the order can be settled.\n        uint32 validTo;\n    }\n\n    /// @dev Data describing all parameters of an ETH flow order.\n    struct Data {\n        /// @dev The address of the token that should be bought for ETH. It follows the same format as in the CoW Swap\n        /// contracts, meaning that the token GPv2Transfer.BUY_ETH_ADDRESS (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n        /// represents native ETH (and should most likely not be used in this context).\n        IERC20 buyToken;\n        /// @dev The address that should receive the proceeds from the order. Note that using the address\n        /// GPv2Order.RECEIVER_SAME_AS_OWNER (i.e., the zero address) as the receiver is not allowed.\n        address receiver;\n        /// @dev The exact amount of ETH that should be sold in this order.\n        uint256 sellAmount;\n        /// @dev The minimum amount of buyToken that should be received to settle this order.\n        uint256 buyAmount;\n        /// @dev Extra data to include in the order. It is used by the CoW Swap infrastructure as extra information on\n        /// the order and has no direct effect on on-chain execution.\n        bytes32 appData;\n        /// @dev The exact amount of ETH that should be paid by the user to the CoW Swap contract after the order is\n        /// settled.\n        uint256 feeAmount;\n        /// @dev The latest timestamp in seconds when the order can be settled.\n        uint32 validTo;\n        /// @dev Flag indicating whether the order is fill-or-kill or can be filled partially.\n        bool partiallyFillable;\n        /// @dev quoteId The quote id obtained from the CoW Swap API to lock in the current price. It is not directly\n        /// used by any onchain component but is part of the information emitted onchain on order creation and may be\n        /// required for an order to be automatically picked up by the CoW Swap orderbook.\n        int64 quoteId;\n    }\n\n    /// @dev An order that is owned by this address is an order that has not yet been assigned.\n    address internal constant NO_OWNER = address(0);\n\n    /// @dev An order that is owned by this address is an order that has been invalidated. Note that this address cannot\n    /// be directly used to create orders.\n    address internal constant INVALIDATED_OWNER = address(type(uint160).max);\n\n    /// @dev Error returned if the receiver of the ETH flow order is unspecified (`GPv2Order.RECEIVER_SAME_AS_OWNER`).\n    error ReceiverMustBeSet();\n\n    /// @dev Transforms an ETH flow order into the CoW Swap order that can be settled by the ETH flow contract.\n    ///\n    /// @param order The ETH flow order to be converted.\n    /// @param wrappedNativeToken The address of the wrapped native token for the current network (e.g., WETH for\n    /// Ethereum mainet).\n    /// @return The CoW Swap order data that represents the user order in the ETH flow contract.\n    function toCoWSwapOrder(Data memory order, IERC20 wrappedNativeToken)\n        internal\n        pure\n        returns (GPv2Order.Data memory)\n    {\n        if (order.receiver == GPv2Order.RECEIVER_SAME_AS_OWNER) {\n            // The receiver field specified which address is going to receive the proceeds from the orders. If using\n            // `RECEIVER_SAME_AS_OWNER`, then the receiver is implicitly assumed by the CoW Swap Protocol to be the\n            // same as the order owner.\n            // However, the owner of an ETH flow order is always the ETH flow smart contract, and any ERC20 tokens sent\n            // to this contract would be lost.\n            revert ReceiverMustBeSet();\n        }\n\n        // Note that not all fields from `order` are used in creating the corresponding CoW Swap order.\n        // For example, validTo and quoteId are ignored.\n        return\n            GPv2Order.Data(\n                wrappedNativeToken, // IERC20 sellToken\n                order.buyToken, // IERC20 buyToken\n                order.receiver, // address receiver\n                order.sellAmount, // uint256 sellAmount\n                order.buyAmount, // uint256 buyAmount\n                // This CoW Swap order is not allowed to expire. If it expired, then any solver of CoW Swap contract\n                // would be allowed to clear the `filledAmount` for this order using `freeFilledAmountStorage`, making\n                // it impossible to detect if the order has been previously filled.\n                // Note that order.validTo is disregarded in building the CoW Swap order.\n                type(uint32).max, // uint32 validTo\n                order.appData, // bytes32 appData\n                order.feeAmount, // uint256 feeAmount\n                // Only sell orders are allowed. In a buy order, any leftover ETH would stay in the ETH flow contract\n                // and would need to be sent back to the user, whose extra gas cost is usually not worth it.\n                GPv2Order.KIND_SELL, // bytes32 kind\n                order.partiallyFillable, // bool partiallyFillable\n                // We do not currently support interacting with the Balancer vault.\n                GPv2Order.BALANCE_ERC20, // bytes32 sellTokenBalance\n                GPv2Order.BALANCE_ERC20 // bytes32 buyTokenBalance\n            );\n    }\n}\n"
24     },
25     "src/mixins/CoWSwapOnchainOrders.sol": {
26       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\nimport \"../vendored/GPv2Order.sol\";\nimport \"../interfaces/ICoWSwapOnchainOrders.sol\";\nimport \"../libraries/CoWSwapEip712.sol\";\n\n/// @title CoW Swap Onchain Order Creator Event Emitter\n/// @author CoW Swap Developers\ncontract CoWSwapOnchainOrders is ICoWSwapOnchainOrders {\n    using GPv2Order for GPv2Order.Data;\n    using GPv2Order for bytes;\n\n    /// @dev The domain separator for the CoW Swap settlement contract.\n    bytes32 internal immutable cowSwapDomainSeparator;\n\n    /// @param settlementContractAddress The address of CoW Swap's settlement contract on the chain where this contract\n    /// is deployed.\n    constructor(address settlementContractAddress) {\n        cowSwapDomainSeparator = CoWSwapEip712.domainSeparator(\n            settlementContractAddress\n        );\n    }\n\n    /// @dev Emits an event with all information needed to execute an order onchain and returns the corresponding order\n    /// hash.\n    ///\n    /// See [`ICoWSwapOnchainOrders.OrderPlacement`] for details on the meaning of each parameter.\n    /// @return The EIP-712 hash of the order data as computed by the CoW Swap settlement contract.\n    function broadcastOrder(\n        address sender,\n        GPv2Order.Data memory order,\n        OnchainSignature memory signature,\n        bytes memory data\n    ) internal returns (bytes32) {\n        emit OrderPlacement(sender, order, signature, data);\n        return order.hash(cowSwapDomainSeparator);\n    }\n}\n"
27     },
28     "src/vendored/GPv2EIP1271.sol": {
29       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\n// Vendored from GPv2 contracts v1.0.0, see:\n// <https://raw.githubusercontent.com/cowprotocol/contracts/main/src/contracts/interfaces/GPv2EIP1271.sol>\n// The following changes were made:\n// - Bumped up Solidity version.\n\nlibrary GPv2EIP1271 {\n    /// @dev Value returned by a call to `isValidSignature` if the signature\n    /// was verified successfully. The value is defined in EIP-1271 as:\n    /// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))\n    bytes4 internal constant MAGICVALUE = 0x1626ba7e;\n}\n\n/// @title EIP1271 Interface\n/// @dev Standardized interface for an implementation of smart contract\n/// signatures as described in EIP-1271. The code that follows is identical to\n/// the code in the standard with the exception of formatting and syntax\n/// changes to adapt the code to our Solidity version.\ninterface EIP1271Verifier {\n    /// @dev Should return whether the signature provided is valid for the\n    /// provided data\n    /// @param _hash      Hash of the data to be signed\n    /// @param _signature Signature byte array associated with _data\n    ///\n    /// MUST return the bytes4 magic value 0x1626ba7e when function passes.\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for\n    /// solc > 0.5)\n    /// MUST allow external calls\n    ///\n    function isValidSignature(bytes32 _hash, bytes memory _signature)\n        external\n        view\n        returns (bytes4 magicValue);\n}\n"
30     },
31     "src/vendored/GPv2Order.sol": {
32       "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\n\n// Vendored from GPv2 contracts v1.0.0, see:\n// <https://raw.githubusercontent.com/cowprotocol/contracts/v1.0.0/src/contracts/libraries/GPv2Order.sol>\n// The following changes were made:\n// - Bumped up Solidity version.\n// - Vendored imports.\n\npragma solidity ^0.8;\n\nimport \"./IERC20.sol\";\n\n/// @title Gnosis Protocol v2 Order Library\n/// @author Gnosis Developers\nlibrary GPv2Order {\n    /// @dev The complete data for a Gnosis Protocol order. This struct contains\n    /// all order parameters that are signed for submitting to GP.\n    struct Data {\n        IERC20 sellToken;\n        IERC20 buyToken;\n        address receiver;\n        uint256 sellAmount;\n        uint256 buyAmount;\n        uint32 validTo;\n        bytes32 appData;\n        uint256 feeAmount;\n        bytes32 kind;\n        bool partiallyFillable;\n        bytes32 sellTokenBalance;\n        bytes32 buyTokenBalance;\n    }\n\n    /// @dev The order EIP-712 type hash for the [`GPv2Order.Data`] struct.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\n    ///     \"Order(\" +\n    ///         \"address sellToken,\" +\n    ///         \"address buyToken,\" +\n    ///         \"address receiver,\" +\n    ///         \"uint256 sellAmount,\" +\n    ///         \"uint256 buyAmount,\" +\n    ///         \"uint32 validTo,\" +\n    ///         \"bytes32 appData,\" +\n    ///         \"uint256 feeAmount,\" +\n    ///         \"string kind,\" +\n    ///         \"bool partiallyFillable\" +\n    ///         \"string sellTokenBalance\" +\n    ///         \"string buyTokenBalance\" +\n    ///     \")\"\n    /// )\n    /// ```\n    bytes32 internal constant TYPE_HASH =\n        hex\"d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489\";\n\n    /// @dev The marker value for a sell order for computing the order struct\n    /// hash. This allows the EIP-712 compatible wallets to display a\n    /// descriptive string for the order kind (instead of 0 or 1).\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"sell\")\n    /// ```\n    bytes32 internal constant KIND_SELL =\n        hex\"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775\";\n\n    /// @dev The OrderKind marker value for a buy order for computing the order\n    /// struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"buy\")\n    /// ```\n    bytes32 internal constant KIND_BUY =\n        hex\"6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc\";\n\n    /// @dev The TokenBalance marker value for using direct ERC20 balances for\n    /// computing the order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"erc20\")\n    /// ```\n    bytes32 internal constant BALANCE_ERC20 =\n        hex\"5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9\";\n\n    /// @dev The TokenBalance marker value for using Balancer Vault external\n    /// balances (in order to re-use Vault ERC20 approvals) for computing the\n    /// order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"external\")\n    /// ```\n    bytes32 internal constant BALANCE_EXTERNAL =\n        hex\"abee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632\";\n\n    /// @dev The TokenBalance marker value for using Balancer Vault internal\n    /// balances for computing the order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"internal\")\n    /// ```\n    bytes32 internal constant BALANCE_INTERNAL =\n        hex\"4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce\";\n\n    /// @dev Marker address used to indicate that the receiver of the trade\n    /// proceeds should the owner of the order.\n    ///\n    /// This is chosen to be `address(0)` for gas efficiency as it is expected\n    /// to be the most common case.\n    address internal constant RECEIVER_SAME_AS_OWNER = address(0);\n\n    /// @dev The byte length of an order unique identifier.\n    uint256 internal constant UID_LENGTH = 56;\n\n    /// @dev Returns the actual receiver for an order. This function checks\n    /// whether or not the [`receiver`] field uses the marker value to indicate\n    /// it is the same as the order owner.\n    ///\n    /// @return receiver The actual receiver of trade proceeds.\n    function actualReceiver(Data memory order, address owner)\n        internal\n        pure\n        returns (address receiver)\n    {\n        if (order.receiver == RECEIVER_SAME_AS_OWNER) {\n            receiver = owner;\n        } else {\n            receiver = order.receiver;\n        }\n    }\n\n    /// @dev Return the EIP-712 signing hash for the specified order.\n    ///\n    /// @param order The order to compute the EIP-712 signing hash for.\n    /// @param domainSeparator The EIP-712 domain separator to use.\n    /// @return orderDigest The 32 byte EIP-712 struct hash.\n    function hash(Data memory order, bytes32 domainSeparator)\n        internal\n        pure\n        returns (bytes32 orderDigest)\n    {\n        bytes32 structHash;\n\n        // NOTE: Compute the EIP-712 order struct hash in place. As suggested\n        // in the EIP proposal, noting that the order struct has 10 fields, and\n        // including the type hash `(12 + 1) * 32 = 416` bytes to hash.\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let dataStart := sub(order, 32)\n            let temp := mload(dataStart)\n            mstore(dataStart, TYPE_HASH)\n            structHash := keccak256(dataStart, 416)\n            mstore(dataStart, temp)\n        }\n\n        // NOTE: Now that we have the struct hash, compute the EIP-712 signing\n        // hash using scratch memory past the free memory pointer. The signing\n        // hash is computed from `\"\\x19\\x01\" || domainSeparator || structHash`.\n        // <https://docs.soliditylang.org/en/v0.8.16/internals/layout_in_memory.html#layout-in-memory>\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, \"\\x19\\x01\")\n            mstore(add(freeMemoryPointer, 2), domainSeparator)\n            mstore(add(freeMemoryPointer, 34), structHash)\n            orderDigest := keccak256(freeMemoryPointer, 66)\n        }\n    }\n\n    /// @dev Packs order UID parameters into the specified memory location. The\n    /// result is equivalent to `abi.encodePacked(...)` with the difference that\n    /// it allows re-using the memory for packing the order UID.\n    ///\n    /// This function reverts if the order UID buffer is not the correct size.\n    ///\n    /// @param orderUid The buffer pack the order UID parameters into.\n    /// @param orderDigest The EIP-712 struct digest derived from the order\n    /// parameters.\n    /// @param owner The address of the user who owns this order.\n    /// @param validTo The epoch time at which the order will stop being valid.\n    function packOrderUidParams(\n        bytes memory orderUid,\n        bytes32 orderDigest,\n        address owner,\n        uint32 validTo\n    ) internal pure {\n        require(orderUid.length == UID_LENGTH, \"GPv2: uid buffer overflow\");\n\n        // NOTE: Write the order UID to the allocated memory buffer. The order\n        // parameters are written to memory in **reverse order** as memory\n        // operations write 32-bytes at a time and we want to use a packed\n        // encoding. This means, for example, that after writing the value of\n        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`\n        // will **overwrite** bytes `20:32`. This is desirable as addresses are\n        // only 20 bytes and `20:32` should be `0`s:\n        //\n        //        |           1111111111222222222233333333334444444444555555\n        //   byte | 01234567890123456789012345678901234567890123456789012345\n        // -------+---------------------------------------------------------\n        //  field | [.........orderDigest..........][......owner.......][vT]\n        // -------+---------------------------------------------------------\n        // mstore |                         [000000000000000000000000000.vT]\n        //        |                     [00000000000.......owner.......]\n        //        | [.........orderDigest..........]\n        //\n        // Additionally, since Solidity `bytes memory` are length prefixed,\n        // 32 needs to be added to all the offsets.\n        //\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(add(orderUid, 56), validTo)\n            mstore(add(orderUid, 52), owner)\n            mstore(add(orderUid, 32), orderDigest)\n        }\n    }\n\n    /// @dev Extracts specific order information from the standardized unique\n    /// order id of the protocol.\n    ///\n    /// @param orderUid The unique identifier used to represent an order in\n    /// the protocol. This uid is the packed concatenation of the order digest,\n    /// the validTo order parameter and the address of the user who created the\n    /// order. It is used by the user to interface with the contract directly,\n    /// and not by calls that are triggered by the solvers.\n    /// @return orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @return owner The address of the user who owns this order.\n    /// @return validTo The epoch time at which the order will stop being valid.\n    function extractOrderUidParams(bytes calldata orderUid)\n        internal\n        pure\n        returns (\n            bytes32 orderDigest,\n            address owner,\n            uint32 validTo\n        )\n    {\n        require(orderUid.length == UID_LENGTH, \"GPv2: invalid uid\");\n\n        // Use assembly to efficiently decode packed calldata.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            orderDigest := calldataload(orderUid.offset)\n            owner := shr(96, calldataload(add(orderUid.offset, 32)))\n            validTo := shr(224, calldataload(add(orderUid.offset, 52)))\n        }\n    }\n}\n"
33     },
34     "src/vendored/IERC20.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin Contracts v4.4.0, see:\n// <https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.4.0/contracts/token/ERC20/IERC20.sol>\n\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
36     }
37   },
38   "settings": {
39     "optimizer": {
40       "enabled": true,
41       "runs": 1000000
42     },
43     "evmVersion": "london",
44     "remappings": [
45       ":ds-test/=lib/forge-std/lib/ds-test/src/",
46       ":forge-std/=lib/forge-std/src/",
47       ":openzeppelin-contracts/=lib/openzeppelin-contracts/"
48     ],
49     "libraries": {},
50     "outputSelection": {
51       "*": {
52         "*": [
53           "evm.bytecode",
54           "evm.deployedBytecode",
55           "devdoc",
56           "userdoc",
57           "metadata",
58           "abi"
59         ]
60       }
61     }
62   }
63 }}