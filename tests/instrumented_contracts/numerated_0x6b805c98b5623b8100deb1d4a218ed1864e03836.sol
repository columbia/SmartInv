1 {{
2   "language": "Solidity",
3   "sources": {
4     "src/AuctionHouse.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM`MMM NMM MMM MMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMhMMMMMMM  MMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM  MM-MMMMM   MMMM    MMMM   lMMMDMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMM jMMMMl   MM    MMM  M  MMM   M   MMMM MMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMM MMMMMMMMM  , `     M   Y   MM  MMM  BMMMMMM MMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMM MMMMMMMMMMMM  IM  MM  l  MMM  X   MM.  MMMMMMMMMM MMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.nlMMMMMMMMMMMMMMMMM]._  MMMMMMMMMMMMMMMNMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMM TMMMMMMMMMMMMMMMMMM          +MMMMMMMMMMMM:  rMMMMMMMMN MMMMMMMMMMMMMM\n// MMMMMMMMMMMM MMMMMMMMMMMMMMMM                  MMMMMM           MMMMMMMM qMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMM^                   MMMb              .MMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMM MMMMMMMMMMMMMMM                     MM                  MMMMMMM MMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM                     M                   gMMMMMMMMMMMMMMMMM\n// MMMMMMMMu MMMMMMMMMMMMMMM                                           MMMMMMM .MMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMM                                           :MMMMMMMMMMMMMMMM\n// MMMMMMM^ MMMMMMMMMMMMMMMl                                            MMMMMMMM MMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMM                                             MMMMMMMMMMMMMMMM\n// MMMMMMM MMMMMMMMMMMMMMMM                                             MMMMMMMM MMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMM                                             MMMMMMMMMMMMMMMM\n// MMMMMMr MMMMMMMMMMMMMMMM                                             MMMMMMMM .MMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMM                                           MMMMMMMMMMMMMMMMM\n// MMMMMMM MMMMMMMMMMMMMMMMM                                         DMMMMMMMMMM MMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM                              MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMM|`MMMMMMMMMMMMMMMM         q                      MMMMMMMMMMMMMMMMMMM  MMMMMMM\n// MMMMMMMMMTMMMMMMMMMMMMMMM                               qMMMMMMMMMMMMMMMMMMgMMMMMMMMM\n// MMMMMMMMq MMMMMMMMMMMMMMMh                             jMMMMMMMMMMMMMMMMMMM nMMMMMMMM\n// MMMMMMMMMM MMMMMMMMMMMMMMMQ      nc    -MMMMMn        MMMMMMMMMMMMMMMMMMMM MMMMMMMMMM\n// MMMMMMMMMM.MMMMMMMMMMMMMMMMMMl            M1       `MMMMMMMMMMMMMMMMMMMMMMrMMMMMMMMMM\n// MMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMM               :MMMMMMMMMM MMMMMMMMMMMM qMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMMMX       MMMMMMMMMMMMMMM  uMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMM DMMMMMMMMM   IMMMMMMMMMMMMMMMMMMMMMMM   M   Y  MMMMMMMN MMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMM MMMMMM    ``    M      MM  MMM   , MMMM    Mv  MMM MMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMM MMh  Ml  .   M  MMMM  I  MMMT  M     :M   ,MMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMM MMMMMMMMt  MM  MMMMB m  ]MMM  MMMM   MMMMMM MMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMM MMMMM  MMM   TM   MM  9U  .MM  _MMMMM MMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM YMMMMMMMn     MMMM    +MMMMMMM1`MMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.`MMM MMM MMMMM`.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM author: phaze MMM\n\nimport {Ownable} from \"./lib/Ownable.sol\";\nimport {IGouda} from \"./lib/interfaces.sol\";\nimport {IMadMouse} from \"./lib/interfaces.sol\";\n\nimport {IERC721} from \"../lib/openzeppelin-contracts/contracts/interfaces/IERC721.sol\";\nimport {IERC20} from \"../lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\";\n\nerror AuctionOngoing();\nerror AuctionInactive();\nerror AuctionCancelled();\n\nerror ContractCallNotAllowed();\n\nerror InvalidTimestamp();\nerror BidTooLow();\nerror NoBidPlaced();\nerror CannotWithdrawWinningBid();\nerror IncorrectWinner();\nerror RequirementNotFulfilled();\nerror InvalidAuctionId();\n\nerror QualifierMaxEntrantsReached();\nerror QualifierInactive();\nerror QualifierSeedNotSet();\nerror QualifierNotEntered();\nerror QualifierAlreadyEntered();\nerror QualifierNotRequired();\nerror QualifierRevealInvalidTimeFrame();\nerror QualifierRandomSeedSet();\n\ncontract AuctionHouse is Ownable {\n    event BidPlaced(uint256 indexed auctionId, address sender, uint256 price);\n\n    struct Auction {\n        uint16 qualifierNumEntrants;\n        uint16 qualifierMaxEntrants;\n        uint40 qualifierDuration;\n        uint16 qualifierChance;\n        uint16 qualifierRandomSeed;\n        uint8 requirement;\n        uint40 start;\n        uint40 duration;\n        uint40 currentBid; // in multiples of 1e18\n        bool cancelled;\n        address prizeNFT;\n        uint40 prizeTokenId;\n    }\n\n    uint256 public numAuctions;\n    mapping(uint256 => Auction) public auctions;\n    mapping(uint256 => mapping(address => uint256)) public bids;\n\n    uint256 constant ONE_MONTH = 3600 * 24 * 7 * 4;\n    uint256 constant AUCTION_EXTEND_DURATION = 5 * 60;\n\n    IGouda constant gouda = IGouda(0x3aD30C5E3496BE07968579169a96f00D56De4C1A);\n    IMadMouse constant genesis = IMadMouse(0x3aD30c5e2985e960E89F4a28eFc91BA73e104b77);\n    IMadMouse constant troupe = IMadMouse(0x74d9d90a7fc261FBe92eD47B606b6E0E00d75E70);\n\n    /* ------------- External ------------- */\n\n    function placeBid(\n        uint256 auctionId,\n        uint40 bid,\n        uint256 requirementData\n    ) external onlyEOA {\n        Auction storage auction = auctions[auctionId];\n\n        if (bid <= auction.currentBid) revert BidTooLow();\n\n        uint256 qualifierDuration = auction.qualifierDuration;\n\n        unchecked {\n            uint256 start = uint256(auction.start) + auction.qualifierDuration;\n            uint256 duration = auction.duration;\n\n            if (duration < block.timestamp - start) revert AuctionInactive();\n\n            uint256 end = start + duration;\n            if (end - block.timestamp < AUCTION_EXTEND_DURATION) {\n                auction.duration = uint40(duration + AUCTION_EXTEND_DURATION);\n            }\n        }\n\n        if (auction.cancelled) revert AuctionCancelled();\n\n        uint256 callerBid = bids[auctionId][msg.sender];\n\n        // if callerBid is > qualifierDownpayment,\n        // we don't have to re-evaluate qualifications,\n        // since this check has already been performed\n        if (callerBid <= 1) {\n            uint256 requirement = auction.requirement;\n            if (requirement != 0 && !fulfillsRequirement(msg.sender, requirement, requirementData))\n                revert RequirementNotFulfilled();\n\n            if (qualifierDuration != 0) {\n                uint256 qualifierRandomSeed = auction.qualifierRandomSeed;\n                if (qualifierRandomSeed == 0) revert QualifierSeedNotSet();\n                if (callerBid == 0) revert QualifierNotEntered(); // non-zero for valid entry because of downpayment when entering qualifier\n                uint256 roll = uint256(keccak256(abi.encodePacked(msg.sender, qualifierRandomSeed)));\n                if (roll & 0xFFFF > auction.qualifierChance) revert QualifierNotEntered();\n            }\n        }\n\n        unchecked {\n            // type(uint40).max * 1e18 < 2^256: can't overflow\n            // underflow assumption: callerBid <= auction.currentBid < bid\n            gouda.burnFrom(msg.sender, (uint256(bid) - callerBid) * 1e18);\n            emit BidPlaced(auctionId, msg.sender, uint256(bid) * 1e18);\n        }\n\n        bids[auctionId][msg.sender] = bid;\n        auction.currentBid = bid;\n    }\n\n    function fulfillsRequirement(\n        address user,\n        uint256 requirement,\n        uint256 data\n    ) public view returns (bool) {\n        unchecked {\n            if (requirement == 1 && genesis.numOwned(user) > 0) return true;\n            else if (requirement == 2 && troupe.numOwned(user) > 0) return true;\n            else if (\n                requirement == 3 &&\n                // specify data == 1 to direct that user is holding troupe and potentially save an sload;\n                // or leave unspecified and worst-case check both\n                ((data != 2 && troupe.numOwned(user) > 0) || (data != 1 && genesis.numOwned(user) > 0))\n            ) return true;\n            else if (\n                requirement == 4 &&\n                (\n                    data > 5000 // specify owner-held id: data > 5000 refers to genesis collection\n                        ? genesis.getLevel(data - 5000) > 1 && genesis.ownerOf(data - 5000) == user\n                        : troupe.getLevel(data) > 1 && troupe.ownerOf(data) == user\n                )\n            ) return true;\n            else if (\n                requirement == 5 &&\n                (\n                    data > 5000\n                        ? genesis.getLevel(data - 5000) > 2 && genesis.ownerOf(data - 5000) == user\n                        : troupe.getLevel(data) > 2 && troupe.ownerOf(data) == user\n                )\n            ) return true;\n            return false;\n        }\n    }\n\n    function claimPrize(uint256 auctionId) external onlyEOA {\n        resolveBid(auctionId);\n    }\n\n    function reclaimGouda(uint256 auctionId) external onlyEOA {\n        resolveBid(auctionId);\n    }\n\n    function enterQualifier(uint256 auctionId, uint256 requirementData) external onlyEOA {\n        Auction storage auction = auctions[auctionId];\n        unchecked {\n            if (++auction.qualifierNumEntrants > auction.qualifierMaxEntrants) revert QualifierMaxEntrantsReached();\n            if (auction.qualifierDuration < block.timestamp - auction.start) revert QualifierInactive();\n        }\n\n        uint256 requirement = auction.requirement;\n        if (requirement != 0 && !fulfillsRequirement(msg.sender, requirement, requirementData))\n            revert RequirementNotFulfilled();\n\n        if (bids[auctionId][msg.sender] >= 1) revert QualifierAlreadyEntered();\n\n        gouda.burnFrom(msg.sender, 1e18);\n        bids[auctionId][msg.sender] = 1;\n    }\n\n    /* ------------- View ------------- */\n\n    function qualifierChosen(uint256 auctionId, address user) external view returns (bool) {\n        Auction storage auction = auctions[auctionId];\n\n        if (auction.duration == 0) return false; // no qualifier required\n\n        uint256 callerBid = bids[auctionId][user];\n        if (callerBid == 0) return false; // downpayment signals successful qualifier entry\n\n        uint256 qualifierRandomSeed = auction.qualifierRandomSeed;\n        if (qualifierRandomSeed == 0) return false;\n\n        uint256 roll = uint256(keccak256(abi.encodePacked(user, qualifierRandomSeed)));\n        if (roll & 0xFFFF > auction.qualifierChance) return false;\n\n        return true;\n    }\n\n    /* ------------- Private ------------- */\n\n    function resolveBid(uint256 auctionId) private {\n        unchecked {\n            Auction storage auction = auctions[auctionId];\n            uint256 qualifierDuration = auction.qualifierDuration;\n            uint256 end = auction.start + qualifierDuration + auction.duration;\n\n            bool cancelled = auction.cancelled;\n\n            if (block.timestamp <= end && !cancelled) revert AuctionOngoing();\n\n            uint256 callerBid = bids[auctionId][msg.sender];\n            delete bids[auctionId][msg.sender];\n\n            if (callerBid == 0) revert NoBidPlaced();\n\n            if (auction.currentBid == callerBid && !cancelled) {\n                IERC721(auction.prizeNFT).transferFrom(owner(), msg.sender, auction.prizeTokenId);\n            } else {\n                // callerBid >= 1\n                if (qualifierDuration != 0) callerBid -= 1; // keep the qualifier downpayment\n                if (callerBid == 0) revert NoBidPlaced();\n                gouda.mint(msg.sender, callerBid * 1e18);\n            }\n        }\n    }\n\n    /* ------------- Owner ------------- */\n\n    function createAuction(\n        address nft,\n        uint40 tokenId,\n        uint16 qualifierMaxEntrants,\n        uint40 qualifierDuration,\n        uint16 qualifierChance,\n        uint8 requirement,\n        uint40 start,\n        uint40 duration\n    ) external onlyOwner {\n        uint256 auctionId;\n        unchecked {\n            auctionId = ++numAuctions;\n\n            if (ONE_MONTH < start - block.timestamp || duration > ONE_MONTH || qualifierDuration > ONE_MONTH)\n                revert InvalidTimestamp();\n        }\n\n        // IERC721(nft).transferFrom(msg.sender, address(this), tokenId);\n\n        Auction storage auction = auctions[auctionId];\n\n        auction.qualifierMaxEntrants = qualifierMaxEntrants;\n        auction.qualifierDuration = qualifierDuration;\n        auction.qualifierChance = qualifierChance;\n\n        auction.requirement = requirement;\n        auction.start = start;\n        auction.duration = duration;\n\n        auction.prizeNFT = nft;\n        auction.prizeTokenId = tokenId;\n    }\n\n    function editAuction(\n        uint256 auctionId,\n        address nft,\n        uint40 tokenId,\n        uint16 qualifierMaxEntrants,\n        uint40 qualifierDuration,\n        uint16 qualifierChance,\n        uint8 requirement,\n        uint40 start,\n        uint40 duration,\n        bool cancelled\n    ) external onlyOwner {\n        unchecked {\n            if (block.timestamp + ONE_MONTH < start || duration > ONE_MONTH || qualifierDuration > ONE_MONTH)\n                revert InvalidTimestamp();\n        }\n        if (auctionId > numAuctions) revert InvalidAuctionId();\n\n        Auction storage auction = auctions[auctionId];\n\n        auction.qualifierMaxEntrants = qualifierMaxEntrants;\n        auction.qualifierDuration = qualifierDuration;\n        auction.qualifierChance = qualifierChance;\n\n        auction.requirement = requirement;\n        auction.start = start;\n        auction.duration = duration;\n\n        auction.prizeNFT = nft;\n        auction.prizeTokenId = tokenId;\n\n        auction.cancelled = cancelled;\n    }\n\n    function revealQualifier(uint256 auctionId) external onlyOwner {\n        Auction storage auction = auctions[auctionId];\n\n        uint256 qualifierDuration = auction.qualifierDuration;\n        if (qualifierDuration == 0) revert QualifierNotRequired();\n\n        unchecked {\n            if (block.timestamp < auction.start + qualifierDuration) revert QualifierRevealInvalidTimeFrame();\n            if (auction.qualifierRandomSeed != 0) revert QualifierRandomSeedSet();\n\n            auction.qualifierRandomSeed = uint16(uint256(blockhash(block.number - 1)));\n        }\n    }\n\n    function rescueToys(IERC721 toy, uint256[] calldata toyIds) external onlyOwner {\n        unchecked {\n            for (uint256 i; i < toyIds.length; ++i) toy.transferFrom(address(this), msg.sender, toyIds[i]);\n        }\n    }\n\n    function rescueERC20(IERC20 token) external onlyOwner {\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    /* ------------- Modifier ------------- */\n\n    modifier onlyEOA() {\n        if (msg.sender != tx.origin) revert ContractCallNotAllowed();\n        _;\n    }\n}\n"
6     },
7     "src/lib/Ownable.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nerror CallerNotOwner();\n\nabstract contract Ownable {\n    address _owner = msg.sender;\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        _owner = newOwner;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != _owner) revert CallerNotOwner();\n        _;\n    }\n}\n"
9     },
10     "src/lib/interfaces.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\ninterface IGouda {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n\n    function transfer(address to, uint256 amount) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function mint(address user, uint256 amount) external;\n\n    function burnFrom(address account, uint256 amount) external;\n}\n\ninterface IMadMouse {\n    function numStaked(address user) external view returns (uint256);\n\n    function numOwned(address user) external view returns (uint256);\n\n    function balanceOf(address user) external view returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function getLevel(uint256 tokenId) external view returns (uint256);\n\n    function getDNA(uint256 tokenId) external view returns (uint256);\n}\n"
12     },
13     "lib/openzeppelin-contracts/contracts/interfaces/IERC721.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
15     },
16     "lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
18     },
19     "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
21     },
22     "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
24     },
25     "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
27     }
28   },
29   "settings": {
30     "optimizer": {
31       "enabled": true,
32       "runs": 10000
33     },
34     "outputSelection": {
35       "*": {
36         "*": [
37           "evm.bytecode",
38           "evm.deployedBytecode",
39           "devdoc",
40           "userdoc",
41           "metadata",
42           "abi"
43         ]
44       }
45     },
46     "libraries": {}
47   }
48 }}