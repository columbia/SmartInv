1 {{
2   "sources": {
3     "IERC20.sol": {
4       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.5;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n"
5     },
6     "IIntegralERC20.sol": {
7       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.5;\n\nimport 'IERC20.sol';\n\ninterface IIntegralERC20 is IERC20 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n}\n"
8     },
9     "IReserves.sol": {
10       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.5;\n\ninterface IReserves {\n    event Sync(uint112 reserve0, uint112 reserve1);\n    event Fees(uint256 fee0, uint256 fee1);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 lastTimestamp\n        );\n\n    function getReferences()\n        external\n        view\n        returns (\n            uint112 reference0,\n            uint112 reference1,\n            uint32 epoch\n        );\n\n    function getFees() external view returns (uint256 fee0, uint256 fee1);\n}\n"
11     },
12     "IIntegralPair.sol": {
13       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.5;\n\nimport 'IIntegralERC20.sol';\nimport 'IReserves.sol';\n\ninterface IIntegralPair is IIntegralERC20, IReserves {\n    event Mint(address indexed sender, address indexed to);\n    event Burn(address indexed sender, address indexed to);\n    event Swap(address indexed sender, address indexed to);\n    event SetMintFee(uint256 fee);\n    event SetBurnFee(uint256 fee);\n    event SetSwapFee(uint256 fee);\n    event SetOracle(address account);\n    event SetTrader(address trader);\n    event SetToken0AbsoluteLimit(uint256 limit);\n    event SetToken1AbsoluteLimit(uint256 limit);\n    event SetToken0RelativeLimit(uint256 limit);\n    event SetToken1RelativeLimit(uint256 limit);\n    event SetPriceDeviationLimit(uint256 limit);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function oracle() external view returns (address);\n\n    function trader() external view returns (address);\n\n    function mintFee() external view returns (uint256);\n\n    function setMintFee(uint256 fee) external;\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burnFee() external view returns (uint256);\n\n    function setBurnFee(uint256 fee) external;\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swapFee() external view returns (uint256);\n\n    function setSwapFee(uint256 fee) external;\n\n    function setOracle(address account) external;\n\n    function setTrader(address account) external;\n\n    function token0AbsoluteLimit() external view returns (uint256);\n\n    function setToken0AbsoluteLimit(uint256 limit) external;\n\n    function token1AbsoluteLimit() external view returns (uint256);\n\n    function setToken1AbsoluteLimit(uint256 limit) external;\n\n    function token0RelativeLimit() external view returns (uint256);\n\n    function setToken0RelativeLimit(uint256 limit) external;\n\n    function token1RelativeLimit() external view returns (uint256);\n\n    function setToken1RelativeLimit(uint256 limit) external;\n\n    function priceDeviationLimit() external view returns (uint256);\n\n    function setPriceDeviationLimit(uint256 limit) external;\n\n    function collect(address to) external;\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to\n    ) external;\n\n    function sync() external;\n\n    function initialize(\n        address _token0,\n        address _token1,\n        address _oracle,\n        address _trader\n    ) external;\n\n    function syncWithOracle() external;\n\n    function fullSync() external;\n\n    function getSpotPrice() external view returns (uint256 spotPrice);\n\n    function getSwapAmount0In(uint256 amount1Out) external view returns (uint256 swapAmount0In);\n\n    function getSwapAmount1In(uint256 amount0Out) external view returns (uint256 swapAmount1In);\n\n    function getSwapAmount0Out(uint256 amount1In) external view returns (uint256 swapAmount0Out);\n\n    function getSwapAmount1Out(uint256 amount0In) external view returns (uint256 swapAmount1Out);\n\n    function getDepositAmount0In(uint256 amount0) external view returns (uint256 depositAmount0In);\n\n    function getDepositAmount1In(uint256 amount1) external view returns (uint256 depositAmount1In);\n}\n"
14     },
15     "SafeMath.sol": {
16       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.5;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, 'SM_ADD_OVERFLOW');\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = sub(x, y, 'SM_SUB_UNDERFLOW');\n    }\n\n    function sub(\n        uint256 x,\n        uint256 y,\n        string memory message\n    ) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, message);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, 'SM_MUL_OVERFLOW');\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, 'SM_DIV_BY_ZERO');\n        uint256 c = a / b;\n        return c;\n    }\n\n    function ceil_div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = div(a, b);\n        if (c == mul(a, b)) {\n            return c;\n        } else {\n            return add(c, 1);\n        }\n    }\n}\n"
17     },
18     "Math.sol": {
19       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.5;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x < y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x > y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
20     },
21     "IIntegralFactory.sol": {
22       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.5;\n\ninterface IIntegralFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n    event OwnerSet(address owner);\n\n    function owner() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        address oracle,\n        address trader\n    ) external returns (address pair);\n\n    function setOwner(address) external;\n\n    function setMintFee(\n        address tokenA,\n        address tokenB,\n        uint256 fee\n    ) external;\n\n    function setBurnFee(\n        address tokenA,\n        address tokenB,\n        uint256 fee\n    ) external;\n\n    function setSwapFee(\n        address tokenA,\n        address tokenB,\n        uint256 fee\n    ) external;\n\n    function setOracle(\n        address tokenA,\n        address tokenB,\n        address oracle\n    ) external;\n\n    function setTrader(\n        address tokenA,\n        address tokenB,\n        address trader\n    ) external;\n\n    function collect(\n        address tokenA,\n        address tokenB,\n        address to\n    ) external;\n\n    function withdraw(\n        address tokenA,\n        address tokenB,\n        uint256 amount,\n        address to\n    ) external;\n}\n"
23     },
24     "IWETH.sol": {
25       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity =0.7.5;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
26     },
27     "TransferHelper.sol": {
28       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.5;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_APPROVE_FAILED');\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{ value: value }(new bytes(0));\n        require(success, 'TH_ETH_TRANSFER_FAILED');\n    }\n}\n"
29     },
30     "TokenShares.sol": {
31       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.5;\n\nimport 'IERC20.sol';\nimport 'IWETH.sol';\nimport 'SafeMath.sol';\nimport 'TransferHelper.sol';\n\nlibrary TokenShares {\n    using SafeMath for uint256;\n    using TransferHelper for address;\n\n    event UnwrapFailed(address to, uint256 amount);\n\n    struct Data {\n        mapping(address => uint256) totalShares;\n        address weth;\n    }\n\n    function setWeth(Data storage data, address _weth) internal {\n        data.weth = _weth;\n    }\n\n    function sharesToAmount(\n        Data storage data,\n        address token,\n        uint256 share\n    ) external returns (uint256) {\n        if (share == 0) {\n            return 0;\n        }\n        if (token == data.weth) {\n            return share;\n        }\n        require(data.totalShares[token] >= share, 'TS_INSUFFICIENT_BALANCE');\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        uint256 value = balance.mul(share).div(data.totalShares[token]);\n        data.totalShares[token] = data.totalShares[token].sub(share);\n        return value;\n    }\n\n    function amountToShares(\n        Data storage data,\n        address token,\n        uint256 amount,\n        bool wrap\n    ) external returns (uint256) {\n        if (amount == 0) {\n            return 0;\n        }\n        if (token == data.weth) {\n            if (wrap) {\n                require(msg.value >= amount, 'TS_INSUFFICIENT_AMOUNT');\n                IWETH(token).deposit{ value: amount }();\n            } else {\n                token.safeTransferFrom(msg.sender, address(this), amount);\n            }\n            return amount;\n        } else {\n            uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n            require(balanceBefore > 0 || data.totalShares[token] == 0, 'TS_INVALID_SHARES');\n            if (data.totalShares[token] == 0) {\n                data.totalShares[token] = balanceBefore;\n            }\n            token.safeTransferFrom(msg.sender, address(this), amount);\n            uint256 balanceAfter = IERC20(token).balanceOf(address(this));\n            require(balanceAfter > balanceBefore, 'TS_INVALID_TRANSFER');\n            if (balanceBefore > 0) {\n                uint256 lastShares = data.totalShares[token];\n                data.totalShares[token] = lastShares.mul(balanceAfter).div(balanceBefore);\n                return data.totalShares[token] - lastShares;\n            } else {\n                data.totalShares[token] = balanceAfter;\n                data.totalShares[token] = balanceAfter;\n                return balanceAfter;\n            }\n        }\n    }\n\n    function onUnwrapFailed(\n        Data storage data,\n        address to,\n        uint256 amount\n    ) external {\n        emit UnwrapFailed(to, amount);\n        IWETH(data.weth).deposit{ value: amount }();\n        TransferHelper.safeTransfer(data.weth, to, amount);\n    }\n}\n"
32     },
33     "Orders.sol": {
34       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.5;\npragma experimental ABIEncoderV2;\n\nimport 'SafeMath.sol';\nimport 'Math.sol';\nimport 'IIntegralFactory.sol';\nimport 'IIntegralPair.sol';\nimport 'TokenShares.sol';\n\nlibrary Orders {\n    using SafeMath for uint256;\n    using TokenShares for TokenShares.Data;\n    using TransferHelper for address;\n\n    enum OrderType { Empty, Deposit, Withdraw, Sell, Buy }\n    enum OrderStatus { NonExistent, EnqueuedWaiting, EnqueuedReady, ExecutedSucceeded, ExecutedFailed, Canceled }\n\n    event MaxGasLimitSet(uint256 maxGasLimit);\n    event GasPriceInertiaSet(uint256 gasPriceInertia);\n    event MaxGasPriceImpactSet(uint256 maxGasPriceImpact);\n    event TransferGasCostSet(address token, uint256 gasCost);\n\n    event DepositEnqueued(uint256 indexed orderId, uint128 validAfterTimestamp, uint256 gasPrice);\n    event WithdrawEnqueued(uint256 indexed orderId, uint128 validAfterTimestamp, uint256 gasPrice);\n    event SellEnqueued(uint256 indexed orderId, uint128 validAfterTimestamp, uint256 gasPrice);\n    event BuyEnqueued(uint256 indexed orderId, uint128 validAfterTimestamp, uint256 gasPrice);\n\n    uint8 private constant DEPOSIT_TYPE = 1;\n    uint8 private constant WITHDRAW_TYPE = 2;\n    uint8 private constant BUY_TYPE = 3;\n    uint8 private constant BUY_INVERTED_TYPE = 4;\n    uint8 private constant SELL_TYPE = 5;\n    uint8 private constant SELL_INVERTED_TYPE = 6;\n\n    uint8 private constant UNWRAP_NOT_FAILED = 0;\n    uint8 private constant KEEP_NOT_FAILED = 1;\n    uint8 private constant UNWRAP_FAILED = 2;\n    uint8 private constant KEEP_FAILED = 3;\n\n    uint256 private constant ETHER_TRANSFER_COST = 2300;\n    uint256 private constant BUFFER_COST = 10000;\n    uint256 private constant EXECUTE_PREPARATION_COST = 55000; // dequeue + getPair in execute\n\n    uint256 public constant ETHER_TRANSFER_CALL_COST = 10000;\n    uint256 public constant PAIR_TRANSFER_COST = 55000;\n    uint256 public constant REFUND_END_COST = 2 * ETHER_TRANSFER_COST + BUFFER_COST;\n    uint256 public constant ORDER_BASE_COST = EXECUTE_PREPARATION_COST + REFUND_END_COST;\n\n    uint256 private constant TIMESTAMP_OFFSET = 1609455600; // 2021 Jan 1\n\n    struct PairInfo {\n        address pair;\n        address token0;\n        address token1;\n    }\n\n    struct Data {\n        uint256 delay;\n        uint256 newestOrderId;\n        uint256 lastProcessedOrderId;\n        mapping(uint256 => StoredOrder) orderQueue;\n        address factory;\n        uint256 maxGasLimit;\n        uint256 gasPrice;\n        uint256 gasPriceInertia;\n        uint256 maxGasPriceImpact;\n        mapping(uint32 => PairInfo) pairs;\n        mapping(address => uint256) transferGasCosts;\n        mapping(uint256 => bool) canceled;\n        mapping(address => bool) depositDisabled;\n        mapping(address => bool) withdrawDisabled;\n        mapping(address => bool) buyDisabled;\n        mapping(address => bool) sellDisabled;\n    }\n\n    struct StoredOrder {\n        // slot 1\n        uint8 orderType;\n        uint32 validAfterTimestamp;\n        uint8 unwrapAndFailure;\n        uint32 deadline;\n        uint32 gasLimit;\n        uint32 gasPrice;\n        uint112 liquidityOrRatio;\n        // slot 1\n        uint112 value0;\n        uint112 value1;\n        uint32 pairId;\n        // slot2\n        address to;\n        uint32 minRatioChangeToSwap;\n        uint32 minSwapPrice;\n        uint32 maxSwapPrice;\n    }\n\n    struct DepositOrder {\n        uint32 pairId;\n        uint256 share0;\n        uint256 share1;\n        uint256 initialRatio;\n        uint256 minRatioChangeToSwap;\n        uint256 minSwapPrice;\n        uint256 maxSwapPrice;\n        bool unwrap;\n        address to;\n        uint256 gasPrice;\n        uint256 gasLimit;\n        uint256 deadline;\n    }\n\n    struct WithdrawOrder {\n        uint32 pairId;\n        uint256 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        bool unwrap;\n        address to;\n        uint256 gasPrice;\n        uint256 gasLimit;\n        uint256 deadline;\n    }\n\n    struct SellOrder {\n        uint32 pairId;\n        bool inverse;\n        uint256 shareIn;\n        uint256 amountOutMin;\n        bool unwrap;\n        address to;\n        uint256 gasPrice;\n        uint256 gasLimit;\n        uint256 deadline;\n    }\n\n    struct BuyOrder {\n        uint32 pairId;\n        bool inverse;\n        uint256 shareInMax;\n        uint256 amountOut;\n        bool unwrap;\n        address to;\n        uint256 gasPrice;\n        uint256 gasLimit;\n        uint256 deadline;\n    }\n\n    function decodeType(uint256 internalType) internal pure returns (OrderType orderType) {\n        if (internalType == DEPOSIT_TYPE) {\n            orderType = OrderType.Deposit;\n        } else if (internalType == WITHDRAW_TYPE) {\n            orderType = OrderType.Withdraw;\n        } else if (internalType == BUY_TYPE) {\n            orderType = OrderType.Buy;\n        } else if (internalType == BUY_INVERTED_TYPE) {\n            orderType = OrderType.Buy;\n        } else if (internalType == SELL_TYPE) {\n            orderType = OrderType.Sell;\n        } else if (internalType == SELL_INVERTED_TYPE) {\n            orderType = OrderType.Sell;\n        } else {\n            orderType = OrderType.Empty;\n        }\n    }\n\n    function getOrder(Data storage data, uint256 orderId)\n        public\n        view\n        returns (OrderType orderType, uint256 validAfterTimestamp)\n    {\n        StoredOrder storage order = data.orderQueue[orderId];\n        uint8 internalType = order.orderType;\n        validAfterTimestamp = uint32ToTimestamp(order.validAfterTimestamp);\n        orderType = decodeType(internalType);\n    }\n\n    function getOrderStatus(Data storage data, uint256 orderId) external view returns (OrderStatus orderStatus) {\n        if (orderId > data.newestOrderId) {\n            return OrderStatus.NonExistent;\n        }\n        if (data.canceled[orderId]) {\n            return OrderStatus.Canceled;\n        }\n        if (isRefundFailed(data, orderId)) {\n            return OrderStatus.ExecutedFailed;\n        }\n        (OrderType orderType, uint256 validAfterTimestamp) = getOrder(data, orderId);\n        if (orderType == OrderType.Empty) {\n            return OrderStatus.ExecutedSucceeded;\n        }\n        if (validAfterTimestamp >= block.timestamp) {\n            return OrderStatus.EnqueuedWaiting;\n        }\n        return OrderStatus.EnqueuedReady;\n    }\n\n    function getPair(\n        Data storage data,\n        address tokenA,\n        address tokenB\n    )\n        internal\n        returns (\n            address pair,\n            uint32 pairId,\n            bool inverted\n        )\n    {\n        inverted = tokenA > tokenB;\n        (address token0, address token1) = inverted ? (tokenB, tokenA) : (tokenA, tokenB);\n        pair = IIntegralFactory(data.factory).getPair(token0, token1);\n        pairId = uint32(bytes4(keccak256(abi.encodePacked((pair)))));\n        require(pair != address(0), 'OS_PAIR_NONEXISTENT');\n        if (data.pairs[pairId].pair == address(0)) {\n            data.pairs[pairId] = PairInfo(pair, token0, token1);\n        }\n    }\n\n    function getPairInfo(Data storage data, uint32 pairId)\n        external\n        view\n        returns (\n            address pair,\n            address token0,\n            address token1\n        )\n    {\n        PairInfo storage info = data.pairs[pairId];\n        pair = info.pair;\n        token0 = info.token0;\n        token1 = info.token1;\n    }\n\n    function getDepositOrder(Data storage data, uint256 index) public view returns (DepositOrder memory order) {\n        StoredOrder memory stored = data.orderQueue[index];\n        require(stored.orderType == DEPOSIT_TYPE, 'OS_INVALID_ORDER_TYPE');\n        order.pairId = stored.pairId;\n        order.share0 = stored.value0;\n        order.share1 = stored.value1;\n        order.initialRatio = stored.liquidityOrRatio;\n        order.minRatioChangeToSwap = stored.minRatioChangeToSwap;\n        order.minSwapPrice = float32ToUint(stored.minSwapPrice);\n        order.maxSwapPrice = float32ToUint(stored.maxSwapPrice);\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\n        order.to = stored.to;\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\n        order.gasLimit = stored.gasLimit;\n        order.deadline = uint32ToTimestamp(stored.deadline);\n    }\n\n    function getWithdrawOrder(Data storage data, uint256 index) public view returns (WithdrawOrder memory order) {\n        StoredOrder memory stored = data.orderQueue[index];\n        require(stored.orderType == WITHDRAW_TYPE, 'OS_INVALID_ORDER_TYPE');\n        order.pairId = stored.pairId;\n        order.liquidity = stored.liquidityOrRatio;\n        order.amount0Min = stored.value0;\n        order.amount1Min = stored.value1;\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\n        order.to = stored.to;\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\n        order.gasLimit = stored.gasLimit;\n        order.deadline = uint32ToTimestamp(stored.deadline);\n    }\n\n    function getSellOrder(Data storage data, uint256 index) public view returns (SellOrder memory order) {\n        StoredOrder memory stored = data.orderQueue[index];\n        require(stored.orderType == SELL_TYPE || stored.orderType == SELL_INVERTED_TYPE, 'OS_INVALID_ORDER_TYPE');\n        order.pairId = stored.pairId;\n        order.inverse = stored.orderType == SELL_INVERTED_TYPE;\n        order.shareIn = stored.value0;\n        order.amountOutMin = stored.value1;\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\n        order.to = stored.to;\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\n        order.gasLimit = stored.gasLimit;\n        order.deadline = uint32ToTimestamp(stored.deadline);\n    }\n\n    function getBuyOrder(Data storage data, uint256 index) public view returns (BuyOrder memory order) {\n        StoredOrder memory stored = data.orderQueue[index];\n        require(stored.orderType == BUY_TYPE || stored.orderType == BUY_INVERTED_TYPE, 'OS_INVALID_ORDER_TYPE');\n        order.pairId = stored.pairId;\n        order.inverse = stored.orderType == BUY_INVERTED_TYPE;\n        order.shareInMax = stored.value0;\n        order.amountOut = stored.value1;\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\n        order.to = stored.to;\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\n        order.gasLimit = stored.gasLimit;\n        order.deadline = uint32ToTimestamp(stored.deadline);\n    }\n\n    function getFailedOrderType(Data storage data, uint256 orderId)\n        external\n        view\n        returns (OrderType orderType, uint256 validAfterTimestamp)\n    {\n        require(isRefundFailed(data, orderId), 'OS_NO_POSSIBLE_REFUND');\n        (orderType, validAfterTimestamp) = getOrder(data, orderId);\n    }\n\n    function getUnwrap(uint8 unwrapAndFailure) private pure returns (bool) {\n        return unwrapAndFailure == UNWRAP_FAILED || unwrapAndFailure == UNWRAP_NOT_FAILED;\n    }\n\n    function getUnwrapAndFailure(bool unwrap) private pure returns (uint8) {\n        return unwrap ? UNWRAP_NOT_FAILED : KEEP_NOT_FAILED;\n    }\n\n    function timestampToUint32(uint256 timestamp) private pure returns (uint32 timestamp32) {\n        if (timestamp == uint256(-1)) {\n            return uint32(-1);\n        }\n        timestamp32 = uintToUint32(timestamp.sub(TIMESTAMP_OFFSET));\n    }\n\n    function uint32ToTimestamp(uint32 timestamp32) private pure returns (uint256 timestamp) {\n        if (timestamp32 == uint32(-1)) {\n            return uint256(-1);\n        }\n        if (timestamp32 == 0) {\n            return 0;\n        }\n        timestamp = uint256(timestamp32) + TIMESTAMP_OFFSET;\n    }\n\n    function gasPriceToUint32(uint256 gasPrice) private pure returns (uint32 gasPrice32) {\n        require((gasPrice / 1e6) * 1e6 == gasPrice, 'OS_GAS_PRICE_PRECISION');\n        gasPrice32 = uintToUint32(gasPrice / 1e6);\n    }\n\n    function uint32ToGasPrice(uint32 gasPrice32) public pure returns (uint256 gasPrice) {\n        gasPrice = uint256(gasPrice32) * 1e6;\n    }\n\n    function uintToUint32(uint256 number) private pure returns (uint32 number32) {\n        number32 = uint32(number);\n        require(uint256(number32) == number, 'OS_OVERFLOW_32');\n    }\n\n    function uintToUint112(uint256 number) private pure returns (uint112 number112) {\n        number112 = uint112(number);\n        require(uint256(number112) == number, 'OS_OVERFLOW_112');\n    }\n\n    function uintToFloat32(uint256 number) internal pure returns (uint32 float32) {\n        // Number is encoded on 4 bytes. 3 bytes for mantissa and 1 for exponent.\n        // If the number fits in the mantissa we set the exponent to zero and return.\n        if (number < 2 << 24) {\n            return uint32(number << 8);\n        }\n        // We find the exponent by counting the number of trailing zeroes.\n        // Simultaneously we remove those zeroes from the number.\n        uint32 exponent;\n        for (exponent = 0; exponent < 256 - 24; exponent++) {\n            // Last bit is one.\n            if (number & 1 == 1) {\n                break;\n            }\n            number = number >> 1;\n        }\n        // The number must fit in the mantissa.\n        require(number < 2 << 24, 'OS_OVERFLOW_FLOAT_ENCODE');\n        // Set the first three bytes to the number and the fourth to the exponent.\n        float32 = uint32(number << 8) | exponent;\n    }\n\n    function float32ToUint(uint32 float32) internal pure returns (uint256 number) {\n        // Number is encoded on 4 bytes. 3 bytes for mantissa and 1 for exponent.\n        // We get the exponent by extracting the last byte.\n        uint256 exponent = float32 & 0xFF;\n        // Sanity check. Only triggered for values not encoded with uintToFloat32.\n        require(exponent <= 256 - 24, 'OS_OVERFLOW_FLOAT_DECODE');\n        // We get the mantissa by extracting the first three bytes and removing the fourth.\n        uint256 mantissa = (float32 & 0xFFFFFF00) >> 8;\n        // We add exponent number zeroes after the mantissa.\n        number = mantissa << exponent;\n    }\n\n    function enqueueDepositOrder(Data storage data, DepositOrder memory depositOrder) internal {\n        data.newestOrderId++;\n        uint128 validAfterTimestamp = uint128(block.timestamp + data.delay);\n        emit DepositEnqueued(data.newestOrderId, validAfterTimestamp, depositOrder.gasPrice);\n        data.orderQueue[data.newestOrderId] = StoredOrder(\n            DEPOSIT_TYPE,\n            timestampToUint32(validAfterTimestamp),\n            getUnwrapAndFailure(depositOrder.unwrap),\n            timestampToUint32(depositOrder.deadline),\n            uintToUint32(depositOrder.gasLimit),\n            gasPriceToUint32(depositOrder.gasPrice),\n            uintToUint112(depositOrder.initialRatio),\n            uintToUint112(depositOrder.share0),\n            uintToUint112(depositOrder.share1),\n            depositOrder.pairId,\n            depositOrder.to,\n            uint32(depositOrder.minRatioChangeToSwap),\n            uintToFloat32(depositOrder.minSwapPrice),\n            uintToFloat32(depositOrder.maxSwapPrice)\n        );\n    }\n\n    function enqueueWithdrawOrder(Data storage data, WithdrawOrder memory withdrawOrder) internal {\n        data.newestOrderId++;\n        uint128 validAfterTimestamp = uint128(block.timestamp + data.delay);\n        emit WithdrawEnqueued(data.newestOrderId, validAfterTimestamp, withdrawOrder.gasPrice);\n        data.orderQueue[data.newestOrderId] = StoredOrder(\n            WITHDRAW_TYPE,\n            timestampToUint32(validAfterTimestamp),\n            getUnwrapAndFailure(withdrawOrder.unwrap),\n            timestampToUint32(withdrawOrder.deadline),\n            uintToUint32(withdrawOrder.gasLimit),\n            gasPriceToUint32(withdrawOrder.gasPrice),\n            uintToUint112(withdrawOrder.liquidity),\n            uintToUint112(withdrawOrder.amount0Min),\n            uintToUint112(withdrawOrder.amount1Min),\n            withdrawOrder.pairId,\n            withdrawOrder.to,\n            0, // maxRatioChange\n            0, // minSwapPrice\n            0 // maxSwapPrice\n        );\n    }\n\n    function enqueueSellOrder(Data storage data, SellOrder memory sellOrder) internal {\n        data.newestOrderId++;\n        uint128 validAfterTimestamp = uint128(block.timestamp + data.delay);\n        emit SellEnqueued(data.newestOrderId, validAfterTimestamp, sellOrder.gasPrice);\n        data.orderQueue[data.newestOrderId] = StoredOrder(\n            sellOrder.inverse ? SELL_INVERTED_TYPE : SELL_TYPE,\n            timestampToUint32(validAfterTimestamp),\n            getUnwrapAndFailure(sellOrder.unwrap),\n            timestampToUint32(sellOrder.deadline),\n            uintToUint32(sellOrder.gasLimit),\n            gasPriceToUint32(sellOrder.gasPrice),\n            0, // liquidityOrRatio\n            uintToUint112(sellOrder.shareIn),\n            uintToUint112(sellOrder.amountOutMin),\n            sellOrder.pairId,\n            sellOrder.to,\n            0, // maxRatioChange\n            0, // minSwapPrice\n            0 // maxSwapPrice\n        );\n    }\n\n    function enqueueBuyOrder(Data storage data, BuyOrder memory buyOrder) internal {\n        data.newestOrderId++;\n        uint128 validAfterTimestamp = uint128(block.timestamp + data.delay);\n        emit BuyEnqueued(data.newestOrderId, validAfterTimestamp, buyOrder.gasPrice);\n        data.orderQueue[data.newestOrderId] = StoredOrder(\n            buyOrder.inverse ? BUY_INVERTED_TYPE : BUY_TYPE,\n            timestampToUint32(validAfterTimestamp),\n            getUnwrapAndFailure(buyOrder.unwrap),\n            timestampToUint32(buyOrder.deadline),\n            uintToUint32(buyOrder.gasLimit),\n            gasPriceToUint32(buyOrder.gasPrice),\n            0, // liquidityOrRatio\n            uintToUint112(buyOrder.shareInMax),\n            uintToUint112(buyOrder.amountOut),\n            buyOrder.pairId,\n            buyOrder.to,\n            0, // maxRatioChange\n            0, // minSwapPrice\n            0 // maxSwapPrice\n        );\n    }\n\n    function isRefundFailed(Data storage data, uint256 index) internal view returns (bool) {\n        uint8 unwrapAndFailure = data.orderQueue[index].unwrapAndFailure;\n        return unwrapAndFailure == UNWRAP_FAILED || unwrapAndFailure == KEEP_FAILED;\n    }\n\n    function markRefundFailed(Data storage data) internal {\n        StoredOrder storage stored = data.orderQueue[data.lastProcessedOrderId];\n        stored.unwrapAndFailure = stored.unwrapAndFailure == UNWRAP_NOT_FAILED ? UNWRAP_FAILED : KEEP_FAILED;\n    }\n\n    function getNextOrder(Data storage data) internal view returns (OrderType orderType, uint256 validAfterTimestamp) {\n        return getOrder(data, data.lastProcessedOrderId + 1);\n    }\n\n    function dequeueCanceledOrder(Data storage data) external {\n        data.lastProcessedOrderId++;\n    }\n\n    function dequeueDepositOrder(Data storage data) external returns (DepositOrder memory order) {\n        data.lastProcessedOrderId++;\n        order = getDepositOrder(data, data.lastProcessedOrderId);\n    }\n\n    function dequeueWithdrawOrder(Data storage data) external returns (WithdrawOrder memory order) {\n        data.lastProcessedOrderId++;\n        order = getWithdrawOrder(data, data.lastProcessedOrderId);\n    }\n\n    function dequeueSellOrder(Data storage data) external returns (SellOrder memory order) {\n        data.lastProcessedOrderId++;\n        order = getSellOrder(data, data.lastProcessedOrderId);\n    }\n\n    function dequeueBuyOrder(Data storage data) external returns (BuyOrder memory order) {\n        data.lastProcessedOrderId++;\n        order = getBuyOrder(data, data.lastProcessedOrderId);\n    }\n\n    function forgetOrder(Data storage data, uint256 orderId) internal {\n        delete data.orderQueue[orderId];\n    }\n\n    function forgetLastProcessedOrder(Data storage data) internal {\n        delete data.orderQueue[data.lastProcessedOrderId];\n    }\n\n    struct DepositParams {\n        address token0;\n        address token1;\n        uint256 amount0;\n        uint256 amount1;\n        uint256 initialRatio;\n        uint256 minRatioChangeToSwap;\n        uint256 minSwapPrice;\n        uint256 maxSwapPrice;\n        bool wrap;\n        address to;\n        uint256 gasLimit;\n        uint256 submitDeadline;\n        uint256 executionDeadline;\n    }\n\n    function deposit(\n        Data storage data,\n        DepositParams calldata depositParams,\n        TokenShares.Data storage tokenShares\n    ) external {\n        require(\n            data.transferGasCosts[depositParams.token0] != 0 && data.transferGasCosts[depositParams.token1] != 0,\n            'OS_TOKEN_TRANSFER_GAS_COST_UNSET'\n        );\n        checkOrderParams(\n            data,\n            depositParams.to,\n            depositParams.gasLimit,\n            depositParams.submitDeadline,\n            depositParams.executionDeadline,\n            ORDER_BASE_COST.add(data.transferGasCosts[depositParams.token0]).add(\n                data.transferGasCosts[depositParams.token1]\n            )\n        );\n        require(depositParams.amount0 != 0 || depositParams.amount1 != 0, 'OS_NO_AMOUNT');\n        (address pair, uint32 pairId, bool inverted) = getPair(data, depositParams.token0, depositParams.token1);\n        require(!data.depositDisabled[pair], 'OS_DEPOSIT_DISABLED');\n\n        uint256 value = msg.value;\n\n        // allocate gas refund\n        if (depositParams.token0 == tokenShares.weth && depositParams.wrap) {\n            value = value.sub(depositParams.amount0, 'OS_NOT_ENOUGH_FUNDS');\n        } else if (depositParams.token1 == tokenShares.weth && depositParams.wrap) {\n            value = value.sub(depositParams.amount1, 'OS_NOT_ENOUGH_FUNDS');\n        }\n        allocateGasRefund(data, value, depositParams.gasLimit);\n\n        uint256 shares0 = tokenShares.amountToShares(depositParams.token0, depositParams.amount0, depositParams.wrap);\n        uint256 shares1 = tokenShares.amountToShares(depositParams.token1, depositParams.amount1, depositParams.wrap);\n\n        IIntegralPair(pair).syncWithOracle();\n        enqueueDepositOrder(\n            data,\n            DepositOrder(\n                pairId,\n                inverted ? shares1 : shares0,\n                inverted ? shares0 : shares1,\n                depositParams.initialRatio,\n                depositParams.minRatioChangeToSwap,\n                depositParams.minSwapPrice,\n                depositParams.maxSwapPrice,\n                depositParams.wrap,\n                depositParams.to,\n                data.gasPrice,\n                depositParams.gasLimit,\n                depositParams.executionDeadline\n            )\n        );\n    }\n\n    struct WithdrawParams {\n        address token0;\n        address token1;\n        uint256 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        bool unwrap;\n        address to;\n        uint256 gasLimit;\n        uint256 submitDeadline;\n        uint256 executionDeadline;\n    }\n\n    function withdraw(Data storage data, WithdrawParams calldata withdrawParams) external {\n        (address pair, uint32 pairId, bool inverted) = getPair(data, withdrawParams.token0, withdrawParams.token1);\n        require(!data.withdrawDisabled[pair], 'OS_WITHDRAW_DISABLED');\n        checkOrderParams(\n            data,\n            withdrawParams.to,\n            withdrawParams.gasLimit,\n            withdrawParams.submitDeadline,\n            withdrawParams.executionDeadline,\n            ORDER_BASE_COST.add(PAIR_TRANSFER_COST)\n        );\n        require(withdrawParams.liquidity != 0, 'OS_NO_LIQUIDITY');\n\n        allocateGasRefund(data, msg.value, withdrawParams.gasLimit);\n        pair.safeTransferFrom(msg.sender, address(this), withdrawParams.liquidity);\n\n        IIntegralPair(pair).syncWithOracle();\n        enqueueWithdrawOrder(\n            data,\n            WithdrawOrder(\n                pairId,\n                withdrawParams.liquidity,\n                inverted ? withdrawParams.amount1Min : withdrawParams.amount0Min,\n                inverted ? withdrawParams.amount0Min : withdrawParams.amount1Min,\n                withdrawParams.unwrap,\n                withdrawParams.to,\n                data.gasPrice,\n                withdrawParams.gasLimit,\n                withdrawParams.executionDeadline\n            )\n        );\n    }\n\n    struct SellParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint256 amountOutMin;\n        bool wrapUnwrap;\n        address to;\n        uint256 gasLimit;\n        uint256 submitDeadline;\n        uint256 executionDeadline;\n    }\n\n    function sell(\n        Data storage data,\n        SellParams calldata sellParams,\n        TokenShares.Data storage tokenShares\n    ) external {\n        require(data.transferGasCosts[sellParams.tokenIn] != 0, 'OS_TOKEN_TRANSFER_GAS_COST_UNSET');\n        checkOrderParams(\n            data,\n            sellParams.to,\n            sellParams.gasLimit,\n            sellParams.submitDeadline,\n            sellParams.executionDeadline,\n            ORDER_BASE_COST.add(data.transferGasCosts[sellParams.tokenIn])\n        );\n        require(sellParams.amountIn != 0, 'OS_NO_AMOUNT_IN');\n        (address pair, uint32 pairId, bool inverted) = getPair(data, sellParams.tokenIn, sellParams.tokenOut);\n        require(!data.sellDisabled[pair], 'OS_SELL_DISABLED');\n        uint256 value = msg.value;\n\n        // allocate gas refund\n        if (sellParams.tokenIn == tokenShares.weth && sellParams.wrapUnwrap) {\n            value = value.sub(sellParams.amountIn, 'OS_NOT_ENOUGH_FUNDS');\n        }\n        allocateGasRefund(data, value, sellParams.gasLimit);\n\n        uint256 shares = tokenShares.amountToShares(sellParams.tokenIn, sellParams.amountIn, sellParams.wrapUnwrap);\n\n        IIntegralPair(pair).syncWithOracle();\n        enqueueSellOrder(\n            data,\n            SellOrder(\n                pairId,\n                inverted,\n                shares,\n                sellParams.amountOutMin,\n                sellParams.wrapUnwrap,\n                sellParams.to,\n                data.gasPrice,\n                sellParams.gasLimit,\n                sellParams.executionDeadline\n            )\n        );\n    }\n\n    struct BuyParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountInMax;\n        uint256 amountOut;\n        bool wrapUnwrap;\n        address to;\n        uint256 gasLimit;\n        uint256 submitDeadline;\n        uint256 executionDeadline;\n    }\n\n    function buy(\n        Data storage data,\n        BuyParams calldata buyParams,\n        TokenShares.Data storage tokenShares\n    ) external {\n        require(data.transferGasCosts[buyParams.tokenIn] != 0, 'OS_TOKEN_TRANSFER_GAS_COST_UNSET');\n        checkOrderParams(\n            data,\n            buyParams.to,\n            buyParams.gasLimit,\n            buyParams.submitDeadline,\n            buyParams.executionDeadline,\n            ORDER_BASE_COST.add(data.transferGasCosts[buyParams.tokenIn])\n        );\n        require(buyParams.amountOut != 0, 'OS_NO_AMOUNT_OUT');\n        (address pair, uint32 pairId, bool inverted) = getPair(data, buyParams.tokenIn, buyParams.tokenOut);\n        require(!data.buyDisabled[pair], 'OS_BUY_DISABLED');\n\n        uint256 value = msg.value;\n\n        // allocate gas refund\n        if (buyParams.tokenIn == tokenShares.weth && buyParams.wrapUnwrap) {\n            value = value.sub(buyParams.amountInMax, 'OS_NOT_ENOUGH_FUNDS');\n        }\n        allocateGasRefund(data, value, buyParams.gasLimit);\n\n        uint256 shares = tokenShares.amountToShares(buyParams.tokenIn, buyParams.amountInMax, buyParams.wrapUnwrap);\n\n        IIntegralPair(pair).syncWithOracle();\n        enqueueBuyOrder(\n            data,\n            BuyOrder(\n                pairId,\n                inverted,\n                shares,\n                buyParams.amountOut,\n                buyParams.wrapUnwrap,\n                buyParams.to,\n                data.gasPrice,\n                buyParams.gasLimit,\n                buyParams.executionDeadline\n            )\n        );\n    }\n\n    function checkOrderParams(\n        Data storage data,\n        address to,\n        uint256 gasLimit,\n        uint256 submitDeadline,\n        uint256 executionDeadline,\n        uint256 minGasLimit\n    ) private view {\n        require(submitDeadline >= block.timestamp, 'OS_EXPIRED');\n        require(executionDeadline > block.timestamp.add(data.delay), 'OS_INVALID_DEADLINE');\n        require(gasLimit <= data.maxGasLimit, 'OS_GAS_LIMIT_TOO_HIGH');\n        require(gasLimit >= minGasLimit, 'OS_GAS_LIMIT_TOO_LOW');\n        require(to != address(0), 'OS_NO_ADDRESS');\n    }\n\n    function allocateGasRefund(\n        Data storage data,\n        uint256 value,\n        uint256 gasLimit\n    ) private returns (uint256 futureFee) {\n        futureFee = data.gasPrice.mul(gasLimit);\n        require(value >= futureFee, 'OS_NOT_ENOUGH_FUNDS');\n        if (value > futureFee) {\n            msg.sender.transfer(value.sub(futureFee));\n        }\n    }\n\n    function updateGasPrice(Data storage data, uint256 gasUsed) external {\n        uint256 scale = Math.min(gasUsed, data.maxGasPriceImpact);\n        uint256 updated = data.gasPrice.mul(data.gasPriceInertia.sub(scale)).add(tx.gasprice.mul(scale)).div(\n            data.gasPriceInertia\n        );\n        // we lower the precision for gas savings in order queue\n        data.gasPrice = updated - (updated % 1e6);\n    }\n\n    function setMaxGasLimit(Data storage data, uint256 _maxGasLimit) external {\n        require(_maxGasLimit <= 10000000, 'OS_MAX_GAS_LIMIT_TOO_HIGH');\n        data.maxGasLimit = _maxGasLimit;\n        emit MaxGasLimitSet(_maxGasLimit);\n    }\n\n    function setGasPriceInertia(Data storage data, uint256 _gasPriceInertia) external {\n        require(_gasPriceInertia >= 1, 'OS_INVALID_INERTIA');\n        data.gasPriceInertia = _gasPriceInertia;\n        emit GasPriceInertiaSet(_gasPriceInertia);\n    }\n\n    function setMaxGasPriceImpact(Data storage data, uint256 _maxGasPriceImpact) external {\n        require(_maxGasPriceImpact <= data.gasPriceInertia, 'OS_INVALID_MAX_GAS_PRICE_IMPACT');\n        data.maxGasPriceImpact = _maxGasPriceImpact;\n        emit MaxGasPriceImpactSet(_maxGasPriceImpact);\n    }\n\n    function setTransferGasCost(\n        Data storage data,\n        address token,\n        uint256 gasCost\n    ) external {\n        data.transferGasCosts[token] = gasCost;\n        emit TransferGasCostSet(token, gasCost);\n    }\n}\n"
35     },
36     "IIntegralDelay.sol": {
37       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.5;\npragma experimental ABIEncoderV2;\n\nimport 'Orders.sol';\n\ninterface IIntegralDelay {\n    event OrderExecuted(uint256 indexed id, bool indexed success, bytes data, uint256 gasSpent, uint256 ethRefunded);\n    event RefundFailed(address indexed to, address indexed token, uint256 amount, bytes data);\n    event EthRefund(address indexed to, bool indexed success, uint256 value);\n    event OwnerSet(address owner);\n    event BotSet(address bot, bool isBot);\n    event DelaySet(uint256 delay);\n    event MaxGasLimitSet(uint256 maxGasLimit);\n    event GasPriceInertiaSet(uint256 gasPriceInertia);\n    event MaxGasPriceImpactSet(uint256 maxGasPriceImpact);\n    event TransferGasCostSet(address token, uint256 gasCost);\n    event OrderDisabled(address pair, Orders.OrderType orderType, bool disabled);\n    event UnwrapFailed(address to, uint256 amount);\n    event Execute(address sender, uint256 n);\n\n    function factory() external returns (address);\n\n    function owner() external returns (address);\n\n    function isBot(address bot) external returns (bool);\n\n    function botExecuteTime() external returns (uint256);\n\n    function gasPriceInertia() external returns (uint256);\n\n    function gasPrice() external returns (uint256);\n\n    function maxGasPriceImpact() external returns (uint256);\n\n    function maxGasLimit() external returns (uint256);\n\n    function delay() external returns (uint256);\n\n    function totalShares(address token) external returns (uint256);\n\n    function weth() external returns (address);\n\n    function getTransferGasCost(address token) external returns (uint256);\n\n    function getDepositOrder(uint256 orderId) external returns (Orders.DepositOrder memory order);\n\n    function getWithdrawOrder(uint256 orderId) external returns (Orders.WithdrawOrder memory order);\n\n    function getSellOrder(uint256 orderId) external returns (Orders.SellOrder memory order);\n\n    function getBuyOrder(uint256 orderId) external returns (Orders.BuyOrder memory order);\n\n    function getDepositDisabled(address pair) external returns (bool);\n\n    function getWithdrawDisabled(address pair) external returns (bool);\n\n    function getBuyDisabled(address pair) external returns (bool);\n\n    function getSellDisabled(address pair) external returns (bool);\n\n    function getOrderStatus(uint256 orderId) external returns (Orders.OrderStatus);\n\n    function setOrderDisabled(\n        address pair,\n        Orders.OrderType orderType,\n        bool disabled\n    ) external;\n\n    function setOwner(address _owner) external;\n\n    function setBot(address _bot, bool _isBot) external;\n\n    function setMaxGasLimit(uint256 _maxGasLimit) external;\n\n    function setDelay(uint256 _delay) external;\n\n    function setGasPriceInertia(uint256 _gasPriceInertia) external;\n\n    function setMaxGasPriceImpact(uint256 _maxGasPriceImpact) external;\n\n    function setTransferGasCost(address token, uint256 gasCost) external;\n\n    function deposit(Orders.DepositParams memory depositParams) external payable returns (uint256 orderId);\n\n    function withdraw(Orders.WithdrawParams memory withdrawParams) external payable returns (uint256 orderId);\n\n    function sell(Orders.SellParams memory sellParams) external payable returns (uint256 orderId);\n\n    function buy(Orders.BuyParams memory buyParams) external payable returns (uint256 orderId);\n\n    function execute(uint256 n) external;\n}\n"
38     },
39     "IIntegralOracle.sol": {
40       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.5;\n\ninterface IIntegralOracle {\n    event OwnerSet(address owner);\n    event UniswapPairSet(address uniswapPair);\n    event PriceUpdateIntervalSet(uint32 interval);\n    event ParametersSet(uint32 epoch, int256[] bidExponents, int256[] bidQs, int256[] askExponents, int256[] askQs);\n\n    function owner() external view returns (address);\n\n    function setOwner(address) external;\n\n    function epoch() external view returns (uint32);\n\n    function xDecimals() external view returns (uint8);\n\n    function yDecimals() external view returns (uint8);\n\n    function getParameters()\n        external\n        view\n        returns (\n            int256[] memory bidExponents,\n            int256[] memory bidQs,\n            int256[] memory askExponents,\n            int256[] memory askQs\n        );\n\n    function setParameters(\n        int256[] calldata bidExponents,\n        int256[] calldata bidQs,\n        int256[] calldata askExponents,\n        int256[] calldata askQs\n    ) external;\n\n    function price() external view returns (int256);\n\n    function priceUpdateInterval() external view returns (uint32);\n\n    function updatePrice() external returns (uint32 _epoch);\n\n    function setPriceUpdateInterval(uint32 interval) external;\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function blockTimestampLast() external view returns (uint32);\n\n    function tradeX(\n        uint256 xAfter,\n        uint256 xBefore,\n        uint256 yBefore\n    ) external view returns (uint256 yAfter);\n\n    function tradeY(\n        uint256 yAfter,\n        uint256 xBefore,\n        uint256 yBefore\n    ) external view returns (uint256 xAfter);\n\n    function getSpotPrice(uint256 xCurrent, uint256 xBefore) external view returns (uint256 spotPrice);\n}\n"
41     },
42     "Normalizer.sol": {
43       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.5;\n\nimport 'SafeMath.sol';\n\nlibrary Normalizer {\n    using SafeMath for uint256;\n\n    function normalize(uint256 amount, uint8 decimals) internal pure returns (uint256) {\n        if (decimals == 18) {\n            return amount;\n        } else if (decimals > 18) {\n            return amount.div(10**(decimals - 18));\n        } else {\n            return amount.mul(10**(18 - decimals));\n        }\n    }\n\n    function denormalize(uint256 amount, uint8 decimals) internal pure returns (uint256) {\n        if (decimals == 18) {\n            return amount;\n        } else if (decimals > 18) {\n            return amount.mul(10**(decimals - 18));\n        } else {\n            return amount.div(10**(18 - decimals));\n        }\n    }\n}\n"
44     },
45     "AddLiquidity.sol": {
46       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.5;\n\nimport 'TransferHelper.sol';\nimport 'SafeMath.sol';\nimport 'Math.sol';\nimport 'IIntegralPair.sol';\n\nlibrary AddLiquidity {\n    using SafeMath for uint256;\n\n    function _quote(\n        uint256 amount0,\n        uint256 reserve0,\n        uint256 reserve1\n    ) private pure returns (uint256 amountB) {\n        require(amount0 > 0, 'AL_INSUFFICIENT_AMOUNT');\n        require(reserve0 > 0 && reserve1 > 0, 'AL_INSUFFICIENT_LIQUIDITY');\n        amountB = amount0.mul(reserve1) / reserve0;\n    }\n\n    function addLiquidity(\n        address pair,\n        uint256 amount0Desired,\n        uint256 amount1Desired\n    ) external view returns (uint256 amount0, uint256 amount1) {\n        if (amount0Desired == 0 || amount1Desired == 0) {\n            return (0, 0);\n        }\n        (uint256 reserve0, uint256 reserve1, ) = IIntegralPair(pair).getReserves();\n        if (reserve0 == 0 && reserve1 == 0) {\n            (amount0, amount1) = (amount0Desired, amount1Desired);\n        } else {\n            uint256 amount1Optimal = _quote(amount0Desired, reserve0, reserve1);\n            if (amount1Optimal <= amount1Desired) {\n                (amount0, amount1) = (amount0Desired, amount1Optimal);\n            } else {\n                uint256 amount0Optimal = _quote(amount1Desired, reserve1, reserve0);\n                assert(amount0Optimal <= amount0Desired);\n                (amount0, amount1) = (amount0Optimal, amount1Desired);\n            }\n        }\n    }\n\n    function swapDeposit0(\n        address pair,\n        address token0,\n        uint256 amount0,\n        uint256 minSwapPrice\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\n        uint256 amount0In = IIntegralPair(pair).getDepositAmount0In(amount0);\n        amount1Left = IIntegralPair(pair).getSwapAmount1Out(amount0In);\n        if (amount1Left == 0) {\n            return (amount0, amount1Left);\n        }\n        uint256 price = amount1Left.mul(1e18).div(amount0In);\n        require(minSwapPrice == 0 || price >= minSwapPrice, 'AL_PRICE_TOO_LOW');\n        TransferHelper.safeTransfer(token0, pair, amount0In);\n        IIntegralPair(pair).swap(0, amount1Left, address(this));\n        amount0Left = amount0.sub(amount0In);\n    }\n\n    function swapDeposit1(\n        address pair,\n        address token1,\n        uint256 amount1,\n        uint256 maxSwapPrice\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\n        uint256 amount1In = IIntegralPair(pair).getDepositAmount1In(amount1);\n        amount0Left = IIntegralPair(pair).getSwapAmount0Out(amount1In);\n        if (amount0Left == 0) {\n            return (amount0Left, amount1);\n        }\n        uint256 price = amount1In.mul(1e18).div(amount0Left);\n        require(maxSwapPrice == 0 || price <= maxSwapPrice, 'AL_PRICE_TOO_HIGH');\n        TransferHelper.safeTransfer(token1, pair, amount1In);\n        IIntegralPair(pair).swap(amount0Left, 0, address(this));\n        amount1Left = amount1.sub(amount1In);\n    }\n\n    function canSwap(\n        uint256 initialRatio, // setting it to 0 disables swap\n        uint256 minRatioChangeToSwap,\n        address pairAddress\n    ) external view returns (bool) {\n        (uint256 reserve0, uint256 reserve1, ) = IIntegralPair(pairAddress).getReserves();\n        if (reserve0 == 0 || reserve1 == 0 || initialRatio == 0) {\n            return false;\n        }\n        uint256 ratio = reserve0.mul(1e18).div(reserve1);\n        // ratioChange(before, after) = MAX(before, after) / MIN(before, after) - 1\n        uint256 change = Math.max(initialRatio, ratio).mul(1e3).div(Math.min(initialRatio, ratio)).sub(1e3);\n        return change >= minRatioChangeToSwap;\n    }\n}\n"
47     },
48     "BuyHelper.sol": {
49       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.5;\n// pragma abicoder v2;\n\nimport 'IIntegralOracle.sol';\nimport 'IIntegralPair.sol';\nimport 'SafeMath.sol';\n\nlibrary BuyHelper {\n    using SafeMath for uint256;\n    uint256 public constant PRECISION = 10**18;\n\n    function getSwapAmount0In(address pair, uint256 amount1Out) external view returns (uint256 swapAmount0In) {\n        (uint112 reserve0, uint112 reserve1, ) = IIntegralPair(pair).getReserves();\n        (uint112 reference0, uint112 reference1, ) = IIntegralPair(pair).getReferences();\n        uint256 balance1After = uint256(reserve1).sub(amount1Out);\n        uint256 balance0After = IIntegralOracle(IIntegralPair(pair).oracle()).tradeY(\n            balance1After,\n            reference0,\n            reference1\n        );\n        uint256 swapFee = IIntegralPair(pair).swapFee();\n        return balance0After.sub(uint256(reserve0)).mul(PRECISION).ceil_div(PRECISION.sub(swapFee)).add(1);\n    }\n\n    function getSwapAmount1In(address pair, uint256 amount0Out) external view returns (uint256 swapAmount1In) {\n        (uint112 reserve0, uint112 reserve1, ) = IIntegralPair(pair).getReserves();\n        (uint112 reference0, uint112 reference1, ) = IIntegralPair(pair).getReferences();\n        uint256 balance0After = uint256(reserve0).sub(amount0Out);\n        uint256 balance1After = IIntegralOracle(IIntegralPair(pair).oracle()).tradeX(\n            balance0After,\n            reference0,\n            reference1\n        );\n        uint256 swapFee = IIntegralPair(pair).swapFee();\n        return balance1After.sub(uint256(reserve1)).mul(PRECISION).ceil_div(PRECISION.sub(swapFee)).add(1);\n    }\n}\n"
50     },
51     "IntegralDelay.sol": {
52       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.5;\npragma experimental ABIEncoderV2;\n\nimport 'IIntegralPair.sol';\nimport 'IIntegralDelay.sol';\nimport 'IIntegralOracle.sol';\nimport 'IWETH.sol';\nimport 'SafeMath.sol';\nimport 'Normalizer.sol';\nimport 'Orders.sol';\nimport 'TokenShares.sol';\nimport 'AddLiquidity.sol';\nimport 'BuyHelper.sol';\n\ncontract IntegralDelay is IIntegralDelay {\n    using SafeMath for uint256;\n    using Normalizer for uint256;\n    using Orders for Orders.Data;\n    using TokenShares for TokenShares.Data;\n    Orders.Data internal orders;\n    TokenShares.Data internal tokenShares;\n\n    uint256 public constant ORDER_CANCEL_TIME = 24 hours;\n    uint256 private constant ORDER_EXECUTED_COST = 3700;\n\n    address public override owner;\n    mapping(address => bool) public override isBot;\n    uint256 public override botExecuteTime;\n\n    constructor(\n        address _factory,\n        address _weth,\n        address _bot\n    ) {\n        orders.factory = _factory;\n        owner = msg.sender;\n        isBot[_bot] = true;\n        orders.gasPrice = tx.gasprice - (tx.gasprice % 1e6);\n        tokenShares.setWeth(_weth);\n        orders.delay = 5 minutes;\n        botExecuteTime = 4 * orders.delay;\n        orders.maxGasLimit = 5000000;\n        orders.gasPriceInertia = 20000000;\n        orders.maxGasPriceImpact = 1000000;\n    }\n\n    function getTransferGasCost(address token) public view override returns (uint256 gasCost) {\n        return orders.transferGasCosts[token];\n    }\n\n    function getDepositOrder(uint256 orderId) public view override returns (Orders.DepositOrder memory order) {\n        return orders.getDepositOrder(orderId);\n    }\n\n    function getWithdrawOrder(uint256 orderId) public view override returns (Orders.WithdrawOrder memory order) {\n        return orders.getWithdrawOrder(orderId);\n    }\n\n    function getSellOrder(uint256 orderId) public view override returns (Orders.SellOrder memory order) {\n        return orders.getSellOrder(orderId);\n    }\n\n    function getBuyOrder(uint256 orderId) public view override returns (Orders.BuyOrder memory order) {\n        return orders.getBuyOrder(orderId);\n    }\n\n    function getDepositDisabled(address pair) public view override returns (bool) {\n        return orders.depositDisabled[pair];\n    }\n\n    function getWithdrawDisabled(address pair) public view override returns (bool) {\n        return orders.withdrawDisabled[pair];\n    }\n\n    function getBuyDisabled(address pair) public view override returns (bool) {\n        return orders.buyDisabled[pair];\n    }\n\n    function getSellDisabled(address pair) public view override returns (bool) {\n        return orders.sellDisabled[pair];\n    }\n\n    function getOrderStatus(uint256 orderId) public view override returns (Orders.OrderStatus) {\n        return orders.getOrderStatus(orderId);\n    }\n\n    uint256 private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, 'ID_LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function factory() public view override returns (address) {\n        return orders.factory;\n    }\n\n    function totalShares(address token) public view override returns (uint256) {\n        return tokenShares.totalShares[token];\n    }\n\n    function weth() public view override returns (address) {\n        return tokenShares.weth;\n    }\n\n    function delay() public view override returns (uint256) {\n        return orders.delay;\n    }\n\n    function lastProcessedOrderId() public view returns (uint256) {\n        return orders.lastProcessedOrderId;\n    }\n\n    function newestOrderId() public view returns (uint256) {\n        return orders.newestOrderId;\n    }\n\n    function getOrder(uint256 orderId) public view returns (Orders.OrderType orderType, uint256 validAfterTimestamp) {\n        return orders.getOrder(orderId);\n    }\n\n    function isOrderCanceled(uint256 orderId) public view returns (bool) {\n        return orders.canceled[orderId];\n    }\n\n    function maxGasLimit() public view override returns (uint256) {\n        return orders.maxGasLimit;\n    }\n\n    function maxGasPriceImpact() public view override returns (uint256) {\n        return orders.maxGasPriceImpact;\n    }\n\n    function gasPriceInertia() public view override returns (uint256) {\n        return orders.gasPriceInertia;\n    }\n\n    function gasPrice() public view override returns (uint256) {\n        return orders.gasPrice;\n    }\n\n    function setOrderDisabled(\n        address pair,\n        Orders.OrderType orderType,\n        bool disabled\n    ) public override {\n        require(msg.sender == owner, 'ID_FORBIDDEN');\n        require(orderType != Orders.OrderType.Empty, 'ID_INVALID_ORDER_TYPE');\n        if (orderType == Orders.OrderType.Deposit) {\n            orders.depositDisabled[pair] = disabled;\n        } else if (orderType == Orders.OrderType.Withdraw) {\n            orders.withdrawDisabled[pair] = disabled;\n        } else if (orderType == Orders.OrderType.Sell) {\n            orders.sellDisabled[pair] = disabled;\n        } else if (orderType == Orders.OrderType.Buy) {\n            orders.buyDisabled[pair] = disabled;\n        }\n        emit OrderDisabled(pair, orderType, disabled);\n    }\n\n    function setOwner(address _owner) public override {\n        require(msg.sender == owner, 'ID_FORBIDDEN');\n        owner = _owner;\n        emit OwnerSet(owner);\n    }\n\n    function setBot(address _bot, bool _isBot) public override {\n        require(msg.sender == owner, 'ID_FORBIDDEN');\n        isBot[_bot] = _isBot;\n        emit BotSet(_bot, _isBot);\n    }\n\n    function setMaxGasLimit(uint256 _maxGasLimit) public override {\n        require(msg.sender == owner, 'ID_FORBIDDEN');\n        orders.setMaxGasLimit(_maxGasLimit);\n    }\n\n    function setDelay(uint256 _delay) public override {\n        require(msg.sender == owner, 'ID_FORBIDDEN');\n        orders.delay = _delay;\n        botExecuteTime = 4 * _delay;\n        emit DelaySet(_delay);\n    }\n\n    function setGasPriceInertia(uint256 _gasPriceInertia) public override {\n        require(msg.sender == owner, 'ID_FORBIDDEN');\n        orders.setGasPriceInertia(_gasPriceInertia);\n    }\n\n    function setMaxGasPriceImpact(uint256 _maxGasPriceImpact) public override {\n        require(msg.sender == owner, 'ID_FORBIDDEN');\n        orders.setMaxGasPriceImpact(_maxGasPriceImpact);\n    }\n\n    function setTransferGasCost(address token, uint256 gasCost) public override {\n        require(msg.sender == owner, 'ID_FORBIDDEN');\n        orders.setTransferGasCost(token, gasCost);\n    }\n\n    function deposit(Orders.DepositParams calldata depositParams)\n        external\n        payable\n        override\n        lock\n        returns (uint256 orderId)\n    {\n        orders.deposit(depositParams, tokenShares);\n        return orders.newestOrderId;\n    }\n\n    function withdraw(Orders.WithdrawParams calldata withdrawParams)\n        external\n        payable\n        override\n        lock\n        returns (uint256 orderId)\n    {\n        orders.withdraw(withdrawParams);\n        return orders.newestOrderId;\n    }\n\n    function sell(Orders.SellParams calldata sellParams) external payable override lock returns (uint256 orderId) {\n        orders.sell(sellParams, tokenShares);\n        return orders.newestOrderId;\n    }\n\n    function buy(Orders.BuyParams calldata buyParams) external payable override lock returns (uint256 orderId) {\n        orders.buy(buyParams, tokenShares);\n        return orders.newestOrderId;\n    }\n\n    function execute(uint256 n) public override lock {\n        emit Execute(msg.sender, n);\n        uint256 gasBefore = gasleft();\n        bool orderExecuted = false;\n        for (uint256 i = 0; i < n; i++) {\n            if (isOrderCanceled(orders.lastProcessedOrderId + 1)) {\n                orders.dequeueCanceledOrder();\n                continue;\n            }\n            (Orders.OrderType orderType, uint256 validAfterTimestamp) = orders.getNextOrder();\n            if (orderType == Orders.OrderType.Empty || validAfterTimestamp >= block.timestamp) {\n                break;\n            }\n            require(\n                block.timestamp >= validAfterTimestamp + botExecuteTime || isBot[msg.sender] || isBot[address(0)],\n                'ID_FORBIDDEN'\n            );\n            orderExecuted = true;\n            if (orderType == Orders.OrderType.Deposit) {\n                executeDeposit();\n            } else if (orderType == Orders.OrderType.Withdraw) {\n                executeWithdraw();\n            } else if (orderType == Orders.OrderType.Sell) {\n                executeSell();\n            } else if (orderType == Orders.OrderType.Buy) {\n                executeBuy();\n            }\n        }\n        if (orderExecuted) {\n            orders.updateGasPrice(gasBefore.sub(gasleft()));\n        }\n    }\n\n    function executeDeposit() internal {\n        uint256 gasStart = gasleft();\n        Orders.DepositOrder memory depositOrder = orders.dequeueDepositOrder();\n        (, address token0, address token1) = orders.getPairInfo(depositOrder.pairId);\n        (bool executionSuccess, bytes memory data) = address(this).call{\n            gas: depositOrder.gasLimit.sub(\n                Orders.ORDER_BASE_COST.add(orders.transferGasCosts[token0]).add(orders.transferGasCosts[token1])\n            )\n        }(abi.encodeWithSelector(this._executeDeposit.selector, depositOrder));\n        bool refundSuccess = true;\n        if (!executionSuccess) {\n            refundSuccess = refundTokens(\n                depositOrder.to,\n                token0,\n                depositOrder.share0,\n                token1,\n                depositOrder.share1,\n                depositOrder.unwrap\n            );\n        }\n        if (!refundSuccess) {\n            orders.markRefundFailed();\n        } else {\n            orders.forgetLastProcessedOrder();\n        }\n        (uint256 gasUsed, uint256 ethRefund) = refund(\n            depositOrder.gasLimit,\n            depositOrder.gasPrice,\n            gasStart,\n            depositOrder.to\n        );\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\n    }\n\n    function executeWithdraw() internal {\n        uint256 gasStart = gasleft();\n        Orders.WithdrawOrder memory withdrawOrder = orders.dequeueWithdrawOrder();\n        (address pair, , ) = orders.getPairInfo(withdrawOrder.pairId);\n        (bool executionSuccess, bytes memory data) = address(this).call{\n            gas: withdrawOrder.gasLimit.sub(Orders.ORDER_BASE_COST.add(Orders.PAIR_TRANSFER_COST))\n        }(abi.encodeWithSelector(this._executeWithdraw.selector, withdrawOrder));\n        bool refundSuccess = true;\n        if (!executionSuccess) {\n            refundSuccess = refundLiquidity(pair, withdrawOrder.to, withdrawOrder.liquidity);\n        }\n        if (!refundSuccess) {\n            orders.markRefundFailed();\n        } else {\n            orders.forgetLastProcessedOrder();\n        }\n        (uint256 gasUsed, uint256 ethRefund) = refund(\n            withdrawOrder.gasLimit,\n            withdrawOrder.gasPrice,\n            gasStart,\n            withdrawOrder.to\n        );\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\n    }\n\n    function executeSell() internal {\n        uint256 gasStart = gasleft();\n        Orders.SellOrder memory sellOrder = orders.dequeueSellOrder();\n        (, address token0, address token1) = orders.getPairInfo(sellOrder.pairId);\n        (bool executionSuccess, bytes memory data) = address(this).call{\n            gas: sellOrder.gasLimit.sub(\n                Orders.ORDER_BASE_COST.add(orders.transferGasCosts[sellOrder.inverse ? token1 : token0])\n            )\n        }(abi.encodeWithSelector(this._executeSell.selector, sellOrder));\n        bool refundSuccess = true;\n        if (!executionSuccess) {\n            refundSuccess = refundToken(\n                sellOrder.inverse ? token1 : token0,\n                sellOrder.to,\n                sellOrder.shareIn,\n                sellOrder.unwrap\n            );\n        }\n        if (!refundSuccess) {\n            orders.markRefundFailed();\n        } else {\n            orders.forgetLastProcessedOrder();\n        }\n        (uint256 gasUsed, uint256 ethRefund) = refund(sellOrder.gasLimit, sellOrder.gasPrice, gasStart, sellOrder.to);\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\n    }\n\n    function executeBuy() internal {\n        uint256 gasStart = gasleft();\n        Orders.BuyOrder memory buyOrder = orders.dequeueBuyOrder();\n        (, address token0, address token1) = orders.getPairInfo(buyOrder.pairId);\n        (bool executionSuccess, bytes memory data) = address(this).call{\n            gas: buyOrder.gasLimit.sub(\n                Orders.ORDER_BASE_COST.add(orders.transferGasCosts[buyOrder.inverse ? token1 : token0])\n            )\n        }(abi.encodeWithSelector(this._executeBuy.selector, buyOrder));\n        bool refundSuccess = true;\n        if (!executionSuccess) {\n            refundSuccess = refundToken(\n                buyOrder.inverse ? token1 : token0,\n                buyOrder.to,\n                buyOrder.shareInMax,\n                buyOrder.unwrap\n            );\n        }\n        if (!refundSuccess) {\n            orders.markRefundFailed();\n        } else {\n            orders.forgetLastProcessedOrder();\n        }\n        (uint256 gasUsed, uint256 ethRefund) = refund(buyOrder.gasLimit, buyOrder.gasPrice, gasStart, buyOrder.to);\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\n    }\n\n    function refund(\n        uint256 gasLimit,\n        uint256 gasPriceInOrder,\n        uint256 gasStart,\n        address to\n    ) private returns (uint256 gasUsed, uint256 leftOver) {\n        uint256 feeCollected = gasLimit.mul(gasPriceInOrder);\n        gasUsed = gasStart.sub(gasleft()).add(Orders.REFUND_END_COST).add(ORDER_EXECUTED_COST);\n        uint256 actualRefund = Math.min(feeCollected, gasUsed.mul(orders.gasPrice));\n        leftOver = feeCollected.sub(actualRefund);\n        require(refundEth(msg.sender, actualRefund), 'ID_ETH_REFUND_FAILED');\n        refundEth(payable(to), leftOver);\n    }\n\n    function refundEth(address payable to, uint256 value) internal returns (bool success) {\n        if (value == 0) {\n            return true;\n        }\n        success = to.send(value);\n        emit EthRefund(to, success, value);\n    }\n\n    function refundToken(\n        address token,\n        address to,\n        uint256 share,\n        bool unwrap\n    ) private returns (bool) {\n        if (share == 0) {\n            return true;\n        }\n        (bool success, bytes memory data) = address(this).call{ gas: orders.transferGasCosts[token] }(\n            abi.encodeWithSelector(this._refundToken.selector, token, to, share, unwrap)\n        );\n        if (!success) {\n            emit RefundFailed(to, token, share, data);\n        }\n        return success;\n    }\n\n    function refundTokens(\n        address to,\n        address token0,\n        uint256 share0,\n        address token1,\n        uint256 share1,\n        bool unwrap\n    ) private returns (bool) {\n        (bool success, bytes memory data) = address(this).call{\n            gas: orders.transferGasCosts[token0].add(orders.transferGasCosts[token1])\n        }(abi.encodeWithSelector(this._refundTokens.selector, to, token0, share0, token1, share1, unwrap));\n        if (!success) {\n            emit RefundFailed(to, token0, share0, data);\n            emit RefundFailed(to, token1, share1, data);\n        }\n        return success;\n    }\n\n    function _refundTokens(\n        address to,\n        address token0,\n        uint256 share0,\n        address token1,\n        uint256 share1,\n        bool unwrap\n    ) external {\n        // no need to check sender, because it is checked in _refundToken\n        _refundToken(token0, to, share0, unwrap);\n        _refundToken(token1, to, share1, unwrap);\n    }\n\n    function _refundToken(\n        address token,\n        address to,\n        uint256 share,\n        bool unwrap\n    ) public {\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\n        if (token == tokenShares.weth && unwrap) {\n            uint256 amount = tokenShares.sharesToAmount(token, share);\n            IWETH(tokenShares.weth).withdraw(amount);\n            payable(to).transfer(amount);\n        } else {\n            return TransferHelper.safeTransfer(token, to, tokenShares.sharesToAmount(token, share));\n        }\n    }\n\n    function refundLiquidity(\n        address pair,\n        address to,\n        uint256 liquidity\n    ) private returns (bool) {\n        if (liquidity == 0) {\n            return true;\n        }\n        (bool success, bytes memory data) = address(this).call{ gas: Orders.PAIR_TRANSFER_COST }(\n            abi.encodeWithSelector(this._refundLiquidity.selector, pair, to, liquidity, false)\n        );\n        if (!success) {\n            emit RefundFailed(to, pair, liquidity, data);\n        }\n        return success;\n    }\n\n    function _refundLiquidity(\n        address pair,\n        address to,\n        uint256 liquidity\n    ) public {\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\n        return TransferHelper.safeTransfer(pair, to, liquidity);\n    }\n\n    function _executeDeposit(Orders.DepositOrder memory depositOrder) public {\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\n        require(depositOrder.deadline >= block.timestamp, 'ID_EXPIRED');\n\n        (address pair, address token0, address token1, uint256 amount0Left, uint256 amount1Left) = _initialDeposit(\n            depositOrder\n        );\n        if (\n            (amount0Left != 0 || amount1Left != 0) &&\n            AddLiquidity.canSwap(\n                depositOrder.initialRatio,\n                depositOrder.minRatioChangeToSwap,\n                orders.pairs[depositOrder.pairId].pair\n            )\n        ) {\n            if (amount0Left != 0) {\n                (amount0Left, amount1Left) = AddLiquidity.swapDeposit0(\n                    pair,\n                    token0,\n                    amount0Left,\n                    depositOrder.minSwapPrice\n                );\n            } else if (amount1Left != 0) {\n                (amount0Left, amount1Left) = AddLiquidity.swapDeposit1(\n                    pair,\n                    token1,\n                    amount1Left,\n                    depositOrder.maxSwapPrice\n                );\n            }\n        }\n        if (amount0Left != 0 && amount1Left != 0) {\n            (amount0Left, amount1Left) = _addLiquidityAndMint(\n                pair,\n                depositOrder.to,\n                token0,\n                token1,\n                amount0Left,\n                amount1Left\n            );\n        }\n\n        _refundDeposit(depositOrder.to, token0, token1, amount0Left, amount1Left);\n    }\n\n    function _initialDeposit(Orders.DepositOrder memory depositOrder)\n        private\n        returns (\n            address pair,\n            address token0,\n            address token1,\n            uint256 amount0Left,\n            uint256 amount1Left\n        )\n    {\n        (pair, token0, token1) = orders.getPairInfo(depositOrder.pairId);\n        uint256 amount0Desired = tokenShares.sharesToAmount(token0, depositOrder.share0);\n        uint256 amount1Desired = tokenShares.sharesToAmount(token1, depositOrder.share1);\n        IIntegralPair(pair).fullSync();\n        (amount0Left, amount1Left) = _addLiquidityAndMint(\n            pair,\n            depositOrder.to,\n            token0,\n            token1,\n            amount0Desired,\n            amount1Desired\n        );\n    }\n\n    function _addLiquidityAndMint(\n        address pair,\n        address to,\n        address token0,\n        address token1,\n        uint256 amount0Desired,\n        uint256 amount1Desired\n    ) private returns (uint256 amount0Left, uint256 amount1Left) {\n        (uint256 amount0, uint256 amount1) = AddLiquidity.addLiquidity(pair, amount0Desired, amount1Desired);\n        if (amount0 == 0 || amount1 == 0) {\n            return (amount0Desired, amount1Desired);\n        }\n        TransferHelper.safeTransfer(token0, pair, amount0);\n        TransferHelper.safeTransfer(token1, pair, amount1);\n        IIntegralPair(pair).mint(to);\n\n        amount0Left = amount0Desired.sub(amount0);\n        amount1Left = amount1Desired.sub(amount1);\n    }\n\n    function _refundDeposit(\n        address to,\n        address token0,\n        address token1,\n        uint256 amount0,\n        uint256 amount1\n    ) private {\n        if (amount0 > 0) {\n            TransferHelper.safeTransfer(token0, to, amount0);\n        }\n        if (amount1 > 0) {\n            TransferHelper.safeTransfer(token1, to, amount1);\n        }\n    }\n\n    function _executeWithdraw(Orders.WithdrawOrder memory withdrawOrder) public {\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\n        require(withdrawOrder.deadline >= block.timestamp, 'ID_EXPIRED');\n\n        (address pair, , ) = orders.getPairInfo(withdrawOrder.pairId);\n        IIntegralPair(pair).fullSync();\n        TransferHelper.safeTransfer(pair, pair, withdrawOrder.liquidity);\n        (uint256 amount0, uint256 amount1) = IIntegralPair(pair).burn(withdrawOrder.to);\n\n        require(amount0 >= withdrawOrder.amount0Min && amount1 >= withdrawOrder.amount1Min, 'ID_INSUFFICIENT_AMOUNT');\n    }\n\n    function _executeBuy(Orders.BuyOrder memory buyOrder) public {\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\n        require(buyOrder.deadline >= block.timestamp, 'ID_EXPIRED');\n\n        (address pairAddress, address token0, address token1) = orders.getPairInfo(buyOrder.pairId);\n        (address tokenIn, address tokenOut) = buyOrder.inverse ? (token1, token0) : (token0, token1);\n        uint256 amountInMax = tokenShares.sharesToAmount(tokenIn, buyOrder.shareInMax);\n        IIntegralPair pair = IIntegralPair(pairAddress);\n        pair.fullSync();\n        uint256 amountIn = buyOrder.inverse\n            ? BuyHelper.getSwapAmount1In(pairAddress, buyOrder.amountOut)\n            : BuyHelper.getSwapAmount0In(pairAddress, buyOrder.amountOut);\n        require(amountInMax >= amountIn, 'ID_INSUFFICIENT_INPUT_AMOUNT');\n        (uint256 amount0Out, uint256 amount1Out) = buyOrder.inverse\n            ? (buyOrder.amountOut, uint256(0))\n            : (uint256(0), buyOrder.amountOut);\n        TransferHelper.safeTransfer(tokenIn, pairAddress, amountIn);\n        if (tokenOut == tokenShares.weth && buyOrder.unwrap) {\n            pair.swap(amount0Out, amount1Out, address(this));\n            IWETH(tokenShares.weth).withdraw(buyOrder.amountOut);\n            (bool success, ) = buyOrder.to.call{ value: buyOrder.amountOut, gas: Orders.ETHER_TRANSFER_CALL_COST }('');\n            if (!success) {\n                tokenShares.onUnwrapFailed(buyOrder.to, buyOrder.amountOut);\n            }\n        } else {\n            pair.swap(amount0Out, amount1Out, buyOrder.to);\n        }\n    }\n\n    function _executeSell(Orders.SellOrder memory sellOrder) public {\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\n        require(sellOrder.deadline >= block.timestamp, 'ID_EXPIRED');\n\n        (address pairAddress, address token0, address token1) = orders.getPairInfo(sellOrder.pairId);\n        (address tokenIn, address tokenOut) = sellOrder.inverse ? (token1, token0) : (token0, token1);\n        uint256 amountIn = tokenShares.sharesToAmount(tokenIn, sellOrder.shareIn);\n        IIntegralPair pair = IIntegralPair(pairAddress);\n        pair.fullSync();\n        TransferHelper.safeTransfer(tokenIn, pairAddress, amountIn);\n        uint256 amountOut = sellOrder.inverse ? pair.getSwapAmount0Out(amountIn) : pair.getSwapAmount1Out(amountIn);\n        require(amountOut >= sellOrder.amountOutMin, 'ID_INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint256 amount0Out, uint256 amount1Out) = sellOrder.inverse\n            ? (amountOut, uint256(0))\n            : (uint256(0), amountOut);\n        if (tokenOut == tokenShares.weth && sellOrder.unwrap) {\n            pair.swap(amount0Out, amount1Out, address(this));\n            IWETH(tokenShares.weth).withdraw(amountOut);\n            (bool success, ) = sellOrder.to.call{ value: amountOut, gas: Orders.ETHER_TRANSFER_CALL_COST }('');\n            if (!success) {\n                tokenShares.onUnwrapFailed(sellOrder.to, amountOut);\n            }\n        } else {\n            pair.swap(amount0Out, amount1Out, sellOrder.to);\n        }\n    }\n\n    function performRefund(\n        Orders.OrderType orderType,\n        uint256 validAfterTimestamp,\n        uint256 orderId,\n        bool shouldRefundEth\n    ) internal {\n        bool canOwnerRefund = validAfterTimestamp.add(365 days) < block.timestamp;\n        if (orderType == Orders.OrderType.Deposit) {\n            Orders.DepositOrder memory depositOrder = orders.getDepositOrder(orderId);\n            (, address token0, address token1) = orders.getPairInfo(depositOrder.pairId);\n            address to = canOwnerRefund ? owner : depositOrder.to;\n            require(\n                refundTokens(to, token0, depositOrder.share0, token1, depositOrder.share1, depositOrder.unwrap),\n                'ID_REFUND_FAILED'\n            );\n            if (shouldRefundEth) {\n                uint256 value = depositOrder.gasPrice.mul(depositOrder.gasLimit);\n                require(refundEth(payable(to), value), 'ID_ETH_REFUND_FAILED');\n            }\n        } else if (orderType == Orders.OrderType.Withdraw) {\n            Orders.WithdrawOrder memory withdrawOrder = orders.getWithdrawOrder(orderId);\n            (address pair, , ) = orders.getPairInfo(withdrawOrder.pairId);\n            address to = canOwnerRefund ? owner : withdrawOrder.to;\n            require(refundLiquidity(pair, to, withdrawOrder.liquidity), 'ID_REFUND_FAILED');\n            if (shouldRefundEth) {\n                uint256 value = withdrawOrder.gasPrice.mul(withdrawOrder.gasLimit);\n                require(refundEth(payable(to), value), 'ID_ETH_REFUND_FAILED');\n            }\n        } else if (orderType == Orders.OrderType.Sell) {\n            Orders.SellOrder memory sellOrder = orders.getSellOrder(orderId);\n            (, address token0, address token1) = orders.getPairInfo(sellOrder.pairId);\n            address to = canOwnerRefund ? owner : sellOrder.to;\n            require(\n                refundToken(sellOrder.inverse ? token1 : token0, to, sellOrder.shareIn, sellOrder.unwrap),\n                'ID_REFUND_FAILED'\n            );\n            if (shouldRefundEth) {\n                uint256 value = sellOrder.gasPrice.mul(sellOrder.gasLimit);\n                require(refundEth(payable(to), value), 'ID_ETH_REFUND_FAILED');\n            }\n        } else if (orderType == Orders.OrderType.Buy) {\n            Orders.BuyOrder memory buyOrder = orders.getBuyOrder(orderId);\n            (, address token0, address token1) = orders.getPairInfo(buyOrder.pairId);\n            address to = canOwnerRefund ? owner : buyOrder.to;\n            require(\n                refundToken(buyOrder.inverse ? token1 : token0, to, buyOrder.shareInMax, buyOrder.unwrap),\n                'ID_REFUND_FAILED'\n            );\n            if (shouldRefundEth) {\n                uint256 value = buyOrder.gasPrice.mul(buyOrder.gasLimit);\n                require(refundEth(payable(to), value), 'ID_ETH_REFUND_FAILED');\n            }\n        }\n        orders.forgetOrder(orderId);\n    }\n\n    function retryRefund(uint256 orderId) public lock {\n        (Orders.OrderType orderType, uint256 validAfterTimestamp) = orders.getFailedOrderType(orderId);\n        performRefund(orderType, validAfterTimestamp, orderId, false);\n    }\n\n    function cancelOrder(uint256 orderId) public lock {\n        (Orders.OrderType orderType, uint256 validAfterTimestamp) = orders.getOrder(orderId);\n        require(validAfterTimestamp.sub(delay()).add(ORDER_CANCEL_TIME) < block.timestamp, 'ID_ORDER_NOT_EXCEEDED');\n        performRefund(orderType, validAfterTimestamp, orderId, true);\n        orders.canceled[orderId] = true;\n    }\n\n    receive() external payable {}\n}\n"
53     }
54   },
55   "settings": {
56     "libraries": {
57       "IERC20.sol": {
58         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
59         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
60         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
61         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
62       },
63       "IIntegralERC20.sol": {
64         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
65         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
66         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
67         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
68       },
69       "IReserves.sol": {
70         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
71         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
72         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
73         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
74       },
75       "IIntegralPair.sol": {
76         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
77         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
78         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
79         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
80       },
81       "SafeMath.sol": {
82         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
83         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
84         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
85         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
86       },
87       "Math.sol": {
88         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
89         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
90         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
91         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
92       },
93       "IIntegralFactory.sol": {
94         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
95         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
96         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
97         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
98       },
99       "IWETH.sol": {
100         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
101         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
102         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
103         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
104       },
105       "TransferHelper.sol": {
106         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
107         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
108         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
109         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
110       },
111       "TokenShares.sol": {
112         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
113         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
114         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
115         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
116       },
117       "Orders.sol": {
118         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
119         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
120         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
121         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
122       },
123       "IIntegralDelay.sol": {
124         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
125         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
126         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
127         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
128       },
129       "IIntegralOracle.sol": {
130         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
131         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
132         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
133         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
134       },
135       "Normalizer.sol": {
136         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
137         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
138         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
139         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
140       },
141       "AddLiquidity.sol": {
142         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
143         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
144         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
145         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
146       },
147       "BuyHelper.sol": {
148         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
149         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
150         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
151         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
152       },
153       "IntegralDelay.sol": {
154         "TokenShares": "0xc82938b53e0e190459ba4e3502bf26f194760183",
155         "Orders": "0x7218D567b671E36c4e6B3257b8919196CF68ff5E",
156         "AddLiquidity": "0x3A09FA6c7Cb82FC94c377087cF59eC9529094e61",
157         "BuyHelper": "0x5d0434d41C77E4D9a858000f3939c0c4A05B0e26"
158       }
159     },
160     "optimizer": {
161       "enabled": true,
162       "runs": 200
163     },
164     "outputSelection": {
165       "*": {
166         "*": [
167           "evm.bytecode",
168           "evm.deployedBytecode",
169           "abi"
170         ]
171       }
172     }
173   },
174   "language": "Solidity"
175 }}