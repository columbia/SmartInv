1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/assets/erc1155/Super1155.sol": {
5       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../../access/PermitControl.sol\";\nimport \"../../proxy/StubProxyRegistry.sol\";\nimport \"../../libraries/DFStorage.sol\";\nimport \"./interfaces/ISuper1155.sol\";\n\n/**\n  @title An ERC-1155 item creation contract.\n  @author Tim Clancy\n  @author Qazawat Zirak\n  @author Rostislav Khlebnikov\n  @author Nikita Elunin\n\n  This contract represents the NFTs within a single collection. It allows for a\n  designated collection owner address to manage the creation of NFTs within this\n  collection. The collection owner grants approval to or removes approval from\n  other addresses governing their ability to mint NFTs from this collection.\n\n  This contract is forked from the inherited OpenZeppelin dependency, and uses\n  ideas from the original ERC-1155 reference implementation.\n\n  July 19th, 2021.\n*/\ncontract Super1155 is PermitControl, ERC165Storage, IERC1155, IERC1155MetadataURI {\n  using Address for address;\n\n  uint256 MAX_INT = type(uint256).max;\n\n  /// The public identifier for the right to set this contract's metadata URI.\n  bytes32 public constant SET_URI = keccak256(\"SET_URI\");\n\n  /// The public identifier for the right to set this contract's proxy registry.\n  bytes32 public constant SET_PROXY_REGISTRY = keccak256(\"SET_PROXY_REGISTRY\");\n\n  /// The public identifier for the right to configure item groups.\n  bytes32 public constant CONFIGURE_GROUP = keccak256(\"CONFIGURE_GROUP\");\n\n  /// The public identifier for the right to mint items.\n  bytes32 public constant MINT  = keccak256(\"MINT\");\n\n  /// The public identifier for the right to burn items.\n  bytes32 public constant BURN = keccak256(\"BURN\");\n\n  /// The public identifier for the right to set item metadata.\n  bytes32 public constant SET_METADATA = keccak256(\"SET_METADATA\");\n\n  /// The public identifier for the right to lock the metadata URI.\n  bytes32 public constant LOCK_URI = keccak256(\"LOCK_URI\");\n\n  /// The public identifier for the right to lock an item's metadata.\n  bytes32 public constant LOCK_ITEM_URI = keccak256(\"LOCK_ITEM_URI\");\n\n  /// The public identifier for the right to disable item creation.\n  bytes32 public constant LOCK_CREATION = keccak256(\"LOCK_CREATION\");\n\n  /// @dev Supply the magic number for the required ERC-1155 interface.\n  bytes4 private constant INTERFACE_ERC1155 = 0xd9b67a26;\n\n  /// @dev Supply the magic number for the required ERC-1155 metadata extension.\n  bytes4 private constant INTERFACE_ERC1155_METADATA_URI = 0x0e89341c;\n\n  /// @dev A mask for isolating an item's group ID.\n  uint256 private constant GROUP_MASK = uint256(type(uint128).max) << 128;\n\n  /// The public name of this contract.\n  string public name;\n\n  /**\n    The ERC-1155 URI for tracking item metadata, supporting {id} substitution.\n    For example: https://token-cdn-domain/{id}.json. See the ERC-1155 spec for\n    more details: https://eips.ethereum.org/EIPS/eip-1155#metadata.\n  */\n  string public metadataUri;\n\n  /// The URI for the storefront-level metadata of contract\n  string public contractURI;\n\n  /// A proxy registry address for supporting automatic delegated approval.\n  address public proxyRegistryAddress;\n\n  /// @dev A mapping from each token ID to per-address balances.\n  mapping (uint256 => mapping(address => uint256)) private balances;\n\n  /// A mapping from each group ID to per-address balances.\n  mapping (uint256 => mapping(address => uint256)) public groupBalances;\n\n  /// A mapping from each address to a collection-wide balance.\n  mapping(address => uint256) public totalBalances;\n\n  /**\n    @dev This is a mapping from each address to per-address operator approvals.\n    Operators are those addresses that have been approved to transfer tokens on\n    behalf of the approver. Transferring tokens includes the right to burn\n    tokens.\n  */\n  mapping (address => mapping(address => bool)) private operatorApprovals;\n\n  /**\n    This struct defines the settings for a particular item group and is tracked\n    in storage.\n\n    @param initialized Whether or not this `ItemGroup` has been initialized.\n    @param name A name for the item group.\n    @param supplyType The supply type for this group of items.\n    @param supplyData An optional integer used by some `supplyType` values.\n    @param itemType The type of item represented by this item group.\n    @param itemData An optional integer used by some `itemType` values.\n    @param burnType The type of burning permitted by this item group.\n    @param burnData An optional integer used by some `burnType` values.\n    @param circulatingSupply The number of individual items within this group in\n      circulation.\n    @param mintCount The number of times items in this group have been minted.\n    @param burnCount The number of times items in this group have been burnt.\n  */\n  struct ItemGroup {\n    uint256 burnData;\n    uint256 circulatingSupply;\n    uint256 mintCount;\n    uint256 burnCount;\n    uint256 supplyData;\n    uint256 itemData;\n    bool initialized;\n    DFStorage.SupplyType supplyType;\n    DFStorage.ItemType itemType;\n    DFStorage.BurnType burnType;\n    string name;\n  }\n\n  /// A mapping of data for each item group.\n  mapping (uint256 => ItemGroup) public itemGroups;\n\n  /// A mapping of circulating supplies for each individual token.\n  mapping (uint256 => uint256) public circulatingSupply;\n\n  /// A mapping of the number of times each individual token has been minted.\n  mapping (uint256 => uint256) public mintCount;\n\n  /// A mapping of the number of times each individual token has been burnt.\n  mapping (uint256 => uint256) public burnCount;\n\n  /**\n    A mapping of token ID to a boolean representing whether the item's metadata\n    has been explicitly frozen via a call to `lockURI(string calldata _uri,\n    uint256 _id)`. Do note that it is possible for an item's mapping here to be\n    false while still having frozen metadata if the item collection as a whole\n    has had its `uriLocked` value set to true.\n  */\n  mapping (uint256 => bool) public metadataFrozen;\n\n  /**\n    A public mapping of optional on-chain metadata for each token ID. A token's\n    on-chain metadata is unable to be changed if the item's metadata URI has\n    been permanently fixed or if the collection's metadata URI as a whole has\n    been frozen.\n  */\n  mapping (uint256 => string) public metadata;\n\n  /// Whether or not the metadata URI has been locked to future changes.\n  bool public uriLocked;\n\n  /// Whether or not the contract URI has been locked to future changes.\n  bool public contractUriLocked;\n\n  /// Whether or not the item collection has been locked to all further minting.\n  bool public locked;\n\n  /**\n    An event that gets emitted when the metadata collection URI is changed.\n\n    @param oldURI The old metadata URI.\n    @param newURI The new metadata URI.\n  */\n  event ChangeURI(string indexed oldURI, string indexed newURI);\n\n  /**\n    An event that gets emitted when the proxy registry address is changed.\n\n    @param oldRegistry The old proxy registry address.\n    @param newRegistry The new proxy registry address.\n  */\n  event ChangeProxyRegistry(address indexed oldRegistry,\n    address indexed newRegistry);\n\n  /**\n    An event that gets emitted when an item group is configured.\n\n    @param manager The caller who configured the item group `_groupId`.\n    @param groupId The groupId being configured.\n    @param newGroup The new group configuration.\n  */\n  event ItemGroupConfigured(address indexed manager, uint256 groupId,\n    DFStorage.ItemGroupInput indexed newGroup);\n\n  /**\n    An event that gets emitted when the item collection is locked to further\n    creation.\n\n    @param locker The caller who locked the collection.\n  */\n  event CollectionLocked(address indexed locker);\n\n  /**\n    An event that gets emitted when a token ID has its on-chain metadata\n    changed.\n\n    @param changer The caller who triggered the metadata change.\n    @param id The ID of the token which had its metadata changed.\n    @param oldMetadata The old metadata of the token.\n    @param newMetadata The new metadata of the token.\n  */\n  event MetadataChanged(address indexed changer, uint256 indexed id,\n    string oldMetadata, string indexed newMetadata);\n\n  /**\n    An event that indicates we have set a permanent metadata URI for a token.\n\n    @param _value The value of the permanent metadata URI.\n    @param _id The token ID associated with the permanent metadata value.\n  */\n  event PermanentURI(string _value, uint256 indexed _id);\n\n  /**\n    An event that emmited when the contract URI is changed\n\n    @param oldURI The old contract URI\n    @param newURI The new contract URI\n   */\n  event ChangeContractURI(string indexed oldURI, string indexed newURI);\n\n  /**\n    An event that indicates we have set a permanent contract URI.\n\n    @param _value The value of the permanent contract URI.\n    @param _id The token ID associated with the permanent metadata value.\n  */\n  event PermanentContractURI(string _value, uint256 indexed _id);\n\n  /**\n    Construct a new ERC-1155 item collection.\n\n    @param _name The name to assign to this item collection contract.\n    @param _metadataURI The metadata URI to perform later token ID substitution with.\n    @param _contractURI The contract URI.\n    @param _proxyRegistryAddress The address of a proxy registry contract.\n  */\n  constructor(address _owner, string memory _name, string memory _metadataURI,\n    string memory _contractURI, address _proxyRegistryAddress) {\n\n    // Register the ERC-165 interfaces.\n    _registerInterface(INTERFACE_ERC1155);\n    _registerInterface(INTERFACE_ERC1155_METADATA_URI);\n\n    setPermit(_msgSender(), UNIVERSAL, CONFIGURE_GROUP, MAX_INT);\n\n     if (_owner != owner()) {\n      transferOwnership(_owner);\n    }\n    // Continue initialization.\n    name = _name;\n    metadataUri = _metadataURI;\n    contractURI = _contractURI;\n    proxyRegistryAddress = _proxyRegistryAddress;\n  }\n\n  /**\n    Return a version number for this contract's interface.\n  */\n  function version() external virtual override pure returns (uint256) {\n    return 1;\n  }\n\n  /**\n    Return the item collection's metadata URI. This implementation returns the\n    same URI for all tokens within the collection and relies on client-side\n    ID substitution per https://eips.ethereum.org/EIPS/eip-1155#metadata. Per\n    said specification, clients calling this function must replace the {id}\n    substring with the actual token ID in hex, not prefixed by 0x, and padded\n    to 64 characters in length.\n\n    @return The metadata URI string of the item with ID `_itemId`.\n  */\n  function uri(uint256) external view returns (string memory) {\n    return metadataUri;\n  }\n\n\n  /**\n    Allow the item collection owner or an approved manager to update the\n    metadata URI of this collection. This implementation relies on a single URI\n    for all items within the collection, and as such does not emit the standard\n    URI event. Instead, we emit our own event to reflect changes in the URI.\n\n    @param _uri The new URI to update to.\n  */\n  function setURI(string calldata _uri) external virtual\n    hasValidPermit(UNIVERSAL, SET_URI) {\n    require(!uriLocked,\n      \"Super1155: the collection URI has been permanently locked\");\n    string memory oldURI = metadataUri;\n    metadataUri = _uri;\n    emit ChangeURI(oldURI, _uri);\n  }\n\n  /**\n    Allow approved manager to update the contract URI. At the end of update, we \n    emit our own event to reflect changes in the URI.\n\n    @param _uri The new contract URI to update to.\n  */\n  function setContractUri(string calldata _uri) external virtual\n    hasValidPermit(UNIVERSAL, SET_URI) {\n      require(!contractUriLocked,\n        \"Super1155: the contract URI has been permanently locked\");\n      string memory oldContractUri = contractURI;\n      contractURI = _uri;\n      emit ChangeContractURI(oldContractUri, _uri);\n  }\n\n  /**\n    Allow the item collection owner or an approved manager to update the proxy\n    registry address handling delegated approval.\n\n    @param _proxyRegistryAddress The address of the new proxy registry to\n      update to.\n  */\n  function setProxyRegistry(address _proxyRegistryAddress) external virtual\n    hasValidPermit(UNIVERSAL, SET_PROXY_REGISTRY) {\n    address oldRegistry = proxyRegistryAddress;\n    proxyRegistryAddress = _proxyRegistryAddress;\n    emit ChangeProxyRegistry(oldRegistry, _proxyRegistryAddress);\n  }\n\n  /**\n    Retrieve the balance of a particular token `_id` for a particular address\n    `_owner`.\n\n    @param _owner The owner to check for this token balance.\n    @param _id The ID of the token to check for a balance.\n    @return The amount of token `_id` owned by `_owner`.\n  */\n  function balanceOf(address _owner, uint256 _id) public view virtual\n  returns (uint256) {\n    require(_owner != address(0),\n      \"ERC1155: balance query for the zero address\");\n    return balances[_id][_owner];\n  }\n\n  /**\n    Retrieve in a single call the balances of some mulitple particular token\n    `_ids` held by corresponding `_owners`.\n\n    @param _owners The owners to check for token balances.\n    @param _ids The IDs of tokens to check for balances.\n    @return the amount of each token owned by each owner.\n  */\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\n    external view virtual returns (uint256[] memory) {\n    require(_owners.length == _ids.length,\n      \"ERC1155: accounts and ids length mismatch\");\n\n    // Populate and return an array of balances.\n    uint256[] memory batchBalances = new uint256[](_owners.length);\n    for (uint256 i = 0; i < _owners.length; ++i) {\n      batchBalances[i] = balanceOf(_owners[i], _ids[i]);\n    }\n    return batchBalances;\n  }\n\n  /**\n    This function returns true if `_operator` is approved to transfer items\n    owned by `_owner`. This approval check features an override to explicitly\n    whitelist any addresses delegated in the proxy registry.\n\n    @param _owner The owner of items to check for transfer ability.\n    @param _operator The potential transferrer of `_owner`'s items.\n    @return Whether `_operator` may transfer items owned by `_owner`.\n  */\n  function isApprovedForAll(address _owner, address _operator) public\n    view virtual returns (bool) {\n    if (StubProxyRegistry(proxyRegistryAddress).proxies(_owner) == _operator) {\n      return true;\n    }\n\n    // We did not find an explicit whitelist in the proxy registry.\n    return operatorApprovals[_owner][_operator];\n  }\n\n  /**\n    Enable or disable approval for a third party `_operator` address to manage\n    (transfer or burn) all of the caller's tokens.\n\n    @param _operator The address to grant management rights over all of the\n      caller's tokens.\n    @param _approved The status of the `_operator`'s approval for the caller.\n  */\n  function setApprovalForAll(address _operator, bool _approved) external\n    virtual {\n    require(_msgSender() != _operator,\n      \"ERC1155: setting approval status for self\");\n    operatorApprovals[_msgSender()][_operator] = _approved;\n    emit ApprovalForAll(_msgSender(), _operator, _approved);\n  }\n\n  /**\n    This private helper function converts a number into a single-element array.\n\n    @param _element The element to convert to an array.\n    @return The array containing the single `_element`.\n  */\n  function _asSingletonArray(uint256 _element) private pure\n    returns (uint256[] memory) {\n    uint256[] memory array = new uint256[](1);\n    array[0] = _element;\n    return array;\n  }\n\n  /**\n    An inheritable and configurable pre-transfer hook that can be overridden.\n    It fires before any token transfer, including mints and burns.\n\n    @param _operator The caller who triggers the token transfer.\n    @param _from The address to transfer tokens from.\n    @param _to The address to transfer tokens to.\n    @param _ids The specific token IDs to transfer.\n    @param _amounts The amounts of the specific `_ids` to transfer.\n    @param _data Additional call data to send with this transfer.\n  */\n  function _beforeTokenTransfer(address _operator, address _from, address _to,\n    uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n    internal virtual {\n  }\n\n  /**\n    ERC-1155 dictates that any contract which wishes to receive ERC-1155 tokens\n    must explicitly designate itself as such. This function checks for such\n    designation to prevent undesirable token transfers.\n\n    @param _operator The caller who triggers the token transfer.\n    @param _from The address to transfer tokens from.\n    @param _to The address to transfer tokens to.\n    @param _id The specific token ID to transfer.\n    @param _amount The amount of the specific `_id` to transfer.\n    @param _data Additional call data to send with this transfer.\n  */\n  function _doSafeTransferAcceptanceCheck(address _operator, address _from,\n    address _to, uint256 _id, uint256 _amount, bytes calldata _data) private {\n    if (_to.isContract()) {\n      try IERC1155Receiver(_to).onERC1155Received(_operator, _from, _id,\n        _amount, _data) returns (bytes4 response) {\n        if (response != IERC1155Receiver(_to).onERC1155Received.selector) {\n          revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n        }\n      } catch Error(string memory reason) {\n        revert(reason);\n      } catch {\n        revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n      }\n    }\n  }\n\n  /**\n    The batch equivalent of `_doSafeTransferAcceptanceCheck()`.\n\n    @param _operator The caller who triggers the token transfer.\n    @param _from The address to transfer tokens from.\n    @param _to The address to transfer tokens to.\n    @param _ids The specific token IDs to transfer.\n    @param _amounts The amounts of the specific `_ids` to transfer.\n    @param _data Additional call data to send with this transfer.\n  */\n  function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from,\n    address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory\n    _data) private {\n    if (_to.isContract()) {\n      try IERC1155Receiver(_to).onERC1155BatchReceived(_operator, _from, _ids,\n        _amounts, _data) returns (bytes4 response) {\n        if (response != IERC1155Receiver(_to).onERC1155BatchReceived.selector) {\n          revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n        }\n      } catch Error(string memory reason) {\n        revert(reason);\n      } catch {\n        revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n      }\n    }\n  }\n\n  /**\n    Transfer on behalf of a caller or one of their authorized token managers\n    items from one address to another.\n\n    @param _from The address to transfer tokens from.\n    @param _to The address to transfer tokens to.\n    @param _ids The specific token IDs to transfer.\n    @param _amounts The amounts of the specific `_ids` to transfer.\n    @param _data Additional call data to send with this transfer.\n  */\n  function safeBatchTransferFrom(address _from, address _to,\n    uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n    public virtual {\n    require(_ids.length == _amounts.length,\n      \"ERC1155: ids and amounts length mismatch\");\n    require(_to != address(0),\n      \"ERC1155: transfer to the zero address\");\n    require(_from == _msgSender() || isApprovedForAll(_from, _msgSender()),\n      \"ERC1155: caller is not owner nor approved\");\n\n    // Validate transfer and perform all batch token sends.\n    _beforeTokenTransfer(_msgSender(), _from, _to, _ids, _amounts, _data);\n    for (uint256 i = 0; i < _ids.length; ++i) {\n\n      // Retrieve the item's group ID.\n      uint256 groupId = (_ids[i] & GROUP_MASK) >> 128;\n\n      // Update all specially-tracked group-specific balances.\n      require(balances[_ids[i]][_from] >= _amounts[i], \"ERC1155: insufficient balance for transfer\");\n      balances[_ids[i]][_from] = balances[_ids[i]][_from] - _amounts[i];\n      balances[_ids[i]][_to] = balances[_ids[i]][_to] + _amounts[i];\n      groupBalances[groupId][_from] = groupBalances[groupId][_from] - _amounts[i];\n      groupBalances[groupId][_to] = groupBalances[groupId][_to] + _amounts[i];\n      totalBalances[_from] = totalBalances[_from] - _amounts[i];\n      totalBalances[_to] = totalBalances[_to] + _amounts[i];\n    }\n\n    // Emit the transfer event and perform the safety check.\n    emit TransferBatch(_msgSender(), _from, _to, _ids, _amounts);\n    _doSafeBatchTransferAcceptanceCheck(_msgSender(), _from, _to, _ids,\n      _amounts, _data);\n  }\n\n\n  /**\n    Transfer on behalf of a caller or one of their authorized token managers\n    items from one address to another.\n\n    @param _from The address to transfer tokens from.\n    @param _to The address to transfer tokens to.\n    @param _id The specific token ID to transfer.\n    @param _amount The amount of the specific `_id` to transfer.\n    @param _data Additional call data to send with this transfer.\n  */\n  function safeTransferFrom(address _from, address _to, uint256 _id,\n    uint256 _amount, bytes calldata _data) external  virtual {\n      safeBatchTransferFrom(_from, _to, _asSingletonArray(_id), _asSingletonArray(_amount), _data);\n  }\n\n  /**\n    Create a new NFT item group or configure an existing one. NFTs within a\n    group share a group ID in the upper 128-bits of their full item ID.\n    Within a group NFTs can be distinguished for the purposes of serializing\n    issue numbers.\n\n    @param _groupId The ID of the item group to create or configure.\n    @param _data The `ItemGroup` data input.\n  */\n  function configureGroup(uint256 _groupId, DFStorage.ItemGroupInput calldata _data) external  {\n    require(_groupId != 0,\n      \"Super1155: group ID 0 is invalid\");\n    require(_hasItemRight(_groupId, CONFIGURE_GROUP), \"Super1155: you don't have rights to configure group\");\n\n    // If the collection is not locked, we may add a new item group.\n    if (!itemGroups[_groupId].initialized) {\n      require(!locked,\n        \"Super1155: the collection is locked so groups cannot be created\");\n      itemGroups[_groupId] = ItemGroup({\n        initialized: true,\n        name: _data.name,\n        supplyType: _data.supplyType,\n        supplyData: _data.supplyData,\n        itemType: _data.itemType,\n        itemData: _data.itemData,\n        burnType: _data.burnType,\n        burnData: _data.burnData,\n        circulatingSupply: 0,\n        mintCount: 0,\n        burnCount: 0\n      });\n\n    // Edit an existing item group. The name may always be updated.\n    } else {\n      itemGroups[_groupId].name = _data.name;\n\n      // A capped supply type may not change.\n      // It may also not have its cap increased.\n      if (itemGroups[_groupId].supplyType == DFStorage.SupplyType.Capped) {\n        require(_data.supplyType == DFStorage.SupplyType.Capped,\n          \"Super1155: you may not uncap a capped supply type\");\n        require(_data.supplyData <= itemGroups[_groupId].supplyData,\n          \"Super1155: you may not increase the supply of a capped type\");\n\n      // The flexible and uncapped types may freely change.\n      } else {\n        itemGroups[_groupId].supplyType = _data.supplyType;\n      }\n\n      // Item supply data may not be reduced below the circulating supply.\n      require(_data.supplyData >= itemGroups[_groupId].circulatingSupply,\n        \"Super1155: you may not decrease supply below the circulating amount\");\n      itemGroups[_groupId].supplyData = _data.supplyData;\n\n      // A nonfungible item may not change type.\n      if (itemGroups[_groupId].itemType == DFStorage.ItemType.Nonfungible) {\n        require(_data.itemType == DFStorage.ItemType.Nonfungible,\n          \"Super1155: you may not alter nonfungible items\");\n\n      // A semifungible item may not change type.\n      } else if (itemGroups[_groupId].itemType == DFStorage.ItemType.Semifungible) {\n        require(_data.itemType == DFStorage.ItemType.Semifungible,\n          \"Super1155: you may not alter nonfungible items\");\n\n      // A fungible item may change type if it is unique enough.\n      } else if (itemGroups[_groupId].itemType == DFStorage.ItemType.Fungible) {\n        if (_data.itemType == DFStorage.ItemType.Nonfungible) {\n          require(itemGroups[_groupId].circulatingSupply <= 1,\n            \"Super1155: the fungible item is not unique enough to change\");\n          itemGroups[_groupId].itemType = DFStorage.ItemType.Nonfungible;\n\n        // We may also try for semifungible items with a high-enough cap.\n        } else if (_data.itemType == DFStorage.ItemType.Semifungible) {\n          require(itemGroups[_groupId].circulatingSupply <= _data.itemData,\n            \"Super1155: the fungible item is not unique enough to change\");\n          itemGroups[_groupId].itemType = DFStorage.ItemType.Semifungible;\n          itemGroups[_groupId].itemData = _data.itemData;\n        }\n      }\n    }\n\n    // Emit the configuration event.\n    emit ItemGroupConfigured(_msgSender(), _groupId, _data);\n  }\n\n  /**\n    This is a private helper function to replace the `hasItemRight` modifier\n    that we use on some functions in order to inline this check during batch\n    minting and burning.\n\n    @param _id The ID of the item to check for the given `_right` on.\n    @param _right The right that the caller is trying to exercise on `_id`.\n    @return Whether or not the caller has a valid right on this item.\n  */\n  function _hasItemRight(uint256 _id, bytes32 _right) private view\n    returns (bool) {\n    uint256 groupId = _id  >> 128;\n    if (_msgSender() == owner()) {\n      return true;\n    }\n    if (hasRight(_msgSender(), UNIVERSAL, _right)) {\n      return true;\n    } \n    if (hasRight(_msgSender(), bytes32(groupId), _right)) {\n      return true;\n    }\n    if (hasRight(_msgSender(), bytes32(_id), _right)) {\n      return true;\n    } \n    return false;\n  }\n\n  /**\n    This is a private helper function to verify, according to all of our various\n    minting and burning rules, whether it would be valid to mint some `_amount`\n    of a particular item `_id`.\n\n    @param _id The ID of the item to check for minting validity.\n    @param _amount The amount of the item to try checking mintability for.\n    @return The ID of the item that should have `_amount` minted for it.\n  */\n  function _mintChecker(uint256 _id, uint256 _amount) private view\n    returns (uint256) {\n\n    // Retrieve the item's group ID.\n    uint256 shiftedGroupId = (_id & GROUP_MASK);\n    uint256 groupId = shiftedGroupId >> 128;\n    require(itemGroups[groupId].initialized,\n      \"Super1155: you cannot mint a non-existent item group\");\n\n    // If we can replenish burnt items, then only our currently-circulating\n    // supply matters. Otherwise, historic mints are what determine the cap.\n    uint256 currentGroupSupply = itemGroups[groupId].mintCount;\n    uint256 currentItemSupply = mintCount[_id];\n    if (itemGroups[groupId].burnType == DFStorage.BurnType.Replenishable) {\n      currentGroupSupply = itemGroups[groupId].circulatingSupply;\n      currentItemSupply = circulatingSupply[_id];\n    }\n\n    // If we are subject to a cap on group size, ensure we don't exceed it.\n    if (itemGroups[groupId].supplyType != DFStorage.SupplyType.Uncapped) {\n      require((currentGroupSupply + _amount) <= itemGroups[groupId].supplyData,\n        \"Super1155: you cannot mint a group beyond its cap\");\n    }\n\n    // Do not violate nonfungibility rules.\n    if (itemGroups[groupId].itemType == DFStorage.ItemType.Nonfungible) {\n      require((currentItemSupply + _amount) <= 1,\n        \"Super1155: you cannot mint more than a single nonfungible item\");\n\n    // Do not violate semifungibility rules.\n    } else if (itemGroups[groupId].itemType == DFStorage.ItemType.Semifungible) {\n      require((currentItemSupply + _amount) <= itemGroups[groupId].itemData,\n        \"Super1155: you cannot mint more than the alloted semifungible items\");\n    }\n\n    // Fungible items are coerced into the single group ID + index one slot.\n    uint256 mintedItemId = _id;\n    if (itemGroups[groupId].itemType == DFStorage.ItemType.Fungible) {\n      mintedItemId = shiftedGroupId + 1;\n    }\n    return mintedItemId;\n  }\n\n  /**\n    Mint a batch of tokens into existence and send them to the `_recipient`\n    address. In order to mint an item, its item group must first have been\n    created. Minting an item must obey both the fungibility and size cap of its\n    group.\n\n    @param _recipient The address to receive all NFTs within the newly-minted\n      group.\n    @param _ids The item IDs for the new items to create.\n    @param _amounts The amount of each corresponding item ID to create.\n    @param _data Any associated data to use on items minted in this transaction.\n  */\n  function mintBatch(address _recipient, uint256[] calldata _ids,\n    uint256[] calldata _amounts, bytes calldata _data)\n    external  {\n    require(_recipient != address(0),\n      \"ERC1155: mint to the zero address\");\n    require(_ids.length == _amounts.length,\n      \"ERC1155: ids and amounts length mismatch\");\n\n    // Validate and perform the mint.\n    address operator = _msgSender();\n    _beforeTokenTransfer(operator, address(0), _recipient, _ids, _amounts,\n      _data);\n\n    // Loop through each of the batched IDs to update storage of special\n    // balances and circulation balances.\n    for (uint256 i = 0; i < _ids.length; i++) {\n      require(_hasItemRight(_ids[i], MINT),\n        \"Super1155: you do not have the right to mint that item\");\n\n      // Retrieve the group ID from the given item `_id` and check mint.\n      uint256 groupId = _ids[i] >> 128;\n      uint256 mintedItemId = _mintChecker(_ids[i], _amounts[i]);\n\n      // Update storage of special balances and circulating values.\n      balances[mintedItemId][_recipient] = balances[mintedItemId][_recipient] + _amounts[i];\n      groupBalances[groupId][_recipient] = groupBalances[groupId][_recipient] + _amounts[i];\n      totalBalances[_recipient] = totalBalances[_recipient] + _amounts[i];\n      mintCount[mintedItemId] = mintCount[mintedItemId] + _amounts[i];\n      circulatingSupply[mintedItemId] = circulatingSupply[mintedItemId] + _amounts[i];\n      itemGroups[groupId].mintCount = itemGroups[groupId].mintCount + _amounts[i];\n      itemGroups[groupId].circulatingSupply =\n        itemGroups[groupId].circulatingSupply + _amounts[i];\n    }\n\n    // Emit event and handle the safety check.\n    emit TransferBatch(operator, address(0), _recipient, _ids, _amounts);\n    _doSafeBatchTransferAcceptanceCheck(operator, address(0), _recipient, _ids,\n      _amounts, _data);\n  }\n\n  /**\n    This is a private helper function to verify, according to all of our various\n    minting and burning rules, whether it would be valid to burn some `_amount`\n    of a particular item `_id`.\n\n    @param _id The ID of the item to check for burning validity.\n    @param _amount The amount of the item to try checking burning for.\n    @return The ID of the item that should have `_amount` burnt for it.\n  */\n  function _burnChecker(uint256 _id, uint256 _amount) private view\n    returns (uint256) {\n\n    // Retrieve the item's group ID.\n    uint256 shiftedGroupId = (_id & GROUP_MASK);\n    uint256 groupId = shiftedGroupId >> 128;\n    require(itemGroups[groupId].initialized,\n      \"Super1155: you cannot burn a non-existent item group\");\n\n    // If the item group is non-burnable, then revert.\n    if (itemGroups[groupId].burnType == DFStorage.BurnType.None) {\n      revert(\"Super1155: you cannot burn a non-burnable item group\");\n    }\n\n    // If we can burn items, then we must verify that we do not exceed the cap.\n    if (itemGroups[groupId].burnType == DFStorage.BurnType.Burnable) {\n      require((itemGroups[groupId].burnCount + _amount)\n        <= itemGroups[groupId].burnData,\n        \"Super1155: you may not exceed the burn limit on this item group\");\n    }\n\n    // Fungible items are coerced into the single group ID + index one slot.\n    uint256 burntItemId = _id;\n    if (itemGroups[groupId].itemType == DFStorage.ItemType.Fungible) {\n      burntItemId = shiftedGroupId + 1;\n    }\n    return burntItemId;\n  }\n\n  /**\n    This function allows an address to destroy multiple different items in a\n    single call.\n\n    @param _burner The address whose items are burning.\n    @param _ids The item IDs to burn.\n    @param _amounts The amounts of the corresponding item IDs to burn.\n  */\n  function burnBatch(address _burner, uint256[] memory _ids,\n    uint256[] memory _amounts) public virtual {\n    require(_burner != address(0),\n      \"ERC1155: burn from the zero address\");\n    require(_ids.length == _amounts.length,\n      \"ERC1155: ids and amounts length mismatch\");\n\n    // Validate and perform the burn.\n    address operator = _msgSender();\n    _beforeTokenTransfer(operator, _burner, address(0), _ids, _amounts, \"\");\n\n    // Loop through each of the batched IDs to update storage of special\n    // balances and circulation balances.\n    for (uint i = 0; i < _ids.length; i++) {\n      require(_hasItemRight(_ids[i], BURN),\n        \"Super1155: you do not have the right to burn that item\");\n\n      // Retrieve the group ID from the given item `_id` and check burn.\n      uint256 groupId = _ids[i] >> 128;\n      uint256 burntItemId = _burnChecker(_ids[i], _amounts[i]);\n\n      // Update storage of special balances and circulating values.\n      require(balances[burntItemId][_burner] >= _amounts[i], \"ERC1155: burn amount exceeds balance\");\n      balances[burntItemId][_burner] = balances[burntItemId][_burner] - _amounts[i];\n      groupBalances[groupId][_burner] = groupBalances[groupId][_burner] - _amounts[i];\n      totalBalances[_burner] = totalBalances[_burner] - _amounts[i];\n      burnCount[burntItemId] = burnCount[burntItemId] + _amounts[i];\n      circulatingSupply[burntItemId] = circulatingSupply[burntItemId] - _amounts[i];\n      itemGroups[groupId].burnCount = itemGroups[groupId].burnCount + _amounts[i];\n      itemGroups[groupId].circulatingSupply =\n        itemGroups[groupId].circulatingSupply - _amounts[i];\n    }\n\n    // Emit the burn event.\n    emit TransferBatch(operator, _burner, address(0), _ids, _amounts);\n  }\n\n  /**\n    This function allows an address to destroy some of its items.\n\n    @param _burner The address whose item is burning.\n    @param _id The item ID to burn.\n    @param _amount The amount of the corresponding item ID to burn.\n  */\n  function burn(address _burner, uint256 _id, uint256 _amount) external virtual{\n      require(_hasItemRight(_id, BURN), \"Super1155: you don't have rights to burn\");\n      burnBatch(_burner, _asSingletonArray(_id), _asSingletonArray(_amount));\n  }\n\n  /**\n    Set the on-chain metadata attached to a specific token ID so long as the\n    collection as a whole or the token specifically has not had metadata\n    editing frozen.\n\n    @param _id The ID of the token to set the `_metadata` for.\n    @param _metadata The metadata string to store on-chain.\n  */\n  function setMetadata(uint256 _id, string memory _metadata) external {\n    require(_hasItemRight(_id, SET_METADATA), \"Super1155: you don't have rights to setMetadata\");\n    uint groupId = _id >> 128;\n    require(!uriLocked && !metadataFrozen[_id] &&  !metadataFrozen[groupId],\n      \"Super1155: you cannot edit this metadata because it is frozen\");\n    string memory oldMetadata = metadata[_id];\n    metadata[_id] = _metadata;\n    emit MetadataChanged(_msgSender(), _id, oldMetadata, _metadata);\n  }\n\n  /**\n    Allow the item collection owner or an associated manager to forever lock the\n    metadata URI on the entire collection to future changes.\n  */\n  function lockURI() external\n    hasValidPermit(UNIVERSAL, LOCK_URI) {\n    uriLocked = true;\n    emit PermanentURI(metadataUri, 2 ** 256 - 1);\n  }\n\n  \n  /** \n    Allow the associated manager to forever lock the contract URI to future \n    changes\n  */\n  function lockContractUri() external\n    hasValidPermit(UNIVERSAL, LOCK_URI) {\n    contractUriLocked = true;\n    emit PermanentContractURI(contractURI, 2 ** 256 - 1);   \n  }\n\n  /**\n    Allow the item collection owner or an associated manager to forever lock the\n    metadata URI on an item to future changes.\n\n    @param _uri The value of the URI to lock for `_id`.\n    @param _id The token ID to lock a metadata URI value into.\n  */\n  function lockURI(string calldata _uri, uint256 _id) external {\n    require(_hasItemRight(_id, LOCK_ITEM_URI), \"Super1155: you don't have rights to lock URI\");\n    metadataFrozen[_id] = true;\n    emit PermanentURI(_uri, _id);\n  }\n\n  /**\n    Allow the item collection owner or an associated manager to forever lock the\n    metadata URI on a group of items to future changes.\n\n    @param _uri The value of the URI to lock for `groupId`.\n    @param groupId The group ID to lock a metadata URI value into.\n  */\n  function lockGroupURI(string calldata _uri, uint256 groupId) external {\n    require(_hasItemRight(groupId, LOCK_ITEM_URI), \"Super1155: you don't have rights to lock group URI\");\n    metadataFrozen[groupId] = true;\n    emit PermanentURI(_uri, groupId);\n  }\n\n  /**\n    Allow the item collection owner or an associated manager to forever lock\n    this contract to further item minting.\n  */\n  function lock() external virtual hasValidPermit(UNIVERSAL, LOCK_CREATION) {\n    locked = true;\n    emit CollectionLocked(_msgSender());\n  }\n\n}"
6     },
7     "@openzeppelin/contracts/utils/introspection/ERC165Storage.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Storage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC165.sol\";\n\n/**\n * @dev Storage based implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165Storage is ERC165 {\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
9     },
10     "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
12     },
13     "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
15     },
16     "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
18     },
19     "@openzeppelin/contracts/utils/Address.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
21     },
22     "contracts/access/PermitControl.sol": {
23       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n  @title An advanced permission-management contract.\n  @author Tim Clancy\n\n  This contract allows for a contract owner to delegate specific rights to\n  external addresses. Additionally, these rights can be gated behind certain\n  sets of circumstances and granted expiration times. This is useful for some\n  more finely-grained access control in contracts.\n\n  The owner of this contract is always a fully-permissioned super-administrator.\n\n  August 23rd, 2021.\n*/\nabstract contract PermitControl is Ownable {\n  using Address for address;\n\n  /// A special reserved constant for representing no rights.\n  bytes32 public constant ZERO_RIGHT = hex\"00000000000000000000000000000000\";\n\n  /// A special constant specifying the unique, universal-rights circumstance.\n  bytes32 public constant UNIVERSAL = hex\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\";\n\n  /*\n    A special constant specifying the unique manager right. This right allows an\n    address to freely-manipulate the `managedRight` mapping.\n  **/\n  bytes32 public constant MANAGER = hex\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\";\n\n  /**\n    A mapping of per-address permissions to the circumstances, represented as\n    an additional layer of generic bytes32 data, under which the addresses have\n    various permits. A permit in this sense is represented by a per-circumstance\n    mapping which couples some right, represented as a generic bytes32, to an\n    expiration time wherein the right may no longer be exercised. An expiration\n    time of 0 indicates that there is in fact no permit for the specified\n    address to exercise the specified right under the specified circumstance.\n\n    @dev Universal rights MUST be stored under the 0xFFFFFFFFFFFFFFFFFFFFFFFF...\n    max-integer circumstance. Perpetual rights may be given an expiry time of\n    max-integer.\n  */\n  mapping( address => mapping( bytes32 => mapping( bytes32 => uint256 )))\n    public permissions;\n\n  /**\n    An additional mapping of managed rights to manager rights. This mapping\n    represents the administrator relationship that various rights have with one\n    another. An address with a manager right may freely set permits for that\n    manager right's managed rights. Each right may be managed by only one other\n    right.\n  */\n  mapping( bytes32 => bytes32 ) public managerRight;\n\n  /**\n    An event emitted when an address has a permit updated. This event captures,\n    through its various parameter combinations, the cases of granting a permit,\n    updating the expiration time of a permit, or revoking a permit.\n\n    @param updator The address which has updated the permit.\n    @param updatee The address whose permit was updated.\n    @param circumstance The circumstance wherein the permit was updated.\n    @param role The role which was updated.\n    @param expirationTime The time when the permit expires.\n  */\n  event PermitUpdated(\n    address indexed updator,\n    address indexed updatee,\n    bytes32 circumstance,\n    bytes32 indexed role,\n    uint256 expirationTime\n  );\n\n//   /**\n//     A version of PermitUpdated for work with setPermits() function.\n    \n//     @param updator The address which has updated the permit.\n//     @param updatees The addresses whose permit were updated.\n//     @param circumstances The circumstances wherein the permits were updated.\n//     @param roles The roles which were updated.\n//     @param expirationTimes The times when the permits expire.\n//   */\n//   event PermitsUpdated(\n//     address indexed updator,\n//     address[] indexed updatees,\n//     bytes32[] circumstances,\n//     bytes32[] indexed roles,\n//     uint256[] expirationTimes\n//   );\n\n  /**\n    An event emitted when a management relationship in `managerRight` is\n    updated. This event captures adding and revoking management permissions via\n    observing the update history of the `managerRight` value.\n\n    @param manager The address of the manager performing this update.\n    @param managedRight The right which had its manager updated.\n    @param managerRight The new manager right which was updated to.\n  */\n  event ManagementUpdated(\n    address indexed manager,\n    bytes32 indexed managedRight,\n    bytes32 indexed managerRight\n  );\n\n  /**\n    A modifier which allows only the super-administrative owner or addresses\n    with a specified valid right to perform a call.\n\n    @param _circumstance The circumstance under which to check for the validity\n      of the specified `right`.\n    @param _right The right to validate for the calling address. It must be\n      non-expired and exist within the specified `_circumstance`.\n  */\n  modifier hasValidPermit(\n    bytes32 _circumstance,\n    bytes32 _right\n  ) {\n    require(_msgSender() == owner()\n      || hasRight(_msgSender(), _circumstance, _right),\n      \"P1\");\n    _;\n  }\n\n  /**\n    Return a version number for this contract's interface.\n  */\n  function version() external virtual pure returns (uint256) {\n    return 1;\n  }\n\n  /**\n    Determine whether or not an address has some rights under the given\n    circumstance, and if they do have the right, until when.\n\n    @param _address The address to check for the specified `_right`.\n    @param _circumstance The circumstance to check the specified `_right` for.\n    @param _right The right to check for validity.\n    @return The timestamp in seconds when the `_right` expires. If the timestamp\n      is zero, we can assume that the user never had the right.\n  */\n  function hasRightUntil(\n    address _address,\n    bytes32 _circumstance,\n    bytes32 _right\n  ) public view returns (uint256) {\n    return permissions[_address][_circumstance][_right];\n  }\n\n   /**\n    Determine whether or not an address has some rights under the given\n    circumstance,\n\n    @param _address The address to check for the specified `_right`.\n    @param _circumstance The circumstance to check the specified `_right` for.\n    @param _right The right to check for validity.\n    @return true or false, whether user has rights and time is valid.\n  */\n  function hasRight(\n    address _address,\n    bytes32 _circumstance,\n    bytes32 _right\n  ) public view returns (bool) {\n    return permissions[_address][_circumstance][_right] > block.timestamp;\n  }\n\n  /**\n    Set the permit to a specific address under some circumstances. A permit may\n    only be set by the super-administrative contract owner or an address holding\n    some delegated management permit.\n\n    @param _address The address to assign the specified `_right` to.\n    @param _circumstance The circumstance in which the `_right` is valid.\n    @param _right The specific right to assign.\n    @param _expirationTime The time when the `_right` expires for the provided\n      `_circumstance`.\n  */\n  function setPermit(\n    address _address,\n    bytes32 _circumstance,\n    bytes32 _right,\n    uint256 _expirationTime\n  ) public virtual hasValidPermit(UNIVERSAL, managerRight[_right]) {\n    require(_right != ZERO_RIGHT,\n      \"P2\");\n    permissions[_address][_circumstance][_right] = _expirationTime;\n    emit PermitUpdated(_msgSender(), _address, _circumstance, _right,\n      _expirationTime);\n  }\n\n//   /**\n//     Version of setPermit() that works with multiple addresses in one transaction.\n\n//     @param _addresses The array of addresses to assign the specified `_right` to.\n//     @param _circumstances The array of circumstances in which the `_right` is \n//                           valid.\n//     @param _rights The array of specific rights to assign.\n//     @param _expirationTimes The array of times when the `_rights` expires for \n//                             the provided _circumstance`.\n//   */\n//   function setPermits(\n//     address[] memory _addresses,\n//     bytes32[] memory _circumstances, \n//     bytes32[] memory _rights, \n//     uint256[] memory _expirationTimes\n//   ) public virtual {\n//     require((_addresses.length == _circumstances.length)\n//              && (_circumstances.length == _rights.length)\n//              && (_rights.length == _expirationTimes.length),\n//              \"leghts of input arrays are not equal\"\n//     );\n//     bytes32 lastRight;\n//     for(uint i = 0; i < _rights.length; i++) {\n//       if (lastRight != _rights[i] || (i == 0)) { \n//         require(_msgSender() == owner() || hasRight(_msgSender(), _circumstances[i], _rights[i]), \"P1\");\n//         require(_rights[i] != ZERO_RIGHT, \"P2\");\n//         lastRight = _rights[i];\n//       }\n//       permissions[_addresses[i]][_circumstances[i]][_rights[i]] = _expirationTimes[i];\n//     }\n//     emit PermitsUpdated(\n//       _msgSender(), \n//       _addresses,\n//       _circumstances,\n//       _rights,\n//       _expirationTimes\n//     );\n//   }\n\n  /**\n    Set the `_managerRight` whose `UNIVERSAL` holders may freely manage the\n    specified `_managedRight`.\n\n    @param _managedRight The right which is to have its manager set to\n      `_managerRight`.\n    @param _managerRight The right whose `UNIVERSAL` holders may manage\n      `_managedRight`.\n  */\n  function setManagerRight(\n    bytes32 _managedRight,\n    bytes32 _managerRight\n  ) external virtual hasValidPermit(UNIVERSAL, MANAGER) {\n    require(_managedRight != ZERO_RIGHT,\n      \"P3\");\n    managerRight[_managedRight] = _managerRight;\n    emit ManagementUpdated(_msgSender(), _managedRight, _managerRight);\n  }\n}"
24     },
25     "contracts/proxy/StubProxyRegistry.sol": {
26       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.7;\n\n/**\n  @title A proxy registry contract.\n  @author Protinam, Project Wyvern\n  @author Tim Clancy\n\n  This contract was originally developed by Project Wyvern\n  (https://github.com/ProjectWyvern/) where it currently enjoys great success as\n  a component of the primary exchange contract for OpenSea. It has been modified\n  to support a more modern version of Solidity with associated best practices.\n  The documentation has also been improved to provide more clarity.\n*/\nabstract contract StubProxyRegistry {\n\n  /**\n    This mapping relates an addresses to its own personal `OwnableDelegateProxy`\n    which allow it to proxy functionality to the various callers contained in\n    `authorizedCallers`.\n  */\n  mapping(address => address) public proxies;\n}\n"
27     },
28     "contracts/libraries/DFStorage.sol": {
29       "content": "pragma solidity 0.8.8;\n\nlibrary DFStorage {\n    /**\n    @notice This struct is a source of mapping-free input to the `addPool` function.\n\n    @param name A name for the pool.\n    @param startTime The timestamp when this pool begins allowing purchases.\n    @param endTime The timestamp after which this pool disallows purchases.\n    @param purchaseLimit The maximum number of items a single address may\n      purchase from this pool.\n    @param singlePurchaseLimit The maximum number of items a single address may\n      purchase from this pool in a single transaction.\n    @param requirement A PoolRequirement requisite for users who want to\n      participate in this pool.\n  */\n    struct PoolInput {\n        string name;\n        uint256 startTime;\n        uint256 endTime;\n        uint256 purchaseLimit;\n        uint256 singlePurchaseLimit;\n        PoolRequirement requirement;\n        address collection;\n    }\n\n    /**\n    @notice This enumeration type specifies the different access rules that may be\n    applied to pools in this shop. Access to a pool may be restricted based on\n    the buyer's holdings of either tokens or items.\n\n    @param Public This specifies a pool which requires no special asset holdings\n      to buy from.\n    @param TokenRequired This specifies a pool which requires the buyer to hold\n      some amount of ERC-20 tokens to buy from.\n    @param ItemRequired This specifies a pool which requires the buyer to hold\n      some amount of an ERC-1155 item to buy from.\n    @param PointRequired This specifies a pool which requires the buyer to hold\n      some amount of points in a Staker to buy from.\n  */\n    enum AccessType {\n        Public,\n        TokenRequired,\n        ItemRequired,\n        PointRequired,\n        ItemRequired721\n    }\n\n    /**\n    @notice This struct tracks information about a prerequisite for a user to\n    participate in a pool.\n\n    @param requiredType The `AccessType` being applied to gate buyers from\n      participating in this pool. See `requiredAsset` for how additional data\n      can apply to the access type.\n    @param requiredAsset Some more specific information about the asset to\n      require. If the `requiredType` is `TokenRequired`, we use this address to\n      find the ERC-20 token that we should be specifically requiring holdings\n      of. If the `requiredType` is `ItemRequired`, we use this address to find\n      the item contract that we should be specifically requiring holdings of. If\n      the `requiredType` is `PointRequired`, we treat this address as the\n      address of a Staker contract. Do note that in order for this to work, the\n      Staker must have approved this shop as a point spender.\n    @param requiredAmount The amount of the specified `requiredAsset` required\n      for the buyer to purchase from this pool.\n    @param requiredId The ID of an address whitelist to restrict participants\n      in this pool. To participate, a purchaser must have their address present\n      in the corresponding whitelist. Other requirements from `requiredType`\n      also apply. An ID of 0 is a sentinel value for no whitelist required.\n  */\n    struct PoolRequirement {\n        AccessType requiredType;\n        address[] requiredAsset;\n        uint256 requiredAmount;\n        uint256[] requiredId;\n    }\n\n    /**\n    @notice This enumeration type specifies the different assets that may be used to\n    complete purchases from this mint shop.\n\n    @param Point This specifies that the asset being used to complete\n      this purchase is non-transferrable points from a `Staker` contract.\n    @param Ether This specifies that the asset being used to complete\n      this purchase is native Ether currency.\n    @param Token This specifies that the asset being used to complete\n      this purchase is an ERC-20 token.\n  */\n    enum AssetType {\n        Point,\n        Ether,\n        Token\n    }\n\n    /**\n    @notice This struct tracks information about a single asset with the associated\n    price that an item is being sold in the shop for. It also includes an\n    `asset` field which is used to convey optional additional data about the\n    asset being used to purchase with.\n\n    @param assetType The `AssetType` type of the asset being used to buy.\n    @param asset Some more specific information about the asset to charge in.\n     If the `assetType` is Point, we use this address to find the specific\n     Staker whose points are used as the currency.\n     If the `assetType` is Ether, we ignore this field.\n     If the `assetType` is Token, we use this address to find the\n     ERC-20 token that we should be specifically charging with.\n    @param price The amount of the specified `assetType` and `asset` to charge.\n  */\n    struct Price {\n        AssetType assetType;\n        address asset;\n        uint256 price;\n    }\n  /**\n    This enumeration lists the various supply types that each item group may\n    use. In general, the administrator of this collection or those permissioned\n    to do so may move from a more-permissive supply type to a less-permissive.\n    For example: an uncapped or flexible supply type may be converted to a\n    capped supply type. A capped supply type may not be uncapped later, however.\n\n    @param Capped There exists a fixed cap on the size of the item group. The\n      cap is set by `supplyData`.\n    @param Uncapped There is no cap on the size of the item group. The value of\n      `supplyData` cannot be set below the current circulating supply but is\n      otherwise ignored.\n    @param Flexible There is a cap which can be raised or lowered (down to\n      circulating supply) freely. The value of `supplyData` cannot be set below\n      the current circulating supply and determines the cap.\n  */\n  enum SupplyType {\n    Capped,\n    Uncapped,\n    Flexible\n  }\n\n  /**\n    This enumeration lists the various item types that each item group may use.\n    In general, these are static once chosen.\n\n    @param Nonfungible The item group is truly nonfungible where each ID may be\n      used only once. The value of `itemData` is ignored.\n    @param Fungible The item group is truly fungible and collapses into a single\n      ID. The value of `itemData` is ignored.\n    @param Semifungible The item group may be broken up across multiple\n      repeating token IDs. The value of `itemData` is the cap of any single\n      token ID in the item group.\n  */\n  enum ItemType {\n    Nonfungible,\n    Fungible,\n    Semifungible\n  }\n\n  /**\n    This enumeration lists the various burn types that each item group may use.\n    These are static once chosen.\n\n    @param None The items in this group may not be burnt. The value of\n      `burnData` is ignored.\n    @param Burnable The items in this group may be burnt. The value of\n      `burnData` is the maximum that may be burnt.\n    @param Replenishable The items in this group, once burnt, may be reminted by\n      the owner. The value of `burnData` is ignored.\n  */\n  enum BurnType {\n    None,\n    Burnable,\n    Replenishable\n  }\n\n  /**\n    This struct is a source of mapping-free input to the `configureGroup`\n    function. It defines the settings for a particular item group.\n   \n    @param supplyData An optional integer used by some `supplyType` values.\n    @param itemData An optional integer used by some `itemType` values.\n    @param burnData An optional integer used by some `burnType` values.\n    @param name A name for the item group.\n    @param supplyType The supply type for this group of items.\n    @param itemType The type of item represented by this item group.\n    @param burnType The type of burning permitted by this item group.\n    \n  */\n  struct ItemGroupInput {\n    uint256 supplyData;\n    uint256 itemData;\n    uint256 burnData;\n    SupplyType supplyType;\n    ItemType itemType;\n    BurnType burnType;\n    string name;\n  }\n\n\n  /**\n    This structure is used at the moment of NFT purchase.\n    @param whiteListId Id of a whiteList.\n    @param index Element index in the original array\n    @param allowance The quantity is available to the user for purchase.\n    @param node Base hash of the element.\n    @param merkleProof Proof that the user is on the whitelist.\n  */\n  struct WhiteListInput {\n    uint256 whiteListId;\n    uint256 index; \n    uint256 allowance;\n    bytes32 node; \n    bytes32[] merkleProof;\n  }\n\n\n  /**\n    This structure is used at the moment of NFT purchase.\n    @param _accesslistId Id of a whiteList.\n    @param _merkleRoot Hash root of merkle tree.\n    @param _startTime The start date of the whitelist\n    @param _endTime The end date of the whitelist\n    @param _price The price that applies to the whitelist\n    @param _token Token with which the purchase will be made\n  */\n  struct WhiteListCreate {\n    uint256 _accesslistId;\n    bytes32 _merkleRoot;\n    uint256 _startTime; \n    uint256 _endTime; \n    uint256 _price; \n    address _token;\n  }\n}\n"
30     },
31     "contracts/assets/erc1155/interfaces/ISuper1155.sol": {
32       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.8;\n\nimport \"../../../libraries/DFStorage.sol\";\n\n/**\n  @title An interface for the `Super1155` ERC-1155 item collection contract.\n  @author 0xthrpw\n  @author Tim Clancy\n\n  August 12th, 2021.\n*/\ninterface ISuper1155 {\n\n  /// The public identifier for the right to set this contract's metadata URI.\n  function SET_URI () external view returns (bytes32);\n\n  /// The public identifier for the right to set this contract's proxy registry.\n  function SET_PROXY_REGISTRY () external view returns (bytes32);\n\n  /// The public identifier for the right to configure item groups.\n  function CONFIGURE_GROUP () external view returns (bytes32);\n\n  /// The public identifier for the right to mint items.\n  function MINT () external view returns (bytes32);\n\n  /// The public identifier for the right to burn items.\n  function BURN () external view returns (bytes32);\n\n  /// The public identifier for the right to set item metadata.\n  function SET_METADATA () external view returns (bytes32);\n\n  /// The public identifier for the right to lock the metadata URI.\n  function LOCK_URI () external view returns (bytes32);\n\n  /// The public identifier for the right to lock an item's metadata.\n  function LOCK_ITEM_URI () external view returns (bytes32);\n\n  /// The public identifier for the right to disable item creation.\n  function LOCK_CREATION () external view returns (bytes32);\n\n  /// The public name of this contract.\n  function name () external view returns (string memory);\n\n  /**\n    The ERC-1155 URI for tracking item metadata, supporting {id} substitution.\n    For example: https://token-cdn-domain/{id}.json. See the ERC-1155 spec for\n    more details: https://eips.ethereum.org/EIPS/eip-1155#metadata.\n  */\n  function metadataUri () external view returns (string memory);\n\n  /// A proxy registry address for supporting automatic delegated approval.\n  function proxyRegistryAddress () external view returns (address);\n\n  /// A mapping from each group ID to per-address balances.\n  function groupBalances (uint256, address) external view returns (uint256);\n\n  /// A mapping from each address to a collection-wide balance.\n  function totalBalances (address) external view returns (uint256);\n\n  /// A mapping of data for each item group.\n  // function itemGroups (uint256) external view returns (ItemGroup memory);\n  /* function itemGroups (uint256) external view returns (bool initialized, string memory _name, uint8 supplyType, uint256 supplyData, uint8 itemType, uint256 itemData, uint8 burnType, uint256 burnData, uint256 _circulatingSupply, uint256 _mintCount, uint256 _burnCount); */\n\n  /// A mapping of circulating supplies for each individual token.\n  function circulatingSupply (uint256) external view returns (uint256);\n\n  /// A mapping of the number of times each individual token has been minted.\n  function mintCount (uint256) external view returns (uint256);\n\n  /// A mapping of the number of times each individual token has been burnt.\n  function burnCount (uint256) external view returns (uint256);\n\n  /**\n    A mapping of token ID to a boolean representing whether the item's metadata\n    has been explicitly frozen via a call to `lockURI(string calldata _uri,\n    uint256 _id)`. Do note that it is possible for an item's mapping here to be\n    false while still having frozen metadata if the item collection as a whole\n    has had its `uriLocked` value set to true.\n  */\n  function metadataFrozen (uint256) external view returns (bool);\n\n  /**\n    A public mapping of optional on-chain metadata for each token ID. A token's\n    on-chain metadata is unable to be changed if the item's metadata URI has\n    been permanently fixed or if the collection's metadata URI as a whole has\n    been frozen.\n  */\n  function metadata (uint256) external view returns (string memory);\n\n  /// Whether or not the metadata URI has been locked to future changes.\n  function uriLocked () external view returns (bool);\n\n  /// Whether or not the item collection has been locked to all further minting.\n  function locked () external view returns (bool);\n\n  /**\n    Return a version number for this contract's interface.\n  */\n  function version () external view returns (uint256);\n\n  /**\n    Return the item collection's metadata URI. This implementation returns the\n    same URI for all tokens within the collection and relies on client-side\n    ID substitution per https://eips.ethereum.org/EIPS/eip-1155#metadata. Per\n    said specification, clients calling this function must replace the {id}\n    substring with the actual token ID in hex, not prefixed by 0x, and padded\n    to 64 characters in length.\n\n    @return The metadata URI string of the item with ID `_itemId`.\n  */\n  function uri (uint256) external view returns (string memory);\n\n  /**\n    Allow the item collection owner or an approved manager to update the\n    metadata URI of this collection. This implementation relies on a single URI\n    for all items within the collection, and as such does not emit the standard\n    URI event. Instead, we emit our own event to reflect changes in the URI.\n\n    @param _uri The new URI to update to.\n  */\n  function setURI (string memory _uri) external;\n\n  /**\n    Allow the item collection owner or an approved manager to update the proxy\n    registry address handling delegated approval.\n\n    @param _proxyRegistryAddress The address of the new proxy registry to\n      update to.\n  */\n  function setProxyRegistry (address _proxyRegistryAddress) external;\n\n  /**\n    Retrieve the balance of a particular token `_id` for a particular address\n    `_owner`.\n\n    @param _owner The owner to check for this token balance.\n    @param _id The ID of the token to check for a balance.\n    @return The amount of token `_id` owned by `_owner`.\n  */\n  function balanceOf (address _owner, uint256 _id) external view returns (uint256);\n\n  /**\n    Retrieve in a single call the balances of some mulitple particular token\n    `_ids` held by corresponding `_owners`.\n\n    @param _owners The owners to check for token balances.\n    @param _ids The IDs of tokens to check for balances.\n    @return the amount of each token owned by each owner.\n  */\n  function balanceOfBatch (address[] memory _owners, uint256[] memory _ids) external view returns (uint256[] memory);\n\n  /**\n    This function returns true if `_operator` is approved to transfer items\n    owned by `_owner`. This approval check features an override to explicitly\n    whitelist any addresses delegated in the proxy registry.\n\n    @param _owner The owner of items to check for transfer ability.\n    @param _operator The potential transferrer of `_owner`'s items.\n    @return Whether `_operator` may transfer items owned by `_owner`.\n  */\n  function isApprovedForAll (address _owner, address _operator) external view returns (bool);\n\n  /**\n    Enable or disable approval for a third party `_operator` address to manage\n    (transfer or burn) all of the caller's tokens.\n\n    @param _operator The address to grant management rights over all of the\n      caller's tokens.\n    @param _approved The status of the `_operator`'s approval for the caller.\n  */\n  function setApprovalForAll (address _operator, bool _approved) external;\n\n  /**\n    Transfer on behalf of a caller or one of their authorized token managers\n    items from one address to another.\n\n    @param _from The address to transfer tokens from.\n    @param _to The address to transfer tokens to.\n    @param _id The specific token ID to transfer.\n    @param _amount The amount of the specific `_id` to transfer.\n    @param _data Additional call data to send with this transfer.\n  */\n  function safeTransferFrom (address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data) external;\n\n  /**\n    Transfer on behalf of a caller or one of their authorized token managers\n    items from one address to another.\n\n    @param _from The address to transfer tokens from.\n    @param _to The address to transfer tokens to.\n    @param _ids The specific token IDs to transfer.\n    @param _amounts The amounts of the specific `_ids` to transfer.\n    @param _data Additional call data to send with this transfer.\n  */\n  function safeBatchTransferFrom (address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data) external;\n\n  /**\n    Create a new NFT item group or configure an existing one. NFTs within a\n    group share a group ID in the upper 128-bits of their full item ID.\n    Within a group NFTs can be distinguished for the purposes of serializing\n    issue numbers.\n\n    @param _groupId The ID of the item group to create or configure.\n    @param _data The `ItemGroup` data input.\n  */\n  function configureGroup (uint256 _groupId, DFStorage.ItemGroupInput calldata _data) external;\n\n  /**\n    Mint a batch of tokens into existence and send them to the `_recipient`\n    address. In order to mint an item, its item group must first have been\n    created. Minting an item must obey both the fungibility and size cap of its\n    group.\n\n    @param _recipient The address to receive all NFTs within the newly-minted\n      group.\n    @param _ids The item IDs for the new items to create.\n    @param _amounts The amount of each corresponding item ID to create.\n    @param _data Any associated data to use on items minted in this transaction.\n  */\n  function mintBatch (address _recipient, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data) external;\n\n  /**\n    This function allows an address to destroy some of its items.\n\n    @param _burner The address whose item is burning.\n    @param _id The item ID to burn.\n    @param _amount The amount of the corresponding item ID to burn.\n  */\n  function burn (address _burner, uint256 _id, uint256 _amount) external;\n\n  /**\n    This function allows an address to destroy multiple different items in a\n    single call.\n\n    @param _burner The address whose items are burning.\n    @param _ids The item IDs to burn.\n    @param _amounts The amounts of the corresponding item IDs to burn.\n  */\n  function burnBatch (address _burner, uint256[] memory _ids, uint256[] memory _amounts) external;\n\n  /**\n    Set the on-chain metadata attached to a specific token ID so long as the\n    collection as a whole or the token specifically has not had metadata\n    editing frozen.\n\n    @param _id The ID of the token to set the `_metadata` for.\n    @param _metadata The metadata string to store on-chain.\n  */\n  function setMetadata (uint256 _id, string memory _metadata) external;\n\n  /**\n    Allow the item collection owner or an associated manager to forever lock the\n    metadata URI on the entire collection to future changes.\n\n    @param _uri The value of the URI to lock for `_id`.\n  */\n  function lockURI(string calldata _uri) external;\n\n  /**\n    Allow the item collection owner or an associated manager to forever lock the\n    metadata URI on an item to future changes.\n\n    @param _uri The value of the URI to lock for `_id`.\n    @param _id The token ID to lock a metadata URI value into.\n  */\n  function lockURI(string calldata _uri, uint256 _id) external;\n\n\n  /**\n    Allow the item collection owner or an associated manager to forever lock the\n    metadata URI on a group of items to future changes.\n\n    @param _uri The value of the URI to lock for `groupId`.\n    @param groupId The group ID to lock a metadata URI value into.\n  */\n  function lockGroupURI(string calldata _uri, uint256 groupId) external;\n\n  /**\n    Allow the item collection owner or an associated manager to forever lock\n    this contract to further item minting.\n  */\n  function lock() external;\n}\n"
33     },
34     "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
36     },
37     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
39     },
40     "@openzeppelin/contracts/access/Ownable.sol": {
41       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
42     },
43     "@openzeppelin/contracts/utils/Context.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
45     }
46   },
47   "settings": {
48     "optimizer": {
49       "enabled": true,
50       "runs": 0
51     },
52     "outputSelection": {
53       "*": {
54         "*": [
55           "evm.bytecode",
56           "evm.deployedBytecode",
57           "devdoc",
58           "userdoc",
59           "metadata",
60           "abi"
61         ]
62       }
63     },
64     "libraries": {}
65   }
66 }}