1 {"IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IERC165 {\n\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        external\n        view\n        returns (bool);\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IERC20 {\n\n    function totalSupply()\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(\n        address _account\n    )\n        external\n        view\n        returns (uint256);\n\n    function transfer(\n        address _recipient,\n        uint256 _amount\n    )\n        external\n        returns (bool);\n\n    function approve(\n        address _spender,\n        uint256 _amount\n    )\n        external\n        returns (bool);\n\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    )\n        external\n        returns (bool);\n\n    function decimals()\n        external\n        view\n        returns (uint8);\n}\n"},"IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./IERC165.sol\";\n\ninterface IERC721 is IERC165 {\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function balanceOf(\n        address owner\n    )\n        external\n        view\n        returns (uint256 balance);\n\n    function ownerOf(\n        uint256 tokenId\n    )\n        external\n        view\n        returns (address owner);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    )\n        external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    )\n        external;\n\n    function approve(\n        address to,\n        uint256 tokenId\n    )\n        external;\n\n    function getApproved(\n        uint256 tokenId\n    )\n        external\n        view\n        returns (address operator);\n\n    function setApprovalForAll(\n        address operator,\n        bool _approved\n    )\n        external;\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    )\n        external\n        view\n        returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    )\n        external;\n}\n"},"IMainGame.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IMainGame {\n\n    function getUserFighters(\n        address user\n    )\n        external\n        view\n        returns (\n            uint256[] memory\n        );\n\n    function getUserHero(\n        address user\n    )\n        external\n        view\n        returns (uint256);\n\n    function equip(\n        uint8 item,\n        uint256 id,\n        uint8 slot\n    )\n        external;\n\n    function unequip(\n        uint8 item,\n        uint8 slot\n    )\n        external;\n\n    function enhance(\n        uint8 item,\n        uint8 slot,\n        uint256 burnTokenId\n    )\n        external;\n}\n"},"IRevealContract.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IRevealContract {\n\n    function enhancementCost(\n        uint256\n    )\n        external\n        view\n        returns (\n            uint256,\n            bool\n        );\n\n    function getEnhancementRequest(\n        uint256 tokenId\n    )\n        external\n        view\n        returns (\n            uint256 id,\n            address requester\n        );\n\n    function reveal(\n        uint256[] calldata tokenIds\n    )\n        external;\n}\n\ninterface HeroReveal {\n\n    function getStats(\n        uint256 _heroID\n    )\n        external\n        view\n        returns (\n            uint256 heroDamageMultiplier,\n            uint256 heroPartySize,\n            uint256 heroUpgradeLevel\n        );\n}\n\ninterface FighterReveal {\n\n    function getStats(\n        uint256 _fighterID\n    )\n        external\n        view\n        returns (\n            uint256 fighterDamageValue,\n            uint256 fighterUpgradeLevel\n        );\n}\n"},"ISeeder.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface ISeeder{\n\n    function getBatch()\n        external\n        view\n        returns(uint256);\n\n    function getNextAvailableBatch()\n        external\n        view\n        returns(uint256);\n\n    function getSeedSafe(\n        address origin,\n        uint256 identifier\n    )\n        external\n        view\n        returns(uint256);\n}\n"},"RaidPartyInsurance.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./RaidPartyInsuranceHelper.sol\";\n\n/**\n  * @title Insurance Purchaser\n  * @author René Hochmuth\n  * ฿helper Vitally Marinchenko (vitally.eth)\n  */\ncontract RaidPartyInsurance is RaidPartyInsuranceHelper {\n\n    constructor(\n        address _CONFETTI_TOKEN_ADDRESS,\n        address _MAIN_GAME_CONTRACT_ADDRESS,\n        address _SEEDER_CONTRACT_ADDRESS,\n        address _HERO_CONTRACT_ADDRESS,\n        address _FIGHTER_CONTRACT_ADDRESS,\n        address _REVEAL_HERO_CONTRACT_ADDRESS,\n        address _REVEAL_FIGHTER_CONTRACT_ADDRESS\n    )\n        RaidPartyInsuranceDeclaration(\n            _CONFETTI_TOKEN_ADDRESS,\n            _REVEAL_FIGHTER_CONTRACT_ADDRESS,\n            _MAIN_GAME_CONTRACT_ADDRESS,\n            _SEEDER_CONTRACT_ADDRESS,\n            _HERO_CONTRACT_ADDRESS,\n            _FIGHTER_CONTRACT_ADDRESS,\n            _REVEAL_HERO_CONTRACT_ADDRESS\n        )\n    {\n        masterAddress = msg.sender;\n    }\n\n    function buyInsuranceFighter(\n        uint256 _tokenID,\n        uint256 _fighterPos\n    )\n        registerAllowedCheck\n        external\n    {\n        _buyInsuranceFighter(\n            _tokenID,\n            _fighterPos\n        );\n    }\n\n    function buyInsuranceHero(\n        uint256 _tokenID\n    )\n        registerAllowedCheck\n        external\n    {\n        _buyInsuranceHero(\n            _tokenID\n        );\n    }\n\n    function buyInsuranceFighterBulk(\n        uint256[] calldata _tokenIDs,\n        uint256[] calldata _fighterPositions\n    )\n        external\n    {\n        for (uint i = 0; i \u003c _tokenIDs.length; i++) {\n            _buyInsuranceFighter(\n                _tokenIDs[i],\n                _fighterPositions[i]\n            );\n        }\n    }\n\n    function insuranceClaimHero(\n        uint256 _tokenID\n    )\n        external\n    {\n        _insuranceClaimHero(\n            _tokenID\n        );\n    }\n\n    function insuranceClaimFighter(\n        uint256 _tokenID,\n        uint256 _fighterPos\n    )\n        external\n    {\n        _insuranceClaimFighter(\n            _tokenID,\n            _fighterPos\n        );\n    }\n\n    function insuranceClaimFighterBulk(\n        uint256[] calldata _tokenIDs,\n        uint256[] calldata _fighterPositions\n    )\n        external\n    {\n        for (uint i = 0; i \u003c _tokenIDs.length; i++) {\n            _insuranceClaimFighter(\n                _tokenIDs[i],\n                _fighterPositions[i]\n            );\n        }\n    }\n\n    function addConfettiReserve(\n        uint256 _amount\n    )\n        external\n    {\n        confettiReserves =\n        confettiReserves + _amount;\n\n        confettiToken.transferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n    }\n\n    function addFighterReserve(\n        uint256 _tokenID\n    )\n        external\n    {\n        _addFighterReserve(\n            _tokenID\n        );\n    }\n\n    function addHeroReserve(\n        uint256 _tokenID\n    )\n        external\n    {\n        _addHeroReserve(\n            _tokenID\n        );\n    }\n\n    function addHeroReserveBulk(\n        uint256[] calldata _tokenIDs\n    )\n        external\n    {\n        for (uint256 i = 0; i \u003c _tokenIDs.length; i++) {\n            _addHeroReserve(\n                _tokenIDs[i]\n            );\n        }\n    }\n\n    function addFighterReserveBulk(\n        uint256[] calldata _tokenIDs\n    )\n        external\n    {\n        for (uint256 i = 0; i \u003c _tokenIDs.length; i++) {\n            _addFighterReserve(\n                _tokenIDs[i]\n            );\n        }\n    }\n\n    function withdrawConfettiAdmin(\n        uint256 _amount\n    )\n        onlyMaster\n        external\n    {\n        confettiReserves -= _amount;\n        _determineConfettiCoverageTotal();\n\n        confettiToken.transfer(\n            msg.sender,\n            _amount\n        );\n    }\n\n    function withdrawHeroAdmin()\n        onlyMaster\n        external\n    {\n        _withdrawHeroAdmin();\n    }\n\n    function withdrawHeroAdminBulk(\n        uint256 _heroes\n    )\n        onlyMaster\n        external\n    {\n        for (uint256 i = 0; i \u003c _heroes; i++) {\n            _withdrawHeroAdmin();\n        }\n    }\n\n    function withdrawFighterAdmin()\n        onlyMaster\n        external\n    {\n        _withdrawFighterAdmin();\n    }\n\n    function withdrawFighterAdminBulk(\n        uint256 _fighters\n    )\n        onlyMaster\n        external\n    {\n        for (uint256 i = 0; i \u003c _fighters; i++) {\n            _withdrawFighterAdmin();\n        }\n    }\n\n    function potentialRegisterIDsUserHero(\n        address _user\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 currentHeroID = mainGame.getUserHero(\n            _user\n        );\n\n        (\n            uint256 currentEnhanceCost,\n            uint256 batch\n        ) = (\n            _determineEnhanceCost(\n                REVEAL_HERO_CONTRACT_ADDRESS,\n                currentHeroID\n            ),\n            _getBatch()\n        );\n\n        (uint256 currentRequestID,) = revealHeroContract.getEnhancementRequest(\n            currentHeroID\n        );\n\n        try seeder.getSeedSafe(\n            REVEAL_HERO_CONTRACT_ADDRESS,\n            currentRequestID\n        ) {}\n        catch\n        {\n            if (_conditionCheckHero(batch, currentEnhanceCost, currentHeroID)) {\n                return currentHeroID;\n            }\n        }\n\n        return 0;\n    }\n\n    function getBatch()\n        external\n        view\n        returns (uint256)\n    {\n        return _getBatch();\n    }\n\n    function activeRemainingFighterReserves()\n        external\n        view\n        returns (uint256)\n    {\n        uint256 batch = _getBatch();\n\n        return fighterReserves.length\n            - fighterReservesPerBatch[batch]\n            - fighterReservesPerBatch[batch + 1];\n    }\n\n    function activeRemainingHeroReserves()\n        external\n        view\n        returns (uint256)\n    {\n        uint256 batch = _getBatch();\n\n        return heroReserves.length\n            - heroReservesPerBatch[batch]\n            - heroReservesPerBatch[batch + 1];\n    }\n\n    function potentialRegisterIDsUserFighter(\n        address _user\n    )\n        external\n        view\n        returns (uint256[] memory)\n    {\n        (\n            uint256 length,\n            uint256 currentFighterID,\n            uint256 currentEnhanceCost,\n            uint256 batch,\n            uint256 currentRequestID,\n            uint256 k\n        ) = (\n            mainGame.getUserFighters(_user).length,\n            0,\n            0,\n            _getBatch(),\n            0,\n            0\n        );\n\n        uint256[] memory loadArray = new uint256[](\n            length\n        );\n\n        for (uint256 i = 0; i \u003c length; i++) {\n\n            currentFighterID = mainGame.getUserFighters(_user)[i];\n\n            currentEnhanceCost = _determineEnhanceCost(\n                REVEAL_FIGHTER_CONTRACT_ADDRESS,\n                currentFighterID\n            );\n\n            (\n                currentRequestID,\n            ) = revealFighterContract.getEnhancementRequest(\n                currentFighterID\n            );\n\n            try seeder.getSeedSafe(\n                REVEAL_FIGHTER_CONTRACT_ADDRESS,\n                currentRequestID\n            ) {}\n            catch\n            {\n                if (_conditionCheckFighter(batch, currentFighterID, currentEnhanceCost)) {\n                    loadArray[k] = currentFighterID;\n                    k += 1;\n                }\n            }\n        }\n\n        uint256[] memory returnArray = new uint256[](k);\n\n        for (uint256 index = 0; index \u003c k; index++) {\n            returnArray[index] = loadArray[index];\n        }\n\n        return returnArray;\n    }\n\n    function changeMaster(\n        address _newMaster\n    )\n        onlyMaster\n        external\n    {\n        masterAddress = _newMaster;\n    }\n\n    function enableRegister()\n        onlyMaster\n        external\n    {\n        registerAllowed = true;\n    }\n\n    function disableRegister()\n        onlyMaster\n        external\n    {\n        registerAllowed = false;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    )\n        public\n        pure\n        returns (bytes4)\n    {\n        return this.onERC721Received.selector;\n    }\n\n    function secondsUntilNextBatch()\n        external\n        view\n        returns (\n            uint256 nextBatch,\n            uint256 timeUntil,\n            uint256 timeStamp\n        )\n    {\n        timeStamp = block.timestamp;\n        nextBatch = seeder.getNextAvailableBatch();\n\n        timeUntil = nextBatch \u003e timeStamp\n            ? nextBatch - timeStamp\n            : 0;\n    }\n\n    function getCostsHero(\n        uint256 _heroID\n    )\n        external\n        view\n        returns (\n            uint256 enhanceCostHero,\n            uint256 insuranceCostHero\n        )\n    {\n        enhanceCostHero = _determineEnhanceCost(\n            REVEAL_HERO_CONTRACT_ADDRESS,\n            _heroID\n        );\n\n        insuranceCostHero = insuranceCostHeroByEnhanceCost[\n            enhanceCostHero\n        ];\n    }\n\n    function getCostsFighter(\n        uint256 _fighterID\n    )\n        external\n        view\n        returns (\n            uint256 enhanceCostFighter,\n            uint256 insuranceCostFigther\n        )\n    {\n        enhanceCostFighter = _determineEnhanceCost(\n            REVEAL_FIGHTER_CONTRACT_ADDRESS,\n            _fighterID\n        );\n\n        insuranceCostFigther = insuranceCostFighterByEnhanceCost[\n            enhanceCostFighter\n        ];\n    }\n\n    function getStatsHero(\n        uint256 _heroID\n    )\n        external\n        view\n        returns (\n            uint256 heroDamageMultiplier,\n            uint256 heroPartySize,\n            uint256 heroUpgradeLevel\n        )\n    {\n        return HeroReveal(REVEAL_HERO_CONTRACT_ADDRESS).getStats(\n            _heroID\n        );\n    }\n\n    function getStatsFighter(\n        uint256 _fighterID\n    )\n        external\n        view\n        returns (\n            uint256 fighterDamageValue,\n            uint256 fighterUpgradeLevel\n        )\n    {\n        return FighterReveal(REVEAL_FIGHTER_CONTRACT_ADDRESS).getStats(\n            _fighterID\n        );\n    }\n}\n"},"RaidPartyInsuranceDeclaration.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./IERC20.sol\";\nimport \"./ISeeder.sol\";\nimport \"./IRevealContract.sol\";\nimport \"./IMainGame.sol\";\nimport \"./IERC721.sol\";\n\ncontract RaidPartyInsuranceDeclaration {\n\n    IERC20 public immutable confettiToken;\n    IERC721 public immutable hero;\n    IERC721 public immutable fighter;\n\n    IRevealContract public immutable revealFighterContract;\n    IRevealContract public immutable revealHeroContract;\n    IMainGame public immutable mainGame;\n    ISeeder public immutable seeder;\n\n    address public immutable CONFETTI_TOKEN_ADDRESS;\n    address public immutable REVEAL_FIGHTER_CONTRACT_ADDRESS;\n    address public immutable REVEAL_HERO_CONTRACT_ADDRESS;\n    address public immutable MAIN_GAME_CONTRACT_ADDRESS;\n    address public immutable SEEDER_CONTRACT_ADDRESS;\n    address public immutable HERO_CONTRACT_ADDRESS;\n    address public immutable FIGHTER_CONTRACT_ADDRESS;\n\n    address public masterAddress;\n    uint256 public confettiReserves;\n\n    uint256 constant PRECISION = 10 ** 18;\n    address constant ZERO_ADDRESS = address(0x0);\n\n    uint256 public immutable MAX_FIGHTER_ENHANCECOST;\n    uint256 public immutable MAX_HERO_ENHANCECOST;\n    uint256 public immutable HERO_ENHANCE_RESERVE_NEEDED_CUTOFF;\n\n    uint256[] public heroReserves;\n    uint256[] public fighterReserves;\n\n    bool public registerAllowed = true;\n\n    mapping(uint256 =\u003e uint256) public batchNumberRegisterHero;\n    mapping(uint256 =\u003e uint256) public batchNumberRegisterFighter;\n\n    mapping(uint256 =\u003e uint256) public heroReservesPerBatch;\n    mapping(uint256 =\u003e uint256) public fighterReservesPerBatch;\n\n    mapping(uint256 =\u003e uint256) public lastEnhanceCostHeroByID;\n    mapping(uint256 =\u003e uint256) public lastEnhanceCostFighterByID;\n\n    mapping(uint256 =\u003e uint256) public insuranceCostHeroByEnhanceCost;\n    mapping(uint256 =\u003e uint256) public insuranceCostFighterByEnhanceCost;\n\n    mapping(uint256 =\u003e mapping(uint256 =\u003e bool)) public tokenIDClaimedInBatchHero;\n    mapping(uint256 =\u003e mapping(uint256 =\u003e bool)) public tokenIDClaimedInBatchFighter;\n\n    mapping(uint256 =\u003e uint256) public confettiReservesPerBatch;\n\n    modifier onlyMaster() {\n        require(\n            masterAddress == msg.sender,\n            \"RaidPartyInsurance: ACCESS_DENIED\"\n        );\n        _;\n     }\n\n    modifier registerAllowedCheck() {\n        require(\n            registerAllowed == true,\n            \"RaidPartyInsurance: REGISTER_NOT_ALLOWED\"\n        );\n        _;\n    }\n\n    constructor(\n        address _CONFETTI_TOKEN_ADDRESS,\n        address _REVEAL_FIGHTER_CONTRACT_ADDRESS,\n        address _MAIN_GAME_CONTRACT_ADDRESS,\n        address _SEEDER_CONTRACT_ADDRESS,\n        address _HERO_CONTRACT_ADDRESS,\n        address _FIGHTER_CONTRACT_ADDRESS,\n        address _REVEAL_HERO_CONTRACT_ADDRESS\n    ) {\n        CONFETTI_TOKEN_ADDRESS = _CONFETTI_TOKEN_ADDRESS;\n        REVEAL_FIGHTER_CONTRACT_ADDRESS = _REVEAL_FIGHTER_CONTRACT_ADDRESS;\n        MAIN_GAME_CONTRACT_ADDRESS = _MAIN_GAME_CONTRACT_ADDRESS;\n        SEEDER_CONTRACT_ADDRESS = _SEEDER_CONTRACT_ADDRESS;\n        HERO_CONTRACT_ADDRESS = _HERO_CONTRACT_ADDRESS;\n        FIGHTER_CONTRACT_ADDRESS = _FIGHTER_CONTRACT_ADDRESS;\n        REVEAL_HERO_CONTRACT_ADDRESS = _REVEAL_HERO_CONTRACT_ADDRESS;\n\n        confettiToken = IERC20(\n            CONFETTI_TOKEN_ADDRESS\n        );\n\n        revealFighterContract = IRevealContract(\n            REVEAL_FIGHTER_CONTRACT_ADDRESS\n        );\n\n        revealHeroContract = IRevealContract(\n            REVEAL_HERO_CONTRACT_ADDRESS\n        );\n\n        mainGame = IMainGame(\n            MAIN_GAME_CONTRACT_ADDRESS\n        );\n\n        seeder = ISeeder(\n            SEEDER_CONTRACT_ADDRESS\n        );\n\n        hero = IERC721(\n            HERO_CONTRACT_ADDRESS\n        );\n\n        fighter = IERC721(\n            FIGHTER_CONTRACT_ADDRESS\n        );\n\n        MAX_FIGHTER_ENHANCECOST = 350 * PRECISION;\n        HERO_ENHANCE_RESERVE_NEEDED_CUTOFF = 1250 * PRECISION;\n        MAX_HERO_ENHANCECOST = 2250 * PRECISION;\n\n        insuranceCostFighterByEnhanceCost[25 * PRECISION] = 25 * PRECISION;\n        insuranceCostFighterByEnhanceCost[35 * PRECISION] = 34 * PRECISION;\n        insuranceCostFighterByEnhanceCost[50 * PRECISION] = 45 * PRECISION;\n        insuranceCostFighterByEnhanceCost[75 * PRECISION] = 61 * PRECISION;\n        insuranceCostFighterByEnhanceCost[100 * PRECISION] = 80 * PRECISION;\n        insuranceCostFighterByEnhanceCost[125 * PRECISION] = 101 * PRECISION;\n        insuranceCostFighterByEnhanceCost[150 * PRECISION] = 125 * PRECISION;\n        insuranceCostFighterByEnhanceCost[300 * PRECISION] = 220 * PRECISION;\n        insuranceCostFighterByEnhanceCost[350 * PRECISION] = 270 * PRECISION;\n\n        insuranceCostHeroByEnhanceCost[250 * PRECISION] = 50 * PRECISION;\n        insuranceCostHeroByEnhanceCost[500 * PRECISION] = 125 * PRECISION;\n        insuranceCostHeroByEnhanceCost[750 * PRECISION] = 225 * PRECISION;\n        insuranceCostHeroByEnhanceCost[1000 * PRECISION] = 350 * PRECISION;\n        insuranceCostHeroByEnhanceCost[1250 * PRECISION] = 1100 * PRECISION;\n        insuranceCostHeroByEnhanceCost[1500 * PRECISION] = 1350 * PRECISION;\n        insuranceCostHeroByEnhanceCost[1750 * PRECISION] = 1625 * PRECISION;\n        insuranceCostHeroByEnhanceCost[2000 * PRECISION] = 1925 * PRECISION;\n        insuranceCostHeroByEnhanceCost[2250 * PRECISION] = 2250 * PRECISION;\n    }\n}\n"},"RaidPartyInsuranceEvents.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ncontract RaidPartyInsuranceEvents {\n\n    event insurancePurchased(\n        uint256 indexed tokenID,\n        address indexed user,\n        bool isFighter,\n        uint256 enhanceCost,\n        uint256 indexed batch,\n        uint256 cost\n    );\n\n    event insuranceClaimed(\n        uint256 indexed tokenID,\n        uint256 indexed batch,\n        address indexed user,\n        bool isFighter,\n        bool nftCompensation,\n        uint256 tokensClaimed\n    );\n\n    event PassedBatchCheck(\n        uint256[] tokenIDs\n    );\n}\n"},"RaidPartyInsuranceHelper.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./RaidPartyInsuranceDeclaration.sol\";\nimport \"./RaidPartyInsuranceEvents.sol\";\n\nabstract contract RaidPartyInsuranceHelper is\n    RaidPartyInsuranceDeclaration,\n    RaidPartyInsuranceEvents\n{\n    function _buyInsuranceFighter(\n        uint256 _tokenID,\n        uint256 _fighterPos\n    )\n        internal\n    {\n        uint256[] memory tokenIDarray = new uint256[](1);\n        tokenIDarray[0] = _tokenID;\n\n        (\n            uint256 batch,\n            uint256 nextBatch\n        ) = _getBatches();\n\n        require(\n            _checkPendingRevealFighter(_tokenID) == true,\n            \"RaidPartyInsuranceHelper: NO_PENDING_REVEAL\"\n        );\n\n        _sameBatchCheck(\n            REVEAL_FIGHTER_CONTRACT_ADDRESS,\n            tokenIDarray\n        );\n\n        _checkIfInMainGameFighter(\n            _tokenID,\n            _fighterPos,\n            msg.sender\n        );\n\n        require(\n            batchNumberRegisterFighter[_tokenID] \u003c batch,\n            \"RaidPartyInsuranceHelper: ALREADY_REGISTERED\"\n        );\n\n        batchNumberRegisterFighter[_tokenID] = batch;\n\n        uint256 enhanceCost = _determineEnhanceCost(\n            REVEAL_FIGHTER_CONTRACT_ADDRESS,\n            _tokenID\n        );\n\n        require(\n            enhanceCost \u003c= MAX_FIGHTER_ENHANCECOST,\n            \"RaidPartyInsuranceHelper: LEVEL_TOO_HIGH\"\n        );\n\n        lastEnhanceCostFighterByID[_tokenID] = enhanceCost;\n\n        fighterReservesPerBatch[nextBatch] += 1;\n        confettiReservesPerBatch[nextBatch] += enhanceCost;\n\n        uint256 insuranceCost = insuranceCostFighterByEnhanceCost[enhanceCost];\n\n        confettiReserves += insuranceCost;\n\n        _determineConfettiCoverageTotal();\n        _determineReserveCoverageTotalFighter();\n\n        confettiToken.transferFrom(\n            msg.sender,\n            address(this),\n            insuranceCost\n        );\n\n        emit insurancePurchased(\n            _tokenID,\n            msg.sender,\n            true,\n            enhanceCost,\n            batch,\n            insuranceCost\n        );\n    }\n\n    function _buyInsuranceHero(\n        uint256 _tokenID\n    )\n        internal\n    {\n        (\n            uint256 batch,\n            uint256 nextBatch\n        ) = _getBatches();\n\n        uint256[] memory tokenIDarray = new uint256[](1);\n        tokenIDarray[0] = _tokenID;\n\n        require(\n            _checkPendingRevealHero(_tokenID) == true,\n            \"RaidPartyInsuranceHelper: NO_PENDING_REVEAL\"\n        );\n\n        _sameBatchCheck(\n            REVEAL_HERO_CONTRACT_ADDRESS,\n            tokenIDarray\n        );\n\n        _checkIfInMainGameHero(\n            _tokenID,\n            msg.sender\n        );\n\n        _checkDblRegisterHero(\n            batch,\n            _tokenID\n        );\n\n        batchNumberRegisterHero[_tokenID] = batch;\n\n        uint256 enhanceCost = _determineEnhanceCost(\n            REVEAL_HERO_CONTRACT_ADDRESS,\n            _tokenID\n        );\n\n        require(\n            enhanceCost \u003c= MAX_HERO_ENHANCECOST,\n            \"RaidPartyInsuranceHelper: LEVEL_TOO_HIGH\"\n        );\n\n        lastEnhanceCostHeroByID[_tokenID] = enhanceCost;\n\n        confettiReservesPerBatch[nextBatch] =\n        confettiReservesPerBatch[nextBatch] + enhanceCost;\n\n        uint256 insuranceCost = insuranceCostHeroByEnhanceCost[enhanceCost];\n\n        confettiReserves =\n        confettiReserves + insuranceCost;\n\n        _determineConfettiCoverageTotal();\n\n        if (enhanceCost \u003e= HERO_ENHANCE_RESERVE_NEEDED_CUTOFF) {\n            heroReservesPerBatch[nextBatch] += 1;\n            _determineReserveCoverageTotalHero();\n        }\n\n        confettiToken.transferFrom(\n            msg.sender,\n            address(this),\n            insuranceCost\n        );\n\n        emit insurancePurchased(\n            _tokenID,\n            msg.sender,\n            false,\n            enhanceCost,\n            batch,\n            insuranceCost\n        );\n    }\n\n    function _addFighterReserve(\n        uint256 _tokenID\n    )\n        internal\n    {\n        fighterReserves.push(\n            _tokenID\n        );\n\n        fighter.safeTransferFrom(\n            msg.sender,\n            address(this),\n            _tokenID\n        );\n    }\n\n    function _addHeroReserve(\n        uint256 _tokenID\n    )\n        internal\n    {\n        heroReserves.push(\n            _tokenID\n        );\n\n        hero.safeTransferFrom(\n            msg.sender,\n            address(this),\n            _tokenID\n        );\n    }\n\n    function _insuranceClaimHero(\n        uint256 _tokenID\n    )\n        internal\n    {\n        uint256 batch = _getBatch();\n\n        uint256[] memory tokenIDarray = new uint256[](1);\n        tokenIDarray[0] = _tokenID;\n\n        require(\n            batchNumberRegisterHero[_tokenID] + 1 == batch,\n            \"RaidPartyInsuranceHelper: WRONG_BATCH\"\n        );\n\n        _checkIfInMainGameHero(\n            _tokenID,\n            msg.sender\n        );\n\n        require(\n            tokenIDClaimedInBatchHero[_tokenID][batch] == false,\n            \"RaidPartyInsuranceHelper: ALREADY_CLAIMED\"\n        );\n\n        if (_checkPendingRevealHero(_tokenID) == true) {\n\n            revealHeroContract.reveal(\n                tokenIDarray\n            );\n        }\n\n        uint256 enhanceCost = _determineEnhanceCost(\n            REVEAL_HERO_CONTRACT_ADDRESS,\n            _tokenID\n        );\n\n        uint256 previousEnhanceCost = lastEnhanceCostHeroByID[_tokenID];\n\n        if (enhanceCost \u003e previousEnhanceCost) {\n\n            emit insuranceClaimed(\n                _tokenID,\n                batch,\n                msg.sender,\n                false,\n                false,\n                0\n            );\n\n            return;\n        }\n\n        tokenIDClaimedInBatchHero[_tokenID][batch] = true;\n        confettiReservesPerBatch[batch] -= previousEnhanceCost;\n        confettiReserves -= previousEnhanceCost;\n\n        bool nftCompensation = previousEnhanceCost \u003e= HERO_ENHANCE_RESERVE_NEEDED_CUTOFF;\n\n        if (nftCompensation == true) {\n            heroReservesPerBatch[batch] -= 1;\n            hero.safeTransferFrom(\n                address(this),\n                msg.sender,\n                _adjustHeroReserveArray()\n            );\n        }\n\n        confettiToken.transfer(\n            msg.sender,\n            previousEnhanceCost\n        );\n\n        emit insuranceClaimed(\n            _tokenID,\n            batch,\n            msg.sender,\n            false,\n            nftCompensation,\n            previousEnhanceCost\n        );\n    }\n\n    function _insuranceClaimFighter(\n        uint256 _tokenID,\n        uint256 _fighterPos\n    )\n        internal\n    {\n        uint256 batch = _getBatch();\n\n        uint256[] memory tokenIDarray = new uint256[](1);\n        tokenIDarray[0] = _tokenID;\n\n        require(\n            batchNumberRegisterFighter[_tokenID] + 1 == batch,\n            \"RaidPartyInsuranceHelper: WRONG_BATCH\"\n        );\n\n        _checkIfInMainGameFighter(\n            _tokenID,\n            _fighterPos,\n            msg.sender\n        );\n\n        require(\n            tokenIDClaimedInBatchFighter[_tokenID][batch] == false,\n            \"RaidPartyInsuranceHelper: ALREADY_CLAIMED\"\n        );\n\n        if (_checkPendingRevealFighter(_tokenID) == true) {\n            revealFighterContract.reveal(tokenIDarray);\n        }\n\n        uint256 enhanceCost = _determineEnhanceCost(\n            REVEAL_FIGHTER_CONTRACT_ADDRESS,\n            _tokenID\n        );\n\n        uint256 previousEnhanceCost = lastEnhanceCostFighterByID[_tokenID];\n\n        if (enhanceCost \u003e previousEnhanceCost) {\n\n            emit insuranceClaimed(\n                _tokenID,\n                batch,\n                msg.sender,\n                true,\n                false,\n                0\n            );\n\n            return;\n        }\n\n        tokenIDClaimedInBatchFighter[_tokenID][batch] = true;\n        confettiReservesPerBatch[batch] -= previousEnhanceCost;\n        fighterReservesPerBatch[batch] -= 1;\n        confettiReserves -= previousEnhanceCost;\n\n        confettiToken.transfer(\n            msg.sender,\n            previousEnhanceCost\n        );\n\n        fighter.safeTransferFrom(\n            address(this),\n            msg.sender,\n            _adjustFighterReserveArray()\n        );\n\n        emit insuranceClaimed(\n            _tokenID,\n            batch,\n            msg.sender,\n            true,\n            true,\n            previousEnhanceCost\n        );\n    }\n\n    function _withdrawHeroAdmin()\n        internal\n    {\n        uint256 lastTokenID = _adjustHeroReserveArray();\n        _determineReserveCoverageTotalHero();\n\n        hero.safeTransferFrom(\n            address(this),\n            msg.sender,\n            lastTokenID\n        );\n    }\n\n    function _withdrawFighterAdmin()\n        internal\n    {\n        uint256 lastTokenID = _adjustFighterReserveArray();\n        _determineReserveCoverageTotalFighter();\n\n        fighter.safeTransferFrom(\n            address(this),\n            msg.sender,\n            lastTokenID\n        );\n    }\n\n    function _sameBatchCheck(\n        address _toCall,\n        uint256[] memory _tokenIDs\n    )\n        internal\n    {\n        try IRevealContract(_toCall).reveal(\n            _tokenIDs\n        )\n        {\n            revert(\n                \"RaidPartyInsuranceHelper: NOT_SAME_BATCH\"\n            );\n        }\n        catch\n        {\n            emit PassedBatchCheck(\n                _tokenIDs\n            );\n        }\n    }\n\n    function _checkDblRegisterHero(\n        uint256 _batch,\n        uint256 _tokenID\n    )\n        internal\n        view\n    {\n        require(\n            batchNumberRegisterHero[_tokenID] \u003c _batch,\n            \"RaidPartyInsuranceHelper: ALREADY_REGISTERED\"\n        );\n    }\n\n    function _getBatch()\n        internal\n        view\n        returns (uint256)\n    {\n        return seeder.getBatch();\n    }\n\n    function _getBatches()\n        internal\n        view\n        returns (\n            uint256 batch,\n            uint256 nextBatch\n        )\n    {\n        batch = _getBatch();\n        nextBatch = batch + 1;\n    }\n\n    function _checkIfInMainGameFighter(\n        uint256 _tokenID,\n        uint256 _fighterPos,\n        address _user\n    )\n        internal\n        view\n    {\n        require(\n            mainGame.getUserFighters(_user)[_fighterPos] == _tokenID,\n            \"RaidPartyInsuranceHelper: WRONG_TOKEN_ID\"\n        );\n    }\n\n    function _checkIfInMainGameHero(\n        uint256 _tokenID,\n        address _user\n    )\n        internal\n        view\n    {\n        require(\n            mainGame.getUserHero(_user) == _tokenID,\n            \"RaidPartyInsuranceHelper: WRONG_TOKEN_ID\"\n        );\n    }\n\n    function _determineEnhanceCost(\n        address _toCall,\n        uint256 _tokenID\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            uint256 enhanceCost,\n        ) = IRevealContract(_toCall).enhancementCost(\n            _tokenID\n        );\n\n        return enhanceCost;\n    }\n\n    function _determineReserveCoverageFighter(\n        uint256 _fighterCount\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return fighterReserves.length \u003e= _fighterCount;\n    }\n\n    function _determineReserveCoverageHero(\n        uint256 _heroCount\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return heroReserves.length \u003e= _heroCount;\n    }\n\n    function _determineReserveCoverageTotalFighter()\n        internal\n        view\n        returns (bool)\n    {\n        uint256 batch = _getBatch();\n        uint256 nextBatch = batch + 1;\n\n        uint256 requiredTotal =\n            fighterReservesPerBatch[batch] +\n            fighterReservesPerBatch[nextBatch];\n\n        require(\n            _determineReserveCoverageFighter(requiredTotal) == true,\n            \"RaidPartyInsuranceHelper: VIOLATES_COVERAGE_FIGHTER\"\n        );\n\n        return true;\n    }\n\n    function _determineReserveCoverageTotalHero()\n        internal\n        view\n        returns (bool)\n    {\n        (\n            uint256 batch,\n            uint256 nextBatch\n        ) = _getBatches();\n\n        uint256 requiredTotal =\n            heroReservesPerBatch[batch] +\n            heroReservesPerBatch[nextBatch];\n\n        require(\n            _determineReserveCoverageHero(requiredTotal) == true,\n            \"RaidPartyInsuranceHelper: VIOLATES_COVERAGE_HERO\"\n        );\n\n        return true;\n    }\n\n    function _determineConfettiCoverage(\n        uint256 _confettiAmount\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return confettiReserves \u003e= _confettiAmount;\n    }\n\n    function _determineConfettiCoverageTotal()\n        internal\n        view\n        returns (bool)\n    {\n        (\n            uint256 batch,\n            uint256 nextBatch\n        ) = _getBatches();\n\n        uint256 requiredTotal =\n            confettiReservesPerBatch[batch] +\n            confettiReservesPerBatch[nextBatch];\n\n        require(\n            _determineConfettiCoverage(requiredTotal) == true,\n            \"RaidPartyInsuranceHelper: VIOLATES_COVERAGE_CONFETII\"\n        );\n\n        return true;\n    }\n\n    function _adjustHeroReserveArray()\n        internal\n        returns (uint256)\n    {\n        uint256 lastIndex = heroReserves.length - 1;\n        uint256 lastTokenID = heroReserves[lastIndex];\n\n        heroReserves.pop();\n        return lastTokenID;\n    }\n\n    function _adjustFighterReserveArray()\n        internal\n        returns (uint256)\n    {\n        uint256 lastIndex = fighterReserves.length - 1;\n        uint256 lastTokenID = fighterReserves[lastIndex];\n\n        fighterReserves.pop();\n        return lastTokenID;\n    }\n\n    function _checkPendingRevealFighter(\n        uint256 _tokenID\n    )\n        internal\n        view\n        returns (bool)\n    {\n        (\n            ,\n            address enhancer\n        ) = revealFighterContract.getEnhancementRequest(\n            _tokenID\n        );\n\n        return enhancer \u003e ZERO_ADDRESS;\n    }\n\n    function _checkPendingRevealHero(\n        uint256 _tokenID\n    )\n        internal\n        view\n        returns (bool)\n    {\n        (\n            ,\n            address enhancer\n        ) = revealHeroContract.getEnhancementRequest(\n            _tokenID\n        );\n\n        return enhancer \u003e ZERO_ADDRESS;\n    }\n\n    function _conditionCheckFighter(\n        uint256 _batch,\n        uint256 _currentFighterID,\n        uint256 _currentEnhanceCost\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return _currentEnhanceCost \u003c MAX_FIGHTER_ENHANCECOST\n            \u0026\u0026 _checkPendingRevealFighter(_currentFighterID)\n            \u0026\u0026 batchNumberRegisterFighter[_currentFighterID] \u003c _batch;\n    }\n\n    function _conditionCheckHero(\n        uint256 _batch,\n        uint256 _currentEnhanceCost,\n        uint256 _currentHeroID\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return _currentEnhanceCost \u003c MAX_HERO_ENHANCECOST\n            \u0026\u0026 _checkPendingRevealHero(_currentHeroID)\n            \u0026\u0026 batchNumberRegisterHero[_currentHeroID] \u003c _batch;\n    }\n}\n"}}