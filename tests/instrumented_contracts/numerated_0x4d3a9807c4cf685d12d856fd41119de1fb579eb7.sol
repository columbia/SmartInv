1 {"PrimaryCoin.sol":{"content":"pragma solidity  ^0.5.7;\r\n\r\nimport \"./Primary_Libs.sol\";\r\nimport \"./Primary_General.sol\";\r\nimport \"./Primary_IERC20.sol\";\r\nimport \"./Primary_ERC20.sol\";\r\n\r\ncontract PrimaryCoin is Identity, ERC20, ERC20Pausable, ERC20Burnable, ERC20Detailed, UniformTokenGrantor \r\n{\r\n    uint32 public constant VERSION = 3;\r\n    uint8 private constant DECIMALS = 10;\r\n//    uint256 private constant TOKEN_WEI = 10 ** uint256(DECIMALS);\r\n//    uint256 private constant INITIAL_WHOLE_TOKENS = uint256(1 * (10 ** 8));\r\n//    uint256 private constant INITIAL_SUPPLY = uint256(INITIAL_WHOLE_TOKENS) * uint256(TOKEN_WEI);\r\n \t  uint256 private constant INITIAL_SUPPLY = 10000000000000000000;\r\n\r\n    constructor () ERC20Detailed(\"Primary\", \"PRIMARY\", DECIMALS) public {\r\n        // This is the only place where we ever mint tokens.\r\n        _mint(msg.sender, INITIAL_SUPPLY);\r\n    }\r\n\r\n    event DepositReceived(address indexed from, uint256 value);\r\n\r\n    function() payable external {\r\n        emit DepositReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    function burn(uint256 value) onlyIfFundsAvailableNow(msg.sender, value) public {\r\n        _burn(msg.sender, value);\r\n    }\r\n\r\n    function kill() whenPaused onlyPauser public returns (bool itsDeadJim) {\r\n        require(isPauser(msg.sender), \"onlyPauser\");\r\n        address payable payableOwner = address(uint160(owner()));\r\n        selfdestruct(payableOwner);\r\n        return true;\r\n    }\r\n}\r\n"},"Primary_ERC20.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Primary_Libs.sol\";\nimport \"./Primary_General.sol\";\nimport \"./Primary_IERC20.sol\";\n\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n     function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\ncontract ERC20Burnable is Context, ERC20 {\n\n    function burn(uint256 amount) public {\n        _burn(_msgSender(), amount);\n    }\n\n    function burnFrom(address account, uint256 amount) public {\n        _burnFrom(account, amount);\n    }\n}\n\ncontract ERC20Pausable is ERC20, Pausable {\n    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n        return super.approve(spender, value);\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {\n        return super.increaseAllowance(spender, addedValue);\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {\n        return super.decreaseAllowance(spender, subtractedValue);\n    }\n}\n\ncontract VerifiedAccount is ERC20, Ownable {\n\n    mapping(address =\u003e bool) private _isRegistered;\n\n    constructor () internal {\n        registerAccount();\n    }\n\n    event AccountRegistered(address indexed account);\n\n    function registerAccount() public returns (bool ok) {\n        _isRegistered[msg.sender] = true;\n        emit AccountRegistered(msg.sender);\n        return true;\n    }\n\n    function isRegistered(address account) public view returns (bool ok) {\n        return _isRegistered[account];\n    }\n\n    function _accountExists(address account) internal view returns (bool exists) {\n        return account == msg.sender || _isRegistered[account];\n    }\n\n    modifier onlyExistingAccount(address account) {\n        require(_accountExists(account), \"account not registered\");\n        _;\n    }\n\n    function safeTransfer(address to, uint256 value) public onlyExistingAccount(to) returns (bool ok) {\n        transfer(to, value);\n        return true;\n    }\n\n    function safeApprove(address spender, uint256 value) public onlyExistingAccount(spender) returns (bool ok) {\n        approve(spender, value);\n        return true;\n    }\n\n    function safeTransferFrom(address from, address to, uint256 value) public onlyExistingAccount(to) returns (bool ok) {\n        transferFrom(from, to, value);\n        return true;\n    }\n\n    function transferOwnership(address newOwner) public onlyExistingAccount(newOwner) onlyOwner {\n        super.transferOwnership(newOwner);\n    }\n}\n\n\ncontract ERC20Vestable is ERC20, VerifiedAccount, GrantorRole, IERC20Vestable {\n    using SafeMath for uint256;\n\n    uint32 private constant THOUSAND_YEARS_DAYS = 365243;                   /* See https://www.timeanddate.com/date/durationresult.html?m1=1\u0026d1=1\u0026y1=2000\u0026m2=1\u0026d2=1\u0026y2=3000 */\n    uint32 private constant TEN_YEARS_DAYS = THOUSAND_YEARS_DAYS / 100;     /* Includes leap years (though it doesn\u0027t really matter) */\n    uint32 private constant SECONDS_PER_DAY = 24 * 60 * 60;                 /* 86400 seconds in a day */\n    uint32 private constant JAN_1_2000_SECONDS = 946684800;                 /* Saturday, January 1, 2000 0:00:00 (GMT) (see https://www.epochconverter.com/) */\n    uint32 private constant JAN_1_2000_DAYS = JAN_1_2000_SECONDS / SECONDS_PER_DAY;\n    uint32 private constant JAN_1_3000_DAYS = JAN_1_2000_DAYS + THOUSAND_YEARS_DAYS;\n\n    struct vestingSchedule {\n        bool isValid;               /* true if an entry exists and is valid */\n        bool isRevocable;           /* true if the vesting option is revocable (a gift), false if irrevocable (purchased) */\n        uint32 cliffDuration;       /* Duration of the cliff, with respect to the grant start day, in days. */\n        uint32 duration;            /* Duration of the vesting schedule, with respect to the grant start day, in days. */\n        uint32 interval;            /* Duration in days of the vesting interval. */\n    }\n\n    struct tokenGrant {\n        bool isActive;              /* true if this vesting entry is active and in-effect entry. */\n        bool wasRevoked;            /* true if this vesting schedule was revoked. */\n        uint32 startDay;            /* Start day of the grant, in days since the UNIX epoch (start of day). */\n        uint256 amount;             /* Total number of tokens that vest. */\n        address vestingLocation;    /* Address of wallet that is holding the vesting schedule. */\n        address grantor;            /* Grantor that made the grant */\n    }\n\n    mapping(address =\u003e vestingSchedule) private _vestingSchedules;\n    mapping(address =\u003e tokenGrant) private _tokenGrants;\n\n\n\n    function _setVestingSchedule(\n        address vestingLocation,\n        uint32 cliffDuration, uint32 duration, uint32 interval,\n        bool isRevocable) internal returns (bool ok) {\n\n        require(\n            duration \u003e 0 \u0026\u0026 duration \u003c= TEN_YEARS_DAYS\n            \u0026\u0026 cliffDuration \u003c duration\n            \u0026\u0026 interval \u003e= 1,\n            \"invalid vesting schedule\"\n        );\n\n        require(\n            duration % interval == 0 \u0026\u0026 cliffDuration % interval == 0,\n            \"invalid cliff/duration for interval\"\n        );\n\n        _vestingSchedules[vestingLocation] = vestingSchedule(\n            true/*isValid*/,\n            isRevocable,\n            cliffDuration, duration, interval\n        );\n\n        emit VestingScheduleCreated(\n            vestingLocation,\n            cliffDuration, duration, interval,\n            isRevocable);\n        return true;\n    }\n\n    function _hasVestingSchedule(address account) internal view returns (bool ok) {\n        return _vestingSchedules[account].isValid;\n    }\n\n    function getIntrinsicVestingSchedule(address grantHolder)\n    public\n    view\n    onlyGrantorOrSelf(grantHolder)\n    returns (\n        uint32 vestDuration,\n        uint32 cliffDuration,\n        uint32 vestIntervalDays\n    )\n    {\n        return (\n        _vestingSchedules[grantHolder].duration,\n        _vestingSchedules[grantHolder].cliffDuration,\n        _vestingSchedules[grantHolder].interval\n        );\n    }\n\n    function _grantVestingTokens(\n        address beneficiary,\n        uint256 totalAmount,\n        uint256 vestingAmount,\n        uint32 startDay,\n        address vestingLocation,\n        address grantor\n    )\n    internal returns (bool ok)\n    {\n        require(!_tokenGrants[beneficiary].isActive, \"grant already exists\");\n\n        require(\n            vestingAmount \u003c= totalAmount \u0026\u0026 vestingAmount \u003e 0\n            \u0026\u0026 startDay \u003e= JAN_1_2000_DAYS \u0026\u0026 startDay \u003c JAN_1_3000_DAYS,\n            \"invalid vesting params\");\n\n        require(_hasVestingSchedule(vestingLocation), \"no such vesting schedule\");\n\n        _transfer(grantor, beneficiary, totalAmount);\n\n        _tokenGrants[beneficiary] = tokenGrant(\n            true/*isActive*/,\n            false/*wasRevoked*/,\n            startDay,\n            vestingAmount,\n            vestingLocation, /* The wallet address where the vesting schedule is kept. */\n            grantor             /* The account that performed the grant (where revoked funds would be sent) */\n        );\n\n        emit VestingTokensGranted(beneficiary, vestingAmount, startDay, vestingLocation, grantor);\n        return true;\n    }\n\n\n    function grantVestingTokens(\n        address beneficiary,\n        uint256 totalAmount,\n        uint256 vestingAmount,\n        uint32 startDay,\n        uint32 duration,\n        uint32 cliffDuration,\n        uint32 interval,\n        bool isRevocable\n    ) public onlyGrantor returns (bool ok) {\n        require(!_tokenGrants[beneficiary].isActive, \"grant already exists\");\n\n        _setVestingSchedule(beneficiary, cliffDuration, duration, interval, isRevocable);\n\n        _grantVestingTokens(beneficiary, totalAmount, vestingAmount, startDay, beneficiary, msg.sender);\n\n        return true;\n    }\n\n    function safeGrantVestingTokens(\n        address beneficiary, uint256 totalAmount, uint256 vestingAmount,\n        uint32 startDay, uint32 duration, uint32 cliffDuration, uint32 interval,\n        bool isRevocable) public onlyGrantor onlyExistingAccount(beneficiary) returns (bool ok) {\n\n        return grantVestingTokens(\n            beneficiary, totalAmount, vestingAmount,\n            startDay, duration, cliffDuration, interval,\n            isRevocable);\n    }\n\n    function today() public view returns (uint32 dayNumber) {\n        return uint32(block.timestamp / SECONDS_PER_DAY);\n    }\n\n    function _effectiveDay(uint32 onDayOrToday) internal view returns (uint32 dayNumber) {\n        return onDayOrToday == 0 ? today() : onDayOrToday;\n    }\n\n    function _getNotVestedAmount(address grantHolder, uint32 onDayOrToday) internal view returns (uint256 amountNotVested) {\n        tokenGrant storage grant = _tokenGrants[grantHolder];\n        vestingSchedule storage vesting = _vestingSchedules[grant.vestingLocation];\n        uint32 onDay = _effectiveDay(onDayOrToday);\n\n        if (!grant.isActive || onDay \u003c grant.startDay + vesting.cliffDuration)\n        {\n            return grant.amount;\n        }\n        else if (onDay \u003e= grant.startDay + vesting.duration)\n        {\n            return uint256(0);\n        }\n        else\n        {\n            uint32 daysVested = onDay - grant.startDay;\n            uint32 effectiveDaysVested = (daysVested / vesting.interval) * vesting.interval;\n            uint256 vested = grant.amount.mul(effectiveDaysVested).div(vesting.duration);\n            return grant.amount.sub(vested);\n        }\n    }\n\n    function _getAvailableAmount(address grantHolder, uint32 onDay) internal view returns (uint256 amountAvailable) {\n        uint256 totalTokens = balanceOf(grantHolder);\n        uint256 vested = totalTokens.sub(_getNotVestedAmount(grantHolder, onDay));\n        return vested;\n    }\n\n    function vestingForAccountAsOf(\n        address grantHolder,\n        uint32 onDayOrToday\n    )\n    public\n    view\n    onlyGrantorOrSelf(grantHolder)\n    returns (\n        uint256 amountVested,\n        uint256 amountNotVested,\n        uint256 amountOfGrant,\n        uint32 vestStartDay,\n        uint32 vestDuration,\n        uint32 cliffDuration,\n        uint32 vestIntervalDays,\n        bool isActive,\n        bool wasRevoked\n    )\n    {\n        tokenGrant storage grant = _tokenGrants[grantHolder];\n        vestingSchedule storage vesting = _vestingSchedules[grant.vestingLocation];\n        uint256 notVestedAmount = _getNotVestedAmount(grantHolder, onDayOrToday);\n        uint256 grantAmount = grant.amount;\n\n        return (\n        grantAmount.sub(notVestedAmount),\n        notVestedAmount,\n        grantAmount,\n        grant.startDay,\n        vesting.duration,\n        vesting.cliffDuration,\n        vesting.interval,\n        grant.isActive,\n        grant.wasRevoked\n        );\n    }\n\n    function vestingAsOf(uint32 onDayOrToday) public view returns (\n        uint256 amountVested,\n        uint256 amountNotVested,\n        uint256 amountOfGrant,\n        uint32 vestStartDay,\n        uint32 vestDuration,\n        uint32 cliffDuration,\n        uint32 vestIntervalDays,\n        bool isActive,\n        bool wasRevoked\n    )\n    {\n        return vestingForAccountAsOf(msg.sender, onDayOrToday);\n    }\n\n    function _fundsAreAvailableOn(address account, uint256 amount, uint32 onDay) internal view returns (bool ok) {\n        return (amount \u003c= _getAvailableAmount(account, onDay));\n    }\n\n    modifier onlyIfFundsAvailableNow(address account, uint256 amount) {\n        require(_fundsAreAvailableOn(account, amount, today()),\n            balanceOf(account) \u003c amount ? \"insufficient funds\" : \"insufficient vested funds\");\n        _;\n    }\n\n\n    function revokeGrant(address grantHolder, uint32 onDay) public onlyGrantor returns (bool ok) {\n        tokenGrant storage grant = _tokenGrants[grantHolder];\n        vestingSchedule storage vesting = _vestingSchedules[grant.vestingLocation];\n        uint256 notVestedAmount;\n\n        require(msg.sender == owner() || msg.sender == grant.grantor, \"not allowed\");\n        require(grant.isActive, \"no active grant\");\n        require(vesting.isRevocable, \"irrevocable\");\n        require(onDay \u003c= grant.startDay + vesting.duration, \"no effect\");\n        require(onDay \u003e= today(), \"cannot revoke vested holdings\");\n        notVestedAmount = _getNotVestedAmount(grantHolder, onDay);\n\n        _approve(grantHolder, grant.grantor, notVestedAmount);\n        transferFrom(grantHolder, grant.grantor, notVestedAmount);\n\n        _tokenGrants[grantHolder].wasRevoked = true;\n        _tokenGrants[grantHolder].isActive = false;\n\n        emit GrantRevoked(grantHolder, onDay);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) public onlyIfFundsAvailableNow(msg.sender, value) returns (bool ok) {\n        return super.transfer(to, value);\n    }\n\n    function approve(address spender, uint256 value) public onlyIfFundsAvailableNow(msg.sender, value) returns (bool ok) {\n        return super.approve(spender, value);\n    }\n}\n\n\ncontract UniformTokenGrantor is ERC20Vestable {\n\n    struct restrictions {\n        bool isValid;\n        uint32 minStartDay;        /* The smallest value for startDay allowed in grant creation. */\n        uint32 maxStartDay;        /* The maximum value for startDay allowed in grant creation. */\n        uint32 expirationDay;       /* The last day this grantor may make grants. */\n    }\n\n    mapping(address =\u003e restrictions) private _restrictions;\n\n    event GrantorRestrictionsSet(\n        address indexed grantor,\n        uint32 minStartDay,\n        uint32 maxStartDay,\n        uint32 expirationDay);\n\n    function setRestrictions(\n        address grantor,\n        uint32 minStartDay,\n        uint32 maxStartDay,\n        uint32 expirationDay\n    )\n    public\n    onlyOwner\n    onlyExistingAccount(grantor)\n    returns (bool ok)\n    {\n        require(\n            isUniformGrantor(grantor)\n         \u0026\u0026 maxStartDay \u003e minStartDay\n         \u0026\u0026 expirationDay \u003e today(), \"invalid params\");\n\n        _restrictions[grantor] = restrictions(\n            true/*isValid*/,\n            minStartDay,\n            maxStartDay,\n            expirationDay\n        );\n\n        emit GrantorRestrictionsSet(grantor, minStartDay, maxStartDay, expirationDay);\n        return true;\n    }\n\n    function setGrantorVestingSchedule(\n        address grantor,\n        uint32 duration,\n        uint32 cliffDuration,\n        uint32 interval,\n        bool isRevocable\n    )\n    public\n    onlyOwner\n    onlyExistingAccount(grantor)\n    returns (bool ok)\n    {\n        require(isUniformGrantor(grantor), \"uniform grantor only\");\n        require(!_hasVestingSchedule(grantor), \"schedule already exists\");\n        _setVestingSchedule(grantor, cliffDuration, duration, interval, isRevocable);\n        return true;\n    }\n\n    function isUniformGrantorWithSchedule(address account) internal view returns (bool ok) {\n        return isUniformGrantor(account) \u0026\u0026 _hasVestingSchedule(account);\n    }\n\n    modifier onlyUniformGrantorWithSchedule(address account) {\n        require(isUniformGrantorWithSchedule(account), \"grantor account not ready\");\n        _;\n    }\n\n    modifier whenGrantorRestrictionsMet(uint32 startDay) {\n        restrictions storage restriction = _restrictions[msg.sender];\n        require(restriction.isValid, \"set restrictions first\");\n\n        require(\n            startDay \u003e= restriction.minStartDay\n            \u0026\u0026 startDay \u003c restriction.maxStartDay, \"startDay too early\");\n\n        require(today() \u003c restriction.expirationDay, \"grantor expired\");\n        _;\n    }\n\n\n    function grantUniformVestingTokens(\n        address beneficiary,\n        uint256 totalAmount,\n        uint256 vestingAmount,\n        uint32 startDay\n    )\n    public\n    onlyUniformGrantorWithSchedule(msg.sender)\n    whenGrantorRestrictionsMet(startDay)\n    returns (bool ok)\n    {\n        return _grantVestingTokens(beneficiary, totalAmount, vestingAmount, startDay, msg.sender, msg.sender);\n    }\n\n    function safeGrantUniformVestingTokens(\n        address beneficiary,\n        uint256 totalAmount,\n        uint256 vestingAmount,\n        uint32 startDay\n    )\n    public\n    onlyUniformGrantorWithSchedule(msg.sender)\n    whenGrantorRestrictionsMet(startDay)\n    onlyExistingAccount(beneficiary)\n    returns (bool ok)\n    {\n        return _grantVestingTokens(beneficiary, totalAmount, vestingAmount, startDay, msg.sender, msg.sender);\n    }\n}\n"},"Primary_General.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Primary_Libs.sol\";\n\ncontract Context {\n\n    constructor () internal { }\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Identity {\n    mapping(address =\u003e string) private _names;\n\n    function iAm(string memory shortName) public {\n        _names[msg.sender] = shortName;\n    }\n\n    function whereAmI() public view returns (address yourAddress) {\n        address myself = msg.sender;\n        return myself;\n    }\n\n    function whoAmI() public view returns (string memory yourName) {\n        return (_names[msg.sender]);\n    }\n}\n\ncontract PauserRole is Context {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    constructor () internal {\n        _addPauser(_msgSender());\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(_msgSender()), \"PauserRole: caller does not have the Pauser role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(_msgSender());\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract GrantorRole is Ownable {\n    bool private constant OWNER_UNIFORM_GRANTOR_FLAG = false;\n\n    using Roles for Roles.Role;\n\n    event GrantorAdded(address indexed account);\n    event GrantorRemoved(address indexed account);\n\n    Roles.Role private _grantors;\n    mapping(address =\u003e bool) private _isUniformGrantor;\n\n    constructor () internal {\n        _addGrantor(msg.sender, OWNER_UNIFORM_GRANTOR_FLAG);\n    }\n\n    modifier onlyGrantor() {\n        require(isGrantor(msg.sender), \"onlyGrantor\");\n        _;\n    }\n\n    modifier onlyGrantorOrSelf(address account) {\n        require(isGrantor(msg.sender) || msg.sender == account, \"onlyGrantorOrSelf\");\n        _;\n    }\n\n    function isGrantor(address account) public view returns (bool) {\n        return _grantors.has(account);\n    }\n\n    function addGrantor(address account, bool isUniformGrantor) public onlyOwner {\n        _addGrantor(account, isUniformGrantor);\n    }\n\n    function removeGrantor(address account) public onlyOwner {\n        _removeGrantor(account);\n    }\n\n    function _addGrantor(address account, bool isUniformGrantor) private {\n        require(account != address(0));\n        _grantors.add(account);\n        _isUniformGrantor[account] = isUniformGrantor;\n        emit GrantorAdded(account);\n    }\n\n    function _removeGrantor(address account) private {\n        require(account != address(0));\n        _grantors.remove(account);\n        emit GrantorRemoved(account);\n    }\n\n    function isUniformGrantor(address account) public view returns (bool) {\n        return isGrantor(account) \u0026\u0026 _isUniformGrantor[account];\n    }\n\n    modifier onlyUniformGrantor() {\n        require(isUniformGrantor(msg.sender), \"onlyUniformGrantor\");\n        // Only grantor role can do this.\n        _;\n    }\n\n    function renounceOwnership() public onlyOwner {\n        require(false, \"forbidden\");\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        _removeGrantor(msg.sender);\n        super.transferOwnership(newOwner);\n        _addGrantor(newOwner, OWNER_UNIFORM_GRANTOR_FLAG);\n    }\n}\n\ncontract Pausable is Context, PauserRole {\n\n    event Paused(address account);\n\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    constructor () internal {\n        _paused = false;\n    }\n\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"},"Primary_IERC20.sol":{"content":"pragma solidity ^0.5.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\ninterface IERC20Vestable {\n    function getIntrinsicVestingSchedule(address grantHolder)\n    external\n    view\n    returns (\n        uint32 cliffDuration,\n        uint32 vestDuration,\n        uint32 vestIntervalDays\n    );\n\n    function grantVestingTokens(\n        address beneficiary,\n        uint256 totalAmount,\n        uint256 vestingAmount,\n        uint32 startDay,\n        uint32 duration,\n        uint32 cliffDuration,\n        uint32 interval,\n        bool isRevocable\n    ) external returns (bool ok);\n\n    function today() external view returns (uint32 dayNumber);\n\n    function vestingForAccountAsOf(\n        address grantHolder,\n        uint32 onDayOrToday\n    )\n    external\n    view\n    returns (\n        uint256 amountVested,\n        uint256 amountNotVested,\n        uint256 amountOfGrant,\n        uint32 vestStartDay,\n        uint32 cliffDuration,\n        uint32 vestDuration,\n        uint32 vestIntervalDays,\n        bool isActive,\n        bool wasRevoked\n    );\n\n    function vestingAsOf(uint32 onDayOrToday) external view returns (\n        uint256 amountVested,\n        uint256 amountNotVested,\n        uint256 amountOfGrant,\n        uint32 vestStartDay,\n        uint32 cliffDuration,\n        uint32 vestDuration,\n        uint32 vestIntervalDays,\n        bool isActive,\n        bool wasRevoked\n    );\n\n    function revokeGrant(address grantHolder, uint32 onDay) external returns (bool);\n\n    event VestingScheduleCreated(\n        address indexed vestingLocation,\n        uint32 cliffDuration, uint32 indexed duration, uint32 interval,\n        bool indexed isRevocable);\n\n    event VestingTokensGranted(\n        address indexed beneficiary,\n        uint256 indexed vestingAmount,\n        uint32 startDay,\n        address vestingLocation,\n        address indexed grantor);\n\n    event GrantRevoked(address indexed grantHolder, uint32 indexed onDay);\n}\n"},"Primary_Libs.sol":{"content":"pragma solidity ^0.5.0;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Roles {\n    struct Role {\n        mapping (address =\u003e bool) bearer;\n    }\n\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}"}}