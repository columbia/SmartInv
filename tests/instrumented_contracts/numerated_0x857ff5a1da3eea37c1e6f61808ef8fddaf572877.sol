1 // File: apevicecity.sol
2 
3 
4 
5 /**
6             __xxxxxxxxxxxxxxxx___.
7                         _gxXXXXXXXXXXXXXXXXXXXXXXXX!x_
8                    __x!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!x_
9                 ,gXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx_
10               ,gXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!_
11             _!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!.
12           gXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXs
13         ,!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!.
14        g!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
15       iXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
16      ,XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
17      !XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
18    ,XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
19    !XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXi
20   dXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
21   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
22   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
23   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
24   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
25   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
26   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
27   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
28   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
29   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
30   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
31   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
32   !XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
33    XXXXXXXXXXXXXXXXXXXf~~~VXXXXXXXXXXXXXXXXXXXXXXXXXXvvvvvvvvXXXXXXXXXXXXXX!
34    !XXXXXXXXXXXXXXXf`       'XXXXXXXXXXXXXXXXXXXXXf`          '~XXXXXXXXXXP
35     vXXXXXXXXXXXX!            !XXXXXXXXXXXXXXXXXX!              !XXXXXXXXX
36      XXXXXXXXXXv`              'VXXXXXXXXXXXXXXX                !XXXXXXXX!
37      !XXXXXXXXX.                 YXXXXXXXXXXXXX!                XXXXXXXXX
38       XXXXXXXXX!                 ,XXXXXXXXXXXXXX                VXXXXXXX!
39       'XXXXXXXX!                ,!XXXX ~~XXXXXXX               iXXXXXX~
40        'XXXXXXXX               ,XXXXXX   XXXXXXXX!             xXXXXXX!
41         !XXXXXXX!xxxxxxs______xXXXXXXX   'YXXXXXX!          ,xXXXXXXXX
42          YXXXXXXXXXXXXXXXXXXXXXXXXXXX`    VXXXXXXX!s. __gxx!XXXXXXXXXP
43           XXXXXXXXXXXXXXXXXXXXXXXXXX!      'XXXXXXXXXXXXXXXXXXXXXXXXX!
44           XXXXXXXXXXXXXXXXXXXXXXXXXP        'YXXXXXXXXXXXXXXXXXXXXXXX!
45           XXXXXXXXXXXXXXXXXXXXXXXX!     i    !XXXXXXXXXXXXXXXXXXXXXXXX
46           XXXXXXXXXXXXXXXXXXXXXXXX!     XX   !XXXXXXXXXXXXXXXXXXXXXXXX
47           XXXXXXXXXXXXXXXXXXXXXXXXx_   iXX_,_dXXXXXXXXXXXXXXXXXXXXXXXX
48           XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXP
49           XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
50            ~vXvvvvXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXf
51                     'VXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXvvvvvv~
52                       'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX~
53                   _    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXv`
54                  -XX!  !XXXXXXX~XXXXXXXXXXXXXXXXXXXXXX~   Xxi
55                   YXX  '~ XXXXX XXXXXXXXXXXXXXXXXXXX`     iXX`
56                   !XX!    !XXX` XXXXXXXXXXXXXXXXXXXX      !XX
57                   !XXX    '~Vf  YXXXXXXXXXXXXXP YXXX     !XXX
58                   !XXX  ,_      !XXP YXXXfXXXX!  XXX     XXXV
59                   !XXX !XX           'XXP 'YXX!       ,.!XXX!
60                   !XXXi!XP  XX.                  ,_  !XXXXXX!
61                   iXXXx X!  XX! !Xx.  ,.     xs.,XXi !XXXXXXf
62                    XXXXXXXXXXXXXXXXX! _!XXx  dXXXXXXX.iXXXXXX
63                    VXXXXXXXXXXXXXXXXXXXXXXXxxXXXXXXXXXXXXXXX!
64                    YXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXV
65                     'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
66                     'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXf
67                        VXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXf
68                          VXXXXXXXXXXXXXXXXXXXXXXXXXXXXv`
69                           ~vXXXXXXXXXXXXXXXXXXXXXXXf`
70                               ~vXXXXXXXXXXXXXXXXv~
71 */
72 
73 
74 // OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)
75 
76 pragma solidity ^0.8.0;
77 
78 
79 abstract contract ReentrancyGuard {
80     // Booleans are more expensive than uint256 or any type that takes up a full
81     // word because each write operation emits an extra SLOAD to first read the
82     // slot's contents, replace the bits taken up by the boolean, and then write
83     // back. This is the compiler's defense against contract upgrades and
84     // pointer aliasing, and it cannot be disabled.
85 
86     // The values being non-zero value makes deployment a bit more expensive,
87     // but in exchange the refund on every call to nonReentrant will be lower in
88     // amount. Since refunds are capped to a percentage of the total
89     // transaction's gas, it is best to keep them low in cases like this one, to
90     // increase the likelihood of the full refund coming into effect.
91     uint256 private constant _NOT_ENTERED = 1;
92     uint256 private constant _ENTERED = 2;
93 
94     uint256 private _status;
95 
96     constructor() {
97         _status = _NOT_ENTERED;
98     }
99 
100     /**
101      * @dev Prevents a contract from calling itself, directly or indirectly.
102      * Calling a `nonReentrant` function from another `nonReentrant`
103      * function is not supported. It is possible to prevent this from happening
104      * by making the `nonReentrant` function external, and making it call a
105      * `private` function that does the actual work.
106      */
107     modifier nonReentrant() {
108         // On the first call to nonReentrant, _notEntered will be true
109         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
110 
111         // Any calls to nonReentrant after this point will fail
112         _status = _ENTERED;
113 
114         _;
115 
116         // By storing the original value once again, a refund is triggered (see
117         // https://eips.ethereum.org/EIPS/eip-2200)
118         _status = _NOT_ENTERED;
119     }
120 }
121 
122 // File: @openzeppelin/contracts/utils/Strings.sol
123 
124 
125 // OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)
126 
127 pragma solidity ^0.8.0;
128 
129 /**
130  * @dev String operations.
131  */
132 library Strings {
133     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
134 
135     /**
136      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
137      */
138     function toString(uint256 value) internal pure returns (string memory) {
139         // Inspired by OraclizeAPI's implementation - MIT licence
140         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
141 
142         if (value == 0) {
143             return "0";
144         }
145         uint256 temp = value;
146         uint256 digits;
147         while (temp != 0) {
148             digits++;
149             temp /= 10;
150         }
151         bytes memory buffer = new bytes(digits);
152         while (value != 0) {
153             digits -= 1;
154             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
155             value /= 10;
156         }
157         return string(buffer);
158     }
159 
160     /**
161      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
162      */
163     function toHexString(uint256 value) internal pure returns (string memory) {
164         if (value == 0) {
165             return "0x00";
166         }
167         uint256 temp = value;
168         uint256 length = 0;
169         while (temp != 0) {
170             length++;
171             temp >>= 8;
172         }
173         return toHexString(value, length);
174     }
175 
176     /**
177      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
178      */
179     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
180         bytes memory buffer = new bytes(2 * length + 2);
181         buffer[0] = "0";
182         buffer[1] = "x";
183         for (uint256 i = 2 * length + 1; i > 1; --i) {
184             buffer[i] = _HEX_SYMBOLS[value & 0xf];
185             value >>= 4;
186         }
187         require(value == 0, "Strings: hex length insufficient");
188         return string(buffer);
189     }
190 }
191 
192 // File: @openzeppelin/contracts/utils/Context.sol
193 
194 
195 // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
196 
197 pragma solidity ^0.8.0;
198 
199 /**
200  * @dev Provides information about the current execution context, including the
201  * sender of the transaction and its data. While these are generally available
202  * via msg.sender and msg.data, they should not be accessed in such a direct
203  * manner, since when dealing with meta-transactions the account sending and
204  * paying for execution may not be the actual sender (as far as an application
205  * is concerned).
206  *
207  * This contract is only required for intermediate, library-like contracts.
208  */
209 abstract contract Context {
210     function _msgSender() internal view virtual returns (address) {
211         return msg.sender;
212     }
213 
214     function _msgData() internal view virtual returns (bytes calldata) {
215         return msg.data;
216     }
217 }
218 
219 // File: @openzeppelin/contracts/access/Ownable.sol
220 
221 
222 // OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)
223 
224 pragma solidity ^0.8.0;
225 
226 
227 /**
228  * @dev Contract module which provides a basic access control mechanism, where
229  * there is an account (an owner) that can be granted exclusive access to
230  * specific functions.
231  *
232  * By default, the owner account will be the one that deploys the contract. This
233  * can later be changed with {transferOwnership}.
234  *
235  * This module is used through inheritance. It will make available the modifier
236  * `onlyOwner`, which can be applied to your functions to restrict their use to
237  * the owner.
238  */
239 abstract contract Ownable is Context {
240     address private _owner;
241 
242     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
243 
244     /**
245      * @dev Initializes the contract setting the deployer as the initial owner.
246      */
247     constructor() {
248         _transferOwnership(_msgSender());
249     }
250 
251     /**
252      * @dev Returns the address of the current owner.
253      */
254     function owner() public view virtual returns (address) {
255         return _owner;
256     }
257 
258     /**
259      * @dev Throws if called by any account other than the owner.
260      */
261     modifier onlyOwner() {
262         require(owner() == _msgSender(), "Ownable: caller is not the owner");
263         _;
264     }
265 
266     /**
267      * @dev Leaves the contract without owner. It will not be possible to call
268      * `onlyOwner` functions anymore. Can only be called by the current owner.
269      *
270      * NOTE: Renouncing ownership will leave the contract without an owner,
271      * thereby removing any functionality that is only available to the owner.
272      */
273     function renounceOwnership() public virtual onlyOwner {
274         _transferOwnership(address(0));
275     }
276 
277     /**
278      * @dev Transfers ownership of the contract to a new account (`newOwner`).
279      * Can only be called by the current owner.
280      */
281     function transferOwnership(address newOwner) public virtual onlyOwner {
282         require(newOwner != address(0), "Ownable: new owner is the zero address");
283         _transferOwnership(newOwner);
284     }
285 
286     /**
287      * @dev Transfers ownership of the contract to a new account (`newOwner`).
288      * Internal function without access restriction.
289      */
290     function _transferOwnership(address newOwner) internal virtual {
291         address oldOwner = _owner;
292         _owner = newOwner;
293         emit OwnershipTransferred(oldOwner, newOwner);
294     }
295 }
296 
297 // File: @openzeppelin/contracts/utils/Address.sol
298 
299 
300 // OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)
301 
302 pragma solidity ^0.8.1;
303 
304 /**
305  * @dev Collection of functions related to the address type
306  */
307 library Address {
308     /**
309      * @dev Returns true if `account` is a contract.
310      *
311      * [IMPORTANT]
312      * ====
313      * It is unsafe to assume that an address for which this function returns
314      * false is an externally-owned account (EOA) and not a contract.
315      *
316      * Among others, `isContract` will return false for the following
317      * types of addresses:
318      *
319      *  - an externally-owned account
320      *  - a contract in construction
321      *  - an address where a contract will be created
322      *  - an address where a contract lived, but was destroyed
323      * ====
324      *
325      * [IMPORTANT]
326      * ====
327      * You shouldn't rely on `isContract` to protect against flash loan attacks!
328      *
329      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
330      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
331      * constructor.
332      * ====
333      */
334     function isContract(address account) internal view returns (bool) {
335         // This method relies on extcodesize/address.code.length, which returns 0
336         // for contracts in construction, since the code is only stored at the end
337         // of the constructor execution.
338 
339         return account.code.length > 0;
340     }
341 
342     /**
343      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
344      * `recipient`, forwarding all available gas and reverting on errors.
345      *
346      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
347      * of certain opcodes, possibly making contracts go over the 2300 gas limit
348      * imposed by `transfer`, making them unable to receive funds via
349      * `transfer`. {sendValue} removes this limitation.
350      *
351      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
352      *
353      * IMPORTANT: because control is transferred to `recipient`, care must be
354      * taken to not create reentrancy vulnerabilities. Consider using
355      * {ReentrancyGuard} or the
356      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
357      */
358     function sendValue(address payable recipient, uint256 amount) internal {
359         require(address(this).balance >= amount, "Address: insufficient balance");
360 
361         (bool success, ) = recipient.call{value: amount}("");
362         require(success, "Address: unable to send value, recipient may have reverted");
363     }
364 
365     /**
366      * @dev Performs a Solidity function call using a low level `call`. A
367      * plain `call` is an unsafe replacement for a function call: use this
368      * function instead.
369      *
370      * If `target` reverts with a revert reason, it is bubbled up by this
371      * function (like regular Solidity function calls).
372      *
373      * Returns the raw returned data. To convert to the expected return value,
374      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
375      *
376      * Requirements:
377      *
378      * - `target` must be a contract.
379      * - calling `target` with `data` must not revert.
380      *
381      * _Available since v3.1._
382      */
383     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
384         return functionCall(target, data, "Address: low-level call failed");
385     }
386 
387     /**
388      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
389      * `errorMessage` as a fallback revert reason when `target` reverts.
390      *
391      * _Available since v3.1._
392      */
393     function functionCall(
394         address target,
395         bytes memory data,
396         string memory errorMessage
397     ) internal returns (bytes memory) {
398         return functionCallWithValue(target, data, 0, errorMessage);
399     }
400 
401     /**
402      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
403      * but also transferring `value` wei to `target`.
404      *
405      * Requirements:
406      *
407      * - the calling contract must have an ETH balance of at least `value`.
408      * - the called Solidity function must be `payable`.
409      *
410      * _Available since v3.1._
411      */
412     function functionCallWithValue(
413         address target,
414         bytes memory data,
415         uint256 value
416     ) internal returns (bytes memory) {
417         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
418     }
419 
420     /**
421      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
422      * with `errorMessage` as a fallback revert reason when `target` reverts.
423      *
424      * _Available since v3.1._
425      */
426     function functionCallWithValue(
427         address target,
428         bytes memory data,
429         uint256 value,
430         string memory errorMessage
431     ) internal returns (bytes memory) {
432         require(address(this).balance >= value, "Address: insufficient balance for call");
433         require(isContract(target), "Address: call to non-contract");
434 
435         (bool success, bytes memory returndata) = target.call{value: value}(data);
436         return verifyCallResult(success, returndata, errorMessage);
437     }
438 
439     /**
440      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
441      * but performing a static call.
442      *
443      * _Available since v3.3._
444      */
445     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
446         return functionStaticCall(target, data, "Address: low-level static call failed");
447     }
448 
449     /**
450      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
451      * but performing a static call.
452      *
453      * _Available since v3.3._
454      */
455     function functionStaticCall(
456         address target,
457         bytes memory data,
458         string memory errorMessage
459     ) internal view returns (bytes memory) {
460         require(isContract(target), "Address: static call to non-contract");
461 
462         (bool success, bytes memory returndata) = target.staticcall(data);
463         return verifyCallResult(success, returndata, errorMessage);
464     }
465 
466     /**
467      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
468      * but performing a delegate call.
469      *
470      * _Available since v3.4._
471      */
472     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
473         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
474     }
475 
476     /**
477      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
478      * but performing a delegate call.
479      *
480      * _Available since v3.4._
481      */
482     function functionDelegateCall(
483         address target,
484         bytes memory data,
485         string memory errorMessage
486     ) internal returns (bytes memory) {
487         require(isContract(target), "Address: delegate call to non-contract");
488 
489         (bool success, bytes memory returndata) = target.delegatecall(data);
490         return verifyCallResult(success, returndata, errorMessage);
491     }
492 
493     /**
494      * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
495      * revert reason using the provided one.
496      *
497      * _Available since v4.3._
498      */
499     function verifyCallResult(
500         bool success,
501         bytes memory returndata,
502         string memory errorMessage
503     ) internal pure returns (bytes memory) {
504         if (success) {
505             return returndata;
506         } else {
507             // Look for revert reason and bubble it up if present
508             if (returndata.length > 0) {
509                 // The easiest way to bubble the revert reason is using memory via assembly
510 
511                 assembly {
512                     let returndata_size := mload(returndata)
513                     revert(add(32, returndata), returndata_size)
514                 }
515             } else {
516                 revert(errorMessage);
517             }
518         }
519     }
520 }
521 
522 // File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
523 
524 
525 // OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)
526 
527 pragma solidity ^0.8.0;
528 
529 /**
530  * @title ERC721 token receiver interface
531  * @dev Interface for any contract that wants to support safeTransfers
532  * from ERC721 asset contracts.
533  */
534 interface IERC721Receiver {
535     /**
536      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
537      * by `operator` from `from`, this function is called.
538      *
539      * It must return its Solidity selector to confirm the token transfer.
540      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
541      *
542      * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
543      */
544     function onERC721Received(
545         address operator,
546         address from,
547         uint256 tokenId,
548         bytes calldata data
549     ) external returns (bytes4);
550 }
551 
552 // File: @openzeppelin/contracts/utils/introspection/IERC165.sol
553 
554 
555 // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
556 
557 pragma solidity ^0.8.0;
558 
559 /**
560  * @dev Interface of the ERC165 standard, as defined in the
561  * https://eips.ethereum.org/EIPS/eip-165[EIP].
562  *
563  * Implementers can declare support of contract interfaces, which can then be
564  * queried by others ({ERC165Checker}).
565  *
566  * For an implementation, see {ERC165}.
567  */
568 interface IERC165 {
569     /**
570      * @dev Returns true if this contract implements the interface defined by
571      * `interfaceId`. See the corresponding
572      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
573      * to learn more about how these ids are created.
574      *
575      * This function call must use less than 30 000 gas.
576      */
577     function supportsInterface(bytes4 interfaceId) external view returns (bool);
578 }
579 
580 // File: @openzeppelin/contracts/utils/introspection/ERC165.sol
581 
582 
583 // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
584 
585 pragma solidity ^0.8.0;
586 
587 
588 /**
589  * @dev Implementation of the {IERC165} interface.
590  *
591  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
592  * for the additional interface id that will be supported. For example:
593  *
594  * ```solidity
595  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
596  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
597  * }
598  * ```
599  *
600  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
601  */
602 abstract contract ERC165 is IERC165 {
603     /**
604      * @dev See {IERC165-supportsInterface}.
605      */
606     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
607         return interfaceId == type(IERC165).interfaceId;
608     }
609 }
610 
611 // File: @openzeppelin/contracts/token/ERC721/IERC721.sol
612 
613 
614 // OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)
615 
616 pragma solidity ^0.8.0;
617 
618 
619 /**
620  * @dev Required interface of an ERC721 compliant contract.
621  */
622 interface IERC721 is IERC165 {
623     /**
624      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
625      */
626     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
627 
628     /**
629      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
630      */
631     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
632 
633     /**
634      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
635      */
636     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
637 
638     /**
639      * @dev Returns the number of tokens in ``owner``'s account.
640      */
641     function balanceOf(address owner) external view returns (uint256 balance);
642 
643     /**
644      * @dev Returns the owner of the `tokenId` token.
645      *
646      * Requirements:
647      *
648      * - `tokenId` must exist.
649      */
650     function ownerOf(uint256 tokenId) external view returns (address owner);
651 
652     /**
653      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
654      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
655      *
656      * Requirements:
657      *
658      * - `from` cannot be the zero address.
659      * - `to` cannot be the zero address.
660      * - `tokenId` token must exist and be owned by `from`.
661      * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
662      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
663      *
664      * Emits a {Transfer} event.
665      */
666     function safeTransferFrom(
667         address from,
668         address to,
669         uint256 tokenId
670     ) external;
671 
672     /**
673      * @dev Transfers `tokenId` token from `from` to `to`.
674      *
675      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
676      *
677      * Requirements:
678      *
679      * - `from` cannot be the zero address.
680      * - `to` cannot be the zero address.
681      * - `tokenId` token must be owned by `from`.
682      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
683      *
684      * Emits a {Transfer} event.
685      */
686     function transferFrom(
687         address from,
688         address to,
689         uint256 tokenId
690     ) external;
691 
692     /**
693      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
694      * The approval is cleared when the token is transferred.
695      *
696      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
697      *
698      * Requirements:
699      *
700      * - The caller must own the token or be an approved operator.
701      * - `tokenId` must exist.
702      *
703      * Emits an {Approval} event.
704      */
705     function approve(address to, uint256 tokenId) external;
706 
707     /**
708      * @dev Returns the account approved for `tokenId` token.
709      *
710      * Requirements:
711      *
712      * - `tokenId` must exist.
713      */
714     function getApproved(uint256 tokenId) external view returns (address operator);
715 
716     /**
717      * @dev Approve or remove `operator` as an operator for the caller.
718      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
719      *
720      * Requirements:
721      *
722      * - The `operator` cannot be the caller.
723      *
724      * Emits an {ApprovalForAll} event.
725      */
726     function setApprovalForAll(address operator, bool _approved) external;
727 
728     /**
729      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
730      *
731      * See {setApprovalForAll}
732      */
733     function isApprovedForAll(address owner, address operator) external view returns (bool);
734 
735     /**
736      * @dev Safely transfers `tokenId` token from `from` to `to`.
737      *
738      * Requirements:
739      *
740      * - `from` cannot be the zero address.
741      * - `to` cannot be the zero address.
742      * - `tokenId` token must exist and be owned by `from`.
743      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
744      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
745      *
746      * Emits a {Transfer} event.
747      */
748     function safeTransferFrom(
749         address from,
750         address to,
751         uint256 tokenId,
752         bytes calldata data
753     ) external;
754 }
755 
756 // File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
757 
758 
759 // OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)
760 
761 pragma solidity ^0.8.0;
762 
763 
764 /**
765  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
766  * @dev See https://eips.ethereum.org/EIPS/eip-721
767  */
768 interface IERC721Metadata is IERC721 {
769     /**
770      * @dev Returns the token collection name.
771      */
772     function name() external view returns (string memory);
773 
774     /**
775      * @dev Returns the token collection symbol.
776      */
777     function symbol() external view returns (string memory);
778 
779     /**
780      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
781      */
782     function tokenURI(uint256 tokenId) external view returns (string memory);
783 }
784 
785 // File: contracts/ERC721A.sol
786 
787 
788 // Creator: Chiru Labs
789 
790 pragma solidity ^0.8.4;
791 
792 
793 
794 
795 
796 
797 
798 
799 error ApprovalCallerNotOwnerNorApproved();
800 error ApprovalQueryForNonexistentToken();
801 error ApproveToCaller();
802 error ApprovalToCurrentOwner();
803 error BalanceQueryForZeroAddress();
804 error MintToZeroAddress();
805 error MintZeroQuantity();
806 error OwnerQueryForNonexistentToken();
807 error TransferCallerNotOwnerNorApproved();
808 error TransferFromIncorrectOwner();
809 error TransferToNonERC721ReceiverImplementer();
810 error TransferToZeroAddress();
811 error URIQueryForNonexistentToken();
812 
813 /**
814  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
815  * the Metadata extension. Built to optimize for lower gas during batch mints.
816  *
817  * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).
818  *
819  * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.
820  *
821  * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).
822  */
823 contract ERC721A is Context, ERC165, IERC721, IERC721Metadata {
824     using Address for address;
825     using Strings for uint256;
826 
827     // Compiler will pack this into a single 256bit word.
828     struct TokenOwnership {
829         // The address of the owner.
830         address addr;
831         // Keeps track of the start time of ownership with minimal overhead for tokenomics.
832         uint64 startTimestamp;
833         // Whether the token has been burned.
834         bool burned;
835     }
836 
837     // Compiler will pack this into a single 256bit word.
838     struct AddressData {
839         // Realistically, 2**64-1 is more than enough.
840         uint64 balance;
841         // Keeps track of mint count with minimal overhead for tokenomics.
842         uint64 numberMinted;
843         // Keeps track of burn count with minimal overhead for tokenomics.
844         uint64 numberBurned;
845         // For miscellaneous variable(s) pertaining to the address
846         // (e.g. number of whitelist mint slots used).
847         // If there are multiple variables, please pack them into a uint64.
848         uint64 aux;
849     }
850 
851     // The tokenId of the next token to be minted.
852     uint256 internal _currentIndex;
853 
854     // The number of tokens burned.
855     uint256 internal _burnCounter;
856 
857     // Token name
858     string private _name;
859 
860     // Token symbol
861     string private _symbol;
862 
863     // Mapping from token ID to ownership details
864     // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.
865     mapping(uint256 => TokenOwnership) internal _ownerships;
866 
867     // Mapping owner address to address data
868     mapping(address => AddressData) private _addressData;
869 
870     // Mapping from token ID to approved address
871     mapping(uint256 => address) private _tokenApprovals;
872 
873     // Mapping from owner to operator approvals
874     mapping(address => mapping(address => bool)) private _operatorApprovals;
875 
876     constructor(string memory name_, string memory symbol_) {
877         _name = name_;
878         _symbol = symbol_;
879         _currentIndex = _startTokenId();
880     }
881 
882     /**
883      * To change the starting tokenId, please override this function.
884      */
885     function _startTokenId() internal view virtual returns (uint256) {
886         return 1;
887     }
888 
889     /**
890      * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.
891      */
892     function totalSupply() public view returns (uint256) {
893         // Counter underflow is impossible as _burnCounter cannot be incremented
894         // more than _currentIndex - _startTokenId() times
895         unchecked {
896             return _currentIndex - _burnCounter - _startTokenId();
897         }
898     }
899 
900     /**
901      * Returns the total amount of tokens minted in the contract.
902      */
903     function _totalMinted() internal view returns (uint256) {
904         // Counter underflow is impossible as _currentIndex does not decrement,
905         // and it is initialized to _startTokenId()
906         unchecked {
907             return _currentIndex - _startTokenId();
908         }
909     }
910 
911     /**
912      * @dev See {IERC165-supportsInterface}.
913      */
914     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
915         return
916             interfaceId == type(IERC721).interfaceId ||
917             interfaceId == type(IERC721Metadata).interfaceId ||
918             super.supportsInterface(interfaceId);
919     }
920 
921     /**
922      * @dev See {IERC721-balanceOf}.
923      */
924     function balanceOf(address owner) public view override returns (uint256) {
925         if (owner == address(0)) revert BalanceQueryForZeroAddress();
926         return uint256(_addressData[owner].balance);
927     }
928 
929     /**
930      * Returns the number of tokens minted by `owner`.
931      */
932     function _numberMinted(address owner) internal view returns (uint256) {
933         return uint256(_addressData[owner].numberMinted);
934     }
935 
936     /**
937      * Returns the number of tokens burned by or on behalf of `owner`.
938      */
939     function _numberBurned(address owner) internal view returns (uint256) {
940         return uint256(_addressData[owner].numberBurned);
941     }
942 
943     /**
944      * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).
945      */
946     function _getAux(address owner) internal view returns (uint64) {
947         return _addressData[owner].aux;
948     }
949 
950     /**
951      * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).
952      * If there are multiple variables, please pack them into a uint64.
953      */
954     function _setAux(address owner, uint64 aux) internal {
955         _addressData[owner].aux = aux;
956     }
957 
958     /**
959      * Gas spent here starts off proportional to the maximum mint batch size.
960      * It gradually moves to O(1) as tokens get transferred around in the collection over time.
961      */
962     function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {
963         uint256 curr = tokenId;
964 
965         unchecked {
966             if (_startTokenId() <= curr && curr < _currentIndex) {
967                 TokenOwnership memory ownership = _ownerships[curr];
968                 if (!ownership.burned) {
969                     if (ownership.addr != address(0)) {
970                         return ownership;
971                     }
972                     // Invariant:
973                     // There will always be an ownership that has an address and is not burned
974                     // before an ownership that does not have an address and is not burned.
975                     // Hence, curr will not underflow.
976                     while (true) {
977                         curr--;
978                         ownership = _ownerships[curr];
979                         if (ownership.addr != address(0)) {
980                             return ownership;
981                         }
982                     }
983                 }
984             }
985         }
986         revert OwnerQueryForNonexistentToken();
987     }
988 
989     /**
990      * @dev See {IERC721-ownerOf}.
991      */
992     function ownerOf(uint256 tokenId) public view override returns (address) {
993         return _ownershipOf(tokenId).addr;
994     }
995 
996     /**
997      * @dev See {IERC721Metadata-name}.
998      */
999     function name() public view virtual override returns (string memory) {
1000         return _name;
1001     }
1002 
1003     /**
1004      * @dev See {IERC721Metadata-symbol}.
1005      */
1006     function symbol() public view virtual override returns (string memory) {
1007         return _symbol;
1008     }
1009 
1010     /**
1011      * @dev See {IERC721Metadata-tokenURI}.
1012      */
1013     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
1014         if (!_exists(tokenId)) revert URIQueryForNonexistentToken();
1015 
1016         string memory baseURI = _baseURI();
1017         return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';
1018     }
1019 
1020     /**
1021      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
1022      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
1023      * by default, can be overriden in child contracts.
1024      */
1025     function _baseURI() internal view virtual returns (string memory) {
1026         return '';
1027     }
1028 
1029     /**
1030      * @dev See {IERC721-approve}.
1031      */
1032     function approve(address to, uint256 tokenId) public override {
1033         address owner = ERC721A.ownerOf(tokenId);
1034         if (to == owner) revert ApprovalToCurrentOwner();
1035 
1036         if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {
1037             revert ApprovalCallerNotOwnerNorApproved();
1038         }
1039 
1040         _approve(to, tokenId, owner);
1041     }
1042 
1043     /**
1044      * @dev See {IERC721-getApproved}.
1045      */
1046     function getApproved(uint256 tokenId) public view override returns (address) {
1047         if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();
1048 
1049         return _tokenApprovals[tokenId];
1050     }
1051 
1052     /**
1053      * @dev See {IERC721-setApprovalForAll}.
1054      */
1055     function setApprovalForAll(address operator, bool approved) public virtual override {
1056         if (operator == _msgSender()) revert ApproveToCaller();
1057 
1058         _operatorApprovals[_msgSender()][operator] = approved;
1059         emit ApprovalForAll(_msgSender(), operator, approved);
1060     }
1061 
1062     /**
1063      * @dev See {IERC721-isApprovedForAll}.
1064      */
1065     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
1066         return _operatorApprovals[owner][operator];
1067     }
1068 
1069     /**
1070      * @dev See {IERC721-transferFrom}.
1071      */
1072     function transferFrom(
1073         address from,
1074         address to,
1075         uint256 tokenId
1076     ) public virtual override {
1077         _transfer(from, to, tokenId);
1078     }
1079 
1080     /**
1081      * @dev See {IERC721-safeTransferFrom}.
1082      */
1083     function safeTransferFrom(
1084         address from,
1085         address to,
1086         uint256 tokenId
1087     ) public virtual override {
1088         safeTransferFrom(from, to, tokenId, '');
1089     }
1090 
1091     /**
1092      * @dev See {IERC721-safeTransferFrom}.
1093      */
1094     function safeTransferFrom(
1095         address from,
1096         address to,
1097         uint256 tokenId,
1098         bytes memory _data
1099     ) public virtual override {
1100         _transfer(from, to, tokenId);
1101         if (to.isContract() && !_checkContractOnERC721Received(from, to, tokenId, _data)) {
1102             revert TransferToNonERC721ReceiverImplementer();
1103         }
1104     }
1105 
1106     /**
1107      * @dev Returns whether `tokenId` exists.
1108      *
1109      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
1110      *
1111      * Tokens start existing when they are minted (`_mint`),
1112      */
1113     function _exists(uint256 tokenId) internal view returns (bool) {
1114         return _startTokenId() <= tokenId && tokenId < _currentIndex && !_ownerships[tokenId].burned;
1115     }
1116 
1117     /**
1118      * @dev Equivalent to `_safeMint(to, quantity, '')`.
1119      */
1120     function _safeMint(address to, uint256 quantity) internal {
1121         _safeMint(to, quantity, '');
1122     }
1123 
1124     /**
1125      * @dev Safely mints `quantity` tokens and transfers them to `to`.
1126      *
1127      * Requirements:
1128      *
1129      * - If `to` refers to a smart contract, it must implement 
1130      *   {IERC721Receiver-onERC721Received}, which is called for each safe transfer.
1131      * - `quantity` must be greater than 0.
1132      *
1133      * Emits a {Transfer} event.
1134      */
1135     function _safeMint(
1136         address to,
1137         uint256 quantity,
1138         bytes memory _data
1139     ) internal {
1140         uint256 startTokenId = _currentIndex;
1141         if (to == address(0)) revert MintToZeroAddress();
1142         if (quantity == 0) revert MintZeroQuantity();
1143 
1144         _beforeTokenTransfers(address(0), to, startTokenId, quantity);
1145 
1146         // Overflows are incredibly unrealistic.
1147         // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1
1148         // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1
1149         unchecked {
1150             _addressData[to].balance += uint64(quantity);
1151             _addressData[to].numberMinted += uint64(quantity);
1152 
1153             _ownerships[startTokenId].addr = to;
1154             _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);
1155 
1156             uint256 updatedIndex = startTokenId;
1157             uint256 end = updatedIndex + quantity;
1158 
1159             if (to.isContract()) {
1160                 do {
1161                     emit Transfer(address(0), to, updatedIndex);
1162                     if (!_checkContractOnERC721Received(address(0), to, updatedIndex++, _data)) {
1163                         revert TransferToNonERC721ReceiverImplementer();
1164                     }
1165                 } while (updatedIndex != end);
1166                 // Reentrancy protection
1167                 if (_currentIndex != startTokenId) revert();
1168             } else {
1169                 do {
1170                     emit Transfer(address(0), to, updatedIndex++);
1171                 } while (updatedIndex != end);
1172             }
1173             _currentIndex = updatedIndex;
1174         }
1175         _afterTokenTransfers(address(0), to, startTokenId, quantity);
1176     }
1177 
1178     /**
1179      * @dev Mints `quantity` tokens and transfers them to `to`.
1180      *
1181      * Requirements:
1182      *
1183      * - `to` cannot be the zero address.
1184      * - `quantity` must be greater than 0.
1185      *
1186      * Emits a {Transfer} event.
1187      */
1188     function _mint(address to, uint256 quantity) internal {
1189         uint256 startTokenId = _currentIndex;
1190         if (to == address(0)) revert MintToZeroAddress();
1191         if (quantity == 0) revert MintZeroQuantity();
1192 
1193         _beforeTokenTransfers(address(0), to, startTokenId, quantity);
1194 
1195         // Overflows are incredibly unrealistic.
1196         // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1
1197         // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1
1198         unchecked {
1199             _addressData[to].balance += uint64(quantity);
1200             _addressData[to].numberMinted += uint64(quantity);
1201 
1202             _ownerships[startTokenId].addr = to;
1203             _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);
1204 
1205             uint256 updatedIndex = startTokenId;
1206             uint256 end = updatedIndex + quantity;
1207 
1208             do {
1209                 emit Transfer(address(0), to, updatedIndex++);
1210             } while (updatedIndex != end);
1211 
1212             _currentIndex = updatedIndex;
1213         }
1214         _afterTokenTransfers(address(0), to, startTokenId, quantity);
1215     }
1216 
1217     /**
1218      * @dev Transfers `tokenId` from `from` to `to`.
1219      *
1220      * Requirements:
1221      *
1222      * - `to` cannot be the zero address.
1223      * - `tokenId` token must be owned by `from`.
1224      *
1225      * Emits a {Transfer} event.
1226      */
1227     function _transfer(
1228         address from,
1229         address to,
1230         uint256 tokenId
1231     ) private {
1232         TokenOwnership memory prevOwnership = _ownershipOf(tokenId);
1233 
1234         if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();
1235 
1236         bool isApprovedOrOwner = (_msgSender() == from ||
1237             isApprovedForAll(from, _msgSender()) ||
1238             getApproved(tokenId) == _msgSender());
1239 
1240         if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();
1241         if (to == address(0)) revert TransferToZeroAddress();
1242 
1243         _beforeTokenTransfers(from, to, tokenId, 1);
1244 
1245         // Clear approvals from the previous owner
1246         _approve(address(0), tokenId, from);
1247 
1248         // Underflow of the sender's balance is impossible because we check for
1249         // ownership above and the recipient's balance can't realistically overflow.
1250         // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.
1251         unchecked {
1252             _addressData[from].balance -= 1;
1253             _addressData[to].balance += 1;
1254 
1255             TokenOwnership storage currSlot = _ownerships[tokenId];
1256             currSlot.addr = to;
1257             currSlot.startTimestamp = uint64(block.timestamp);
1258 
1259             // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.
1260             // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.
1261             uint256 nextTokenId = tokenId + 1;
1262             TokenOwnership storage nextSlot = _ownerships[nextTokenId];
1263             if (nextSlot.addr == address(0)) {
1264                 // This will suffice for checking _exists(nextTokenId),
1265                 // as a burned slot cannot contain the zero address.
1266                 if (nextTokenId != _currentIndex) {
1267                     nextSlot.addr = from;
1268                     nextSlot.startTimestamp = prevOwnership.startTimestamp;
1269                 }
1270             }
1271         }
1272 
1273         emit Transfer(from, to, tokenId);
1274         _afterTokenTransfers(from, to, tokenId, 1);
1275     }
1276 
1277     /**
1278      * @dev Equivalent to `_burn(tokenId, false)`.
1279      */
1280     function _burn(uint256 tokenId) internal virtual {
1281         _burn(tokenId, false);
1282     }
1283 
1284     /**
1285      * @dev Destroys `tokenId`.
1286      * The approval is cleared when the token is burned.
1287      *
1288      * Requirements:
1289      *
1290      * - `tokenId` must exist.
1291      *
1292      * Emits a {Transfer} event.
1293      */
1294     function _burn(uint256 tokenId, bool approvalCheck) internal virtual {
1295         TokenOwnership memory prevOwnership = _ownershipOf(tokenId);
1296 
1297         address from = prevOwnership.addr;
1298 
1299         if (approvalCheck) {
1300             bool isApprovedOrOwner = (_msgSender() == from ||
1301                 isApprovedForAll(from, _msgSender()) ||
1302                 getApproved(tokenId) == _msgSender());
1303 
1304             if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();
1305         }
1306 
1307         _beforeTokenTransfers(from, address(0), tokenId, 1);
1308 
1309         // Clear approvals from the previous owner
1310         _approve(address(0), tokenId, from);
1311 
1312         // Underflow of the sender's balance is impossible because we check for
1313         // ownership above and the recipient's balance can't realistically overflow.
1314         // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.
1315         unchecked {
1316             AddressData storage addressData = _addressData[from];
1317             addressData.balance -= 1;
1318             addressData.numberBurned += 1;
1319 
1320             // Keep track of who burned the token, and the timestamp of burning.
1321             TokenOwnership storage currSlot = _ownerships[tokenId];
1322             currSlot.addr = from;
1323             currSlot.startTimestamp = uint64(block.timestamp);
1324             currSlot.burned = true;
1325 
1326             // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.
1327             // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.
1328             uint256 nextTokenId = tokenId + 1;
1329             TokenOwnership storage nextSlot = _ownerships[nextTokenId];
1330             if (nextSlot.addr == address(0)) {
1331                 // This will suffice for checking _exists(nextTokenId),
1332                 // as a burned slot cannot contain the zero address.
1333                 if (nextTokenId != _currentIndex) {
1334                     nextSlot.addr = from;
1335                     nextSlot.startTimestamp = prevOwnership.startTimestamp;
1336                 }
1337             }
1338         }
1339 
1340         emit Transfer(from, address(0), tokenId);
1341         _afterTokenTransfers(from, address(0), tokenId, 1);
1342 
1343         // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.
1344         unchecked {
1345             _burnCounter++;
1346         }
1347     }
1348 
1349     /**
1350      * @dev Approve `to` to operate on `tokenId`
1351      *
1352      * Emits a {Approval} event.
1353      */
1354     function _approve(
1355         address to,
1356         uint256 tokenId,
1357         address owner
1358     ) private {
1359         _tokenApprovals[tokenId] = to;
1360         emit Approval(owner, to, tokenId);
1361     }
1362 
1363     /**
1364      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.
1365      *
1366      * @param from address representing the previous owner of the given token ID
1367      * @param to target address that will receive the tokens
1368      * @param tokenId uint256 ID of the token to be transferred
1369      * @param _data bytes optional data to send along with the call
1370      * @return bool whether the call correctly returned the expected magic value
1371      */
1372     function _checkContractOnERC721Received(
1373         address from,
1374         address to,
1375         uint256 tokenId,
1376         bytes memory _data
1377     ) private returns (bool) {
1378         try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
1379             return retval == IERC721Receiver(to).onERC721Received.selector;
1380         } catch (bytes memory reason) {
1381             if (reason.length == 0) {
1382                 revert TransferToNonERC721ReceiverImplementer();
1383             } else {
1384                 assembly {
1385                     revert(add(32, reason), mload(reason))
1386                 }
1387             }
1388         }
1389     }
1390 
1391     /**
1392      * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.
1393      * And also called before burning one token.
1394      *
1395      * startTokenId - the first token id to be transferred
1396      * quantity - the amount to be transferred
1397      *
1398      * Calling conditions:
1399      *
1400      * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be
1401      * transferred to `to`.
1402      * - When `from` is zero, `tokenId` will be minted for `to`.
1403      * - When `to` is zero, `tokenId` will be burned by `from`.
1404      * - `from` and `to` are never both zero.
1405      */
1406     function _beforeTokenTransfers(
1407         address from,
1408         address to,
1409         uint256 startTokenId,
1410         uint256 quantity
1411     ) internal virtual {}
1412 
1413     /**
1414      * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes
1415      * minting.
1416      * And also called after one token has been burned.
1417      *
1418      * startTokenId - the first token id to be transferred
1419      * quantity - the amount to be transferred
1420      *
1421      * Calling conditions:
1422      *
1423      * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been
1424      * transferred to `to`.
1425      * - When `from` is zero, `tokenId` has been minted for `to`.
1426      * - When `to` is zero, `tokenId` has been burned by `from`.
1427      * - `from` and `to` are never both zero.
1428      */
1429     function _afterTokenTransfers(
1430         address from,
1431         address to,
1432         uint256 startTokenId,
1433         uint256 quantity
1434     ) internal virtual {}
1435 }
1436 // File: contracts/GossamerGods.sol
1437 
1438 
1439 
1440 pragma solidity ^0.8.0;
1441 
1442     /**
1443                       __------__
1444                     /~          ~\
1445                    |    //^\//^\|          Oh..My great god ...     
1446                  /~~\  ||  o| |o|:~\       Look no further
1447                 | |6   ||___|_|_||:|    /  there is no information you need below
1448                  \__.  /      o  \/'       
1449          /~~~~\    `\  \         /
1450         | |~~\ |     )  ~------~`\
1451        /' |  | |   /     ____ /~~~)\
1452       (_/'   | | |     /'    |    ( |
1453              | | |     \    /   __)/ \
1454              \  \ \      \/    /' \   `\
1455                \  \|\        /   | |\___|
1456                  \ |  \____/     | |
1457                  /^~>  \        _/ <
1458                 |  |         \       \
1459                 |  | \        \        \
1460                 -^-\  \       |        )
1461                      `\_______/^\______/
1462 
1463 
1464 
1465     */
1466 
1467 
1468 
1469 contract APEVICECITY is ERC721A, Ownable, ReentrancyGuard {
1470   using Address for address;
1471   using Strings for uint;
1472 
1473 
1474   string  public  baseTokenURI = "ipfs://QmSihZTssccgZrG5NWt1MFcE7YoNsg5EYmmNtFM2V7nigE//";
1475   uint256  public  maxSupply = 7777;
1476   uint256 public  MAX_MINTS_PER_TX = 10;
1477   uint256 public  PUBLIC_SALE_PRICE = 0.003 ether;
1478   uint256 public  NUM_FREE_MINTS = 5000;
1479   uint256 public  MAX_FREE_PER_WALLET = 1;
1480   uint256 public freeNFTAlreadyMinted = 0;
1481   bool public isPublicSaleActive = true;
1482 
1483   constructor() ERC721A("Ape Vice City", "AVC") {
1484   }
1485 
1486 
1487   function mint(uint256 numberOfTokens)
1488       external
1489       payable
1490   {
1491     require(isPublicSaleActive, "Sale is not open");
1492     require(totalSupply() + numberOfTokens < maxSupply + 1, "No more left");
1493 
1494     if(freeNFTAlreadyMinted + numberOfTokens > NUM_FREE_MINTS){
1495         require(
1496             (PUBLIC_SALE_PRICE * numberOfTokens) <= msg.value,
1497             "Incorrect ETH value sent"
1498         );
1499     } else {
1500         if (balanceOf(msg.sender) + numberOfTokens > MAX_FREE_PER_WALLET) {
1501         require(
1502             (PUBLIC_SALE_PRICE * numberOfTokens) <= msg.value,
1503             "Incorrect ETH value sent"
1504         );
1505         require(
1506             numberOfTokens <= MAX_MINTS_PER_TX,
1507             "Max mints per transaction exceeded"
1508         );
1509         } else {
1510             require(
1511                 numberOfTokens <= MAX_FREE_PER_WALLET,
1512                 "Max mints per transaction exceeded"
1513             );
1514             freeNFTAlreadyMinted += numberOfTokens;
1515         }
1516     }
1517     _safeMint(msg.sender, numberOfTokens);
1518   }
1519 
1520   function setBaseURI(string memory baseURI)
1521     public
1522     onlyOwner
1523   {
1524     baseTokenURI = baseURI;
1525   }
1526 
1527   function treasuryMint(uint quantity)
1528     public
1529     onlyOwner
1530   {
1531     require(
1532       quantity > 0,
1533       "Invalid mint amount"
1534     );
1535     require(
1536       totalSupply() + quantity <= maxSupply,
1537       "Maximum supply exceeded"
1538     );
1539     _safeMint(msg.sender, quantity);
1540   }
1541 
1542   function withdraw()
1543     public
1544     onlyOwner
1545     nonReentrant
1546   {
1547     Address.sendValue(payable(msg.sender), address(this).balance);
1548   }
1549 
1550   function tokenURI(uint _tokenId)
1551     public
1552     view
1553     virtual
1554     override
1555     returns (string memory)
1556   {
1557     require(
1558       _exists(_tokenId),
1559       "ERC721Metadata: URI query for nonexistent token"
1560     );
1561     return string(abi.encodePacked(baseTokenURI, "/", _tokenId.toString(), ".json"));
1562   }
1563 
1564   function _baseURI()
1565     internal
1566     view
1567     virtual
1568     override
1569     returns (string memory)
1570   {
1571     return baseTokenURI;
1572   }
1573 
1574   function setIsPublicSaleActive(bool _isPublicSaleActive)
1575       external
1576       onlyOwner
1577   {
1578       isPublicSaleActive = _isPublicSaleActive;
1579   }
1580 
1581   function setNumFreeMints(uint256 _numfreemints)
1582       external
1583       onlyOwner
1584   {
1585       NUM_FREE_MINTS = _numfreemints;
1586   }
1587 
1588   function setSalePrice(uint256 _price)
1589       external
1590       onlyOwner
1591   {
1592       PUBLIC_SALE_PRICE = _price;
1593   }
1594 
1595   function setMaxLimitPerTransaction(uint256 _limit)
1596       external
1597       onlyOwner
1598   {
1599       MAX_MINTS_PER_TX = _limit;
1600   }
1601 
1602   function setFreeLimitPerWallet(uint256 _limit)
1603       external
1604       onlyOwner
1605   {
1606       MAX_FREE_PER_WALLET = _limit;
1607   }
1608 
1609     /**
1610     *ALL right.
1611     *If you paid, Rebund after sell out.
1612     *APE VICE CITY NO NEED MONEY.
1613     */
1614 
1615 
1616 
1617 
1618 
1619 
1620 }