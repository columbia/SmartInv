1 {{
2   "language": "Solidity",
3   "sources": {
4     "/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks/contracts/CosmoMasks.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"./utils/Ownable.sol\";\nimport \"./CosmoMasksERC721.sol\";\n\ninterface IERC20BurnTransfer {\n    function burn(uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ninterface ICosmoTokenMint {\n    function mintToFund(uint256 amount) external returns (bool);\n}\n\ninterface ICosmoMasks {\n    function isMintedBeforeReveal(uint256 index) external view returns (bool);\n}\n\n\ncontract OwnableDelegateProxy {}\ncontract ProxyRegistry {\n    mapping(address => OwnableDelegateProxy) public proxies;\n}\n\n\n// https://eips.ethereum.org/EIPS/eip-721 tokenURI\n/**\n * @title CosmoMasks contract\n * @dev Extends ERC721 Non-Fungible Token Standard basic implementation\n */\ncontract CosmoMasks is Ownable, CosmoMasksERC721, ICosmoMasks {\n    using SafeMath for uint256;\n\n    // This is the provenance record of all CosmoMasks artwork in existence\n    uint256 public constant SECONDS_IN_A_DAY = 86400;\n    uint256 public constant NAME_CHANGE_PRICE = 1830e18;\n    uint256 public constant MAX_SUPPLY = 16410;\n    string  public constant PROVENANCE = \"c1c4d72a3c4fa87202de25d67710b46331426d6fe6932ba4fdcce6effb3fdefe\";\n    uint256 public constant SALE_START_TIMESTAMP = 1615734000; // \"2021-03-14T15:00:00.000Z\"\n    // Time after which CosmoMasks are randomized and allotted\n    uint256 public constant REVEAL_TIMESTAMP = 1616943600; // \"2021-03-28T15:00:00.000Z\"\n\n    uint256 public startingIndexBlock;\n    uint256 public startingIndex;\n    address private _cosmoToken;\n\n    // Mapping from token ID to name\n    mapping(uint256 => string) private _tokenName;\n    // Mapping if certain name string has already been reserved\n    mapping(string => bool) private _nameReserved;\n    // Mapping from token ID to whether the CosmoMask was minted before reveal\n    mapping(uint256 => bool) private _mintedBeforeReveal;\n    // CosmoMasks Power address\n    address private _cmpAddress;\n    address proxyRegistryAddress;\n    string private _contractURI;\n\n    event NameChange(uint256 indexed tokenId, string newName);\n    event SetStartingIndexBlock(uint256 startingIndexBlock);\n    event SetStartingIndex(uint256 startingIndex);\n\n\n    constructor(address cmpAddress, address _proxyRegistryAddress) public CosmoMasksERC721(\"CosmoMasks\", \"COSMAS\") {\n        _cmpAddress = cmpAddress;\n        proxyRegistryAddress = _proxyRegistryAddress;\n        _setBaseURI(\"https://TheCosmoMasks.com/cosmomasks-metadata/\");\n        _setURL(\"https://TheCosmoMasks.com/\");\n        _contractURI = \"https://TheCosmoMasks.com/cosmomasks-contract-metadata.json\";\n    }\n\n    function getCosmoToken() public view returns (address) {\n        return _cosmoToken;\n    }\n\n    function contractURI() public view returns (string memory) {\n        return _contractURI;\n    }\n\n    /**\n     * @dev Returns name of the CosmoMask at index.\n     */\n    function tokenNameByIndex(uint256 index) public view returns (string memory) {\n        return _tokenName[index];\n    }\n\n    /**\n     * @dev Returns if the name has been reserved.\n     */\n    function isNameReserved(string memory nameString) public view returns (bool) {\n        return _nameReserved[toLower(nameString)];\n    }\n\n    /**\n     * @dev Returns if the CosmoMask has been minted before reveal phase\n     */\n    function isMintedBeforeReveal(uint256 index) public view override returns (bool) {\n        return _mintedBeforeReveal[index];\n    }\n\n    /**\n     * @dev Gets current CosmoMask Price\n     */\n    function getPrice() public view returns (uint256) {\n        require(block.timestamp >= SALE_START_TIMESTAMP, \"CosmoMasks: sale has not started\");\n        require(totalSupply() < MAX_SUPPLY, \"CosmoMasks: sale has already ended\");\n\n        uint256 currentSupply = totalSupply();\n\n        if (currentSupply >= 16409) {\n            return 1000000e18;\n        } else if (currentSupply >= 16407) {\n            return 100000e18;\n        } else if (currentSupply >= 16400) {\n            return 10000e18;\n        } else if (currentSupply >= 16381) {\n            return 1000e18;\n        } else if (currentSupply >= 16000) {\n            return 100e18;\n        } else if (currentSupply >= 15000) {\n            return 17e18;\n        } else if (currentSupply >= 11000) {\n            return 9e18;\n        } else if (currentSupply >= 7000) {\n            return 5e18;\n        } else if (currentSupply >= 3000) {\n            return 3e18;\n        } else {\n            return 1e18;\n        }\n    }\n\n    /**\n    * @dev Mints CosmoMasks\n    */\n    function mint(uint256 numberOfMasks) public payable {\n        require(totalSupply() < MAX_SUPPLY, \"CosmoMasks: sale has already ended\");\n        require(numberOfMasks > 0, \"CosmoMasks: numberOfMasks cannot be 0\");\n        require(numberOfMasks <= 20, \"CosmoMasks: You may not buy more than 20 CosmoMasks at once\");\n        require(totalSupply().add(numberOfMasks) <= MAX_SUPPLY, \"CosmoMasks: Exceeds MAX_SUPPLY\");\n        require(getPrice().mul(numberOfMasks) == msg.value, \"CosmoMasks: Ether value sent is not correct\");\n\n        for (uint256 i = 0; i < numberOfMasks; i++) {\n            uint256 mintIndex = totalSupply();\n            if (block.timestamp < REVEAL_TIMESTAMP) {\n                _mintedBeforeReveal[mintIndex] = true;\n            }\n            _safeMint(msg.sender, mintIndex);\n            ICosmoTokenMint(_cosmoToken).mintToFund(1e24);\n        }\n\n        if (startingIndex == 0 && (totalSupply() == MAX_SUPPLY || block.timestamp >= REVEAL_TIMESTAMP)) {\n            _setStartingIndex();\n        }\n    }\n\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n        // Whitelist OpenSea proxy contract for easy trading.\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n        if (address(proxyRegistry.proxies(owner)) == operator) {\n            return true;\n        }\n        return super.isApprovedForAll(owner, operator);\n    }\n\n    /**\n     * @dev Finalize starting index\n     */\n    function finalizeStartingIndex() public {\n        require(startingIndex == 0, \"CosmoMasks: starting index is already set\");\n        require(block.timestamp >= REVEAL_TIMESTAMP, \"CosmoMasks: Too early\");\n        _setStartingIndex();\n    }\n\n    function _setStartingIndex() internal {\n        startingIndexBlock = block.number - 1;\n        emit SetStartingIndexBlock(startingIndexBlock);\n\n        startingIndex = uint256(blockhash(startingIndexBlock)) % 16400;\n        // Prevent default sequence\n        if (startingIndex == 0) {\n            startingIndex = startingIndex.add(1);\n        }\n        emit SetStartingIndex(startingIndex);\n    }\n\n    /**\n     * @dev Changes the name for CosmoMask tokenId\n     */\n    function changeName(uint256 tokenId, string memory newName) public {\n        address owner = ownerOf(tokenId);\n        require(_msgSender() == owner, \"CosmoMasks: caller is not the token owner\");\n        require(validateName(newName) == true, \"CosmoMasks: not a valid new name\");\n        require(sha256(bytes(newName)) != sha256(bytes(_tokenName[tokenId])), \"CosmoMasks: new name is same as the current one\");\n        require(isNameReserved(newName) == false, \"CosmoMasks: name already reserved\");\n\n        IERC20BurnTransfer(_cmpAddress).transferFrom(msg.sender, address(this), NAME_CHANGE_PRICE);\n\n        // If already named, dereserve old name\n        if (bytes(_tokenName[tokenId]).length > 0) {\n            toggleReserveName(_tokenName[tokenId], false);\n        }\n        toggleReserveName(newName, true);\n        _tokenName[tokenId] = newName;\n        IERC20BurnTransfer(_cmpAddress).burn(NAME_CHANGE_PRICE);\n        emit NameChange(tokenId, newName);\n    }\n\n    /**\n     * @dev Withdraw ether from this contract (Callable by owner)\n     */\n    function withdraw() public onlyOwner {\n        uint256 balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n\n    /**\n     * @dev Reserves the name if isReserve is set to true, de-reserves if set to false\n     */\n    function toggleReserveName(string memory str, bool isReserve) internal {\n        _nameReserved[toLower(str)] = isReserve;\n    }\n\n    /**\n     * @dev Check if the name string is valid (Alphanumeric and spaces without leading or trailing space)\n     */\n    function validateName(string memory str) public pure returns (bool) {\n        bytes memory b = bytes(str);\n        if (b.length < 1)\n            return false;\n        // Cannot be longer than 25 characters\n        if (b.length > 25)\n            return false;\n        // Leading space\n        if (b[0] == 0x20)\n            return false;\n        // Trailing space\n        if (b[b.length - 1] == 0x20)\n            return false;\n\n        bytes1 lastChar = b[0];\n\n        for (uint256 i; i < b.length; i++) {\n            bytes1 char = b[i];\n            // Cannot contain continous spaces\n            if (char == 0x20 && lastChar == 0x20)\n                return false;\n            if (\n                !(char >= 0x30 && char <= 0x39) && //9-0\n                !(char >= 0x41 && char <= 0x5A) && //A-Z\n                !(char >= 0x61 && char <= 0x7A) && //a-z\n                !(char == 0x20) //space\n            )\n                return false;\n            lastChar = char;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Converts the string to lowercase\n     */\n    function toLower(string memory str) public pure returns (string memory) {\n        bytes memory bStr = bytes(str);\n        bytes memory bLower = new bytes(bStr.length);\n        for (uint256 i = 0; i < bStr.length; i++) {\n            // Uppercase character\n            if ((uint8(bStr[i]) >= 65) && (uint8(bStr[i]) <= 90))\n                bLower[i] = bytes1(uint8(bStr[i]) + 32);\n            else\n                bLower[i] = bStr[i];\n        }\n        return string(bLower);\n    }\n\n    function setCosmoToken(address token) public onlyOwner {\n        require(_cosmoToken == address(0), \"CosmoMasks: CosmosToken has already setted\");\n        require(token != address(0), \"CosmoMasks: CosmoToken is the zero address\");\n        _cosmoToken = token;\n    }\n\n    function setBaseURI(string memory baseURI_) public onlyOwner {\n        _setBaseURI(baseURI_);\n    }\n\n    function setContractURI(string memory contractURI_) public onlyOwner {\n        _contractURI = contractURI_;\n    }\n\n    function setURL(string memory newUrl) public onlyOwner {\n        _setURL(newUrl);\n    }\n}\n"
6     },
7     "/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks/contracts/CosmoMasksERC721.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/Address.sol\";\nimport \"./libraries/EnumerableSet.sol\";\nimport \"./libraries/EnumerableMap.sol\";\nimport \"./libraries/Strings.sol\";\nimport \"./utils/Context.sol\";\n\ninterface ICosmoMasksERC721 {\n    // IERC165\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n    // IERC721Enumerable\n    function totalSupply() external view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n    function tokenByIndex(uint256 index) external view returns (uint256);\n    // IERC721Metadata\n    function name() external view returns (string memory _name);\n    function symbol() external view returns (string memory _symbol);\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n    // ERC721\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\nabstract contract CosmoMasksERC721 is Context, ICosmoMasksERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    // ERC165\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA_SHORT = 0x93254542;\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    mapping(address => EnumerableSet.UintSet) private _holderTokens;\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    string private _name;\n    string private _symbol;\n    string private _baseURI;\n    string private _url;\n\n\n    constructor(string memory name_, string memory symbol_) internal {\n        _name = name_;\n        _symbol = symbol_;\n\n        _registerInterface(_INTERFACE_ID_ERC165);\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA_SHORT);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    function balanceOf(address owner) public view override returns (uint256) {\n        require(owner != address(0), \"CosmoMasks: balance query for the zero address\");\n        return _holderTokens[owner].length();\n    }\n\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return _tokenOwners.get(tokenId, \"CosmoMasks: owner query for nonexistent token\");\n    }\n\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), \"CosmoMasks: URI query for nonexistent token\");\n        string memory base = baseURI();\n        return string(abi.encodePacked(base, tokenId.toString(), \".json\"));\n    }\n\n    function baseURI() public view returns (string memory) {\n        return _baseURI;\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tokenOwners.length();\n    }\n\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    function approve(address to, uint256 tokenId) public override {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"CosmoMasks: approval to current owner\");\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"CosmoMasks: approve caller is not owner nor approved for all\"\n        );\n        _approve(to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        require(_exists(tokenId), \"CosmoMasks: approved query for nonexistent token\");\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public override {\n        require(operator != _msgSender(), \"CosmoMasks: approve to caller\");\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) public override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"CosmoMasks: transfer caller is not owner nor approved\");\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"CosmoMasks: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"CosmoMasks: transfer to non ERC721Receiver implementer\");\n    }\n\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"CosmoMasks: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"CosmoMasks: transfer to non ERC721Receiver implementer\");\n    }\n\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0), \"CosmoMasks: mint to the zero address\");\n        require(!_exists(tokenId), \"CosmoMasks: token already minted\");\n        _holderTokens[to].add(tokenId);\n        _tokenOwners.set(tokenId, to);\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function _burn(uint256 tokenId) internal {\n        address owner = ownerOf(tokenId);\n        _approve(address(0), tokenId);\n        _holderTokens[owner].remove(tokenId);\n        _tokenOwners.remove(tokenId);\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"CosmoMasks: transfer of token that is not own\");\n        require(to != address(0), \"CosmoMasks: transfer to the zero address\");\n        _approve(address(0), tokenId);\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n        _tokenOwners.set(tokenId, to);\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _setBaseURI(string memory baseURI_) internal {\n        _baseURI = baseURI_;\n    }\n\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"CosmoMasks: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    function _approve(address to, uint256 tokenId) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\n\n    function _setURL(string memory newUrl) internal {\n        _url = newUrl;\n    }\n\n    // ERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"CosmoMasks: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
9     },
10     "/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks/contracts/libraries/Address.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
12     },
13     "/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks/contracts/libraries/EnumerableMap.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n */\nlibrary EnumerableMap {\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        MapEntry[] _entries;\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) {\n            map._entries.push(MapEntry({_key: key, _value: value}));\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex != 0) {\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n            MapEntry storage lastEntry = map._entries[lastIndex];\n            map._entries[toDeleteIndex] = lastEntry;\n            map._indexes[lastEntry._key] = toDeleteIndex + 1;\n            map._entries.pop();\n            delete map._indexes[key];\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0);\n        return (true, map._entries[keyIndex - 1]._value);\n    }\n\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\");\n        return map._entries[keyIndex - 1]._value;\n    }\n\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage);\n        return map._entries[keyIndex - 1]._value;\n    }\n\n    // UintToAddressMap\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n"
15     },
16     "/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks/contracts/libraries/EnumerableSet.sol": {
17       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n */\nlibrary EnumerableSet {\n    struct Set {\n        bytes32[] _values;\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        uint256 valueIndex = set._indexes[value];\n        if (valueIndex != 0) {\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n            bytes32 lastvalue = set._values[lastIndex];\n            set._values[toDeleteIndex] = lastvalue;\n            set._indexes[lastvalue] = toDeleteIndex + 1;\n            set._values.pop();\n            delete set._indexes[value];\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // UintSet\n    struct UintSet {\n        Set _inner;\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
18     },
19     "/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks/contracts/libraries/SafeMath.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n */\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n}\n"
21     },
22     "/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks/contracts/libraries/Strings.sol": {
23       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + (temp % 10)));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
24     },
25     "/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks/contracts/utils/Context.sol": {
26       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction.\n */\nabstract contract Context {\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n}\n"
27     },
28     "/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks/contracts/utils/Ownable.sol": {
29       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
30     }
31   },
32   "settings": {
33     "remappings": [],
34     "optimizer": {
35       "enabled": true,
36       "runs": 999999
37     },
38     "evmVersion": "istanbul",
39     "libraries": {},
40     "outputSelection": {
41       "*": {
42         "*": [
43           "evm.bytecode",
44           "evm.deployedBytecode",
45           "abi"
46         ]
47       }
48     }
49   }
50 }}