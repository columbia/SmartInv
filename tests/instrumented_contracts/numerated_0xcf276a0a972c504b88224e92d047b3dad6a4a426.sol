1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/exchange/SmartWalletSwapProxy.sol": {
5       "content": "pragma solidity 0.6.6;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./SmartWalletSwapStorage.sol\";\n\n\ncontract SmartWalletSwapProxy is SmartWalletSwapStorage {\n    using Address for address;\n\n    event ImplementationUpdated(address indexed implementation);\n\n    constructor(\n        address _admin,\n        address _implementation,\n        IKyberProxy _proxy,\n        IUniswapV2Router02[] memory _routers\n    ) public SmartWalletSwapStorage(_admin) {\n        _setImplementation(_implementation);\n        kyberProxy = _proxy;\n        for (uint256 i = 0; i < _routers.length; i++) {\n            isRouterSupported[_routers[i]] = true;\n        }\n    }\n\n    function updateNewImplementation(address _implementation) external onlyAdmin {\n        _setImplementation(_implementation);\n        emit ImplementationUpdated(_implementation);\n    }\n\n    receive() external payable {}\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    fallback() external payable {\n        (bool success, ) = implementation().delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize())\n            switch success\n                case 0 {\n                    revert(free_mem_ptr, returndatasize())\n                }\n                default {\n                    return(free_mem_ptr, returndatasize())\n                }\n        }\n    }\n\n    function implementation() public view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    function _setImplementation(address _implementation) internal {\n        require(_implementation.isContract(), \"non-contract address\");\n\n        bytes32 slot = IMPLEMENTATION;\n        assembly {\n            sstore(slot, _implementation)\n        }\n    }\n}\n"
6     },
7     "@openzeppelin/contracts/utils/Address.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
9     },
10     "contracts/exchange/SmartWalletSwapStorage.sol": {
11       "content": "pragma solidity 0.6.6;\n\nimport \"../burnHelper/IBurnGasHelper.sol\";\nimport \"../interfaces/IKyberProxy.sol\";\nimport \"../interfaces/IGasToken.sol\";\nimport \"../lending/ISmartWalletLending.sol\";\nimport \"@kyber.network/utils-sc/contracts/IERC20Ext.sol\";\nimport \"@kyber.network/utils-sc/contracts/Utils.sol\";\nimport \"@kyber.network/utils-sc/contracts/Withdrawable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\n\n\ncontract SmartWalletSwapStorage is Utils, Withdrawable, ReentrancyGuard {\n\n    uint256 constant internal MAX_AMOUNT = uint256(-1);\n\n    mapping (address => mapping(IERC20Ext => uint256)) public platformWalletFees;\n    // Proxy and routers will be set only once in constructor\n    IKyberProxy public kyberProxy;\n    // check if a router (Uniswap or its clones) is supported\n    mapping(IUniswapV2Router02 => bool) public isRouterSupported;\n\n    IBurnGasHelper public burnGasHelper;\n    mapping (address => bool) public supportedPlatformWallets;\n\n    struct TradeInput {\n        uint256 srcAmount;\n        uint256 minData; // min rate if Kyber, min return if Uni-pools\n        address payable recipient;\n        uint256 platformFeeBps;\n        address payable platformWallet;\n        bytes hint;\n    }\n\n    ISmartWalletLending public lendingImpl;\n\n    // bytes32(uint256(keccak256(\"SmartWalletSwapImplementation\")) - 1)\n    bytes32 internal constant IMPLEMENTATION = 0x6a7efb0627ddb0e69b773958c7c9c3c9c3dc049819cdf56a8ee84c3074b2a5d7;\n\n    constructor(address _admin) public Withdrawable(_admin) {}\n}\n"
12     },
13     "contracts/burnHelper/IBurnGasHelper.sol": {
14       "content": "pragma solidity 0.6.6;\n\n\ninterface IBurnGasHelper {\n    function getAmountGasTokensToBurn(uint256 gasTotalConsumption)\n        external\n        view\n        returns (uint256 numGas, address gasToken);\n}\n"
15     },
16     "contracts/interfaces/IKyberProxy.sol": {
17       "content": "pragma solidity 0.6.6;\n\nimport \"@kyber.network/utils-sc/contracts/IERC20Ext.sol\";\n\n\ninterface IKyberProxy {\n\n    function tradeWithHintAndFee(\n        IERC20 src,\n        uint256 srcAmount,\n        IERC20 dest,\n        address payable destAddress,\n        uint256 maxDestAmount,\n        uint256 minConversionRate,\n        address payable platformWallet,\n        uint256 platformFeeBps,\n        bytes calldata hint\n    ) external payable returns (uint256 destAmount);\n\n    function getExpectedRateAfterFee(\n        IERC20 src,\n        IERC20 dest,\n        uint256 srcQty,\n        uint256 platformFeeBps,\n        bytes calldata hint\n    ) external view returns (uint256 expectedRate);\n}\n"
18     },
19     "contracts/interfaces/IGasToken.sol": {
20       "content": "pragma solidity 0.6.6;\n\ninterface IGasToken {\n    function mint(uint256 value) external;\n    function freeUpTo(uint256 value) external returns (uint256 freed);\n\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\n\n    function balanceOf(address who) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool success);\n    function transferFrom(address from, address to, uint256 value) external returns (bool success);\n    function approve(address spender, uint256 value) external returns (bool success);\n}\n"
21     },
22     "contracts/lending/ISmartWalletLending.sol": {
23       "content": "pragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\nimport \"@kyber.network/utils-sc/contracts/IERC20Ext.sol\";\nimport \"../interfaces/IAaveLendingPoolV2.sol\";\nimport \"../interfaces/IAaveLendingPoolV1.sol\";\nimport \"../interfaces/IWeth.sol\";\nimport \"../interfaces/ICompErc20.sol\";\n\n\ninterface ISmartWalletLending {\n\n    event ClaimedComp(\n        address[] holders,\n        ICompErc20[] cTokens,\n        bool borrowers,\n        bool suppliers\n    );\n\n    enum LendingPlatform { AAVE_V1, AAVE_V2, COMPOUND }\n\n    struct UserReserveData {\n        uint256 currentATokenBalance;\n        uint256 liquidityRate;\n        uint256 poolShareInPrecision;\n        bool usageAsCollateralEnabled;\n        // Aave v1 data\n        uint256 currentBorrowBalance;\n        uint256 principalBorrowBalance;\n        uint256 borrowRateMode;\n        uint256 borrowRate;\n        uint256 originationFee;\n        // Aave v2 data\n        uint256 currentStableDebt;\n        uint256 currentVariableDebt;\n        uint256 principalStableDebt;\n        uint256 scaledVariableDebt;\n        uint256 stableBorrowRate;\n    }\n\n    function updateAaveLendingPoolData(\n        IAaveLendingPoolV2 poolV2,\n        IProtocolDataProvider provider,\n        IAaveLendingPoolV1 poolV1,\n        address lendingPoolCoreV1,\n        uint16 referalCode,\n        IWeth weth,\n        IERC20Ext[] calldata tokens\n    ) external;\n\n    function updateCompoundData(\n        address _comptroller,\n        address _cEth,\n        address[] calldata _cTokens\n    ) external;\n\n    function depositTo(\n        LendingPlatform platform,\n        address payable onBehalfOf,\n        IERC20Ext token,\n        uint256 amount\n    ) external;\n\n    function borrowFrom(\n        LendingPlatform platform,\n        address payable onBehalfOf,\n        IERC20Ext token,\n        uint256 borrowAmount,\n        uint256 interestRateMode\n    ) external;\n\n    function withdrawFrom(\n        LendingPlatform platform,\n        address payable onBehalfOf,\n        IERC20Ext token,\n        uint256 amount,\n        uint256 minReturn\n    ) external returns (uint256 returnedAmount);\n\n    function repayBorrowTo(\n        LendingPlatform platform,\n        address payable onBehalfOf,\n        IERC20Ext token,\n        uint256 amount,\n        uint256 payAmount,\n        uint256 rateMode // only for aave v2\n    ) external;\n    \n    function claimComp(\n        address[] calldata holders,\n        ICompErc20[] calldata cTokens,\n        bool borrowers,\n        bool suppliers\n    ) external;\n\n    function storeAndRetrieveUserDebtCurrent(\n        LendingPlatform platform,\n        address _reserve,\n        address _user\n    ) external returns (uint256 debt);\n\n    function getLendingToken(LendingPlatform platform, IERC20Ext token) external view returns(address);\n\n    function getUserDebtStored(LendingPlatform platform, address reserve, address user)\n        external\n        view\n        returns (uint256 debt);\n}\n"
24     },
25     "@kyber.network/utils-sc/contracts/IERC20Ext.sol": {
26       "content": "pragma solidity 0.6.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\n/**\n * @dev Interface extending ERC20 standard to include decimals() as\n *      it is optional in the OpenZeppelin IERC20 interface.\n */\ninterface IERC20Ext is IERC20 {\n    /**\n     * @dev This function is required as Kyber requires to interact\n     *      with token.decimals() with many of its operations.\n     */\n    function decimals() external view returns (uint8 digits);\n}\n"
27     },
28     "@kyber.network/utils-sc/contracts/Utils.sol": {
29       "content": "pragma solidity 0.6.6;\n\nimport \"./IERC20Ext.sol\";\n\n\n/**\n * @title Kyber utility file\n * mostly shared constants and rate calculation helpers\n * inherited by most of kyber contracts.\n * previous utils implementations are for previous solidity versions.\n */\ncontract Utils {\n    /// Declared constants below to be used in tandem with\n    /// getDecimalsConstant(), for gas optimization purposes\n    /// which return decimals from a constant list of popular\n    /// tokens.\n    IERC20Ext internal constant ETH_TOKEN_ADDRESS = IERC20Ext(\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n    );\n    IERC20Ext internal constant USDT_TOKEN_ADDRESS = IERC20Ext(\n        0xdAC17F958D2ee523a2206206994597C13D831ec7\n    );\n    IERC20Ext internal constant DAI_TOKEN_ADDRESS = IERC20Ext(\n        0x6B175474E89094C44Da98b954EedeAC495271d0F\n    );\n    IERC20Ext internal constant USDC_TOKEN_ADDRESS = IERC20Ext(\n        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n    );\n    IERC20Ext internal constant WBTC_TOKEN_ADDRESS = IERC20Ext(\n        0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\n    );\n    IERC20Ext internal constant KNC_TOKEN_ADDRESS = IERC20Ext(\n        0xdd974D5C2e2928deA5F71b9825b8b646686BD200\n    );\n    uint256 public constant BPS = 10000; // Basic Price Steps. 1 step = 0.01%\n    uint256 internal constant PRECISION = (10**18);\n    uint256 internal constant MAX_QTY = (10**28); // 10B tokens\n    uint256 internal constant MAX_RATE = (PRECISION * 10**7); // up to 10M tokens per eth\n    uint256 internal constant MAX_DECIMALS = 18;\n    uint256 internal constant ETH_DECIMALS = 18;\n    uint256 internal constant MAX_ALLOWANCE = uint256(-1); // token.approve inifinite\n\n    mapping(IERC20Ext => uint256) internal decimals;\n\n    /// @dev Sets the decimals of a token to storage if not already set, and returns\n    ///      the decimals value of the token. Prefer using this function over\n    ///      getDecimals(), to avoid forgetting to set decimals in local storage.\n    /// @param token The token type\n    /// @return tokenDecimals The decimals of the token\n    function getSetDecimals(IERC20Ext token) internal returns (uint256 tokenDecimals) {\n        tokenDecimals = getDecimalsConstant(token);\n        if (tokenDecimals > 0) return tokenDecimals;\n\n        tokenDecimals = decimals[token];\n        if (tokenDecimals == 0) {\n            tokenDecimals = token.decimals();\n            decimals[token] = tokenDecimals;\n        }\n    }\n\n    /// @dev Get the balance of a user\n    /// @param token The token type\n    /// @param user The user's address\n    /// @return The balance\n    function getBalance(IERC20Ext token, address user) internal view returns (uint256) {\n        if (token == ETH_TOKEN_ADDRESS) {\n            return user.balance;\n        } else {\n            return token.balanceOf(user);\n        }\n    }\n\n    /// @dev Get the decimals of a token, read from the constant list, storage,\n    ///      or from token.decimals(). Prefer using getSetDecimals when possible.\n    /// @param token The token type\n    /// @return tokenDecimals The decimals of the token\n    function getDecimals(IERC20Ext token) internal view returns (uint256 tokenDecimals) {\n        // return token decimals if has constant value\n        tokenDecimals = getDecimalsConstant(token);\n        if (tokenDecimals > 0) return tokenDecimals;\n\n        // handle case where token decimals is not a declared decimal constant\n        tokenDecimals = decimals[token];\n        // moreover, very possible that old tokens have decimals 0\n        // these tokens will just have higher gas fees.\n        return (tokenDecimals > 0) ? tokenDecimals : token.decimals();\n    }\n\n    function calcDestAmount(\n        IERC20Ext src,\n        IERC20Ext dest,\n        uint256 srcAmount,\n        uint256 rate\n    ) internal view returns (uint256) {\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\n    }\n\n    function calcSrcAmount(\n        IERC20Ext src,\n        IERC20Ext dest,\n        uint256 destAmount,\n        uint256 rate\n    ) internal view returns (uint256) {\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\n    }\n\n    function calcDstQty(\n        uint256 srcQty,\n        uint256 srcDecimals,\n        uint256 dstDecimals,\n        uint256 rate\n    ) internal pure returns (uint256) {\n        require(srcQty <= MAX_QTY, \"srcQty > MAX_QTY\");\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\n\n        if (dstDecimals >= srcDecimals) {\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\n        } else {\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\n        }\n    }\n\n    function calcSrcQty(\n        uint256 dstQty,\n        uint256 srcDecimals,\n        uint256 dstDecimals,\n        uint256 rate\n    ) internal pure returns (uint256) {\n        require(dstQty <= MAX_QTY, \"dstQty > MAX_QTY\");\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\n\n        //source quantity is rounded up. to avoid dest quantity being too low.\n        uint256 numerator;\n        uint256 denominator;\n        if (srcDecimals >= dstDecimals) {\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\n            denominator = rate;\n        } else {\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\n            numerator = (PRECISION * dstQty);\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\n        }\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\n    }\n\n    function calcRateFromQty(\n        uint256 srcAmount,\n        uint256 destAmount,\n        uint256 srcDecimals,\n        uint256 dstDecimals\n    ) internal pure returns (uint256) {\n        require(srcAmount <= MAX_QTY, \"srcAmount > MAX_QTY\");\n        require(destAmount <= MAX_QTY, \"destAmount > MAX_QTY\");\n\n        if (dstDecimals >= srcDecimals) {\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\n            return ((destAmount * PRECISION) / ((10**(dstDecimals - srcDecimals)) * srcAmount));\n        } else {\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\n            return ((destAmount * PRECISION * (10**(srcDecimals - dstDecimals))) / srcAmount);\n        }\n    }\n\n    /// @dev save storage access by declaring token decimal constants\n    /// @param token The token type\n    /// @return token decimals\n    function getDecimalsConstant(IERC20Ext token) internal pure returns (uint256) {\n        if (token == ETH_TOKEN_ADDRESS) {\n            return ETH_DECIMALS;\n        } else if (token == USDT_TOKEN_ADDRESS) {\n            return 6;\n        } else if (token == DAI_TOKEN_ADDRESS) {\n            return 18;\n        } else if (token == USDC_TOKEN_ADDRESS) {\n            return 6;\n        } else if (token == WBTC_TOKEN_ADDRESS) {\n            return 8;\n        } else if (token == KNC_TOKEN_ADDRESS) {\n            return 18;\n        } else {\n            return 0;\n        }\n    }\n\n    function minOf(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x > y ? y : x;\n    }\n}\n"
30     },
31     "@kyber.network/utils-sc/contracts/Withdrawable.sol": {
32       "content": "pragma solidity 0.6.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./IERC20Ext.sol\";\nimport \"./PermissionGroups.sol\";\n\ncontract Withdrawable is PermissionGroups {\n    using SafeERC20 for IERC20Ext;\n\n    event TokenWithdraw(IERC20Ext token, uint256 amount, address sendTo);\n    event EtherWithdraw(uint256 amount, address sendTo);\n\n    constructor(address _admin) public PermissionGroups(_admin) {}\n\n    /**\n     * @dev Withdraw all IERC20Ext compatible tokens\n     * @param token IERC20Ext The address of the token contract\n     */\n    function withdrawToken(\n        IERC20Ext token,\n        uint256 amount,\n        address sendTo\n    ) external onlyAdmin {\n        token.safeTransfer(sendTo, amount);\n        emit TokenWithdraw(token, amount, sendTo);\n    }\n\n    /**\n     * @dev Withdraw Ethers\n     */\n    function withdrawEther(uint256 amount, address payable sendTo) external onlyAdmin {\n        (bool success, ) = sendTo.call{value: amount}(\"\");\n        require(success, \"withdraw failed\");\n        emit EtherWithdraw(amount, sendTo);\n    }\n}\n"
33     },
34     "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
36     },
37     "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
38       "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
39     },
40     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
41       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
42     },
43     "contracts/interfaces/IAaveLendingPoolV2.sol": {
44       "content": "pragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\nimport \"../wrappers/AAVE/DataTypes.sol\";\nimport \"../wrappers/AAVE/IProtocolDataProvider.sol\";\n\n\ninterface IAaveLendingPoolV2 {\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     **/\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @return The final amount repaid\n     **/\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 rateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n     * @param asset The address of the underlying asset deposited\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n     **/\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n    /**\n     * @dev Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state of the reserve\n     **/\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n}\n"
45     },
46     "contracts/interfaces/IAaveLendingPoolV1.sol": {
47       "content": "pragma solidity 0.6.6;\n\n\ninterface IAaveLendingPoolV1 {\n    function deposit(\n        address _reserve,\n        uint256 _amount,\n        uint16 _referralCode\n    ) external payable;\n\n    function borrow(\n        address _reserve,\n        uint256 _amount,\n        uint256 _interestRateMode,\n        uint16 _referralCode\n    ) external;\n\n    function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external;\n\n    function repay(\n        address _reserve,\n        uint256 _amount,\n        address payable _onBehalfOf\n    ) external payable;\n\n    function core() external view returns (address);\n\n    function getUserReserveData(address _reserve, address _user)\n        external\n        view\n        returns (\n            uint256 currentATokenBalance,\n            uint256 currentBorrowBalance,\n            uint256 principalBorrowBalance,\n            uint256 borrowRateMode,\n            uint256 borrowRate,\n            uint256 liquidityRate,\n            uint256 originationFee,\n            uint256 variableBorrowIndex,\n            uint256 lastUpdateTimestamp,\n            bool usageAsCollateralEnabled\n        );\n}\n\ninterface IAToken {\n    function redeem(uint256 _amount) external;\n}\n"
48     },
49     "contracts/interfaces/IWeth.sol": {
50       "content": "pragma solidity 0.6.6;\n\nimport \"@kyber.network/utils-sc/contracts/IERC20Ext.sol\";\n\n\ninterface IWeth is IERC20Ext {\n    function deposit() external payable;\n    function withdraw(uint256 wad) external;\n}\n"
51     },
52     "contracts/interfaces/ICompErc20.sol": {
53       "content": "pragma solidity 0.6.6;\n\n\ninterface ICompErc20 {\n    function mint(uint mintAmount) external returns (uint);\n    function redeem(uint redeemTokens) external returns (uint);\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n    function borrow(uint borrowAmount) external returns (uint);\n    function repayBorrow(uint repayAmount) external returns (uint);\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\n\n    function transfer(address dst, uint amount) external returns (bool);\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\n    function approve(address spender, uint amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function balanceOfUnderlying(address owner) external returns (uint);\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n    function totalBorrowsCurrent() external returns (uint);\n    function borrowBalanceCurrent(address account) external returns (uint);\n    function borrowBalanceStored(address account) external view returns (uint);\n    function exchangeRateCurrent() external returns (uint);\n    function exchangeRateStored() external view returns (uint);\n    function underlying() external view returns (address);\n}\n\ninterface ICompEth {\n    function mint() external payable;\n    function repayBorrowBehalf(address borrower) external payable;\n    function repayBorrow() external payable;\n}\n"
54     },
55     "contracts/wrappers/AAVE/DataTypes.sol": {
56       "content": "pragma solidity 0.6.6;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    uint256 data;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n}\n"
57     },
58     "contracts/wrappers/AAVE/IProtocolDataProvider.sol": {
59       "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface IProtocolDataProvider {\n  struct TokenData {\n    string symbol;\n    address tokenAddress;\n  }\n\n  function getAllReservesTokens() external view returns (TokenData[] memory);\n  function getAllATokens() external view returns (TokenData[] memory);\n  function getReserveConfigurationData(address asset)\n    external view returns(\n        uint256 decimals,\n        uint256 ltv,\n        uint256 liquidationThreshold,\n        uint256 liquidationBonus,\n        uint256 reserveFactor,\n        bool usageAsCollateralEnabled,\n        bool borrowingEnabled,\n        bool stableBorrowRateEnabled,\n        bool isActive,\n        bool isFrozen\n    );\n  function getReserveData(address asset)\n    external view returns (\n        uint256 availableLiquidity,\n        uint256 totalStableDebt,\n        uint256 totalVariableDebt,\n        uint256 liquidityRate,\n        uint256 variableBorrowRate,\n        uint256 stableBorrowRate,\n        uint256 averageStableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex,\n        uint40 lastUpdateTimestamp\n    );\n  function getUserReserveData(address asset, address user)\n    external view returns (\n        uint256 currentATokenBalance,\n        uint256 currentStableDebt,\n        uint256 currentVariableDebt,\n        uint256 principalStableDebt,\n        uint256 scaledVariableDebt,\n        uint256 stableBorrowRate,\n        uint256 liquidityRate,\n        uint40 stableRateLastUpdated,\n        bool usageAsCollateralEnabled\n    );\n  function getReserveTokensAddresses(address asset)\n    external view returns (\n        address aTokenAddress,\n        address stableDebtTokenAddress,\n        address variableDebtTokenAddress\n    );\n  function calculateUserGlobalData(address _user)\n    external\n    view\n    returns (\n        uint256 totalLiquidityBalanceETH,\n        uint256 totalCollateralBalanceETH,\n        uint256 totalBorrowBalanceETH,\n        uint256 totalFeesETH,\n        uint256 currentLtv,\n        uint256 currentLiquidationThreshold,\n        uint256 healthFactor,\n        bool healthFactorBelowThreshold\n    );\n}\n"
60     },
61     "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
62       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
63     },
64     "@kyber.network/utils-sc/contracts/PermissionGroups.sol": {
65       "content": "pragma solidity 0.6.6;\n\ncontract PermissionGroups {\n    uint256 internal constant MAX_GROUP_SIZE = 50;\n\n    address public admin;\n    address public pendingAdmin;\n    mapping(address => bool) internal operators;\n    mapping(address => bool) internal alerters;\n    address[] internal operatorsGroup;\n    address[] internal alertersGroup;\n\n    event AdminClaimed(address newAdmin, address previousAdmin);\n\n    event TransferAdminPending(address pendingAdmin);\n\n    event OperatorAdded(address newOperator, bool isAdd);\n\n    event AlerterAdded(address newAlerter, bool isAdd);\n\n    constructor(address _admin) public {\n        require(_admin != address(0), \"admin 0\");\n        admin = _admin;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"only admin\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operators[msg.sender], \"only operator\");\n        _;\n    }\n\n    modifier onlyAlerter() {\n        require(alerters[msg.sender], \"only alerter\");\n        _;\n    }\n\n    function getOperators() external view returns (address[] memory) {\n        return operatorsGroup;\n    }\n\n    function getAlerters() external view returns (address[] memory) {\n        return alertersGroup;\n    }\n\n    /**\n     * @dev Allows the current admin to set the pendingAdmin address.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdmin(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0), \"new admin 0\");\n        emit TransferAdminPending(newAdmin);\n        pendingAdmin = newAdmin;\n    }\n\n    /**\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0), \"admin 0\");\n        emit TransferAdminPending(newAdmin);\n        emit AdminClaimed(newAdmin, admin);\n        admin = newAdmin;\n    }\n\n    /**\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\n     */\n    function claimAdmin() public {\n        require(pendingAdmin == msg.sender, \"not pending\");\n        emit AdminClaimed(pendingAdmin, admin);\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n    function addAlerter(address newAlerter) public onlyAdmin {\n        require(!alerters[newAlerter], \"alerter exists\"); // prevent duplicates.\n        require(alertersGroup.length < MAX_GROUP_SIZE, \"max alerters\");\n\n        emit AlerterAdded(newAlerter, true);\n        alerters[newAlerter] = true;\n        alertersGroup.push(newAlerter);\n    }\n\n    function removeAlerter(address alerter) public onlyAdmin {\n        require(alerters[alerter], \"not alerter\");\n        alerters[alerter] = false;\n\n        for (uint256 i = 0; i < alertersGroup.length; ++i) {\n            if (alertersGroup[i] == alerter) {\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\n                alertersGroup.pop();\n                emit AlerterAdded(alerter, false);\n                break;\n            }\n        }\n    }\n\n    function addOperator(address newOperator) public onlyAdmin {\n        require(!operators[newOperator], \"operator exists\"); // prevent duplicates.\n        require(operatorsGroup.length < MAX_GROUP_SIZE, \"max operators\");\n\n        emit OperatorAdded(newOperator, true);\n        operators[newOperator] = true;\n        operatorsGroup.push(newOperator);\n    }\n\n    function removeOperator(address operator) public onlyAdmin {\n        require(operators[operator], \"not operator\");\n        operators[operator] = false;\n\n        for (uint256 i = 0; i < operatorsGroup.length; ++i) {\n            if (operatorsGroup[i] == operator) {\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n                operatorsGroup.pop();\n                emit OperatorAdded(operator, false);\n                break;\n            }\n        }\n    }\n}\n"
66     },
67     "@openzeppelin/contracts/math/SafeMath.sol": {
68       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
69     },
70     "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
71       "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
72     }
73   },
74   "settings": {
75     "optimizer": {
76       "enabled": true,
77       "runs": 200
78     },
79     "outputSelection": {
80       "*": {
81         "*": [
82           "evm.bytecode",
83           "evm.deployedBytecode",
84           "abi"
85         ]
86       }
87     },
88     "libraries": {}
89   }
90 }}