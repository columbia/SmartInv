1 {"Addresses.sol":{"content":"pragma solidity 0.5.17;\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n  \n\n  /**\n   * Returns whether the target address is a contract\n   * @dev This function will return false if invoked during the constructor of a contract,\n   * as the code is not actually created until after the constructor finishes.\n   * @param account address to check\n   * @return whether the target address is a contract\n   */\n  function isContract(address account) internal view returns (bool) {\n      // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n      // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n      // for accounts without code, i.e. `keccak256(\u0027\u0027)`\n      bytes32 codehash;\n      bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n      // solhint-disable-next-line no-inline-assembly\n      assembly { codehash := extcodehash(account) }\n      return (codehash != accountHash \u0026\u0026 codehash != 0x0);\n  }\n\n}"},"BaseERC721.sol":{"content":"pragma solidity 0.5.17;\n\nimport \"./ERC721Token.sol\";\nimport \"./ERC20Interface.sol\";\nimport \"./Freezable.sol\";\n\n/**\n * @title Base ERC721 token\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\n * This contract implements basic ERC721 token functionality with bulk functionalities\n */\ncontract BaseERC721 is ERC721Token, Freezable {\n\n  constructor(string memory name, string memory symbol, string memory _baseTokenURI) public  ERC721Token(name, symbol){\n    baseTokenURI = _baseTokenURI;\n  }\n\n  /**\n   * @dev Updates the base URL of token\n   * Reverts if the sender is not owner\n   * @param _newURI New base URL\n   */\n  function updateBaseTokenURI(string memory _newURI)\n    public\n    onlyOwner\n    noEmergencyFreeze\n  {\n    baseTokenURI = _newURI;\n  }\n\n  /**\n   * @dev Mints new token on blockchain\n   * Reverts if the sender is not operator with level 1\n   * @param _id Id of NFT to be minted\n   * @dev URI is not provided because URI will be deducted based on baseURL\n   */\n  function mint(uint256 _id, address _to)\n    public\n    onlyDeputyOrOwner\n    noEmergencyFreeze\n    returns (bool)\n  {\n    super._mint(_to, _id);\n    return true;\n  }\n\n  function bulkMint(uint[] memory _ids, address[] memory _users)\n    public\n    onlyDeputyOrOwner\n    noEmergencyFreeze\n    returns (bool)\n  {\n    require(_ids.length == _users.length, \"Invalid params\");\n    for(uint i=0; i\u003c_ids.length; i++) {\n      super._mint(_users[i], _ids[i]);\n    }\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens (similar to ERC-20 transfer)\n   * Reverts if the sender is not owner of the NFT or approved\n   * @param _to address to which token is transferred\n   * @param _tokenId Id of NFT being transferred\n   */\n  function transfer(address _to, uint256 _tokenId)\n    public\n    noEmergencyFreeze\n    returns (bool)\n  {\n    safeTransferFrom(msg.sender, _to, _tokenId);\n    return true;\n  }\n\n  /**\n   * @dev Burn an existing NFT\n   * @param _id Id of NFT to be burned\n   */\n  function burn(uint _id)\n    public\n    noEmergencyFreeze\n    returns (bool)\n  {\n    super._burn(msg.sender, _id);\n    return true;\n  }\n\n  //////////////////////////////////////////\n  // PUBLICLY ACCESSIBLE METHODS (CONSTANT)\n  //////////////////////////////////////////\n\n}"},"CustomERC721.sol":{"content":"/**\n * This is custom ERC-721 token with some add on functionalities\n*/\n\npragma solidity 0.5.17;\n\nimport \"./BaseERC721.sol\";\n\n/**\n * @title CustomERC721\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\n */\ncontract CustomERC721 is BaseERC721 {\n\n  // mapping for replay protection\n  mapping(address =\u003e uint) private userNonce;\n\n  bool public isNormalUserAllowed; // can normal user access advanced features\n  \n  constructor(string memory name, string memory symbol, string memory baseURI) public BaseERC721(name, symbol, baseURI) {\n    isNormalUserAllowed = false;\n  }\n\n  modifier canAccessProvableFunctions() {\n    require(isNormalUserAllowed || msg.sender == owner || isDeputyOwner[msg.sender], \"Not allowed to access provable fns\");\n    _;\n  }\n\n  /**\n   * @dev Allows normal users to call provable fns\n   * Reverts if the sender is not owner of contract\n   * @param _perm permission to users\n   */\n  function allowNormalUser(bool _perm)\n    public \n    onlyOwner\n  {\n    isNormalUserAllowed = _perm;\n  }\n  \n  /**\n   * @dev Allows submitting already signed transaction\n   * Reverts if the signed data is incorrect\n   * @param message signed message by user\n   * @param r signature\n   * @param s signature\n   * @param v recovery id of signature\n   * @param spender address which is approved\n   * @param approved bool value for status of approval\n   * message should be hash(functionWord, contractAddress, nonce, fnParams)\n   */\n  function provable_setApprovalForAll(bytes32 message, bytes32 r, bytes32 s, uint8 v, address spender, bool approved)\n    public\n    noEmergencyFreeze\n    canAccessProvableFunctions\n  {\n    address signer = getSigner(message, r, s, v);\n    require (signer != address(0), \"Invalid signer\");\n\n    bytes32 proof = getMessageSetApprovalForAll(signer, spender, approved);\n    require(proof == message, \"Invalid proof\");\n\n    // perform the original set Approval\n    operatorApprovals[signer][spender] = approved;\n    emit ApprovalForAll(signer, spender, approved);\n    userNonce[signer] = userNonce[signer].add(1);\n  }\n\n  /**\n   * @dev Allows submitting already signed transaction for NFT transfer\n   * Reverts if the signed data is incorrect\n   * @param message signed message by user\n   * @param r signature\n   * @param s signature\n   * @param v recovery id of signature\n   * @param to recipient address\n   * @param tokenId ID of NFT\n   * message should be hash(functionWord, contractAddress, nonce, fnParams)\n   */\n  function provable_transfer(bytes32 message, bytes32 r, bytes32 s, uint8 v, address to, uint tokenId)\n    public \n    noEmergencyFreeze\n    canAccessProvableFunctions\n  {\n    address signer = getSigner(message, r, s, v);\n    require (signer != address(0),\"Invalid signer\");\n\n    bytes32 proof = getMessageTransfer(signer, to, tokenId);\n    require (proof == message, \"Invalid proof\");\n    \n    // Execute original function\n    require(to != address(0), \"Zero address not allowed\");\n    clearApproval(signer, tokenId);\n    removeTokenFrom(signer, tokenId);\n    addTokenTo(to, tokenId);\n    emit Transfer(signer, to, tokenId);\n\n    // update state variables\n    userNonce[signer] = userNonce[signer].add(1);\n  }\n\n  /**\n   * @dev Check signer of a message\n   * @param message signed message by user\n   * @param r signature\n   * @param s signature\n   * @param v recovery id of signature\n   * @return signer of message\n   */\n  function getSigner(bytes32 message, bytes32 r, bytes32 s,  uint8 v) public pure returns (address){\n    bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n    bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, message));\n    address signer = ecrecover(prefixedHash,v,r,s);\n    return signer;\n  }\n\n  /**\n   * @dev Get message to be signed for transfer\n   * @param signer of message\n   * @param to recipient address\n   * @param id NFT id\n   * @return hash of (functionWord, contractAddress, nonce, ...fnParams)\n   */\n  function getMessageTransfer(address signer, address to, uint id)\n    public\n    view\n    returns (bytes32) \n  {\n    return keccak256(abi.encodePacked(\n      bytes4(0xb483afd3),\n      address(this),\n      userNonce[signer],\n      to,\n      id\n    ));\n  }\n\n  /**\n   * @dev Get message to be signed for set Approval\n   * @param signer of message\n   * @param spender address which is approved\n   * @param approved bool value for status of approval\n   * @return hash of (functionWord, contractAddress, nonce, ...fnParams)\n   */\n  function getMessageSetApprovalForAll(address signer, address spender, bool approved)\n    public \n    view \n    returns (bytes32)\n  {\n    bytes32 proof = keccak256(abi.encodePacked(\n      bytes4(0xbad4c8ea),\n      address(this),\n      userNonce[signer],\n      spender,\n      approved\n    ));\n    return proof;\n  }\n\n  /**\n  * returns nonce of user to be used for next signing\n  */\n  function getUserNonce(address user) public view returns (uint) {\n    return userNonce[user];\n  }\n\n  /**\n   * @dev Owner can transfer out any accidentally sent ERC20 tokens\n   * @param contractAddress ERC20 contract address\n   * @param to withdrawal address\n   * @param value no of tokens to be withdrawan\n   */\n  function transferAnyERC20Token(address contractAddress, address to,  uint value) public onlyOwner {\n    ERC20Interface(contractAddress).transfer(to, value);\n  }\n\n  /**\n   * @dev Owner can transfer out any accidentally sent ERC721 tokens\n   * @param contractAddress ERC721 contract address\n   * @param to withdrawal address\n   * @param tokenId Id of 721 token\n   */\n  function withdrawAnyERC721Token(address contractAddress, address to, uint tokenId) public onlyOwner {\n    ERC721Basic(contractAddress).safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @dev Owner kill the smart contract\n   * @param message Confirmation message to prevent accidebtal calling\n   * @notice BE VERY CAREFULL BEFORE CALLING THIS FUNCTION\n   * Better pause the contract\n   * DO CALL \"transferAnyERC20Token\" before TO WITHDRAW ANY ERC-2O\u0027s FROM CONTRACT\n   */\n  function kill(uint message) public onlyOwner {\n    require (message == 123456789987654321, \"Invalid code\");\n    // Transfer Eth to owner and terminate contract\n    selfdestruct(msg.sender);\n  }\n\n}"},"ERC165.sol":{"content":"pragma solidity 0.5.17;\n\n/**\n * @title ERC165\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface ERC165 {\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceId The interface identifier, as specified in ERC-165\n   * @dev Interface identification is specified in ERC-165. This function\n   * uses less than 30,000 gas.\n   */\n  function supportsInterface(bytes4 _interfaceId)\n    external\n    view\n    returns (bool);\n}\n"},"ERC20Interface.sol":{"content":"pragma solidity ^0.5.17;\n\ncontract ERC20Interface {\n  function transfer(address to, uint tokens) public returns (bool success);\n  function balanceOf(address _sender) public view returns (uint _bal);\n  function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n  event Transfer(address indexed from, address indexed to, uint tokens);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  function transferFrom(address from, address to, uint tokens) public returns (bool success);\n}"},"ERC721.sol":{"content":"pragma solidity 0.5.17;\n\nimport \"./ERC721Basic.sol\";\nimport \"./ERC721Enumerable.sol\";\nimport \"./ERC721Metadata.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n\n}"},"ERC721Basic.sol":{"content":"pragma solidity 0.5.17;\n\nimport \"./ERC165.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721Basic is ERC165 {\n  event Transfer(\n    address indexed _from,\n    address indexed _to,\n    uint256 indexed _tokenId\n  );\n  event Approval(\n    address indexed _owner,\n    address indexed _approved,\n    uint256 indexed _tokenId\n  );\n  event ApprovalForAll(\n    address indexed _owner,\n    address indexed _operator,\n    bool _approved\n  );\n\n  function balanceOf(address _owner) public view returns (uint256 _balance);\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n  function exists(uint256 _tokenId) public view returns (bool _exists);\n\n  function approve(address _to, uint256 _tokenId) public;\n  function getApproved(uint256 _tokenId)\n    public view returns (address _operator);\n\n  function setApprovalForAll(address _operator, bool _approved) public;\n  function isApprovedForAll(address _owner, address _operator)\n    public view returns (bool);\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\n    public;\n\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes memory _data\n  )\n    public;\n}"},"ERC721BasicToken.sol":{"content":"pragma solidity 0.5.17;\n\nimport \"./SupportsInterfaceWithLookup.sol\";\nimport \"./ERC721Basic.sol\";\nimport \"./ERC721Receiver.sol\";\n\nimport \"./SafeMath.sol\";\nimport \"./Addresses.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic {\n\n  bytes4 private constant InterfaceId_ERC721 = 0x80ac58cd;\n  /*\n   * 0x80ac58cd ===\n   *   bytes4(keccak256(\u0027balanceOf(address)\u0027)) ^\n   *   bytes4(keccak256(\u0027ownerOf(uint256)\u0027)) ^\n   *   bytes4(keccak256(\u0027approve(address,uint256)\u0027)) ^\n   *   bytes4(keccak256(\u0027getApproved(uint256)\u0027)) ^\n   *   bytes4(keccak256(\u0027setApprovalForAll(address,bool)\u0027)) ^\n   *   bytes4(keccak256(\u0027isApprovedForAll(address,address)\u0027)) ^\n   *   bytes4(keccak256(\u0027transferFrom(address,address,uint256)\u0027)) ^\n   *   bytes4(keccak256(\u0027safeTransferFrom(address,address,uint256)\u0027)) ^\n   *   bytes4(keccak256(\u0027safeTransferFrom(address,address,uint256,bytes)\u0027))\n   */\n\n  bytes4 private constant InterfaceId_ERC721Exists = 0x4f558e79;\n  /*\n   * 0x4f558e79 ===\n   *   bytes4(keccak256(\u0027exists(uint256)\u0027))\n   */\n\n  using SafeMath for uint256;\n  using Address for address;\n\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\n  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n  bytes4 private constant ERC721_RECEIVED = 0xf0b9e5ba;\n\n  // Mapping from token ID to owner\n  mapping (uint256 =\u003e address) internal tokenOwner;\n\n  // Mapping from token ID to approved address\n  mapping (uint256 =\u003e address) internal tokenApprovals;\n\n  // Mapping from owner to number of owned token\n  mapping (address =\u003e uint256) internal ownedTokensCount;\n\n  // Mapping from owner to operator approvals\n  mapping (address =\u003e mapping (address =\u003e bool)) internal operatorApprovals;\n\n  /**\n   * @dev Guarantees msg.sender is owner of the given token\n   * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n   */\n  modifier onlyOwnerOf(uint256 _tokenId) {\n    require(ownerOf(_tokenId) == msg.sender, \"Only asset owner is allowed\");\n    _;\n  }\n\n  /**\n   * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\n   * @param _tokenId uint256 ID of the token to validate\n   */\n  modifier canTransfer(uint256 _tokenId) {\n    require(isApprovedOrOwner(msg.sender, _tokenId), \"Can not transfer\");\n    _;\n  }\n\n  constructor()\n    public\n  {\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(InterfaceId_ERC721);\n    _registerInterface(InterfaceId_ERC721Exists);\n  }\n\n  /**\n   * @dev Gets the balance of the specified address\n   * @param _owner address to query the balance of\n   * @return uint256 representing the amount owned by the passed address\n   */\n  function balanceOf(address _owner) public view returns (uint256) {\n    require(_owner != address(0), \"Zero address not allowed\");\n    return ownedTokensCount[_owner];\n  }\n\n  /**\n   * @dev Gets the owner of the specified token ID\n   * @param _tokenId uint256 ID of the token to query the owner of\n   * @return owner address currently marked as the owner of the given token ID\n   */\n  function ownerOf(uint256 _tokenId) public view returns (address) {\n    address owner = tokenOwner[_tokenId];\n    require(owner != address(0), \"Zero address not allowed\");\n    return owner;\n  }\n\n  /**\n   * @dev Returns whether the specified token exists\n   * @param _tokenId uint256 ID of the token to query the existence of\n   * @return whether the token exists\n   */\n  function exists(uint256 _tokenId) public view returns (bool) {\n    address owner = tokenOwner[_tokenId];\n    return owner != address(0);\n  }\n\n  /**\n   * @dev Approves another address to transfer the given token ID\n   * The zero address indicates there is no approved address.\n   * There can only be one approved address per token at a given time.\n   * Can only be called by the token owner or an approved operator.\n   * @param _to address to be approved for the given token ID\n   * @param _tokenId uint256 ID of the token to be approved\n   */\n  function approve(address _to, uint256 _tokenId) public {\n    address owner = ownerOf(_tokenId);\n    require(_to != owner, \"Can not approve to self\");\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \"Not allowed to update approvals\");\n\n    tokenApprovals[_tokenId] = _to;\n    emit Approval(owner, _to, _tokenId);\n  }\n\n  /**\n   * @dev Gets the approved address for a token ID, or zero if no address set\n   * @param _tokenId uint256 ID of the token to query the approval of\n   * @return address currently approved for the given token ID\n   */\n  function getApproved(uint256 _tokenId) public view returns (address) {\n    return tokenApprovals[_tokenId];\n  }\n\n  /**\n   * @dev Sets or unsets the approval of a given operator\n   * An operator is allowed to transfer all tokens of the sender on their behalf\n   * @param _to operator address to set the approval\n   * @param _approved representing the status of the approval to be set\n   */\n  function setApprovalForAll(address _to, bool _approved) public {\n    require(_to != msg.sender, \"Can not approve to self\");\n    operatorApprovals[msg.sender][_to] = _approved;\n    emit ApprovalForAll(msg.sender, _to, _approved);\n  }\n\n  /**\n   * @dev Tells whether an operator is approved by a given owner\n   * @param _owner owner address which you want to query the approval of\n   * @param _operator operator address which you want to query the approval of\n   * @return bool whether the given operator is approved by the given owner\n   */\n  function isApprovedForAll(\n    address _owner,\n    address _operator\n  )\n    public\n    view\n    returns (bool)\n  {\n    return operatorApprovals[_owner][_operator];\n  }\n\n  /**\n   * @dev Transfers the ownership of a given token ID to another address\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param _from current owner of the token\n   * @param _to address to receive the ownership of the given token ID\n   * @param _tokenId uint256 ID of the token to be transferred\n  */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    public\n    canTransfer(_tokenId)\n  \n  {\n    require(_from != address(0), \"Zero address not allowed\");\n    require(_to != address(0), \"Zero address not allowed\");\n\n    clearApproval(_from, _tokenId);\n    removeTokenFrom(_from, _tokenId);\n    addTokenTo(_to, _tokenId);\n\n    emit Transfer(_from, _to, _tokenId);\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   *\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param _from current owner of the token\n   * @param _to address to receive the ownership of the given token ID\n   * @param _tokenId uint256 ID of the token to be transferred\n  */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    public\n    canTransfer(_tokenId)\n  \n  {\n    // solium-disable-next-line arg-overflow\n    safeTransferFrom(_from, _to, _tokenId, \"\");\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param _from current owner of the token\n   * @param _to address to receive the ownership of the given token ID\n   * @param _tokenId uint256 ID of the token to be transferred\n   * @param _data bytes data to send along with a safe transfer check\n   */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes memory _data\n  )\n    public\n    canTransfer(_tokenId)\n  {\n    transferFrom(_from, _to, _tokenId);\n    // solium-disable-next-line arg-overflow\n    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data), \"Safe Transfer failed\");\n  }\n\n  /**\n   * @dev Returns whether the given spender can transfer a given token ID\n   * @param _spender address of the spender to query\n   * @param _tokenId uint256 ID of the token to be transferred\n   * @return bool whether the msg.sender is approved for the given token ID,\n   *  is an operator of the owner, or is the owner of the token\n   */\n  function isApprovedOrOwner(\n    address _spender,\n    uint256 _tokenId\n  )\n    internal\n    view\n    returns (bool)\n  {\n    address owner = ownerOf(_tokenId);\n    // Disable solium check because of\n    // https://github.com/duaraghav8/Solium/issues/175\n    // solium-disable-next-line operator-whitespace\n    return (\n      _spender == owner ||\n      getApproved(_tokenId) == _spender ||\n      isApprovedForAll(owner, _spender)\n    );\n  }\n\n  /**\n   * @dev Internal function to mint a new token\n   * Reverts if the given token ID already exists\n   * @param _to The address that will own the minted token\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n   */\n  function _mint(address _to, uint256 _tokenId) internal {\n    require(_to != address(0), \"Zero address not allowed\");\n    addTokenTo(_to, _tokenId);\n    emit Transfer(address(0), _to, _tokenId);\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address _owner, uint256 _tokenId) internal {\n    clearApproval(_owner, _tokenId);\n    removeTokenFrom(_owner, _tokenId);\n    emit Transfer(_owner, address(0), _tokenId);\n  }\n\n  /**\n   * @dev Internal function to clear current approval of a given token ID\n   * Reverts if the given address is not indeed the owner of the token\n   * @param _owner owner of the token\n   * @param _tokenId uint256 ID of the token to be transferred\n   */\n  function clearApproval(address _owner, uint256 _tokenId) internal {\n    require(ownerOf(_tokenId) == _owner, \"Asset does not belong to given owmer\");\n    if (tokenApprovals[_tokenId] != address(0)) {\n      tokenApprovals[_tokenId] = address(0);\n      emit Approval(_owner, address(0), _tokenId);\n    }\n  }\n\n  /**\n   * @dev Internal function to add a token ID to the list of a given address\n   * @param _to address representing the new owner of the given token ID\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n   */\n  function addTokenTo(address _to, uint256 _tokenId) internal {\n    require(tokenOwner[_tokenId] == address(0), \"Asset already exists\");\n    tokenOwner[_tokenId] = _to;\n    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\n  }\n\n  /**\n   * @dev Internal function to remove a token ID from the list of a given address\n   * @param _from address representing the previous owner of the given token ID\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n   */\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\n    require(ownerOf(_tokenId) == _from, \"Asset does not belong to given owmer\");\n    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\n    tokenOwner[_tokenId] = address(0);\n  }\n\n  /**\n   * @dev Internal function to invoke `onERC721Received` on a target address\n   * The call is not executed if the target address is not a contract\n   * @param _from address representing the previous owner of the given token ID\n   * @param _to target address that will receive the tokens\n   * @param _tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return whether the call correctly returned the expected magic value\n   */\n  function checkAndCallSafeTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes memory _data\n  )\n    internal\n    returns (bool)\n  {\n    if (!_to.isContract()) {\n      return true;\n    }\n    bytes4 retval = ERC721Receiver(_to).onERC721Received(\n      _from, _tokenId, _data);\n    return (retval == ERC721_RECEIVED);\n  }\n}"},"ERC721Enumerable.sol":{"content":"pragma solidity 0.5.17;\n\nimport \"./ERC721Basic.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721Enumerable is ERC721Basic {\n  function totalSupply() public view returns (uint256);\n  function tokenOfOwnerByIndex(\n    address _owner,\n    uint256 _index\n  )\n    public\n    view\n    returns (uint256 _tokenId);\n\n  function tokenByIndex(uint256 _index) public view returns (uint256);\n}"},"ERC721Metadata.sol":{"content":"pragma solidity 0.5.17;\n\nimport \"./ERC721Basic.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata \n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721Metadata is ERC721Basic {\n  function name() external view returns (string memory _name);\n  function symbol() external view returns (string memory _symbol);\n  function tokenURI(uint256 _tokenId) public view returns (string memory);\n}"},"ERC721Receiver.sol":{"content":"pragma solidity 0.5.17;\n\n/**\n * @title ERC721 token receiver interface\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract ERC721Receiver {\n  /**\n   * @dev Magic value to be returned upon successful reception of an NFT\n   *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n   */\n  bytes4 internal constant ERC721_RECEIVED = 0xf0b9e5ba;\n\n  /**\n   * @notice Handle the receipt of an NFT\n   * @dev The ERC721 smart contract calls this function on the recipient\n   * after a `safetransfer`. This function MAY throw to revert and reject the\n   * transfer. This function MUST use 50,000 gas or less. Return of other\n   * than the magic value MUST result in the transaction being reverted.\n   * Note: the contract address is always the message sender.\n   * @param _from The sending address\n   * @param _tokenId The NFT identifier which is being transfered\n   * @param _data Additional data with no specified format\n   * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\n   */\n  function onERC721Received(\n    address _from,\n    uint256 _tokenId,\n    bytes memory _data\n  )\n    public\n    returns(bytes4);\n}"},"ERC721Token.sol":{"content":"pragma solidity 0.5.17;\n\nimport \"./ERC721.sol\";\nimport \"./ERC721BasicToken.sol\";\nimport \"./SupportsInterfaceWithLookup.sol\";\nimport \"./Strings.sol\";\n\n\n/**\n * @title Full ERC721 Token\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\n * This implementation includes all the required and some optional functionality of the ERC721 standard\n * Moreover, it includes approve all functionality using operator terminology\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {\n\n  bytes4 private constant InterfaceId_ERC721Enumerable = 0x780e9d63;\n  /**\n   * 0x780e9d63 ===\n   *   bytes4(keccak256(\u0027totalSupply()\u0027)) ^\n   *   bytes4(keccak256(\u0027tokenOfOwnerByIndex(address,uint256)\u0027)) ^\n   *   bytes4(keccak256(\u0027tokenByIndex(uint256)\u0027))\n   */\n\n  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n  /**\n   * 0x5b5e139f ===\n   *   bytes4(keccak256(\u0027name()\u0027)) ^\n   *   bytes4(keccak256(\u0027symbol()\u0027)) ^\n   *   bytes4(keccak256(\u0027tokenURI(uint256)\u0027))\n   */\n\n  // Token name\n  string internal name_;\n\n  // Token symbol\n  string internal symbol_;\n\n  // to store base URL\n  string internal baseTokenURI;\n\n  // Mapping from owner to list of owned token IDs\n  mapping(address =\u003e uint256[]) internal ownedTokens;\n\n  // Mapping from token ID to index of the owner tokens list\n  mapping(uint256 =\u003e uint256) internal ownedTokensIndex;\n\n  // Array with all token ids, used for enumeration\n  uint256[] internal allTokens;\n\n  // Mapping from token id to position in the allTokens array\n  mapping(uint256 =\u003e uint256) internal allTokensIndex;\n\n  /**\n   * @dev Constructor function\n   */\n  constructor(string memory _name, string memory _symbol) public {\n    name_ = _name;\n    symbol_ = _symbol;\n\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(InterfaceId_ERC721Enumerable);\n    _registerInterface(InterfaceId_ERC721Metadata);\n  }\n\n  /**\n   * @dev Gets the token name\n   * @return string representing the token name\n   */\n  function name() external view returns (string memory) {\n    return name_;\n  }\n\n  /**\n   * @dev Gets the token symbol\n   * @return string representing the token symbol\n   */\n  function symbol() external view returns (string memory) {\n    return symbol_;\n  }\n\n  /**\n   * @dev Returns an URI for a given token ID\n   * Throws if the token ID does not exist. May return an empty string.\n   * @param _tokenId uint256 ID of the token to query\n   */\n  function tokenURI(uint256 _tokenId) public view returns (string memory) {\n    require(exists(_tokenId), \"Asset does not exist\");\n    return string(abi.encodePacked(baseTokenURI, Strings.toString(_tokenId)));\n  }\n\n  /**\n   * @dev Gets the token ID at a given index of the tokens list of the requested owner\n   * @param _owner address owning the tokens list to be accessed\n   * @param _index uint256 representing the index to be accessed of the requested tokens list\n   * @return uint256 token ID at the given index of the tokens list owned by the requested address\n   */\n  function tokenOfOwnerByIndex(\n    address _owner,\n    uint256 _index\n  )\n    public\n    view\n    returns (uint256)\n  {\n    require(_index \u003c balanceOf(_owner), \"Invalid index\");\n    return ownedTokens[_owner][_index];\n  }\n\n  /**\n   * @dev Gets the total amount of tokens stored by the contract\n   * @return uint256 representing the total amount of tokens\n   */\n  function totalSupply() public view returns (uint256) {\n    return allTokens.length;\n  }\n\n  /**\n   * @dev Gets the token ID at a given index of all the tokens in this contract\n   * Reverts if the index is greater or equal to the total number of tokens\n   * @param _index uint256 representing the index to be accessed of the tokens list\n   * @return uint256 token ID at the given index of the tokens list\n   */\n  function tokenByIndex(uint256 _index) public view returns (uint256) {\n    require(_index \u003c totalSupply(), \"Invalid index\");\n    return allTokens[_index];\n  }\n\n  // @dev This function is not needed as token URI will be created automatically based in base URL\n  // /**\n  //  * @dev Internal function to set the token URI for a given token\n  //  * Reverts if the token ID does not exist\n  //  * @param _tokenId uint256 ID of the token to set its URI\n  //  * @param _uri string URI to assign\n  //  */\n  // function _setTokenURI(uint256 _tokenId, string memory _uri) internal {\n  //   require(exists(_tokenId));\n  //   tokenURI[_tokenId] = _uri;\n  // }\n\n  /**\n   * @dev Internal function to add a token ID to the list of a given address\n   * @param _to address representing the new owner of the given token ID\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n   */\n  function addTokenTo(address _to, uint256 _tokenId) internal {\n    super.addTokenTo(_to, _tokenId);\n    uint256 length = ownedTokens[_to].length;\n    ownedTokens[_to].push(_tokenId);\n    ownedTokensIndex[_tokenId] = length;\n  }\n\n  /**\n   * @dev Internal function to remove a token ID from the list of a given address\n   * @param _from address representing the previous owner of the given token ID\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n   */\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\n    super.removeTokenFrom(_from, _tokenId);\n\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n\n    ownedTokens[_from][tokenIndex] = lastToken;\n    ownedTokens[_from][lastTokenIndex] = 0;\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\n\n    ownedTokens[_from].length--;\n    ownedTokensIndex[_tokenId] = 0;\n    ownedTokensIndex[lastToken] = tokenIndex;\n  }\n\n  /**\n   * @dev Internal function to mint a new token\n   * Reverts if the given token ID already exists\n   * @param _to address the beneficiary that will own the minted token\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n   */\n  function _mint(address _to, uint256 _tokenId) internal {\n    super._mint(_to, _tokenId);\n\n    allTokensIndex[_tokenId] = allTokens.length;\n    allTokens.push(_tokenId);\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param _owner owner of the token to burn\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address _owner, uint256 _tokenId) internal {\n    super._burn(_owner, _tokenId);\n\n    // Clear metadata (if any)\n    // if (bytes(tokenURI[_tokenId]).length != 0) {\n    //   delete tokenURIs[_tokenId];\n    // }\n\n    // Reorg all tokens array\n    uint256 tokenIndex = allTokensIndex[_tokenId];\n    uint256 lastTokenIndex = allTokens.length.sub(1);\n    uint256 lastToken = allTokens[lastTokenIndex];\n\n    allTokens[tokenIndex] = lastToken;\n    allTokens[lastTokenIndex] = 0;\n\n    allTokens.length--;\n    allTokensIndex[_tokenId] = 0;\n    allTokensIndex[lastToken] = tokenIndex;\n  }\n}"},"Freezable.sol":{"content":"pragma solidity 0.5.17;\n\nimport \"./Ownership.sol\";\n\ncontract Freezable is Ownership {\n    \n    mapping (address =\u003e bool) frozen;\n    bool public emergencyFreeze = false;\n\n    event Freezed(address targetAddress, bool frozen);\n    event EmerygencyFreezed(bool emergencyFreezeStatus);\n\n    modifier unfreezed(address _account) { \n        require(!frozen[_account]);\n        _;  \n    }\n    \n    modifier noEmergencyFreeze() { \n        require(!emergencyFreeze);\n        _; \n    }\n\n    // ------------------------------------------------------------------------\n    // Freeze account - onlyOwner\n    // ------------------------------------------------------------------------\n    function freezeAccount (address _target, bool _freeze) public onlyOwner returns(bool) {\n        frozen[_target] = _freeze;\n        emit Freezed(_target, _freeze);\n        return true;\n    }\n\n    // ------------------------------------------------------------------------\n    // Emerygency freeze - onlyOwner\n    // ------------------------------------------------------------------------\n    function emergencyFreezeAllAccounts (bool _freeze) public onlyOwner returns(bool) {\n        emergencyFreeze = _freeze;\n        emit EmerygencyFreezed(_freeze);\n        return true;\n    }\n\n    // ------------------------------------------------------------------------\n    // Get Freeze Status : Constant\n    // ------------------------------------------------------------------------\n    function isFreezed(address _targetAddress) public view returns (bool) {\n        return frozen[_targetAddress]; \n    }\n\n}"},"Ownership.sol":{"content":"pragma solidity 0.5.17;\n\ncontract Ownership {\n\n  address public owner;\n  address[] public deputyOwners;\n\n  mapping(address =\u003e bool) public isDeputyOwner;\n\n  event OwnershipUpdated(address oldOwner, address newOwner);\n  event DeputyOwnerUpdated(address _do, bool _isAdded);\n\n  constructor() public {\n    owner = msg.sender;\n    deputyOwners = [msg.sender];\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Not owner\");\n    _;\n  }\n\n  modifier onlyDeputyOrOwner() {\n    require(msg.sender == owner || isDeputyOwner[msg.sender], \"Only owner or deputy owner is allowed\");\n    _;\n  }\n\n\n  /**\n   * @dev Transfer the ownership to some other address.\n   * new owner can not be a zero address.\n   * Only owner can call this function\n   * @param _newOwner Address to which ownership is being transferred\n   */\n  function updateOwner(address _newOwner)\n    public\n    onlyOwner\n  {\n    require(_newOwner != address(0x0), \"Invalid address\");\n    owner = _newOwner;\n    emit OwnershipUpdated(msg.sender, owner);\n  }\n\n  /**\n    * @dev Add new deputy owner.\n    * Only Owner can call this function\n    * New Deputy should not be zero address\n    * New Deputy should not be be already exisitng\n    * emit DeputyOwnerUdpatd event\n    * @param _newDO Address of new deputy owner\n   */\n  function addDeputyOwner(address _newDO)\n    public\n    onlyOwner\n  {\n    require(!isDeputyOwner[_newDO], \"Deputy Owner already exists\");\n    require(_newDO != address(0), \"Zero address not allowed\");\n    deputyOwners.push(_newDO);\n    isDeputyOwner[_newDO] = true;\n    emit DeputyOwnerUpdated(_newDO, true);\n  }\n\n  /**\n    * @dev Remove an existing deputy owner.\n    * Only Owner can call this function\n    * Given address should be a deputy owner\n    * emit DeputyOwnerUdpatd event\n    * @param _existingDO Address of existing deputy owner\n   */\n  function removeDeputyOwner(address _existingDO)\n    public\n    onlyOwner\n  {\n    require(isDeputyOwner[_existingDO], \"Deputy Owner does not exits\");\n    uint existingId;\n    for(uint i=0; i\u003cdeputyOwners.length; i++) {\n      if(deputyOwners[i] == _existingDO) existingId=i;\n    }\n\n    // swap this with last element\n    deputyOwners[existingId] = deputyOwners[deputyOwners.length-1];\n    delete deputyOwners[deputyOwners.length-1];\n    deputyOwners.length--;\n    isDeputyOwner[_existingDO] = false;\n    emit DeputyOwnerUpdated(_existingDO, false);\n  }\n\n  /**\n   * @dev Renounce the ownership.\n   * This will leave the contract without any owner.\n   * Only owner can call this function\n   * @param _validationCode A code to prevent aaccidental calling of this function\n   */\n  function renounceOwnership(uint _validationCode)\n    public\n    onlyOwner\n  {\n    require(_validationCode == 123456789, \"Invalid code\");\n    owner = address(0);\n    emit OwnershipUpdated(msg.sender, owner);\n  }\n}"},"SafeMath.sol":{"content":"pragma solidity ^0.5.17;\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n    return c;\n  }\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b \u003c= a);\n    return a - b;\n  }\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c \u003e= a \u0026\u0026 c\u003e=b);\n    return c;\n  }\n}"},"Strings.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.17;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI\u0027s implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = byte(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}"},"SupportsInterfaceWithLookup.sol":{"content":"pragma solidity 0.5.17;\n\nimport \"./ERC165.sol\";\n\n/**\n * @title SupportsInterfaceWithLookup\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\n * @dev Implements ERC165 using a lookup table.\n */\ncontract SupportsInterfaceWithLookup is ERC165 {\n  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\n  /**\n   * 0x01ffc9a7 ===\n   *   bytes4(keccak256(\u0027supportsInterface(bytes4)\u0027))\n   */\n\n  /**\n   * @dev a mapping of interface id to whether or not it\u0027s supported\n   */\n  mapping(bytes4 =\u003e bool) internal supportedInterfaces;\n\n  /**\n   * @dev A contract implementing SupportsInterfaceWithLookup\n   * implement ERC165 itself\n   */\n  constructor()\n    public\n  {\n    _registerInterface(InterfaceId_ERC165);\n  }\n\n  /**\n   * @dev implement supportsInterface(bytes4) using a lookup table\n   */\n  function supportsInterface(bytes4 _interfaceId)\n    external\n    view\n    returns (bool)\n  {\n    return supportedInterfaces[_interfaceId];\n  }\n\n  /**\n   * @dev private method for registering an interface\n   */\n  function _registerInterface(bytes4 _interfaceId)\n    internal\n  {\n    require(_interfaceId != 0xffffffff);\n    supportedInterfaces[_interfaceId] = true;\n  }\n}"},"UserMintableNFT.sol":{"content":"/**\n * This is enhancement over custom NFT allowing users to mint tokens approved by admin\n * This contract will be used as enhanced version of NFT (v2)\n*/\n\npragma solidity 0.5.17;\n\nimport \"./CustomERC721.sol\";\n\ncontract UserMintableNFT is CustomERC721 {\n\n  mapping(address =\u003e mapping(uint =\u003e bool)) isNonceUsed;\n\n  constructor(string memory name, string memory symbol, string memory baseURI) public CustomERC721(name, symbol, baseURI)\n  {\n\n  }\n\n  /**\n   * @dev Allows anyone to mint token signed by admin\n   * Reverts if admin has not signed for `tokenId` or `to`\n   * @param r signature\n   * @param s signature\n   * @param v recovery id of signature\n   * @param tokenId tokenId to be minted\n   * @param to address to which tokens needs to be minted\n   * @param _signerNonce non-sequential nonce of signer to avoid replay protection\n   * @return bool true when operation is successful\n\n   */\n  function userMint(\n    bytes32 r, bytes32 s, uint8 v,\n    uint256 tokenId,\n    address to,\n    uint256 _signerNonce\n  )\n    public\n    noEmergencyFreeze\n    returns (bool)\n  {\n    \n    bytes32 message = keccak256(abi.encodePacked(\n      bytes4(0x8cd49589), // Keccak-256 hash of \"userMint\"\n      address(this),\n      _signerNonce,\n      to,\n      tokenId\n    ));\n    address signer = getSigner(message, r, s, v);\n    require(signer == owner || isDeputyOwner[signer], \"Admin should sign message\");\n    require(isNonceUsed[signer][_signerNonce], \"nonce already used\");\n    super._mint(to, tokenId);\n    isNonceUsed[signer][_signerNonce] = true;\n    return true;\n  }\n\n  /**\n   * @dev Allows anyone to mint tokens signed by admin\n   * Reverts if admin has not signed for `tokenIds` or `to`\n   * @param r signature\n   * @param s signature\n   * @param v recovery id of signature\n   * @param tokenIds tokenIds to be minted\n   * @param to address to which tokens needs to be minted\n   * @param _signerNonce non-sequential nonce of signer to avoid replay protection\n   * @return bool true when operation is successful\n   */\n  function userBulkMint(\n    bytes32 r, bytes32 s, uint8 v,\n    uint256[] memory tokenIds,\n    address to,\n    uint256 _signerNonce\n  )\n    public\n    noEmergencyFreeze\n    returns (bool)\n  {\n    bytes32 message = keccak256(abi.encodePacked(\n      bytes4(0x5827c1ff), // Keccak-256 hash of \"userBulkMint\"\n      address(this),\n      _signerNonce,\n      to,\n      tokenIds\n    ));\n    address signer = getSigner(message, r, s, v);\n    require(signer == owner || isDeputyOwner[signer], \"Admin should sign message\");\n    require(isNonceUsed[signer][_signerNonce], \"nonce already used\");\n    for(uint256 i=0; i\u003ctokenIds.length; i++) {\n      super._mint(to, tokenIds[i]);\n    }\n    isNonceUsed[signer][_signerNonce] = true;\n    return true;\n  }\n  \n}\n\n"}}