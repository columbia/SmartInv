1 {{
2   "language": "Solidity",
3   "sources": {
4     "@aragon/os/contracts/lib/math/Math.sol": {
5       "content": "pragma solidity ^0.4.24;\n\n/**\n * @title Math\n * @dev Assorted math operations\n */\n\nlibrary Math {\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n}\n"
6     },
7     "@aragon/os/contracts/lib/math/SafeMath.sol": {
8       "content": "// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d51e38758e1d985661534534d5c61e27bece5042/contracts/math/SafeMath.sol\n// Adapted to use pragma ^0.4.24 and satisfy our linter rules\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    string private constant ERROR_ADD_OVERFLOW = \"MATH_ADD_OVERFLOW\";\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH_SUB_UNDERFLOW\";\n    string private constant ERROR_MUL_OVERFLOW = \"MATH_MUL_OVERFLOW\";\n    string private constant ERROR_DIV_ZERO = \"MATH_DIV_ZERO\";\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        uint256 c = _a * _b;\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n        uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n        uint256 c = _a - _b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        uint256 c = _a + _b;\n        require(c >= _a, ERROR_ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, ERROR_DIV_ZERO);\n        return a % b;\n    }\n}\n"
9     },
10     "@aragon/os/contracts/lib/math/SafeMath64.sol": {
11       "content": "// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d51e38758e1d985661534534d5c61e27bece5042/contracts/math/SafeMath.sol\n// Adapted for uint64, pragma ^0.4.24, and satisfying our linter rules\n// Also optimized the mul() implementation, see https://github.com/aragon/aragonOS/pull/417\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath64\n * @dev Math operations for uint64 with safety checks that revert on error\n */\nlibrary SafeMath64 {\n    string private constant ERROR_ADD_OVERFLOW = \"MATH64_ADD_OVERFLOW\";\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH64_SUB_UNDERFLOW\";\n    string private constant ERROR_MUL_OVERFLOW = \"MATH64_MUL_OVERFLOW\";\n    string private constant ERROR_DIV_ZERO = \"MATH64_DIV_ZERO\";\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint64 _a, uint64 _b) internal pure returns (uint64) {\n        uint256 c = uint256(_a) * uint256(_b);\n        require(c < 0x010000000000000000, ERROR_MUL_OVERFLOW); // 2**64 (less gas this way)\n\n        return uint64(c);\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint64 _a, uint64 _b) internal pure returns (uint64) {\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n        uint64 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint64 _a, uint64 _b) internal pure returns (uint64) {\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n        uint64 c = _a - _b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint64 _a, uint64 _b) internal pure returns (uint64) {\n        uint64 c = _a + _b;\n        require(c >= _a, ERROR_ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\n        require(b != 0, ERROR_DIV_ZERO);\n        return a % b;\n    }\n}\n"
12     },
13     "/contracts/governance/VotingStakingRewards.sol": {
14       "content": "pragma solidity ^0.4.24;\n\nimport \"@aragon/os/contracts/lib/math/SafeMath.sol\";\nimport \"@aragon/os/contracts/lib/math/SafeMath64.sol\";\nimport \"@aragon/os/contracts/lib/math/Math.sol\";\n\nimport \"./interfaces/IVeXBE.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IBoostLogicProvider.sol\";\n\nimport \"./utils/VotingPausable.sol\";\nimport \"./utils/VotingNonReentrant.sol\";\nimport \"./utils/VotingOwnable.sol\";\nimport \"./utils/VotingInitializable.sol\";\n\ncontract VotingStakingRewards is\n    VotingPausable,\n    VotingNonReentrant,\n    VotingOwnable,\n    VotingInitializable\n{\n    using SafeMath for uint256;\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    uint256 public constant PCT_BASE = 10**18; // 0% = 0; 1% = 10^16; 100% = 10^18\n    uint256 internal constant MAX_BOOST_LEVEL = PCT_BASE;\n\n    address public treasury;\n\n    struct BondedReward {\n        uint256 amount;\n        uint256 unlockTime;\n    }\n\n    mapping(address => bool) public allowance;\n    mapping(address => BondedReward) public bondedRewardLocks;\n\n    uint256 public penaltyPct = PCT_BASE / 2; // PCT_BASE is 10^18\n\n    uint256 public inverseMaxBoostCoefficient = 40; // 1 / inverseMaxBoostCoefficient = max boost coef. (ex. if 40 then 1 / (40 / 100) = 2.5)\n\n    IERC20 public rewardsToken;\n    IERC20 public stakingToken;\n    uint256 public periodFinish;\n    uint256 public rewardRate;\n    uint256 public rewardsDuration;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    address public rewardsDistribution;\n    uint256 public bondedLockDuration;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) internal _balances;\n\n    IVeXBE public token;\n    IBoostLogicProvider public boostLogicProvider;\n\n    function configure(\n        address _rewardsDistribution,\n        IERC20 _rewardsToken,\n        IERC20 _stakingToken,\n        uint256 _rewardsDuration,\n        IVeXBE _token,\n        IBoostLogicProvider _boostLogicProvider,\n        address _treasury,\n        uint256 _bondedLockDuration,\n        address[] memory _allowance\n    ) public initializer {\n        rewardsToken = _rewardsToken;\n        stakingToken = _stakingToken;\n        rewardsDistribution = _rewardsDistribution;\n        rewardsDuration = _rewardsDuration;\n        token = _token;\n        boostLogicProvider = _boostLogicProvider;\n        treasury = _treasury;\n        require(_bondedLockDuration > 0, \"badBondDuration\");\n        bondedLockDuration = _bondedLockDuration;\n        for (uint256 i = 0; i < _allowance.length; i++) {\n            allowance[_allowance[i]] = true;\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address account) {\n        uint256 _lastTimeReward = lastTimeRewardApplicable();\n        uint256 _duration = _lastTimeReward.sub(lastUpdateTime);\n        rewardPerTokenStored = _rewardPerToken(_duration);\n        lastUpdateTime = _lastTimeReward;\n        if (account != address(0)) {\n            (uint256 userEarned, uint256 toTreasury) = potentialXbeReturns(\n                0,\n                account\n            );\n            rewards[account] = userEarned;\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n            // transfer remaining reward share to treasury\n            if (toTreasury > 0) {\n                require(\n                    stakingToken.transfer(treasury, toTreasury),\n                    \"!boostDelta\"\n                );\n            }\n        }\n        _;\n    }\n\n    modifier onlyRewardsDistribution() {\n        require(\n            msg.sender == rewardsDistribution,\n            \"Caller is not RewardsDistribution contract\"\n        );\n        _;\n    }\n\n    /* ========== OWNERS FUNCTIONS ========== */\n\n    function setRewardsDistribution(address _rewardsDistribution)\n        external\n        onlyOwner\n    {\n        rewardsDistribution = _rewardsDistribution;\n    }\n\n    function setInverseMaxBoostCoefficient(uint256 _inverseMaxBoostCoefficient)\n        external\n        onlyOwner\n    {\n        inverseMaxBoostCoefficient = _inverseMaxBoostCoefficient;\n        require(\n            _inverseMaxBoostCoefficient > 0 &&\n                _inverseMaxBoostCoefficient < 100,\n            \"invalidInverseMaxBoostCoefficient\"\n        );\n    }\n\n    function setPenaltyPct(uint256 _penaltyPct) external onlyOwner {\n        penaltyPct = _penaltyPct;\n        require(_penaltyPct < PCT_BASE, \"tooHighPct\");\n    }\n\n    function setBondedLockDuration(uint256 _bondedLockDuration)\n        external\n        onlyOwner\n    {\n        bondedLockDuration = _bondedLockDuration;\n    }\n\n    function setBoostLogicProvider(address _boostLogicProvider)\n        external\n        onlyOwner\n    {\n        boostLogicProvider = IBoostLogicProvider(_boostLogicProvider);\n    }\n\n    function setAddressWhoCanAutoStake(address _addr, bool _flag)\n        external\n        onlyOwner\n    {\n        allowance[_addr] = _flag;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min256(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() external view returns (uint256) {\n        return _rewardPerToken(lastTimeRewardApplicable().sub(lastUpdateTime));\n    }\n\n    function _rewardPerToken(uint256 duration) internal view returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                duration.mul(rewardRate).mul(PCT_BASE).div(totalSupply)\n            );\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        onlyRewardsDistribution\n        updateReward(address(0))\n    {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        require(\n            rewardRate <= balance.div(rewardsDuration),\n            \"Provided reward too high\"\n        );\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(rewardsDuration);\n        emit RewardAdded(reward);\n    }\n\n    function _stake(address _for, uint256 _amount) internal {\n        require(_amount > 0, \"Cannot stake 0\");\n        totalSupply = totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"!t\"\n        );\n        emit Staked(_for, _amount);\n    }\n\n    function stakeFor(address _for, uint256 amount)\n        external\n        nonReentrant\n        whenNotPaused\n        updateReward(_for)\n    {\n        require(allowance[msg.sender], \"stakeNotApproved\");\n\n        _stake(_for, amount);\n\n        BondedReward memory rewardLock = bondedRewardLocks[_for];\n        if (block.timestamp >= rewardLock.unlockTime) {\n            bondedRewardLocks[_for].amount = amount;\n        } else {\n            bondedRewardLocks[_for].amount = rewardLock.amount.add(amount);\n        }\n        bondedRewardLocks[_for].unlockTime = block.timestamp.add(\n            bondedLockDuration\n        );\n    }\n\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        whenNotPaused\n        updateReward(msg.sender)\n    {\n        _stake(msg.sender, amount);\n    }\n\n    function withdrawBondedOrWithPenalty()\n        external\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        uint256 amount = bondedRewardLocks[msg.sender].amount;\n        uint256 escrowed = token.lockedAmount(msg.sender);\n        amount = Math.min256(amount, _balances[msg.sender].sub(escrowed));\n\n        totalSupply = totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        if (block.timestamp >= bondedRewardLocks[msg.sender].unlockTime) {\n            require(stakingToken.transfer(msg.sender, amount), \"!tBonded\");\n        } else {\n            uint256 penalty = amount.mul(penaltyPct).div(PCT_BASE);\n            uint256 toTransfer = amount.sub(penalty);\n            require(\n                stakingToken.transfer(msg.sender, toTransfer),\n                \"!tBondedWithPenalty\"\n            );\n            require(stakingToken.transfer(treasury, penalty), \"!tPenalty\");\n        }\n        delete bondedRewardLocks[msg.sender];\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function withdrawUnbonded(uint256 amount)\n        external\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"!withdraw0\");\n\n        uint256 escrowed = token.lockedAmount(msg.sender);\n        require(\n            _balances[msg.sender].sub(escrowed).sub(\n                bondedRewardLocks[msg.sender].amount\n            ) >= amount,\n            \"escrow amount failure\"\n        );\n\n        totalSupply = totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        require(stakingToken.transfer(msg.sender, amount), \"!t\");\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function _baseBoostLevel() internal view returns (uint256) {\n        return PCT_BASE.mul(inverseMaxBoostCoefficient).div(100);\n    }\n\n    function _lockedBoostLevel(address account)\n        internal\n        view\n        returns (uint256)\n    {\n        IVeXBE veXBE = token;\n        uint256 votingBalance = veXBE.balanceOf(account);\n        uint256 votingTotal = veXBE.totalSupply();\n        uint256 lockedAmount = veXBE.lockedAmount(account);\n        if (votingTotal == 0 || votingBalance == 0) {\n            return _baseBoostLevel();\n        }\n\n        uint256 res = PCT_BASE\n            .mul(inverseMaxBoostCoefficient)\n            .add(\n                uint256(100)\n                    .sub(inverseMaxBoostCoefficient)\n                    .mul(PCT_BASE)\n                    .mul(veXBE.lockedSupply())\n                    .div(votingTotal)\n                    .mul(votingBalance)\n                    .div(lockedAmount)\n            )\n            .div(100);\n\n        return res < MAX_BOOST_LEVEL ? res : MAX_BOOST_LEVEL;\n    }\n\n    function calculateBoostLevel(address account)\n        public\n        view\n        returns (uint256)\n    {\n        IVeXBE veXBE = token;\n        uint256 lockedAmount = veXBE.lockedAmount(account);\n\n        uint256 stakedAmount = _balances[account];\n        if (stakedAmount == 0 || lockedAmount == 0) {\n            return _baseBoostLevel();\n        }\n\n        uint256 lockedBoost = boostLogicProvider.hasMaxBoostLevel(account)\n            ? MAX_BOOST_LEVEL\n            : _lockedBoostLevel(account);\n\n        return\n            lockedBoost\n                .mul(lockedAmount)\n                .add(_baseBoostLevel().mul(stakedAmount.sub(lockedAmount)))\n                .div(stakedAmount);\n    }\n\n    function earned(address account)\n        external\n        view\n        returns (\n            uint256 // userEarned\n        )\n    {\n        uint256 duration = lastTimeRewardApplicable().sub(lastUpdateTime);\n        (uint256 userEarned, ) = potentialXbeReturns(duration, account);\n        return userEarned;\n    }\n\n    function potentialXbeReturns(uint256 duration, address account)\n        public\n        view\n        returns (\n            uint256,\n            uint256 // userEarned, toTreasury\n        )\n    {\n        uint256 boostLevel = calculateBoostLevel(account);\n        require(boostLevel <= MAX_BOOST_LEVEL, \"badBoostLevel\");\n\n        uint256 maxBoostedReward = _balances[account]\n            .mul(_rewardPerToken(duration).sub(userRewardPerTokenPaid[account]))\n            .div(PCT_BASE);\n\n        uint256 toUser = maxBoostedReward.mul(boostLevel).div(PCT_BASE);\n        uint256 toTreasury = maxBoostedReward.sub(toUser);\n\n        return (toUser.add(rewards[account]), toTreasury);\n    }\n\n    function getReward() external nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            require(rewardsToken.transfer(msg.sender, reward), \"!t\");\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n}\n"
15     },
16     "/contracts/governance/interfaces/IBoostLogicProvider.sol": {
17       "content": "pragma solidity ^0.4.24;\n\ninterface IBoostLogicProvider {\n    function hasMaxBoostLevel(address account) external view returns (bool);\n}\n"
18     },
19     "/contracts/governance/interfaces/IERC20.sol": {
20       "content": "pragma solidity ^0.4.24;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"
21     },
22     "/contracts/governance/interfaces/IVeXBE.sol": {
23       "content": "pragma solidity ^0.4.24;\n\ninterface IVeXBE {\n    function getLastUserSlope(address addr) external view returns (int128);\n\n    function lockedEnd(address addr) external view returns (uint256);\n\n    function lockedAmount(address addr) external view returns (uint256);\n\n    function userPointEpoch(address addr) external view returns (uint256);\n\n    function userPointHistoryTs(address addr, uint256 epoch)\n        external\n        view\n        returns (uint256);\n\n    function balanceOfAt(address addr, uint256 _block)\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(address addr) external view returns (uint256);\n\n    function balanceOf(address addr, uint256 timestamp)\n        external\n        view\n        returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function lockedSupply() external view returns (uint256);\n\n    function lockStarts(address addr) external view returns (uint256);\n\n    function totalSupplyAt(uint256 _block) external view returns (uint256);\n}\n"
24     },
25     "/contracts/governance/utils/VotingInitializable.sol": {
26       "content": "pragma solidity ^0.4.24;\n\ncontract VotingInitializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"alreadyInitialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
27     },
28     "/contracts/governance/utils/VotingNonReentrant.sol": {
29       "content": "pragma solidity ^0.4.24;\n\ncontract VotingNonReentrant {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status = _NOT_ENTERED;\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
30     },
31     "/contracts/governance/utils/VotingOwnable.sol": {
32       "content": "pragma solidity ^0.4.24;\n\ncontract VotingOwnable {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"!owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"owner0\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
33     },
34     "/contracts/governance/utils/VotingPausable.sol": {
35       "content": "pragma solidity ^0.4.24;\n\ncontract VotingPausable {\n    bool public paused;\n    address private pauser;\n\n    constructor() public {\n        pauser = msg.sender;\n    }\n\n    modifier whenNotPaused() {\n        require(!paused, \"paused\");\n        _;\n    }\n\n    function setPaused(bool _paused) external {\n        require(msg.sender == pauser, \"!pauser\");\n        paused = _paused;\n    }\n\n    function transferOwnership(address newPauser) public {\n        require(msg.sender == pauser, \"!pauser\");\n        pauser = newPauser;\n    }\n}\n"
36     }
37   },
38   "settings": {
39     "remappings": [],
40     "optimizer": {
41       "enabled": true,
42       "runs": 200
43     },
44     "evmVersion": "byzantium",
45     "libraries": {},
46     "outputSelection": {
47       "*": {
48         "*": [
49           "evm.bytecode",
50           "evm.deployedBytecode",
51           "abi"
52         ]
53       }
54     }
55   }
56 }}