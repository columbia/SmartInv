1 {{
2   "language": "Solidity",
3   "sources": {
4     "/Users/Elena/Source/argent-contracts/contracts/infrastructure/IModuleRegistry.sol": {
5       "content": "// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.7.0;\n\n/**\n * @title IModuleRegistry\n * @notice Interface for the registry of authorised modules.\n */\ninterface IModuleRegistry {\n    function registerModule(address _module, bytes32 _name) external;\n\n    function deregisterModule(address _module) external;\n\n    function registerUpgrader(address _upgrader, bytes32 _name) external;\n\n    function deregisterUpgrader(address _upgrader) external;\n\n    function recoverToken(address _token) external;\n\n    function moduleInfo(address _module) external view returns (bytes32);\n\n    function upgraderInfo(address _upgrader) external view returns (bytes32);\n\n    function isRegisteredModule(address _module) external view returns (bool);\n\n    function isRegisteredModule(address[] calldata _modules) external view returns (bool);\n\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool);\n}"
6     },
7     "/Users/Elena/Source/argent-contracts/contracts/infrastructure/WalletFactory.sol": {
8       "content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\nimport \"../wallet/Proxy.sol\";\nimport \"../wallet/BaseWallet.sol\";\nimport \"./base/Owned.sol\";\nimport \"./base/Managed.sol\";\nimport \"./storage/IGuardianStorage.sol\";\nimport \"./IModuleRegistry.sol\";\nimport \"../modules/common/IVersionManager.sol\";\nimport \"../modules/common/Utils.sol\";\n\n/**\n * @title WalletFactory\n * @notice The WalletFactory contract creates and assigns wallets to accounts.\n * @author Julien Niset - <julien@argent.xyz>\n */\ncontract WalletFactory is Owned, Managed {\n\n    address constant internal ETH_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // The address of the module dregistry\n    address public moduleRegistry;\n    // The address of the base wallet implementation\n    address public walletImplementation;\n    // The address of the GuardianStorage\n    address public guardianStorage;\n    // The recipient of the refund\n    address public refundAddress; \n\n    // *************** Events *************************** //\n\n    event ModuleRegistryChanged(address addr);\n    event RefundAddressChanged(address addr);\n    event WalletCreated(address indexed wallet, address indexed owner, address indexed guardian, address refundToken, uint256 refundAmount);\n\n    // *************** Constructor ********************** //\n\n    /**\n     * @notice Default constructor.\n     */\n    constructor(address _moduleRegistry, address _walletImplementation, address _guardianStorage, address _refundAddress) public {\n        require(_moduleRegistry != address(0), \"WF: ModuleRegistry address not defined\");\n        require(_walletImplementation != address(0), \"WF: WalletImplementation address not defined\");\n        require(_guardianStorage != address(0), \"WF: GuardianStorage address not defined\");\n        require(_refundAddress != address(0), \"WF: refund address not defined\");\n        moduleRegistry = _moduleRegistry;\n        walletImplementation = _walletImplementation;\n        guardianStorage = _guardianStorage;\n        refundAddress = _refundAddress;\n    }\n\n    // *************** External Functions ********************* //\n     \n    /**\n     * @notice Lets the manager create a wallet for an owner account at a specific address.\n     * The wallet is initialised with the version manager module, the version number and a first guardian.\n     * The wallet is created using the CREATE2 opcode.\n     * @param _owner The account address.\n     * @param _versionManager The version manager module\n     * @param _guardian The guardian address.\n     * @param _salt The salt.\n     * @param _version The version of the feature bundle.\n     */\n    function createCounterfactualWallet(\n        address _owner,\n        address _versionManager,\n        address _guardian,\n        bytes32 _salt,\n        uint256 _version,\n        uint256 _refundAmount,\n        address _refundToken,\n        bytes calldata _ownerSignature\n    )\n        external\n        onlyManager\n        returns (address _wallet)\n    {\n        validateInputs(_owner, _versionManager, _guardian, _version);\n        bytes32 newsalt = newSalt(_salt, _owner, _versionManager, _guardian, _version);\n        Proxy proxy = new Proxy{salt: newsalt}(walletImplementation);\n        address payable wallet = address(proxy);\n        configureWallet(BaseWallet(wallet), _owner, _versionManager, _guardian, _version);\n        if (_refundAmount > 0 && _ownerSignature.length == 65) {\n            validateAndRefund(wallet, _owner, _refundAmount, _refundToken, _ownerSignature);\n        }\n        // remove the factory from the authorised modules\n        BaseWallet(wallet).authoriseModule(address(this), false);\n\n        // emit event\n        emit WalletCreated(wallet, _owner, _guardian, _refundToken, _refundAmount);\n\n        return wallet;\n    }\n\n    /**\n     * @notice Gets the address of a counterfactual wallet with a first default guardian.\n     * @param _owner The account address.\n     * @param _versionManager The version manager module\n     * @param _guardian The guardian address.\n     * @param _salt The salt.\n     * @param _version The version of feature bundle.\n     * @return _wallet The address that the wallet will have when created using CREATE2 and the same input parameters.\n     */\n    function getAddressForCounterfactualWallet(\n        address _owner,\n        address _versionManager,\n        address _guardian,\n        bytes32 _salt,\n        uint256 _version\n    )\n        external\n        view\n        returns (address _wallet)\n    {\n        validateInputs(_owner, _versionManager, _guardian, _version);\n        bytes32 newsalt = newSalt(_salt, _owner, _versionManager, _guardian, _version);\n        bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint256(walletImplementation));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n        _wallet = address(uint160(uint256(hash)));\n    }\n\n    /**\n     * @notice Lets the owner change the address of the module registry contract.\n     * @param _moduleRegistry The address of the module registry contract.\n     */\n    function changeModuleRegistry(address _moduleRegistry) external onlyOwner {\n        require(_moduleRegistry != address(0), \"WF: address cannot be null\");\n        moduleRegistry = _moduleRegistry;\n        emit ModuleRegistryChanged(_moduleRegistry);\n    }\n\n    /**\n     * @notice Lets the owner change the refund address.\n     * @param _refundAddress The address to use for refunds.\n     */\n    function changeRefundAddress(address _refundAddress) external onlyOwner {\n        require(_refundAddress != address(0), \"WF: address cannot be null\");\n        refundAddress = _refundAddress;\n        emit RefundAddressChanged(_refundAddress);\n    }\n\n    /**\n     * @notice Inits the module for a wallet by doing nothing.\n     * The method can only be called by the wallet itself.\n     * @param _wallet The wallet.\n     */\n    function init(BaseWallet _wallet) external pure {\n        //do nothing\n    }\n\n    // *************** Internal Functions ********************* //\n\n    /**\n     * @notice Helper method to configure a wallet for a set of input parameters.\n     * @param _wallet The target wallet\n     * @param _owner The account address.\n     * @param _versionManager The version manager module\n     * @param _guardian The guardian address.\n     * @param _version The version of the feature bundle.\n     */\n    function configureWallet(\n        BaseWallet _wallet,\n        address _owner,\n        address _versionManager,\n        address _guardian,\n        uint256 _version\n    )\n        internal\n    {\n        // add the factory to modules so it can add a guardian and upgrade the wallet to the required version\n        address[] memory extendedModules = new address[](2);\n        extendedModules[0] = _versionManager;\n        extendedModules[1] = address(this);\n\n        // initialise the wallet with the owner and the extended modules\n        _wallet.init(_owner, extendedModules);\n\n        // add guardian\n        IGuardianStorage(guardianStorage).addGuardian(address(_wallet), _guardian);\n\n        // upgrade the wallet\n        IVersionManager(_versionManager).upgradeWallet(address(_wallet), _version);\n    }\n\n    /**\n     * @notice Generates a new salt based on a provided salt, an owner, a list of modules and an optional guardian.\n     * @param _salt The slat provided.\n     * @param _owner The owner address.\n     * @param _versionManager The version manager module\n     * @param _guardian The guardian address.\n     * @param _version The version of feature bundle\n     */\n    function newSalt(bytes32 _salt, address _owner, address _versionManager, address _guardian, uint256 _version) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_salt, _owner, _versionManager, _guardian, _version));\n    }\n\n    /**\n     * @notice Throws if the owner, guardian, version or version manager is invalid.\n     * @param _owner The owner address.\n     * @param _versionManager The version manager module\n     * @param _guardian The guardian address\n     * @param _version The version of feature bundle\n     */\n    function validateInputs(address _owner, address _versionManager, address _guardian, uint256 _version) internal view {\n        require(_owner != address(0), \"WF: owner cannot be null\");\n        require(IModuleRegistry(moduleRegistry).isRegisteredModule(_versionManager), \"WF: invalid _versionManager\");\n        require(_guardian != (address(0)), \"WF: guardian cannot be null\");\n        require(_version > 0, \"WF: invalid _version\");\n    }\n\n    /**\n     * @notice Refunds the creation of the wallet when provided with a valid signature from the wallet owner.\n     * @param _wallet The wallet created\n     * @param _owner The owner address\n     * @param _refundAmount The amount to refund\n     * @param _refundToken The token to use for the refund\n     * @param _ownerSignature A signature from the wallet owner approving the refund amount and token. \n     */\n    function validateAndRefund(\n        address _wallet,\n        address _owner,\n        uint256 _refundAmount,\n        address _refundToken,\n        bytes memory _ownerSignature\n    )\n        internal\n    {\n        bytes32 signedHash = keccak256(abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(abi.encodePacked(_refundAmount, _refundToken))\n            ));\n        address signer = Utils.recoverSigner(signedHash, _ownerSignature, 0);\n        if (signer == _owner) {\n            if (_refundToken == ETH_TOKEN) {\n                invokeWallet(_wallet, refundAddress, _refundAmount, \"\");\n            } else {\n                bytes memory methodData = abi.encodeWithSignature(\"transfer(address,uint256)\", refundAddress, _refundAmount);\n                bytes memory transferSuccessBytes = invokeWallet(_wallet, _refundToken, 0, methodData);\n                if (transferSuccessBytes.length > 0) {\n                    require(abi.decode(transferSuccessBytes, (bool)), \"WF: Refund transfer failed\");\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Invoke the wallet to execute the refund transfer.\n     * @param _wallet The wallet\n     * @param _to The destination of the call\n     * @param _value The value of the call\n     * @param _data The data associated to the call\n     */\n    function invokeWallet(\n        address _wallet,\n        address _to,\n        uint256 _value,\n        bytes memory _data\n    )\n        internal\n        returns (bytes memory _res)\n    {\n        bool success;\n        (success, _res) = _wallet.call(abi.encodeWithSignature(\"invoke(address,uint256,bytes)\", _to, _value, _data));\n        if (success) {\n            (_res) = abi.decode(_res, (bytes));\n        } else {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n}"
9     },
10     "/Users/Elena/Source/argent-contracts/contracts/infrastructure/base/Managed.sol": {
11       "content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.7.0;\n\nimport \"./Owned.sol\";\n\n/**\n * @title Managed\n * @notice Basic contract that defines a set of managers. Only the owner can add/remove managers.\n * @author Julien Niset - <julien@argent.xyz>\n */\ncontract Managed is Owned {\n\n    // The managers\n    mapping (address => bool) public managers;\n\n    /**\n     * @notice Throws if the sender is not a manager.\n     */\n    modifier onlyManager {\n        require(managers[msg.sender] == true, \"M: Must be manager\");\n        _;\n    }\n\n    event ManagerAdded(address indexed _manager);\n    event ManagerRevoked(address indexed _manager);\n\n    /**\n    * @notice Adds a manager.\n    * @param _manager The address of the manager.\n    */\n    function addManager(address _manager) external onlyOwner {\n        require(_manager != address(0), \"M: Address must not be null\");\n        if (managers[_manager] == false) {\n            managers[_manager] = true;\n            emit ManagerAdded(_manager);\n        }\n    }\n\n    /**\n    * @notice Revokes a manager.\n    * @param _manager The address of the manager.\n    */\n    function revokeManager(address _manager) external onlyOwner {\n        require(managers[_manager] == true, \"M: Target must be an existing manager\");\n        delete managers[_manager];\n        emit ManagerRevoked(_manager);\n    }\n}"
12     },
13     "/Users/Elena/Source/argent-contracts/contracts/infrastructure/base/Owned.sol": {
14       "content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.7.0;\n\n/**\n * @title Owned\n * @notice Basic contract to define an owner.\n * @author Julien Niset - <julien@argent.xyz>\n */\ncontract Owned {\n\n    // The owner\n    address public owner;\n\n    event OwnerChanged(address indexed _newOwner);\n\n    /**\n     * @notice Throws if the sender is not the owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Must be owner\");\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @notice Lets the owner transfer ownership of the contract to a new owner.\n     * @param _newOwner The new owner.\n     */\n    function changeOwner(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"Address must not be null\");\n        owner = _newOwner;\n        emit OwnerChanged(_newOwner);\n    }\n}"
15     },
16     "/Users/Elena/Source/argent-contracts/contracts/infrastructure/storage/IGuardianStorage.sol": {
17       "content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.7.0;\n\ninterface IGuardianStorage {\n\n    /**\n     * @notice Lets an authorised module add a guardian to a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to add.\n     */\n    function addGuardian(address _wallet, address _guardian) external;\n\n    /**\n     * @notice Lets an authorised module revoke a guardian from a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to revoke.\n     */\n    function revokeGuardian(address _wallet, address _guardian) external;\n\n    /**\n     * @notice Checks if an account is a guardian for a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The account.\n     * @return true if the account is a guardian for a wallet.\n     */\n    function isGuardian(address _wallet, address _guardian) external view returns (bool);\n\n    function isLocked(address _wallet) external view returns (bool);\n\n    function getLock(address _wallet) external view returns (uint256);\n\n    function getLocker(address _wallet) external view returns (address);\n\n    function setLock(address _wallet, uint256 _releaseAfter) external;\n\n    function getGuardians(address _wallet) external view returns (address[] memory);\n\n    function guardianCount(address _wallet) external view returns (uint256);\n}"
18     },
19     "/Users/Elena/Source/argent-contracts/contracts/infrastructure/storage/ILimitStorage.sol": {
20       "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\n/**\n * @title ILimitStorage\n * @notice LimitStorage interface\n */\ninterface ILimitStorage {\n\n    struct Limit {\n        // the current limit\n        uint128 current;\n        // the pending limit if any\n        uint128 pending;\n        // when the pending limit becomes the current limit\n        uint64 changeAfter;\n    }\n\n    struct DailySpent {\n        // The amount already spent during the current period\n        uint128 alreadySpent;\n        // The end of the current period\n        uint64 periodEnd;\n    }\n\n    function setLimit(address _wallet, Limit memory _limit) external;\n\n    function getLimit(address _wallet) external view returns (Limit memory _limit);\n\n    function setDailySpent(address _wallet, DailySpent memory _dailySpent) external;\n\n    function getDailySpent(address _wallet) external view returns (DailySpent memory _dailySpent);\n\n    function setLimitAndDailySpent(address _wallet, Limit memory _limit, DailySpent memory _dailySpent) external;\n\n    function getLimitAndDailySpent(address _wallet) external view returns (Limit memory _limit, DailySpent memory _dailySpent);\n}"
21     },
22     "/Users/Elena/Source/argent-contracts/contracts/modules/common/IModule.sol": {
23       "content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.7.0;\n\n/**\n * @title IModule\n * @notice Interface for a module.\n * A module MUST implement the addModule() method to ensure that a wallet with at least one module\n * can never end up in a \"frozen\" state.\n * @author Julien Niset - <julien@argent.xyz>\n */\ninterface IModule {\n    /**\n     * @notice Inits a module for a wallet by e.g. setting some wallet specific parameters in storage.\n     * @param _wallet The wallet.\n     */\n    function init(address _wallet) external;\n\n    /**\t\n     * @notice Adds a module to a wallet. Cannot execute when wallet is locked (or under recovery)\t\n     * @param _wallet The target wallet.\t\n     * @param _module The modules to authorise.\t\n     */\t\n    function addModule(address _wallet, address _module) external;\n}"
24     },
25     "/Users/Elena/Source/argent-contracts/contracts/modules/common/IVersionManager.sol": {
26       "content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../infrastructure/storage/ILimitStorage.sol\";\n\n/**\n * @title IVersionManager\n * @notice Interface for the VersionManager module.\n * @author Olivier VDB - <olivier@argent.xyz>\n */\ninterface IVersionManager {\n    /**\n     * @notice Returns true if the feature is authorised for the wallet\n     * @param _wallet The target wallet.\n     * @param _feature The feature.\n     */\n    function isFeatureAuthorised(address _wallet, address _feature) external view returns (bool);\n\n    /**\n     * @notice Lets a feature (caller) invoke a wallet.\n     * @param _wallet The target wallet.\n     * @param _to The target address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function checkAuthorisedFeatureAndInvokeWallet(\n        address _wallet,\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes memory _res);\n\n    /* ******* Backward Compatibility with old Storages and BaseWallet *************** */\n\n    /**\n     * @notice Sets a new owner for the wallet.\n     * @param _newOwner The new owner.\n     */\n    function setOwner(address _wallet, address _newOwner) external;\n\n    /**\n     * @notice Lets a feature write data to a storage contract.\n     * @param _wallet The target wallet.\n     * @param _storage The storage contract.\n     * @param _data The data of the call\n     */\n    function invokeStorage(address _wallet, address _storage, bytes calldata _data) external;\n\n    /**\n     * @notice Upgrade a wallet to a new version.\n     * @param _wallet the wallet to upgrade\n     * @param _toVersion the new version\n     */\n    function upgradeWallet(address _wallet, uint256 _toVersion) external;\n \n}"
27     },
28     "/Users/Elena/Source/argent-contracts/contracts/modules/common/Utils.sol": {
29       "content": "// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\n/**\n * @title Utils\n * @notice Common utility methods used by modules.\n */\nlibrary Utils {\n\n    /**\n    * @notice Helper method to recover the signer at a given position from a list of concatenated signatures.\n    * @param _signedHash The signed hash\n    * @param _signatures The concatenated signatures.\n    * @param _index The index of the signature to recover.\n    */\n    function recoverSigner(bytes32 _signedHash, bytes memory _signatures, uint _index) internal pure returns (address) {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        // we jump 32 (0x20) as the first slot of bytes contains the length\n        // we jump 65 (0x41) per signature\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\n        }\n        require(v == 27 || v == 28);\n\n        address recoveredAddress = ecrecover(_signedHash, v, r, s);\n        require(recoveredAddress != address(0), \"Utils: ecrecover returned 0\");\n        return recoveredAddress;\n    }\n\n    /**\n    * @notice Helper method to parse data and extract the method signature.\n    */\n    function functionPrefix(bytes memory _data) internal pure returns (bytes4 prefix) {\n        require(_data.length >= 4, \"RM: Invalid functionPrefix\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            prefix := mload(add(_data, 0x20))\n        }\n    }\n\n    /**\n    * @notice Returns ceil(a / b).\n    */\n    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        if (a % b == 0) {\n            return c;\n        } else {\n            return c + 1;\n        }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a < b) {\n            return a;\n        }\n        return b;\n    }\n}\n"
30     },
31     "/Users/Elena/Source/argent-contracts/contracts/wallet/BaseWallet.sol": {
32       "content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\nimport \"../modules/common/IModule.sol\";\nimport \"./IWallet.sol\";\n\n/**\n * @title BaseWallet\n * @notice Simple modular wallet that authorises modules to call its invoke() method.\n * @author Julien Niset - <julien@argent.xyz>\n */\ncontract BaseWallet is IWallet {\n\n    // The implementation of the proxy\n    address public implementation;\n    // The owner\n    address public override owner;\n    // The authorised modules\n    mapping (address => bool) public override authorised;\n    // The enabled static calls\n    mapping (bytes4 => address) public override enabled;\n    // The number of modules\n    uint public override modules;\n\n    event AuthorisedModule(address indexed module, bool value);\n    event EnabledStaticCall(address indexed module, bytes4 indexed method);\n    event Invoked(address indexed module, address indexed target, uint indexed value, bytes data);\n    event Received(uint indexed value, address indexed sender, bytes data);\n    event OwnerChanged(address owner);\n\n    /**\n     * @notice Throws if the sender is not an authorised module.\n     */\n    modifier moduleOnly {\n        require(authorised[msg.sender], \"BW: msg.sender not an authorized module\");\n        _;\n    }\n\n    /**\n     * @notice Inits the wallet by setting the owner and authorising a list of modules.\n     * @param _owner The owner.\n     * @param _modules The modules to authorise.\n     */\n    function init(address _owner, address[] calldata _modules) external {\n        require(owner == address(0) && modules == 0, \"BW: wallet already initialised\");\n        require(_modules.length > 0, \"BW: construction requires at least 1 module\");\n        owner = _owner;\n        modules = _modules.length;\n        for (uint256 i = 0; i < _modules.length; i++) {\n            require(authorised[_modules[i]] == false, \"BW: module is already added\");\n            authorised[_modules[i]] = true;\n            IModule(_modules[i]).init(address(this));\n            emit AuthorisedModule(_modules[i], true);\n        }\n        if (address(this).balance > 0) {\n            emit Received(address(this).balance, address(0), \"\");\n        }\n    }\n\n    /**\n     * @inheritdoc IWallet\n     */\n    function authoriseModule(address _module, bool _value) external override moduleOnly {\n        if (authorised[_module] != _value) {\n            emit AuthorisedModule(_module, _value);\n            if (_value == true) {\n                modules += 1;\n                authorised[_module] = true;\n                IModule(_module).init(address(this));\n            } else {\n                modules -= 1;\n                require(modules > 0, \"BW: wallet must have at least one module\");\n                delete authorised[_module];\n            }\n        }\n    }\n\n    /**\n    * @inheritdoc IWallet\n    */\n    function enableStaticCall(address _module, bytes4 _method) external override moduleOnly {\n        require(authorised[_module], \"BW: must be an authorised module for static call\");\n        enabled[_method] = _module;\n        emit EnabledStaticCall(_module, _method);\n    }\n\n    /**\n     * @inheritdoc IWallet\n     */\n    function setOwner(address _newOwner) external override moduleOnly {\n        require(_newOwner != address(0), \"BW: address cannot be null\");\n        owner = _newOwner;\n        emit OwnerChanged(_newOwner);\n    }\n\n    /**\n     * @notice Performs a generic transaction.\n     * @param _target The address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function invoke(address _target, uint _value, bytes calldata _data) external moduleOnly returns (bytes memory _result) {\n        bool success;\n        (success, _result) = _target.call{value: _value}(_data);\n        if (!success) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n        emit Invoked(msg.sender, _target, _value, _data);\n    }\n\n    /**\n     * @notice This method delegates the static call to a target contract if the data corresponds\n     * to an enabled module, or logs the call otherwise.\n     */\n    fallback() external payable {\n        address module = enabled[msg.sig];\n        if (module == address(0)) {\n            emit Received(msg.value, msg.sender, msg.data);\n        } else {\n            require(authorised[module], \"BW: must be an authorised module for static call\");\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                calldatacopy(0, 0, calldatasize())\n                let result := staticcall(gas(), module, 0, calldatasize(), 0, 0)\n                returndatacopy(0, 0, returndatasize())\n                switch result\n                case 0 {revert(0, returndatasize())}\n                default {return (0, returndatasize())}\n            }\n        }\n    }\n\n    receive() external payable {\n    }\n}"
33     },
34     "/Users/Elena/Source/argent-contracts/contracts/wallet/IWallet.sol": {
35       "content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.7.0;\n\n/**\n * @title IWallet\n * @notice Interface for the BaseWallet\n */\ninterface IWallet {\n    /**\n     * @notice Returns the wallet owner.\n     * @return The wallet owner address.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Returns the number of authorised modules.\n     * @return The number of authorised modules.\n     */\n    function modules() external view returns (uint);\n\n    /**\n     * @notice Sets a new owner for the wallet.\n     * @param _newOwner The new owner.\n     */\n    function setOwner(address _newOwner) external;\n\n    /**\n     * @notice Checks if a module is authorised on the wallet.\n     * @param _module The module address to check.\n     * @return `true` if the module is authorised, otherwise `false`.\n     */\n    function authorised(address _module) external view returns (bool);\n\n    /**\n     * @notice Returns the module responsible for a static call redirection.\n     * @param _sig The signature of the static call.\n     * @return the module doing the redirection\n     */\n    function enabled(bytes4 _sig) external view returns (address);\n\n    /**\n     * @notice Enables/Disables a module.\n     * @param _module The target module.\n     * @param _value Set to `true` to authorise the module.\n     */\n    function authoriseModule(address _module, bool _value) external;\n\n    /**\n    * @notice Enables a static method by specifying the target module to which the call must be delegated.\n    * @param _module The target module.\n    * @param _method The static method signature.\n    */\n    function enableStaticCall(address _module, bytes4 _method) external;\n}"
36     },
37     "/Users/Elena/Source/argent-contracts/contracts/wallet/Proxy.sol": {
38       "content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\n/**\n * @title Proxy\n * @notice Basic proxy that delegates all calls to a fixed implementing contract.\n * The implementing contract cannot be upgraded.\n * @author Julien Niset - <julien@argent.xyz>\n */\ncontract Proxy {\n\n    address implementation;\n\n    event Received(uint indexed value, address indexed sender, bytes data);\n\n    constructor(address _implementation) public {\n        implementation = _implementation;\n    }\n\n    fallback() external payable {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let target := sload(0)\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {revert(0, returndatasize())}\n            default {return (0, returndatasize())}\n        }\n    }\n\n    receive() external payable {\n        emit Received(msg.value, msg.sender, msg.data);\n    }\n}"
39     }
40   },
41   "settings": {
42     "remappings": [],
43     "optimizer": {
44       "enabled": true,
45       "runs": 999
46     },
47     "evmVersion": "istanbul",
48     "libraries": {
49       "": {}
50     },
51     "outputSelection": {
52       "*": {
53         "*": [
54           "evm.bytecode",
55           "evm.deployedBytecode",
56           "abi"
57         ]
58       }
59     }
60   }
61 }}