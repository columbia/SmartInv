1 {{
2   "language": "Solidity",
3   "sources": {
4     "/home/hunter/projects/farmland/farmland-contract-development/contracts/Corn.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.9;\n\nimport \"@openzeppelin/contracts/token/ERC777/IERC777.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/introspection/IERC1820Registry.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/ERC777.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Sender.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @dev Details of a farm at an address\n */\nstruct Farm {\n    uint256 amount;\n    uint256 compostedAmount;\n    uint256 blockNumber;\n    uint256 lastHarvestedBlockNumber;\n    address harvesterAddress;\n}\n\n/**\n * @dev Farmland - Crop Smart Contract\n */\ncontract Corn is ERC777, IERC777Recipient, ReentrancyGuard {\n    /**\n     * @dev Protect against overflows by using safe math operations (these are .add,.sub functions)\n     */\n    using SafeMath for uint256;\n\n    /**\n     * @dev To limit one action per block per address\n     */\n    modifier preventSameBlock(address targetAddress) {\n        require(\n            farms[targetAddress].blockNumber != block.number &&\n                farms[targetAddress].lastHarvestedBlockNumber != block.number,\n            \"You can not allocate/release or harvest in the same block\"\n        );\n        _; // Call the actual code\n    }\n\n    /**\n     * @dev There must be a farm on this LAND to execute this function\n     */\n    modifier requireFarm(address targetAddress, bool requiredState) {\n        if (requiredState) {\n            require(\n                farms[targetAddress].amount != 0,\n                \"You must have allocated land to grow crops on your farm\"\n            );\n        } else {\n            require(\n                farms[targetAddress].amount == 0,\n                \"You must have released your land\"\n            );\n        }\n        _; // Call the actual code\n    }\n\n    /**\n     * @dev This will be LAND token smart contract address\n     */\n    IERC777 private immutable _token;\n    IERC1820Registry private _erc1820 =\n        IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n    bytes32 private constant TOKENS_RECIPIENT_INTERFACE_HASH =\n        keccak256(\"ERC777TokensRecipient\");\n\n    /**\n     * @dev Decline some incoming transactions (Only allow crop smart contract to send/receive LAND)\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata,\n        bytes calldata\n    ) external override {\n        require(amount > 0, \"You must receive a positive number of tokens\");\n        require(\n            _msgSender() == address(_token),\n            \"You can only build farms on LAND\"\n        );\n\n        // Ensure someone doesn't send in some LAND to this contract by mistake (Only the contract itself can send itself LAND)\n        require(\n            operator == address(this),\n            \"Only CORN contract can send itself LAND tokens\"\n        );\n        require(to == address(this), \"Funds must be coming into a CORN token\");\n        require(from != to, \"Why would CORN contract send tokens to itself?\");\n    }\n\n    /**\n     * @dev How many blocks before the farm maturity boost starts ( Set to 6400 on mainnet - around 1 day )\n     */\n    uint256 private immutable _startMaturityBoost;\n\n    /**\n     * @dev How many blocks before the maximum 3x farm maturity boost is reached ( Set to 179200 on mainnet - around 28 days)\n     */\n    uint256 private immutable _endMaturityBoost;\n\n    /**\n     * @dev How many blocks until the fail safe limit is lifted and you are able to allocate any amount of LAND to growing crops (Set to 161280 on mainnet for 28 day failsafe period)\n     */\n    uint256 private immutable _failsafeTargetBlock;\n\n    constructor(\n        address token,\n        uint256 startMaturityBoost,\n        uint256 endMaturityBoost,\n        uint256 failsafeBlockDuration\n    ) public ERC777(\"Corn\", \"CORN\", new address[](0)) {\n        require(\n            endMaturityBoost > 0,\n            \"endMaturityBoost must be at least 1 block (min 24 hours before time farm maturation starts)\"\n        ); // to avoid division by 0\n\n        _token = IERC777(token);\n        _startMaturityBoost = startMaturityBoost;\n        _endMaturityBoost = endMaturityBoost;\n        _failsafeTargetBlock = block.number.add(failsafeBlockDuration);\n\n        _erc1820.setInterfaceImplementer(\n            address(this),\n            TOKENS_RECIPIENT_INTERFACE_HASH,\n            address(this)\n        );\n    }\n\n    /**\n     * @dev 0.00000001 crops grown per block for each LAND allocated to a farm ... 10^18 / 10^8 = 10^10\n     */\n    uint256 private constant _harvestPerBlockDivisor = 10**8;\n\n    /**\n     * @dev To avoid small burn ratios we multiply the ratios by this number.\n     */\n    uint256 private constant _ratioMultiplier = 10**10;\n\n    /**\n     * @dev To get 4 decimals on our multipliers, we multiply all ratios & divide ratios by this number.\n     * @dev This is done because we're using integers without any decimals.\n     */\n    uint256 private constant _percentMultiplier = 10000;\n\n    /**\n     * @dev The maximum LAND that can be allocated to a farm during fail safe period.\n     */\n    uint256 public constant failsafeMaxAmount = 1000 * (10**18);\n\n    /**\n     * @dev This is the farm's maximum 10x compost productivity boost. It's multiplicative with the maturity boost.\n     */\n    uint256 public constant maxCompostBoost = 100000;\n\n    /**\n     * @dev This is the farm's maximum 3x maturity productivity boost. It's multiplicative with the compost boost.\n     */\n    uint256 public constant maxMaturityBoost = 30000;\n\n    /**\n     * @dev This is the maximum number of blocks in each growth cycle ( around 42 days) before a harvest is required. After this many blocks crop will stop growing.\n     */\n    uint256 public constant maxGrowthCycle = 268800;\n\n    /**\n     * @dev This is the maximum the maturity boost extends beyond the base level of 1x. This is the \"2x\" in the \"1x base + (0x to 2x bonus) with a maximum of 3x\"\n     */\n    uint256 public constant maturityBoostExtension = 20000;\n\n    /**\n     * @dev PUBLIC: By making farms public we can access elements through the contract view (vs having to create methods)\n     */\n    mapping(address => Farm) public farms;\n\n    /**\n     * @dev PUBLIC: Store how much LAND is allocated to growing crops in farms globally\n     */\n    uint256 public globalAllocatedAmount;\n\n    /**\n     * @dev PUBLIC: Store how much is crop has been composted globally (only from active farms on LAND addresses)\n     */\n    uint256 public globalCompostedAmount;\n\n    /**\n     * @dev PUBLIC: Store how many addresses currently have an active farm\n     */\n    uint256 public globalTotalFarms;\n\n    // Events\n    event Allocated(\n        address sender,\n        uint256 blockNumber,\n        address farmerAddress,\n        uint256 amount,\n        uint256 burnedAmountIncrease\n    );\n    event Released(\n        address sender,\n        uint256 amount,\n        uint256 burnedAmountDecrease\n    );\n    event Composted(\n        address sender,\n        address targetAddress,\n        uint256 amount\n    );\n    event Harvested(\n        address sender,\n        uint256 blockNumber,\n        address sourceAddress,\n        address targetAddress,\n        uint256 targetBlock,\n        uint256 amount\n    );\n\n    //////////////////// END HEADER //////////////////////\n\n    /**\n     * @dev PUBLIC: Allocate LAND to growing crops on a farm with the specified address as the harvester.\n     */\n    function allocate(address farmerAddress, uint256 amount)\n        public\n        nonReentrant()\n        preventSameBlock(_msgSender())\n        requireFarm(_msgSender(), false) // Ensure LAND is not already in a farm\n    {\n        require(\n            amount > 0,\n            \"You must provide a positive amount of LAND to build a farm\"\n        );\n\n        // Ensure you can only lock up to a limited amount of LAND during failsafe period\n        if (block.number < _failsafeTargetBlock) {\n            require(\n                amount <= failsafeMaxAmount,\n                \"You can only allocate a maximum of 1000 LAND during failsafe.\"\n            );\n        }\n\n        Farm storage senderFarm = farms[_msgSender()]; // Shortcut accessor\n\n        senderFarm.amount = amount;\n        senderFarm.blockNumber = block.number;\n        senderFarm.lastHarvestedBlockNumber = block.number; // Reset the last harvest height to the new LAND allocation height\n        senderFarm.harvesterAddress = farmerAddress;\n\n        globalAllocatedAmount = globalAllocatedAmount.add(amount);\n        globalCompostedAmount = globalCompostedAmount.add(\n            senderFarm.compostedAmount\n        );\n        globalTotalFarms += 1;\n\n        emit Allocated(\n            _msgSender(),\n            block.number,\n            farmerAddress,\n            amount,\n            senderFarm.compostedAmount\n        );\n\n        // Send [amount] of LAND token from the address that is calling this function to crop smart contract.\n        IERC777(_token).operatorSend(\n            _msgSender(),\n            address(this),\n            amount,\n            \"\",\n            \"\"\n        ); // [RE-ENTRANCY WARNING] external call, must be at the end\n    }\n\n    /**\n     * @dev PUBLIC: Releasing a farm returns LAND to the owners\n     */\n    function release()\n        public\n        nonReentrant()\n        preventSameBlock(_msgSender())\n        requireFarm(_msgSender(), true) // Ensure the address you are releasing has a farm on the LAND\n    {\n        Farm storage senderFarm = farms[_msgSender()]; // Shortcut accessor\n\n        uint256 amount = senderFarm.amount;\n        senderFarm.amount = 0;\n\n        globalAllocatedAmount = globalAllocatedAmount.sub(amount);\n        globalCompostedAmount = globalCompostedAmount.sub(\n            senderFarm.compostedAmount\n        );\n        globalTotalFarms = globalTotalFarms.sub(1);\n\n        emit Released(_msgSender(), amount, senderFarm.compostedAmount);\n\n        // Send back the LAND amount to person calling the method\n        IERC777(_token).send(_msgSender(), amount, \"\"); // [RE-ENTRANCY WARNING] external call, must be at the end\n    }\n\n    /**\n     * @dev PUBLIC: Composting a crop fertilizes a farm at specific address\n     */\n    function compost(address targetAddress, uint256 amount)\n        public\n        nonReentrant()\n        requireFarm(targetAddress, true) // Ensure the address you are composting to has a farm on the LAND\n    {\n        require(amount > 0, \"Nothing to compost\");\n\n        Farm storage targetFarm = farms[targetAddress]; // Shortcut accessor, pay attention to targetAddress here\n\n        targetFarm.compostedAmount = targetFarm.compostedAmount.add(amount);\n\n        globalCompostedAmount = globalCompostedAmount.add(amount);\n\n        emit Composted(_msgSender(), targetAddress, amount);\n\n        // Call the normal ERC-777 burn (this will destroy a crop token). We don't check address balance for amount because the internal burn does this check for us.\n        _burn(_msgSender(), amount, \"\", \"\"); // [RE-ENTRANCY WARNING] external call, must be at the end\n    }\n\n    /**\n     * @dev PUBLIC: Harvests crops from a specific address to a specified address UP TO the target block\n     */\n    function harvest(\n        address sourceAddress,\n        address targetAddress,\n        uint256 targetBlock\n    )\n        public\n        nonReentrant()\n        preventSameBlock(sourceAddress)\n        requireFarm(sourceAddress, true) // Ensure the adress that is being harvested has a farm on the LAND\n    {\n        require(\n            targetBlock <= block.number,\n            \"You can only harvest up to current block\"\n        );\n\n        Farm storage sourceFarm = farms[sourceAddress]; // Shortcut accessor, pay attention to sourceAddress here\n\n        require(\n            sourceFarm.lastHarvestedBlockNumber < targetBlock,\n            \"You can only harvest ahead of last harvested block\"\n        );\n        require(\n            sourceFarm.harvesterAddress == _msgSender(),\n            \"You must be the delegated harvester of the sourceAddress\"\n        );\n\n        uint256 mintAmount = getHarvestAmount(sourceAddress, targetBlock);\n        require(mintAmount > 0, \"Nothing to harvest\");\n\n        sourceFarm.lastHarvestedBlockNumber = targetBlock; // Reset the last harvested height\n\n        emit Harvested(\n            _msgSender(),\n            block.number,\n            sourceAddress,\n            targetAddress,\n            targetBlock,\n            mintAmount\n        );\n\n        // Call the normal ERC-777 mint (this will harvest crop tokens to targetAddress)\n        _mint(targetAddress, mintAmount, \"\", \"\"); // [RE-ENTRANCY WARNING] external call, must be at the end\n    }\n\n    //////////////////// VIEW ONLY //////////////////////\n\n    /**\n     * @dev PUBLIC: Get the harvested amount of a specific address up to a target block\n     */\n    function getHarvestAmount(address targetAddress, uint256 targetBlock)\n        public\n        view\n        returns (uint256)\n    {\n        Farm storage targetFarm = farms[targetAddress]; // Shortcut accessor\n\n        // Ensure this address has a farm on the LAND\n        if (targetFarm.amount == 0) {\n            return 0;\n        }\n\n        require(\n            targetBlock <= block.number,\n            \"You can only calculate up to current block\"\n        );\n        require(\n            targetFarm.lastHarvestedBlockNumber <= targetBlock,\n            \"You can only specify blocks at or ahead of last harvested block\"\n        );\n\n        uint256 lastBlockInGrowthCycle =\n            targetFarm.lastHarvestedBlockNumber.add(maxGrowthCycle); // end of growth cycle last allowed block\n        uint256 blocksMinted = maxGrowthCycle;\n\n        if (targetBlock < lastBlockInGrowthCycle) {\n            blocksMinted = targetBlock.sub(targetFarm.lastHarvestedBlockNumber);\n        }\n\n        uint256 amount = targetFarm.amount; // Total of size of the farm in LAND for this address\n        uint256 blocksMintedByAmount = amount.mul(blocksMinted);\n\n        // Adjust by multipliers\n        uint256 compostMultiplier = getAddressCompostMultiplier(targetAddress);\n        uint256 maturityMultipler = getAddressMaturityMultiplier(targetAddress);\n        uint256 afterMultiplier =\n            blocksMintedByAmount\n                .mul(compostMultiplier)\n                .div(_percentMultiplier)\n                .mul(maturityMultipler)\n                .div(_percentMultiplier);\n\n        uint256 actualMinted = afterMultiplier.div(_harvestPerBlockDivisor);\n\n        return actualMinted;\n    }\n\n    /**\n     * @dev PUBLIC: Find out a farms maturity boost for the current LAND address (Using 1 block = 13.5 sec formula)\n     */\n    function getAddressMaturityMultiplier(address targetAddress)\n        public\n        view\n        returns (uint256)\n    {\n        Farm storage targetFarm = farms[targetAddress]; // Shortcut accessor\n\n        // Ensure this address has a farm on the LAND\n        if (targetFarm.amount == 0) {\n            return _percentMultiplier;\n        }\n\n        // You don't get a boost until minimum blocks passed\n        uint256 targetBlockNumber =\n            targetFarm.blockNumber.add(_startMaturityBoost);\n        if (block.number < targetBlockNumber) {\n            return _percentMultiplier;\n        }\n\n        // 24 hours - min before starting to receive rewards\n        // 28 days - max for waiting 28 days (The function returns PERCENT (10000x) the multiplier for 4 decimal accuracy\n        uint256 blockDiff =\n            block.number\n            .sub(targetBlockNumber)\n            .mul(maturityBoostExtension)\n            .div(_endMaturityBoost)\n            .add(_percentMultiplier);\n\n        uint256 timeMultiplier = Math.min(maxMaturityBoost, blockDiff); // Min 1x, Max 3x\n        return timeMultiplier;\n    }\n\n    /**\n     * @dev PUBLIC: Find out a farms compost productivity boost for a specific address. This will be returned as PERCENT (10000x)\n     */\n    function getAddressCompostMultiplier(address targetAddress)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 myRatio = getAddressRatio(targetAddress);\n        uint256 globalRatio = getGlobalRatio();\n\n        // Avoid division by 0 & ensure 1x boost if nothing is locked\n        if (globalRatio == 0 || myRatio == 0) {\n            return _percentMultiplier;\n        }\n\n        // The final multiplier is return with 10000x multiplication and will need to be divided by 10000 for final number\n        uint256 compostMultiplier =\n            Math.min(\n                maxCompostBoost,\n                myRatio.mul(_percentMultiplier).div(globalRatio).add(\n                    _percentMultiplier\n                )\n            ); // Min 1x, Max 10x\n        return compostMultiplier;\n    }\n\n    /**\n     * @dev PUBLIC: Get LAND/CROP burn ratio for a specific address\n     */\n    function getAddressRatio(address targetAddress)\n        public\n        view\n        returns (uint256)\n    {\n        Farm storage targetFarm = farms[targetAddress]; // Shortcut accessor\n\n        uint256 addressLockedAmount = targetFarm.amount;\n        uint256 addressBurnedAmount = targetFarm.compostedAmount;\n\n        // If you haven't harvested or composted anything then you get the default 1x boost\n        if (addressLockedAmount == 0) {\n            return 0;\n        }\n\n        // Compost/Maturity ratios for both address & network\n        // Note that we multiply both ratios by the ratio multiplier before dividing. For tiny CROP/LAND burn ratios.\n        uint256 myRatio =\n            addressBurnedAmount.mul(_ratioMultiplier).div(addressLockedAmount);\n        return myRatio;\n    }\n\n    /**\n     * @dev PUBLIC: Get LAND/CROP compost ratio for global (entire network)\n     */\n    function getGlobalRatio() public view returns (uint256) {\n        // If you haven't harvested or composted anything then you get the default 1x multiplier\n        if (globalAllocatedAmount == 0) {\n            return 0;\n        }\n\n        // Compost/Maturity for both address & network\n        // Note that we multiply both ratios by the ratio multiplier before dividing. For tiny CROP/LAND burn ratios.\n        uint256 globalRatio =\n            globalCompostedAmount.mul(_ratioMultiplier).div(globalAllocatedAmount);\n        return globalRatio;\n    }\n\n    /**\n     * @dev PUBLIC: Get Average LAND/CROP compost ratio for global (entire network)\n     */\n    function getGlobalAverageRatio() public view returns (uint256) {\n        // If you haven't harvested or composted anything then you get the default 1x multiplier\n        if (globalAllocatedAmount == 0) {\n            return 0;\n        }\n\n        // Compost/Maturity for both address & network\n        // Note that we multiply both ratios by the ratio multiplier before dividing. For tiny CROP/LAND burn ratios.\n        uint256 globalAverageRatio =\n            globalCompostedAmount\n                .mul(_ratioMultiplier)\n                .div(globalAllocatedAmount)\n                .div(globalTotalFarms);\n        return globalAverageRatio;\n    }\n\n    /**\n     * @dev PUBLIC: Grab a collection of data associated with an address\n     */\n    function getAddressDetails(address targetAddress)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 cropBalance = balanceOf(targetAddress);\n        uint256 harvestAmount = getHarvestAmount(targetAddress, block.number);\n\n        uint256 addressMaturityMultiplier = getAddressMaturityMultiplier(targetAddress);\n        uint256 addressCompostMultiplier = getAddressCompostMultiplier(targetAddress);\n\n        return (\n            block.number,\n            cropBalance,\n            harvestAmount,\n            addressMaturityMultiplier,\n            addressCompostMultiplier\n        );\n    }\n\n    /**\n     * @dev PUBLIC: Get additional token details\n     */\n    function getAddressTokenDetails(address targetAddress)\n        public\n        view\n        returns (\n            uint256,\n            bool,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        bool isOperator =\n            IERC777(_token).isOperatorFor(address(this), targetAddress);\n        uint256 landBalance = IERC777(_token).balanceOf(targetAddress);\n        uint256 myRatio = getAddressRatio(targetAddress);\n        uint256 globalRatio = getGlobalRatio();\n        uint256 globalAverageRatio = getGlobalAverageRatio();\n\n        return (\n            block.number,\n            isOperator,\n            landBalance,\n            myRatio,\n            globalRatio,\n            globalAverageRatio\n        );\n    }\n\n    /**\n     * @dev PUBLIC: Get some global details\n     */\n    function getGlobalDetails()\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 globalRatio = getGlobalRatio();\n        uint256 globalAverageRatio = getGlobalAverageRatio();\n\n        return (\n            globalTotalFarms,\n            globalRatio,\n            globalAverageRatio,\n            globalAllocatedAmount,\n            globalCompostedAmount\n        );\n    }\n\n    /**\n     * @dev PUBLIC: Get some contracts constants\n     */\n    function getConstantDetails()\n        public\n        pure\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            maxCompostBoost,\n            maxMaturityBoost,\n            maxGrowthCycle,\n            maturityBoostExtension\n        );\n    }\n}\n"
6     },
7     "@openzeppelin/contracts/GSN/Context.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
9     },
10     "@openzeppelin/contracts/introspection/IERC1820Registry.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
12     },
13     "@openzeppelin/contracts/math/Math.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
15     },
16     "@openzeppelin/contracts/math/SafeMath.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
18     },
19     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
21     },
22     "@openzeppelin/contracts/token/ERC777/ERC777.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC777.sol\";\nimport \"./IERC777Recipient.sol\";\nimport \"./IERC777Sender.sol\";\nimport \"../../token/ERC20/IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../introspection/IERC1820Registry.sol\";\n\n/**\n * @dev Implementation of the {IERC777} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * Support for ERC20 is included in this contract, as specified by the EIP: both\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\n * movements.\n *\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\n * are no special restrictions in the amount of tokens that created, moved, or\n * destroyed. This makes integration with ERC20 applications seamless.\n */\ncontract ERC777 is Context, IERC777, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    IERC1820Registry constant internal _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    mapping(address => uint256) private _balances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    // We inline the result of the following hashes because Solidity doesn't resolve them at compile time.\n    // See https://github.com/ethereum/solidity/issues/4024.\n\n    // keccak256(\"ERC777TokensSender\")\n    bytes32 constant private _TOKENS_SENDER_INTERFACE_HASH =\n        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\n\n    // keccak256(\"ERC777TokensRecipient\")\n    bytes32 constant private _TOKENS_RECIPIENT_INTERFACE_HASH =\n        0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\n    address[] private _defaultOperatorsArray;\n\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n    mapping(address => bool) private _defaultOperators;\n\n    // For each account, a mapping of its operators and revoked default operators.\n    mapping(address => mapping(address => bool)) private _operators;\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\n\n    // ERC20-allowances\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    /**\n     * @dev `defaultOperators` may be an empty array.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address[] memory defaultOperators_\n    ) public {\n        _name = name_;\n        _symbol = symbol_;\n\n        _defaultOperatorsArray = defaultOperators_;\n        for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\n            _defaultOperators[_defaultOperatorsArray[i]] = true;\n        }\n\n        // register interfaces\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n    }\n\n    /**\n     * @dev See {IERC777-name}.\n     */\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC777-symbol}.\n     */\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {ERC20-decimals}.\n     *\n     * Always returns 18, as per the\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n     */\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC777-granularity}.\n     *\n     * This implementation always returns `1`.\n     */\n    function granularity() public view override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @dev See {IERC777-totalSupply}.\n     */\n    function totalSupply() public view override(IERC20, IERC777) returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\n     */\n    function balanceOf(address tokenHolder) public view override(IERC20, IERC777) returns (uint256) {\n        return _balances[tokenHolder];\n    }\n\n    /**\n     * @dev See {IERC777-send}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function send(address recipient, uint256 amount, bytes memory data) public override  {\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n     * interface if it is a contract.\n     *\n     * Also emits a {Sent} event.\n     */\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n\n        address from = _msgSender();\n\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\n\n        _move(from, from, recipient, amount, \"\", \"\");\n\n        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev See {IERC777-burn}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function burn(uint256 amount, bytes memory data) public override  {\n        _burn(_msgSender(), amount, data, \"\");\n    }\n\n    /**\n     * @dev See {IERC777-isOperatorFor}.\n     */\n    function isOperatorFor(\n        address operator,\n        address tokenHolder\n    ) public view override returns (bool) {\n        return operator == tokenHolder ||\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n            _operators[tokenHolder][operator];\n    }\n\n    /**\n     * @dev See {IERC777-authorizeOperator}.\n     */\n    function authorizeOperator(address operator) public override  {\n        require(_msgSender() != operator, \"ERC777: authorizing self as operator\");\n\n        if (_defaultOperators[operator]) {\n            delete _revokedDefaultOperators[_msgSender()][operator];\n        } else {\n            _operators[_msgSender()][operator] = true;\n        }\n\n        emit AuthorizedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-revokeOperator}.\n     */\n    function revokeOperator(address operator) public override  {\n        require(operator != _msgSender(), \"ERC777: revoking self as operator\");\n\n        if (_defaultOperators[operator]) {\n            _revokedDefaultOperators[_msgSender()][operator] = true;\n        } else {\n            delete _operators[_msgSender()][operator];\n        }\n\n        emit RevokedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-defaultOperators}.\n     */\n    function defaultOperators() public view override returns (address[] memory) {\n        return _defaultOperatorsArray;\n    }\n\n    /**\n     * @dev See {IERC777-operatorSend}.\n     *\n     * Emits {Sent} and {IERC20-Transfer} events.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    )\n    public override\n    {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n        _send(sender, recipient, amount, data, operatorData, true);\n    }\n\n    /**\n     * @dev See {IERC777-operatorBurn}.\n     *\n     * Emits {Burned} and {IERC20-Transfer} events.\n     */\n    function operatorBurn(address account, uint256 amount, bytes memory data, bytes memory operatorData) public override {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n        _burn(account, amount, data, operatorData);\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators may\n     * not have allowance, and accounts with allowance may not be operators\n     * themselves.\n     */\n    function allowance(address holder, address spender) public view override returns (uint256) {\n        return _allowances[holder][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function approve(address spender, uint256 value) public override returns (bool) {\n        address holder = _msgSender();\n        _approve(holder, spender, value);\n        return true;\n    }\n\n   /**\n    * @dev See {IERC20-transferFrom}.\n    *\n    * Note that operator and allowance concepts are orthogonal: operators cannot\n    * call `transferFrom` (unless they have allowance), and accounts with\n    * allowance cannot call `operatorSend` (unless they are operators).\n    *\n    * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.\n    */\n    function transferFrom(address holder, address recipient, uint256 amount) public override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n        require(holder != address(0), \"ERC777: transfer from the zero address\");\n\n        address spender = _msgSender();\n\n        _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\n\n        _move(spender, holder, recipient, amount, \"\", \"\");\n        _approve(holder, spender, _allowances[holder][spender].sub(amount, \"ERC777: transfer amount exceeds allowance\"));\n\n        _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n    internal virtual\n    {\n        require(account != address(0), \"ERC777: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, amount);\n\n        // Update state variables\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, true);\n\n        emit Minted(operator, account, amount, userData, operatorData);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Send tokens\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _send(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    )\n        internal\n    {\n        require(from != address(0), \"ERC777: send from the zero address\");\n        require(to != address(0), \"ERC777: send to the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\n\n        _move(operator, from, to, amount, userData, operatorData);\n\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n    }\n\n    /**\n     * @dev Burn tokens\n     * @param from address token holder address\n     * @param amount uint256 amount of tokens to burn\n     * @param data bytes extra information provided by the token holder\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _burn(\n        address from,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    )\n        internal virtual\n    {\n        require(from != address(0), \"ERC777: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), amount);\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n        // Update state variables\n        _balances[from] = _balances[from].sub(amount, \"ERC777: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Burned(operator, from, amount, data, operatorData);\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _move(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        private\n    {\n        _beforeTokenTransfer(operator, from, to, amount);\n\n        _balances[from] = _balances[from].sub(amount, \"ERC777: transfer amount exceeds balance\");\n        _balances[to] = _balances[to].add(amount);\n\n        emit Sent(operator, from, to, amount, userData, operatorData);\n        emit Transfer(from, to, amount);\n    }\n\n    /**\n     * @dev See {ERC20-_approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function _approve(address holder, address spender, uint256 value) internal {\n        require(holder != address(0), \"ERC777: approve from the zero address\");\n        require(spender != address(0), \"ERC777: approve to the zero address\");\n\n        _allowances[holder][spender] = value;\n        emit Approval(holder, spender, value);\n    }\n\n    /**\n     * @dev Call from.tokensToSend() if the interface is registered\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _callTokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        private\n    {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n        }\n    }\n\n    /**\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\n     * tokensReceived() was not registered for the recipient\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _callTokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    )\n        private\n    {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(to, _TOKENS_RECIPIENT_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n        } else if (requireReceptionAck) {\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes\n     * calls to {send}, {transfer}, {operatorSend}, minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address operator, address from, address to, uint256 amount) internal virtual { }\n}\n"
24     },
25     "@openzeppelin/contracts/token/ERC777/IERC777.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See {IERC1820Registry} and\n * {ERC1820Implementer}.\n */\ninterface IERC777 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n"
27     },
28     "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
30     },
31     "@openzeppelin/contracts/token/ERC777/IERC777Sender.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\n *\n * {IERC777} Token holders can be notified of operations performed on their\n * tokens by having a contract implement this interface (contract holders can be\n *  their own implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Sender {\n    /**\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\n     * is conveyed by `to` being the zero address or not.\n     *\n     * This call occurs _before_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
33     },
34     "@openzeppelin/contracts/utils/Address.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
36     },
37     "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
39     }
40   },
41   "settings": {
42     "remappings": [],
43     "optimizer": {
44       "enabled": true,
45       "runs": 200
46     },
47     "evmVersion": "istanbul",
48     "libraries": {},
49     "outputSelection": {
50       "*": {
51         "*": [
52           "evm.bytecode",
53           "evm.deployedBytecode",
54           "abi"
55         ]
56       }
57     }
58   }
59 }}