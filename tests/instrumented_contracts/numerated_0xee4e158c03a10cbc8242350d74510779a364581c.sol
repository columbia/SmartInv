1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/UserProxy.sol": {
5       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IERC20Permit.sol\";\nimport \"./interfaces/ITranche.sol\";\nimport \"./interfaces/IWETH.sol\";\nimport \"./interfaces/IWrappedPosition.sol\";\nimport \"./libraries/Authorizable.sol\";\n\n/// @author Element Finance\n/// @title User Proxy\ncontract UserProxy is Authorizable {\n    // This contract is a convenience library to consolidate\n    // the actions needed to create interest or principal tokens to one call.\n    // It will hold user allowances, and can be disabled by authorized addresses\n    // for security.\n    // If frozen users still control their own tokens so can manually redeem them.\n\n    // Store the accessibility state of the contract\n    bool public isFrozen = false;\n    // Constant wrapped ether address\n    IWETH public immutable weth;\n    // Tranche factory address for Tranche contract address derivation\n    address internal immutable _trancheFactory;\n    // Tranche bytecode hash for Tranche contract address derivation.\n    // This is constant as long as Tranche does not implement non-constant constructor arguments.\n    bytes32 internal immutable _trancheBytecodeHash;\n    // A constant which represents ether\n    address internal constant _ETH_CONSTANT = address(\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n    );\n\n    /// @dev Marks the msg.sender as authorized and sets them\n    ///      as the owner in authorization library\n    /// @param _weth The constant weth contract address\n    /// @param __trancheFactory Address of the TrancheFactory contract\n    /// @param __trancheBytecodeHash Hash of the Tranche bytecode.\n    constructor(\n        IWETH _weth,\n        address __trancheFactory,\n        bytes32 __trancheBytecodeHash\n    ) Authorizable() {\n        _authorize(msg.sender);\n        weth = _weth;\n        _trancheFactory = __trancheFactory;\n        _trancheBytecodeHash = __trancheBytecodeHash;\n    }\n\n    /// @dev Requires that the contract is not frozen\n    modifier notFrozen() {\n        require(!isFrozen, \"Contract frozen\");\n        _;\n    }\n\n    /// @dev Allows an authorized address to freeze or unfreeze this contract\n    /// @param _newState True for frozen and false for unfrozen\n    function setIsFrozen(bool _newState) external onlyAuthorized() {\n        isFrozen = _newState;\n    }\n\n    // Memory encoding of the permit data\n    struct PermitData {\n        IERC20Permit tokenContract;\n        address who;\n        uint256 amount;\n        uint256 expiration;\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n    }\n\n    /// @dev Takes the input permit calls and executes them\n    /// @param data The array which encodes the set of permit calls to make\n    modifier preApproval(PermitData[] memory data) {\n        // If permit calls are provided we make try to make them\n        if (data.length != 0) {\n            // We make permit calls for each indicated call\n            for (uint256 i = 0; i < data.length; i++) {\n                _permitCall(data[i]);\n            }\n        }\n        _;\n    }\n\n    /// @dev Makes permit calls indicated by a struct\n    /// @param data the struct which has the permit calldata\n    function _permitCall(PermitData memory data) internal {\n        // Make the permit call to the token in the data field using\n        // the fields provided.\n        // Security note - This fairly open call is safe because it cannot\n        // call 'transferFrom' or other sensitive methods despite the open\n        // scope. Do not make more general without security review.\n        data.tokenContract.permit(\n            msg.sender,\n            data.who,\n            data.amount,\n            data.expiration,\n            data.v,\n            data.r,\n            data.s\n        );\n    }\n\n    /// @notice Mints a Principal/Interest token pair from either underlying token or Eth\n    ///      then returns the tokens to the caller.\n    /// @dev This function assumes that it already has an allowance for the token in question.\n    /// @param _amount The amount of underlying to turn into tokens\n    /// @param _underlying Either (1) The underlying ERC20 token contract\n    ///                   or (2) the _ETH_CONSTANT to indicate the user has sent eth.\n    ///                   This token should revert in the event of a transfer failure.\n    /// @param _expiration The expiration time of the Tranche contract\n    /// @param _position The contract which manages pooled deposits\n    /// @param _permitCallData Encoded array of permit calls to make prior to minting\n    ///                        the data should be encoded with abi.encode(data, \"PermitData[]\")\n    ///                        each PermitData struct provided will be executed as a call.\n    ///                        An example use of this is if using a token with permit like USDC\n    ///                        to encode a permit which gives this contract allowance before minting.\n    /// @return returns the minted amounts of PT and YT\n    // NOTE - It is critical that the notFrozen modifier is listed first so it gets called first.\n    function mint(\n        uint256 _amount,\n        IERC20 _underlying,\n        uint256 _expiration,\n        address _position,\n        PermitData[] calldata _permitCallData\n    )\n        external\n        payable\n        notFrozen()\n        preApproval(_permitCallData)\n        returns (uint256, uint256)\n    {\n        // If the underlying token matches this predefined 'ETH token'\n        // then we create weth for the user and go from there\n        if (address(_underlying) == _ETH_CONSTANT) {\n            // Check that the amount matches the amount provided\n            require(msg.value == _amount, \"Incorrect amount provided\");\n            // Create weth from the provided eth\n            weth.deposit{ value: msg.value }();\n            weth.transfer(address(_position), _amount);\n        } else {\n            // Check for the fact that this branch should not be payable\n            require(msg.value == 0, \"Non payable\");\n            // Move the user's funds to the wrapped position contract\n            _underlying.transferFrom(msg.sender, address(_position), _amount);\n        }\n\n        // Proceed to internal minting steps\n        (uint256 ptMinted, uint256 ytMinted) = _mint(_expiration, _position);\n        // This sanity check ensure that at least as much was minted as was transferred\n        require(ytMinted >= _amount, \"Not enough minted\");\n        return (ptMinted, ytMinted);\n    }\n\n    /// @dev Allows a user to withdraw and unwrap weth in the same transaction\n    ///      likely quite a bit more expensive than direct unwrapping but useful\n    ///      for those who want to do one tx instead of two\n    /// @param _expiration The tranche expiration time\n    /// @param _position The contract which interacts with the yield bearing strategy\n    /// @param _amountPT The amount of principal token to withdraw\n    /// @param _amountYT The amount of yield token to withdraw.\n    /// @param _permitCallData Encoded array of permit calls to make prior to withdrawing,\n    ///                        should be used to get allowances for PT and YT\n    // NOTE - It is critical that the notFrozen modifier is listed first so it gets called first.\n    function withdrawWeth(\n        uint256 _expiration,\n        address _position,\n        uint256 _amountPT,\n        uint256 _amountYT,\n        PermitData[] calldata _permitCallData\n    ) external notFrozen() preApproval(_permitCallData) {\n        // Post the Berlin hardfork this call warms the address so only cost ~100 gas overall\n        require(IWrappedPosition(_position).token() == weth, \"Non weth token\");\n        // Only allow access if the user is actually attempting to withdraw\n        require(((_amountPT != 0) || (_amountYT != 0)), \"Invalid withdraw\");\n        // Because of create2 we know this code is exactly what is expected.\n        ITranche derivedTranche = _deriveTranche(_position, _expiration);\n\n        uint256 wethReceivedPt = 0;\n        uint256 wethReceivedYt = 0;\n        // Check if we need to withdraw principal token\n        if (_amountPT != 0) {\n            // If we have to withdraw PT first transfer it to this contract\n            derivedTranche.transferFrom(msg.sender, address(this), _amountPT);\n            // Then we withdraw that PT with the resulting weth going to this address\n            wethReceivedPt = derivedTranche.withdrawPrincipal(\n                _amountPT,\n                address(this)\n            );\n        }\n        // Check if we need to withdraw yield token\n        if (_amountYT != 0) {\n            // Post Berlin this lookup only costs 100 gas overall as well\n            IERC20Permit yieldToken = derivedTranche.interestToken();\n            // Transfer the YT to this contract\n            yieldToken.transferFrom(msg.sender, address(this), _amountYT);\n            // Withdraw that YT\n            wethReceivedYt = derivedTranche.withdrawInterest(\n                _amountYT,\n                address(this)\n            );\n        }\n\n        // A sanity check that some value was withdrawn\n        if (_amountPT != 0) {\n            require((wethReceivedPt != 0), \"Rugged\");\n        }\n        if (_amountYT != 0) {\n            require((wethReceivedYt != 0), \"No yield accrued\");\n        }\n        // Withdraw the ether from weth\n        weth.withdraw(wethReceivedPt + wethReceivedYt);\n        // Send the withdrawn eth to the caller\n        payable(msg.sender).transfer(wethReceivedPt + wethReceivedYt);\n    }\n\n    /// @dev The receive function allows WETH and only WETH to send\n    ///      eth directly to this contract. Note - It Cannot be assumed\n    ///      that this will prevent this contract from having an ETH balance\n    receive() external payable {\n        require(msg.sender == address(weth));\n    }\n\n    /// @dev This internal mint function performs the core minting logic after\n    ///      the contract has already transferred to WrappedPosition contract\n    /// @param _expiration The tranche expiration time\n    /// @param _position The contract which interacts with the yield bearing strategy\n    /// @return the principal token yield token returned\n    function _mint(uint256 _expiration, address _position)\n        internal\n        returns (uint256, uint256)\n    {\n        // Use create2 to derive the tranche contract\n        ITranche tranche = _deriveTranche(address(_position), _expiration);\n        // Move funds into the Tranche contract\n        // it will credit the msg.sender with the new tokens\n        return tranche.prefundedDeposit(msg.sender);\n    }\n\n    /// @dev This internal function produces the deterministic create2\n    ///      address of the Tranche contract from a wrapped position contract and expiration\n    /// @param _position The wrapped position contract address\n    /// @param _expiration The expiration time of the tranche\n    /// @return The derived Tranche contract\n    function _deriveTranche(address _position, uint256 _expiration)\n        internal\n        virtual\n        view\n        returns (ITranche)\n    {\n        bytes32 salt = keccak256(abi.encodePacked(_position, _expiration));\n        bytes32 addressBytes = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                _trancheFactory,\n                salt,\n                _trancheBytecodeHash\n            )\n        );\n        return ITranche(address(uint160(uint256(addressBytes))));\n    }\n\n    /// @dev This contract holds a number of allowances for addresses so if it is deprecated\n    ///      it should be removed so that users do not have to remove allowances.\n    ///      Note - onlyOwner is a stronger check than onlyAuthorized, many addresses can be\n    ///      authorized to freeze or unfreeze the contract but only the owner address can kill\n    function deprecate() external onlyOwner() {\n        selfdestruct(payable(msg.sender));\n    }\n}\n"
6     },
7     "contracts/interfaces/IERC20.sol": {
8       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function symbol() external view returns (string memory);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    // Note this is non standard but nearly all ERC20 have exposed decimal functions\n    function decimals() external view returns (uint8);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
9     },
10     "contracts/interfaces/IERC20Permit.sol": {
11       "content": "// Forked from openzepplin\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit is IERC20 {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
12     },
13     "contracts/interfaces/ITranche.sol": {
14       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./IERC20Permit.sol\";\nimport \"./IInterestToken.sol\";\n\ninterface ITranche is IERC20Permit {\n    function deposit(uint256 _shares, address destination)\n        external\n        returns (uint256, uint256);\n\n    function prefundedDeposit(address _destination)\n        external\n        returns (uint256, uint256);\n\n    function withdrawPrincipal(uint256 _amount, address _destination)\n        external\n        returns (uint256);\n\n    function withdrawInterest(uint256 _amount, address _destination)\n        external\n        returns (uint256);\n\n    function interestToken() external view returns (IInterestToken);\n\n    function interestSupply() external view returns (uint128);\n}\n"
15     },
16     "contracts/interfaces/IWETH.sol": {
17       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n}\n"
18     },
19     "contracts/interfaces/IWrappedPosition.sol": {
20       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./IERC20Permit.sol\";\nimport \"./IERC20.sol\";\n\ninterface IWrappedPosition is IERC20Permit {\n    function token() external view returns (IERC20);\n\n    function balanceOfUnderlying(address who) external view returns (uint256);\n\n    function getSharesToUnderlying(uint256 shares)\n        external\n        view\n        returns (uint256);\n\n    function deposit(address sender, uint256 amount) external returns (uint256);\n\n    function withdraw(\n        address sender,\n        uint256 _shares,\n        uint256 _minUnderlying\n    ) external returns (uint256);\n\n    function withdrawUnderlying(\n        address _destination,\n        uint256 _amount,\n        uint256 _minUnderlying\n    ) external returns (uint256, uint256);\n\n    function prefundedDeposit(address _destination)\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n}\n"
21     },
22     "contracts/libraries/Authorizable.sol": {
23       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.7.0;\n\ncontract Authorizable {\n    // This contract allows a flexible authorization scheme\n\n    // The owner who can change authorization status\n    address public owner;\n    // A mapping from an address to its authorization status\n    mapping(address => bool) public authorized;\n\n    /// @dev We set the deployer to the owner\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// @dev This modifier checks if the msg.sender is the owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Sender not owner\");\n        _;\n    }\n\n    /// @dev This modifier checks if an address is authorized\n    modifier onlyAuthorized() {\n        require(isAuthorized(msg.sender), \"Sender not Authorized\");\n        _;\n    }\n\n    /// @dev Returns true if an address is authorized\n    /// @param who the address to check\n    /// @return true if authorized false if not\n    function isAuthorized(address who) public view returns (bool) {\n        return authorized[who];\n    }\n\n    /// @dev Privileged function authorize an address\n    /// @param who the address to authorize\n    function authorize(address who) external onlyOwner() {\n        _authorize(who);\n    }\n\n    /// @dev Privileged function to de authorize an address\n    /// @param who The address to remove authorization from\n    function deauthorize(address who) external onlyOwner() {\n        authorized[who] = false;\n    }\n\n    /// @dev Function to change owner\n    /// @param who The new owner address\n    function setOwner(address who) public onlyOwner() {\n        owner = who;\n    }\n\n    /// @dev Inheritable function which authorizes someone\n    /// @param who the address to authorize\n    function _authorize(address who) internal {\n        authorized[who] = true;\n    }\n}\n"
24     },
25     "contracts/interfaces/IInterestToken.sol": {
26       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./IERC20Permit.sol\";\n\ninterface IInterestToken is IERC20Permit {\n    function mint(address _account, uint256 _amount) external;\n\n    function burn(address _account, uint256 _amount) external;\n}\n"
27     }
28   },
29   "settings": {
30     "optimizer": {
31       "enabled": true,
32       "runs": 7500
33     },
34     "outputSelection": {
35       "*": {
36         "*": [
37           "evm.bytecode",
38           "evm.deployedBytecode",
39           "abi"
40         ]
41       }
42     },
43     "libraries": {}
44   }
45 }}