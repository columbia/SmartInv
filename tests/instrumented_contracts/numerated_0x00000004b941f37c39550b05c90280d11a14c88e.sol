1 {"LibAuthPause.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\nimport \"LibBaseAuth.sol\";\r\n\r\n\r\n/**\r\n * @dev Auth pause.\r\n */\r\ncontract AuthPause is BaseAuth {\r\n    using Roles for Roles.Role;\r\n\r\n    bool private _paused = false;\r\n\r\n    event PausedON();\r\n    event PausedOFF();\r\n\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier onlyNotPaused() {\r\n        require(!_paused, \"Paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return Returns true if the contract is paused, false otherwise.\r\n     */\r\n    function isPaused()\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets paused state.\r\n     *\r\n     * Can only be called by the current owner.\r\n     */\r\n    function setPaused(bool value)\r\n        external\r\n        onlyAgent\r\n    {\r\n        _paused = value;\r\n\r\n        if (_paused) {\r\n            emit PausedON();\r\n        } else {\r\n            emit PausedOFF();\r\n        }\r\n    }\r\n}\r\n"},"LibBaseAuth.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\nimport \"LibRoles.sol\";\r\nimport \"LibIERC20.sol\";\r\n\r\n\r\n/**\r\n * @dev Base auth.\r\n */\r\ncontract BaseAuth {\r\n    using Roles for Roles.Role;\r\n\r\n    Roles.Role private _agents;\r\n\r\n    event AgentAdded(address indexed account);\r\n    event AgentRemoved(address indexed account);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor ()\r\n    {\r\n        _agents.add(msg.sender);\r\n        emit AgentAdded(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by account which is not an agent.\r\n     */\r\n    modifier onlyAgent() {\r\n        require(isAgent(msg.sender), \"AgentRole: caller does not have the Agent role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Rescue compatible ERC20 Token\r\n     *\r\n     * Can only be called by an agent.\r\n     */\r\n    function rescueToken(\r\n        address tokenAddr,\r\n        address recipient,\r\n        uint256 amount\r\n    )\r\n        external\r\n        onlyAgent\r\n    {\r\n        IERC20 _token = IERC20(tokenAddr);\r\n        require(recipient != address(0), \"Rescue: recipient is the zero address\");\r\n        uint256 balance = _token.balanceOf(address(this));\r\n\r\n        require(balance \u003e= amount, \"Rescue: amount exceeds balance\");\r\n        _token.transfer(recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw Ether\r\n     *\r\n     * Can only be called by an agent.\r\n     */\r\n    function withdrawEther(\r\n        address payable recipient,\r\n        uint256 amount\r\n    )\r\n        external\r\n        onlyAgent\r\n    {\r\n        require(recipient != address(0), \"Withdraw: recipient is the zero address\");\r\n        uint256 balance = address(this).balance;\r\n        require(balance \u003e= amount, \"Withdraw: amount exceeds balance\");\r\n        recipient.transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the `account` has the Agent role.\r\n     */\r\n    function isAgent(address account)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _agents.has(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Give an `account` access to the Agent role.\r\n     *\r\n     * Can only be called by an agent.\r\n     */\r\n    function addAgent(address account)\r\n        public\r\n        onlyAgent\r\n    {\r\n        _agents.add(account);\r\n        emit AgentAdded(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an `account` access from the Agent role.\r\n     *\r\n     * Can only be called by an agent.\r\n     */\r\n    function removeAgent(address account)\r\n        public\r\n        onlyAgent\r\n    {\r\n        _agents.remove(account);\r\n        emit AgentRemoved(account);\r\n    }\r\n}\r\n\r\n"},"LibIERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n"},"LibIEtherUSDPrice.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\ninterface IEtherUSDPrice {\r\n    function etherUSDPrice() external view returns (uint256);\r\n}\r\n"},"LibIPermille.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\n\r\n/**\r\n * @dev Interface of a permille contract.\r\n */\r\ninterface IPermille {\r\n    function permille() external view returns (uint16);\r\n}\r\n"},"LibIVesting.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\n\r\n/**\r\n * @dev Interface of an vesting contract.\r\n */\r\ninterface IVesting {\r\n    function vestingOf(address account) external view returns (uint256);\r\n}\r\n"},"LibIVokenAudit.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\ninterface IVokenAudit {\r\n    function getAccount(address account) external view\r\n        returns (\r\n            uint72 wei_purchased,\r\n            uint72 wei_rewarded,\r\n            uint72 wei_audit,\r\n            uint16 txs_in,\r\n            uint16 txs_out\r\n        );\r\n}\r\n"},"LibIVokenSale.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\n\r\ninterface IVokenSale {\r\n    function vokenUSDPrice() external view returns (uint256);\r\n}\r\n"},"LibIVokenTB.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\n\r\n/**\r\n * @title Interface of VokenTB.\r\n */\r\ninterface IVokenTB {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    \r\n    function cap() external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function mint(address account, uint256 amount) external returns (bool);\r\n    function mintWithVesting(address account, uint256 amount, address vestingContract) external returns (bool);\r\n\r\n    function referrer(address account) external view returns (address payable);\r\n    function address2voken(address account) external view returns (uint160);\r\n    function voken2address(uint160 voken) external view returns (address payable);\r\n}\r\n"},"LibRoles.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\n\r\n/**\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role\r\n    {\r\n        mapping (address =\u003e bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(\r\n        Role storage role,\r\n        address account\r\n    )\r\n        internal\r\n    {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account\u0027s access to this role.\r\n     */\r\n    function remove(\r\n        Role storage role,\r\n        address account\r\n    )\r\n        internal\r\n    {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     *\r\n     * @return bool\r\n     */\r\n    function has(\r\n        Role storage role,\r\n        address account\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n"},"LibSafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"},"ResaleOrUpdateToVokenTB.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\n// Resale Voken1.0/2.0 or Upgrade to VokenTB.\r\n//\r\n// More info:\r\n//   https://voken.io\r\n//\r\n// Contact us:\r\n//   support@voken.io\r\n\r\n\r\nimport \"LibSafeMath.sol\";\r\nimport \"LibAuthPause.sol\";\r\nimport \"LibIVesting.sol\";\r\nimport \"LibIERC20.sol\";\r\nimport \"LibIVokenTB.sol\";\r\nimport \"LibIVokenAudit.sol\";\r\nimport \"RouWithResaleOnly.sol\";\r\nimport \"RouWithDeadline.sol\";\r\nimport \"RouWithCoeff.sol\";\r\nimport \"RouWithUSDPrice.sol\";\r\nimport \"RouWithUSDToken.sol\";\r\nimport \"RouWithVestingPermille.sol\";\r\n\r\n\r\n/**\r\n * @title Resale Voken1.0/2.0 or Upgrade to VokenTB.\r\n */\r\ncontract ResaleOrUpgradeToVokenTB is IVesting, AuthPause, WithResaleOnly, WithDeadline, WithCoeff, WithUSDPrice, WithUSDToken, WithVestingPermille {\r\n    using SafeMath for uint256;\r\n\r\n    struct Resale {\r\n        uint256 usdAudit;\r\n        uint256 usdClaimed;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    struct Upgraded {\r\n        uint256 claimed;\r\n        uint256 bonuses;\r\n        uint256 etherUSDPrice;\r\n        uint256 vokenUSDPrice;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    uint256 private immutable VOKEN_UPGRADED_CAP = 21_000_000e9;\r\n\r\n    uint256 private _usdAudit;\r\n    uint256 private _usdClaimed;\r\n\r\n    uint256 private _v1Claimed;\r\n    uint256 private _v1Bonuses;\r\n    uint256 private _v2Claimed;\r\n    uint256 private _v2Bonuses;\r\n\r\n    IVokenTB private immutable VOKEN_TB = IVokenTB(0x1234567a022acaa848E7D6bC351d075dBfa76Dd4);\r\n\r\n    IERC20 private immutable VOKEN_1 = IERC20(0x82070415FEe803f94Ce5617Be1878503e58F0a6a);  // Voken1.0\r\n    IERC20 private immutable VOKEN_2 = IERC20(0xFfFAb974088Bd5bF3d7E6F522e93Dd7861264cDB);  // Voken2.0\r\n\r\n    IVokenAudit private immutable VOKEN_1_AUDIT = IVokenAudit(0x11111eA590876f5E8416cD4a81A0CFb9DfA2b08E);\r\n    IVokenAudit private immutable VOKEN_2_AUDIT = IVokenAudit(0x22222eA5b84E877A1790b4653a70ad0df8e3E890);\r\n\r\n    mapping (address =\u003e Resale) private _v1ResaleApplied;\r\n    mapping (address =\u003e Resale) private _v2ResaleApplied;\r\n    mapping (address =\u003e Upgraded) private _v1UpgradeApplied;\r\n    mapping (address =\u003e Upgraded) private _v2UpgradeApplied;\r\n\r\n\r\n    /**\r\n     * @dev Accept Ether.\r\n     */\r\n    receive()\r\n        external\r\n        payable\r\n    {\r\n        //\r\n    }\r\n\r\n    /**\r\n     * @dev Apply re-sale. \r\n     */\r\n    function applyV1Resale()\r\n        external\r\n    {\r\n        _v1Resale(msg.sender);\r\n    }\r\n\r\n    function applyV2Resale()\r\n        external\r\n    {\r\n        _v2Resale(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Apply upgrade.\r\n     */\r\n    function applyV1Upgrade()\r\n        external\r\n    {\r\n        _v1Upgrade(msg.sender);\r\n    }\r\n\r\n    function applyV2Upgrade()\r\n        external\r\n    {\r\n        _v2Upgrade(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim USD, according to re-sale.\r\n     */\r\n    function claimV1USD()\r\n        external\r\n    {\r\n        _v1ClaimUSD();\r\n    }\r\n\r\n    function claimV2USD()\r\n        external\r\n    {\r\n        _v2ClaimUSD();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the status.\r\n     */\r\n    function status()\r\n        public\r\n        view\r\n        returns (\r\n            uint256 deadline,\r\n\r\n            uint256 usdAudit,\r\n            uint256 usdClaimed,\r\n            uint256 usdReceived,\r\n\r\n            uint256 resaleEtherUSD,\r\n\r\n            uint256 v1Claimed,\r\n            uint256 v1Bonuses,\r\n            uint256 v2Claimed,\r\n            uint256 v2Bonuses,\r\n\r\n            uint256 etherUSD,\r\n            uint256 vokenUSD\r\n        )\r\n    {\r\n        deadline = _deadline();\r\n        \r\n        usdAudit = _usdAudit;\r\n        usdClaimed = _usdClaimed;\r\n        usdReceived = _usdReceived();\r\n\r\n        resaleEtherUSD = resaleEtherUSDPrice();\r\n\r\n        v1Claimed = _v1Claimed;\r\n        v1Bonuses = _v1Bonuses;\r\n        v2Claimed =  _v2Claimed;\r\n        v2Bonuses = _v2Bonuses;\r\n        \r\n        etherUSD = _etherUSDPrice();\r\n        vokenUSD = vokenUSDPrice();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns status of `account`.\r\n     */\r\n    function getAccountStatus(address account)\r\n        public\r\n        view\r\n        returns (\r\n            bool canOnlyResale,\r\n            uint256 v1ResaleAppliedTimestamp,\r\n            uint256 v2ResaleAppliedTimestamp,\r\n            uint256 v1UpgradeAppliedTimestamp,\r\n            uint256 v2UpgradeAppliedTimestamp,\r\n\r\n            uint256 v1Balance,\r\n            uint256 v2Balance,\r\n            \r\n            uint256 etherBalance\r\n        )\r\n    {\r\n        canOnlyResale = isResaleOnly(account);\r\n\r\n        v1ResaleAppliedTimestamp = _v1ResaleApplied[account].timestamp;\r\n        v1UpgradeAppliedTimestamp = _v1UpgradeApplied[account].timestamp;\r\n        v1Balance = VOKEN_1.balanceOf(account);\r\n\r\n        v2ResaleAppliedTimestamp = _v2ResaleApplied[account].timestamp;\r\n        v2UpgradeAppliedTimestamp = _v2UpgradeApplied[account].timestamp;\r\n        v2Balance = VOKEN_2.balanceOf(account);\r\n        \r\n        etherBalance = account.balance;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the re-sale status.\r\n     */\r\n    function v1ResaleStatus(address account)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 usdQuota,\r\n            uint256 usdAudit,\r\n            uint256 usdClaimed,\r\n            uint256 timestamp\r\n        )\r\n    {\r\n        timestamp = _v1ResaleApplied[account].timestamp;\r\n        if (timestamp \u003e 0) {\r\n            usdQuota = _v1USDQuota(account);\r\n            usdAudit = _v1ResaleApplied[account].usdAudit;\r\n            usdClaimed = _v1ResaleApplied[account].usdClaimed;\r\n        }\r\n    }\r\n\r\n    function v2ResaleStatus(address account)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 usdQuota,\r\n            uint256 usdAudit,\r\n            uint256 usdClaimed,\r\n            uint256 timestamp\r\n        )\r\n    {\r\n        timestamp = _v2ResaleApplied[account].timestamp;\r\n        if (timestamp \u003e 0) {\r\n            usdQuota = _v2USDQuota(account);\r\n            usdAudit = _v2ResaleApplied[account].usdAudit;\r\n            usdClaimed = _v2ResaleApplied[account].usdClaimed;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the upgrade status.\r\n     */\r\n    function v1UpgradeStatus(address account)\r\n        public\r\n        view\r\n        returns (\r\n            uint72 weiPurchased,\r\n            uint72 weiRewarded,\r\n            uint72 weiAudit,\r\n            uint16 txsIn,\r\n            uint16 txsOut,\r\n\r\n            uint256 claim,\r\n            uint256 bonus,\r\n            uint256 etherUSD,\r\n            uint256 vokenUSD,\r\n\r\n            uint256 timestamp\r\n        )\r\n    {\r\n        (weiPurchased, weiRewarded, weiAudit, txsIn, txsOut) = VOKEN_1_AUDIT.getAccount(account);\r\n        (claim, bonus, etherUSD, vokenUSD, timestamp) = _v1UpgradeQuota(account);\r\n    }\r\n\r\n    function v2UpgradeStatus(address account)\r\n        public\r\n        view\r\n        returns (\r\n            uint72 weiPurchased,\r\n            uint72 weiRewarded,\r\n            uint72 weiAudit,\r\n            uint16 txsIn,\r\n            uint16 txsOut,\r\n\r\n            uint256 claim,\r\n            uint256 bonus,\r\n            uint256 etherUSD,\r\n            uint256 vokenUSD,\r\n            uint256 timestamp\r\n        )\r\n    {\r\n        (weiPurchased, weiRewarded, weiAudit, txsIn, txsOut) = VOKEN_2_AUDIT.getAccount(account);\r\n        (claim, bonus, etherUSD, vokenUSD, timestamp) = _v2UpgradeQuota(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the vesting amount of VOKEN by `account`, only for this re-sale/upgrade contract/program.\r\n     */\r\n    function vestingOf(address account)\r\n        public\r\n        override\r\n        view\r\n        returns (uint256 vesting)\r\n    {\r\n        vesting = vesting.add(_getV1ClaimedVestingAmount(_v1UpgradeApplied[account].claimed));\r\n        vesting = vesting.add(_getV1BonusesVestingAmount(_v1UpgradeApplied[account].bonuses));\r\n        vesting = vesting.add(_getV2ClaimedVestingAmount(_v2UpgradeApplied[account].claimed));\r\n        vesting = vesting.add(_getV2BonusesVestingAmount(_v2UpgradeApplied[account].bonuses));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns USD received.\r\n     */\r\n    function _usdReceived()\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _usdClaimed.add(_getUSDBalance());\r\n    }\r\n\r\n    /**\r\n     * @dev Re-Sale.\r\n     */\r\n    function _v1Resale(address account)\r\n        private\r\n        onlyBeforeDeadline\r\n        onlyNotPaused\r\n    {\r\n        require(_v1ResaleApplied[account].timestamp == 0, \"Voken1 Resale: already applied before\");\r\n        require(_v1UpgradeApplied[account].timestamp == 0, \"Voken1 Resale: already applied for upgrade\");\r\n\r\n        (, , uint256 weiAudit, ,) = VOKEN_1_AUDIT.getAccount(account);\r\n        require(weiAudit \u003e 0, \"Voken1 Resale: audit ETH is zero\");\r\n\r\n        uint256 usdAudit = resaleEtherUSDPrice().mul(weiAudit).div(1 ether);\r\n        _usdAudit = _usdAudit.add(usdAudit);\r\n        _v1ResaleApplied[account].usdAudit = usdAudit;\r\n        _v1ResaleApplied[account].timestamp = block.timestamp;\r\n    }\r\n\r\n    function _v2Resale(address account)\r\n        private\r\n        onlyBeforeDeadline\r\n        onlyNotPaused\r\n    {\r\n        require(_v2ResaleApplied[account].timestamp == 0, \"Voken2 Resale: already applied before\");\r\n        require(_v2UpgradeApplied[account].timestamp == 0, \"Voken2 Resale: already applied for upgrade\");\r\n\r\n        (, , uint256 weiAudit, ,) = VOKEN_2_AUDIT.getAccount(account);\r\n        require(weiAudit \u003e 0, \"Voken2 Resale: audit ETH is zero\");\r\n\r\n        uint256 usdAudit = resaleEtherUSDPrice().mul(weiAudit).div(1 ether);\r\n        _usdAudit = _usdAudit.add(usdAudit);\r\n        _v2ResaleApplied[account].usdAudit = usdAudit;\r\n        _v2ResaleApplied[account].timestamp = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade.\r\n     */\r\n    function _v1Upgrade(address account)\r\n        private\r\n        onlyBeforeDeadline\r\n        onlyNotPaused\r\n    {\r\n        require(!isResaleOnly(account), \"Upgrade from Voken1: can only apply for resale\");\r\n        require(_v1ResaleApplied[account].timestamp == 0, \"Upgrade from Voken1: already applied for resale\");\r\n        require(_v1UpgradeApplied[account].timestamp == 0, \"Upgrade from Voken1: already applied before\");\r\n\r\n        (uint256 claim, uint256 bonus, uint256 etherUSD, uint256 vokenUSD,) = _v1UpgradeQuota(account);\r\n        require(claim \u003e 0 || bonus \u003e 0, \"Upgrade from Voken1: not upgradeable\");\r\n\r\n\r\n        uint256 vokenUpgraded = _v1Claimed.add(_v1Bonuses).add(_v2Claimed).add(_v2Bonuses);\r\n        require(vokenUpgraded \u003c VOKEN_UPGRADED_CAP, \"Upgrade from Voken1: out of the cap\");\r\n\r\n        if (claim \u003e 0) {\r\n            VOKEN_TB.mintWithVesting(account, claim, address(this));\r\n            _v1Claimed = _v1Claimed.add(claim);\r\n            _v1UpgradeApplied[account].claimed = claim;\r\n        }\r\n\r\n        if (bonus \u003e 0) {\r\n            VOKEN_TB.mintWithVesting(account, bonus, address(this));\r\n            _v1Bonuses = _v1Bonuses.add(bonus);\r\n            _v1UpgradeApplied[account].bonuses = bonus;\r\n        }\r\n\r\n        _v1UpgradeApplied[account].etherUSDPrice = etherUSD;\r\n        _v1UpgradeApplied[account].vokenUSDPrice = vokenUSD;\r\n        _v1UpgradeApplied[account].timestamp = block.timestamp;\r\n    }\r\n\r\n    function _v2Upgrade(address account)\r\n        private\r\n        onlyBeforeDeadline\r\n        onlyNotPaused\r\n    {\r\n        require(!isResaleOnly(account), \"Upgrade from Voken2: can only apply for resale\");\r\n        require(_v2ResaleApplied[account].timestamp == 0, \"Upgrade from Voken2: already applied for resale\");\r\n        require(_v2UpgradeApplied[account].timestamp == 0, \"Upgrade from Voken2: already applied for upgrade\");\r\n\r\n        (uint256 claim, uint256 bonus, uint256 etherUSD, uint256 vokenUSD,) = _v2UpgradeQuota(account);\r\n        require(claim \u003e 0 || bonus \u003e 0, \"Upgrade from Voken2: not upgradeable\");\r\n\r\n        uint256 vokenUpgraded = _v1Claimed.add(_v1Bonuses).add(_v2Claimed).add(_v2Bonuses);\r\n        require(vokenUpgraded \u003c VOKEN_UPGRADED_CAP, \"Upgrade from Voken2: out of the cap\");\r\n\r\n        if (claim \u003e 0) {\r\n            VOKEN_TB.mintWithVesting(account, claim, address(this));\r\n            _v2Claimed = _v2Claimed.add(claim);\r\n            _v2UpgradeApplied[account].claimed = claim;\r\n        }\r\n\r\n        if (bonus \u003e 0) {\r\n            VOKEN_TB.mintWithVesting(account, bonus, address(this));\r\n            _v2Bonuses = _v2Bonuses.add(bonus);\r\n            _v2UpgradeApplied[account].bonuses = bonus;\r\n        }\r\n\r\n        _v2UpgradeApplied[account].etherUSDPrice = etherUSD;\r\n        _v2UpgradeApplied[account].vokenUSDPrice = vokenUSD;\r\n        _v2UpgradeApplied[account].timestamp = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Claim USD.\r\n     */\r\n    function _v1ClaimUSD()\r\n        private\r\n    {\r\n        require(_v1ResaleApplied[msg.sender].timestamp \u003e 0, \"Have not applied for resale yet\");\r\n\r\n        uint256 balance = _getUSDBalance();\r\n        require(balance \u003e 0, \"USD balance is zero\");\r\n\r\n        uint256 quota = _v1USDQuota(msg.sender);\r\n        require(quota \u003e 0, \"No USD quota to claim\");\r\n\r\n        if (quota \u003c balance) {\r\n            _usdClaimed = _usdClaimed.add(quota);\r\n            _v1ResaleApplied[msg.sender].usdClaimed = _v1ResaleApplied[msg.sender].usdClaimed.add(quota);\r\n            _transferUSD(msg.sender, quota);\r\n        }\r\n\r\n        else {\r\n            _usdClaimed = _usdClaimed.add(balance);\r\n            _v1ResaleApplied[msg.sender].usdClaimed = _v1ResaleApplied[msg.sender].usdClaimed.add(balance);\r\n            _transferUSD(msg.sender, balance);\r\n        }\r\n    }\r\n\r\n    function _v2ClaimUSD()\r\n        private\r\n    {\r\n        require(_v2ResaleApplied[msg.sender].timestamp \u003e 0, \"Have not applied for resale yet\");\r\n        \r\n        uint256 balance = _getUSDBalance();\r\n        require(balance \u003e 0, \"USD balance is zero\");\r\n\r\n        uint256 quota = _v2USDQuota(msg.sender);\r\n        require(quota \u003e 0, \"No USD quota to claim\");\r\n\r\n        if (quota \u003c balance) {\r\n            _usdClaimed = _usdClaimed.add(quota);\r\n            _v2ResaleApplied[msg.sender].usdClaimed = _v2ResaleApplied[msg.sender].usdClaimed.add(quota);\r\n            _transferUSD(msg.sender, quota);\r\n        }\r\n\r\n        else {\r\n            _usdClaimed = _usdClaimed.add(balance);\r\n            _v2ResaleApplied[msg.sender].usdClaimed = _v2ResaleApplied[msg.sender].usdClaimed.add(balance);\r\n            _transferUSD(msg.sender, balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the USD amount of an `account` in re-sale.\r\n     */\r\n    function _v1USDQuota(address account)\r\n        private\r\n        view\r\n        returns (uint256 quota)\r\n    {\r\n        if (_v1ResaleApplied[account].usdAudit \u003e 0 \u0026\u0026 _usdAudit \u003e 0) {\r\n            uint256 amount = _usdReceived().mul(_v1ResaleApplied[account].usdAudit).div(_usdAudit);\r\n\r\n            if (_v1ResaleApplied[account].usdClaimed \u003c= amount) {\r\n                quota = amount.sub(_v1ResaleApplied[account].usdClaimed);\r\n            }\r\n\r\n            uint256 balance = _getUSDBalance();\r\n            if (balance \u003c quota) {\r\n                quota = balance;\r\n            }\r\n\r\n            uint256 diff = _v1ResaleApplied[account].usdAudit.sub(_v1ResaleApplied[account].usdClaimed);\r\n            \r\n            if (diff \u003c quota) {\r\n                quota = diff;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _v2USDQuota(address account)\r\n        private\r\n        view\r\n        returns (uint256 quota)\r\n    {\r\n        if (_v2ResaleApplied[account].usdAudit \u003e 0 \u0026\u0026 _usdAudit \u003e 0) {\r\n            uint256 amount = _usdReceived().mul(_v2ResaleApplied[account].usdAudit).div(_usdAudit);\r\n\r\n            if (_v2ResaleApplied[account].usdClaimed \u003c= amount) {\r\n                quota = amount.sub(_v2ResaleApplied[account].usdClaimed);\r\n            }\r\n            \r\n            uint256 balance = _getUSDBalance();\r\n            if (balance \u003c quota) {\r\n                quota = balance;\r\n            }\r\n\r\n            uint256 diff = _v2ResaleApplied[account].usdAudit.sub(_v2ResaleApplied[account].usdClaimed);\r\n            \r\n            if (diff \u003c quota) {\r\n                quota = diff;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns upgrading data/quota.\r\n     */\r\n    function _v1UpgradeQuota(address account)\r\n        private\r\n        view\r\n        returns (\r\n            uint256 claim,\r\n            uint256 bonus,\r\n            uint256 etherUSD,\r\n            uint256 vokenUSD,\r\n            uint256 timestamp\r\n        )\r\n    {\r\n        timestamp = _v1UpgradeApplied[account].timestamp;\r\n\r\n        if (timestamp \u003e 0) {\r\n            claim = _v1UpgradeApplied[account].claimed;\r\n            bonus = _v1UpgradeApplied[account].bonuses;\r\n            etherUSD = _v1UpgradeApplied[account].etherUSDPrice;\r\n            vokenUSD = _v1UpgradeApplied[account].vokenUSDPrice;\r\n        }\r\n\r\n        else {\r\n            (, , uint256 wei_audit, ,) = VOKEN_1_AUDIT.getAccount(account);\r\n            \r\n            if (!isResaleOnly(account)) {\r\n                etherUSD = _etherUSDPrice();\r\n                vokenUSD = vokenUSDPrice();\r\n\r\n                claim = wei_audit.mul(etherUSD).div(1e15).div(vokenUSD).mul(1e6);\r\n                bonus = claim.mul(v1BonusCoeff()).div(1e3);\r\n\r\n                uint256 shift = VOKEN_1.balanceOf(account).div(v1ClaimRatio()).div(1e3).mul(1e6);\r\n                uint256 mint = claim.add(bonus);\r\n        \r\n                if (mint \u003c shift) {\r\n                    bonus = shift.sub(claim);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _v2UpgradeQuota(address account)\r\n        private\r\n        view\r\n        returns (\r\n            uint256 claim,\r\n            uint256 bonus,\r\n            uint256 etherUSD,\r\n            uint256 vokenUSD,\r\n            uint256 timestamp\r\n        )\r\n    {\r\n        timestamp = _v2UpgradeApplied[account].timestamp;\r\n\r\n        if (timestamp \u003e 0) {\r\n            claim = _v2UpgradeApplied[account].claimed;\r\n            bonus = _v2UpgradeApplied[account].bonuses;\r\n            etherUSD = _v2UpgradeApplied[account].etherUSDPrice;\r\n            vokenUSD = _v2UpgradeApplied[account].vokenUSDPrice;\r\n        }\r\n\r\n        else {\r\n            (, , uint256 wei_audit, ,) = VOKEN_2_AUDIT.getAccount(account);\r\n            \r\n            if (!isResaleOnly(account)) {\r\n                etherUSD = _etherUSDPrice();\r\n                vokenUSD = vokenUSDPrice();\r\n\r\n                claim = wei_audit.mul(etherUSD).div(1e15).div(vokenUSD).mul(1e6);\r\n                bonus = claim.mul(v2BonusCoeff()).div(1e3);\r\n\r\n                uint256 shift = VOKEN_2.balanceOf(account).div(v2ClaimRatio()).div(1e3).mul(1e6);\r\n                uint256 mint = claim.add(bonus);\r\n        \r\n                if (mint \u003c shift) {\r\n                    bonus = shift.sub(claim);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the bigger one between `a` and `b`.\r\n     */\r\n    function max(uint256 a, uint256 b)\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a \u003e b ? a : b;\r\n    }\r\n}\r\n"},"RouWithCoeff.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\n\r\nimport \"LibBaseAuth.sol\";\r\n\r\n\r\ncontract WithCoeff is BaseAuth {\r\n    uint16 private _v1ClaimRatio;\r\n    uint16 private _v2ClaimRatio;\r\n    uint16 private _v1BonusCoeff;\r\n    uint16 private _v2BonusCoeff;\r\n\r\n\r\n    constructor ()\r\n    {\r\n        _v1ClaimRatio = 133;\r\n        _v2ClaimRatio = 200;\r\n        _v1BonusCoeff = 50;\r\n        _v2BonusCoeff = 100;\r\n    }\r\n\r\n    function setCoeff(\r\n        uint16 v1ClaimRatio_,\r\n        uint16 v2ClaimRatio_,\r\n        uint16 v1BonusCoeff_,\r\n        uint16 v2BonusCoeff_\r\n    )\r\n        external\r\n        onlyAgent\r\n    {\r\n        _v1ClaimRatio = v1ClaimRatio_;\r\n        _v2ClaimRatio = v2ClaimRatio_;\r\n        _v1BonusCoeff = v1BonusCoeff_;\r\n        _v2BonusCoeff = v2BonusCoeff_;\r\n    }\r\n\r\n    function v1ClaimRatio()\r\n        internal\r\n        view\r\n        returns (uint16)\r\n    {\r\n        return _v1ClaimRatio;\r\n    }\r\n\r\n    function v2ClaimRatio()\r\n        internal\r\n        view\r\n        returns (uint16)\r\n    {\r\n        return _v2ClaimRatio;\r\n    }\r\n\r\n    function v1BonusCoeff()\r\n        internal\r\n        view\r\n        returns (uint16)\r\n    {\r\n        return _v1BonusCoeff;\r\n    }\r\n\r\n    function v2BonusCoeff()\r\n        internal\r\n        view\r\n        returns (uint16)\r\n    {\r\n        return _v2BonusCoeff;\r\n    }\r\n}\r\n"},"RouWithDeadline.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\n\r\nimport \"LibBaseAuth.sol\";\r\n\r\n\r\ncontract WithDeadline is BaseAuth {\r\n    uint256 private _deadlineTimestamp;\r\n\r\n    constructor ()\r\n    {\r\n        _deadlineTimestamp = 1617235199;  // Wed, 31 Mar 2021 23:59:59 +0000\r\n    }\r\n\r\n    modifier onlyBeforeDeadline()\r\n    {\r\n        require(block.timestamp \u003c= _deadlineTimestamp, \"later than deadline\");\r\n        _;\r\n    }\r\n\r\n    function setDeadline(\r\n        uint256 deadlineTimestamp\r\n    )\r\n        external\r\n        onlyAgent\r\n    {\r\n        _deadlineTimestamp = deadlineTimestamp;\r\n    }\r\n\r\n    function _deadline()\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _deadlineTimestamp;\r\n    }\r\n}\r\n"},"RouWithResaleOnly.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\n\r\nimport \"LibBaseAuth.sol\";\r\n\r\n\r\ncontract WithResaleOnly is BaseAuth {\r\n    mapping (address =\u003e bool) private _resaleOnly;\r\n\r\n\r\n    function setResaleOnlys(address[] memory accounts, bool[] memory values)\r\n        external\r\n        onlyAgent\r\n    {\r\n        for (uint8 i = 0; i \u003c accounts.length; i++) {\r\n            _resaleOnly[accounts[i]] = values[i];\r\n        }\r\n    }\r\n\r\n    function isResaleOnly(address account)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _resaleOnly[account];\r\n    }\r\n}\r\n"},"RouWithUSDPrice.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\nimport \"LibBaseAuth.sol\";\r\nimport \"LibIEtherUSDPrice.sol\";\r\nimport \"LibIVokenSale.sol\";\r\n\r\n\r\ncontract WithUSDPrice is BaseAuth {\r\n    uint256 private _resaleEtherUSDPrice;\r\n    uint256 private _defaultEtherUSDPrice;\r\n    uint256 private _defaultVokenUSDPrice;\r\n\r\n    IEtherUSDPrice private _etherUSDPriceContract;\r\n    IVokenSale private _vokenSaleContract;\r\n\r\n\r\n    constructor ()\r\n    {\r\n        _resaleEtherUSDPrice = 350e6;\r\n        _defaultEtherUSDPrice = 580e6;\r\n        _defaultVokenUSDPrice = 0.5e6;\r\n    }\r\n\r\n    /**\r\n     * @dev Set Ether USD Price Contract.\r\n     */\r\n    function setEtherUSDPriceContract(address etherUSDPriceContract_)\r\n        external\r\n        onlyAgent\r\n    {\r\n        _etherUSDPriceContract = IEtherUSDPrice(etherUSDPriceContract_);\r\n    }\r\n\r\n    /**\r\n     * @dev Set Voken Sale Contract.\r\n     */\r\n    function setVokenSaleContract(address vokenSaleContract_)\r\n        external\r\n        onlyAgent\r\n    {\r\n        _vokenSaleContract = IVokenSale(vokenSaleContract_);\r\n    }\r\n\r\n    /**\r\n     * @dev Set default USD price of ETH and VokenTB.\r\n     */\r\n    function setDefaultUSDPrice(\r\n        uint256 resaleEtherUSDPrice_,\r\n        uint256 defaultEtherUSDPrice_,\r\n        uint256 defaultVokenUSDPrice_\r\n    )\r\n        external\r\n        onlyAgent\r\n    {\r\n        _resaleEtherUSDPrice = resaleEtherUSDPrice_;\r\n        _defaultEtherUSDPrice = defaultEtherUSDPrice_;\r\n        _defaultVokenUSDPrice = defaultVokenUSDPrice_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the (resale) ETH price in USD, with 6 decimals.\r\n     */\r\n    function resaleEtherUSDPrice()\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _resaleEtherUSDPrice;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ETH price in USD, with 6 decimals.\r\n     */\r\n    function _etherUSDPrice()\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (_etherUSDPriceContract != IEtherUSDPrice(0)) {\r\n            try _etherUSDPriceContract.etherUSDPrice() returns (uint256 value) {\r\n                return value;\r\n            }\r\n            \r\n            catch {\r\n                return _defaultEtherUSDPrice; \r\n            }\r\n        }\r\n\r\n        return _defaultEtherUSDPrice;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the Voken price in USD, with 6 decimals.\r\n     */\r\n    function vokenUSDPrice()\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (_vokenSaleContract != IVokenSale(0)) {\r\n            try _vokenSaleContract.vokenUSDPrice() returns (uint256 value) {\r\n                return value;\r\n            }\r\n            \r\n            catch {\r\n                return _defaultVokenUSDPrice;\r\n            }\r\n        }\r\n\r\n        return _defaultVokenUSDPrice;\r\n    }\r\n}\r\n\r\n"},"RouWithUSDToken.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\n\r\nimport \"LibSafeMath.sol\";\r\nimport \"LibBaseAuth.sol\";\r\nimport \"LibIERC20.sol\";\r\n\r\n\r\ncontract WithUSDToken is BaseAuth {\r\n    using SafeMath for uint256;\r\n    \r\n    IERC20 private _token;\r\n    uint8 private _decimalsDiff;\r\n    uint8 private constant DEFAULT_DECIMALS = 6;\r\n\r\n    constructor ()\r\n    {\r\n        setUSDToken(address(0x6B175474E89094C44Da98b954EedeAC495271d0F), 18); // DAI Stablecoin\r\n    }\r\n\r\n    function setUSDToken(address tokenContract, uint8 decimals)\r\n        public\r\n        onlyAgent\r\n    {\r\n        require(decimals \u003e= DEFAULT_DECIMALS, \"Set USD Token: decimals less than 6\");\r\n        require(decimals \u003c= 18, \"Set USD Token: decimals greater than 18\");\r\n\r\n        _token = IERC20(tokenContract);\r\n        _decimalsDiff = decimals - DEFAULT_DECIMALS;\r\n    }\r\n\r\n    function _getUSDBalance()\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (_decimalsDiff \u003e 0) {\r\n            return _token.balanceOf(address(this)).div(10 ** _decimalsDiff);\r\n        } else {\r\n            return _token.balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    function _transferUSD(address recipient, uint256 amount)\r\n        internal\r\n    {\r\n        if (_decimalsDiff \u003e 0) {\r\n            _token.transfer(recipient, amount.mul(10 ** _decimalsDiff));\r\n        } else {\r\n            _token.transfer(recipient, amount);\r\n        }\r\n    }\r\n}\r\n"},"RouWithVestingPermille.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.5;\r\n\r\n\r\nimport \"LibSafeMath.sol\";\r\nimport \"LibBaseAuth.sol\";\r\nimport \"LibIPermille.sol\";\r\n\r\n\r\ncontract WithVestingPermille is BaseAuth {\r\n    using SafeMath for uint256;\r\n\r\n    IPermille private _v1ClaimedVestingPermilleContract;\r\n    IPermille private _v1BonusesVestingPermilleContract;\r\n    IPermille private _v2ClaimedVestingPermilleContract;\r\n    IPermille private _v2BonusesVestingPermilleContract;\r\n\r\n    /**\r\n     * @dev Set Vesting Permille Contract(s).\r\n     */\r\n    function setV1CRPC(address permilleContract)\r\n        external\r\n        onlyAgent\r\n    {\r\n        _v1ClaimedVestingPermilleContract = IPermille(permilleContract);\r\n    }\r\n\r\n    function setV1BRPC(address permilleContract)\r\n        external\r\n        onlyAgent\r\n    {\r\n        _v1BonusesVestingPermilleContract = IPermille(permilleContract);\r\n    }\r\n\r\n    function setV2CRPC(address permilleContract)\r\n        external\r\n        onlyAgent\r\n    {\r\n        _v2ClaimedVestingPermilleContract = IPermille(permilleContract);\r\n    }\r\n\r\n    function setV2BRPC(address permilleContract)\r\n        external\r\n        onlyAgent\r\n    {\r\n        _v2BonusesVestingPermilleContract = IPermille(permilleContract);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the Vesting Permille Contract(s).\r\n     */\r\n    function VestingPermilleContracts()\r\n        public\r\n        view\r\n        returns (\r\n            IPermille v1ClaimedVestingPermilleContract,\r\n            IPermille v1BonusesVestingPermilleContract,\r\n            IPermille v2ClaimedVestingPermilleContract,\r\n            IPermille v2BonusesVestingPermilleContract\r\n        )\r\n    {\r\n        v1ClaimedVestingPermilleContract = _v1ClaimedVestingPermilleContract;\r\n        v1BonusesVestingPermilleContract = _v1BonusesVestingPermilleContract;\r\n        v2ClaimedVestingPermilleContract = _v2ClaimedVestingPermilleContract;\r\n        v2BonusesVestingPermilleContract = _v2BonusesVestingPermilleContract;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the `Vesting` amount for v1Claimed.\r\n     */\r\n    function _getV1ClaimedVestingAmount(uint256 amount)\r\n        internal\r\n        view\r\n        returns (uint256 Vesting)\r\n    {\r\n        if (amount \u003e 0) {\r\n            Vesting = _getVestingAmount(amount, _v1ClaimedVestingPermilleContract);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the `Vesting` amount for v1Bonuses.\r\n     */\r\n    function _getV1BonusesVestingAmount(uint256 amount)\r\n        internal\r\n        view\r\n        returns (uint256 Vesting)\r\n    {\r\n        if (amount \u003e 0) {\r\n            Vesting = _getVestingAmount(amount, _v1BonusesVestingPermilleContract);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the `Vesting` amount for v2Claimed.\r\n     */\r\n    function _getV2ClaimedVestingAmount(uint256 amount)\r\n        internal\r\n        view\r\n        returns (uint256 Vesting)\r\n    {\r\n        if (amount \u003e 0) {\r\n            Vesting = _getVestingAmount(amount, _v2ClaimedVestingPermilleContract);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the `Vesting` amount for v2Bonuses.\r\n     */\r\n    function _getV2BonusesVestingAmount(uint256 amount)\r\n        internal\r\n        view\r\n        returns (uint256 Vesting)\r\n    {\r\n        if (amount \u003e 0) {\r\n            Vesting = _getVestingAmount(amount, _v2BonusesVestingPermilleContract);\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev Returns the `Vesting` amount via a `permilleContract`.\r\n     */\r\n    function _getVestingAmount(uint256 amount, IPermille permilleContract)\r\n        private\r\n        view\r\n        returns (uint256 Vesting)\r\n    {\r\n        Vesting = amount;\r\n        \r\n        if (permilleContract != IPermille(0)) {\r\n            try permilleContract.permille() returns (uint16 permille) {\r\n                if (permille == 0) {\r\n                    Vesting = 0;\r\n                }\r\n\r\n                else if (permille \u003c 1_000) {\r\n                    Vesting = Vesting.mul(permille).div(1_000);\r\n                }\r\n            }\r\n\r\n            catch {\r\n                //\r\n            }\r\n        }\r\n    }\r\n}\r\n"}}