1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/aave/AaveBasicProxy.sol": {
5       "content": "pragma solidity ^0.6.0;\n\nimport \"../utils/GasBurner.sol\";\nimport \"../interfaces/IAToken.sol\";\nimport \"../interfaces/ILendingPool.sol\";\nimport \"../interfaces/ILendingPoolAddressesProvider.sol\";\n\nimport \"../utils/SafeERC20.sol\";\n\n/// @title Basic compound interactions through the DSProxy\ncontract AaveBasicProxy is GasBurner {\n\n    using SafeERC20 for ERC20;\n\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant AAVE_LENDING_POOL_ADDRESSES = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\n\n    uint16 public constant AAVE_REFERRAL_CODE = 64;\n\n    /// @notice User deposits tokens to the Aave protocol\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @param _tokenAddr The address of the token to be deposited\n    /// @param _amount Amount of tokens to be deposited\n    function deposit(address _tokenAddr, uint256 _amount) public burnGas(5) payable {\n        address lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        uint ethValue = _amount;\n\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\n            approveToken(_tokenAddr, lendingPoolCore);\n            ethValue = 0;\n        }\n\n        ILendingPool(lendingPool).deposit{value: ethValue}(_tokenAddr, _amount, AAVE_REFERRAL_CODE);\n\n        setUserUseReserveAsCollateralIfNeeded(_tokenAddr);\n    }\n\n    /// @notice User withdraws tokens from the Aave protocol\n    /// @param _tokenAddr The address of the token to be withdrawn\n    /// @param _aTokenAddr ATokens to be withdrawn\n    /// @param _amount Amount of tokens to be withdrawn\n    /// @param _wholeAmount If true we will take the whole amount on chain\n    function withdraw(address _tokenAddr, address _aTokenAddr, uint256 _amount, bool _wholeAmount) public burnGas(8) {\n        uint256 amount = _wholeAmount ? ERC20(_aTokenAddr).balanceOf(address(this)) : _amount;\n\n        IAToken(_aTokenAddr).redeem(amount);\n\n        withdrawTokens(_tokenAddr);\n    }\n\n    /// @notice User borrows tokens to the Aave protocol\n    /// @param _tokenAddr The address of the token to be borrowed\n    /// @param _amount Amount of tokens to be borrowed\n    /// @param _type Send 1 for stable rate and 2 for variable rate\n    function borrow(address _tokenAddr, uint256 _amount, uint256 _type) public burnGas(8) {\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        ILendingPool(lendingPool).borrow(_tokenAddr, _amount, _type, AAVE_REFERRAL_CODE);\n\n        withdrawTokens(_tokenAddr);\n    }\n\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @notice User paybacks tokens to the Aave protocol\n    /// @param _tokenAddr The address of the token to be paybacked\n    /// @param _aTokenAddr ATokens to be paybacked\n    /// @param _amount Amount of tokens to be payed back\n    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt\n    function payback(address _tokenAddr, address _aTokenAddr, uint256 _amount, bool _wholeDebt) public burnGas(3) payable {\n        address lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        uint256 amount = _amount;\n\n        (,uint256 borrowAmount,,,,,uint256 originationFee,,,) = ILendingPool(lendingPool).getUserReserveData(_tokenAddr, address(this));\n\n        if (_wholeDebt) {\n            amount = borrowAmount + originationFee;\n        }\n\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), amount);\n            approveToken(_tokenAddr, lendingPoolCore);\n        }\n\n        ILendingPool(lendingPool).repay{value: msg.value}(_tokenAddr, amount, payable(address(this)));\n\n        withdrawTokens(_tokenAddr);\n    }\n\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @notice User paybacks tokens to the Aave protocol\n    /// @param _tokenAddr The address of the token to be paybacked\n    /// @param _aTokenAddr ATokens to be paybacked\n    /// @param _amount Amount of tokens to be payed back\n    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt\n    function paybackOnBehalf(address _tokenAddr, address _aTokenAddr, uint256 _amount, bool _wholeDebt, address payable _onBehalf) public burnGas(3) payable {\n        address lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        uint256 amount = _amount;\n\n        (,uint256 borrowAmount,,,,,uint256 originationFee,,,) = ILendingPool(lendingPool).getUserReserveData(_tokenAddr, _onBehalf);\n\n        if (_wholeDebt) {\n            amount = borrowAmount + originationFee;\n        }\n\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), amount);\n            approveToken(_tokenAddr, lendingPoolCore);\n        }\n\n        ILendingPool(lendingPool).repay{value: msg.value}(_tokenAddr, amount, _onBehalf);\n\n        withdrawTokens(_tokenAddr);\n    }\n\n    /// @notice Helper method to withdraw tokens from the DSProxy\n    /// @param _tokenAddr Address of the token to be withdrawn\n    function withdrawTokens(address _tokenAddr) public {\n        uint256 amount = _tokenAddr == ETH_ADDR ? address(this).balance : ERC20(_tokenAddr).balanceOf(address(this));\n\n        if (amount > 0) {\n            if (_tokenAddr != ETH_ADDR) {\n                ERC20(_tokenAddr).safeTransfer(msg.sender, amount);\n            } else {\n                msg.sender.transfer(amount);\n            }\n        }\n    }\n\n    /// @notice Approves token contract to pull underlying tokens from the DSProxy\n    /// @param _tokenAddr Token we are trying to approve\n    /// @param _caller Address which will gain the approval\n    function approveToken(address _tokenAddr, address _caller) internal {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeApprove(_caller, uint256(-1));\n        }\n    }\n\n    function setUserUseReserveAsCollateralIfNeeded(address _tokenAddr) public {\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n        (,,,,,,,,,bool collateralEnabled) = ILendingPool(lendingPool).getUserReserveData(_tokenAddr, address(this));\n\n        if (!collateralEnabled) {\n            ILendingPool(lendingPool).setUserUseReserveAsCollateral(_tokenAddr, true);\n        }\n    }\n\n    function setUserUseReserveAsCollateral(address _tokenAddr, bool _true) public {\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        ILendingPool(lendingPool).setUserUseReserveAsCollateral(_tokenAddr, _true);\n    }\n\n    function swapBorrowRateMode(address _reserve) public {\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        ILendingPool(lendingPool).swapBorrowRateMode(_reserve);\n    }\n}\n"
6     },
7     "contracts/utils/GasBurner.sol": {
8       "content": "pragma solidity ^0.6.0;\n\nimport \"../interfaces/GasTokenInterface.sol\";\n\ncontract GasBurner {\n    // solhint-disable-next-line const-name-snakecase\n    GasTokenInterface public constant gasToken = GasTokenInterface(0x0000000000b3F879cb30FE243b4Dfee438691c04);\n\n    modifier burnGas(uint _amount) {\n        if (gasToken.balanceOf(address(this)) >= _amount) {\n            gasToken.free(_amount);\n        }\n\n        _;\n    }\n}\n"
9     },
10     "contracts/interfaces/IAToken.sol": {
11       "content": "pragma solidity ^0.6.0;\n\nabstract contract IAToken {\n    function redeem(uint256 _amount) external virtual;\n    function balanceOf(address _owner) external virtual view returns (uint256 balance);\n}\n"
12     },
13     "contracts/interfaces/ILendingPool.sol": {
14       "content": "pragma solidity ^0.6.0;\n\nabstract contract ILendingPool {\n    function flashLoan( address payable _receiver, address _reserve, uint _amount, bytes calldata _params) external virtual;\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode) external virtual payable;\n\tfunction setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external virtual;\n\tfunction borrow(address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode) external virtual;\n\tfunction repay( address _reserve, uint256 _amount, address payable _onBehalfOf) external virtual payable;\n\tfunction swapBorrowRateMode(address _reserve) external virtual;\n    function getReserves() external virtual view returns(address[] memory);\n\n    /// @param _reserve underlying token address\n    function getReserveData(address _reserve)\n        external virtual\n        view\n        returns (\n            uint256 totalLiquidity,               // reserve total liquidity\n            uint256 availableLiquidity,           // reserve available liquidity for borrowing\n            uint256 totalBorrowsStable,           // total amount of outstanding borrows at Stable rate\n            uint256 totalBorrowsVariable,         // total amount of outstanding borrows at Variable rate\n            uint256 liquidityRate,                // current deposit APY of the reserve for depositors, in Ray units.\n            uint256 variableBorrowRate,           // current variable rate APY of the reserve pool, in Ray units.\n            uint256 stableBorrowRate,             // current stable rate APY of the reserve pool, in Ray units.\n            uint256 averageStableBorrowRate,      // current average stable borrow rate\n            uint256 utilizationRate,              // expressed as total borrows/total liquidity.\n            uint256 liquidityIndex,               // cumulative liquidity index\n            uint256 variableBorrowIndex,          // cumulative variable borrow index\n            address aTokenAddress,                // aTokens contract address for the specific _reserve\n            uint40 lastUpdateTimestamp            // timestamp of the last update of reserve data\n        );\n\n    /// @param _user users address\n    function getUserAccountData(address _user)\n        external virtual\n        view\n        returns (\n            uint256 totalLiquidityETH,            // user aggregated deposits across all the reserves. In Wei\n            uint256 totalCollateralETH,           // user aggregated collateral across all the reserves. In Wei\n            uint256 totalBorrowsETH,              // user aggregated outstanding borrows across all the reserves. In Wei\n            uint256 totalFeesETH,                 // user aggregated current outstanding fees in ETH. In Wei\n            uint256 availableBorrowsETH,          // user available amount to borrow in ETH\n            uint256 currentLiquidationThreshold,  // user current average liquidation threshold across all the collaterals deposited\n            uint256 ltv,                          // user average Loan-to-Value between all the collaterals\n            uint256 healthFactor                  // user current Health Factor\n    );\n\n    /// @param _reserve underlying token address\n    /// @param _user users address\n    function getUserReserveData(address _reserve, address _user)\n        external virtual\n        view\n        returns (\n            uint256 currentATokenBalance,         // user current reserve aToken balance\n            uint256 currentBorrowBalance,         // user current reserve outstanding borrow balance\n            uint256 principalBorrowBalance,       // user balance of borrowed asset\n            uint256 borrowRateMode,               // user borrow rate mode either Stable or Variable\n            uint256 borrowRate,                   // user current borrow rate APY\n            uint256 liquidityRate,                // user current earn rate on _reserve\n            uint256 originationFee,               // user outstanding loan origination fee\n            uint256 variableBorrowIndex,          // user variable cumulative index\n            uint256 lastUpdateTimestamp,          // Timestamp of the last data update\n            bool usageAsCollateralEnabled         // Whether the user's current reserve is enabled as a collateral\n    );\n\n    function getReserveConfigurationData(address _reserve)\n        external virtual\n        view\n        returns (\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            address rateStrategyAddress,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive\n    );\n\n    // ------------------ LendingPoolCoreData ------------------------\n    function getReserveATokenAddress(address _reserve) public virtual view returns (address);\n    function getReserveConfiguration(address _reserve)\n        external virtual\n        view\n        returns (uint256, uint256, uint256, bool);\n    function getUserUnderlyingAssetBalance(address _reserve, address _user)\n        public virtual\n        view\n        returns (uint256);\n\n    function getReserveCurrentLiquidityRate(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n    function getReserveCurrentVariableBorrowRate(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n    function getReserveCurrentStableBorrowRate(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n    function getReserveTotalLiquidity(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n    function getReserveAvailableLiquidity(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n    function getReserveTotalBorrowsVariable(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n    function getReserveTotalBorrowsStable(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n\n    // ---------------- LendingPoolDataProvider ---------------------\n    function calculateUserGlobalData(address _user)\n        public virtual\n        view\n        returns (\n            uint256 totalLiquidityBalanceETH,\n            uint256 totalCollateralBalanceETH,\n            uint256 totalBorrowBalanceETH,\n            uint256 totalFeesETH,\n            uint256 currentLtv,\n            uint256 currentLiquidationThreshold,\n            uint256 healthFactor,\n            bool healthFactorBelowThreshold\n        );\n}\n"
15     },
16     "contracts/interfaces/ILendingPoolAddressesProvider.sol": {
17       "content": "pragma solidity ^0.6.0;\n\n/**\n@title ILendingPoolAddressesProvider interface\n@notice provides the interface to fetch the LendingPoolCore address\n */\nabstract contract ILendingPoolAddressesProvider {\n\n    function getLendingPool() public virtual view returns (address);\n    function getLendingPoolCore() public virtual view returns (address payable);\n    function getLendingPoolConfigurator() public virtual view returns (address);\n    function getLendingPoolDataProvider() public virtual view returns (address);\n    function getLendingPoolParametersProvider() public virtual view returns (address);\n    function getTokenDistributor() public virtual view returns (address);\n    function getFeeProvider() public virtual view returns (address);\n    function getLendingPoolLiquidationManager() public virtual view returns (address);\n    function getLendingPoolManager() public virtual view returns (address);\n    function getPriceOracle() public virtual view returns (address);\n    function getLendingRateOracle() public virtual view returns (address);\n}"
18     },
19     "contracts/utils/SafeERC20.sol": {
20       "content": "pragma solidity ^0.6.0;\n\nimport \"../interfaces/ERC20.sol\";\nimport \"./Address.sol\";\nimport \"./SafeMath.sol\";\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     */\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function _callOptionalReturn(ERC20 token, bytes memory data) private {\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
21     },
22     "contracts/interfaces/GasTokenInterface.sol": {
23       "content": "pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract GasTokenInterface is ERC20 {\n    function free(uint256 value) public virtual returns (bool success);\n\n    function freeUpTo(uint256 value) public virtual returns (uint256 freed);\n\n    function freeFrom(address from, uint256 value) public virtual returns (bool success);\n\n    function freeFromUpTo(address from, uint256 value) public virtual returns (uint256 freed);\n}\n"
24     },
25     "contracts/interfaces/ERC20.sol": {
26       "content": "pragma solidity ^0.6.0;\n\ninterface ERC20 {\n    function totalSupply() external view returns (uint256 supply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    function decimals() external view returns (uint256 digits);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n"
27     },
28     "contracts/utils/Address.sol": {
29       "content": "pragma solidity ^0.6.0;\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
30     },
31     "contracts/utils/SafeMath.sol": {
32       "content": "pragma solidity ^0.6.0;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
33     },
34     "contracts/utils/PullTokensProxy.sol": {
35       "content": "pragma solidity ^0.6.0;\n\nimport \"../interfaces/DSProxyInterface.sol\";\nimport \"./SafeERC20.sol\";\n\n/// @title Pulls a specified amount of tokens from the EOA owner account to the proxy\ncontract PullTokensProxy {\n    using SafeERC20 for ERC20;\n\n    /// @notice Pulls a token from the proxyOwner -> proxy\n    /// @dev Proxy owner must first give approve to the proxy address\n    /// @param _tokenAddr Address of the ERC20 token\n    /// @param _amount Amount of tokens which will be transfered to the proxy\n    function pullTokens(address _tokenAddr, uint _amount) public {\n        address proxyOwner = DSProxyInterface(address(this)).owner();\n\n        ERC20(_tokenAddr).safeTransferFrom(proxyOwner, address(this), _amount);\n    }\n}\n"
36     },
37     "contracts/interfaces/DSProxyInterface.sol": {
38       "content": "pragma solidity ^0.6.0;\n\n\nabstract contract DSProxyInterface {\n\n    /// Truffle wont compile if this isn't commented\n    // function execute(bytes memory _code, bytes memory _data)\n    //     public virtual\n    //     payable\n    //     returns (address, bytes32);\n\n    function execute(address _target, bytes memory _data) public virtual payable returns (bytes32);\n\n    function setCache(address _cacheAddr) public virtual payable returns (bool);\n\n    function owner() public virtual returns (address);\n}\n"
39     },
40     "contracts/utils/DFSProxy.sol": {
41       "content": "pragma solidity ^0.6.0;\n\nimport \"../auth/Auth.sol\";\nimport \"../interfaces/DSProxyInterface.sol\";\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\ncontract DFSProxy is Auth {\n    string public constant NAME = \"DFSProxy\";\n    string public constant VERSION = \"v0.1\";\n\n    mapping(address => mapping(uint => bool)) public nonces;\n\n    // --- EIP712 niceties ---\n    bytes32 public DOMAIN_SEPARATOR;\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\"callProxy(address _user,address _proxy,address _contract,bytes _txData,uint256 _nonce)\");\n\n    constructor(uint256 chainId_) public {\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(NAME)),\n            keccak256(bytes(VERSION)),\n            chainId_,\n            address(this)\n        ));\n    }\n\n    function callProxy(address _user, address _proxy, address _contract, bytes calldata _txData, uint256 _nonce,\n                    uint8 _v, bytes32 _r, bytes32 _s) external payable onlyAuthorized\n    {\n        bytes32 digest =\n            keccak256(abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH,\n                                     _user,\n                                     _proxy,\n                                     _contract,\n                                     _txData,\n                                     _nonce))\n        ));\n\n        // user must be proxy owner\n        require(DSProxyInterface(_proxy).owner() == _user);\n        require(_user == ecrecover(digest, _v, _r, _s), \"DFSProxy/user-not-valid\");\n        require(!nonces[_user][_nonce], \"DFSProxy/invalid-nonce\");\n        \n        nonces[_user][_nonce] = true;\n\n        DSProxyInterface(_proxy).execute{value: msg.value}(_contract, _txData);\n    }\n}"
42     },
43     "contracts/auth/Auth.sol": {
44       "content": "pragma solidity ^0.6.0;\n\nimport \"./AdminAuth.sol\";\n\ncontract Auth is AdminAuth {\n\n\tbool public ALL_AUTHORIZED = false;\n\n\tmapping(address => bool) public authorized;\n\n\tmodifier onlyAuthorized() {\n        require(ALL_AUTHORIZED || authorized[msg.sender]);\n        _;\n    }\n\n\tconstructor() public {\n\t\tauthorized[msg.sender] = true;\n\t}\n\n\tfunction setAuthorized(address _user, bool _approved) public onlyOwner {\n\t\tauthorized[_user] = _approved;\n\t}\n\n\tfunction setAllAuthorized(bool _authorized) public onlyOwner {\n\t\tALL_AUTHORIZED = _authorized;\n\t}\n}"
45     },
46     "contracts/auth/AdminAuth.sol": {
47       "content": "pragma solidity ^0.6.0;\n\nimport \"../utils/SafeERC20.sol\";\n\ncontract AdminAuth {\n\n    using SafeERC20 for ERC20;\n\n    address public owner;\n    address public admin;\n\n    modifier onlyOwner() {\n        require(owner == msg.sender);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(admin == msg.sender);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n        admin = 0x25eFA336886C74eA8E282ac466BdCd0199f85BB9;\n    }\n\n    /// @notice Admin is set by owner first time, after that admin is super role and has permission to change owner\n    /// @param _admin Address of multisig that becomes admin\n    function setAdminByOwner(address _admin) public {\n        require(msg.sender == owner);\n        require(admin == address(0));\n\n        admin = _admin;\n    }\n\n    /// @notice Admin is able to set new admin\n    /// @param _admin Address of multisig that becomes new admin\n    function setAdminByAdmin(address _admin) public {\n        require(msg.sender == admin);\n\n        admin = _admin;\n    }\n\n    /// @notice Admin is able to change owner\n    /// @param _owner Address of new owner\n    function setOwnerByAdmin(address _owner) public {\n        require(msg.sender == admin);\n\n        owner = _owner;\n    }\n\n    /// @notice Destroy the contract\n    function kill() public onlyOwner {\n        selfdestruct(payable(owner));\n    }\n\n    /// @notice  withdraw stuck funds\n    function withdrawStuckFunds(address _token, uint _amount) public onlyOwner {\n        if (_token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            payable(owner).transfer(_amount);\n        } else {\n            ERC20(_token).safeTransfer(owner, _amount);\n        }\n    }\n}\n"
48     },
49     "contracts/shifter/LoanShifterTaker.sol": {
50       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/ILendingPool.sol\";\nimport \"../interfaces/CTokenInterface.sol\";\nimport \"../interfaces/ILoanShifter.sol\";\nimport \"../interfaces/DSProxyInterface.sol\";\nimport \"../interfaces/Vat.sol\";\nimport \"../interfaces/Manager.sol\";\nimport \"../interfaces/IMCDSubscriptions.sol\";\nimport \"../interfaces/ICompoundSubscriptions.sol\";\nimport \"../auth/AdminAuth.sol\";\nimport \"../auth/ProxyPermission.sol\";\nimport \"../exchangeV3/DFSExchangeData.sol\";\nimport \"./ShifterRegistry.sol\";\nimport \"../utils/GasBurner.sol\";\nimport \"../loggers/DefisaverLogger.sol\";\n\n\n/// @title LoanShifterTaker Entry point for using the shifting operation\ncontract LoanShifterTaker is AdminAuth, ProxyPermission, GasBurner {\n\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant CETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    address public constant MCD_SUB_ADDRESS = 0xC45d4f6B6bf41b6EdAA58B01c4298B8d9078269a;\n    address public constant COMPOUND_SUB_ADDRESS = 0x52015EFFD577E08f498a0CCc11905925D58D6207;\n\n    address public constant MANAGER_ADDRESS = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\n\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n\n    Manager public constant manager = Manager(MANAGER_ADDRESS);\n    ShifterRegistry public constant shifterRegistry = ShifterRegistry(0x597C52281b31B9d949a9D8fEbA08F7A2530a965e);\n\n    enum Protocols { MCD, COMPOUND }\n    enum SwapType { NO_SWAP, COLL_SWAP, DEBT_SWAP }\n    enum Unsub { NO_UNSUB, FIRST_UNSUB, SECOND_UNSUB, BOTH_UNSUB }\n\n    struct LoanShiftData {\n        Protocols fromProtocol;\n        Protocols toProtocol;\n        SwapType swapType;\n        Unsub unsub;\n        bool wholeDebt;\n        uint collAmount;\n        uint debtAmount;\n        address debtAddr1;\n        address debtAddr2;\n        address addrLoan1;\n        address addrLoan2;\n        uint id1;\n        uint id2;\n    }\n\n    /// @notice Main entry point, it will move or transform a loan\n    /// @dev Called through DSProxy\n    function moveLoan(\n        DFSExchangeData.ExchangeData memory _exchangeData,\n        LoanShiftData memory _loanShift\n    ) public payable burnGas(20) {\n        if (_isSameTypeVaults(_loanShift)) {\n            _forkVault(_loanShift);\n            logEvent(_exchangeData, _loanShift);\n            return;\n        }\n\n        _callCloseAndOpen(_exchangeData, _loanShift);\n    }\n\n    //////////////////////// INTERNAL FUNCTIONS //////////////////////////\n\n    function _callCloseAndOpen(\n        DFSExchangeData.ExchangeData memory _exchangeData,\n        LoanShiftData memory _loanShift\n    ) internal {\n        address protoAddr = shifterRegistry.getAddr(getNameByProtocol(uint8(_loanShift.fromProtocol)));\n\n        if (_loanShift.wholeDebt) {\n            _loanShift.debtAmount = ILoanShifter(protoAddr).getLoanAmount(_loanShift.id1, _loanShift.debtAddr1);\n        }\n\n        // encode data\n        bytes memory paramsData = abi.encode(_loanShift, _exchangeData, address(this));\n\n        address payable loanShifterReceiverAddr = payable(shifterRegistry.getAddr(\"LOAN_SHIFTER_RECEIVER\"));\n\n        loanShifterReceiverAddr.transfer(address(this).balance);\n\n        // call FL\n        givePermission(loanShifterReceiverAddr);\n\n        lendingPool.flashLoan(loanShifterReceiverAddr,\n           getLoanAddr(_loanShift.debtAddr1, _loanShift.fromProtocol), _loanShift.debtAmount, paramsData);\n\n        removePermission(loanShifterReceiverAddr);\n\n        unsubFromAutomation(\n            _loanShift.unsub,\n            _loanShift.id1,\n            _loanShift.id2,\n            _loanShift.fromProtocol,\n            _loanShift.toProtocol\n        );\n\n        logEvent(_exchangeData, _loanShift);\n    }\n\n    function _forkVault(LoanShiftData memory _loanShift) internal {\n        // Create new Vault to move to\n        if (_loanShift.id2 == 0) {\n            _loanShift.id2 = manager.open(manager.ilks(_loanShift.id1), address(this));\n        }\n\n        if (_loanShift.wholeDebt) {\n            manager.shift(_loanShift.id1, _loanShift.id2);\n        }\n    }\n\n    function _isSameTypeVaults(LoanShiftData memory _loanShift) internal pure returns (bool) {\n        return _loanShift.fromProtocol == Protocols.MCD && _loanShift.toProtocol == Protocols.MCD\n                && _loanShift.addrLoan1 == _loanShift.addrLoan2;\n    }\n\n    function getNameByProtocol(uint8 _proto) internal pure returns (string memory) {\n        if (_proto == 0) {\n            return \"MCD_SHIFTER\";\n        } else if (_proto == 1) {\n            return \"COMP_SHIFTER\";\n        }\n    }\n\n    function getLoanAddr(address _address, Protocols _fromProtocol) internal returns (address) {\n        if (_fromProtocol == Protocols.COMPOUND) {\n            return getUnderlyingAddr(_address);\n        } else if (_fromProtocol == Protocols.MCD) {\n            return DAI_ADDRESS;\n        } else {\n            return address(0);\n        }\n    }\n\n    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\n        if (_cTokenAddress == CETH_ADDRESS) {\n            return ETH_ADDRESS;\n        } else {\n            return CTokenInterface(_cTokenAddress).underlying();\n        }\n    }\n\n    function logEvent(\n        DFSExchangeData.ExchangeData memory _exchangeData,\n        LoanShiftData memory _loanShift\n    ) internal {\n        address srcAddr = _exchangeData.srcAddr;\n        address destAddr = _exchangeData.destAddr;\n\n        uint collAmount = _exchangeData.srcAmount;\n        uint debtAmount = _exchangeData.destAmount;\n\n        if (_loanShift.swapType == SwapType.NO_SWAP) {\n            srcAddr = _loanShift.addrLoan1;\n            destAddr = _loanShift.debtAddr1;\n\n            collAmount = _loanShift.collAmount;\n            debtAmount = _loanShift.debtAmount;\n        }\n\n        DefisaverLogger(DEFISAVER_LOGGER)\n            .Log(address(this), msg.sender, \"LoanShifter\",\n            abi.encode(\n            _loanShift.fromProtocol,\n            _loanShift.toProtocol,\n            _loanShift.swapType,\n            srcAddr,\n            destAddr,\n            collAmount,\n            debtAmount\n        ));\n    }\n\n    function unsubFromAutomation(Unsub _unsub, uint _cdp1, uint _cdp2, Protocols _from, Protocols _to) internal {\n        if (_unsub != Unsub.NO_UNSUB) {\n            if (_unsub == Unsub.FIRST_UNSUB || _unsub == Unsub.BOTH_UNSUB) {\n                unsubscribe(_cdp1, _from);\n            }\n\n            if (_unsub == Unsub.SECOND_UNSUB || _unsub == Unsub.BOTH_UNSUB) {\n                unsubscribe(_cdp2, _to);\n            }\n        }\n    }\n\n    function unsubscribe(uint _cdpId, Protocols _protocol) internal {\n        if (_cdpId != 0 && _protocol == Protocols.MCD) {\n            IMCDSubscriptions(MCD_SUB_ADDRESS).unsubscribe(_cdpId);\n        }\n\n        if (_protocol == Protocols.COMPOUND) {\n            ICompoundSubscriptions(COMPOUND_SUB_ADDRESS).unsubscribe();\n        }\n    }\n\n}\n"
51     },
52     "contracts/interfaces/CTokenInterface.sol": {
53       "content": "pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract CTokenInterface is ERC20 {\n    function mint(uint256 mintAmount) external virtual returns (uint256);\n\n    // function mint() external virtual payable;\n\n    function accrueInterest() public virtual returns (uint);\n\n    function redeem(uint256 redeemTokens) external virtual returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);\n\n    function borrow(uint256 borrowAmount) external virtual returns (uint256);\n    function borrowIndex() public view virtual returns (uint);\n    function borrowBalanceStored(address) public view virtual returns(uint);\n\n    function repayBorrow(uint256 repayAmount) external virtual returns (uint256);\n\n    function repayBorrow() external virtual payable;\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (uint256);\n\n    function repayBorrowBehalf(address borrower) external virtual payable;\n\n    function liquidateBorrow(address borrower, uint256 repayAmount, address cTokenCollateral)\n        external virtual\n        returns (uint256);\n\n    function liquidateBorrow(address borrower, address cTokenCollateral) external virtual payable;\n\n    function exchangeRateCurrent() external virtual returns (uint256);\n\n    function supplyRatePerBlock() external virtual returns (uint256);\n\n    function borrowRatePerBlock() external virtual returns (uint256);\n\n    function totalReserves() external virtual returns (uint256);\n\n    function reserveFactorMantissa() external virtual returns (uint256);\n\n    function borrowBalanceCurrent(address account) external virtual returns (uint256);\n\n    function totalBorrowsCurrent() external virtual returns (uint256);\n\n    function getCash() external virtual returns (uint256);\n\n    function balanceOfUnderlying(address owner) external virtual returns (uint256);\n\n    function underlying() external virtual returns (address);\n\n    function getAccountSnapshot(address account) external virtual view returns (uint, uint, uint, uint);\n}\n"
54     },
55     "contracts/interfaces/ILoanShifter.sol": {
56       "content": "pragma solidity ^0.6.0;\n\nabstract contract ILoanShifter {\n    function getLoanAmount(uint, address) public virtual returns (uint);\n    function getUnderlyingAsset(address _addr) public view virtual returns (address);\n}\n"
57     },
58     "contracts/interfaces/Vat.sol": {
59       "content": "pragma solidity ^0.6.0;\n\nabstract contract Vat {\n\n    struct Urn {\n        uint256 ink;   // Locked Collateral  [wad]\n        uint256 art;   // Normalised Debt    [wad]\n    }\n\n    struct Ilk {\n        uint256 Art;   // Total Normalised Debt     [wad]\n        uint256 rate;  // Accumulated Rates         [ray]\n        uint256 spot;  // Price with Safety Margin  [ray]\n        uint256 line;  // Debt Ceiling              [rad]\n        uint256 dust;  // Urn Debt Floor            [rad]\n    }\n\n    mapping (bytes32 => mapping (address => Urn )) public urns;\n    mapping (bytes32 => Ilk)                       public ilks;\n    mapping (bytes32 => mapping (address => uint)) public gem;  // [wad]\n\n    function can(address, address) virtual public view returns (uint);\n    function dai(address) virtual public view returns (uint);\n    function frob(bytes32, address, address, address, int, int) virtual public;\n    function hope(address) virtual public;\n    function move(address, address, uint) virtual public;\n    function fork(bytes32, address, address, int, int) virtual public;\n}\n"
60     },
61     "contracts/interfaces/Manager.sol": {
62       "content": "pragma solidity ^0.6.0;\n\nabstract contract Manager {\n    function last(address) virtual public returns (uint);\n    function cdpCan(address, uint, address) virtual public view returns (uint);\n    function ilks(uint) virtual public view returns (bytes32);\n    function owns(uint) virtual public view returns (address);\n    function urns(uint) virtual public view returns (address);\n    function vat() virtual public view returns (address);\n    function open(bytes32, address) virtual public returns (uint);\n    function give(uint, address) virtual public;\n    function cdpAllow(uint, address, uint) virtual public;\n    function urnAllow(address, uint) virtual public;\n    function frob(uint, int, int) virtual public;\n    function flux(uint, address, uint) virtual public;\n    function move(uint, address, uint) virtual public;\n    function exit(address, uint, address, uint) virtual public;\n    function quit(uint, address) virtual public;\n    function enter(address, uint) virtual public;\n    function shift(uint, uint) virtual public;\n}\n"
63     },
64     "contracts/interfaces/IMCDSubscriptions.sol": {
65       "content": "pragma solidity ^0.6.0;\n\nabstract contract IMCDSubscriptions {\n    function unsubscribe(uint256 _cdpId) external virtual ;\n    function subscribersPos(uint256 _cdpId) external virtual returns (uint256, bool);\n}\n"
66     },
67     "contracts/interfaces/ICompoundSubscriptions.sol": {
68       "content": "pragma solidity ^0.6.0;\n\nabstract contract ICompoundSubscriptions {\n    function unsubscribe() external virtual ;\n}\n"
69     },
70     "contracts/auth/ProxyPermission.sol": {
71       "content": "pragma solidity ^0.6.0;\n\nimport \"../DS/DSGuard.sol\";\nimport \"../DS/DSAuth.sol\";\n\ncontract ProxyPermission {\n    address public constant FACTORY_ADDRESS = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;\n\n    /// @notice Called in the context of DSProxy to authorize an address\n    /// @param _contractAddr Address which will be authorized\n    function givePermission(address _contractAddr) public {\n        address currAuthority = address(DSAuth(address(this)).authority());\n        DSGuard guard = DSGuard(currAuthority);\n\n        if (currAuthority == address(0)) {\n            guard = DSGuardFactory(FACTORY_ADDRESS).newGuard();\n            DSAuth(address(this)).setAuthority(DSAuthority(address(guard)));\n        }\n\n        guard.permit(_contractAddr, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n    }\n\n    /// @notice Called in the context of DSProxy to remove authority of an address\n    /// @param _contractAddr Auth address which will be removed from authority list\n    function removePermission(address _contractAddr) public {\n        address currAuthority = address(DSAuth(address(this)).authority());\n        \n        // if there is no authority, that means that contract doesn't have permission\n        if (currAuthority == address(0)) {\n            return;\n        }\n\n        DSGuard guard = DSGuard(currAuthority);\n        guard.forbid(_contractAddr, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n    }\n\n    function proxyOwner() internal returns(address) {\n        return DSAuth(address(this)).owner();\n    } \n}\n"
72     },
73     "contracts/exchangeV3/DFSExchangeData.sol": {
74       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ncontract DFSExchangeData {\n\n    // first is empty to keep the legacy order in place\n    enum ExchangeType { _, OASIS, KYBER, UNISWAP, ZEROX }\n\n    enum ActionType { SELL, BUY }\n\n    struct OffchainData {\n        address wrapper;\n        address exchangeAddr;\n        address allowanceTarget;\n        uint256 price;\n        uint256 protocolFee;\n        bytes callData;\n    }\n\n    struct ExchangeData {\n        address srcAddr;\n        address destAddr;\n        uint256 srcAmount;\n        uint256 destAmount;\n        uint256 minPrice;\n        uint256 dfsFeeDivider; // service fee divider\n        address user; // user to check special fee\n        address wrapper;\n        bytes wrapperData;\n        OffchainData offchainData;\n    }\n\n    function packExchangeData(ExchangeData memory _exData) public pure returns(bytes memory) {\n        return abi.encode(_exData);\n    }\n\n    function unpackExchangeData(bytes memory _data) public pure returns(ExchangeData memory _exData) {\n        _exData = abi.decode(_data, (ExchangeData));\n    }\n}"
75     },
76     "contracts/shifter/ShifterRegistry.sol": {
77       "content": "pragma solidity ^0.6.0;\n\nimport \"../auth/AdminAuth.sol\";\n\ncontract ShifterRegistry is AdminAuth {\n    mapping (string => address) public contractAddresses;\n    bool public finalized;\n\n    function changeContractAddr(string memory _contractName, address _protoAddr) public onlyOwner {\n        require(!finalized);\n        contractAddresses[_contractName] = _protoAddr;\n    }\n\n    function lock() public onlyOwner {\n        finalized = true;\n    }\n\n    function getAddr(string memory _contractName) public view returns (address contractAddr) {\n        contractAddr = contractAddresses[_contractName];\n\n        require(contractAddr != address(0), \"No contract address registred\");\n    }\n\n}\n"
78     },
79     "contracts/loggers/DefisaverLogger.sol": {
80       "content": "pragma solidity ^0.6.0;\n\ncontract DefisaverLogger {\n    event LogEvent(\n        address indexed contractAddress,\n        address indexed caller,\n        string indexed logName,\n        bytes data\n    );\n\n    // solhint-disable-next-line func-name-mixedcase\n    function Log(address _contract, address _caller, string memory _logName, bytes memory _data)\n        public\n    {\n        emit LogEvent(_contract, _caller, _logName, _data);\n    }\n}\n"
81     },
82     "contracts/DS/DSGuard.sol": {
83       "content": "pragma solidity ^0.6.0;\n\n\nabstract contract DSGuard {\n    function canCall(address src_, address dst_, bytes4 sig) public view virtual returns (bool);\n\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\n\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\n\n    function permit(address src, address dst, bytes32 sig) public virtual;\n\n    function forbid(address src, address dst, bytes32 sig) public virtual;\n}\n\n\nabstract contract DSGuardFactory {\n    function newGuard() public virtual returns (DSGuard guard);\n}\n"
84     },
85     "contracts/DS/DSAuth.sol": {
86       "content": "pragma solidity ^0.6.0;\n\nimport \"./DSAuthority.sol\";\n\n\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority public authority;\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_) public auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_) public auth {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n"
87     },
88     "contracts/DS/DSAuthority.sol": {
89       "content": "pragma solidity ^0.6.0;\n\n\nabstract contract DSAuthority {\n    function canCall(address src, address dst, bytes4 sig) public virtual view returns (bool);\n}\n"
90     },
91     "contracts/reflexer/saver/RAISaverProxy.sol": {
92       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../utils/Discount.sol\";\n\nimport \"../../interfaces/reflexer/IOracleRelayer.sol\";\nimport \"../../interfaces/reflexer/ITaxCollector.sol\";\nimport \"../../interfaces/reflexer/ICoinJoin.sol\";\n\nimport \"./RAISaverProxyHelper.sol\";\nimport \"../../utils/BotRegistry.sol\";\nimport \"../../exchangeV3/DFSExchangeCore.sol\";\n\n/// @title Implements Boost and Repay for Reflexer Safes\ncontract RAISaverProxy is DFSExchangeCore, RAISaverProxyHelper {\n\n    uint public constant MANUAL_SERVICE_FEE = 400; // 0.25% Fee\n    uint public constant AUTOMATIC_SERVICE_FEE = 333; // 0.3% Fee\n\n    bytes32 public constant ETH_COLL_TYPE = 0x4554482d41000000000000000000000000000000000000000000000000000000;\n\n    address public constant SAFE_ENGINE_ADDRESS = 0xCC88a9d330da1133Df3A7bD823B95e52511A6962;\n    address public constant ORACLE_RELAYER_ADDRESS = 0x4ed9C0dCa0479bC64d8f4EB3007126D5791f7851;\n    address public constant RAI_JOIN_ADDRESS = 0x0A5653CCa4DB1B6E265F47CAf6969e64f1CFdC45;\n    address public constant TAX_COLLECTOR_ADDRESS = 0xcDB05aEda142a1B0D6044C09C64e4226c1a281EB;\n    address public constant RAI_ADDRESS = 0x03ab458634910AaD20eF5f1C8ee96F1D6ac54919;\n\n    address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;\n\n    ISAFEEngine public constant safeEngine = ISAFEEngine(SAFE_ENGINE_ADDRESS);\n    ICoinJoin public constant raiJoin = ICoinJoin(RAI_JOIN_ADDRESS);\n    IOracleRelayer public constant oracleRelayer = IOracleRelayer(ORACLE_RELAYER_ADDRESS);\n\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\n\n    /// @notice Repay - draws collateral, converts to Rai and repays the debt\n    /// @dev Must be called by the DSProxy contract that owns the Safe\n    function repay(\n        ExchangeData memory _exchangeData,\n        uint _safeId,\n        uint _gasCost,\n        address _joinAddr,\n        ManagerType _managerType\n    ) public payable {\n\n        address managerAddr = getManagerAddr(_managerType);\n\n        address user = getOwner(ISAFEManager(managerAddr), _safeId);\n        bytes32 ilk = ISAFEManager(managerAddr).collateralTypes(_safeId);\n\n        drawCollateral(managerAddr, _safeId, _joinAddr, _exchangeData.srcAmount, true);\n\n        _exchangeData.user = user;\n        _exchangeData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\n        (, uint raiAmount) = _sell(_exchangeData);\n\n        raiAmount -= takeFee(_gasCost, raiAmount);\n\n        paybackDebt(managerAddr, _safeId, ilk, raiAmount, user);\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n\n        logger.Log(address(this), msg.sender, \"RAIRepay\", abi.encode(_safeId, user, _exchangeData.srcAmount, raiAmount));\n\n    }\n\n    /// @notice Boost - draws Rai, converts to collateral and adds to Safe\n    /// @dev Must be called by the DSProxy contract that owns the Safe\n    function boost(\n        ExchangeData memory _exchangeData,\n        uint _safeId,\n        uint _gasCost,\n        address _joinAddr,\n        ManagerType _managerType\n    ) public payable {\n\n        address managerAddr = getManagerAddr(_managerType);\n\n        address user = getOwner(ISAFEManager(managerAddr), _safeId);\n        bytes32 ilk = ISAFEManager(managerAddr).collateralTypes(_safeId);\n\n        uint raiDrawn = drawRai(managerAddr, _safeId, ilk, _exchangeData.srcAmount);\n\n        _exchangeData.user = user;\n        _exchangeData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\n        _exchangeData.srcAmount = raiDrawn - takeFee(_gasCost, raiDrawn);\n        (, uint swapedColl) = _sell(_exchangeData);\n\n        addCollateral(managerAddr, _safeId, _joinAddr, swapedColl, true);\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n\n        logger.Log(address(this), msg.sender, \"RAIBoost\", abi.encode(_safeId, user, _exchangeData.srcAmount, swapedColl));\n    }\n\n    /// @notice Draws Rai from the Safe\n    /// @dev If _raiAmount is bigger than max available we'll draw max\n    /// @param _managerAddr Address of the Safe Manager\n    /// @param _safeId Id of the Safe\n    /// @param _collType Coll type of the Safe\n    /// @param _raiAmount Amount of Rai to draw\n    function drawRai(address _managerAddr, uint _safeId, bytes32 _collType, uint _raiAmount) internal returns (uint) {\n        uint rate = ITaxCollector(TAX_COLLECTOR_ADDRESS).taxSingle(_collType);\n        uint raiVatBalance = safeEngine.coinBalance(ISAFEManager(_managerAddr).safes(_safeId));\n\n        uint maxAmount = getMaxDebt(_managerAddr, _safeId, _collType);\n\n        if (_raiAmount >= maxAmount) {\n            _raiAmount = sub(maxAmount, 1);\n        }\n\n        ISAFEManager(_managerAddr).modifySAFECollateralization(_safeId, int(0), normalizeDrawAmount(_raiAmount, rate, raiVatBalance));\n        ISAFEManager(_managerAddr).transferInternalCoins(_safeId, address(this), toRad(_raiAmount));\n\n        if (safeEngine.safeRights(address(this), address(RAI_JOIN_ADDRESS)) == 0) {\n            safeEngine.approveSAFEModification(RAI_JOIN_ADDRESS);\n        }\n\n        ICoinJoin(RAI_JOIN_ADDRESS).exit(address(this), _raiAmount);\n\n        return _raiAmount;\n    }\n\n    /// @notice Adds collateral to the Safe\n    /// @param _managerAddr Address of the Safe Manager\n    /// @param _safeId Id of the Safe\n    /// @param _joinAddr Address of the join contract for the Safe collateral\n    /// @param _amount Amount of collateral to add\n    /// @param _toWeth Should we convert to Weth\n    function addCollateral(address _managerAddr, uint _safeId, address _joinAddr, uint _amount, bool _toWeth) internal {\n        int convertAmount = 0;\n\n        if (isEthJoinAddr(_joinAddr) && _toWeth) {\n            TokenInterface(IBasicTokenAdapters(_joinAddr).collateral()).deposit{value: _amount}();\n            convertAmount = toPositiveInt(_amount);\n        } else {\n            convertAmount = toPositiveInt(convertTo18(_joinAddr, _amount));\n        }\n\n        ERC20(address(IBasicTokenAdapters(_joinAddr).collateral())).safeApprove(_joinAddr, _amount);\n\n        IBasicTokenAdapters(_joinAddr).join(address(this), _amount);\n\n        safeEngine.modifySAFECollateralization(\n            ISAFEManager(_managerAddr).collateralTypes(_safeId),\n            ISAFEManager(_managerAddr).safes(_safeId),\n            address(this),\n            address(this),\n            convertAmount,\n            0\n        );\n\n    }\n\n    /// @notice Draws collateral and returns it to DSProxy\n    /// @param _managerAddr Address of the Safe Manager\n    /// @dev If _amount is bigger than max available we'll draw max\n    /// @param _safeId Id of the Safe\n    /// @param _joinAddr Address of the join contract for the Safe collateral\n    /// @param _amount Amount of collateral to draw\n    /// @param _toEth Boolean if we should unwrap Ether\n    function drawCollateral(address _managerAddr, uint _safeId, address _joinAddr, uint _amount, bool _toEth) internal returns (uint) {\n        uint frobAmount = _amount;\n\n        if (IBasicTokenAdapters(_joinAddr).decimals() != 18) {\n            frobAmount = _amount * (10 ** (18 - IBasicTokenAdapters(_joinAddr).decimals()));\n        }\n\n        ISAFEManager(_managerAddr).modifySAFECollateralization(_safeId, -toPositiveInt(frobAmount), 0);\n        ISAFEManager(_managerAddr).transferCollateral(_safeId, address(this), frobAmount);\n\n        IBasicTokenAdapters(_joinAddr).exit(address(this), _amount);\n\n        if (isEthJoinAddr(_joinAddr) && _toEth) {\n            TokenInterface(IBasicTokenAdapters(_joinAddr).collateral()).withdraw(_amount); // Weth -> Eth\n        }\n\n        return _amount;\n    }\n\n    /// @notice Paybacks Rai debt\n    /// @param _managerAddr Address of the Safe Manager\n    /// @dev If the _raiAmount is bigger than the whole debt, returns extra Rai\n    /// @param _safeId Id of the Safe\n    /// @param _collType Coll type of the Safe\n    /// @param _raiAmount Amount of Rai to payback\n    /// @param _owner Address that owns the DSProxy that owns the Safe\n    function paybackDebt(address _managerAddr, uint _safeId, bytes32 _collType, uint _raiAmount, address _owner) internal {\n        address urn = ISAFEManager(_managerAddr).safes(_safeId);\n\n        uint wholeDebt = getAllDebt(SAFE_ENGINE_ADDRESS, urn, urn, _collType);\n\n        if (_raiAmount > wholeDebt) {\n            ERC20(RAI_ADDRESS).transfer(_owner, sub(_raiAmount, wholeDebt));\n            _raiAmount = wholeDebt;\n        }\n\n        if (ERC20(RAI_ADDRESS).allowance(address(this), RAI_JOIN_ADDRESS) == 0) {\n            ERC20(RAI_ADDRESS).approve(RAI_JOIN_ADDRESS, uint(-1));\n        }\n\n        raiJoin.join(urn, _raiAmount);\n\n        int paybackAmnt = _getRepaidDeltaDebt(SAFE_ENGINE_ADDRESS, ISAFEEngine(safeEngine).coinBalance(urn), urn, _collType);\n\n        ISAFEManager(_managerAddr).modifySAFECollateralization(_safeId, 0, paybackAmnt);\n    }\n\n    /// @notice Gets the maximum amount of collateral available to draw\n    /// @param _managerAddr Address of the Safe Manager\n    /// @param _safeId Id of the Safe\n    /// @param _collType Coll type of the Safe\n    /// @param _joinAddr Joind address of collateral\n    /// @dev Substracts 1% to aviod rounding error later on\n    function getMaxCollateral(address _managerAddr, uint _safeId, bytes32 _collType, address _joinAddr) public view returns (uint) {\n        (uint collateral, uint debt) = getSafeInfo(ISAFEManager(_managerAddr), _safeId, _collType);\n\n        (, , uint256 safetyPrice, , , ) =\n            ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);\n\n        uint maxCollateral = sub(collateral, wmul(wdiv(RAY, safetyPrice), debt));\n\n        uint normalizeMaxCollateral = maxCollateral / (10 ** (18 - IBasicTokenAdapters(_joinAddr).decimals()));\n\n        // take one percent due to precision issues\n        return normalizeMaxCollateral * 99 / 100;\n    }\n\n    /// @notice Gets the maximum amount of debt available to generate\n    /// @param _managerAddr Address of the Safe Manager\n    /// @param _safeId Id of the Safe\n    /// @param _collType Coll type of the Safe\n    /// @dev Substracts 10 wei to aviod rounding error later on\n    function getMaxDebt(\n        address _managerAddr,\n        uint256 _safeId,\n        bytes32 _collType\n    ) public view virtual returns (uint256) {\n        (uint256 collateral, uint256 debt) =\n            getSafeInfo(ISAFEManager(_managerAddr), _safeId, _collType);\n\n        (, , uint256 safetyPrice, , , ) =\n            ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);\n\n        return sub(sub(rmul(collateral, safetyPrice), debt), 10);\n    }\n\n    function getPrice(bytes32 _collType) public returns (uint256) {\n        (, uint256 safetyCRatio) =\n            IOracleRelayer(ORACLE_RELAYER_ADDRESS).collateralTypes(_collType);\n        (, , uint256 safetyPrice, , , ) =\n            ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);\n\n        uint256 redemptionPrice = IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionPrice();\n\n        return rmul(rmul(safetyPrice, redemptionPrice), safetyCRatio);\n    }\n\n    function isAutomation() internal view returns(bool) {\n        return BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin);\n    }\n\n    function takeFee(uint256 _gasCost, uint _amount) internal returns(uint) {\n        if (_gasCost > 0) {\n            uint ethRaiPrice = getPrice(ETH_COLL_TYPE);\n            uint feeAmount = rmul(_gasCost, ethRaiPrice);\n\n            if (feeAmount > _amount / 5) {\n                feeAmount = _amount / 5;\n            }\n\n            address walletAddr = _feeRecipient.getFeeAddr();\n\n            ERC20(RAI_ADDRESS).transfer(walletAddr, feeAmount);\n\n            return feeAmount;\n        }\n\n        return 0;\n    }\n}\n"
93     },
94     "contracts/utils/Discount.sol": {
95       "content": "pragma solidity ^0.6.0;\n\n\ncontract Discount {\n    address public owner;\n    mapping(address => CustomServiceFee) public serviceFees;\n\n    uint256 constant MAX_SERVICE_FEE = 400;\n\n    struct CustomServiceFee {\n        bool active;\n        uint256 amount;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function isCustomFeeSet(address _user) public view returns (bool) {\n        return serviceFees[_user].active;\n    }\n\n    function getCustomServiceFee(address _user) public view returns (uint256) {\n        return serviceFees[_user].amount;\n    }\n\n    function setServiceFee(address _user, uint256 _fee) public {\n        require(msg.sender == owner, \"Only owner\");\n        require(_fee >= MAX_SERVICE_FEE || _fee == 0);\n\n        serviceFees[_user] = CustomServiceFee({active: true, amount: _fee});\n    }\n\n    function disableServiceFee(address _user) public {\n        require(msg.sender == owner, \"Only owner\");\n\n        serviceFees[_user] = CustomServiceFee({active: false, amount: 0});\n    }\n}\n"
96     },
97     "contracts/interfaces/reflexer/IOracleRelayer.sol": {
98       "content": "pragma solidity ^0.6.0;\n\nabstract contract IOracleRelayer {\n    struct CollateralType {\n        address orcl;\n        uint256 safetyCRatio;\n    }\n\n    mapping (bytes32 => CollateralType) public collateralTypes;\n\n    function redemptionPrice() public virtual returns (uint256);\n    uint256 public redemptionRate;\n}\n"
99     },
100     "contracts/interfaces/reflexer/ITaxCollector.sol": {
101       "content": "pragma solidity ^0.6.0;\n\nabstract contract ITaxCollector {\n    struct CollateralType {\n        uint256 stabilityFee;\n        uint256 updateTime;\n    }\n\n    mapping (bytes32 => CollateralType) public collateralTypes;\n\n    function taxSingle(bytes32) public virtual returns (uint);\n}\n"
102     },
103     "contracts/interfaces/reflexer/ICoinJoin.sol": {
104       "content": "\npragma solidity ^0.6.0;\n\nabstract contract ICoinJoin {\n    uint256 public decimals;\n\n    function join(address account, uint256 wad) external virtual;\n\n    function exit(address account, uint256 wad) external virtual;\n}\n"
105     },
106     "contracts/reflexer/saver/RAISaverProxyHelper.sol": {
107       "content": "pragma solidity ^0.6.0;\n\nimport \"../../DS/DSMath.sol\";\nimport \"../../DS/DSProxy.sol\";\nimport \"../../interfaces/reflexer/IBasicTokenAdapters.sol\";\nimport \"../../interfaces/reflexer/ISAFEManager.sol\";\nimport \"../../interfaces/reflexer/ISAFEEngine.sol\";\nimport \"../../interfaces/reflexer/ITaxCollector.sol\";\n\n/// @title Helper methods for RAISaverProxy\ncontract RAISaverProxyHelper is DSMath {\n\n    enum ManagerType { RAI }\n\n    /// @notice Returns a normalized debt _amount based on the current rate\n    /// @param _amount Amount of dai to be normalized\n    /// @param _rate Current rate of the stability fee\n    /// @param _daiVatBalance Balance od Dai in the Vat for that Safe\n    function normalizeDrawAmount(uint _amount, uint _rate, uint _daiVatBalance) internal pure returns (int dart) {\n        if (_daiVatBalance < mul(_amount, RAY)) {\n            dart = toPositiveInt(sub(mul(_amount, RAY), _daiVatBalance) / _rate);\n            dart = mul(uint(dart), _rate) < mul(_amount, RAY) ? dart + 1 : dart;\n        }\n    }\n\n    /// @notice Converts a number to Rad percision\n    /// @param _wad The input number in wad percision\n    function toRad(uint _wad) internal pure returns (uint) {\n        return mul(_wad, 10 ** 27);\n    }\n\n    /// @notice Converts a number to 18 decimal percision\n    /// @param _joinAddr Join address of the collateral\n    /// @param _amount Number to be converted\n    function convertTo18(address _joinAddr, uint256 _amount) internal view returns (uint256) {\n        return mul(_amount, 10 ** (18 - IBasicTokenAdapters(_joinAddr).decimals()));\n    }\n\n    /// @notice Converts a uint to int and checks if positive\n    /// @param _x Number to be converted\n    function toPositiveInt(uint _x) internal pure returns (int y) {\n        y = int(_x);\n        require(y >= 0, \"int-overflow\");\n    }\n\n    /// @notice Gets Dai amount in Vat which can be added to Safe\n    /// @param _safeEngine Address of Vat contract\n    /// @param _urn Urn of the Safe\n    /// @param _collType CollType of the Safe\n    function normalizePaybackAmount(address _safeEngine, address _urn, bytes32 _collType) internal view returns (int amount) {\n        uint dai = ISAFEEngine(_safeEngine).coinBalance(_urn);\n\n        (, uint rate,,,,) = ISAFEEngine(_safeEngine).collateralTypes(_collType);\n        (, uint art) = ISAFEEngine(_safeEngine).safes(_collType, _urn);\n\n        amount = toPositiveInt(dai / rate);\n        amount = uint(amount) <= art ? - amount : - toPositiveInt(art);\n    }\n\n    /// @notice Gets delta debt generated (Total Safe debt minus available safeHandler COIN balance)\n    /// @param safeEngine address\n    /// @param taxCollector address\n    /// @param safeHandler address\n    /// @param collateralType bytes32\n    /// @return deltaDebt\n    function _getGeneratedDeltaDebt(\n        address safeEngine,\n        address taxCollector,\n        address safeHandler,\n        bytes32 collateralType,\n        uint wad\n    ) internal returns (int deltaDebt) {\n        // Updates stability fee rate\n        uint rate = ITaxCollector(taxCollector).taxSingle(collateralType);\n        require(rate > 0, \"invalid-collateral-type\");\n\n        // Gets COIN balance of the handler in the safeEngine\n        uint coin = ISAFEEngine(safeEngine).coinBalance(safeHandler);\n\n        // If there was already enough COIN in the safeEngine balance, just exits it without adding more debt\n        if (coin < mul(wad, RAY)) {\n            // Calculates the needed deltaDebt so together with the existing coins in the safeEngine is enough to exit wad amount of COIN tokens\n            deltaDebt = toPositiveInt(sub(mul(wad, RAY), coin) / rate);\n            // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given COIN wad amount)\n            deltaDebt = mul(uint(deltaDebt), rate) < mul(wad, RAY) ? deltaDebt + 1 : deltaDebt;\n        }\n    }\n\n    function _getRepaidDeltaDebt(\n        address safeEngine,\n        uint coin,\n        address safe,\n        bytes32 collateralType\n    ) internal view returns (int deltaDebt) {\n        // Gets actual rate from the safeEngine\n        (, uint rate,,,,) = ISAFEEngine(safeEngine).collateralTypes(collateralType);\n        require(rate > 0, \"invalid-collateral-type\");\n\n        // Gets actual generatedDebt value of the safe\n        (, uint generatedDebt) = ISAFEEngine(safeEngine).safes(collateralType, safe);\n\n        // Uses the whole coin balance in the safeEngine to reduce the debt\n        deltaDebt = toPositiveInt(coin / rate);\n        // Checks the calculated deltaDebt is not higher than safe.generatedDebt (total debt), otherwise uses its value\n        deltaDebt = uint(deltaDebt) <= generatedDebt ? - deltaDebt : - toPositiveInt(generatedDebt);\n    }\n\n    /// @notice Gets the whole debt of the Safe\n    /// @param _safeEngine Address of Vat contract\n    /// @param _usr Address of the Dai holder\n    /// @param _urn Urn of the Safe\n    /// @param _collType CollType of the Safe\n    function getAllDebt(address _safeEngine, address _usr, address _urn, bytes32 _collType) internal view returns (uint daiAmount) {\n        (, uint rate,,,,) = ISAFEEngine(_safeEngine).collateralTypes(_collType);\n        (, uint art) = ISAFEEngine(_safeEngine).safes(_collType, _urn);\n        uint dai = ISAFEEngine(_safeEngine).coinBalance(_usr);\n\n        uint rad = sub(mul(art, rate), dai);\n        daiAmount = rad / RAY;\n\n        daiAmount = mul(daiAmount, RAY) < rad ? daiAmount + 1 : daiAmount;\n    }\n\n    /// @notice Gets the token address from the Join contract\n    /// @param _joinAddr Address of the Join contract\n    function getCollateralAddr(address _joinAddr) internal view returns (address) {\n        return address(IBasicTokenAdapters(_joinAddr).collateral());\n    }\n\n    /// @notice Checks if the join address is one of the Ether coll. types\n    /// @param _joinAddr Join address to check\n    function isEthJoinAddr(address _joinAddr) internal view returns (bool) {\n        // if it's dai_join_addr don't check gem() it will fail\n        if (_joinAddr == 0x0A5653CCa4DB1B6E265F47CAf6969e64f1CFdC45) return false;\n\n        // if coll is weth it's and eth type coll\n        if (address(IBasicTokenAdapters(_joinAddr).collateral()) == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /// @notice Gets Safe info (collateral, debt)\n    /// @param _manager Manager contract\n    /// @param _safeId Id of the Safe\n    /// @param _collType CollType of the Safe\n    function getSafeInfo(ISAFEManager _manager, uint _safeId, bytes32 _collType) public view returns (uint, uint) {\n        address vat = _manager.safeEngine();\n        address urn = _manager.safes(_safeId);\n\n        (uint collateral, uint debt) = ISAFEEngine(vat).safes(_collType, urn);\n        (,uint rate,,,,) = ISAFEEngine(vat).collateralTypes(_collType);\n\n        return (collateral, rmul(debt, rate));\n    }\n\n    /// @notice Address that owns the DSProxy that owns the Safe\n    /// @param _manager Manager contract\n    /// @param _safeId Id of the Safe\n    function getOwner(ISAFEManager _manager, uint _safeId) public view returns (address) {\n        DSProxy proxy = DSProxy(uint160(_manager.ownsSAFE(_safeId)));\n\n        return proxy.owner();\n    }\n\n    /// @notice Based on the manager type returns the address\n    /// @param _managerType Type of vault manager to use\n    function getManagerAddr(ManagerType _managerType) public pure returns (address) {\n        if (_managerType == ManagerType.RAI) {\n            return 0xEfe0B4cA532769a3AE758fD82E1426a03A94F185;\n        }\n    }\n}\n"
108     },
109     "contracts/utils/BotRegistry.sol": {
110       "content": "pragma solidity ^0.6.0;\n\nimport \"../auth/AdminAuth.sol\";\n\ncontract BotRegistry is AdminAuth {\n\n    mapping (address => bool) public botList;\n\n    constructor() public {\n        botList[0x776B4a13093e30B05781F97F6A4565B6aa8BE330] = true;\n\n        botList[0xAED662abcC4FA3314985E67Ea993CAD064a7F5cF] = true;\n        botList[0xa5d330F6619d6bF892A5B87D80272e1607b3e34D] = true;\n        botList[0x5feB4DeE5150B589a7f567EA7CADa2759794A90A] = true;\n        botList[0x7ca06417c1d6f480d3bB195B80692F95A6B66158] = true;\n    }\n\n    function setBot(address _botAddr, bool _state) public onlyOwner {\n        botList[_botAddr] = _state;\n    }\n\n}\n"
111     },
112     "contracts/exchangeV3/DFSExchangeCore.sol": {
113       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../DS/DSMath.sol\";\nimport \"../interfaces/TokenInterface.sol\";\nimport \"../interfaces/ExchangeInterfaceV3.sol\";\nimport \"../utils/ZrxAllowlist.sol\";\nimport \"./DFSExchangeData.sol\";\nimport \"./DFSExchangeHelper.sol\";\nimport \"../exchange/SaverExchangeRegistry.sol\";\nimport \"../interfaces/OffchainWrapperInterface.sol\";\n\ncontract DFSExchangeCore is DFSExchangeHelper, DSMath, DFSExchangeData {\n\n    string public constant ERR_SLIPPAGE_HIT = \"Slippage hit\";\n    string public constant ERR_DEST_AMOUNT_MISSING = \"Dest amount missing\";\n    string public constant ERR_WRAPPER_INVALID = \"Wrapper invalid\";\n    string public constant ERR_NOT_ZEROX_EXCHANGE = \"Zerox exchange invalid\";\n\n    /// @notice Internal method that preforms a sell on 0x/on-chain\n    /// @dev Usefull for other DFS contract to integrate for exchanging\n    /// @param exData Exchange data struct\n    /// @return (address, uint) Address of the wrapper used and destAmount\n    function _sell(ExchangeData memory exData) internal returns (address, uint) {\n\n        address wrapper;\n        uint swapedTokens;\n        bool success;\n\n        // if selling eth, convert to weth\n        if (exData.srcAddr == KYBER_ETH_ADDRESS) {\n            exData.srcAddr = ethToWethAddr(exData.srcAddr);\n            TokenInterface(EXCHANGE_WETH_ADDRESS).deposit{value: exData.srcAmount}();\n        }\n\n        exData.srcAmount -= getFee(exData.srcAmount, exData.user, exData.srcAddr, exData.dfsFeeDivider);\n\n        // Try 0x first and then fallback on specific wrapper\n        if (exData.offchainData.price > 0) {\n            (success, swapedTokens) = takeOrder(exData, ActionType.SELL);\n\n            if (success) {\n                wrapper = exData.offchainData.exchangeAddr;\n            }\n        }\n\n        // fallback to desired wrapper if 0x failed\n        if (!success) {\n            swapedTokens = saverSwap(exData, ActionType.SELL);\n            wrapper = exData.wrapper;\n        }\n\n        // if anything is left in weth, pull it to user as eth\n        if (getBalance(EXCHANGE_WETH_ADDRESS) > 0) {\n            TokenInterface(EXCHANGE_WETH_ADDRESS).withdraw(\n                TokenInterface(EXCHANGE_WETH_ADDRESS).balanceOf(address(this))\n            );\n        }\n\n        if (exData.destAddr == EXCHANGE_WETH_ADDRESS) {\n            require(getBalance(KYBER_ETH_ADDRESS) >= wmul(exData.minPrice, exData.srcAmount), ERR_SLIPPAGE_HIT);\n        } else {\n            require(getBalance(exData.destAddr) >= wmul(exData.minPrice, exData.srcAmount), ERR_SLIPPAGE_HIT);\n        }\n\n        return (wrapper, swapedTokens);\n    }\n\n    /// @notice Internal method that preforms a buy on 0x/on-chain\n    /// @dev Usefull for other DFS contract to integrate for exchanging\n    /// @param exData Exchange data struct\n    /// @return (address, uint) Address of the wrapper used and srcAmount\n    function _buy(ExchangeData memory exData) internal returns (address, uint) {\n\n        address wrapper;\n        uint swapedTokens;\n        bool success;\n\n        require(exData.destAmount != 0, ERR_DEST_AMOUNT_MISSING);\n\n        exData.srcAmount -= getFee(exData.srcAmount, exData.user, exData.srcAddr, exData.dfsFeeDivider);\n\n        // if selling eth, convert to weth\n        if (exData.srcAddr == KYBER_ETH_ADDRESS) {\n            exData.srcAddr = ethToWethAddr(exData.srcAddr);\n            TokenInterface(EXCHANGE_WETH_ADDRESS).deposit{value: exData.srcAmount}();\n        }\n\n        if (exData.offchainData.price > 0) {\n            (success, swapedTokens) = takeOrder(exData, ActionType.BUY);\n\n            if (success) {\n                wrapper = exData.offchainData.exchangeAddr;\n            }\n        }\n\n        // fallback to desired wrapper if 0x failed\n        if (!success) {\n            swapedTokens = saverSwap(exData, ActionType.BUY);\n            wrapper = exData.wrapper;\n        }\n\n        // if anything is left in weth, pull it to user as eth\n        if (getBalance(EXCHANGE_WETH_ADDRESS) > 0) {\n            TokenInterface(EXCHANGE_WETH_ADDRESS).withdraw(\n                TokenInterface(EXCHANGE_WETH_ADDRESS).balanceOf(address(this))\n            );\n        }\n\n        if (exData.destAddr == EXCHANGE_WETH_ADDRESS) {\n            require(getBalance(KYBER_ETH_ADDRESS) >= exData.destAmount, ERR_SLIPPAGE_HIT);\n        } else {\n            require(getBalance(exData.destAddr) >= exData.destAmount, ERR_SLIPPAGE_HIT);\n        }\n\n        return (wrapper, getBalance(exData.destAddr));\n    }\n\n    /// @notice Takes order from 0x and returns bool indicating if it is successful\n    /// @param _exData Exchange data\n    function takeOrder(\n        ExchangeData memory _exData,\n        ActionType _type\n    ) private returns (bool success, uint256) {\n        if (!ZrxAllowlist(ZRX_ALLOWLIST_ADDR).isZrxAddr(_exData.offchainData.exchangeAddr)) {\n            return (false, 0);\n        }\n\n        if (!SaverExchangeRegistry(SAVER_EXCHANGE_REGISTRY).isWrapper(_exData.offchainData.wrapper)) {\n            return (false, 0);\n        }\n\n        // send src amount\n        ERC20(_exData.srcAddr).safeTransfer(_exData.offchainData.wrapper, _exData.srcAmount);\n\n        return OffchainWrapperInterface(_exData.offchainData.wrapper).takeOrder{value: _exData.offchainData.protocolFee}(_exData, _type);\n    }\n\n    /// @notice Calls wraper contract for exchage to preform an on-chain swap\n    /// @param _exData Exchange data struct\n    /// @param _type Type of action SELL|BUY\n    /// @return swapedTokens For Sell that the destAmount, for Buy thats the srcAmount\n    function saverSwap(ExchangeData memory _exData, ActionType _type) internal returns (uint swapedTokens) {\n        require(SaverExchangeRegistry(SAVER_EXCHANGE_REGISTRY).isWrapper(_exData.wrapper), ERR_WRAPPER_INVALID);\n\n        ERC20(_exData.srcAddr).safeTransfer(_exData.wrapper, _exData.srcAmount);\n\n        if (_type == ActionType.SELL) {\n            swapedTokens = ExchangeInterfaceV3(_exData.wrapper).\n                    sell(_exData.srcAddr, _exData.destAddr, _exData.srcAmount, _exData.wrapperData);\n        } else {\n            swapedTokens = ExchangeInterfaceV3(_exData.wrapper).\n                    buy(_exData.srcAddr, _exData.destAddr, _exData.destAmount, _exData.wrapperData);\n        }\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external virtual payable {}\n}\n"
114     },
115     "contracts/DS/DSMath.sol": {
116       "content": "pragma solidity ^0.6.0;\n\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n"
117     },
118     "contracts/DS/DSProxy.sol": {
119       "content": "pragma solidity ^0.6.0;\n\nimport \"./DSAuth.sol\";\nimport \"./DSNote.sol\";\n\n\nabstract contract DSProxy is DSAuth, DSNote {\n    DSProxyCache public cache; // global cache for contracts\n\n    constructor(address _cacheAddr) public {\n        require(setCache(_cacheAddr));\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    // use the proxy to execute calldata _data on contract _code\n    // function execute(bytes memory _code, bytes memory _data)\n    //     public\n    //     payable\n    //     virtual\n    //     returns (address target, bytes32 response);\n\n    function execute(address _target, bytes memory _data)\n        public\n        payable\n        virtual\n        returns (bytes32 response);\n\n    //set new cache\n    function setCache(address _cacheAddr) public virtual payable returns (bool);\n}\n\n\ncontract DSProxyCache {\n    mapping(bytes32 => address) cache;\n\n    function read(bytes memory _code) public view returns (address) {\n        bytes32 hash = keccak256(_code);\n        return cache[hash];\n    }\n\n    function write(bytes memory _code) public returns (address target) {\n        assembly {\n            target := create(0, add(_code, 0x20), mload(_code))\n            switch iszero(extcodesize(target))\n                case 1 {\n                    // throw if contract failed to deploy\n                    revert(0, 0)\n                }\n        }\n        bytes32 hash = keccak256(_code);\n        cache[hash] = target;\n    }\n}\n"
120     },
121     "contracts/interfaces/reflexer/IBasicTokenAdapters.sol": {
122       "content": "pragma solidity ^0.6.0;\n\nabstract contract IBasicTokenAdapters {\n    bytes32 public collateralType;\n\n    function decimals() virtual public view returns (uint);\n    function collateral() virtual public view returns (address);\n    function join(address, uint) virtual public payable;\n    function exit(address, uint) virtual public;\n}\n"
123     },
124     "contracts/interfaces/reflexer/ISAFEManager.sol": {
125       "content": "pragma solidity ^0.6.0;\n\nabstract contract ISAFEManager {\n\n    function lastSAFEID(address) virtual public returns (uint);\n    function safeCan(address, uint, address) virtual public view returns (uint);\n    function collateralTypes(uint) virtual public view returns (bytes32);\n    function ownsSAFE(uint) virtual public view returns (address);\n    function safes(uint) virtual public view returns (address);\n    function safeEngine() virtual public view returns (address);\n    function openSAFE(bytes32, address) virtual public returns (uint);\n    function transferSAFEOwnership(uint, address) virtual public;\n    function allowSAFE(uint, address, uint) virtual public;\n    function handlerAllowed(address, uint) virtual public;\n    function modifySAFECollateralization(uint, int, int) virtual public;\n    function transferCollateral(uint, address, uint) virtual public;\n    function transferInternalCoins(uint, address, uint) virtual public;\n    function quitSystem(uint, address) virtual public;\n    function enterSystem(address, uint) virtual public;\n    function moveSAFE(uint, uint) virtual public;\n}\n"
126     },
127     "contracts/interfaces/reflexer/ISAFEEngine.sol": {
128       "content": "pragma solidity ^0.6.0;\n\nabstract contract ISAFEEngine {\n\n    struct SAFE {\n        uint256 lockedCollateral;\n        uint256 generatedDebt;\n    }\n\n    struct CollateralType {\n        // Total debt issued for this specific collateral type\n        uint256 debtAmount;        // [wad]\n        // Accumulator for interest accrued on this collateral type\n        uint256 accumulatedRate;   // [ray]\n        // Floor price at which a SAFE is allowed to generate debt\n        uint256 safetyPrice;       // [ray]\n        // Maximum amount of debt that can be generated with this collateral type\n        uint256 debtCeiling;       // [rad]\n        // Minimum amount of debt that must be generated by a SAFE using this collateral\n        uint256 debtFloor;         // [rad]\n        // Price at which a SAFE gets liquidated\n        uint256 liquidationPrice;  // [ray]\n    }\n\n    mapping (bytes32 => mapping (address => SAFE )) public safes;\n    mapping (bytes32 => CollateralType) public collateralTypes;\n    mapping (bytes32 => mapping (address => uint)) public tokenCollateral;\n\n    function safeRights(address, address) virtual public view returns (uint);\n    function coinBalance(address) virtual public view returns (uint);\n    function modifySAFECollateralization(bytes32, address, address, address, int, int) virtual public;\n    function approveSAFEModification(address) virtual public;\n    function transferInternalCoins(address, address, uint) virtual public;\n    function transferSAFECollateralAndDebt(bytes32, address, address, int, int) virtual public;\n}\n"
129     },
130     "contracts/DS/DSNote.sol": {
131       "content": "pragma solidity ^0.6.0;\n\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 indexed bar,\n        uint256 wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n"
132     },
133     "contracts/interfaces/TokenInterface.sol": {
134       "content": "pragma solidity ^0.6.0;\n\nabstract contract TokenInterface {\n\taddress public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    \n    function allowance(address, address) public virtual returns (uint256);\n\n    function balanceOf(address) public virtual returns (uint256);\n\n    function approve(address, uint256) public virtual;\n\n    function transfer(address, uint256) public virtual returns (bool);\n\n    function transferFrom(address, address, uint256) public virtual returns (bool);\n\n    function deposit() public virtual payable;\n\n    function withdraw(uint256) public virtual;\n}\n"
135     },
136     "contracts/interfaces/ExchangeInterfaceV3.sol": {
137       "content": "pragma solidity ^0.6.0;\n\ninterface ExchangeInterfaceV3 {\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) external payable returns (uint);\n\n    function buy(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) external payable returns(uint);\n\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) external view returns (uint);\n\n    function getBuyRate(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) external view returns (uint);\n}\n"
138     },
139     "contracts/utils/ZrxAllowlist.sol": {
140       "content": "pragma solidity ^0.6.0;\n\nimport \"../auth/AdminAuth.sol\";\n\ncontract ZrxAllowlist is AdminAuth {\n\n    mapping (address => bool) public zrxAllowlist;\n    mapping(address => bool) private nonPayableAddrs;\n\n    constructor() public {\n        zrxAllowlist[0x6958F5e95332D93D21af0D7B9Ca85B8212fEE0A5] = true;\n        zrxAllowlist[0x61935CbDd02287B511119DDb11Aeb42F1593b7Ef] = true;\n        zrxAllowlist[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;\n        zrxAllowlist[0x080bf510FCbF18b91105470639e9561022937712] = true;\n\n        nonPayableAddrs[0x080bf510FCbF18b91105470639e9561022937712] = true;\n    }\n\n    function setAllowlistAddr(address _zrxAddr, bool _state) public onlyOwner {\n        zrxAllowlist[_zrxAddr] = _state;\n    }\n\n    function isZrxAddr(address _zrxAddr) public view returns (bool) {\n        return zrxAllowlist[_zrxAddr];\n    }\n\n    function addNonPayableAddr(address _nonPayableAddr) public onlyOwner {\n\t\tnonPayableAddrs[_nonPayableAddr] = true;\n\t}\n\n\tfunction removeNonPayableAddr(address _nonPayableAddr) public onlyOwner {\n\t\tnonPayableAddrs[_nonPayableAddr] = false;\n\t}\n\n\tfunction isNonPayableAddr(address _addr) public view returns(bool) {\n\t\treturn nonPayableAddrs[_addr];\n\t}\n}\n"
141     },
142     "contracts/exchangeV3/DFSExchangeHelper.sol": {
143       "content": "pragma solidity ^0.6.0;\n\nimport \"../utils/SafeERC20.sol\";\nimport \"../utils/Discount.sol\";\nimport \"../interfaces/IFeeRecipient.sol\";\n\ncontract DFSExchangeHelper {\n\n    string public constant ERR_OFFCHAIN_DATA_INVALID = \"Offchain data invalid\";\n\n    using SafeERC20 for ERC20;\n\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant EXCHANGE_WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    IFeeRecipient public constant _feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);\n\n    address public constant DISCOUNT_ADDRESS = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n    address public constant SAVER_EXCHANGE_REGISTRY = 0x25dd3F51e0C3c3Ff164DDC02A8E4D65Bb9cBB12D;\n\n    address public constant ZRX_ALLOWLIST_ADDR = 0x4BA1f38427b33B8ab7Bb0490200dAE1F1C36823F;\n\n\n    function getDecimals(address _token) internal view returns (uint256) {\n        if (_token == KYBER_ETH_ADDRESS) return 18;\n\n        return ERC20(_token).decimals();\n    }\n\n    function getBalance(address _tokenAddr) internal view returns (uint balance) {\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\n            balance = address(this).balance;\n        } else {\n            balance = ERC20(_tokenAddr).balanceOf(address(this));\n        }\n    }\n\n    function sendLeftover(address _srcAddr, address _destAddr, address payable _to) internal {\n        // send back any leftover ether or tokens\n        if (address(this).balance > 0) {\n            _to.transfer(address(this).balance);\n        }\n\n        if (getBalance(_srcAddr) > 0) {\n            ERC20(_srcAddr).safeTransfer(_to, getBalance(_srcAddr));\n        }\n\n        if (getBalance(_destAddr) > 0) {\n            ERC20(_destAddr).safeTransfer(_to, getBalance(_destAddr));\n        }\n    }\n\n    /// @notice Takes a feePercentage and sends it to wallet\n    /// @param _amount Dai amount of the whole trade\n    /// @param _user Address of the user\n    /// @param _token Address of the token\n    /// @param _dfsFeeDivider Dfs fee divider\n    /// @return feeAmount Amount in Dai owner earned on the fee\n    function getFee(uint256 _amount, address _user, address _token, uint256 _dfsFeeDivider) internal returns (uint256 feeAmount) {\n        if (_dfsFeeDivider != 0 && Discount(DISCOUNT_ADDRESS).isCustomFeeSet(_user)) {\n            _dfsFeeDivider = Discount(DISCOUNT_ADDRESS).getCustomServiceFee(_user);\n        }\n\n        if (_dfsFeeDivider == 0) {\n            feeAmount = 0;\n        } else {\n            feeAmount = _amount / _dfsFeeDivider;\n\n            // fee can't go over 10% of the whole amount\n            if (feeAmount > (_amount / 10)) {\n                feeAmount = _amount / 10;\n            }\n\n            address walletAddr = _feeRecipient.getFeeAddr();\n\n            if (_token == KYBER_ETH_ADDRESS) {\n                payable(walletAddr).transfer(feeAmount);\n            } else {\n                ERC20(_token).safeTransfer(walletAddr, feeAmount);\n            }\n        }\n    }\n\n    function sliceUint(bytes memory bs, uint256 start) internal pure returns (uint256) {\n        require(bs.length >= start + 32, \"slicing out of range\");\n\n        uint256 x;\n        assembly {\n            x := mload(add(bs, add(0x20, start)))\n        }\n\n        return x;\n    }\n\n        function writeUint256(bytes memory _b, uint256 _index, uint _input) internal pure {\n        if (_b.length < _index + 32) {\n            revert(ERR_OFFCHAIN_DATA_INVALID);\n        }\n\n        bytes32 input = bytes32(_input);\n\n        _index += 32;\n\n        // Read the bytes32 from array memory\n        assembly {\n            mstore(add(_b, _index), input)\n        }\n    }\n\n    /// @notice Converts Kybers Eth address -> Weth\n    /// @param _src Input address\n    function ethToWethAddr(address _src) internal pure returns (address) {\n        return _src == KYBER_ETH_ADDRESS ? EXCHANGE_WETH_ADDRESS : _src;\n    }\n}\n"
144     },
145     "contracts/exchange/SaverExchangeRegistry.sol": {
146       "content": "pragma solidity ^0.6.0;\n\nimport \"../auth/AdminAuth.sol\";\n\ncontract SaverExchangeRegistry is AdminAuth {\n\n\tmapping(address => bool) private wrappers;\n\n\tconstructor() public {\n\t\twrappers[0x880A845A85F843a5c67DB2061623c6Fc3bB4c511] = true;\n\t\twrappers[0x4c9B55f2083629A1F7aDa257ae984E03096eCD25] = true;\n\t\twrappers[0x42A9237b872368E1bec4Ca8D26A928D7d39d338C] = true;\n\t}\n\n\tfunction addWrapper(address _wrapper) public onlyOwner {\n\t\twrappers[_wrapper] = true;\n\t}\n\n\tfunction removeWrapper(address _wrapper) public onlyOwner {\n\t\twrappers[_wrapper] = false;\n\t}\n\n\tfunction isWrapper(address _wrapper) public view returns(bool) {\n\t\treturn wrappers[_wrapper];\n\t}\n}\n"
147     },
148     "contracts/interfaces/OffchainWrapperInterface.sol": {
149       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../exchangeV3/DFSExchangeData.sol\";\n\nabstract contract OffchainWrapperInterface is DFSExchangeData {\n    function takeOrder(\n        ExchangeData memory _exData,\n        ActionType _type\n    ) virtual public payable returns (bool success, uint256);\n}\n"
150     },
151     "contracts/interfaces/IFeeRecipient.sol": {
152       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nabstract contract IFeeRecipient {\n    function getFeeAddr() public view virtual returns (address);\n    function changeWalletAddr(address _newWallet) public virtual;\n}\n"
153     },
154     "contracts/shifter/LoanShifterReceiver.sol": {
155       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../auth/AdminAuth.sol\";\nimport \"../utils/FlashLoanReceiverBase.sol\";\nimport \"../interfaces/DSProxyInterface.sol\";\nimport \"../exchangeV3/DFSExchangeCore.sol\";\nimport \"./ShifterRegistry.sol\";\nimport \"./LoanShifterTaker.sol\";\n\n/// @title LoanShifterReceiver Recevies the Aave flash loan and calls actions through users DSProxy\ncontract LoanShifterReceiver is DFSExchangeCore, FlashLoanReceiverBase, AdminAuth {\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER =\n        ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    uint public constant SERVICE_FEE = 400; // 0.25% Fee\n\n    ShifterRegistry public constant shifterRegistry =\n        ShifterRegistry(0x597C52281b31B9d949a9D8fEbA08F7A2530a965e);\n\n    struct ParamData {\n        bytes proxyData1;\n        bytes proxyData2;\n        address proxy;\n        address debtAddr;\n        uint8 protocol1;\n        uint8 protocol2;\n        uint8 swapType;\n    }\n\n    constructor() public FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER) {}\n\n    function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params\n    ) external override {\n        // Format the call data for DSProxy\n        (ParamData memory paramData, ExchangeData memory exchangeData) =\n            packFunctionCall(_amount, _fee, _params);\n\n        address protocolAddr1 = shifterRegistry.getAddr(getNameByProtocol(paramData.protocol1));\n        address protocolAddr2 = shifterRegistry.getAddr(getNameByProtocol(paramData.protocol2));\n\n        // Send Flash loan amount to DSProxy\n        sendTokenToProxy(payable(paramData.proxy), _reserve, _amount);\n\n        // Execute the Close/Change debt operation\n        DSProxyInterface(paramData.proxy).execute(protocolAddr1, paramData.proxyData1);\n\n        exchangeData.dfsFeeDivider = SERVICE_FEE;\n        exchangeData.user = DSProxyInterface(paramData.proxy).owner();\n\n        if (paramData.swapType == 1) {\n            uint256 amount = exchangeData.srcAmount;\n\n            if (exchangeData.srcAddr != exchangeData.destAddr) {\n                // COLL_SWAP\n                (, amount) = _sell(exchangeData);\n            }\n\n            sendTokenAndEthToProxy(payable(paramData.proxy), exchangeData.destAddr, amount);\n        } else if (paramData.swapType == 2) {\n            // DEBT_SWAP\n\n            if (exchangeData.srcAddr != exchangeData.destAddr) {\n                exchangeData.destAmount = (_amount + _fee);\n                _buy(exchangeData);\n\n                // Send extra to DSProxy\n                sendTokenToProxy(\n                    payable(paramData.proxy),\n                    exchangeData.srcAddr,\n                    ERC20(exchangeData.srcAddr).balanceOf(address(this))\n                );\n            }\n        } else {\n            // NO_SWAP just send tokens to proxy\n            sendTokenAndEthToProxy(\n                payable(paramData.proxy),\n                exchangeData.srcAddr,\n                getBalance(exchangeData.srcAddr)\n            );\n        }\n\n        // Execute the Open operation\n        DSProxyInterface(paramData.proxy).execute(protocolAddr2, paramData.proxyData2);\n\n        // Repay FL\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }\n\n    function packFunctionCall(\n        uint256 _amount,\n        uint256 _fee,\n        bytes memory _params\n    )\n        internal\n        pure\n        returns (ParamData memory paramData, ExchangeData memory exchangeData)\n    {\n\n        LoanShifterTaker.LoanShiftData memory shiftData;\n        address proxy;\n\n        (shiftData, exchangeData, proxy) = abi.decode(\n            _params,\n            (LoanShifterTaker.LoanShiftData, ExchangeData, address)\n        );\n\n        bytes memory proxyData1;\n        bytes memory proxyData2;\n        uint256 openDebtAmount = (_amount + _fee);\n\n        if (shiftData.fromProtocol == LoanShifterTaker.Protocols.MCD) {\n            // MAKER FROM\n            proxyData1 = abi.encodeWithSignature(\n                \"close(uint256,address,uint256,uint256)\",\n                shiftData.id1,\n                shiftData.addrLoan1,\n                _amount,\n                shiftData.collAmount\n            );\n        } else if (shiftData.fromProtocol == LoanShifterTaker.Protocols.COMPOUND) {\n            // COMPOUND FROM\n            if (shiftData.swapType == LoanShifterTaker.SwapType.DEBT_SWAP) {\n                // DEBT_SWAP\n                proxyData1 = abi.encodeWithSignature(\n                    \"changeDebt(address,address,uint256,uint256)\",\n                    shiftData.debtAddr1,\n                    shiftData.debtAddr2,\n                    _amount,\n                    exchangeData.srcAmount\n                );\n            } else {\n                proxyData1 = abi.encodeWithSignature(\n                    \"close(address,address,uint256,uint256)\",\n                    shiftData.addrLoan1,\n                    shiftData.debtAddr1,\n                    shiftData.collAmount,\n                    shiftData.debtAmount\n                );\n            }\n        }\n\n        if (shiftData.toProtocol == LoanShifterTaker.Protocols.MCD) {\n            // MAKER TO\n            proxyData2 = abi.encodeWithSignature(\n                \"open(uint256,address,uint256)\",\n                shiftData.id2,\n                shiftData.addrLoan2,\n                openDebtAmount\n            );\n        } else if (shiftData.toProtocol == LoanShifterTaker.Protocols.COMPOUND) {\n            // COMPOUND TO\n            if (shiftData.swapType == LoanShifterTaker.SwapType.DEBT_SWAP) {\n                // DEBT_SWAP\n                proxyData2 = abi.encodeWithSignature(\"repayAll(address)\", shiftData.debtAddr2);\n            } else {\n                proxyData2 = abi.encodeWithSignature(\n                    \"open(address,address,uint256)\",\n                    shiftData.addrLoan2,\n                    shiftData.debtAddr2,\n                    openDebtAmount\n                );\n            }\n        }\n\n        paramData = ParamData({\n            proxyData1: proxyData1,\n            proxyData2: proxyData2,\n            proxy: proxy,\n            debtAddr: shiftData.debtAddr1,\n            protocol1: uint8(shiftData.fromProtocol),\n            protocol2: uint8(shiftData.toProtocol),\n            swapType: uint8(shiftData.swapType)\n        });\n    }\n\n    function sendTokenAndEthToProxy(\n        address payable _proxy,\n        address _reserve,\n        uint256 _amount\n    ) internal {\n        if (_reserve != ETH_ADDRESS) {\n            ERC20(_reserve).safeTransfer(_proxy, _amount);\n        }\n\n        _proxy.transfer(address(this).balance);\n    }\n\n    function sendTokenToProxy(\n        address payable _proxy,\n        address _reserve,\n        uint256 _amount\n    ) internal {\n        if (_reserve != ETH_ADDRESS) {\n            ERC20(_reserve).safeTransfer(_proxy, _amount);\n        } else {\n            _proxy.transfer(address(this).balance);\n        }\n    }\n\n    function getNameByProtocol(uint8 _proto) internal pure returns (string memory) {\n        if (_proto == 0) {\n            return \"MCD_SHIFTER\";\n        } else if (_proto == 1) {\n            return \"COMP_SHIFTER\";\n        }\n    }\n\n    receive() external payable override(FlashLoanReceiverBase, DFSExchangeCore) {}\n}\n"
156     },
157     "contracts/utils/FlashLoanReceiverBase.sol": {
158       "content": "pragma solidity ^0.6.0;\n\nimport \"./SafeERC20.sol\";\n\ninterface IFlashLoanReceiver {\n    function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external;\n}\n\nabstract contract ILendingPoolAddressesProvider {\n\n    function getLendingPool() public view virtual returns (address);\n    function setLendingPoolImpl(address _pool) public virtual;\n\n    function getLendingPoolCore() public virtual view returns (address payable);\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public virtual;\n\n    function getLendingPoolConfigurator() public virtual view returns (address);\n    function setLendingPoolConfiguratorImpl(address _configurator) public virtual;\n\n    function getLendingPoolDataProvider() public virtual view returns (address);\n    function setLendingPoolDataProviderImpl(address _provider) public virtual;\n\n    function getLendingPoolParametersProvider() public virtual view returns (address);\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public virtual;\n\n    function getTokenDistributor() public virtual view returns (address);\n    function setTokenDistributor(address _tokenDistributor) public virtual;\n\n\n    function getFeeProvider() public virtual view returns (address);\n    function setFeeProviderImpl(address _feeProvider) public virtual;\n\n    function getLendingPoolLiquidationManager() public virtual view returns (address);\n    function setLendingPoolLiquidationManager(address _manager) public virtual;\n\n    function getLendingPoolManager() public virtual view returns (address);\n    function setLendingPoolManager(address _lendingPoolManager) public virtual;\n\n    function getPriceOracle() public virtual view returns (address);\n    function setPriceOracle(address _priceOracle) public virtual;\n\n    function getLendingRateOracle() public view virtual returns (address);\n    function setLendingRateOracle(address _lendingRateOracle) public virtual;\n}\n\nlibrary EthAddressLib {\n\n    function ethAddress() internal pure returns(address) {\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    }\n}\n\nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver {\n\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n\n    ILendingPoolAddressesProvider public addressesProvider;\n\n    constructor(ILendingPoolAddressesProvider _provider) public {\n        addressesProvider = _provider;\n    }\n\n    receive () external virtual payable {}\n\n    function transferFundsBackToPoolInternal(address _reserve, uint256 _amount) internal {\n\n        address payable core = addressesProvider.getLendingPoolCore();\n\n        transferInternal(core,_reserve, _amount);\n    }\n\n    function transferInternal(address payable _destination, address _reserve, uint256  _amount) internal {\n        if(_reserve == EthAddressLib.ethAddress()) {\n            //solium-disable-next-line\n            _destination.call{value: _amount}(\"\");\n            return;\n        }\n\n        ERC20(_reserve).safeTransfer(_destination, _amount);\n\n\n    }\n\n    function getBalanceInternal(address _target, address _reserve) internal view returns(uint256) {\n        if(_reserve == EthAddressLib.ethAddress()) {\n\n            return _target.balance;\n        }\n\n        return ERC20(_reserve).balanceOf(_target);\n\n    }\n}\n"
159     },
160     "contracts/compound/create/CompoundCreateReceiver.sol": {
161       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../DS/DSProxy.sol\";\nimport \"../../utils/FlashLoanReceiverBase.sol\";\nimport \"../../interfaces/DSProxyInterface.sol\";\nimport \"../../exchangeV3/DFSExchangeCore.sol\";\nimport \"../../shifter/ShifterRegistry.sol\";\nimport \"./CompoundCreateTaker.sol\";\n\n/// @title Contract that receives the FL from Aave for Creating loans\ncontract CompoundCreateReceiver is FlashLoanReceiverBase, DFSExchangeCore {\n\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n    ShifterRegistry public constant shifterRegistry = ShifterRegistry(0x597C52281b31B9d949a9D8fEbA08F7A2530a965e);\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    uint public constant SERVICE_FEE = 400; // 0.25% Fee\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor() public FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER) {}\n\n    struct CompCreateData {\n        address payable proxyAddr;\n        bytes proxyData;\n        address cCollAddr;\n        address cDebtAddr;\n    }\n\n    /// @notice Called by Aave when sending back the FL amount\n    /// @param _reserve The address of the borrowed token\n    /// @param _amount Amount of FL tokens received\n    /// @param _fee FL Aave fee\n    /// @param _params The params that are sent from the original FL caller contract\n   function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n        // Format the call data for DSProxy\n        (CompCreateData memory compCreate, ExchangeData memory exchangeData)\n                                 = packFunctionCall(_amount, _fee, _params);\n\n\n        address leveragedAsset = _reserve;\n\n        // If the assets are different\n        if (compCreate.cCollAddr != compCreate.cDebtAddr) {\n            exchangeData.dfsFeeDivider = SERVICE_FEE;\n            exchangeData.user = DSProxyInterface(compCreate.proxyAddr).owner();\n\n            _sell(exchangeData);\n\n            leveragedAsset = exchangeData.destAddr;\n        }\n\n        // Send amount to DSProxy\n        sendToProxy(compCreate.proxyAddr, leveragedAsset);\n\n        address compOpenProxy = shifterRegistry.getAddr(\"COMP_SHIFTER\");\n\n        // Execute the DSProxy call\n        DSProxyInterface(compCreate.proxyAddr).execute(compOpenProxy, compCreate.proxyData);\n\n        // Repay the loan with the money DSProxy sent back\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            // solhint-disable-next-line avoid-tx-origin\n            tx.origin.transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Formats function data call so we can call it through DSProxy\n    /// @param _amount Amount of FL\n    /// @param _fee Fee of the FL\n    /// @param _params Saver proxy params\n    function packFunctionCall(uint _amount, uint _fee, bytes memory _params) internal pure  returns (CompCreateData memory compCreate, ExchangeData memory exchangeData) {\n\n        CompoundCreateTaker.CreateInfo memory createData;\n        address proxy;\n\n        (createData , exchangeData, proxy)= abi.decode(_params, (CompoundCreateTaker.CreateInfo, ExchangeData, address));\n\n        bytes memory proxyData = abi.encodeWithSignature(\n            \"open(address,address,uint256)\",\n                                createData.cCollAddress, createData.cBorrowAddress, (_amount + _fee));\n\n\n        compCreate = CompCreateData({\n            proxyAddr: payable(proxy),\n            proxyData: proxyData,\n            cCollAddr: createData.cCollAddress,\n            cDebtAddr: createData.cBorrowAddress\n        });\n\n        return (compCreate, exchangeData);\n    }\n\n    /// @notice Send the FL funds received to DSProxy\n    /// @param _proxy DSProxy address\n    /// @param _reserve Token address\n    function sendToProxy(address payable _proxy, address _reserve) internal {\n        if (_reserve != ETH_ADDRESS) {\n            ERC20(_reserve).safeTransfer(_proxy, ERC20(_reserve).balanceOf(address(this)));\n        } else {\n            _proxy.transfer(address(this).balance);\n        }\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external override(FlashLoanReceiverBase, DFSExchangeCore) payable {}\n}\n"
162     },
163     "contracts/compound/create/CompoundCreateTaker.sol": {
164       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../auth/ProxyPermission.sol\";\nimport \"../../exchangeV3/DFSExchangeData.sol\";\nimport \"../../utils/SafeERC20.sol\";\n\n/// @title Opens compound positions with a leverage\ncontract CompoundCreateTaker is ProxyPermission {\n    using SafeERC20 for ERC20;\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    // solhint-disable-next-line const-name-snakecase\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\n\n    struct CreateInfo {\n        address cCollAddress;\n        address cBorrowAddress;\n        uint depositAmount;\n    }\n\n    /// @notice Main function which will take a FL and open a leverage position\n    /// @dev Call through DSProxy, if _exchangeData.destAddr is a token approve DSProxy\n    /// @param _createInfo [cCollAddress, cBorrowAddress, depositAmount]\n    /// @param _exchangeData Exchange data struct\n    function openLeveragedLoan(\n        CreateInfo memory _createInfo,\n        DFSExchangeData.ExchangeData memory _exchangeData,\n        address payable _compReceiver\n    ) public payable {\n        uint loanAmount = _exchangeData.srcAmount;\n\n        // Pull tokens from user\n        if (_exchangeData.destAddr != ETH_ADDRESS) {\n            ERC20(_exchangeData.destAddr).safeTransferFrom(msg.sender, address(this), _createInfo.depositAmount);\n        } else {\n            require(msg.value >= _createInfo.depositAmount, \"Must send correct amount of eth\");\n        }\n\n        // Send tokens to FL receiver\n        sendDeposit(_compReceiver, _exchangeData.destAddr);\n\n        bytes memory paramsData = abi.encode(_createInfo, _exchangeData, address(this));\n\n        givePermission(_compReceiver);\n\n        lendingPool.flashLoan(_compReceiver, _exchangeData.srcAddr, loanAmount, paramsData);\n\n        removePermission(_compReceiver);\n\n        logger.Log(address(this), msg.sender, \"CompoundLeveragedLoan\",\n            abi.encode(_exchangeData.srcAddr, _exchangeData.destAddr, _exchangeData.srcAmount, _exchangeData.destAmount));\n    }\n\n    function sendDeposit(address payable _compoundReceiver, address _token) internal {\n        if (_token != ETH_ADDRESS) {\n            ERC20(_token).safeTransfer(_compoundReceiver, ERC20(_token).balanceOf(address(this)));\n        }\n\n        _compoundReceiver.transfer(address(this).balance);\n    }\n}\n"
165     },
166     "contracts/reflexer/saver/RAISaverTaker.sol": {
167       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../saver/RAISaverProxy.sol\";\nimport \"../../exchangeV3/DFSExchangeData.sol\";\nimport \"../../utils/GasBurner.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../utils/DydxFlashLoanBase.sol\";\n\ncontract RAISaverTaker is RAISaverProxy, DydxFlashLoanBase, GasBurner {\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    struct SaverData {\n        uint256 flAmount;\n        bool isRepay;\n        uint256 safeId;\n        uint256 gasCost;\n        address joinAddr;\n        ManagerType managerType;\n    }\n\n    function boostWithLoan(\n        ExchangeData memory _exchangeData,\n        uint256 _safeId,\n        uint256 _gasCost,\n        address _joinAddr,\n        ManagerType _managerType,\n        address _raiSaverFlashLoan\n    ) public payable burnGas(25) {\n        address managerAddr = getManagerAddr(_managerType);\n\n        uint256 maxDebt =\n            getMaxDebt(managerAddr, _safeId, ISAFEManager(managerAddr).collateralTypes(_safeId));\n\n        if (maxDebt >= _exchangeData.srcAmount) {\n            if (_exchangeData.srcAmount > maxDebt) {\n                _exchangeData.srcAmount = maxDebt;\n            }\n\n            boost(_exchangeData, _safeId, _gasCost, _joinAddr, _managerType);\n            return;\n        }\n\n        uint256 loanAmount = getAvailableEthLiquidity();\n\n        SaverData memory saverData =\n            SaverData({\n                flAmount: loanAmount,\n                isRepay: false,\n                safeId: _safeId,\n                gasCost: _gasCost,\n                joinAddr: _joinAddr,\n                managerType: _managerType\n            });\n\n        _flashLoan(_raiSaverFlashLoan, _exchangeData, saverData);\n    }\n\n    function repayWithLoan(\n        ExchangeData memory _exchangeData,\n        uint256 _safeId,\n        uint256 _gasCost,\n        address _joinAddr,\n        ManagerType _managerType,\n        address _raiSaverFlashLoan\n    ) public payable burnGas(25) {\n        address managerAddr = getManagerAddr(_managerType);\n\n        uint256 maxColl =\n            getMaxCollateral(\n                managerAddr,\n                _safeId,\n                ISAFEManager(managerAddr).collateralTypes(_safeId),\n                _joinAddr\n            );\n\n        if (maxColl >= _exchangeData.srcAmount) {\n            if (_exchangeData.srcAmount > maxColl) {\n                _exchangeData.srcAmount = maxColl;\n            }\n\n            repay(_exchangeData, _safeId, _gasCost, _joinAddr, _managerType);\n            return;\n        }\n\n        uint256 loanAmount = _exchangeData.srcAmount;\n\n        SaverData memory saverData =\n            SaverData({\n                flAmount: loanAmount,\n                isRepay: true,\n                safeId: _safeId,\n                gasCost: _gasCost,\n                joinAddr: _joinAddr,\n                managerType: _managerType\n            });\n\n        _flashLoan(_raiSaverFlashLoan, _exchangeData, saverData);\n    }\n\n    /// @notice Gets the maximum amount of debt available to generate\n    /// @param _managerAddr Address of the CDP Manager\n    /// @param _safeId Id of the CDP\n    /// @param _collType Coll type of the CDP\n    function getMaxDebt(\n        address _managerAddr,\n        uint256 _safeId,\n        bytes32 _collType\n    ) public override view returns (uint256) {\n        (uint256 collateral, uint256 debt) =\n            getSafeInfo(ISAFEManager(_managerAddr), _safeId, _collType);\n\n        (, , uint256 safetyPrice, , , ) =\n            ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);\n\n        return sub(rmul(collateral, safetyPrice), debt);\n    }\n\n    /// @notice Fetches Eth Dydx liqudity\n    function getAvailableEthLiquidity() internal view returns (uint256 liquidity) {\n        liquidity = ERC20(WETH_ADDR).balanceOf(SOLO_MARGIN_ADDRESS);\n    }\n\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\n    /// @dev User must send 2 wei with this transaction\n    function _flashLoan(address RAI_SAVER_FLASH_LOAN, ExchangeData memory _exchangeData, SaverData memory _saverData) internal {\n        ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\n\n        address managerAddr = getManagerAddr(_saverData.managerType);\n\n        // Get marketId from token address\n        uint256 marketId = _getMarketIdFromTokenAddress(WETH_ADDR);\n\n        // Calculate repay amount (_amount + (2 wei))\n        // Approve transfer from\n        uint256 repayAmount = _getRepaymentAmountInternal(_saverData.flAmount);\n        ERC20(WETH_ADDR).approve(SOLO_MARGIN_ADDRESS, repayAmount);\n\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\n\n        operations[0] = _getWithdrawAction(marketId, _saverData.flAmount, RAI_SAVER_FLASH_LOAN);\n        payable(RAI_SAVER_FLASH_LOAN).transfer(msg.value); // 0x fee\n\n        bytes memory exchangeData = packExchangeData(_exchangeData);\n        operations[1] = _getCallAction(abi.encode(exchangeData, _saverData), RAI_SAVER_FLASH_LOAN);\n\n        operations[2] = _getDepositAction(marketId, repayAmount, address(this));\n\n        Account.Info[] memory accountInfos = new Account.Info[](1);\n        accountInfos[0] = _getAccountInfo();\n\n        ISAFEManager(managerAddr).allowSAFE(_saverData.safeId, RAI_SAVER_FLASH_LOAN, 1);\n        solo.operate(accountInfos, operations);\n        ISAFEManager(managerAddr).allowSAFE(_saverData.safeId, RAI_SAVER_FLASH_LOAN, 0);\n    }\n}\n"
168     },
169     "contracts/utils/DydxFlashLoanBase.sol": {
170       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../utils/SafeMath.sol\";\nimport \"../savings/dydx/ISoloMargin.sol\";\n\ncontract DydxFlashLoanBase {\n    using SafeMath for uint256;\n\n    address public constant SOLO_MARGIN_ADDRESS = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\n\n    function _getMarketIdFromTokenAddress(address token)\n        internal\n        view\n        returns (uint256)\n    {\n        return 0;\n    }\n\n    function _getRepaymentAmountInternal(uint256 amount)\n        internal\n        view\n        returns (uint256)\n    {\n        // Needs to be overcollateralize\n        // Needs to provide +2 wei to be safe\n        return amount.add(2);\n    }\n\n    function _getAccountInfo() internal view returns (Account.Info memory) {\n        return Account.Info({owner: address(this), number: 1});\n    }\n\n    function _getWithdrawAction(uint marketId, uint256 amount, address contractAddr)\n        internal\n        view\n        returns (Actions.ActionArgs memory)\n    {\n        return\n            Actions.ActionArgs({\n                actionType: Actions.ActionType.Withdraw,\n                accountId: 0,\n                amount: Types.AssetAmount({\n                    sign: false,\n                    denomination: Types.AssetDenomination.Wei,\n                    ref: Types.AssetReference.Delta,\n                    value: amount\n                }),\n                primaryMarketId: marketId,\n                secondaryMarketId: 0,\n                otherAddress: contractAddr,\n                otherAccountId: 0,\n                data: \"\"\n            });\n    }\n\n    function _getCallAction(bytes memory data, address contractAddr)\n        internal\n        view\n        returns (Actions.ActionArgs memory)\n    {\n        return\n            Actions.ActionArgs({\n                actionType: Actions.ActionType.Call,\n                accountId: 0,\n                amount: Types.AssetAmount({\n                    sign: false,\n                    denomination: Types.AssetDenomination.Wei,\n                    ref: Types.AssetReference.Delta,\n                    value: 0\n                }),\n                primaryMarketId: 0,\n                secondaryMarketId: 0,\n                otherAddress: contractAddr,\n                otherAccountId: 0,\n                data: data\n            });\n    }\n\n    function _getDepositAction(uint marketId, uint256 amount, address contractAddr)\n        internal\n        view\n        returns (Actions.ActionArgs memory)\n    {\n        return\n            Actions.ActionArgs({\n                actionType: Actions.ActionType.Deposit,\n                accountId: 0,\n                amount: Types.AssetAmount({\n                    sign: true,\n                    denomination: Types.AssetDenomination.Wei,\n                    ref: Types.AssetReference.Delta,\n                    value: amount\n                }),\n                primaryMarketId: marketId,\n                secondaryMarketId: 0,\n                otherAddress: contractAddr,\n                otherAccountId: 0,\n                data: \"\"\n            });\n    }\n}\n"
171     },
172     "contracts/savings/dydx/ISoloMargin.sol": {
173       "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n\nlibrary Account {\n    enum Status {Normal, Liquid, Vapor}\n    struct Info {\n        address owner; // The address that owns the account\n        uint256 number; // A nonce that allows a single address to control many accounts\n    }\n    struct Storage {\n        mapping(uint256 => Types.Par) balances; // Mapping from marketId to principal\n        Status status;\n    }\n}\n\n\nlibrary Actions {\n    enum ActionType {\n        Deposit, // supply tokens\n        Withdraw, // borrow tokens\n        Transfer, // transfer balance between accounts\n        Buy, // buy an amount of some token (public virtually)\n        Sell, // sell an amount of some token (public virtually)\n        Trade, // trade tokens against another account\n        Liquidate, // liquidate an undercollateralized or expiring account\n        Vaporize, // use excess tokens to zero-out a completely negative account\n        Call // send arbitrary data to an address\n    }\n\n    enum AccountLayout {OnePrimary, TwoPrimary, PrimaryAndSecondary}\n\n    enum MarketLayout {ZeroMarkets, OneMarket, TwoMarkets}\n\n    struct ActionArgs {\n        ActionType actionType;\n        uint256 accountId;\n        Types.AssetAmount amount;\n        uint256 primaryMarketId;\n        uint256 secondaryMarketId;\n        address otherAddress;\n        uint256 otherAccountId;\n        bytes data;\n    }\n\n    struct DepositArgs {\n        Types.AssetAmount amount;\n        Account.Info account;\n        uint256 market;\n        address from;\n    }\n\n    struct WithdrawArgs {\n        Types.AssetAmount amount;\n        Account.Info account;\n        uint256 market;\n        address to;\n    }\n\n    struct TransferArgs {\n        Types.AssetAmount amount;\n        Account.Info accountOne;\n        Account.Info accountTwo;\n        uint256 market;\n    }\n\n    struct BuyArgs {\n        Types.AssetAmount amount;\n        Account.Info account;\n        uint256 makerMarket;\n        uint256 takerMarket;\n        address exchangeWrapper;\n        bytes orderData;\n    }\n\n    struct SellArgs {\n        Types.AssetAmount amount;\n        Account.Info account;\n        uint256 takerMarket;\n        uint256 makerMarket;\n        address exchangeWrapper;\n        bytes orderData;\n    }\n\n    struct TradeArgs {\n        Types.AssetAmount amount;\n        Account.Info takerAccount;\n        Account.Info makerAccount;\n        uint256 inputMarket;\n        uint256 outputMarket;\n        address autoTrader;\n        bytes tradeData;\n    }\n\n    struct LiquidateArgs {\n        Types.AssetAmount amount;\n        Account.Info solidAccount;\n        Account.Info liquidAccount;\n        uint256 owedMarket;\n        uint256 heldMarket;\n    }\n\n    struct VaporizeArgs {\n        Types.AssetAmount amount;\n        Account.Info solidAccount;\n        Account.Info vaporAccount;\n        uint256 owedMarket;\n        uint256 heldMarket;\n    }\n\n    struct CallArgs {\n        Account.Info account;\n        address callee;\n        bytes data;\n    }\n}\n\n\nlibrary Decimal {\n    struct D256 {\n        uint256 value;\n    }\n}\n\n\nlibrary Interest {\n    struct Rate {\n        uint256 value;\n    }\n\n    struct Index {\n        uint96 borrow;\n        uint96 supply;\n        uint32 lastUpdate;\n    }\n}\n\n\nlibrary Monetary {\n    struct Price {\n        uint256 value;\n    }\n    struct Value {\n        uint256 value;\n    }\n}\n\n\nlibrary Storage {\n    // All information necessary for tracking a market\n    struct Market {\n        // Contract address of the associated ERC20 token\n        address token;\n        // Total aggregated supply and borrow amount of the entire market\n        Types.TotalPar totalPar;\n        // Interest index of the market\n        Interest.Index index;\n        // Contract address of the price oracle for this market\n        address priceOracle;\n        // Contract address of the interest setter for this market\n        address interestSetter;\n        // Multiplier on the marginRatio for this market\n        Decimal.D256 marginPremium;\n        // Multiplier on the liquidationSpread for this market\n        Decimal.D256 spreadPremium;\n        // Whether additional borrows are allowed for this market\n        bool isClosing;\n    }\n\n    // The global risk parameters that govern the health and security of the system\n    struct RiskParams {\n        // Required ratio of over-collateralization\n        Decimal.D256 marginRatio;\n        // Percentage penalty incurred by liquidated accounts\n        Decimal.D256 liquidationSpread;\n        // Percentage of the borrower's interest fee that gets passed to the suppliers\n        Decimal.D256 earningsRate;\n        // The minimum absolute borrow value of an account\n        // There must be sufficient incentivize to liquidate undercollateralized accounts\n        Monetary.Value minBorrowedValue;\n    }\n\n    // The maximum RiskParam values that can be set\n    struct RiskLimits {\n        uint64 marginRatioMax;\n        uint64 liquidationSpreadMax;\n        uint64 earningsRateMax;\n        uint64 marginPremiumMax;\n        uint64 spreadPremiumMax;\n        uint128 minBorrowedValueMax;\n    }\n\n    // The entire storage state of Solo\n    struct State {\n        // number of markets\n        uint256 numMarkets;\n        // marketId => Market\n        mapping(uint256 => Market) markets;\n        // owner => account number => Account\n        mapping(address => mapping(uint256 => Account.Storage)) accounts;\n        // Addresses that can control other users accounts\n        mapping(address => mapping(address => bool)) operators;\n        // Addresses that can control all users accounts\n        mapping(address => bool) globalOperators;\n        // mutable risk parameters of the system\n        RiskParams riskParams;\n        // immutable risk limits of the system\n        RiskLimits riskLimits;\n    }\n}\n\n\nlibrary Types {\n    enum AssetDenomination {\n        Wei, // the amount is denominated in wei\n        Par // the amount is denominated in par\n    }\n\n    enum AssetReference {\n        Delta, // the amount is given as a delta from the current value\n        Target // the amount is given as an exact number to end up at\n    }\n\n    struct AssetAmount {\n        bool sign; // true if positive\n        AssetDenomination denomination;\n        AssetReference ref;\n        uint256 value;\n    }\n\n    struct TotalPar {\n        uint128 borrow;\n        uint128 supply;\n    }\n\n    struct Par {\n        bool sign; // true if positive\n        uint128 value;\n    }\n\n    struct Wei {\n        bool sign; // true if positive\n        uint256 value;\n    }\n}\n\n\nabstract contract ISoloMargin {\n    struct OperatorArg {\n        address operator;\n        bool trusted;\n    }\n\n    function ownerSetSpreadPremium(\n        uint256 marketId,\n        Decimal.D256 memory spreadPremium\n    ) public virtual;\n\n    function getIsGlobalOperator(address operator) public virtual view returns (bool);\n\n    function getMarketTokenAddress(uint256 marketId)\n        public virtual\n        view\n        returns (address);\n\n    function ownerSetInterestSetter(uint256 marketId, address interestSetter)\n        public virtual;\n\n    function getAccountValues(Account.Info memory account)\n        public virtual\n        view\n        returns (Monetary.Value memory, Monetary.Value memory);\n\n    function getMarketPriceOracle(uint256 marketId)\n        public virtual\n        view\n        returns (address);\n\n    function getMarketInterestSetter(uint256 marketId)\n        public virtual\n        view\n        returns (address);\n\n    function getMarketSpreadPremium(uint256 marketId)\n        public virtual\n        view\n        returns (Decimal.D256 memory);\n\n    function getNumMarkets() public virtual view returns (uint256);\n\n    function ownerWithdrawUnsupportedTokens(address token, address recipient)\n        public virtual\n        returns (uint256);\n\n    function ownerSetMinBorrowedValue(Monetary.Value memory minBorrowedValue)\n        public virtual;\n\n    function ownerSetLiquidationSpread(Decimal.D256 memory spread) public virtual;\n\n    function ownerSetEarningsRate(Decimal.D256 memory earningsRate) public virtual;\n\n    function getIsLocalOperator(address owner, address operator)\n        public virtual\n        view\n        returns (bool);\n\n    function getAccountPar(Account.Info memory account, uint256 marketId)\n        public virtual\n        view\n        returns (Types.Par memory);\n\n    function ownerSetMarginPremium(\n        uint256 marketId,\n        Decimal.D256 memory marginPremium\n    ) public virtual;\n\n    function getMarginRatio() public virtual view returns (Decimal.D256 memory);\n\n    function getMarketCurrentIndex(uint256 marketId)\n        public virtual\n        view\n        returns (Interest.Index memory);\n\n    function getMarketIsClosing(uint256 marketId) public virtual view returns (bool);\n\n    function getRiskParams() public virtual view returns (Storage.RiskParams memory);\n\n    function getAccountBalances(Account.Info memory account)\n        public virtual\n        view\n        returns (address[] memory, Types.Par[] memory, Types.Wei[] memory);\n\n    function renounceOwnership() public virtual;\n\n    function getMinBorrowedValue() public virtual view returns (Monetary.Value memory);\n\n    function setOperators(OperatorArg[] memory args) public virtual;\n\n    function getMarketPrice(uint256 marketId) public virtual view returns (address);\n\n    function owner() public virtual view returns (address);\n\n    function isOwner() public virtual view returns (bool);\n\n    function ownerWithdrawExcessTokens(uint256 marketId, address recipient)\n        public virtual\n        returns (uint256);\n\n    function ownerAddMarket(\n        address token,\n        address priceOracle,\n        address interestSetter,\n        Decimal.D256 memory marginPremium,\n        Decimal.D256 memory spreadPremium\n    ) public virtual;\n\n    function operate(\n        Account.Info[] memory accounts,\n        Actions.ActionArgs[] memory actions\n    ) public virtual;\n\n    function getMarketWithInfo(uint256 marketId)\n        public virtual\n        view\n        returns (\n            Storage.Market memory,\n            Interest.Index memory,\n            Monetary.Price memory,\n            Interest.Rate memory\n        );\n\n    function ownerSetMarginRatio(Decimal.D256 memory ratio) public virtual;\n\n    function getLiquidationSpread() public virtual view returns (Decimal.D256 memory);\n\n    function getAccountWei(Account.Info memory account, uint256 marketId)\n        public virtual\n        view\n        returns (Types.Wei memory);\n\n    function getMarketTotalPar(uint256 marketId)\n        public virtual\n        view\n        returns (Types.TotalPar memory);\n\n    function getLiquidationSpreadForPair(\n        uint256 heldMarketId,\n        uint256 owedMarketId\n    ) public virtual view returns (Decimal.D256 memory);\n\n    function getNumExcessTokens(uint256 marketId)\n        public virtual\n        view\n        returns (Types.Wei memory);\n\n    function getMarketCachedIndex(uint256 marketId)\n        public virtual\n        view\n        returns (Interest.Index memory);\n\n    function getAccountStatus(Account.Info memory account)\n        public virtual\n        view\n        returns (uint8);\n\n    function getEarningsRate() public virtual view returns (Decimal.D256 memory);\n\n    function ownerSetPriceOracle(uint256 marketId, address priceOracle) public virtual;\n\n    function getRiskLimits() public virtual view returns (Storage.RiskLimits memory);\n\n    function getMarket(uint256 marketId)\n        public virtual\n        view\n        returns (Storage.Market memory);\n\n    function ownerSetIsClosing(uint256 marketId, bool isClosing) public virtual;\n\n    function ownerSetGlobalOperator(address operator, bool approved) public virtual;\n\n    function transferOwnership(address newOwner) public virtual;\n\n    function getAdjustedAccountValues(Account.Info memory account)\n        public virtual\n        view\n        returns (Monetary.Value memory, Monetary.Value memory);\n\n    function getMarketMarginPremium(uint256 marketId)\n        public virtual\n        view\n        returns (Decimal.D256 memory);\n\n    function getMarketInterestRate(uint256 marketId)\n        public virtual\n        view\n        returns (Interest.Rate memory);\n}\n"
174     },
175     "contracts/flashloan/DydxFlashLoanTaker.sol": {
176       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../auth/ProxyPermission.sol\";\nimport \"../utils/DydxFlashLoanBase.sol\";\nimport \"../loggers/DefisaverLogger.sol\";\nimport \"../interfaces/ERC20.sol\";\n\n\n/// @title Takes flash loan\ncontract DyDxFlashLoanTaker is DydxFlashLoanBase, ProxyPermission {\n\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n\n    /// @notice Takes flash loan for _receiver\n    /// @dev Receiver must send back WETH + 2 wei after executing transaction\n    /// @dev Method is meant to be called from proxy and proxy will give authorization to _receiver\n    /// @param _receiver Address of funds receiver\n    /// @param _ethAmount ETH amount that needs to be pulled from dydx    \n    /// @param _encodedData Bytes with packed data\n    function takeLoan(address _receiver, uint256 _ethAmount, bytes memory _encodedData) public {\n        ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\n\n        // Get marketId from token address\n        uint256 marketId = _getMarketIdFromTokenAddress(WETH_ADDR);\n\n        // Calculate repay amount (_amount + (2 wei))\n        // Approve transfer from\n        uint256 repayAmount = _getRepaymentAmountInternal(_ethAmount);\n        ERC20(WETH_ADDR).approve(SOLO_MARGIN_ADDRESS, repayAmount);\n\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\n\n        operations[0] = _getWithdrawAction(marketId, _ethAmount, _receiver);\n        operations[1] = _getCallAction(\n            _encodedData,\n            _receiver\n        );\n        operations[2] = _getDepositAction(marketId, repayAmount, address(this));\n\n        Account.Info[] memory accountInfos = new Account.Info[](1);\n        accountInfos[0] = _getAccountInfo();\n\n        givePermission(_receiver);\n        solo.operate(accountInfos, operations);\n        removePermission(_receiver);\n\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"DyDxFlashLoanTaken\", abi.encode(_receiver, _ethAmount, _encodedData));\n    }\n}"
177     },
178     "contracts/savings/SavingsProxy.sol": {
179       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./ProtocolInterface.sol\";\nimport \"../interfaces/ERC20.sol\";\nimport \"../interfaces/ITokenInterface.sol\";\nimport \"../interfaces/ComptrollerInterface.sol\";\nimport \"./dydx/ISoloMargin.sol\";\nimport \"./SavingsLogger.sol\";\nimport \"./dsr/DSRSavingsProtocol.sol\";\nimport \"./compound/CompoundSavingsProtocol.sol\";\n\n\ncontract SavingsProxy is DSRSavingsProtocol, CompoundSavingsProtocol {\n    address public constant ADAI_ADDRESS = 0xfC1E690f61EFd961294b3e1Ce3313fBD8aa4f85d;\n\n    address public constant SAVINGS_DYDX_ADDRESS = 0x03b1565e070df392e48e7a8e01798C4B00E534A5;\n    address public constant SAVINGS_AAVE_ADDRESS = 0x535B9035E9bA8D7efe0FeAEac885fb65b303E37C;\n    address public constant NEW_IDAI_ADDRESS = 0x493C57C4763932315A328269E1ADaD09653B9081;\n\n    address public constant COMP_ADDRESS = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    address public constant SAVINGS_LOGGER_ADDRESS = 0x89b3635BD2bAD145C6f92E82C9e83f06D5654984;\n    address public constant SOLO_MARGIN_ADDRESS = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\n\n    enum SavingsProtocol {Compound, Dydx, Fulcrum, Dsr, Aave}\n\n    function deposit(SavingsProtocol _protocol, uint256 _amount) public {\n        if (_protocol == SavingsProtocol.Dsr) {\n            dsrDeposit(_amount, true);\n        } else if (_protocol == SavingsProtocol.Compound) {\n            compDeposit(msg.sender, _amount);\n        } else {\n            _deposit(_protocol, _amount, true);\n        }\n\n        SavingsLogger(SAVINGS_LOGGER_ADDRESS).logDeposit(msg.sender, uint8(_protocol), _amount);\n    }\n\n    function withdraw(SavingsProtocol _protocol, uint256 _amount) public {\n        if (_protocol == SavingsProtocol.Dsr) {\n            dsrWithdraw(_amount, true);\n        } else if (_protocol == SavingsProtocol.Compound) {\n            compWithdraw(msg.sender, _amount);\n        } else {\n            _withdraw(_protocol, _amount, true);\n        }\n\n        SavingsLogger(SAVINGS_LOGGER_ADDRESS).logWithdraw(msg.sender, uint8(_protocol), _amount);\n    }\n\n    function swap(SavingsProtocol _from, SavingsProtocol _to, uint256 _amount) public {\n        if (_from == SavingsProtocol.Dsr) {\n            dsrWithdraw(_amount, false);\n        } else if (_from == SavingsProtocol.Compound) {\n            compWithdraw(msg.sender, _amount);\n        } else {\n            _withdraw(_from, _amount, false);\n        }\n\n        // possible to withdraw 1-2 wei less than actual amount due to division precision\n        // so we deposit all amount on DSProxy\n        uint256 amountToDeposit = ERC20(DAI_ADDRESS).balanceOf(address(this));\n\n        if (_to == SavingsProtocol.Dsr) {\n            dsrDeposit(amountToDeposit, false);\n        } else if (_from == SavingsProtocol.Compound) {\n            compDeposit(msg.sender, _amount);\n        } else {\n            _deposit(_to, amountToDeposit, false);\n        }\n\n        SavingsLogger(SAVINGS_LOGGER_ADDRESS).logSwap(\n            msg.sender,\n            uint8(_from),\n            uint8(_to),\n            _amount\n        );\n    }\n\n    function withdrawDai() public {\n        ERC20(DAI_ADDRESS).transfer(msg.sender, ERC20(DAI_ADDRESS).balanceOf(address(this)));\n    }\n\n    function claimComp() public {\n        ComptrollerInterface(COMP_ADDRESS).claimComp(address(this));\n    }\n\n    function getAddress(SavingsProtocol _protocol) public pure returns (address) {\n\n        if (_protocol == SavingsProtocol.Dydx) {\n            return SAVINGS_DYDX_ADDRESS;\n        }\n\n        if (_protocol == SavingsProtocol.Aave) {\n            return SAVINGS_AAVE_ADDRESS;\n        }\n    }\n\n    function _deposit(SavingsProtocol _protocol, uint256 _amount, bool _fromUser) internal {\n        if (_fromUser) {\n            ERC20(DAI_ADDRESS).transferFrom(msg.sender, address(this), _amount);\n        }\n\n        approveDeposit(_protocol);\n\n        ProtocolInterface(getAddress(_protocol)).deposit(address(this), _amount);\n\n        endAction(_protocol);\n    }\n\n    function _withdraw(SavingsProtocol _protocol, uint256 _amount, bool _toUser) public {\n        approveWithdraw(_protocol);\n\n        ProtocolInterface(getAddress(_protocol)).withdraw(address(this), _amount);\n\n        endAction(_protocol);\n\n        if (_toUser) {\n            withdrawDai();\n        }\n    }\n\n    function endAction(SavingsProtocol _protocol) internal {\n        if (_protocol == SavingsProtocol.Dydx) {\n            setDydxOperator(false);\n        }\n    }\n\n    function approveDeposit(SavingsProtocol _protocol) internal {\n        if (_protocol == SavingsProtocol.Compound || _protocol == SavingsProtocol.Fulcrum || _protocol == SavingsProtocol.Aave) {\n            ERC20(DAI_ADDRESS).approve(getAddress(_protocol), uint256(-1));\n        }\n\n        if (_protocol == SavingsProtocol.Dydx) {\n            ERC20(DAI_ADDRESS).approve(SOLO_MARGIN_ADDRESS, uint256(-1));\n            setDydxOperator(true);\n        }\n    }\n\n    function approveWithdraw(SavingsProtocol _protocol) internal {\n        if (_protocol == SavingsProtocol.Compound) {\n            ERC20(NEW_CDAI_ADDRESS).approve(getAddress(_protocol), uint256(-1));\n        }\n\n        if (_protocol == SavingsProtocol.Dydx) {\n            setDydxOperator(true);\n        }\n\n        if (_protocol == SavingsProtocol.Fulcrum) {\n            ERC20(NEW_IDAI_ADDRESS).approve(getAddress(_protocol), uint256(-1));\n        }\n\n        if (_protocol == SavingsProtocol.Aave) {\n            ERC20(ADAI_ADDRESS).approve(getAddress(_protocol), uint256(-1));\n        }\n    }\n\n    function setDydxOperator(bool _trusted) internal {\n        ISoloMargin.OperatorArg[] memory operatorArgs = new ISoloMargin.OperatorArg[](1);\n        operatorArgs[0] = ISoloMargin.OperatorArg({\n            operator: getAddress(SavingsProtocol.Dydx),\n            trusted: _trusted\n        });\n\n        ISoloMargin(SOLO_MARGIN_ADDRESS).setOperators(operatorArgs);\n    }\n}\n"
180     },
181     "contracts/savings/ProtocolInterface.sol": {
182       "content": "pragma solidity ^0.6.0;\n\nabstract contract ProtocolInterface {\n    function deposit(address _user, uint256 _amount) public virtual;\n\n    function withdraw(address _user, uint256 _amount) public virtual;\n}\n"
183     },
184     "contracts/interfaces/ITokenInterface.sol": {
185       "content": "pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract ITokenInterface is ERC20 {\n    function assetBalanceOf(address _owner) public virtual view returns (uint256);\n\n    function mint(address receiver, uint256 depositAmount) external virtual returns (uint256 mintAmount);\n\n    function burn(address receiver, uint256 burnAmount) external virtual returns (uint256 loanAmountPaid);\n\n    function tokenPrice() public virtual view returns (uint256 price);\n}\n"
186     },
187     "contracts/interfaces/ComptrollerInterface.sol": {
188       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nabstract contract ComptrollerInterface {\n    struct CompMarketState {\n        uint224 index;\n        uint32 block;\n    }\n\n    function claimComp(address holder) public virtual;\n    function claimComp(address holder, address[] memory cTokens) public virtual;\n    function claimComp(address[] memory holders, address[] memory cTokens, bool borrowers, bool suppliers) public virtual;\n\n    function compSupplyState(address) public view virtual returns (CompMarketState memory);\n    function compSupplierIndex(address,address) public view virtual returns (uint);\n    function compAccrued(address) public view virtual returns (uint);\n\n    function compBorrowState(address) public view virtual returns (CompMarketState memory);\n    function compBorrowerIndex(address,address) public view virtual returns (uint);\n\n    function enterMarkets(address[] calldata cTokens) external virtual returns (uint256[] memory);\n\n    function exitMarket(address cToken) external virtual returns (uint256);\n\n    function getAssetsIn(address account) external virtual view returns (address[] memory);\n\n    function markets(address account) public virtual view returns (bool, uint256);\n\n    function getAccountLiquidity(address account) external virtual view returns (uint256, uint256, uint256);\n\n    function oracle() public virtual view returns (address);\n\n    function borrowCaps(address) external virtual returns (uint256);\n}\n"
189     },
190     "contracts/savings/SavingsLogger.sol": {
191       "content": "pragma solidity ^0.6.0;\n\ncontract SavingsLogger {\n    event Deposit(address indexed sender, uint8 protocol, uint256 amount);\n    event Withdraw(address indexed sender, uint8 protocol, uint256 amount);\n    event Swap(address indexed sender, uint8 fromProtocol, uint8 toProtocol, uint256 amount);\n\n    function logDeposit(address _sender, uint8 _protocol, uint256 _amount) external {\n        emit Deposit(_sender, _protocol, _amount);\n    }\n\n    function logWithdraw(address _sender, uint8 _protocol, uint256 _amount) external {\n        emit Withdraw(_sender, _protocol, _amount);\n    }\n\n    function logSwap(address _sender, uint8 _protocolFrom, uint8 _protocolTo, uint256 _amount)\n        external\n    {\n        emit Swap(_sender, _protocolFrom, _protocolTo, _amount);\n    }\n}\n"
192     },
193     "contracts/savings/dsr/DSRSavingsProtocol.sol": {
194       "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/Join.sol\";\nimport \"../../DS/DSMath.sol\";\n\nabstract contract VatLike {\n    function can(address, address) virtual public view returns (uint);\n    function ilks(bytes32) virtual public view returns (uint, uint, uint, uint, uint);\n    function dai(address) virtual public view returns (uint);\n    function urns(bytes32, address) virtual public view returns (uint, uint);\n    function frob(bytes32, address, address, address, int, int) virtual public;\n    function hope(address) virtual public;\n    function move(address, address, uint) virtual public;\n}\n\nabstract contract PotLike {\n    function pie(address) virtual public view returns (uint);\n    function drip() virtual public returns (uint);\n    function join(uint) virtual public;\n    function exit(uint) virtual public;\n}\n\nabstract contract GemLike {\n    function approve(address, uint) virtual public;\n    function transfer(address, uint) virtual public;\n    function transferFrom(address, address, uint) virtual public;\n    function deposit() virtual public payable;\n    function withdraw(uint) virtual public;\n}\n\nabstract contract DaiJoinLike {\n    function vat() virtual public returns (VatLike);\n    function dai() virtual public returns (GemLike);\n    function join(address, uint) virtual public payable;\n    function exit(address, uint) virtual public;\n}\n\ncontract DSRSavingsProtocol is DSMath {\n\n    // Mainnet\n    address public constant POT_ADDRESS = 0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7;\n    address public constant DAI_JOIN_ADDRESS = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\n\n    function dsrDeposit(uint _amount, bool _fromUser) internal {\n        VatLike vat = DaiJoinLike(DAI_JOIN_ADDRESS).vat();\n\n        uint chi = PotLike(POT_ADDRESS).drip();\n\n        daiJoin_join(DAI_JOIN_ADDRESS, address(this), _amount, _fromUser);\n\n        if (vat.can(address(this), address(POT_ADDRESS)) == 0) {\n            vat.hope(POT_ADDRESS);\n        }\n\n        PotLike(POT_ADDRESS).join(mul(_amount, RAY) / chi);\n    }\n\n    function dsrWithdraw(uint _amount, bool _toUser) internal {\n        VatLike vat = DaiJoinLike(DAI_JOIN_ADDRESS).vat();\n\n        uint chi = PotLike(POT_ADDRESS).drip();\n        uint pie = mul(_amount, RAY) / chi;\n\n        PotLike(POT_ADDRESS).exit(pie);\n        uint balance = DaiJoinLike(DAI_JOIN_ADDRESS).vat().dai(address(this));\n\n        if (vat.can(address(this), address(DAI_JOIN_ADDRESS)) == 0) {\n            vat.hope(DAI_JOIN_ADDRESS);\n        }\n\n        address to;\n        if (_toUser) {\n            to = msg.sender;\n        } else {\n            to = address(this);\n        }\n\n        if (_amount == uint(-1)) {\n            DaiJoinLike(DAI_JOIN_ADDRESS).exit(to, mul(chi, pie) / RAY);\n        } else {\n            DaiJoinLike(DAI_JOIN_ADDRESS).exit(\n                to,\n                balance >= mul(_amount, RAY) ? _amount : balance / RAY\n            );\n        }\n    }\n\n    function daiJoin_join(address apt, address urn, uint wad, bool _fromUser) internal {\n        if (_fromUser) {\n            DaiJoinLike(apt).dai().transferFrom(msg.sender, address(this), wad);\n        }\n\n        DaiJoinLike(apt).dai().approve(apt, wad);\n\n        DaiJoinLike(apt).join(urn, wad);\n    }\n}\n"
195     },
196     "contracts/savings/compound/CompoundSavingsProtocol.sol": {
197       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../ProtocolInterface.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../compound/helpers/Exponential.sol\";\nimport \"../../interfaces/ERC20.sol\";\n\ncontract CompoundSavingsProtocol {\n\n    address public constant NEW_CDAI_ADDRESS = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    CTokenInterface public constant cDaiContract = CTokenInterface(NEW_CDAI_ADDRESS);\n\n    function compDeposit(address _user, uint _amount) internal {\n        // get dai from user\n        require(ERC20(DAI_ADDRESS).transferFrom(_user, address(this), _amount));\n\n        // mainnet only\n        ERC20(DAI_ADDRESS).approve(NEW_CDAI_ADDRESS, uint(-1));\n\n        // mint cDai\n        require(cDaiContract.mint(_amount) == 0, \"Failed Mint\");\n    }\n\n    function compWithdraw(address _user, uint _amount) internal {\n        // transfer all users balance to this contract\n        require(cDaiContract.transferFrom(_user, address(this), ERC20(NEW_CDAI_ADDRESS).balanceOf(_user)));\n\n        // approve cDai to compound contract\n        cDaiContract.approve(NEW_CDAI_ADDRESS, uint(-1));\n        // get dai from cDai contract\n        require(cDaiContract.redeemUnderlying(_amount) == 0, \"Reedem Failed\");\n\n        // return to user balance we didn't spend\n        uint cDaiBalance = cDaiContract.balanceOf(address(this));\n        if (cDaiBalance > 0) {\n            cDaiContract.transfer(_user, cDaiBalance);\n        }\n        // return dai we have to user\n        ERC20(DAI_ADDRESS).transfer(_user, _amount);\n    }\n}\n"
198     },
199     "contracts/interfaces/Join.sol": {
200       "content": "pragma solidity ^0.6.0;\n\nimport \"./Gem.sol\";\n\nabstract contract Join {\n    bytes32 public ilk;\n\n    function dec() virtual public view returns (uint);\n    function gem() virtual public view returns (Gem);\n    function join(address, uint) virtual public payable;\n    function exit(address, uint) virtual public;\n}\n"
201     },
202     "contracts/interfaces/Gem.sol": {
203       "content": "pragma solidity ^0.6.0;\n\nabstract contract Gem {\n    function dec() virtual public returns (uint);\n    function gem() virtual public returns (Gem);\n    function join(address, uint) virtual public payable;\n    function exit(address, uint) virtual public;\n\n    function approve(address, uint) virtual public;\n    function transfer(address, uint) virtual public returns (bool);\n    function transferFrom(address, address, uint) virtual public returns (bool);\n    function deposit() virtual public payable;\n    function withdraw(uint) virtual public;\n    function allowance(address, address) virtual public returns (uint);\n}\n"
204     },
205     "contracts/compound/helpers/Exponential.sol": {
206       "content": "pragma solidity ^0.6.0;\n\nimport \"./CarefulMath.sol\";\n\ncontract Exponential is CarefulMath {\n    uint constant expScale = 1e18;\n    uint constant doubleScale = 1e36;\n    uint constant halfExpScale = expScale/2;\n    uint constant mantissaOne = expScale;\n\n    struct Exp {\n        uint mantissa;\n    }\n\n    struct Double {\n        uint mantissa;\n    }\n\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        return getExp(a.mantissa, b.mantissa);\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) pure internal returns (uint) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa < right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\n        return value.mantissa == 0;\n    }\n\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(uint a, uint b) pure internal returns (uint) {\n        return sub_(a, b, \"subtraction underflow\");\n    }\n\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n    }\n\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\n        return mul_(a, b.mantissa) / expScale;\n    }\n\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n    }\n\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\n        return mul_(a, b.mantissa) / doubleScale;\n    }\n\n    function mul_(uint a, uint b) pure internal returns (uint) {\n        return mul_(a, b, \"multiplication overflow\");\n    }\n\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        uint c = a * b;\n        require(c / a == b, errorMessage);\n        return c;\n    }\n\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n    }\n\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\n        return Exp({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\n        return div_(mul_(a, expScale), b.mantissa);\n    }\n\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n    }\n\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Double memory b) pure internal returns (uint) {\n        return div_(mul_(a, doubleScale), b.mantissa);\n    }\n\n    function div_(uint a, uint b) pure internal returns (uint) {\n        return div_(a, b, \"divide by zero\");\n    }\n\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(uint a, uint b) pure internal returns (uint) {\n        return add_(a, b, \"addition overflow\");\n    }\n\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        uint c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n}\n"
207     },
208     "contracts/compound/helpers/CarefulMath.sol": {
209       "content": "pragma solidity ^0.6.0;\n\ncontract CarefulMath {\n\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n    * @dev Multiplies two numbers, returns an error on overflow.\n    */\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint c = a * b;\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b <= a) {\n            return (MathError.NO_ERROR, a - b);\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev Adds two numbers, returns an error on overflow.\n    */\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        uint c = a + b;\n\n        if (c >= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev add a and b and then subtract c\n    */\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n        (MathError err0, uint sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n}\n"
210     },
211     "contracts/cream/helpers/CreamSaverHelper.sol": {
212       "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/CEtherInterface.sol\";\nimport \"../../interfaces/CompoundOracleInterface.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../interfaces/ComptrollerInterface.sol\";\nimport \"../../interfaces/IFeeRecipient.sol\";\n\nimport \"../../utils/Discount.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../DS/DSProxy.sol\";\nimport \"../../compound/helpers/Exponential.sol\";\nimport \"../../utils/BotRegistry.sol\";\n\nimport \"../../utils/SafeERC20.sol\";\n\n/// @title Utlity functions for cream contracts\ncontract CreamSaverHelper is DSMath, Exponential {\n\n    using SafeERC20 for ERC20;\n\n    IFeeRecipient public constant feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);\n\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    uint public constant MANUAL_SERVICE_FEE = 400; // 0.25% Fee\n    uint public constant AUTOMATIC_SERVICE_FEE = 333; // 0.3% Fee\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant CETH_ADDRESS = 0xD06527D5e56A3495252A528C4987003b712860eE;\n    address public constant COMPTROLLER = 0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258;\n\n    address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;\n\n    /// @notice Helper method to payback the cream debt\n    /// @dev If amount is bigger it will repay the whole debt and send the extra to the _user\n    /// @param _amount Amount of tokens we want to repay\n    /// @param _cBorrowToken Ctoken address we are repaying\n    /// @param _borrowToken Token address we are repaying\n    /// @param _user Owner of the cream position we are paying back\n    function paybackDebt(uint _amount, address _cBorrowToken, address _borrowToken, address payable _user) internal {\n        uint wholeDebt = CTokenInterface(_cBorrowToken).borrowBalanceCurrent(address(this));\n\n        if (_amount > wholeDebt) {\n            if (_borrowToken == ETH_ADDRESS) {\n                _user.transfer((_amount - wholeDebt));\n            } else {\n                ERC20(_borrowToken).safeTransfer(_user, (_amount - wholeDebt));\n            }\n\n            _amount = wholeDebt;\n        }\n\n        approveCToken(_borrowToken, _cBorrowToken);\n\n        if (_borrowToken == ETH_ADDRESS) {\n            CEtherInterface(_cBorrowToken).repayBorrow{value: _amount}();\n        } else {\n            require(CTokenInterface(_cBorrowToken).repayBorrow(_amount) == 0);\n        }\n    }\n\n    /// @notice Calculates the fee amount\n    /// @param _amount Amount that is converted\n    /// @param _user Actuall user addr not DSProxy\n    /// @param _gasCost Ether amount of gas we are spending for tx\n    /// @param _cTokenAddr CToken addr. of token we are getting for the fee\n    /// @return feeAmount The amount we took for the fee\n    function getFee(uint _amount, address _user, uint _gasCost, address _cTokenAddr) internal returns (uint feeAmount) {\n        uint fee = MANUAL_SERVICE_FEE;\n\n        if (BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin)) {\n            fee = AUTOMATIC_SERVICE_FEE;\n        }\n\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\n\n        if (Discount(DISCOUNT_ADDR).isCustomFeeSet(_user)) {\n            fee = Discount(DISCOUNT_ADDR).getCustomServiceFee(_user);\n        }\n\n        feeAmount = (fee == 0) ? 0 : (_amount / fee);\n\n        if (_gasCost != 0) {\n            address oracle = ComptrollerInterface(COMPTROLLER).oracle();\n\n            uint ethTokenPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cTokenAddr);\n\n            _gasCost = wdiv(_gasCost, ethTokenPrice);\n\n            feeAmount = add(feeAmount, _gasCost);\n        }\n\n        // fee can't go over 20% of the whole amount\n        if (feeAmount > (_amount / 5)) {\n            feeAmount = _amount / 5;\n        }\n\n        address walletAddr = feeRecipient.getFeeAddr();\n\n\n        if (tokenAddr == ETH_ADDRESS) {\n            payable(walletAddr).transfer(feeAmount);\n        } else {\n            ERC20(tokenAddr).safeTransfer(walletAddr, feeAmount);\n        }\n    }\n\n    /// @notice Calculates the gas cost of transaction and send it to wallet\n    /// @param _amount Amount that is converted\n    /// @param _gasCost Ether amount of gas we are spending for tx\n    /// @param _cTokenAddr CToken addr. of token we are getting for the fee\n    /// @return feeAmount The amount we took for the fee\n    function getGasCost(uint _amount, uint _gasCost, address _cTokenAddr) internal returns (uint feeAmount) {\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\n\n        if (_gasCost != 0) {\n            address oracle = ComptrollerInterface(COMPTROLLER).oracle();\n\n            uint ethTokenPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cTokenAddr);\n\n            feeAmount = wdiv(_gasCost, ethTokenPrice);\n        }\n\n        // fee can't go over 20% of the whole amount\n        if (feeAmount > (_amount / 5)) {\n            feeAmount = _amount / 5;\n        }\n\n        address walletAddr = feeRecipient.getFeeAddr();\n\n        if (tokenAddr == ETH_ADDRESS) {\n            payable(walletAddr).transfer(feeAmount);\n        } else {\n            ERC20(tokenAddr).safeTransfer(walletAddr, feeAmount);\n        }\n    }\n\n    /// @notice Enters the market for the collatera and borrow tokens\n    /// @param _cTokenAddrColl Collateral address we are entering the market in\n    /// @param _cTokenAddrBorrow Borrow address we are entering the market in\n    function enterMarket(address _cTokenAddrColl, address _cTokenAddrBorrow) internal {\n        address[] memory markets = new address[](2);\n        markets[0] = _cTokenAddrColl;\n        markets[1] = _cTokenAddrBorrow;\n\n        ComptrollerInterface(COMPTROLLER).enterMarkets(markets);\n    }\n\n    /// @notice Approves CToken contract to pull underlying tokens from the DSProxy\n    /// @param _tokenAddr Token we are trying to approve\n    /// @param _cTokenAddr Address which will gain the approval\n    function approveCToken(address _tokenAddr, address _cTokenAddr) internal {\n        if (_tokenAddr != ETH_ADDRESS) {\n            ERC20(_tokenAddr).safeApprove(_cTokenAddr, uint(-1));\n        }\n    }\n\n    /// @notice Returns the underlying address of the cToken asset\n    /// @param _cTokenAddress cToken address\n    /// @return Token address of the cToken specified\n    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\n        if (_cTokenAddress == CETH_ADDRESS) {\n            return ETH_ADDRESS;\n        } else {\n            return CTokenInterface(_cTokenAddress).underlying();\n        }\n    }\n\n    /// @notice Returns the owner of the DSProxy that called the contract\n    function getUserAddress() internal view returns (address) {\n        DSProxy proxy = DSProxy(uint160(address(this)));\n\n        return proxy.owner();\n    }\n\n    /// @notice Returns the maximum amount of collateral available to withdraw\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n    /// @param _cCollAddress Collateral we are getting the max value of\n    /// @param _account Users account\n    /// @return Returns the max. collateral amount in that token\n    function getMaxCollateral(address _cCollAddress, address _account) public returns (uint) {\n        (, uint liquidityInEth, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n        uint usersBalance = CTokenInterface(_cCollAddress).balanceOfUnderlying(_account);\n        address oracle = ComptrollerInterface(COMPTROLLER).oracle();\n\n        if (liquidityInEth == 0) return usersBalance;\n\n        CTokenInterface(_cCollAddress).accrueInterest();\n\n         if (_cCollAddress == CETH_ADDRESS) {\n             if (liquidityInEth > usersBalance) return usersBalance;\n\n             return sub(liquidityInEth, (liquidityInEth / 100));\n         }\n\n        uint ethPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cCollAddress);\n        uint liquidityInToken = wdiv(liquidityInEth, ethPrice);\n\n        if (liquidityInToken > usersBalance) return usersBalance;\n\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\n    }\n\n    /// @notice Returns the maximum amount of borrow amount available\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n    /// @param _cBorrowAddress Borrow token we are getting the max value of\n    /// @param _account Users account\n    /// @return Returns the max. borrow amount in that token\n    function getMaxBorrow(address _cBorrowAddress, address _account) public returns (uint) {\n        (, uint liquidityInEth, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n        address oracle = ComptrollerInterface(COMPTROLLER).oracle();\n\n        CTokenInterface(_cBorrowAddress).accrueInterest();\n\n        if (_cBorrowAddress == CETH_ADDRESS) return sub(liquidityInEth, (liquidityInEth / 100));\n\n        uint ethPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cBorrowAddress);\n        uint liquidityInToken = wdiv(liquidityInEth, ethPrice);\n\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\n    }\n}\n"
213     },
214     "contracts/interfaces/CEtherInterface.sol": {
215       "content": "pragma solidity ^0.6.0;\n\nabstract contract CEtherInterface {\n    function mint() external virtual payable;\n    function repayBorrow() external virtual payable;\n}\n"
216     },
217     "contracts/interfaces/CompoundOracleInterface.sol": {
218       "content": "pragma solidity ^0.6.0;\n\nabstract contract CompoundOracleInterface {\n    function getUnderlyingPrice(address cToken) external view virtual returns (uint);\n}\n"
219     },
220     "contracts/cream/saver/CreamSaverFlashProxy.sol": {
221       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../exchange/SaverExchangeCore.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../utils/Discount.sol\";\nimport \"../helpers/CreamSaverHelper.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\n\n/// @title Implements the actual logic of Repay/Boost with FL\ncontract CreamSaverFlashProxy is SaverExchangeCore, CreamSaverHelper  {\n\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n\n    using SafeERC20 for ERC20;\n\n    /// @notice Repays the position and sends tokens back for FL\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]\n    /// @param _gasCost Gas cost for transaction\n    /// @param _flashLoanData Data about FL [amount, fee]\n    function flashRepay(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost,\n        uint[2] memory _flashLoanData // amount, fee\n    ) public payable {\n        enterMarket(_cAddresses[0], _cAddresses[1]);\n\n        address payable user = payable(getUserAddress());\n        uint flashBorrowed = _flashLoanData[0] + _flashLoanData[1];\n\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\n\n        // draw max coll\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(maxColl) == 0);\n\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            // swap max coll + loanAmount\n            _exData.srcAmount = maxColl + _flashLoanData[0];\n            (,swapAmount) = _sell(_exData);\n\n            // get fee\n            swapAmount -= getFee(swapAmount, user, _gasCost, _cAddresses[1]);\n        } else {\n            swapAmount = (maxColl + _flashLoanData[0]);\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        }\n\n        // payback debt\n        paybackDebt(swapAmount, _cAddresses[1], borrowToken, user);\n\n        // draw collateral for loanAmount + loanFee\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(flashBorrowed) == 0);\n\n        // repay flash loan\n        returnFlashLoan(collToken, flashBorrowed);\n\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"CreamRepay\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\n    }\n\n    /// @notice Boosts the position and sends tokens back for FL\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    /// @param _flashLoanData Data about FL [amount, fee]\n    function flashBoost(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost,\n        uint[2] memory _flashLoanData // amount, fee\n    ) public payable {\n        enterMarket(_cAddresses[0], _cAddresses[1]);\n\n        address payable user = payable(getUserAddress());\n        uint flashBorrowed = _flashLoanData[0] + _flashLoanData[1];\n\n        // borrow max amount\n        uint borrowAmount = getMaxBorrow(_cAddresses[1], address(this));\n        require(CTokenInterface(_cAddresses[1]).borrow(borrowAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            // get dfs fee\n            borrowAmount -= getFee((borrowAmount + _flashLoanData[0]), user, _gasCost, _cAddresses[1]);\n            _exData.srcAmount = (borrowAmount + _flashLoanData[0]);\n\n            (,swapAmount) = _sell(_exData);\n        } else {\n            swapAmount = (borrowAmount + _flashLoanData[0]);\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        }\n\n        // deposit swaped collateral\n        depositCollateral(collToken, _cAddresses[0], swapAmount);\n\n        // borrow token to repay flash loan\n        require(CTokenInterface(_cAddresses[1]).borrow(flashBorrowed) == 0);\n\n        // repay flash loan\n        returnFlashLoan(borrowToken, flashBorrowed);\n\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"CreamBoost\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\n    }\n\n    /// @notice Helper method to deposit tokens in Compound\n    /// @param _collToken Token address of the collateral\n    /// @param _cCollToken CToken address of the collateral\n    /// @param _depositAmount Amount to deposit\n    function depositCollateral(address _collToken, address _cCollToken, uint _depositAmount) internal {\n        approveCToken(_collToken, _cCollToken);\n\n        if (_collToken != ETH_ADDRESS) {\n            require(CTokenInterface(_cCollToken).mint(_depositAmount) == 0);\n        } else {\n            CEtherInterface(_cCollToken).mint{value: _depositAmount}(); // reverts on fail\n        }\n    }\n\n    /// @notice Returns the tokens/ether to the msg.sender which is the FL contract\n    /// @param _tokenAddr Address of token which we return\n    /// @param _amount Amount to return\n    function returnFlashLoan(address _tokenAddr, uint _amount) internal {\n        if (_tokenAddr != ETH_ADDRESS) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, _amount);\n        }\n\n        msg.sender.transfer(address(this).balance);\n    }\n\n}\n"
222     },
223     "contracts/exchange/SaverExchangeCore.sol": {
224       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../DS/DSMath.sol\";\nimport \"../interfaces/TokenInterface.sol\";\nimport \"../interfaces/ExchangeInterfaceV2.sol\";\nimport \"../utils/ZrxAllowlist.sol\";\nimport \"./SaverExchangeHelper.sol\";\nimport \"./SaverExchangeRegistry.sol\";\n\ncontract SaverExchangeCore is SaverExchangeHelper, DSMath {\n\n    // first is empty to keep the legacy order in place\n    enum ExchangeType { _, OASIS, KYBER, UNISWAP, ZEROX }\n\n    enum ActionType { SELL, BUY }\n\n    struct ExchangeData {\n        address srcAddr;\n        address destAddr;\n        uint srcAmount;\n        uint destAmount;\n        uint minPrice;\n        address wrapper;\n        address exchangeAddr;\n        bytes callData;\n        uint256 price0x;\n    }\n\n    /// @notice Internal method that preforms a sell on 0x/on-chain\n    /// @dev Usefull for other DFS contract to integrate for exchanging\n    /// @param exData Exchange data struct\n    /// @return (address, uint) Address of the wrapper used and destAmount\n    function _sell(ExchangeData memory exData) internal returns (address, uint) {\n\n        address wrapper;\n        uint swapedTokens;\n        bool success;\n        uint tokensLeft = exData.srcAmount;\n\n        // if selling eth, convert to weth\n        if (exData.srcAddr == KYBER_ETH_ADDRESS) {\n            exData.srcAddr = ethToWethAddr(exData.srcAddr);\n            TokenInterface(WETH_ADDRESS).deposit.value(exData.srcAmount)();\n        }\n\n        // Try 0x first and then fallback on specific wrapper\n        if (exData.price0x > 0) {\n            approve0xProxy(exData.srcAddr, exData.srcAmount);\n\n            uint ethAmount = getProtocolFee(exData.srcAddr, exData.srcAmount);\n            (success, swapedTokens, tokensLeft) = takeOrder(exData, ethAmount, ActionType.SELL);\n\n            if (success) {\n                wrapper = exData.exchangeAddr;\n            }\n        }\n\n        // fallback to desired wrapper if 0x failed\n        if (!success) {\n            swapedTokens = saverSwap(exData, ActionType.SELL);\n            wrapper = exData.wrapper;\n        }\n\n        require(getBalance(exData.destAddr) >= wmul(exData.minPrice, exData.srcAmount), \"Final amount isn't correct\");\n\n        // if anything is left in weth, pull it to user as eth\n        if (getBalance(WETH_ADDRESS) > 0) {\n            TokenInterface(WETH_ADDRESS).withdraw(\n                TokenInterface(WETH_ADDRESS).balanceOf(address(this))\n            );\n        }\n\n        return (wrapper, swapedTokens);\n    }\n\n    /// @notice Internal method that preforms a buy on 0x/on-chain\n    /// @dev Usefull for other DFS contract to integrate for exchanging\n    /// @param exData Exchange data struct\n    /// @return (address, uint) Address of the wrapper used and srcAmount\n    function _buy(ExchangeData memory exData) internal returns (address, uint) {\n\n        address wrapper;\n        uint swapedTokens;\n        bool success;\n\n        require(exData.destAmount != 0, \"Dest amount must be specified\");\n\n        // if selling eth, convert to weth\n        if (exData.srcAddr == KYBER_ETH_ADDRESS) {\n            exData.srcAddr = ethToWethAddr(exData.srcAddr);\n            TokenInterface(WETH_ADDRESS).deposit.value(exData.srcAmount)();\n        }\n\n        if (exData.price0x > 0) {\n            approve0xProxy(exData.srcAddr, exData.srcAmount);\n\n            uint ethAmount = getProtocolFee(exData.srcAddr, exData.srcAmount);\n            (success, swapedTokens,) = takeOrder(exData, ethAmount, ActionType.BUY);\n\n            if (success) {\n                wrapper = exData.exchangeAddr;\n            }\n        }\n\n        // fallback to desired wrapper if 0x failed\n        if (!success) {\n            swapedTokens = saverSwap(exData, ActionType.BUY);\n            wrapper = exData.wrapper;\n        }\n\n        require(getBalance(exData.destAddr) >= exData.destAmount, \"Final amount isn't correct\");\n\n        // if anything is left in weth, pull it to user as eth\n        if (getBalance(WETH_ADDRESS) > 0) {\n            TokenInterface(WETH_ADDRESS).withdraw(\n                TokenInterface(WETH_ADDRESS).balanceOf(address(this))\n            );\n        }\n\n        return (wrapper, getBalance(exData.destAddr));\n    }\n\n    /// @notice Takes order from 0x and returns bool indicating if it is successful\n    /// @param _exData Exchange data\n    /// @param _ethAmount Ether fee needed for 0x order\n    function takeOrder(\n        ExchangeData memory _exData,\n        uint256 _ethAmount,\n        ActionType _type\n    ) private returns (bool success, uint256, uint256) {\n\n        // write in the exact amount we are selling/buing in an order\n        if (_type == ActionType.SELL) {\n            writeUint256(_exData.callData, 36, _exData.srcAmount);\n        } else {\n            writeUint256(_exData.callData, 36, _exData.destAmount);\n        }\n\n        if (ZrxAllowlist(ZRX_ALLOWLIST_ADDR).isNonPayableAddr(_exData.exchangeAddr)) {\n            _ethAmount = 0;\n        }\n\n        uint256 tokensBefore = getBalance(_exData.destAddr);\n\n        if (ZrxAllowlist(ZRX_ALLOWLIST_ADDR).isZrxAddr(_exData.exchangeAddr)) {\n            (success, ) = _exData.exchangeAddr.call{value: _ethAmount}(_exData.callData);\n        } else {\n            success = false;\n        }\n\n        uint256 tokensSwaped = 0;\n        uint256 tokensLeft = _exData.srcAmount;\n\n        if (success) {\n            // check to see if any _src tokens are left over after exchange\n            tokensLeft = getBalance(_exData.srcAddr);\n\n            // convert weth -> eth if needed\n            if (_exData.destAddr == KYBER_ETH_ADDRESS) {\n                TokenInterface(WETH_ADDRESS).withdraw(\n                    TokenInterface(WETH_ADDRESS).balanceOf(address(this))\n                );\n            }\n\n            // get the current balance of the swaped tokens\n            tokensSwaped = getBalance(_exData.destAddr) - tokensBefore;\n        }\n\n        return (success, tokensSwaped, tokensLeft);\n    }\n\n    /// @notice Calls wraper contract for exchage to preform an on-chain swap\n    /// @param _exData Exchange data struct\n    /// @param _type Type of action SELL|BUY\n    /// @return swapedTokens For Sell that the destAmount, for Buy thats the srcAmount\n    function saverSwap(ExchangeData memory _exData, ActionType _type) internal returns (uint swapedTokens) {\n        require(SaverExchangeRegistry(SAVER_EXCHANGE_REGISTRY).isWrapper(_exData.wrapper), \"Wrapper is not valid\");\n\n        uint ethValue = 0;\n\n        ERC20(_exData.srcAddr).safeTransfer(_exData.wrapper, _exData.srcAmount);\n\n        if (_type == ActionType.SELL) {\n            swapedTokens = ExchangeInterfaceV2(_exData.wrapper).\n                    sell{value: ethValue}(_exData.srcAddr, _exData.destAddr, _exData.srcAmount);\n        } else {\n            swapedTokens = ExchangeInterfaceV2(_exData.wrapper).\n                    buy{value: ethValue}(_exData.srcAddr, _exData.destAddr, _exData.destAmount);\n        }\n    }\n\n    function writeUint256(bytes memory _b, uint256 _index, uint _input) internal pure {\n        if (_b.length < _index + 32) {\n            revert(\"Incorrent lengt while writting bytes32\");\n        }\n\n        bytes32 input = bytes32(_input);\n\n        _index += 32;\n\n        // Read the bytes32 from array memory\n        assembly {\n            mstore(add(_b, _index), input)\n        }\n    }\n\n    /// @notice Converts Kybers Eth address -> Weth\n    /// @param _src Input address\n    function ethToWethAddr(address _src) internal pure returns (address) {\n        return _src == KYBER_ETH_ADDRESS ? WETH_ADDRESS : _src;\n    }\n\n    /// @notice Calculates protocol fee\n    /// @param _srcAddr selling token address (if eth should be WETH)\n    /// @param _srcAmount amount we are selling\n    function getProtocolFee(address _srcAddr, uint256 _srcAmount) internal view returns(uint256) {\n        // if we are not selling ETH msg value is always the protocol fee\n        if (_srcAddr != WETH_ADDRESS) return address(this).balance;\n\n        // if msg value is larger than srcAmount, that means that msg value is protocol fee + srcAmount, so we subsctract srcAmount from msg value\n        // we have an edge case here when protocol fee is higher than selling amount\n        if (address(this).balance > _srcAmount) return address(this).balance - _srcAmount;\n\n        // if msg value is lower than src amount, that means that srcAmount isn't included in msg value, so we return msg value\n        return address(this).balance;\n    }\n\n    function packExchangeData(ExchangeData memory _exData) public pure returns(bytes memory) {\n        // splitting in two different bytes and encoding all because of stack too deep in decoding part\n\n        bytes memory part1 = abi.encode(\n            _exData.srcAddr,\n            _exData.destAddr,\n            _exData.srcAmount,\n            _exData.destAmount\n        );\n\n        bytes memory part2 = abi.encode(\n            _exData.minPrice,\n            _exData.wrapper,\n            _exData.exchangeAddr,\n            _exData.callData,\n            _exData.price0x\n        );\n\n\n        return abi.encode(part1, part2);\n    }\n\n    function unpackExchangeData(bytes memory _data) public pure returns(ExchangeData memory _exData) {\n        (\n            bytes memory part1,\n            bytes memory part2\n        ) = abi.decode(_data, (bytes,bytes));\n\n        (\n            _exData.srcAddr,\n            _exData.destAddr,\n            _exData.srcAmount,\n            _exData.destAmount\n        ) = abi.decode(part1, (address,address,uint256,uint256));\n\n        (\n            _exData.minPrice,\n            _exData.wrapper,\n            _exData.exchangeAddr,\n            _exData.callData,\n            _exData.price0x\n        )\n        = abi.decode(part2, (uint256,address,address,bytes,uint256));\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external virtual payable {}\n}\n"
225     },
226     "contracts/interfaces/ExchangeInterfaceV2.sol": {
227       "content": "pragma solidity ^0.6.0;\n\ninterface ExchangeInterfaceV2 {\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external payable returns (uint);\n\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external payable returns(uint);\n\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) external view returns (uint);\n\n    function getBuyRate(address _srcAddr, address _destAddr, uint _srcAmount) external view returns (uint);\n}\n"
228     },
229     "contracts/exchange/SaverExchangeHelper.sol": {
230       "content": "pragma solidity ^0.6.0;\n\nimport \"../utils/SafeERC20.sol\";\nimport \"../utils/Discount.sol\";\n\ncontract SaverExchangeHelper {\n\n    using SafeERC20 for ERC20;\n\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    address public constant DISCOUNT_ADDRESS = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n    address public constant SAVER_EXCHANGE_REGISTRY = 0x25dd3F51e0C3c3Ff164DDC02A8E4D65Bb9cBB12D;\n\n    address public constant ERC20_PROXY_0X = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;\n    address public constant ZRX_ALLOWLIST_ADDR = 0x4BA1f38427b33B8ab7Bb0490200dAE1F1C36823F;\n\n\n    function getDecimals(address _token) internal view returns (uint256) {\n        if (_token == KYBER_ETH_ADDRESS) return 18;\n\n        return ERC20(_token).decimals();\n    }\n\n    function getBalance(address _tokenAddr) internal view returns (uint balance) {\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\n            balance = address(this).balance;\n        } else {\n            balance = ERC20(_tokenAddr).balanceOf(address(this));\n        }\n    }\n\n    function approve0xProxy(address _tokenAddr, uint _amount) internal {\n        if (_tokenAddr != KYBER_ETH_ADDRESS) {\n            ERC20(_tokenAddr).safeApprove(address(ERC20_PROXY_0X), _amount);\n        }\n    }\n\n    function sendLeftover(address _srcAddr, address _destAddr, address payable _to) internal {\n        // send back any leftover ether or tokens\n        if (address(this).balance > 0) {\n            _to.transfer(address(this).balance);\n        }\n\n        if (getBalance(_srcAddr) > 0) {\n            ERC20(_srcAddr).safeTransfer(_to, getBalance(_srcAddr));\n        }\n\n        if (getBalance(_destAddr) > 0) {\n            ERC20(_destAddr).safeTransfer(_to, getBalance(_destAddr));\n        }\n    }\n\n    function sliceUint(bytes memory bs, uint256 start) internal pure returns (uint256) {\n        require(bs.length >= start + 32, \"slicing out of range\");\n\n        uint256 x;\n        assembly {\n            x := mload(add(bs, add(0x20, start)))\n        }\n\n        return x;\n    }\n}\n"
231     },
232     "contracts/mcd/saver/MCDSaverProxy.sol": {
233       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../utils/Discount.sol\";\n\nimport \"../../interfaces/Spotter.sol\";\nimport \"../../interfaces/Jug.sol\";\nimport \"../../interfaces/DaiJoin.sol\";\nimport \"../../interfaces/Join.sol\";\n\nimport \"./MCDSaverProxyHelper.sol\";\nimport \"../../utils/BotRegistry.sol\";\nimport \"../../exchangeV3/DFSExchangeCore.sol\";\n\n/// @title Implements Boost and Repay for MCD CDPs\ncontract MCDSaverProxy is DFSExchangeCore, MCDSaverProxyHelper {\n\n    uint public constant MANUAL_SERVICE_FEE = 400; // 0.25% Fee\n    uint public constant AUTOMATIC_SERVICE_FEE = 333; // 0.3% Fee\n\n    bytes32 public constant ETH_ILK = 0x4554482d41000000000000000000000000000000000000000000000000000000;\n\n    address public constant VAT_ADDRESS = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\n    address public constant SPOTTER_ADDRESS = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;\n    address public constant DAI_JOIN_ADDRESS = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\n    address public constant JUG_ADDRESS = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;\n\n    Vat public constant vat = Vat(VAT_ADDRESS);\n    DaiJoin public constant daiJoin = DaiJoin(DAI_JOIN_ADDRESS);\n    Spotter public constant spotter = Spotter(SPOTTER_ADDRESS);\n\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\n\n    /// @notice Repay - draws collateral, converts to Dai and repays the debt\n    /// @dev Must be called by the DSProxy contract that owns the CDP\n    function repay(\n        ExchangeData memory _exchangeData,\n        uint _cdpId,\n        uint _gasCost,\n        address _joinAddr,\n        ManagerType _managerType\n    ) public payable {\n\n        address managerAddr = getManagerAddr(_managerType);\n\n        address user = getOwner(Manager(managerAddr), _cdpId);\n        bytes32 ilk = Manager(managerAddr).ilks(_cdpId);\n\n        drawCollateral(managerAddr, _cdpId, _joinAddr, _exchangeData.srcAmount);\n\n        _exchangeData.user = user;\n        _exchangeData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\n        (, uint daiAmount) = _sell(_exchangeData);\n\n        daiAmount -= takeFee(_gasCost, daiAmount);\n\n        paybackDebt(managerAddr, _cdpId, ilk, daiAmount, user);\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n\n        logger.Log(address(this), msg.sender, \"MCDRepay\", abi.encode(_cdpId, user, _exchangeData.srcAmount, daiAmount));\n\n    }\n\n    /// @notice Boost - draws Dai, converts to collateral and adds to CDP\n    /// @dev Must be called by the DSProxy contract that owns the CDP\n    function boost(\n        ExchangeData memory _exchangeData,\n        uint _cdpId,\n        uint _gasCost,\n        address _joinAddr,\n        ManagerType _managerType\n    ) public payable {\n\n        address managerAddr = getManagerAddr(_managerType);\n\n        address user = getOwner(Manager(managerAddr), _cdpId);\n        bytes32 ilk = Manager(managerAddr).ilks(_cdpId);\n\n        uint daiDrawn = drawDai(managerAddr, _cdpId, ilk, _exchangeData.srcAmount);\n\n        _exchangeData.user = user;\n        _exchangeData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\n        _exchangeData.srcAmount = daiDrawn - takeFee(_gasCost, daiDrawn);\n        (, uint swapedColl) = _sell(_exchangeData);\n\n        addCollateral(managerAddr, _cdpId, _joinAddr, swapedColl);\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n\n        logger.Log(address(this), msg.sender, \"MCDBoost\", abi.encode(_cdpId, user, _exchangeData.srcAmount, swapedColl));\n    }\n\n    /// @notice Draws Dai from the CDP\n    /// @dev If _daiAmount is bigger than max available we'll draw max\n    /// @param _managerAddr Address of the CDP Manager\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    /// @param _daiAmount Amount of Dai to draw\n    function drawDai(address _managerAddr, uint _cdpId, bytes32 _ilk, uint _daiAmount) internal returns (uint) {\n        uint rate = Jug(JUG_ADDRESS).drip(_ilk);\n        uint daiVatBalance = vat.dai(Manager(_managerAddr).urns(_cdpId));\n\n        uint maxAmount = getMaxDebt(_managerAddr, _cdpId, _ilk);\n\n        if (_daiAmount >= maxAmount) {\n            _daiAmount = sub(maxAmount, 1);\n        }\n\n        Manager(_managerAddr).frob(_cdpId, int(0), normalizeDrawAmount(_daiAmount, rate, daiVatBalance));\n        Manager(_managerAddr).move(_cdpId, address(this), toRad(_daiAmount));\n\n        if (vat.can(address(this), address(DAI_JOIN_ADDRESS)) == 0) {\n            vat.hope(DAI_JOIN_ADDRESS);\n        }\n\n        DaiJoin(DAI_JOIN_ADDRESS).exit(address(this), _daiAmount);\n\n        return _daiAmount;\n    }\n\n    /// @notice Adds collateral to the CDP\n    /// @param _managerAddr Address of the CDP Manager\n    /// @param _cdpId Id of the CDP\n    /// @param _joinAddr Address of the join contract for the CDP collateral\n    /// @param _amount Amount of collateral to add\n    function addCollateral(address _managerAddr, uint _cdpId, address _joinAddr, uint _amount) internal {\n        int convertAmount = 0;\n\n        if (isEthJoinAddr(_joinAddr)) {\n            Join(_joinAddr).gem().deposit{value: _amount}();\n            convertAmount = toPositiveInt(_amount);\n        } else {\n            convertAmount = toPositiveInt(convertTo18(_joinAddr, _amount));\n        }\n\n        ERC20(address(Join(_joinAddr).gem())).safeApprove(_joinAddr, _amount);\n\n        Join(_joinAddr).join(address(this), _amount);\n\n        vat.frob(\n            Manager(_managerAddr).ilks(_cdpId),\n            Manager(_managerAddr).urns(_cdpId),\n            address(this),\n            address(this),\n            convertAmount,\n            0\n        );\n\n    }\n\n    /// @notice Draws collateral and returns it to DSProxy\n    /// @param _managerAddr Address of the CDP Manager\n    /// @dev If _amount is bigger than max available we'll draw max\n    /// @param _cdpId Id of the CDP\n    /// @param _joinAddr Address of the join contract for the CDP collateral\n    /// @param _amount Amount of collateral to draw\n    function drawCollateral(address _managerAddr, uint _cdpId, address _joinAddr, uint _amount) internal returns (uint) {\n        uint frobAmount = _amount;\n\n        if (Join(_joinAddr).dec() != 18) {\n            frobAmount = _amount * (10 ** (18 - Join(_joinAddr).dec()));\n        }\n\n        Manager(_managerAddr).frob(_cdpId, -toPositiveInt(frobAmount), 0);\n        Manager(_managerAddr).flux(_cdpId, address(this), frobAmount);\n\n        Join(_joinAddr).exit(address(this), _amount);\n\n        if (isEthJoinAddr(_joinAddr)) {\n            Join(_joinAddr).gem().withdraw(_amount); // Weth -> Eth\n        }\n\n        return _amount;\n    }\n\n    /// @notice Paybacks Dai debt\n    /// @param _managerAddr Address of the CDP Manager\n    /// @dev If the _daiAmount is bigger than the whole debt, returns extra Dai\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    /// @param _daiAmount Amount of Dai to payback\n    /// @param _owner Address that owns the DSProxy that owns the CDP\n    function paybackDebt(address _managerAddr, uint _cdpId, bytes32 _ilk, uint _daiAmount, address _owner) internal {\n        address urn = Manager(_managerAddr).urns(_cdpId);\n\n        uint wholeDebt = getAllDebt(VAT_ADDRESS, urn, urn, _ilk);\n\n        if (_daiAmount > wholeDebt) {\n            ERC20(DAI_ADDRESS).transfer(_owner, sub(_daiAmount, wholeDebt));\n            _daiAmount = wholeDebt;\n        }\n\n        if (ERC20(DAI_ADDRESS).allowance(address(this), DAI_JOIN_ADDRESS) == 0) {\n            ERC20(DAI_ADDRESS).approve(DAI_JOIN_ADDRESS, uint(-1));\n        }\n\n        daiJoin.join(urn, _daiAmount);\n\n        Manager(_managerAddr).frob(_cdpId, 0, normalizePaybackAmount(VAT_ADDRESS, urn, _ilk));\n    }\n\n    /// @notice Gets the maximum amount of collateral available to draw\n    /// @param _managerAddr Address of the CDP Manager\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    /// @param _joinAddr Joind address of collateral\n    /// @dev Substracts 10 wei to aviod rounding error later on\n    function getMaxCollateral(address _managerAddr, uint _cdpId, bytes32 _ilk, address _joinAddr) public view returns (uint) {\n        uint price = getPrice(_ilk);\n\n        (uint collateral, uint debt) = getCdpInfo(Manager(_managerAddr), _cdpId, _ilk);\n\n        (, uint mat) = Spotter(SPOTTER_ADDRESS).ilks(_ilk);\n\n        uint maxCollateral = sub(collateral, (div(mul(mat, debt), price)));\n\n        uint normalizeMaxCollateral = maxCollateral / (10 ** (18 - Join(_joinAddr).dec()));\n\n        // take one percent due to precision issues\n        return normalizeMaxCollateral * 99 / 100;\n    }\n\n    /// @notice Gets the maximum amount of debt available to generate\n    /// @param _managerAddr Address of the CDP Manager\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    /// @dev Substracts 10 wei to aviod rounding error later on\n    function getMaxDebt(address _managerAddr, uint _cdpId, bytes32 _ilk) public virtual view returns (uint) {\n        uint price = getPrice(_ilk);\n\n        (, uint mat) = spotter.ilks(_ilk);\n        (uint collateral, uint debt) = getCdpInfo(Manager(_managerAddr), _cdpId, _ilk);\n\n        return sub(sub(div(mul(collateral, price), mat), debt), 10);\n    }\n\n    /// @notice Gets a price of the asset\n    /// @param _ilk Ilk of the CDP\n    function getPrice(bytes32 _ilk) public view returns (uint) {\n        (, uint mat) = spotter.ilks(_ilk);\n        (,,uint spot,,) = vat.ilks(_ilk);\n\n        return rmul(rmul(spot, spotter.par()), mat);\n    }\n\n    function isAutomation() internal view returns(bool) {\n        return BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin);\n    }\n\n    function takeFee(uint256 _gasCost, uint _amount) internal returns(uint) {\n        if (_gasCost > 0) {\n            uint ethDaiPrice = getPrice(ETH_ILK);\n            uint feeAmount = rmul(_gasCost, ethDaiPrice);\n\n            if (feeAmount > _amount / 5) {\n                feeAmount = _amount / 5;\n            }\n\n            address walletAddr = _feeRecipient.getFeeAddr();\n\n            ERC20(DAI_ADDRESS).transfer(walletAddr, feeAmount);\n\n            return feeAmount;\n        }\n\n        return 0;\n    }\n}\n"
234     },
235     "contracts/interfaces/Spotter.sol": {
236       "content": "pragma solidity ^0.6.0;\n\nimport \"./PipInterface.sol\";\n\nabstract contract Spotter {\n    struct Ilk {\n        PipInterface pip;\n        uint256 mat;\n    }\n\n    mapping (bytes32 => Ilk) public ilks;\n\n    uint256 public par;\n\n}\n"
237     },
238     "contracts/interfaces/Jug.sol": {
239       "content": "pragma solidity ^0.6.0;\n\nabstract contract Jug {\n    struct Ilk {\n        uint256 duty;\n        uint256  rho;\n    }\n\n    mapping (bytes32 => Ilk) public ilks;\n\n    function drip(bytes32) public virtual returns (uint);\n}\n"
240     },
241     "contracts/interfaces/DaiJoin.sol": {
242       "content": "pragma solidity ^0.6.0;\n\nimport \"./Vat.sol\";\nimport \"./Gem.sol\";\n\nabstract contract DaiJoin {\n    function vat() public virtual returns (Vat);\n    function dai() public virtual returns (Gem);\n    function join(address, uint) public virtual payable;\n    function exit(address, uint) public virtual;\n}\n"
243     },
244     "contracts/mcd/saver/MCDSaverProxyHelper.sol": {
245       "content": "pragma solidity ^0.6.0;\n\nimport \"../../DS/DSMath.sol\";\nimport \"../../DS/DSProxy.sol\";\nimport \"../../interfaces/Manager.sol\";\nimport \"../../interfaces/Join.sol\";\nimport \"../../interfaces/Vat.sol\";\n\n/// @title Helper methods for MCDSaverProxy\ncontract MCDSaverProxyHelper is DSMath {\n\n    enum ManagerType { MCD, BPROTOCOL }\n\n    /// @notice Returns a normalized debt _amount based on the current rate\n    /// @param _amount Amount of dai to be normalized\n    /// @param _rate Current rate of the stability fee\n    /// @param _daiVatBalance Balance od Dai in the Vat for that CDP\n    function normalizeDrawAmount(uint _amount, uint _rate, uint _daiVatBalance) internal pure returns (int dart) {\n        if (_daiVatBalance < mul(_amount, RAY)) {\n            dart = toPositiveInt(sub(mul(_amount, RAY), _daiVatBalance) / _rate);\n            dart = mul(uint(dart), _rate) < mul(_amount, RAY) ? dart + 1 : dart;\n        }\n    }\n\n    /// @notice Converts a number to Rad percision\n    /// @param _wad The input number in wad percision\n    function toRad(uint _wad) internal pure returns (uint) {\n        return mul(_wad, 10 ** 27);\n    }\n\n    /// @notice Converts a number to 18 decimal percision\n    /// @param _joinAddr Join address of the collateral\n    /// @param _amount Number to be converted\n    function convertTo18(address _joinAddr, uint256 _amount) internal view returns (uint256) {\n        return mul(_amount, 10 ** (18 - Join(_joinAddr).dec()));\n    }\n\n    /// @notice Converts a uint to int and checks if positive\n    /// @param _x Number to be converted\n    function toPositiveInt(uint _x) internal pure returns (int y) {\n        y = int(_x);\n        require(y >= 0, \"int-overflow\");\n    }\n\n    /// @notice Gets Dai amount in Vat which can be added to Cdp\n    /// @param _vat Address of Vat contract\n    /// @param _urn Urn of the Cdp\n    /// @param _ilk Ilk of the Cdp\n    function normalizePaybackAmount(address _vat, address _urn, bytes32 _ilk) internal view returns (int amount) {\n        uint dai = Vat(_vat).dai(_urn);\n\n        (, uint rate,,,) = Vat(_vat).ilks(_ilk);\n        (, uint art) = Vat(_vat).urns(_ilk, _urn);\n\n        amount = toPositiveInt(dai / rate);\n        amount = uint(amount) <= art ? - amount : - toPositiveInt(art);\n    }\n\n    /// @notice Gets the whole debt of the CDP\n    /// @param _vat Address of Vat contract\n    /// @param _usr Address of the Dai holder\n    /// @param _urn Urn of the Cdp\n    /// @param _ilk Ilk of the Cdp\n    function getAllDebt(address _vat, address _usr, address _urn, bytes32 _ilk) internal view returns (uint daiAmount) {\n        (, uint rate,,,) = Vat(_vat).ilks(_ilk);\n        (, uint art) = Vat(_vat).urns(_ilk, _urn);\n        uint dai = Vat(_vat).dai(_usr);\n\n        uint rad = sub(mul(art, rate), dai);\n        daiAmount = rad / RAY;\n\n        daiAmount = mul(daiAmount, RAY) < rad ? daiAmount + 1 : daiAmount;\n    }\n\n    /// @notice Gets the token address from the Join contract\n    /// @param _joinAddr Address of the Join contract\n    function getCollateralAddr(address _joinAddr) internal view returns (address) {\n        return address(Join(_joinAddr).gem());\n    }\n\n    /// @notice Checks if the join address is one of the Ether coll. types\n    /// @param _joinAddr Join address to check\n    function isEthJoinAddr(address _joinAddr) internal view returns (bool) {\n        // if it's dai_join_addr don't check gem() it will fail\n        if (_joinAddr == 0x9759A6Ac90977b93B58547b4A71c78317f391A28) return false;\n\n        // if coll is weth it's and eth type coll\n        if (address(Join(_joinAddr).gem()) == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /// @notice Gets CDP info (collateral, debt)\n    /// @param _manager Manager contract\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    function getCdpInfo(Manager _manager, uint _cdpId, bytes32 _ilk) public view returns (uint, uint) {\n        address vat = _manager.vat();\n        address urn = _manager.urns(_cdpId);\n\n        (uint collateral, uint debt) = Vat(vat).urns(_ilk, urn);\n        (,uint rate,,,) = Vat(vat).ilks(_ilk);\n\n        return (collateral, rmul(debt, rate));\n    }\n\n    /// @notice Address that owns the DSProxy that owns the CDP\n    /// @param _manager Manager contract\n    /// @param _cdpId Id of the CDP\n    function getOwner(Manager _manager, uint _cdpId) public view returns (address) {\n        DSProxy proxy = DSProxy(uint160(_manager.owns(_cdpId)));\n\n        return proxy.owner();\n    }\n\n    /// @notice Based on the manager type returns the address\n    /// @param _managerType Type of vault manager to use\n    function getManagerAddr(ManagerType _managerType) public pure returns (address) {\n        if (_managerType == ManagerType.MCD) {\n            return 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\n        } else if (_managerType == ManagerType.BPROTOCOL) {\n            return 0x3f30c2381CD8B917Dd96EB2f1A4F96D91324BBed;\n        }\n    }\n}\n"
246     },
247     "contracts/interfaces/PipInterface.sol": {
248       "content": "pragma solidity ^0.6.0;\n\n\nabstract contract PipInterface {\n    function read() public virtual returns (bytes32);\n}\n"
249     },
250     "contracts/shifter/protocols/McdShifter.sol": {
251       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/ILoanShifter.sol\";\nimport \"../../mcd/saver/MCDSaverProxy.sol\";\nimport \"../../mcd/create/MCDCreateProxyActions.sol\";\n\ncontract McdShifter is MCDSaverProxy {\n\n    using SafeERC20 for ERC20;\n\n    Manager manager = Manager(0x5ef30b9986345249bc32d8928B7ee64DE9435E39);\n\n    address public constant OPEN_PROXY_ACTIONS = 0x6d0984E80a86f26c0dd564ca0CF74a8E9Da03305;\n\n    function getLoanAmount(uint _cdpId, address _joinAddr) public view virtual returns(uint loanAmount) {\n        bytes32 ilk = manager.ilks(_cdpId);\n\n        (, uint rate,,,) = vat.ilks(ilk);\n        (, uint art) = vat.urns(ilk, manager.urns(_cdpId));\n        uint dai = vat.dai(manager.urns(_cdpId));\n\n        uint rad = sub(mul(art, rate), dai);\n        loanAmount = rad / RAY;\n\n        loanAmount = mul(loanAmount, RAY) < rad ? loanAmount + 1 : loanAmount;\n    }\n\n    function close(\n        uint _cdpId,\n        address _joinAddr,\n        uint _loanAmount,\n        uint _collateral\n    ) public {\n        address owner = getOwner(manager, _cdpId);\n        bytes32 ilk = manager.ilks(_cdpId);\n        (uint maxColl, ) = getCdpInfo(manager, _cdpId, ilk);\n\n        // repay dai debt cdp\n        paybackDebt(address(manager), _cdpId, ilk, _loanAmount, owner);\n\n        maxColl = _collateral > maxColl ? maxColl : _collateral;\n\n        // withdraw collateral from cdp\n        drawCollateral(address(manager), _cdpId, _joinAddr, maxColl);\n\n        // send back to msg.sender\n        if (isEthJoinAddr(_joinAddr)) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20 collToken = ERC20(getCollateralAddr(_joinAddr));\n            collToken.safeTransfer(msg.sender, collToken.balanceOf(address(this)));\n        }\n    }\n\n    function open(\n        uint _cdpId,\n        address _joinAddr,\n        uint _debtAmount\n    ) public {\n\n        uint collAmount = 0;\n\n        if (isEthJoinAddr(_joinAddr)) {\n            collAmount = address(this).balance;\n        } else {\n            collAmount = ERC20(address(Join(_joinAddr).gem())).balanceOf(address(this));\n        }\n\n        if (_cdpId == 0) {\n            openAndWithdraw(collAmount, _debtAmount, address(this), _joinAddr);\n        } else {\n            // add collateral\n            addCollateral(address(manager), _cdpId, _joinAddr, collAmount);\n            // draw debt\n            drawDai(address(manager), _cdpId, manager.ilks(_cdpId), _debtAmount);\n        }\n\n        // transfer to repay FL\n        ERC20(DAI_ADDRESS).transfer(msg.sender, ERC20(DAI_ADDRESS).balanceOf(address(this)));\n\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }\n\n    function openAndWithdraw(uint _collAmount, uint _debtAmount, address _proxy, address _joinAddrTo) internal {\n        bytes32 ilk = Join(_joinAddrTo).ilk();\n\n        if (isEthJoinAddr(_joinAddrTo)) {\n            MCDCreateProxyActions(OPEN_PROXY_ACTIONS).openLockETHAndDraw{value: address(this).balance}(\n                address(manager),\n                JUG_ADDRESS,\n                _joinAddrTo,\n                DAI_JOIN_ADDRESS,\n                ilk,\n                _debtAmount,\n                _proxy\n            );\n        } else {\n            ERC20(getCollateralAddr(_joinAddrTo)).approve(OPEN_PROXY_ACTIONS, uint256(-1));\n\n            MCDCreateProxyActions(OPEN_PROXY_ACTIONS).openLockGemAndDraw(\n                address(manager),\n                JUG_ADDRESS,\n                _joinAddrTo,\n                DAI_JOIN_ADDRESS,\n                ilk,\n                _collAmount,\n                _debtAmount,\n                true,\n                _proxy\n            );\n        }\n    }\n\n}\n"
252     },
253     "contracts/mcd/create/MCDCreateProxyActions.sol": {
254       "content": "pragma solidity ^0.6.0;\n\n\nabstract contract GemLike {\n    function approve(address, uint256) public virtual;\n\n    function transfer(address, uint256) public virtual;\n\n    function transferFrom(address, address, uint256) public virtual;\n\n    function deposit() public virtual payable;\n\n    function withdraw(uint256) public virtual;\n}\n\n\nabstract contract ManagerLike {\n    function cdpCan(address, uint256, address) public virtual view returns (uint256);\n\n    function ilks(uint256) public virtual view returns (bytes32);\n\n    function owns(uint256) public virtual view returns (address);\n\n    function urns(uint256) public virtual view returns (address);\n\n    function vat() public virtual view returns (address);\n\n    function open(bytes32, address) public virtual returns (uint256);\n\n    function give(uint256, address) public virtual;\n\n    function cdpAllow(uint256, address, uint256) public virtual;\n\n    function urnAllow(address, uint256) public virtual;\n\n    function frob(uint256, int256, int256) public virtual;\n\n    function flux(uint256, address, uint256) public virtual;\n\n    function move(uint256, address, uint256) public virtual;\n\n    function exit(address, uint256, address, uint256) public virtual;\n\n    function quit(uint256, address) public virtual;\n\n    function enter(address, uint256) public virtual;\n\n    function shift(uint256, uint256) public virtual;\n}\n\n\nabstract contract VatLike {\n    function can(address, address) public virtual view returns (uint256);\n\n    function ilks(bytes32) public virtual view returns (uint256, uint256, uint256, uint256, uint256);\n\n    function dai(address) public virtual view returns (uint256);\n\n    function urns(bytes32, address) public virtual view returns (uint256, uint256);\n\n    function frob(bytes32, address, address, address, int256, int256) public virtual;\n\n    function hope(address) public virtual;\n\n    function move(address, address, uint256) public virtual;\n}\n\n\nabstract contract GemJoinLike {\n    function dec() public virtual returns (uint256);\n\n    function gem() public virtual returns (GemLike);\n\n    function join(address, uint256) public virtual payable;\n\n    function exit(address, uint256) public virtual;\n}\n\n\nabstract contract GNTJoinLike {\n    function bags(address) public virtual view returns (address);\n\n    function make(address) public virtual returns (address);\n}\n\n\nabstract contract DaiJoinLike {\n    function vat() public virtual returns (VatLike);\n\n    function dai() public virtual returns (GemLike);\n\n    function join(address, uint256) public virtual payable;\n\n    function exit(address, uint256) public virtual;\n}\n\n\nabstract contract HopeLike {\n    function hope(address) public virtual;\n\n    function nope(address) public virtual;\n}\n\n\nabstract contract ProxyRegistryInterface {\n    function build(address) public virtual returns (address);\n}\n\n\nabstract contract EndLike {\n    function fix(bytes32) public virtual view returns (uint256);\n\n    function cash(bytes32, uint256) public virtual;\n\n    function free(bytes32) public virtual;\n\n    function pack(uint256) public virtual;\n\n    function skim(bytes32, address) public virtual;\n}\n\n\nabstract contract JugLike {\n    function drip(bytes32) public virtual returns (uint256);\n}\n\n\nabstract contract PotLike {\n    function pie(address) public virtual view returns (uint256);\n\n    function drip() public virtual returns (uint256);\n\n    function join(uint256) public virtual;\n\n    function exit(uint256) public virtual;\n}\n\n\nabstract contract ProxyRegistryLike {\n    function proxies(address) public virtual view returns (address);\n\n    function build(address) public virtual returns (address);\n}\n\n\nabstract contract ProxyLike {\n    function owner() public virtual view returns (address);\n}\n\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// WARNING: These functions meant to be used as a a library for a DSProxy. Some are unsafe if you call them directly.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ncontract Common {\n    uint256 constant RAY = 10**27;\n\n    // Internal functions\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\n    }\n\n    // Public functions\n    // solhint-disable-next-line func-name-mixedcase\n    function daiJoin_join(address apt, address urn, uint256 wad) public {\n        // Gets DAI from the user's wallet\n        DaiJoinLike(apt).dai().transferFrom(msg.sender, address(this), wad);\n        // Approves adapter to take the DAI amount\n        DaiJoinLike(apt).dai().approve(apt, wad);\n        // Joins DAI into the vat\n        DaiJoinLike(apt).join(urn, wad);\n    }\n}\n\n\ncontract MCDCreateProxyActions is Common {\n    // Internal functions\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"sub-overflow\");\n    }\n\n    function toInt(uint256 x) internal pure returns (int256 y) {\n        y = int256(x);\n        require(y >= 0, \"int-overflow\");\n    }\n\n    function toRad(uint256 wad) internal pure returns (uint256 rad) {\n        rad = mul(wad, 10**27);\n    }\n\n    function convertTo18(address gemJoin, uint256 amt) internal returns (uint256 wad) {\n        // For those collaterals that have less than 18 decimals precision we need to do the conversion before passing to frob function\n        // Adapters will automatically handle the difference of precision\n        wad = mul(amt, 10**(18 - GemJoinLike(gemJoin).dec()));\n    }\n\n    function _getDrawDart(address vat, address jug, address urn, bytes32 ilk, uint256 wad)\n        internal\n        returns (int256 dart)\n    {\n        // Updates stability fee rate\n        uint256 rate = JugLike(jug).drip(ilk);\n\n        // Gets DAI balance of the urn in the vat\n        uint256 dai = VatLike(vat).dai(urn);\n\n        // If there was already enough DAI in the vat balance, just exits it without adding more debt\n        if (dai < mul(wad, RAY)) {\n            // Calculates the needed dart so together with the existing dai in the vat is enough to exit wad amount of DAI tokens\n            dart = toInt(sub(mul(wad, RAY), dai) / rate);\n            // This is neeeded due lack of precision. It might need to sum an extra dart wei (for the given DAI wad amount)\n            dart = mul(uint256(dart), rate) < mul(wad, RAY) ? dart + 1 : dart;\n        }\n    }\n\n    function _getWipeDart(address vat, uint256 dai, address urn, bytes32 ilk)\n        internal\n        view\n        returns (int256 dart)\n    {\n        // Gets actual rate from the vat\n        (, uint256 rate, , , ) = VatLike(vat).ilks(ilk);\n        // Gets actual art value of the urn\n        (, uint256 art) = VatLike(vat).urns(ilk, urn);\n\n        // Uses the whole dai balance in the vat to reduce the debt\n        dart = toInt(dai / rate);\n        // Checks the calculated dart is not higher than urn.art (total debt), otherwise uses its value\n        dart = uint256(dart) <= art ? -dart : -toInt(art);\n    }\n\n    function _getWipeAllWad(address vat, address usr, address urn, bytes32 ilk)\n        internal\n        view\n        returns (uint256 wad)\n    {\n        // Gets actual rate from the vat\n        (, uint256 rate, , , ) = VatLike(vat).ilks(ilk);\n        // Gets actual art value of the urn\n        (, uint256 art) = VatLike(vat).urns(ilk, urn);\n        // Gets actual dai amount in the urn\n        uint256 dai = VatLike(vat).dai(usr);\n\n        uint256 rad = sub(mul(art, rate), dai);\n        wad = rad / RAY;\n\n        // If the rad precision has some dust, it will need to request for 1 extra wad wei\n        wad = mul(wad, RAY) < rad ? wad + 1 : wad;\n    }\n\n    // Public functions\n\n    function transfer(address gem, address dst, uint256 wad) public {\n        GemLike(gem).transfer(dst, wad);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function ethJoin_join(address apt, address urn) public payable {\n        // Wraps ETH in WETH\n        GemJoinLike(apt).gem().deposit{value: msg.value}();\n        // Approves adapter to take the WETH amount\n        GemJoinLike(apt).gem().approve(address(apt), msg.value);\n        // Joins WETH collateral into the vat\n        GemJoinLike(apt).join(urn, msg.value);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function gemJoin_join(address apt, address urn, uint256 wad, bool transferFrom) public {\n        // Only executes for tokens that have approval/transferFrom implementation\n        if (transferFrom) {\n            // Gets token from the user's wallet\n            GemJoinLike(apt).gem().transferFrom(msg.sender, address(this), wad);\n            // Approves adapter to take the token amount\n            GemJoinLike(apt).gem().approve(apt, 0);\n            GemJoinLike(apt).gem().approve(apt, wad);\n        }\n        // Joins token collateral into the vat\n        GemJoinLike(apt).join(urn, wad);\n    }\n\n    function hope(address obj, address usr) public {\n        HopeLike(obj).hope(usr);\n    }\n\n    function nope(address obj, address usr) public {\n        HopeLike(obj).nope(usr);\n    }\n\n    function open(address manager, bytes32 ilk, address usr) public returns (uint256 cdp) {\n        cdp = ManagerLike(manager).open(ilk, usr);\n    }\n\n    function give(address manager, uint256 cdp, address usr) public {\n        ManagerLike(manager).give(cdp, usr);\n    }\n\n    function move(address manager, uint256 cdp, address dst, uint256 rad) public {\n        ManagerLike(manager).move(cdp, dst, rad);\n    }\n\n    function frob(address manager, uint256 cdp, int256 dink, int256 dart) public {\n        ManagerLike(manager).frob(cdp, dink, dart);\n    }\n\n    function lockETH(address manager, address ethJoin, uint256 cdp) public payable {\n        // Receives ETH amount, converts it to WETH and joins it into the vat\n        ethJoin_join(ethJoin, address(this));\n        // Locks WETH amount into the CDP\n        VatLike(ManagerLike(manager).vat()).frob(\n            ManagerLike(manager).ilks(cdp),\n            ManagerLike(manager).urns(cdp),\n            address(this),\n            address(this),\n            toInt(msg.value),\n            0\n        );\n    }\n\n    function lockGem(address manager, address gemJoin, uint256 cdp, uint256 wad, bool transferFrom)\n        public\n    {\n        // Takes token amount from user's wallet and joins into the vat\n        gemJoin_join(gemJoin, address(this), wad, transferFrom);\n        // Locks token amount into the CDP\n        VatLike(ManagerLike(manager).vat()).frob(\n            ManagerLike(manager).ilks(cdp),\n            ManagerLike(manager).urns(cdp),\n            address(this),\n            address(this),\n            toInt(convertTo18(gemJoin, wad)),\n            0\n        );\n    }\n\n    function draw(address manager, address jug, address daiJoin, uint256 cdp, uint256 wad) public {\n        address urn = ManagerLike(manager).urns(cdp);\n        address vat = ManagerLike(manager).vat();\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        // Generates debt in the CDP\n        frob(manager, cdp, 0, _getDrawDart(vat, jug, urn, ilk, wad));\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n        move(manager, cdp, address(this), toRad(wad));\n        // Allows adapter to access to proxy's DAI balance in the vat\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n            VatLike(vat).hope(daiJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        DaiJoinLike(daiJoin).exit(msg.sender, wad);\n    }\n\n    function lockETHAndDraw(\n        address manager,\n        address jug,\n        address ethJoin,\n        address daiJoin,\n        uint256 cdp,\n        uint256 wadD\n    ) public payable {\n        address urn = ManagerLike(manager).urns(cdp);\n        address vat = ManagerLike(manager).vat();\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        // Receives ETH amount, converts it to WETH and joins it into the vat\n        ethJoin_join(ethJoin, urn);\n        // Locks WETH amount into the CDP and generates debt\n        frob(manager, cdp, toInt(msg.value), _getDrawDart(vat, jug, urn, ilk, wadD));\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n        move(manager, cdp, address(this), toRad(wadD));\n        // Allows adapter to access to proxy's DAI balance in the vat\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n            VatLike(vat).hope(daiJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        DaiJoinLike(daiJoin).exit(msg.sender, wadD);\n    }\n\n    function openLockETHAndDraw(\n        address manager,\n        address jug,\n        address ethJoin,\n        address daiJoin,\n        bytes32 ilk,\n        uint256 wadD,\n        address owner\n    ) public payable returns (uint256 cdp) {\n        cdp = open(manager, ilk, address(this));\n        lockETHAndDraw(manager, jug, ethJoin, daiJoin, cdp, wadD);\n        give(manager, cdp, owner);\n    }\n\n    function lockGemAndDraw(\n        address manager,\n        address jug,\n        address gemJoin,\n        address daiJoin,\n        uint256 cdp,\n        uint256 wadC,\n        uint256 wadD,\n        bool transferFrom\n    ) public {\n        address urn = ManagerLike(manager).urns(cdp);\n        address vat = ManagerLike(manager).vat();\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        // Takes token amount from user's wallet and joins into the vat\n        gemJoin_join(gemJoin, urn, wadC, transferFrom);\n        // Locks token amount into the CDP and generates debt\n        frob(\n            manager,\n            cdp,\n            toInt(convertTo18(gemJoin, wadC)),\n            _getDrawDart(vat, jug, urn, ilk, wadD)\n        );\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n        move(manager, cdp, address(this), toRad(wadD));\n        // Allows adapter to access to proxy's DAI balance in the vat\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n            VatLike(vat).hope(daiJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        DaiJoinLike(daiJoin).exit(msg.sender, wadD);\n    }\n\n    function openLockGemAndDraw(\n        address manager,\n        address jug,\n        address gemJoin,\n        address daiJoin,\n        bytes32 ilk,\n        uint256 wadC,\n        uint256 wadD,\n        bool transferFrom,\n        address owner\n    ) public returns (uint256 cdp) {\n        cdp = open(manager, ilk, address(this));\n        lockGemAndDraw(manager, jug, gemJoin, daiJoin, cdp, wadC, wadD, transferFrom);\n        give(manager, cdp, owner);\n    }\n}\n"
255     },
256     "contracts/mcd/create/MCDCreateFlashLoan.sol": {
257       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../exchangeV3/DFSExchangeCore.sol\";\nimport \"./MCDCreateProxyActions.sol\";\nimport \"../../utils/FlashLoanReceiverBase.sol\";\nimport \"../../interfaces/Manager.sol\";\nimport \"../../interfaces/Join.sol\";\nimport \"../../DS/DSProxy.sol\";\nimport \"./MCDCreateTaker.sol\";\n\ncontract MCDCreateFlashLoan is DFSExchangeCore, AdminAuth, FlashLoanReceiverBase {\n    address public constant CREATE_PROXY_ACTIONS = 0x6d0984E80a86f26c0dd564ca0CF74a8E9Da03305;\n\n    uint public constant SERVICE_FEE = 400; // 0.25% Fee\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n\n    address public constant DAI_JOIN_ADDRESS = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\n    address public constant JUG_ADDRESS = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\n    address public constant MANAGER_ADDRESS = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\n\n    constructor() FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER) public {}\n\n    function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n\n        //check the contract has the specified balance\n        require(_amount <= getBalanceInternal(address(this), _reserve),\n            \"Invalid balance for the contract\");\n\n        (address proxy, bytes memory packedData) = abi.decode(_params, (address,bytes));\n        (MCDCreateTaker.CreateData memory createData, ExchangeData memory exchangeData) = abi.decode(packedData, (MCDCreateTaker.CreateData,ExchangeData));\n\n        exchangeData.dfsFeeDivider = SERVICE_FEE;\n        exchangeData.user = DSProxy(payable(proxy)).owner();\n\n        openAndLeverage(createData.collAmount, createData.daiAmount + _fee, createData.joinAddr, proxy, exchangeData);\n\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }\n\n    function openAndLeverage(\n        uint _collAmount,\n        uint _daiAmountAndFee,\n        address _joinAddr,\n        address _proxy,\n        ExchangeData memory _exchangeData\n    ) public {\n        (, uint256 collSwaped) = _sell(_exchangeData);\n\n        bytes32 ilk = Join(_joinAddr).ilk();\n\n        if (isEthJoinAddr(_joinAddr)) {\n            MCDCreateProxyActions(CREATE_PROXY_ACTIONS).openLockETHAndDraw{value: address(this).balance}(\n                MANAGER_ADDRESS,\n                JUG_ADDRESS,\n                _joinAddr,\n                DAI_JOIN_ADDRESS,\n                ilk,\n                _daiAmountAndFee,\n                _proxy\n            );\n        } else {\n            ERC20(address(Join(_joinAddr).gem())).safeApprove(CREATE_PROXY_ACTIONS, (_collAmount + collSwaped));\n\n            MCDCreateProxyActions(CREATE_PROXY_ACTIONS).openLockGemAndDraw(\n                MANAGER_ADDRESS,\n                JUG_ADDRESS,\n                _joinAddr,\n                DAI_JOIN_ADDRESS,\n                ilk,\n                (_collAmount + collSwaped),\n                _daiAmountAndFee,\n                true,\n                _proxy\n            );\n        }\n    }\n\n    /// @notice Checks if the join address is one of the Ether coll. types\n    /// @param _joinAddr Join address to check\n    function isEthJoinAddr(address _joinAddr) internal view returns (bool) {\n        // if it's dai_join_addr don't check gem() it will fail\n        if (_joinAddr == 0x9759A6Ac90977b93B58547b4A71c78317f391A28) return false;\n\n        // if coll is weth it's and eth type coll\n        if (address(Join(_joinAddr).gem()) == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) {\n            return true;\n        }\n\n        return false;\n    }\n\n    receive() external override(FlashLoanReceiverBase, DFSExchangeCore) payable {}\n}\n"
258     },
259     "contracts/mcd/create/MCDCreateTaker.sol": {
260       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../mcd/saver/MCDSaverProxy.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../exchangeV3/DFSExchangeData.sol\";\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../utils/GasBurner.sol\";\n\ncontract MCDCreateTaker is GasBurner {\n\n    using SafeERC20 for ERC20;\n\n    address payable public constant MCD_CREATE_FLASH_LOAN = 0x409F216aa8034a12135ab6b74Bf6444335004BBd;\n\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    // solhint-disable-next-line const-name-snakecase\n    Manager public constant manager = Manager(0x5ef30b9986345249bc32d8928B7ee64DE9435E39);\n\n    // solhint-disable-next-line const-name-snakecase\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\n\n    struct CreateData {\n        uint collAmount;\n        uint daiAmount;\n        address joinAddr;\n    }\n\n    function openWithLoan(\n        DFSExchangeData.ExchangeData memory _exchangeData,\n        CreateData memory _createData\n    ) public payable burnGas(20) {\n\n        MCD_CREATE_FLASH_LOAN.transfer(msg.value); //0x fee\n\n\n        if (!isEthJoinAddr(_createData.joinAddr)) {\n            ERC20(getCollateralAddr(_createData.joinAddr)).safeTransferFrom(msg.sender, address(this), _createData.collAmount);\n            ERC20(getCollateralAddr(_createData.joinAddr)).safeTransfer(MCD_CREATE_FLASH_LOAN, _createData.collAmount);\n        }\n\n        bytes memory packedData = _packData(_createData, _exchangeData);\n        bytes memory paramsData = abi.encode(address(this), packedData);\n\n        lendingPool.flashLoan(MCD_CREATE_FLASH_LOAN, DAI_ADDRESS, _createData.daiAmount, paramsData);\n\n        logger.Log(address(this), msg.sender, \"MCDCreate\", abi.encode(manager.last(address(this)), _createData.collAmount, _createData.daiAmount));\n    }\n\n    function getCollateralAddr(address _joinAddr) internal view returns (address) {\n        return address(Join(_joinAddr).gem());\n    }\n\n    /// @notice Checks if the join address is one of the Ether coll. types\n    /// @param _joinAddr Join address to check\n    function isEthJoinAddr(address _joinAddr) internal view returns (bool) {\n        // if it's dai_join_addr don't check gem() it will fail\n        if (_joinAddr == 0x9759A6Ac90977b93B58547b4A71c78317f391A28) return false;\n\n        // if coll is weth it's and eth type coll\n        if (address(Join(_joinAddr).gem()) == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function _packData(\n        CreateData memory _createData,\n        DFSExchangeData.ExchangeData memory _exchangeData\n    ) internal pure returns (bytes memory) {\n\n        return abi.encode(_createData, _exchangeData);\n    }\n}\n"
261     },
262     "contracts/mcd/saver/MCDSaverTaker.sol": {
263       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../saver/MCDSaverProxy.sol\";\nimport \"../../exchangeV3/DFSExchangeData.sol\";\nimport \"../../utils/GasBurner.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\n\ncontract MCDSaverTaker is MCDSaverProxy, GasBurner {\n\n    address payable public constant MCD_SAVER_FLASH_LOAN = 0xcBb5DbBCcFbf6aF8AF75d0cbD5646C73d847cd15;\n    address public constant AAVE_POOL_CORE = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    function boostWithLoan(\n        ExchangeData memory _exchangeData,\n        uint _cdpId,\n        uint _gasCost,\n        address _joinAddr,\n        ManagerType _managerType\n    ) public payable burnGas(25) {\n        address managerAddr = getManagerAddr(_managerType);\n\n        uint256 maxDebt = getMaxDebt(managerAddr, _cdpId, Manager(managerAddr).ilks(_cdpId));\n\n        uint maxLiq = getAvailableLiquidity(DAI_JOIN_ADDRESS);\n\n        if (maxDebt >= _exchangeData.srcAmount || maxLiq == 0) {\n            if (_exchangeData.srcAmount > maxDebt) {\n                _exchangeData.srcAmount = maxDebt;\n            }\n\n            boost(_exchangeData, _cdpId, _gasCost, _joinAddr, _managerType);\n            return;\n        }\n\n        uint256 loanAmount = sub(_exchangeData.srcAmount, maxDebt);\n        loanAmount = loanAmount > maxLiq ? maxLiq : loanAmount;\n\n        MCD_SAVER_FLASH_LOAN.transfer(msg.value); // 0x fee\n\n        Manager(managerAddr).cdpAllow(_cdpId, MCD_SAVER_FLASH_LOAN, 1);\n\n        bytes memory paramsData = abi.encode(packExchangeData(_exchangeData), _cdpId, _gasCost, _joinAddr, false, uint8(_managerType));\n\n        lendingPool.flashLoan(MCD_SAVER_FLASH_LOAN, DAI_ADDRESS, loanAmount, paramsData);\n\n        Manager(managerAddr).cdpAllow(_cdpId, MCD_SAVER_FLASH_LOAN, 0);\n    }\n\n    function repayWithLoan(\n        ExchangeData memory _exchangeData,\n        uint _cdpId,\n        uint _gasCost,\n        address _joinAddr,\n        ManagerType _managerType\n    ) public payable burnGas(25) {\n        address managerAddr = getManagerAddr(_managerType);\n\n        uint256 maxColl = getMaxCollateral(managerAddr, _cdpId, Manager(managerAddr).ilks(_cdpId), _joinAddr);\n\n        uint maxLiq = getAvailableLiquidity(_joinAddr);\n\n        if (maxColl >= _exchangeData.srcAmount || maxLiq == 0) {\n            if (_exchangeData.srcAmount > maxColl) {\n                _exchangeData.srcAmount = maxColl;\n            }\n\n            repay(_exchangeData, _cdpId, _gasCost, _joinAddr, _managerType);\n            return;\n        }\n\n        uint256 loanAmount = sub(_exchangeData.srcAmount, maxColl);\n        loanAmount = loanAmount > maxLiq ? maxLiq : loanAmount;\n\n        MCD_SAVER_FLASH_LOAN.transfer(msg.value); // 0x fee\n\n        Manager(managerAddr).cdpAllow(_cdpId, MCD_SAVER_FLASH_LOAN, 1);\n\n        bytes memory paramsData = abi.encode(packExchangeData(_exchangeData), _cdpId, _gasCost, _joinAddr, true, uint8(_managerType));\n\n        lendingPool.flashLoan(MCD_SAVER_FLASH_LOAN, getAaveCollAddr(_joinAddr), loanAmount, paramsData);\n\n        Manager(managerAddr).cdpAllow(_cdpId, MCD_SAVER_FLASH_LOAN, 0);\n    }\n\n\n    /// @notice Gets the maximum amount of debt available to generate\n    /// @param _managerAddr Address of the CDP Manager\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    function getMaxDebt(address _managerAddr, uint256 _cdpId, bytes32 _ilk) public override view returns (uint256) {\n        uint256 price = getPrice(_ilk);\n\n        (, uint256 mat) = spotter.ilks(_ilk);\n        (uint256 collateral, uint256 debt) = getCdpInfo(Manager(_managerAddr), _cdpId, _ilk);\n\n        return sub(wdiv(wmul(collateral, price), mat), debt);\n    }\n\n    function getAaveCollAddr(address _joinAddr) internal view returns (address) {\n        if (isEthJoinAddr(_joinAddr)\n            || _joinAddr == 0x775787933e92b709f2a3C70aa87999696e74A9F8) {\n            return KYBER_ETH_ADDRESS;\n        } else if (_joinAddr == DAI_JOIN_ADDRESS) {\n            return DAI_ADDRESS;\n        } else\n         {\n            return getCollateralAddr(_joinAddr);\n        }\n    }\n\n    function getAvailableLiquidity(address _joinAddr) internal view returns (uint liquidity) {\n        address tokenAddr = getAaveCollAddr(_joinAddr);\n\n        if (tokenAddr == KYBER_ETH_ADDRESS) {\n            liquidity = AAVE_POOL_CORE.balance;\n        } else {\n            liquidity = ERC20(tokenAddr).balanceOf(AAVE_POOL_CORE);\n        }\n    }\n\n}\n"
264     },
265     "contracts/savings/aave/AaveSavingsProtocol.sol": {
266       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../ProtocolInterface.sol\";\nimport \"../../interfaces/IAToken.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../interfaces/ERC20.sol\";\nimport \"../../DS/DSAuth.sol\";\n\n\ncontract AaveSavingsProtocol is ProtocolInterface, DSAuth {\n\n    address public constant ADAI_ADDRESS = 0xfC1E690f61EFd961294b3e1Ce3313fBD8aa4f85d;\n    address public constant AAVE_LENDING_POOL = 0x398eC7346DcD622eDc5ae82352F02bE94C62d119;\n    address public constant AAVE_LENDING_POOL_CORE = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    function deposit(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n        // get dai from user\n        require(ERC20(DAI_ADDRESS).transferFrom(_user, address(this), _amount));\n\n        ERC20(DAI_ADDRESS).approve(AAVE_LENDING_POOL_CORE, uint(-1));\n        ILendingPool(AAVE_LENDING_POOL).deposit(DAI_ADDRESS, _amount, 0);\n\n        ERC20(ADAI_ADDRESS).transfer(_user, ERC20(ADAI_ADDRESS).balanceOf(address(this)));\n    }\n\n    function withdraw(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n        require(ERC20(ADAI_ADDRESS).transferFrom(_user, address(this), _amount));\n\n        IAToken(ADAI_ADDRESS).redeem(_amount);\n\n        // return dai we have to user\n        ERC20(DAI_ADDRESS).transfer(_user, _amount);\n    }\n}\n"
267     },
268     "contracts/savings/fulcrum/FulcrumSavingsProtocol.sol": {
269       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../ProtocolInterface.sol\";\nimport \"../../interfaces/ERC20.sol\";\nimport \"../../interfaces/ITokenInterface.sol\";\nimport \"../../DS/DSAuth.sol\";\n\ncontract FulcrumSavingsProtocol is ProtocolInterface, DSAuth {\n\n    address public constant NEW_IDAI_ADDRESS = 0x493C57C4763932315A328269E1ADaD09653B9081;\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    address public savingsProxy;\n    uint public decimals = 10 ** 18;\n\n    function addSavingsProxy(address _savingsProxy) public auth {\n        savingsProxy = _savingsProxy;\n    }\n\n    function deposit(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n\n        // get dai from user\n        require(ERC20(DAI_ADDRESS).transferFrom(_user, address(this), _amount));\n\n        // approve dai to Fulcrum\n        ERC20(DAI_ADDRESS).approve(NEW_IDAI_ADDRESS, uint(-1));\n\n        // mint iDai\n        ITokenInterface(NEW_IDAI_ADDRESS).mint(_user, _amount);\n    }\n\n    function withdraw(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n\n        // transfer all users tokens to our contract\n        require(ERC20(NEW_IDAI_ADDRESS).transferFrom(_user, address(this), ITokenInterface(NEW_IDAI_ADDRESS).balanceOf(_user)));\n\n        // approve iDai to that contract\n        ERC20(NEW_IDAI_ADDRESS).approve(NEW_IDAI_ADDRESS, uint(-1));\n        uint tokenPrice = ITokenInterface(NEW_IDAI_ADDRESS).tokenPrice();\n\n        // get dai from iDai contract\n        ITokenInterface(NEW_IDAI_ADDRESS).burn(_user, _amount * decimals / tokenPrice);\n\n        // return all remaining tokens back to user\n        require(ERC20(NEW_IDAI_ADDRESS).transfer(_user, ITokenInterface(NEW_IDAI_ADDRESS).balanceOf(address(this))));\n    }\n}\n"
270     },
271     "contracts/savings/dydx/DydxSavingsProtocol.sol": {
272       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../ProtocolInterface.sol\";\nimport \"./ISoloMargin.sol\";\nimport \"../../interfaces/ERC20.sol\";\nimport \"../../DS/DSAuth.sol\";\n\ncontract DydxSavingsProtocol is ProtocolInterface, DSAuth {\n    address public constant SOLO_MARGIN_ADDRESS = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\n\n    ISoloMargin public soloMargin;\n    address public savingsProxy;\n\n    uint daiMarketId = 3;\n\n    constructor() public {\n        soloMargin = ISoloMargin(SOLO_MARGIN_ADDRESS);\n    }\n\n    function addSavingsProxy(address _savingsProxy) public auth {\n        savingsProxy = _savingsProxy;\n    }\n\n    function deposit(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n\n        Account.Info[] memory accounts = new Account.Info[](1);\n        accounts[0] = getAccount(_user, 0);\n\n        Actions.ActionArgs[] memory actions = new Actions.ActionArgs[](1);\n        Types.AssetAmount memory amount = Types.AssetAmount({\n            sign: true,\n            denomination: Types.AssetDenomination.Wei,\n            ref: Types.AssetReference.Delta,\n            value: _amount\n        });\n\n        actions[0] = Actions.ActionArgs({\n            actionType: Actions.ActionType.Deposit,\n            accountId: 0,\n            amount: amount,\n            primaryMarketId: daiMarketId,\n            otherAddress: _user,\n            secondaryMarketId: 0, //not used\n            otherAccountId: 0, //not used\n            data: \"\" //not used\n        });\n\n        soloMargin.operate(accounts, actions);\n    }\n\n    function withdraw(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n\n        Account.Info[] memory accounts = new Account.Info[](1);\n        accounts[0] = getAccount(_user, 0);\n\n        Actions.ActionArgs[] memory actions = new Actions.ActionArgs[](1);\n        Types.AssetAmount memory amount = Types.AssetAmount({\n            sign: false,\n            denomination: Types.AssetDenomination.Wei,\n            ref: Types.AssetReference.Delta,\n            value: _amount\n        });\n\n        actions[0] = Actions.ActionArgs({\n            actionType: Actions.ActionType.Withdraw,\n            accountId: 0,\n            amount: amount,\n            primaryMarketId: daiMarketId,\n            otherAddress: _user,\n            secondaryMarketId: 0, //not used\n            otherAccountId: 0, //not used\n            data: \"\" //not used\n        });\n\n        soloMargin.operate(accounts, actions);\n    }\n\n    function getWeiBalance(address _user, uint _index) public view returns(Types.Wei memory) {\n\n        Types.Wei[] memory weiBalances;\n        (,,weiBalances) = soloMargin.getAccountBalances(getAccount(_user, _index));\n\n        return weiBalances[daiMarketId];\n    }\n\n    function getParBalance(address _user, uint _index) public view returns(Types.Par memory) {\n        Types.Par[] memory parBalances;\n        (,parBalances,) = soloMargin.getAccountBalances(getAccount(_user, _index));\n\n        return parBalances[daiMarketId];\n    }\n\n    function getAccount(address _user, uint _index) public pure returns(Account.Info memory) {\n        Account.Info memory account = Account.Info({\n            owner: _user,\n            number: _index\n        });\n\n        return account;\n    }\n}\n"
273     },
274     "contracts/reflexer/saver/RAISaverFlashLoan.sol": {
275       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./RAISaverTaker.sol\";\nimport \"../saver/RAISaverProxy.sol\";\nimport \"../../savings/dydx/ISoloMargin.sol\";\nimport \"../../exchangeV3/DFSExchangeCore.sol\";\n\ncontract RAISaverFlashLoan is RAISaverProxy, AdminAuth {\n\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    function callFunction(\n        address,\n        Account.Info memory,\n        bytes memory _params\n    ) public {\n\n        (\n            bytes memory exDataBytes ,\n            RAISaverTaker.SaverData memory saverData\n        )\n         = abi.decode(_params, (bytes, RAISaverTaker.SaverData));\n\n\n        ExchangeData memory exchangeData = unpackExchangeData(exDataBytes);\n\n        address managerAddr = getManagerAddr(saverData.managerType);\n        address userProxy = ISAFEManager(managerAddr).ownsSAFE(saverData.safeId);\n\n        if (saverData.isRepay) {\n            repayWithLoan(exchangeData, saverData);\n        } else {\n            boostWithLoan(exchangeData, saverData);\n        }\n\n        // payback FL, assumes we have weth\n        TokenInterface(WETH_ADDR).deposit{value: (address(this).balance)}();\n        ERC20(WETH_ADDR).safeTransfer(userProxy, (saverData.flAmount + 2));\n    }\n\n    function boostWithLoan(\n        ExchangeData memory _exchangeData,\n        RAISaverTaker.SaverData memory _saverData\n    ) internal {\n\n        address managerAddr = getManagerAddr(_saverData.managerType);\n        address user = getOwner(ISAFEManager(managerAddr), _saverData.safeId);\n        bytes32 collType = ISAFEManager(managerAddr).collateralTypes(_saverData.safeId);\n\n        addCollateral(managerAddr, _saverData.safeId, _saverData.joinAddr, _saverData.flAmount, false);\n\n        // Draw users Rai\n        uint raiDrawn = drawRai(managerAddr, _saverData.safeId, collType, _exchangeData.srcAmount);\n\n        // Swap\n        _exchangeData.srcAmount = raiDrawn - takeFee(_saverData.gasCost, raiDrawn);\n        _exchangeData.user = user;\n        _exchangeData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\n\n        (, uint swapedAmount) = _sell(_exchangeData);\n\n        // Return collateral\n        addCollateral(managerAddr, _saverData.safeId, _saverData.joinAddr, swapedAmount, true);\n        // Draw collateral to repay the flash loan\n        drawCollateral(managerAddr, _saverData.safeId, _saverData.joinAddr, _saverData.flAmount, false);\n\n        logger.Log(address(this), msg.sender, \"RAIFlashBoost\", abi.encode(_saverData.safeId, user, _exchangeData.srcAmount, swapedAmount));\n    }\n\n    function repayWithLoan(\n        ExchangeData memory _exchangeData,\n        RAISaverTaker.SaverData memory _saverData\n    ) internal {\n\n        TokenInterface(WETH_ADDR).withdraw(_saverData.flAmount);\n\n        address managerAddr = getManagerAddr(_saverData.managerType);\n\n        address user = getOwner(ISAFEManager(managerAddr), _saverData.safeId);\n        bytes32 collType = ISAFEManager(managerAddr).collateralTypes(_saverData.safeId);\n\n        // Swap\n        _exchangeData.srcAmount = _saverData.flAmount;\n        _exchangeData.user = user;\n\n        _exchangeData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\n\n        (, uint paybackAmount) = _sell(_exchangeData);\n\n        paybackAmount -= takeFee(_saverData.gasCost, paybackAmount);\n        paybackAmount = limitLoanAmount(managerAddr, _saverData.safeId, collType, paybackAmount, user);\n\n        // Payback the debt\n        paybackDebt(managerAddr, _saverData.safeId, collType, paybackAmount, user);\n\n        // Draw collateral to repay the flash loan\n        drawCollateral(managerAddr, _saverData.safeId, _saverData.joinAddr, _saverData.flAmount, false);\n\n        logger.Log(address(this), msg.sender, \"RAIFlashRepay\", abi.encode(_saverData.safeId, user, _exchangeData.srcAmount, paybackAmount));\n    }\n\n    /// @notice Handles that the amount is not bigger than cdp debt and not dust\n    function limitLoanAmount(address _managerAddr, uint _safeId, bytes32 _collType, uint _paybackAmount, address _owner) internal returns (uint256) {\n        uint debt = getAllDebt(address(safeEngine), ISAFEManager(_managerAddr).safes(_safeId), ISAFEManager(_managerAddr).safes(_safeId), _collType);\n\n        if (_paybackAmount > debt) {\n            ERC20(RAI_ADDRESS).transfer(_owner, (_paybackAmount - debt));\n            return debt;\n        }\n\n        uint debtLeft = debt - _paybackAmount;\n\n        (,,,, uint dust,) = safeEngine.collateralTypes(_collType);\n        dust = dust / 10**27;\n\n        // Less than dust value\n        if (debtLeft < dust) {\n            uint amountOverDust = (dust - debtLeft);\n\n            ERC20(RAI_ADDRESS).transfer(_owner, amountOverDust);\n\n            return (_paybackAmount - amountOverDust);\n        }\n\n        return _paybackAmount;\n    }\n\n    receive() external override(DFSExchangeCore) payable {}\n\n}\n"
276     },
277     "contracts/aaveV2/saver/AaveSaverReceiverV2.sol": {
278       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../savings/dydx/ISoloMargin.sol\";\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\nimport \"../../DS/DSProxy.sol\";\nimport \"../AaveHelperV2.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../../exchangeV3/DFSExchangeData.sol\";\n\n/// @title Import Aave position from account to wallet\ncontract AaveSaverReceiverV2 is AaveHelperV2, AdminAuth, DFSExchangeData {\n\n    using SafeERC20 for ERC20;\n\n    address public constant AAVE_SAVER_PROXY = 0xBBCD23145Ab10C369c9e5D3b1D58506B0cD2ab44;\n    address public constant AAVE_BASIC_PROXY = 0xc17c8eB12Ba24D62E69fd57cbd504EEf418867f9;\n    address public constant AETH_ADDRESS = 0x030bA81f1c18d280636F32af80b9AAd02Cf0854e;\n\n    function callFunction(\n        address sender,\n        Account.Info memory account,\n        bytes memory data\n    ) public {\n        (\n            bytes memory exchangeDataBytes,\n            address market,\n            uint256 rateMode,\n            uint256 gasCost,\n            bool isRepay,\n            uint256 ethAmount,\n            uint256 txValue,\n            address user,\n            address proxy\n        )\n        = abi.decode(data, (bytes,address,uint256,uint256,bool,uint256,uint256,address,address));\n\n        // withdraw eth\n        TokenInterface(WETH_ADDRESS).withdraw(ethAmount);\n\n        // deposit eth on behalf of proxy\n        DSProxy(payable(proxy)).execute{value: ethAmount}(AAVE_BASIC_PROXY, abi.encodeWithSignature(\"deposit(address,address,uint256)\", market, ETH_ADDR, ethAmount));\n\n        bytes memory functionData = packFunctionCall(market, exchangeDataBytes, rateMode, gasCost, isRepay);\n        DSProxy(payable(proxy)).execute{value: txValue}(AAVE_SAVER_PROXY, functionData);\n\n        // withdraw deposited eth\n        DSProxy(payable(proxy)).execute(AAVE_BASIC_PROXY, abi.encodeWithSignature(\"withdraw(address,address,uint256)\", market, ETH_ADDR, ethAmount));\n\n        // deposit eth, get weth and return to sender\n        TokenInterface(WETH_ADDRESS).deposit.value(address(this).balance)();\n        ERC20(WETH_ADDRESS).safeTransfer(proxy, ethAmount+2);\n    }\n\n    function packFunctionCall(address _market, bytes memory _exchangeDataBytes, uint256 _rateMode, uint256 _gasCost, bool _isRepay) internal returns (bytes memory) {\n        ExchangeData memory exData = unpackExchangeData(_exchangeDataBytes);\n\n        bytes memory functionData;\n\n        if (_isRepay) {\n            functionData = abi.encodeWithSignature(\"repay(address,(address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256,uint256)\", _market, exData, _rateMode, _gasCost);\n        } else {\n            functionData = abi.encodeWithSignature(\"boost(address,(address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256,uint256)\", _market, exData, _rateMode, _gasCost);\n        }\n\n        return functionData;\n    }\n\n    /// @dev if contract receive eth, convert it to WETH\n    receive() external payable {\n        // deposit eth and get weth\n        if (msg.sender == owner) {\n            TokenInterface(WETH_ADDRESS).deposit.value(address(this).balance)();\n        }\n    }\n}\n"
279     },
280     "contracts/aaveV2/AaveHelperV2.sol": {
281       "content": "pragma solidity ^0.6.0;\n\nimport \"../DS/DSMath.sol\";\nimport \"../DS/DSProxy.sol\";\nimport \"../utils/Discount.sol\";\nimport \"../interfaces/IFeeRecipient.sol\";\nimport \"../interfaces/IAToken.sol\";\nimport \"../interfaces/ILendingPoolV2.sol\";\nimport \"../interfaces/IPriceOracleGetterAave.sol\";\nimport \"../interfaces/IAaveProtocolDataProviderV2.sol\";\n\nimport \"../utils/SafeERC20.sol\";\nimport \"../utils/BotRegistry.sol\";\n\ncontract AaveHelperV2 is DSMath {\n\n    using SafeERC20 for ERC20;\n\n    IFeeRecipient public constant feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);\n\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // mainnet\n\n    uint public constant MANUAL_SERVICE_FEE = 400; // 0.25% Fee\n    uint public constant AUTOMATIC_SERVICE_FEE = 333; // 0.3% Fee\n\n    address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;\n\n\taddress public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint public constant NINETY_NINE_PERCENT_WEI = 990000000000000000;\n    uint16 public constant AAVE_REFERRAL_CODE = 64;\n\n    uint public constant STABLE_ID = 1;\n    uint public constant VARIABLE_ID = 2;\n\n    /// @notice Calculates the gas cost for transaction\n    /// @param _oracleAddress address of oracle used\n    /// @param _amount Amount that is converted\n    /// @param _user Actuall user addr not DSProxy\n    /// @param _gasCost Ether amount of gas we are spending for tx\n    /// @param _tokenAddr token addr. of token we are getting for the fee\n    /// @return gasCost The amount we took for the gas cost\n    function getGasCost(address _oracleAddress, uint _amount, address _user, uint _gasCost, address _tokenAddr) internal returns (uint gasCost) {\n        if (_gasCost == 0) return 0;\n\n        // in case its ETH, we need to get price for WETH\n        // everywhere else  we still use ETH as thats the token we have in this moment\n        address priceToken = _tokenAddr == ETH_ADDR ? WETH_ADDRESS : _tokenAddr;\n        uint256 price = IPriceOracleGetterAave(_oracleAddress).getAssetPrice(priceToken);\n        _gasCost = wdiv(_gasCost, price) / (10 ** (18 - _getDecimals(_tokenAddr)));\n        gasCost = _gasCost;\n\n        // gas cost can't go over 20% of the whole amount\n        if (gasCost > (_amount / 5)) {\n            gasCost = _amount / 5;\n        }\n\n        address walletAddr = feeRecipient.getFeeAddr();\n\n        if (_tokenAddr == ETH_ADDR) {\n            payable(walletAddr).transfer(gasCost);\n        } else {\n            ERC20(_tokenAddr).safeTransfer(walletAddr, gasCost);\n        }\n    }\n\n\n    /// @notice Returns the owner of the DSProxy that called the contract\n    function getUserAddress() internal view returns (address) {\n        DSProxy proxy = DSProxy(payable(address(this)));\n\n        return proxy.owner();\n    }\n\n    /// @notice Approves token contract to pull underlying tokens from the DSProxy\n    /// @param _tokenAddr Token we are trying to approve\n    /// @param _caller Address which will gain the approval\n    function approveToken(address _tokenAddr, address _caller) internal {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeApprove(_caller, uint256(-1));\n        }\n    }\n\n    /// @notice Send specific amount from contract to specific user\n    /// @param _token Token we are trying to send\n    /// @param _user User that should receive funds\n    /// @param _amount Amount that should be sent\n    function sendContractBalance(address _token, address _user, uint _amount) internal {\n        if (_amount == 0) return;\n\n        if (_token == ETH_ADDR) {\n            payable(_user).transfer(_amount);\n        } else {\n            ERC20(_token).safeTransfer(_user, _amount);\n        }\n    }\n\n    function sendFullContractBalance(address _token, address _user) internal {\n        if (_token == ETH_ADDR) {\n            sendContractBalance(_token, _user, address(this).balance);\n        } else {\n            sendContractBalance(_token, _user, ERC20(_token).balanceOf(address(this)));\n        }\n    }\n\n    function _getDecimals(address _token) internal view returns (uint256) {\n        if (_token == ETH_ADDR) return 18;\n\n        return ERC20(_token).decimals();\n    }\n\n    function getDataProvider(address _market) internal view returns(IAaveProtocolDataProviderV2) {\n        return IAaveProtocolDataProviderV2(ILendingPoolAddressesProviderV2(_market).getAddress(0x0100000000000000000000000000000000000000000000000000000000000000));\n    }\n}\n"
282     },
283     "contracts/interfaces/ILendingPoolV2.sol": {
284       "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProviderV2 {\n  event LendingPoolUpdated(address indexed newAddress);\n  event ConfigurationAdminUpdated(address indexed newAddress);\n  event EmergencyAdminUpdated(address indexed newAddress);\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n  event PriceOracleUpdated(address indexed newAddress);\n  event LendingRateOracleUpdated(address indexed newAddress);\n  event ProxyCreated(bytes32 id, address indexed newAddress);\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n  function setAddress(bytes32 id, address newAddress) external;\n\n  function setAddressAsProxy(bytes32 id, address impl) external;\n\n  function getAddress(bytes32 id) external view returns (address);\n\n  function getLendingPool() external view returns (address);\n\n  function setLendingPoolImpl(address pool) external;\n\n  function getLendingPoolConfigurator() external view returns (address);\n\n  function setLendingPoolConfiguratorImpl(address configurator) external;\n\n  function getLendingPoolCollateralManager() external view returns (address);\n\n  function setLendingPoolCollateralManager(address manager) external;\n\n  function getPoolAdmin() external view returns (address);\n\n  function setPoolAdmin(address admin) external;\n\n  function getEmergencyAdmin() external view returns (address);\n\n  function setEmergencyAdmin(address admin) external;\n\n  function getPriceOracle() external view returns (address);\n\n  function setPriceOracle(address priceOracle) external;\n\n  function getLendingRateOracle() external view returns (address);\n\n  function setLendingRateOracle(address lendingRateOracle) external;\n}\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    uint256 data;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n}\n\ninterface ILendingPoolV2 {\n  /**\n   * @dev Emitted on deposit()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the deposit\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n   * @param amount The amount deposited\n   * @param referral The referral code used\n   **/\n  event Deposit(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlyng asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to Address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint256 borrowRateMode,\n    uint256 borrowRate,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address indexed initiator,\n    address indexed asset,\n    uint256 amount,\n    uint256 premium,\n    uint16 referralCode\n  );\n\n  /**\n   * @dev Emitted when the pause is triggered.\n   */\n  event Paused();\n\n  /**\n   * @dev Emitted when the pause is lifted.\n   */\n  event Unpaused();\n\n  /**\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n   * LendingPoolCollateral manager using a DELEGATECALL\n   * This allows to have the events in the generated ABI for LendingPool.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n   * gets added to the LendingPool ABI\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The new liquidity rate\n   * @param stableBorrowRate The new stable borrow rate\n   * @param variableBorrowRate The new variable borrow rate\n   * @param liquidityIndex The new liquidity index\n   * @param variableBorrowIndex The new variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external;\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   **/\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 rateMode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n   * @param asset The address of the underlying asset borrowed\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n  /**\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n   *        borrowed at a stable rate and depositors are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n   * @param asset The address of the underlying asset deposited\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n   * For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts amounts being flash-borrowed\n   * @param modes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralETH the total collateral in ETH of the user\n   * @return totalDebtETH the total debt in ETH of the user\n   * @return availableBorrowsETH the borrowing power left of the user\n   * @return currentLiquidationThreshold the liquidation threshold of the user\n   * @return ltv the loan to value of the user\n   * @return healthFactor the current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint256 totalCollateralETH,\n      uint256 totalDebtETH,\n      uint256 availableBorrowsETH,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  function initReserve(\n    address reserve,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\n    external;\n\n  function setConfiguration(address reserve, uint256 configuration) external;\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @dev Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @dev Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromAfter,\n    uint256 balanceToBefore\n  ) external;\n\n  function getReservesList() external view returns (address[] memory);\n\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProviderV2);\n\n  function setPause(bool val) external;\n\n  function paused() external view returns (bool);\n}\n\n"
285     },
286     "contracts/interfaces/IPriceOracleGetterAave.sol": {
287       "content": "pragma solidity ^0.6.0;\n\n/************\n@title IPriceOracleGetterAave interface\n@notice Interface for the Aave price oracle.*/\nabstract contract IPriceOracleGetterAave {\n    function getAssetPrice(address _asset) external virtual view returns (uint256);\n    function getAssetsPrices(address[] calldata _assets) external virtual view returns(uint256[] memory);\n    function getSourceOfAsset(address _asset) external virtual view returns(address);\n    function getFallbackOracle() external virtual view returns(address);\n}"
288     },
289     "contracts/interfaces/IAaveProtocolDataProviderV2.sol": {
290       "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nabstract contract IAaveProtocolDataProviderV2 {\n\n  struct TokenData {\n    string symbol;\n    address tokenAddress;\n  }\n\n  function getAllReservesTokens() external virtual view returns (TokenData[] memory);\n\n  function getAllATokens() external virtual view returns (TokenData[] memory);\n\n  function getReserveConfigurationData(address asset)\n    external virtual\n    view\n    returns (\n      uint256 decimals,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus,\n      uint256 reserveFactor,\n      bool usageAsCollateralEnabled,\n      bool borrowingEnabled,\n      bool stableBorrowRateEnabled,\n      bool isActive,\n      bool isFrozen\n    );\n\n  function getReserveData(address asset)\n    external virtual\n    view\n    returns (\n      uint256 availableLiquidity,\n      uint256 totalStableDebt,\n      uint256 totalVariableDebt,\n      uint256 liquidityRate,\n      uint256 variableBorrowRate,\n      uint256 stableBorrowRate,\n      uint256 averageStableBorrowRate,\n      uint256 liquidityIndex,\n      uint256 variableBorrowIndex,\n      uint40 lastUpdateTimestamp\n    );\n\n  function getUserReserveData(address asset, address user)\n    external virtual\n    view\n    returns (\n      uint256 currentATokenBalance,\n      uint256 currentStableDebt,\n      uint256 currentVariableDebt,\n      uint256 principalStableDebt,\n      uint256 scaledVariableDebt,\n      uint256 stableBorrowRate,\n      uint256 liquidityRate,\n      uint40 stableRateLastUpdated,\n      bool usageAsCollateralEnabled\n    );\n\n  function getReserveTokensAddresses(address asset)\n    external virtual\n    view\n    returns (\n      address aTokenAddress,\n      address stableDebtTokenAddress,\n      address variableDebtTokenAddress\n    );\n}"
291     },
292     "contracts/aaveV2/saver/optimized/AaveSaverTakerOV2.sol": {
293       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../AaveHelperV2.sol\";\nimport \"../../../utils/GasBurner.sol\";\nimport \"../../../auth/AdminAuth.sol\";\nimport \"../../../auth/ProxyPermission.sol\";\nimport \"../../../utils/DydxFlashLoanBase.sol\";\nimport \"../../../loggers/DefisaverLogger.sol\";\nimport \"../../../interfaces/ProxyRegistryInterface.sol\";\nimport \"../../../interfaces/TokenInterface.sol\";\nimport \"../../../interfaces/ERC20.sol\";\nimport \"../../../exchangeV3/DFSExchangeData.sol\";\n\n/// @title Import Aave position from account to wallet\n/// @dev Contract needs to have enough wei in WETH for all transactions (2 WETH wei per transaction)\ncontract AaveSaverTakerOV2 is ProxyPermission, GasBurner, DFSExchangeData, AaveHelperV2 {\n\n    address payable public constant AAVE_RECEIVER = 0xC8446F4244Fa9dDc90B3bB57Ca05e46A62Ba4e31;\n\n    // leaving _flAmount to be the same as the older version\n    function repay(address _market, ExchangeData memory _data, uint _rateMode, uint256 _gasCost, uint _flAmount) public payable burnGas(10) {\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\n\n        // send msg.value for exchange to the receiver\n        AAVE_RECEIVER.transfer(msg.value);\n\n        address[] memory assets = new address[](1);\n        assets[0] = _data.srcAddr;\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = _data.srcAmount;\n\n        // for repay we are using regular flash loan with paying back the flash loan + premium\n        uint256[] memory modes = new uint256[](1);\n        modes[0] = 0;\n\n        // create data\n        bytes memory encodedData = packExchangeData(_data);\n        bytes memory data = abi.encode(encodedData, _market, _gasCost, _rateMode, true, address(this));\n\n        // give permission to receiver and execute tx\n        givePermission(AAVE_RECEIVER);\n        ILendingPoolV2(lendingPool).flashLoan(AAVE_RECEIVER, assets, amounts, modes, address(this), data, AAVE_REFERRAL_CODE);\n        removePermission(AAVE_RECEIVER);\n    }\n\n    // leaving _flAmount to be the same as the older version\n    function boost(address _market, ExchangeData memory _data, uint _rateMode, uint256 _gasCost, uint _flAmount) public payable burnGas(10) {\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\n\n        // send msg.value for exchange to the receiver\n        AAVE_RECEIVER.transfer(msg.value);\n\n        address[] memory assets = new address[](1);\n        assets[0] = _data.srcAddr;\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = _data.srcAmount;\n\n        uint256[] memory modes = new uint256[](1);\n        modes[0] = _rateMode;\n\n        // create data\n        bytes memory encodedData = packExchangeData(_data);\n        bytes memory data = abi.encode(encodedData, _market, _gasCost, _rateMode, false, address(this));\n\n        // give permission to receiver and execute tx\n        givePermission(AAVE_RECEIVER);\n        ILendingPoolV2(lendingPool).flashLoan(AAVE_RECEIVER, assets, amounts, modes, address(this), data, AAVE_REFERRAL_CODE);\n        removePermission(AAVE_RECEIVER);\n    }\n}\n"
294     },
295     "contracts/interfaces/ProxyRegistryInterface.sol": {
296       "content": "pragma solidity ^0.6.0;\n\nimport \"./DSProxyInterface.sol\";\n\nabstract contract ProxyRegistryInterface {\n    function proxies(address _owner) public virtual view returns (address);\n    function build(address) public virtual returns (address);\n}\n"
297     },
298     "contracts/exchangeV3/wrappersV3/OasisTradeWrapperV3.sol": {
299       "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/ExchangeInterfaceV3.sol\";\nimport \"../../interfaces/OasisInterface.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\ncontract OasisTradeWrapperV3 is DSMath, ExchangeInterfaceV3, AdminAuth {\n\n    using SafeERC20 for ERC20;\n\n    address public constant OTC_ADDRESS = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Sells a _srcAmount of tokens at Oasis\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Destination amount\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) external override payable returns (uint) {\n        address srcAddr = ethToWethAddr(_srcAddr);\n        address destAddr = ethToWethAddr(_destAddr);\n\n        ERC20(srcAddr).safeApprove(OTC_ADDRESS, _srcAmount);\n\n        uint destAmount = OasisInterface(OTC_ADDRESS).sellAllAmount(srcAddr, _srcAmount, destAddr, 0);\n\n        // convert weth -> eth and send back\n        if (destAddr == WETH_ADDRESS) {\n            TokenInterface(WETH_ADDRESS).withdraw(destAmount);\n            msg.sender.transfer(destAmount);\n        } else {\n            ERC20(destAddr).safeTransfer(msg.sender, destAmount);\n        }\n\n        return destAmount;\n    }\n\n    /// @notice Buys a _destAmount of tokens at Oasis\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint srcAmount\n    function buy(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) external override payable returns(uint) {\n        address srcAddr = ethToWethAddr(_srcAddr);\n        address destAddr = ethToWethAddr(_destAddr);\n\n        ERC20(srcAddr).safeApprove(OTC_ADDRESS, uint(-1));\n\n        uint srcAmount = OasisInterface(OTC_ADDRESS).buyAllAmount(destAddr, _destAmount, srcAddr, uint(-1));\n\n        // convert weth -> eth and send back\n        if (destAddr == WETH_ADDRESS) {\n            TokenInterface(WETH_ADDRESS).withdraw(_destAmount);\n            msg.sender.transfer(_destAmount);\n        } else {\n            ERC20(destAddr).safeTransfer(msg.sender, _destAmount);\n        }\n\n        // Send the leftover from the source token back\n        sendLeftOver(srcAddr);\n\n        return srcAmount;\n    }\n\n    /// @notice Return a rate for which we can sell an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Rate\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) public override view returns (uint) {\n        address srcAddr = ethToWethAddr(_srcAddr);\n        address destAddr = ethToWethAddr(_destAddr);\n\n        return wdiv(OasisInterface(OTC_ADDRESS).getBuyAmount(destAddr, srcAddr, _srcAmount), _srcAmount);\n    }\n\n\n    /// @notice Return a rate for which we can buy an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint Rate\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) public override view returns (uint) {\n        address srcAddr = ethToWethAddr(_srcAddr);\n        address destAddr = ethToWethAddr(_destAddr);\n\n        return wdiv(1 ether, wdiv(OasisInterface(OTC_ADDRESS).getPayAmount(srcAddr, destAddr, _destAmount), _destAmount));\n    }\n\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\n    /// @param _srcAddr Source token address\n     function sendLeftOver(address _srcAddr) internal {\n        msg.sender.transfer(address(this).balance);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            ERC20(_srcAddr).safeTransfer(msg.sender, ERC20(_srcAddr).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Converts Kybers Eth address -> Weth\n    /// @param _src Input address\n    function ethToWethAddr(address _src) internal pure returns (address) {\n        return _src == KYBER_ETH_ADDRESS ? WETH_ADDRESS : _src;\n    }\n\n\n    receive() payable external {}\n}\n"
300     },
301     "contracts/interfaces/OasisInterface.sol": {
302       "content": "pragma solidity ^0.6.0;\n\nabstract contract OasisInterface {\n    function getBuyAmount(address tokenToBuy, address tokenToPay, uint256 amountToPay)\n        external\n        virtual\n        view\n        returns (uint256 amountBought);\n\n    function getPayAmount(address tokenToPay, address tokenToBuy, uint256 amountToBuy)\n        public virtual\n        view\n        returns (uint256 amountPaid);\n\n    function sellAllAmount(address pay_gem, uint256 pay_amt, address buy_gem, uint256 min_fill_amount)\n        public virtual\n        returns (uint256 fill_amt);\n\n    function buyAllAmount(address buy_gem, uint256 buy_amt, address pay_gem, uint256 max_fill_amount)\n        public virtual\n        returns (uint256 fill_amt);\n}\n"
303     },
304     "contracts/mcd/bids/BidProxy.sol": {
305       "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/Join.sol\";\nimport \"../../interfaces/ERC20.sol\";\nimport \"../../interfaces/Vat.sol\";\nimport \"../../interfaces/Flipper.sol\";\nimport \"../../interfaces/Gem.sol\";\n\ncontract BidProxy {\n\n    address public constant DAI_JOIN = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\n\n    address public constant VAT_ADDRESS = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    function daiBid(uint _bidId, uint _amount, address _flipper) public {\n        uint tendAmount = _amount * (10 ** 27);\n\n        joinDai(_amount);\n\n        (, uint lot, , , , , , ) = Flipper(_flipper).bids(_bidId);\n\n        Vat(VAT_ADDRESS).hope(_flipper);\n\n        Flipper(_flipper).tend(_bidId, lot, tendAmount);\n    }\n\n    function collateralBid(uint _bidId, uint _amount, address _flipper) public {\n        (uint bid, , , , , , , ) = Flipper(_flipper).bids(_bidId);\n\n        joinDai(bid / (10**27));\n\n        Vat(VAT_ADDRESS).hope(_flipper);\n\n        Flipper(_flipper).dent(_bidId, _amount, bid);\n    }\n\n    function closeBid(uint _bidId, address _flipper, address _joinAddr) public {\n        bytes32 ilk = Join(_joinAddr).ilk();\n\n        Flipper(_flipper).deal(_bidId);\n        uint amount = Vat(VAT_ADDRESS).gem(ilk, address(this));\n\n        Vat(VAT_ADDRESS).hope(_joinAddr);\n        Gem(_joinAddr).exit(msg.sender, amount);\n    }\n\n    function exitCollateral(address _joinAddr) public {\n        bytes32 ilk = Join(_joinAddr).ilk();\n\n        uint amount = Vat(VAT_ADDRESS).gem(ilk, address(this));\n\n        if(Join(_joinAddr).dec() != 18) {\n            amount = amount / (10**(18 - Join(_joinAddr).dec()));\n        }\n\n        Vat(VAT_ADDRESS).hope(_joinAddr);\n        Gem(_joinAddr).exit(msg.sender, amount);\n    }\n\n    function exitDai() public {\n        uint amount = Vat(VAT_ADDRESS).dai(address(this)) / (10**27);\n\n        Vat(VAT_ADDRESS).hope(DAI_JOIN);\n        Gem(DAI_JOIN).exit(msg.sender, amount);\n    }\n\n    function withdrawToken(address _token) public {\n        uint balance = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).transfer(msg.sender, balance);\n    }\n\n    function withdrawEth() public {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n\n    function joinDai(uint _amount) internal {\n        uint amountInVat = Vat(VAT_ADDRESS).dai(address(this)) / (10**27);\n\n        if (_amount > amountInVat) {\n            uint amountDiff = (_amount - amountInVat) + 1;\n\n            ERC20(DAI_ADDRESS).transferFrom(msg.sender, address(this), amountDiff);\n            ERC20(DAI_ADDRESS).approve(DAI_JOIN, amountDiff);\n            Join(DAI_JOIN).join(address(this), amountDiff);\n        }\n    }\n}\n"
306     },
307     "contracts/interfaces/Flipper.sol": {
308       "content": "pragma solidity ^0.6.0;\n\nabstract contract Flipper {\n    function bids(uint _bidId) public virtual returns (uint256, uint256, address, uint48, uint48, address, address, uint256);\n    function tend(uint id, uint lot, uint bid) virtual external;\n    function dent(uint id, uint lot, uint bid) virtual external;\n    function deal(uint id) virtual external;\n}\n"
309     },
310     "contracts/mcd/MCDLoanInfo.sol": {
311       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./saver/MCDSaverProxyHelper.sol\";\nimport \"../interfaces/Spotter.sol\";\n\ncontract MCDLoanInfo is MCDSaverProxyHelper {\n\n    Manager public constant manager = Manager(0x5ef30b9986345249bc32d8928B7ee64DE9435E39);\n    Vat public constant vat = Vat(0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B);\n    Spotter public constant spotter = Spotter(0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3);\n\n    struct VaultInfo {\n        address owner;\n        uint256 ratio;\n    \tuint256 collateral;\n    \tuint256 debt;\n    \tbytes32 ilk;\n    \taddress urn;\n    }\n\n\t/// @notice Gets a price of the asset\n    /// @param _ilk Ilk of the CDP\n    function getPrice(bytes32 _ilk) public view returns (uint) {\n        (, uint mat) = spotter.ilks(_ilk);\n        (,,uint spot,,) = vat.ilks(_ilk);\n\n        return rmul(rmul(spot, spotter.par()), mat);\n    }\n\n    /// @notice Gets CDP ratio\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    function getRatio(uint _cdpId, bytes32 _ilk) public view returns (uint) {\n        uint price = getPrice( _ilk);\n\n        (uint collateral, uint debt) = getCdpInfo(manager, _cdpId, _ilk);\n\n        if (debt == 0) return 0;\n\n        return rdiv(wmul(collateral, price), debt);\n    }\n\n    /// @notice Gets CDP info (collateral, debt, price, ilk)\n    /// @param _cdpId Id of the CDP\n    function getVaultInfo(uint _cdpId) public view returns (VaultInfo memory vaultInfo) {\n        address urn = manager.urns(_cdpId);\n        bytes32 ilk = manager.ilks(_cdpId);\n\n        (uint256 collateral, uint256 debt) = vat.urns(ilk, urn);\n        (,uint rate,,,) = vat.ilks(ilk);\n\n        debt = rmul(debt, rate);\n\n        vaultInfo = VaultInfo({\n            owner: manager.owns(_cdpId),\n            ratio: getRatio(_cdpId, ilk),\n            collateral: collateral,\n            debt: debt,\n            ilk: ilk,\n            urn: urn\n        });\n    }\n\n    function getVaultInfos(uint256[] memory _cdps) public view returns (VaultInfo[] memory vaultInfos) {\n    \tvaultInfos = new VaultInfo[](_cdps.length);\n\n    \tfor (uint256 i = 0; i < _cdps.length; i++) {\n    \t\tvaultInfos[i] = getVaultInfo(_cdps[i]);\n    \t}\n    }\n\n    function getRatios(uint256[] memory _cdps) public view returns (uint[] memory ratios) {\n    \tratios = new uint256[](_cdps.length);\n\n    \tfor (uint256 i = 0; i<_cdps.length; i++) {\n    \t\tbytes32 ilk = manager.ilks(_cdps[i]);\n\n    \t\tratios[i] = getRatio(_cdps[i], ilk);\n    \t}\n    }\n}"
312     },
313     "contracts/mcd/automaticV2/SubscriptionsV2.sol": {
314       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/Manager.sol\";\nimport \"./StaticV2.sol\";\nimport \"../saver/MCDSaverProxy.sol\";\nimport \"../../interfaces/Vat.sol\";\nimport \"../../interfaces/Spotter.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\n/// @title Handles subscriptions for automatic monitoring\ncontract SubscriptionsV2 is AdminAuth, StaticV2 {\n\n    bytes32 internal constant ETH_ILK = 0x4554482d41000000000000000000000000000000000000000000000000000000;\n    bytes32 internal constant BAT_ILK = 0x4241542d41000000000000000000000000000000000000000000000000000000;\n\n    address public constant MANAGER_ADDRESS = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\n    address public constant VAT_ADDRESS = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\n    address public constant SPOTTER_ADDRESS = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;\n\n    CdpHolder[] public subscribers;\n    mapping (uint => SubPosition) public subscribersPos;\n\n    mapping (bytes32 => uint) public minLimits;\n\n    uint public changeIndex;\n\n    Manager public manager = Manager(MANAGER_ADDRESS);\n    Vat public vat = Vat(VAT_ADDRESS);\n    Spotter public spotter = Spotter(SPOTTER_ADDRESS);\n    MCDSaverProxy public saverProxy;\n\n    event Subscribed(address indexed owner, uint cdpId);\n    event Unsubscribed(address indexed owner, uint cdpId);\n    event Updated(address indexed owner, uint cdpId);\n    event ParamUpdates(address indexed owner, uint cdpId, uint128, uint128, uint128, uint128, bool boostEnabled);\n\n    /// @param _saverProxy Address of the MCDSaverProxy contract\n    constructor(address _saverProxy) public {\n        saverProxy = MCDSaverProxy(payable(_saverProxy));\n\n        minLimits[ETH_ILK] = 1700000000000000000;\n        minLimits[BAT_ILK] = 1700000000000000000;\n    }\n\n    /// @dev Called by the DSProxy contract which owns the CDP\n    /// @notice Adds the users CDP in the list of subscriptions so it can be monitored\n    /// @param _cdpId Id of the CDP\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalBoost Ratio amount which boost should target\n    /// @param _optimalRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    /// @param _nextPriceEnabled Boolean determing if we can use nextPrice for this cdp\n    function subscribe(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled, bool _nextPriceEnabled) external {\n        require(isOwner(msg.sender, _cdpId), \"Must be called by Cdp owner\");\n\n        // if boost is not enabled, set max ratio to max uint\n        uint128 localMaxRatio = _boostEnabled ? _maxRatio : uint128(-1);\n        require(checkParams(manager.ilks(_cdpId), _minRatio, localMaxRatio), \"Must be correct params\");\n\n        SubPosition storage subInfo = subscribersPos[_cdpId];\n\n        CdpHolder memory subscription = CdpHolder({\n                minRatio: _minRatio,\n                maxRatio: localMaxRatio,\n                optimalRatioBoost: _optimalBoost,\n                optimalRatioRepay: _optimalRepay,\n                owner: msg.sender,\n                cdpId: _cdpId,\n                boostEnabled: _boostEnabled,\n                nextPriceEnabled: _nextPriceEnabled\n            });\n\n        changeIndex++;\n\n        if (subInfo.subscribed) {\n            subscribers[subInfo.arrPos] = subscription;\n\n            emit Updated(msg.sender, _cdpId);\n            emit ParamUpdates(msg.sender, _cdpId, _minRatio, localMaxRatio, _optimalBoost, _optimalRepay, _boostEnabled);\n        } else {\n            subscribers.push(subscription);\n\n            subInfo.arrPos = subscribers.length - 1;\n            subInfo.subscribed = true;\n\n            emit Subscribed(msg.sender, _cdpId);\n        }\n    }\n\n    /// @notice Called by the users DSProxy\n    /// @dev Owner who subscribed cancels his subscription\n    function unsubscribe(uint _cdpId) external {\n        require(isOwner(msg.sender, _cdpId), \"Must be called by Cdp owner\");\n\n        _unsubscribe(_cdpId);\n    }\n\n    /// @dev Checks if the _owner is the owner of the CDP\n    function isOwner(address _owner, uint _cdpId) internal view returns (bool) {\n        return getOwner(_cdpId) == _owner;\n    }\n\n    /// @dev Checks limit for minimum ratio and if minRatio is bigger than max\n    function checkParams(bytes32 _ilk, uint128 _minRatio, uint128 _maxRatio) internal view returns (bool) {\n        if (_minRatio < minLimits[_ilk]) {\n            return false;\n        }\n\n        if (_minRatio > _maxRatio) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @dev Internal method to remove a subscriber from the list\n    function _unsubscribe(uint _cdpId) internal {\n        require(subscribers.length > 0, \"Must have subscribers in the list\");\n\n        SubPosition storage subInfo = subscribersPos[_cdpId];\n\n        require(subInfo.subscribed, \"Must first be subscribed\");\n\n        uint lastCdpId = subscribers[subscribers.length - 1].cdpId;\n\n        SubPosition storage subInfo2 = subscribersPos[lastCdpId];\n        subInfo2.arrPos = subInfo.arrPos;\n\n        subscribers[subInfo.arrPos] = subscribers[subscribers.length - 1];\n        subscribers.pop();\n\n        changeIndex++;\n        subInfo.subscribed = false;\n        subInfo.arrPos = 0;\n\n        emit Unsubscribed(msg.sender, _cdpId);\n    }\n\n    /// @notice Returns an address that owns the CDP\n    /// @param _cdpId Id of the CDP\n    function getOwner(uint _cdpId) public view returns(address) {\n        return manager.owns(_cdpId);\n    }\n\n    /// @notice Helper method for the front to get all the info about the subscribed CDP\n    function getSubscribedInfo(uint _cdpId) public view returns(bool, uint128, uint128, uint128, uint128, address, uint coll, uint debt) {\n        SubPosition memory subInfo = subscribersPos[_cdpId];\n\n        if (!subInfo.subscribed) return (false, 0, 0, 0, 0, address(0), 0, 0);\n\n        (coll, debt) = saverProxy.getCdpInfo(manager, _cdpId, manager.ilks(_cdpId));\n\n        CdpHolder memory subscriber = subscribers[subInfo.arrPos];\n\n        return (\n            true,\n            subscriber.minRatio,\n            subscriber.maxRatio,\n            subscriber.optimalRatioRepay,\n            subscriber.optimalRatioBoost,\n            subscriber.owner,\n            coll,\n            debt\n        );\n    }\n\n    function getCdpHolder(uint _cdpId) public view returns (bool subscribed, CdpHolder memory) {\n        SubPosition memory subInfo = subscribersPos[_cdpId];\n\n        if (!subInfo.subscribed) return (false, CdpHolder(0, 0, 0, 0, address(0), 0, false, false));\n\n        CdpHolder memory subscriber = subscribers[subInfo.arrPos];\n\n        return (true, subscriber);\n    }\n\n    /// @notice Helper method for the front to get the information about the ilk of a CDP\n    function getIlkInfo(bytes32 _ilk, uint _cdpId) public view returns(bytes32 ilk, uint art, uint rate, uint spot, uint line, uint dust, uint mat, uint par) {\n        // send either ilk or cdpId\n        if (_ilk == bytes32(0)) {\n            _ilk = manager.ilks(_cdpId);\n        }\n\n        ilk = _ilk;\n        (,mat) = spotter.ilks(_ilk);\n        par = spotter.par();\n        (art, rate, spot, line, dust) = vat.ilks(_ilk);\n    }\n\n    /// @notice Helper method to return all the subscribed CDPs\n    function getSubscribers() public view returns (CdpHolder[] memory) {\n        return subscribers;\n    }\n\n    /// @notice Helper method to return all the subscribed CDPs\n    function getSubscribersByPage(uint _page, uint _perPage) public view returns (CdpHolder[] memory) {\n        CdpHolder[] memory holders = new CdpHolder[](_perPage);\n\n        uint start = _page * _perPage;\n        uint end = start + _perPage;\n\n        uint count = 0;\n        for (uint i=start; i<end; i++) {\n            holders[count] = subscribers[i];\n            count++;\n        }\n\n        return holders;\n    }\n\n    ////////////// ADMIN METHODS ///////////////////\n\n    /// @notice Admin function to change a min. limit for an asset\n    function changeMinRatios(bytes32 _ilk, uint _newRatio) public onlyOwner {\n        minLimits[_ilk] = _newRatio;\n    }\n\n    /// @notice Admin function to unsubscribe a CDP\n    function unsubscribeByAdmin(uint _cdpId) public onlyOwner {\n        SubPosition storage subInfo = subscribersPos[_cdpId];\n\n        if (subInfo.subscribed) {\n            _unsubscribe(_cdpId);\n        }\n    }\n}\n"
315     },
316     "contracts/mcd/automaticV2/StaticV2.sol": {
317       "content": "pragma solidity ^0.6.0;\n\n/// @title Implements enum Method\nabstract contract StaticV2 {\n\n    enum Method { Boost, Repay }\n\n    struct CdpHolder {\n        uint128 minRatio;\n        uint128 maxRatio;\n        uint128 optimalRatioBoost;\n        uint128 optimalRatioRepay;\n        address owner;\n        uint cdpId;\n        bool boostEnabled;\n        bool nextPriceEnabled;\n    }\n\n    struct SubPosition {\n        uint arrPos;\n        bool subscribed;\n    }\n}\n"
318     },
319     "contracts/mcd/automaticV2/MCDMonitorV2.sol": {
320       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/Manager.sol\";\nimport \"../../interfaces/Vat.sol\";\nimport \"../../interfaces/Spotter.sol\";\n\nimport \"../../DS/DSMath.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../utils/GasBurner.sol\";\nimport \"../../utils/BotRegistry.sol\";\nimport \"../../exchangeV3/DFSExchangeData.sol\";\n\nimport \"./ISubscriptionsV2.sol\";\nimport \"./StaticV2.sol\";\nimport \"./MCDMonitorProxyV2.sol\";\n\n\n/// @title Implements logic that allows bots to call Boost and Repay\ncontract MCDMonitorV2 is DSMath, AdminAuth, GasBurner, StaticV2 {\n\n    uint public REPAY_GAS_TOKEN = 25;\n    uint public BOOST_GAS_TOKEN = 25;\n\n    uint public MAX_GAS_PRICE = 800000000000; // 800 gwei\n\n    uint public REPAY_GAS_COST = 1000000;\n    uint public BOOST_GAS_COST = 1000000;\n\n    bytes4 public REPAY_SELECTOR = 0xf360ce20;\n    bytes4 public BOOST_SELECTOR = 0x8ec2ae25;\n\n    MCDMonitorProxyV2 public monitorProxyContract;\n    ISubscriptionsV2 public subscriptionsContract;\n    address public mcdSaverTakerAddress;\n\n    address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;\n\n    address public constant PROXY_PERMISSION_ADDR = 0x5a4f877CA808Cca3cB7c2A194F80Ab8588FAE26B;\n\n    Manager public manager = Manager(0x5ef30b9986345249bc32d8928B7ee64DE9435E39);\n    Vat public vat = Vat(0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B);\n    Spotter public spotter = Spotter(0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3);\n\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\n\n    modifier onlyApproved() {\n        require(BotRegistry(BOT_REGISTRY_ADDRESS).botList(msg.sender), \"Not auth bot\");\n        _;\n    }\n\n    constructor(address _monitorProxy, address _subscriptions, address _mcdSaverTakerAddress) public {\n        monitorProxyContract = MCDMonitorProxyV2(_monitorProxy);\n        subscriptionsContract = ISubscriptionsV2(_subscriptions);\n        mcdSaverTakerAddress = _mcdSaverTakerAddress;\n    }\n\n    /// @notice Bots call this method to repay for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    function repayFor(\n        DFSExchangeData.ExchangeData memory _exchangeData,\n        uint _cdpId,\n        uint _nextPrice,\n        address _joinAddr\n    ) public payable onlyApproved burnGas(REPAY_GAS_TOKEN) {\n\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Repay, _cdpId, _nextPrice);\n        require(isAllowed);\n\n        uint gasCost = calcGasCost(REPAY_GAS_COST);\n\n        address owner = subscriptionsContract.getOwner(_cdpId);\n\n        monitorProxyContract.callExecute{value: msg.value}(\n            owner,\n            mcdSaverTakerAddress,\n            abi.encodeWithSelector(REPAY_SELECTOR, _exchangeData, _cdpId, gasCost, _joinAddr, 0));\n\n\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Repay, _cdpId, _nextPrice);\n        require(isGoodRatio);\n\n        returnEth();\n\n        logger.Log(address(this), owner, \"AutomaticMCDRepay\", abi.encode(ratioBefore, ratioAfter));\n    }\n\n    /// @notice Bots call this method to boost for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    function boostFor(\n        DFSExchangeData.ExchangeData memory _exchangeData,\n        uint _cdpId,\n        uint _nextPrice,\n        address _joinAddr\n    ) public payable onlyApproved burnGas(BOOST_GAS_TOKEN)  {\n\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Boost, _cdpId, _nextPrice);\n        require(isAllowed);\n\n        uint gasCost = calcGasCost(BOOST_GAS_COST);\n\n        address owner = subscriptionsContract.getOwner(_cdpId);\n\n        monitorProxyContract.callExecute{value: msg.value}(\n            owner,\n            mcdSaverTakerAddress,\n            abi.encodeWithSelector(BOOST_SELECTOR, _exchangeData, _cdpId, gasCost, _joinAddr, 0));\n\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Boost, _cdpId, _nextPrice);\n        require(isGoodRatio);\n\n        returnEth();\n\n        logger.Log(address(this), owner, \"AutomaticMCDBoost\", abi.encode(ratioBefore, ratioAfter));\n    }\n\n/******************* INTERNAL METHODS ********************************/\n    function returnEth() internal {\n        // return if some eth left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n/******************* STATIC METHODS ********************************/\n\n    /// @notice Returns an address that owns the CDP\n    /// @param _cdpId Id of the CDP\n    function getOwner(uint _cdpId) public view returns(address) {\n        return manager.owns(_cdpId);\n    }\n\n    /// @notice Gets CDP info (collateral, debt)\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    function getCdpInfo(uint _cdpId, bytes32 _ilk) public view returns (uint, uint) {\n        address urn = manager.urns(_cdpId);\n\n        (uint collateral, uint debt) = vat.urns(_ilk, urn);\n        (,uint rate,,,) = vat.ilks(_ilk);\n\n        return (collateral, rmul(debt, rate));\n    }\n\n    /// @notice Gets a price of the asset\n    /// @param _ilk Ilk of the CDP\n    function getPrice(bytes32 _ilk) public view returns (uint) {\n        (, uint mat) = spotter.ilks(_ilk);\n        (,,uint spot,,) = vat.ilks(_ilk);\n\n        return rmul(rmul(spot, spotter.par()), mat);\n    }\n\n    /// @notice Gets CDP ratio\n    /// @param _cdpId Id of the CDP\n    /// @param _nextPrice Next price for user\n    function getRatio(uint _cdpId, uint _nextPrice) public view returns (uint) {\n        bytes32 ilk = manager.ilks(_cdpId);\n        uint price = (_nextPrice == 0) ? getPrice(ilk) : _nextPrice;\n\n        (uint collateral, uint debt) = getCdpInfo(_cdpId, ilk);\n\n        if (debt == 0) return 0;\n\n        return rdiv(wmul(collateral, price), debt) / (10 ** 18);\n    }\n\n    /// @notice Checks if Boost/Repay could be triggered for the CDP\n    /// @dev Called by MCDMonitor to enforce the min/max check\n    function canCall(Method _method, uint _cdpId, uint _nextPrice) public view returns(bool, uint) {\n        bool subscribed;\n        CdpHolder memory holder;\n        (subscribed, holder) = subscriptionsContract.getCdpHolder(_cdpId);\n\n        // check if cdp is subscribed\n        if (!subscribed) return (false, 0);\n\n        // check if using next price is allowed\n        if (_nextPrice > 0 && !holder.nextPriceEnabled) return (false, 0);\n\n        // check if boost and boost allowed\n        if (_method == Method.Boost && !holder.boostEnabled) return (false, 0);\n\n        // check if owner is still owner\n        if (getOwner(_cdpId) != holder.owner) return (false, 0);\n\n        uint currRatio = getRatio(_cdpId, _nextPrice);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.minRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.maxRatio, currRatio);\n        }\n    }\n\n    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call\n    function ratioGoodAfter(Method _method, uint _cdpId, uint _nextPrice) public view returns(bool, uint) {\n        CdpHolder memory holder;\n\n        (, holder) = subscriptionsContract.getCdpHolder(_cdpId);\n\n        uint currRatio = getRatio(_cdpId, _nextPrice);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.maxRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.minRatio, currRatio);\n        }\n    }\n\n    /// @notice Calculates gas cost (in Eth) of tx\n    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP\n    /// @param _gasAmount Amount of gas used for the tx\n    function calcGasCost(uint _gasAmount) public view returns (uint) {\n        uint gasPrice = tx.gasprice <= MAX_GAS_PRICE ? tx.gasprice : MAX_GAS_PRICE;\n\n        return mul(gasPrice, _gasAmount);\n    }\n\n/******************* OWNER ONLY OPERATIONS ********************************/\n\n    /// @notice Allows owner to change gas cost for boost operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for boost method\n    function changeBoostGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        BOOST_GAS_COST = _gasCost;\n    }\n\n    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for repay method\n    function changeRepayGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        REPAY_GAS_COST = _gasCost;\n    }\n\n    /// @notice Allows owner to change max gas price\n    /// @param _maxGasPrice New max gas price\n    function changeMaxGasPrice(uint _maxGasPrice) public onlyOwner {\n        require(_maxGasPrice < 1000000000000);\n\n        MAX_GAS_PRICE = _maxGasPrice;\n    }\n\n    /// @notice Allows owner to change the amount of gas token burned per function call\n    /// @param _gasAmount Amount of gas token\n    /// @param _isRepay Flag to know for which function we are setting the gas token amount\n    function changeGasTokenAmount(uint _gasAmount, bool _isRepay) public onlyOwner {\n        if (_isRepay) {\n            REPAY_GAS_TOKEN = _gasAmount;\n        } else {\n            BOOST_GAS_TOKEN = _gasAmount;\n        }\n    }\n}\n"
321     },
322     "contracts/mcd/automaticV2/ISubscriptionsV2.sol": {
323       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./StaticV2.sol\";\n\nabstract contract ISubscriptionsV2 is StaticV2 {\n\n    function getOwner(uint _cdpId) external view virtual returns(address);\n    function getSubscribedInfo(uint _cdpId) public view virtual returns(bool, uint128, uint128, uint128, uint128, address, uint coll, uint debt);\n    function getCdpHolder(uint _cdpId) public view virtual returns (bool subscribed, CdpHolder memory);\n}\n"
324     },
325     "contracts/mcd/automaticV2/MCDMonitorProxyV2.sol": {
326       "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/DSProxyInterface.sol\";\nimport \"../../interfaces/ERC20.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\n/// @title Implements logic for calling MCDSaverProxy always from same contract\ncontract MCDMonitorProxyV2 is AdminAuth {\n\n    uint public CHANGE_PERIOD;\n    uint public MIN_CHANGE_PERIOD = 6 * 1 hours;\n    address public monitor;\n    address public newMonitor;\n    address public lastMonitor;\n    uint public changeRequestedTimestamp;\n\n    event MonitorChangeInitiated(address oldMonitor, address newMonitor);\n    event MonitorChangeCanceled();\n    event MonitorChangeFinished(address monitor);\n    event MonitorChangeReverted(address monitor);\n\n    modifier onlyMonitor() {\n        require (msg.sender == monitor);\n        _;\n    }\n\n    constructor(uint _changePeriod) public {\n        CHANGE_PERIOD = _changePeriod * 1 hours;\n    }\n\n    /// @notice Only monitor contract is able to call execute on users proxy\n    /// @param _owner Address of cdp owner (users DSProxy address)\n    /// @param _saverProxy Address of MCDSaverProxy\n    /// @param _data Data to send to MCDSaverProxy\n    function callExecute(address _owner, address _saverProxy, bytes memory _data) public payable onlyMonitor {\n        // execute reverts if calling specific method fails\n        DSProxyInterface(_owner).execute{value: msg.value}(_saverProxy, _data);\n\n        // return if anything left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Allowed users are able to set Monitor contract without any waiting period first time\n    /// @param _monitor Address of Monitor contract\n    function setMonitor(address _monitor) public onlyOwner {\n        require(monitor == address(0));\n        monitor = _monitor;\n    }\n\n    /// @notice Allowed users are able to start procedure for changing monitor\n    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change\n    /// @param _newMonitor address of new monitor\n    function changeMonitor(address _newMonitor) public onlyOwner {\n        require(changeRequestedTimestamp == 0);\n\n        changeRequestedTimestamp = now;\n        lastMonitor = monitor;\n        newMonitor = _newMonitor;\n\n        emit MonitorChangeInitiated(lastMonitor, newMonitor);\n    }\n\n    /// @notice At any point allowed users are able to cancel monitor change\n    function cancelMonitorChange() public onlyOwner {\n        require(changeRequestedTimestamp > 0);\n\n        changeRequestedTimestamp = 0;\n        newMonitor = address(0);\n\n        emit MonitorChangeCanceled();\n    }\n\n    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started\n    function confirmNewMonitor() public onlyOwner {\n        require((changeRequestedTimestamp + CHANGE_PERIOD) < now);\n        require(changeRequestedTimestamp != 0);\n        require(newMonitor != address(0));\n\n        monitor = newMonitor;\n        newMonitor = address(0);\n        changeRequestedTimestamp = 0;\n\n        emit MonitorChangeFinished(monitor);\n    }\n\n    /// @notice Its possible to revert monitor to last used monitor\n    function revertMonitor() public onlyOwner {\n        require(lastMonitor != address(0));\n\n        monitor = lastMonitor;\n\n        emit MonitorChangeReverted(monitor);\n    }\n\n    function setChangePeriod(uint _periodInHours) public onlyOwner {\n        require(_periodInHours * 1 hours > MIN_CHANGE_PERIOD);\n\n        CHANGE_PERIOD = _periodInHours * 1 hours;\n    }\n\n}\n"
327     },
328     "contracts/compound/helpers/CompoundSaverHelper.sol": {
329       "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/CEtherInterface.sol\";\nimport \"../../interfaces/CompoundOracleInterface.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../interfaces/ComptrollerInterface.sol\";\nimport \"../../interfaces/IFeeRecipient.sol\";\n\nimport \"../../utils/Discount.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../DS/DSProxy.sol\";\nimport \"./Exponential.sol\";\nimport \"../../utils/BotRegistry.sol\";\n\nimport \"../../utils/SafeERC20.sol\";\n\n/// @title Utlity functions for Compound contracts\ncontract CompoundSaverHelper is DSMath, Exponential {\n\n    using SafeERC20 for ERC20;\n\n    IFeeRecipient public constant feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);\n\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    uint public constant MANUAL_SERVICE_FEE = 400; // 0.25% Fee\n    uint public constant AUTOMATIC_SERVICE_FEE = 333; // 0.3% Fee\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant CETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n    address public constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    address public constant COMPOUND_LOGGER = 0x3DD0CDf5fFA28C6847B4B276e2fD256046a44bb7;\n\n    address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;\n\n    /// @notice Helper method to payback the Compound debt\n    /// @dev If amount is bigger it will repay the whole debt and send the extra to the _user\n    /// @param _amount Amount of tokens we want to repay\n    /// @param _cBorrowToken Ctoken address we are repaying\n    /// @param _borrowToken Token address we are repaying\n    /// @param _user Owner of the compound position we are paying back\n    function paybackDebt(uint _amount, address _cBorrowToken, address _borrowToken, address payable _user) internal {\n        uint wholeDebt = CTokenInterface(_cBorrowToken).borrowBalanceCurrent(address(this));\n\n        if (_amount > wholeDebt) {\n            if (_borrowToken == ETH_ADDRESS) {\n                _user.transfer((_amount - wholeDebt));\n            } else {\n                ERC20(_borrowToken).safeTransfer(_user, (_amount - wholeDebt));\n            }\n\n            _amount = wholeDebt;\n        }\n\n        approveCToken(_borrowToken, _cBorrowToken);\n\n        if (_borrowToken == ETH_ADDRESS) {\n            CEtherInterface(_cBorrowToken).repayBorrow{value: _amount}();\n        } else {\n            require(CTokenInterface(_cBorrowToken).repayBorrow(_amount) == 0);\n        }\n    }\n\n    /// @notice Calculates the fee amount\n    /// @param _amount Amount that is converted\n    /// @param _user Actuall user addr not DSProxy\n    /// @param _gasCost Ether amount of gas we are spending for tx\n    /// @param _cTokenAddr CToken addr. of token we are getting for the fee\n    /// @return feeAmount The amount we took for the fee\n    function getFee(uint _amount, address _user, uint _gasCost, address _cTokenAddr) internal returns (uint feeAmount) {\n        uint fee = MANUAL_SERVICE_FEE;\n\n        if (BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin)) {\n            fee = AUTOMATIC_SERVICE_FEE;\n        }\n\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\n\n        if (Discount(DISCOUNT_ADDR).isCustomFeeSet(_user)) {\n            fee = Discount(DISCOUNT_ADDR).getCustomServiceFee(_user);\n        }\n\n        feeAmount = (fee == 0) ? 0 : (_amount / fee);\n\n        if (_gasCost != 0) {\n            address oracle = ComptrollerInterface(COMPTROLLER).oracle();\n\n            uint usdTokenPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cTokenAddr);\n            uint ethPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(CETH_ADDRESS);\n\n            uint tokenPriceInEth = wdiv(usdTokenPrice, ethPrice);\n\n            _gasCost = wdiv(_gasCost, tokenPriceInEth);\n\n            feeAmount = add(feeAmount, _gasCost);\n        }\n\n        // fee can't go over 20% of the whole amount\n        if (feeAmount > (_amount / 5)) {\n            feeAmount = _amount / 5;\n        }\n\n        address walletAddr = feeRecipient.getFeeAddr();\n\n        if (tokenAddr == ETH_ADDRESS) {\n            payable(walletAddr).transfer(feeAmount);\n        } else {\n            ERC20(tokenAddr).safeTransfer(walletAddr, feeAmount);\n        }\n    }\n\n    /// @notice Calculates the gas cost of transaction and send it to wallet\n    /// @param _amount Amount that is converted\n    /// @param _gasCost Ether amount of gas we are spending for tx\n    /// @param _cTokenAddr CToken addr. of token we are getting for the fee\n    /// @return feeAmount The amount we took for the fee\n    function getGasCost(uint _amount, uint _gasCost, address _cTokenAddr) internal returns (uint feeAmount) {\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\n\n        if (_gasCost != 0) {\n            address oracle = ComptrollerInterface(COMPTROLLER).oracle();\n\n            uint usdTokenPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cTokenAddr);\n            uint ethPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(CETH_ADDRESS);\n\n            uint tokenPriceInEth = wdiv(usdTokenPrice, ethPrice);\n\n            feeAmount = wdiv(_gasCost, tokenPriceInEth);\n        }\n\n        // fee can't go over 20% of the whole amount\n        if (feeAmount > (_amount / 5)) {\n            feeAmount = _amount / 5;\n        }\n\n        address walletAddr = feeRecipient.getFeeAddr();\n\n        if (tokenAddr == ETH_ADDRESS) {\n            payable(walletAddr).transfer(feeAmount);\n        } else {\n            ERC20(tokenAddr).safeTransfer(walletAddr, feeAmount);\n        }\n    }\n\n    /// @notice Enters the market for the collatera and borrow tokens\n    /// @param _cTokenAddrColl Collateral address we are entering the market in\n    /// @param _cTokenAddrBorrow Borrow address we are entering the market in\n    function enterMarket(address _cTokenAddrColl, address _cTokenAddrBorrow) internal {\n        address[] memory markets = new address[](2);\n        markets[0] = _cTokenAddrColl;\n        markets[1] = _cTokenAddrBorrow;\n\n        ComptrollerInterface(COMPTROLLER).enterMarkets(markets);\n    }\n\n    /// @notice Approves CToken contract to pull underlying tokens from the DSProxy\n    /// @param _tokenAddr Token we are trying to approve\n    /// @param _cTokenAddr Address which will gain the approval\n    function approveCToken(address _tokenAddr, address _cTokenAddr) internal {\n        if (_tokenAddr != ETH_ADDRESS) {\n            ERC20(_tokenAddr).safeApprove(_cTokenAddr, uint(-1));\n        }\n    }\n\n    /// @notice Returns the underlying address of the cToken asset\n    /// @param _cTokenAddress cToken address\n    /// @return Token address of the cToken specified\n    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\n        if (_cTokenAddress == CETH_ADDRESS) {\n            return ETH_ADDRESS;\n        } else {\n            return CTokenInterface(_cTokenAddress).underlying();\n        }\n    }\n\n    /// @notice Returns the owner of the DSProxy that called the contract\n    function getUserAddress() internal view returns (address) {\n        DSProxy proxy = DSProxy(uint160(address(this)));\n\n        return proxy.owner();\n    }\n\n    /// @notice Returns the maximum amount of collateral available to withdraw\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n    /// @param _cCollAddress Collateral we are getting the max value of\n    /// @param _account Users account\n    /// @return Returns the max. collateral amount in that token\n    function getMaxCollateral(address _cCollAddress, address _account) public returns (uint) {\n        (, uint liquidityInUsd, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n        uint usersBalance = CTokenInterface(_cCollAddress).balanceOfUnderlying(_account);\n        address oracle = ComptrollerInterface(COMPTROLLER).oracle();\n\n        if (liquidityInUsd == 0) return usersBalance;\n\n        CTokenInterface(_cCollAddress).accrueInterest();\n\n        (, uint collFactorMantissa) = ComptrollerInterface(COMPTROLLER).markets(_cCollAddress);\n        Exp memory collateralFactor = Exp({mantissa: collFactorMantissa});\n\n        (, uint tokensToUsd) = divScalarByExpTruncate(liquidityInUsd, collateralFactor);\n\n        uint usdPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cCollAddress);\n        uint liqInToken = wdiv(tokensToUsd, usdPrice);\n\n        if (liqInToken > usersBalance) return usersBalance;\n\n        return sub(liqInToken, (liqInToken / 100)); // cut off 1% due to rounding issues\n    }\n\n    /// @notice Returns the maximum amount of borrow amount available\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n    /// @param _cBorrowAddress Borrow token we are getting the max value of\n    /// @param _account Users account\n    /// @return Returns the max. borrow amount in that token\n    function getMaxBorrow(address _cBorrowAddress, address _account) public returns (uint) {\n        (, uint liquidityInUsd, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n        address oracle = ComptrollerInterface(COMPTROLLER).oracle();\n\n        CTokenInterface(_cBorrowAddress).accrueInterest();\n\n        uint usdPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cBorrowAddress);\n        uint liquidityInToken = wdiv(liquidityInUsd, usdPrice);\n\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\n    }\n\n    function isAutomation() internal view returns(bool) {\n        return BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin);\n    }\n}\n"
330     },
331     "contracts/shifter/protocols/CompShifter.sol": {
332       "content": "pragma solidity ^0.6.0;\n\nimport \"../../compound/helpers/CompoundSaverHelper.sol\";\n\ncontract CompShifter is CompoundSaverHelper {\n\n    using SafeERC20 for ERC20;\n\n    address public constant COMPTROLLER_ADDR = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    function getLoanAmount(uint _cdpId, address _joinAddr) public returns(uint loanAmount) {\n        return getWholeDebt(_cdpId, _joinAddr);\n    }\n\n    function getWholeDebt(uint _cdpId, address _joinAddr) public returns(uint loanAmount) {\n        return CTokenInterface(_joinAddr).borrowBalanceCurrent(msg.sender);\n    }\n\n    function close(\n        address _cCollAddr,\n        address _cBorrowAddr,\n        uint _collAmount,\n        uint _debtAmount\n    ) public {\n        address collAddr = getUnderlyingAddr(_cCollAddr);\n\n        // payback debt\n        paybackDebt(_debtAmount, _cBorrowAddr, getUnderlyingAddr(_cBorrowAddr), tx.origin);\n\n        require(CTokenInterface(_cCollAddr).redeemUnderlying(_collAmount) == 0);\n\n        // Send back money to repay FL\n        if (collAddr == ETH_ADDRESS) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20(collAddr).safeTransfer(msg.sender, ERC20(collAddr).balanceOf(address(this)));\n        }\n    }\n\n    function changeDebt(\n        address _cBorrowAddrOld,\n        address _cBorrowAddrNew,\n        uint _debtAmountOld,\n        uint _debtAmountNew\n    ) public {\n\n        address borrowAddrNew = getUnderlyingAddr(_cBorrowAddrNew);\n\n        // payback debt in one token\n        paybackDebt(_debtAmountOld, _cBorrowAddrOld, getUnderlyingAddr(_cBorrowAddrOld), tx.origin);\n\n        // draw debt in another one\n        borrowCompound(_cBorrowAddrNew, _debtAmountNew);\n\n        // Send back money to repay FL\n        if (borrowAddrNew == ETH_ADDRESS) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20(borrowAddrNew).safeTransfer(msg.sender, ERC20(borrowAddrNew).balanceOf(address(this)));\n        }\n    }\n\n    function open(\n        address _cCollAddr,\n        address _cBorrowAddr,\n        uint _debtAmount\n    ) public {\n\n        address collAddr = getUnderlyingAddr(_cCollAddr);\n        address borrowAddr = getUnderlyingAddr(_cBorrowAddr);\n\n        uint collAmount = 0;\n\n        if (collAddr == ETH_ADDRESS) {\n            collAmount = address(this).balance;\n        } else {\n            collAmount = ERC20(collAddr).balanceOf(address(this));\n        }\n\n        depositCompound(collAddr, _cCollAddr, collAmount);\n\n        // draw debt\n        borrowCompound(_cBorrowAddr, _debtAmount);\n\n        // Send back money to repay FL\n        if (borrowAddr == ETH_ADDRESS) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20(borrowAddr).safeTransfer(msg.sender, ERC20(borrowAddr).balanceOf(address(this)));\n        }\n\n    }\n\n    function repayAll(address _cTokenAddr) public {\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\n        uint amount = ERC20(tokenAddr).balanceOf(address(this));\n\n        if (amount != 0) {\n            paybackDebt(amount, _cTokenAddr, tokenAddr, tx.origin);\n        }\n    }\n\n    function depositCompound(address _tokenAddr, address _cTokenAddr, uint _amount) internal {\n        approveCToken(_tokenAddr, _cTokenAddr);\n\n        enterMarket(_cTokenAddr);\n\n        if (_tokenAddr != ETH_ADDRESS) {\n            require(CTokenInterface(_cTokenAddr).mint(_amount) == 0, \"mint error\");\n        } else {\n            CEtherInterface(_cTokenAddr).mint{value: _amount}();\n        }\n    }\n\n    function borrowCompound(address _cTokenAddr, uint _amount) internal {\n        enterMarket(_cTokenAddr);\n\n        require(CTokenInterface(_cTokenAddr).borrow(_amount) == 0);\n    }\n\n    function enterMarket(address _cTokenAddr) public {\n        address[] memory markets = new address[](1);\n        markets[0] = _cTokenAddr;\n\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\n    }\n\n}\n"
333     },
334     "contracts/compound/saver/CompoundSaverFlashProxy.sol": {
335       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../exchangeV3/DFSExchangeCore.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../utils/Discount.sol\";\nimport \"../helpers/CompoundSaverHelper.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\n\n/// @title Implements the actual logic of Repay/Boost with FL\ncontract CompoundSaverFlashProxy is DFSExchangeCore, CompoundSaverHelper  {\n\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n\n    using SafeERC20 for ERC20;\n\n    /// @notice Repays the position and sends tokens back for FL\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]\n    /// @param _gasCost Gas cost for transaction\n    /// @param _flashLoanData Data about FL [amount, fee]\n    function flashRepay(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost,\n        uint[2] memory _flashLoanData // amount, fee\n    ) public payable {\n        enterMarket(_cAddresses[0], _cAddresses[1]);\n\n        address payable user = payable(getUserAddress());\n        uint flashBorrowed = _flashLoanData[0] + _flashLoanData[1];\n\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\n\n        // draw max coll\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(maxColl) == 0);\n\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            // swap max coll + loanAmount\n            _exData.srcAmount = maxColl + _flashLoanData[0];\n            _exData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\n            _exData.user = user;\n\n            (,swapAmount) = _sell(_exData);\n\n            // get fee\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        } else {\n            swapAmount = (maxColl + _flashLoanData[0]);\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        }\n\n        // payback debt\n        paybackDebt(swapAmount, _cAddresses[1], borrowToken, user);\n\n        // draw collateral for loanAmount + loanFee\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(flashBorrowed) == 0);\n\n        // repay flash loan\n        returnFlashLoan(collToken, flashBorrowed);\n\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"CompoundRepay\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\n    }\n\n    /// @notice Boosts the position and sends tokens back for FL\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    /// @param _flashLoanData Data about FL [amount, fee]\n    function flashBoost(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost,\n        uint[2] memory _flashLoanData // amount, fee\n    ) public payable {\n        enterMarket(_cAddresses[0], _cAddresses[1]);\n\n        address payable user = payable(getUserAddress());\n        uint flashBorrowed = _flashLoanData[0] + _flashLoanData[1];\n\n        // borrow max amount\n        uint borrowAmount = getMaxBorrow(_cAddresses[1], address(this));\n        require(CTokenInterface(_cAddresses[1]).borrow(borrowAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            // get dfs fee\n            _exData.srcAmount = (borrowAmount + _flashLoanData[0]);\n            _exData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\n            _exData.user = user;\n\n            (, swapAmount) = _sell(_exData);\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        } else {\n            swapAmount = (borrowAmount + _flashLoanData[0]);\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        }\n\n        // deposit swaped collateral\n        depositCollateral(collToken, _cAddresses[0], swapAmount);\n\n        // borrow token to repay flash loan\n        require(CTokenInterface(_cAddresses[1]).borrow(flashBorrowed) == 0);\n\n        // repay flash loan\n        returnFlashLoan(borrowToken, flashBorrowed);\n\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"CompoundBoost\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\n    }\n\n    /// @notice Helper method to deposit tokens in Compound\n    /// @param _collToken Token address of the collateral\n    /// @param _cCollToken CToken address of the collateral\n    /// @param _depositAmount Amount to deposit\n    function depositCollateral(address _collToken, address _cCollToken, uint _depositAmount) internal {\n        approveCToken(_collToken, _cCollToken);\n\n        if (_collToken != ETH_ADDRESS) {\n            require(CTokenInterface(_cCollToken).mint(_depositAmount) == 0);\n        } else {\n            CEtherInterface(_cCollToken).mint{value: _depositAmount}(); // reverts on fail\n        }\n    }\n\n    /// @notice Returns the tokens/ether to the msg.sender which is the FL contract\n    /// @param _tokenAddr Address of token which we return\n    /// @param _amount Amount to return\n    function returnFlashLoan(address _tokenAddr, uint _amount) internal {\n        if (_tokenAddr != ETH_ADDRESS) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, _amount);\n        }\n\n        msg.sender.transfer(address(this).balance);\n    }\n\n}\n"
336     },
337     "contracts/cream/import/CreamImportTaker.sol": {
338       "content": "pragma solidity ^0.6.0;\n\nimport \"../../utils/GasBurner.sol\";\nimport \"../../auth/ProxyPermission.sol\";\n\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../interfaces/ProxyRegistryInterface.sol\";\n\nimport \"../helpers/CreamSaverHelper.sol\";\n\n/// @title Imports cream position from the account to DSProxy\ncontract CreamImportTaker is CreamSaverHelper, ProxyPermission, GasBurner {\n\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    address payable public constant CREAM_IMPORT_FLASH_LOAN = 0x24F4aC0Fe758c45cf8425D8Fbdd608cca9A7dBf8;\n    address public constant PROXY_REGISTRY_ADDRESS = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\n\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\n\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\n    /// @dev User must approve cream_IMPORT_FLASH_LOAN to pull _cCollateralToken\n    /// @param _cCollateralToken Collateral we are moving to DSProxy\n    /// @param _cBorrowToken Borrow token we are moving to DSProxy\n    function importLoan(address _cCollateralToken, address _cBorrowToken) external burnGas(20) {\n        address proxy = getProxy();\n\n        uint loanAmount = CTokenInterface(_cBorrowToken).borrowBalanceCurrent(msg.sender);\n        bytes memory paramsData = abi.encode(_cCollateralToken, _cBorrowToken, msg.sender, proxy);\n\n        givePermission(CREAM_IMPORT_FLASH_LOAN);\n\n        lendingPool.flashLoan(CREAM_IMPORT_FLASH_LOAN, getUnderlyingAddr(_cBorrowToken), loanAmount, paramsData);\n\n        removePermission(CREAM_IMPORT_FLASH_LOAN);\n\n        logger.Log(address(this), msg.sender, \"CreamImport\", abi.encode(loanAmount, 0, _cCollateralToken));\n    }\n\n    /// @notice Gets proxy address, if user doesn't has DSProxy build it\n    /// @return proxy DsProxy address\n    function getProxy() internal returns (address proxy) {\n        proxy = ProxyRegistryInterface(PROXY_REGISTRY_ADDRESS).proxies(msg.sender);\n\n        if (proxy == address(0)) {\n            proxy = ProxyRegistryInterface(PROXY_REGISTRY_ADDRESS).build(msg.sender);\n        }\n\n    }\n}\n"
339     },
340     "contracts/cream/import/CreamImportFlashLoan.sol": {
341       "content": "pragma solidity ^0.6.0;\n\nimport \"../../utils/FlashLoanReceiverBase.sol\";\nimport \"../../interfaces/ProxyRegistryInterface.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../utils/SafeERC20.sol\";\n\n/// @title Receives FL from Aave and imports the position to DSProxy\ncontract CreamImportFlashLoan is FlashLoanReceiverBase {\n\n    using SafeERC20 for ERC20;\n\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n\n    address public constant CREAM_BORROW_PROXY = 0x87F198Ef6116CdBC5f36B581d212ad950b7e2Ddd;\n\n    address public owner;\n\n    constructor()\n        FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER)\n        public {\n            owner = msg.sender;\n    }\n\n    /// @notice Called by Aave when sending back the FL amount\n    /// @param _reserve The address of the borrowed token\n    /// @param _amount Amount of FL tokens received\n    /// @param _fee FL Aave fee\n    /// @param _params The params that are sent from the original FL caller contract\n    function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n\n        (\n            address cCollateralToken,\n            address cBorrowToken,\n            address user,\n            address proxy\n        )\n        = abi.decode(_params, (address,address,address,address));\n\n        // approve FL tokens so we can repay them\n        ERC20(_reserve).safeApprove(cBorrowToken, uint(-1));\n\n        // repay cream debt\n        require(CTokenInterface(cBorrowToken).repayBorrowBehalf(user, uint(-1)) == 0, \"Repay borrow behalf fail\");\n\n        // transfer cTokens to proxy\n        uint cTokenBalance = CTokenInterface(cCollateralToken).balanceOf(user);\n        require(CTokenInterface(cCollateralToken).transferFrom(user, proxy, cTokenBalance));\n\n        // borrow\n        bytes memory proxyData = getProxyData(cCollateralToken, cBorrowToken, _reserve, (_amount + _fee));\n        DSProxyInterface(proxy).execute(CREAM_BORROW_PROXY, proxyData);\n\n        // Repay the loan with the money DSProxy sent back\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n    }\n\n    /// @notice Formats function data call so we can call it through DSProxy\n    /// @param _cCollToken CToken address of collateral\n    /// @param _cBorrowToken CToken address we will borrow\n    /// @param _borrowToken Token address we will borrow\n    /// @param _amount Amount that will be borrowed\n    /// @return proxyData Formated function call data\n    function getProxyData(address _cCollToken, address _cBorrowToken, address _borrowToken, uint _amount) internal pure returns (bytes memory proxyData) {\n        proxyData = abi.encodeWithSignature(\n            \"borrow(address,address,address,uint256)\",\n            _cCollToken, _cBorrowToken, _borrowToken, _amount);\n    }\n\n    function withdrawStuckFunds(address _tokenAddr, uint _amount) public {\n        require(owner == msg.sender, \"Must be owner\");\n\n        if (_tokenAddr == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            msg.sender.transfer(_amount);\n        } else {\n            ERC20(_tokenAddr).safeTransfer(owner, _amount);\n        }\n    }\n}\n"
342     },
343     "contracts/mcd/saver/MCDSaverFlashLoan.sol": {
344       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../mcd/saver/MCDSaverProxy.sol\";\nimport \"../../utils/FlashLoanReceiverBase.sol\";\nimport \"../../exchangeV3/DFSExchangeCore.sol\";\n\n/// @title Receiver of Dydx flash loan and performs the fl repay/boost logic\n/// @notice Must have a dust amount of WETH on the contract for 2 wei dydx fee\ncontract MCDSaverFlashLoan is MCDSaverProxy, AdminAuth, FlashLoanReceiverBase {\n\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n\n    constructor() FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER) public {}\n\n    struct SaverData {\n        uint cdpId;\n        uint gasCost;\n        uint loanAmount;\n        uint fee;\n        address joinAddr;\n        ManagerType managerType;\n    }\n\n    function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n\n        //check the contract has the specified balance\n        require(_amount <= getBalanceInternal(address(this), _reserve),\n            \"Invalid balance for the contract\");\n\n        (\n            bytes memory exDataBytes,\n            uint cdpId,\n            uint gasCost,\n            address joinAddr,\n            bool isRepay,\n            uint8 managerType\n        )\n         = abi.decode(_params, (bytes,uint256,uint256,address,bool,uint8));\n\n        ExchangeData memory exchangeData = unpackExchangeData(exDataBytes);\n\n        SaverData memory saverData = SaverData({\n            cdpId: cdpId,\n            gasCost: gasCost,\n            loanAmount: _amount,\n            fee: _fee,\n            joinAddr: joinAddr,\n            managerType: ManagerType(managerType)\n        });\n\n        if (isRepay) {\n            repayWithLoan(exchangeData, saverData);\n        } else {\n            boostWithLoan(exchangeData, saverData);\n        }\n\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }\n\n    function boostWithLoan(\n        ExchangeData memory _exchangeData,\n        SaverData memory _saverData\n    ) internal {\n\n        address managerAddr = getManagerAddr(_saverData.managerType);\n\n        address user = getOwner(Manager(managerAddr), _saverData.cdpId);\n\n        // Draw users Dai\n        uint maxDebt = getMaxDebt(managerAddr, _saverData.cdpId, Manager(managerAddr).ilks(_saverData.cdpId));\n        uint daiDrawn = drawDai(managerAddr, _saverData.cdpId, Manager(managerAddr).ilks(_saverData.cdpId), maxDebt);\n\n        // Swap\n        _exchangeData.srcAmount = daiDrawn + _saverData.loanAmount - takeFee(_saverData.gasCost, daiDrawn + _saverData.loanAmount);\n        _exchangeData.user = user;\n        _exchangeData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\n        (, uint swapedAmount) = _sell(_exchangeData);\n\n        // Return collateral\n        addCollateral(managerAddr, _saverData.cdpId, _saverData.joinAddr, swapedAmount);\n\n        // Draw Dai to repay the flash loan\n        drawDai(managerAddr, _saverData.cdpId,  Manager(managerAddr).ilks(_saverData.cdpId), (_saverData.loanAmount + _saverData.fee));\n\n        logger.Log(address(this), msg.sender, \"MCDFlashBoost\", abi.encode(_saverData.cdpId, user, _exchangeData.srcAmount, swapedAmount));\n    }\n\n    function repayWithLoan(\n        ExchangeData memory _exchangeData,\n        SaverData memory _saverData\n    ) internal {\n\n        address managerAddr = getManagerAddr(_saverData.managerType);\n\n        address user = getOwner(Manager(managerAddr), _saverData.cdpId);\n        bytes32 ilk = Manager(managerAddr).ilks(_saverData.cdpId);\n\n        // Draw collateral\n        uint maxColl = getMaxCollateral(managerAddr, _saverData.cdpId, ilk, _saverData.joinAddr);\n        uint collDrawn = drawCollateral(managerAddr, _saverData.cdpId, _saverData.joinAddr, maxColl);\n\n        // Swap\n        _exchangeData.srcAmount = (_saverData.loanAmount + collDrawn);\n        _exchangeData.user = user;\n        _exchangeData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\n        (, uint paybackAmount) = _sell(_exchangeData);\n\n        paybackAmount -= takeFee(_saverData.gasCost, paybackAmount);\n        paybackAmount = limitLoanAmount(managerAddr, _saverData.cdpId, ilk, paybackAmount, user);\n\n        // Payback the debt\n        paybackDebt(managerAddr, _saverData.cdpId, ilk, paybackAmount, user);\n\n        // Draw collateral to repay the flash loan\n        drawCollateral(managerAddr, _saverData.cdpId, _saverData.joinAddr, (_saverData.loanAmount + _saverData.fee));\n\n        logger.Log(address(this), msg.sender, \"MCDFlashRepay\", abi.encode(_saverData.cdpId, user, _exchangeData.srcAmount, paybackAmount));\n    }\n\n    /// @notice Handles that the amount is not bigger than cdp debt and not dust\n    function limitLoanAmount(address _managerAddr, uint _cdpId, bytes32 _ilk, uint _paybackAmount, address _owner) internal returns (uint256) {\n        uint debt = getAllDebt(address(vat), Manager(_managerAddr).urns(_cdpId), Manager(_managerAddr).urns(_cdpId), _ilk);\n\n        if (_paybackAmount > debt) {\n            ERC20(DAI_ADDRESS).transfer(_owner, (_paybackAmount - debt));\n            return debt;\n        }\n\n        uint debtLeft = debt - _paybackAmount;\n\n        (,,,, uint dust) = vat.ilks(_ilk);\n        dust = dust / 10**27;\n\n        // Less than dust value\n        if (debtLeft < dust) {\n            uint amountOverDust = (dust - debtLeft);\n\n            ERC20(DAI_ADDRESS).transfer(_owner, amountOverDust);\n\n            return (_paybackAmount - amountOverDust);\n        }\n\n        return _paybackAmount;\n    }\n\n    receive() external override(FlashLoanReceiverBase, DFSExchangeCore) payable {}\n\n}\n"
345     },
346     "contracts/mcd/close/MCDCloseFlashLoan.sol": {
347       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../mcd/saver/MCDSaverProxy.sol\";\nimport \"../../utils/FlashLoanReceiverBase.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../../exchangeV3/DFSExchangeCore.sol\";\nimport \"../../mcd/saver/MCDSaverProxyHelper.sol\";\nimport \"./MCDCloseTaker.sol\";\n\ncontract MCDCloseFlashLoan is DFSExchangeCore, MCDSaverProxyHelper, FlashLoanReceiverBase, AdminAuth {\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n\n    uint public constant SERVICE_FEE = 400; // 0.25% Fee\n\n    bytes32 internal constant ETH_ILK = 0x4554482d41000000000000000000000000000000000000000000000000000000;\n\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public constant DAI_JOIN_ADDRESS = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\n    address public constant SPOTTER_ADDRESS = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;\n    address public constant VAT_ADDRESS = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\n\n    DaiJoin public constant daiJoin = DaiJoin(DAI_JOIN_ADDRESS);\n    Spotter public constant spotter = Spotter(SPOTTER_ADDRESS);\n    Vat public constant vat = Vat(VAT_ADDRESS);\n\n    struct CloseData {\n        uint cdpId;\n        uint collAmount;\n        uint daiAmount;\n        uint minAccepted;\n        address joinAddr;\n        address proxy;\n        uint flFee;\n        bool toDai;\n        address reserve;\n        uint amount;\n    }\n\n    constructor() FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER) public {}\n\n    function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n\n        (address proxy, bytes memory packedData) = abi.decode(_params, (address,bytes));\n\n        (MCDCloseTaker.CloseData memory closeDataSent, ExchangeData memory exchangeData) = abi.decode(packedData, (MCDCloseTaker.CloseData,ExchangeData));\n\n        CloseData memory closeData = CloseData({\n            cdpId: closeDataSent.cdpId,\n            collAmount: closeDataSent.collAmount,\n            daiAmount: closeDataSent.daiAmount,\n            minAccepted: closeDataSent.minAccepted,\n            joinAddr: closeDataSent.joinAddr,\n            proxy: proxy,\n            flFee: _fee,\n            toDai: closeDataSent.toDai,\n            reserve: _reserve,\n            amount: _amount\n        });\n\n        address user = DSProxy(payable(closeData.proxy)).owner();\n\n        exchangeData.dfsFeeDivider = SERVICE_FEE;\n        exchangeData.user = user;\n\n        address managerAddr = getManagerAddr(closeDataSent.managerType);\n\n        closeCDP(closeData, exchangeData, user, managerAddr);\n    }\n\n    function closeCDP(\n        CloseData memory _closeData,\n        ExchangeData memory _exchangeData,\n        address _user,\n        address _managerAddr\n    ) internal {\n\n        paybackDebt(_managerAddr, _closeData.cdpId, Manager(_managerAddr).ilks(_closeData.cdpId), _closeData.daiAmount); // payback whole debt\n        uint drawnAmount = drawMaxCollateral(_managerAddr, _closeData.cdpId, _closeData.joinAddr, _closeData.collAmount); // draw whole collateral\n\n        uint daiSwaped = 0;\n\n        if (_closeData.toDai) {\n            _exchangeData.srcAmount = drawnAmount;\n            (, daiSwaped) = _sell(_exchangeData);\n        } else {\n            _exchangeData.destAmount = (_closeData.daiAmount + _closeData.flFee);\n            (, daiSwaped) = _buy(_exchangeData);\n        }\n\n        address tokenAddr = getVaultCollAddr(_closeData.joinAddr);\n\n        if (_closeData.toDai) {\n            tokenAddr = DAI_ADDRESS;\n        }\n\n        require(getBalance(tokenAddr) >= _closeData.minAccepted, \"Below min. number of eth specified\");\n\n        transferFundsBackToPoolInternal(_closeData.reserve, _closeData.amount.add(_closeData.flFee));\n\n        sendLeftover(tokenAddr, DAI_ADDRESS, payable(_user));\n\n    }\n\n    function drawMaxCollateral(address _managerAddr, uint _cdpId, address _joinAddr, uint _amount) internal returns (uint) {\n        Manager(_managerAddr).frob(_cdpId, -toPositiveInt(_amount), 0);\n        Manager(_managerAddr).flux(_cdpId, address(this), _amount);\n\n        uint joinAmount = _amount;\n\n        if (Join(_joinAddr).dec() != 18) {\n            joinAmount = _amount / (10 ** (18 - Join(_joinAddr).dec()));\n        }\n\n        Join(_joinAddr).exit(address(this), joinAmount);\n\n        if (isEthJoinAddr(_joinAddr)) {\n            Join(_joinAddr).gem().withdraw(joinAmount); // Weth -> Eth\n        }\n\n        return joinAmount;\n    }\n\n    function paybackDebt(address _managerAddr, uint _cdpId, bytes32 _ilk, uint _daiAmount) internal {\n        address urn = Manager(_managerAddr).urns(_cdpId);\n\n        daiJoin.dai().approve(DAI_JOIN_ADDRESS, _daiAmount);\n        daiJoin.join(urn, _daiAmount);\n\n        Manager(_managerAddr).frob(_cdpId, 0, normalizePaybackAmount(VAT_ADDRESS, urn, _ilk));\n    }\n\n    function getVaultCollAddr(address _joinAddr) internal view returns (address) {\n        address tokenAddr = address(Join(_joinAddr).gem());\n\n        if (tokenAddr == EXCHANGE_WETH_ADDRESS) {\n            return KYBER_ETH_ADDRESS;\n        }\n\n        return tokenAddr;\n    }\n\n    function getPrice(bytes32 _ilk) public view returns (uint256) {\n        (, uint256 mat) = spotter.ilks(_ilk);\n        (, , uint256 spot, , ) = vat.ilks(_ilk);\n\n        return rmul(rmul(spot, spotter.par()), mat);\n    }\n\n    receive() external override(FlashLoanReceiverBase, DFSExchangeCore) payable {}\n\n}\n"
348     },
349     "contracts/mcd/close/MCDCloseTaker.sol": {
350       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../mcd/saver/MCDSaverProxy.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../exchangeV3/DFSExchangeData.sol\";\nimport \"../../utils/GasBurner.sol\";\n\nabstract contract IMCDSubscriptions {\n    function unsubscribe(uint256 _cdpId) external virtual ;\n\n    function subscribersPos(uint256 _cdpId) external virtual returns (uint256, bool);\n}\n\n\ncontract MCDCloseTaker is MCDSaverProxyHelper, GasBurner {\n\n    address public constant SUBSCRIPTION_ADDRESS_NEW = 0xC45d4f6B6bf41b6EdAA58B01c4298B8d9078269a;\n\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    address public constant SPOTTER_ADDRESS = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;\n    address public constant VAT_ADDRESS = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    // solhint-disable-next-line const-name-snakecase\n    DefisaverLogger public constant logger = DefisaverLogger(DEFISAVER_LOGGER);\n\n    struct CloseData {\n        uint cdpId;\n        address joinAddr;\n        uint collAmount;\n        uint daiAmount;\n        uint minAccepted;\n        bool wholeDebt;\n        bool toDai;\n        ManagerType managerType;\n    }\n\n    Vat public constant vat = Vat(VAT_ADDRESS);\n    Spotter public constant spotter = Spotter(SPOTTER_ADDRESS);\n\n    function closeWithLoan(\n        DFSExchangeData.ExchangeData memory _exchangeData,\n        CloseData memory _closeData,\n        address payable mcdCloseFlashLoan\n    ) public payable burnGas(20) {\n        mcdCloseFlashLoan.transfer(msg.value); // 0x fee\n\n        address managerAddr = getManagerAddr(_closeData.managerType);\n\n        if (_closeData.wholeDebt) {\n            _closeData.daiAmount = getAllDebt(\n                VAT_ADDRESS,\n                Manager(managerAddr).urns(_closeData.cdpId),\n                Manager(managerAddr).urns(_closeData.cdpId),\n                Manager(managerAddr).ilks(_closeData.cdpId)\n            );\n\n            (_closeData.collAmount, )\n                = getCdpInfo(Manager(managerAddr), _closeData.cdpId, Manager(managerAddr).ilks(_closeData.cdpId));\n        }\n\n        Manager(managerAddr).cdpAllow(_closeData.cdpId, mcdCloseFlashLoan, 1);\n\n        bytes memory packedData  = _packData(_closeData, _exchangeData);\n        bytes memory paramsData = abi.encode(address(this), packedData);\n\n        lendingPool.flashLoan(mcdCloseFlashLoan, DAI_ADDRESS, _closeData.daiAmount, paramsData);\n\n        Manager(managerAddr).cdpAllow(_closeData.cdpId, mcdCloseFlashLoan, 0);\n\n        // If sub. to automatic protection unsubscribe\n        unsubscribe(SUBSCRIPTION_ADDRESS_NEW, _closeData.cdpId);\n\n        logger.Log(address(this), msg.sender, \"MCDClose\", abi.encode(_closeData.cdpId, _closeData.collAmount, _closeData.daiAmount, _closeData.toDai));\n    }\n\n    /// @notice Gets the maximum amount of debt available to generate\n    /// @param _managerAddr Address of the CDP Manager\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    function getMaxDebt(address _managerAddr, uint256 _cdpId, bytes32 _ilk) public view returns (uint256) {\n        uint256 price = getPrice(_ilk);\n\n        (, uint256 mat) = spotter.ilks(_ilk);\n        (uint256 collateral, uint256 debt) = getCdpInfo(Manager(_managerAddr), _cdpId, _ilk);\n\n        return sub(wdiv(wmul(collateral, price), mat), debt);\n    }\n\n    /// @notice Gets a price of the asset\n    /// @param _ilk Ilk of the CDP\n    function getPrice(bytes32 _ilk) public view returns (uint256) {\n        (, uint256 mat) = spotter.ilks(_ilk);\n        (, , uint256 spot, , ) = vat.ilks(_ilk);\n\n        return rmul(rmul(spot, spotter.par()), mat);\n    }\n\n    function unsubscribe(address _subContract, uint _cdpId) internal {\n        (, bool isSubscribed) = IMCDSubscriptions(_subContract).subscribersPos(_cdpId);\n\n        if (isSubscribed) {\n            IMCDSubscriptions(_subContract).unsubscribe(_cdpId);\n        }\n    }\n\n    function _packData(\n        CloseData memory _closeData,\n        DFSExchangeData.ExchangeData memory _exchangeData\n    ) internal pure returns (bytes memory) {\n\n        return abi.encode(_closeData, _exchangeData);\n    }\n\n}\n"
351     },
352     "contracts/cream/saver/CreamSaverFlashLoan.sol": {
353       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/FlashLoanReceiverBase.sol\";\nimport \"../../interfaces/DSProxyInterface.sol\";\nimport \"../../exchange/SaverExchangeCore.sol\";\n\n/// @title Contract that receives the FL from Aave for Repays/Boost\ncontract CreamSaverFlashLoan is FlashLoanReceiverBase, SaverExchangeCore {\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n\n    address payable public COMPOUND_SAVER_FLASH_PROXY = 0x1e012554891d271eDc80ba8eB146EA5FF596fA51;\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address public owner;\n\n    using SafeERC20 for ERC20;\n\n    constructor()\n        FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER)\n        public {\n            owner = msg.sender;\n    }\n\n    /// @notice Called by Aave when sending back the FL amount\n    /// @param _reserve The address of the borrowed token\n    /// @param _amount Amount of FL tokens received\n    /// @param _fee FL Aave fee\n    /// @param _params The params that are sent from the original FL caller contract\n   function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n        // Format the call data for DSProxy\n        (bytes memory proxyData, address payable proxyAddr) = packFunctionCall(_amount, _fee, _params);\n\n        // Send Flash loan amount to DSProxy\n        sendLoanToProxy(proxyAddr, _reserve, _amount);\n\n        // Execute the DSProxy call\n        DSProxyInterface(proxyAddr).execute(COMPOUND_SAVER_FLASH_PROXY, proxyData);\n\n        // Repay the loan with the money DSProxy sent back\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Formats function data call so we can call it through DSProxy\n    /// @param _amount Amount of FL\n    /// @param _fee Fee of the FL\n    /// @param _params Saver proxy params\n    /// @return proxyData Formated function call data\n    function packFunctionCall(uint _amount, uint _fee, bytes memory _params) internal pure returns (bytes memory proxyData, address payable) {\n        (\n            bytes memory exDataBytes,\n            address[2] memory cAddresses, // cCollAddress, cBorrowAddress\n            uint256 gasCost,\n            bool isRepay,\n            address payable proxyAddr\n        )\n        = abi.decode(_params, (bytes,address[2],uint256,bool,address));\n\n        ExchangeData memory _exData = unpackExchangeData(exDataBytes);\n\n        uint[2] memory flashLoanData = [_amount, _fee];\n\n        if (isRepay) {\n            proxyData = abi.encodeWithSignature(\"flashRepay((address,address,uint256,uint256,uint256,address,address,bytes,uint256),address[2],uint256,uint256[2])\", _exData, cAddresses, gasCost, flashLoanData);\n        } else {\n            proxyData = abi.encodeWithSignature(\"flashBoost((address,address,uint256,uint256,uint256,address,address,bytes,uint256),address[2],uint256,uint256[2])\", _exData, cAddresses, gasCost, flashLoanData);\n        }\n\n        return (proxyData, proxyAddr);\n    }\n\n    /// @notice Send the FL funds received to DSProxy\n    /// @param _proxy DSProxy address\n    /// @param _reserve Token address\n    /// @param _amount Amount of tokens\n    function sendLoanToProxy(address payable _proxy, address _reserve, uint _amount) internal {\n        if (_reserve != ETH_ADDRESS) {\n            ERC20(_reserve).safeTransfer(_proxy, _amount);\n        }\n\n        _proxy.transfer(address(this).balance);\n    }\n\n    receive() external override(SaverExchangeCore, FlashLoanReceiverBase) payable {}\n}\n"
354     },
355     "contracts/utils/ExchangeDataParser.sol": {
356       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../exchange/SaverExchangeCore.sol\";\n\ncontract ExchangeDataParser {\n     function decodeExchangeData(\n        SaverExchangeCore.ExchangeData memory exchangeData\n    ) internal pure returns (address[4] memory, uint[4] memory, bytes memory) {\n        return (\n         [exchangeData.srcAddr, exchangeData.destAddr, exchangeData.exchangeAddr, exchangeData.wrapper],\n         [exchangeData.srcAmount, exchangeData.destAmount, exchangeData.minPrice, exchangeData.price0x],\n         exchangeData.callData\n        );\n    }\n\n    function encodeExchangeData(\n        address[4] memory exAddr, uint[4] memory exNum, bytes memory callData\n    ) internal pure returns (SaverExchangeCore.ExchangeData memory) {\n        return SaverExchangeCore.ExchangeData({\n            srcAddr: exAddr[0],\n            destAddr: exAddr[1],\n            srcAmount: exNum[0],\n            destAmount: exNum[1],\n            minPrice: exNum[2],\n            wrapper: exAddr[3],\n            exchangeAddr: exAddr[2],\n            callData: callData,\n            price0x: exNum[3]\n        });\n    }\n}\n"
357     },
358     "contracts/exchange/SaverExchange.sol": {
359       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/GasTokenInterface.sol\";\nimport \"../interfaces/IFeeRecipient.sol\";\nimport \"./SaverExchangeCore.sol\";\nimport \"../DS/DSMath.sol\";\nimport \"../loggers/DefisaverLogger.sol\";\nimport \"../auth/AdminAuth.sol\";\nimport \"../utils/GasBurner.sol\";\nimport \"../utils/SafeERC20.sol\";\n\ncontract SaverExchange is SaverExchangeCore, AdminAuth, GasBurner {\n\n    using SafeERC20 for ERC20;\n\n    uint256 public constant SERVICE_FEE = 800; // 0.125% Fee\n\n    IFeeRecipient public constant _feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);\n\n    // solhint-disable-next-line const-name-snakecase\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\n\n    uint public burnAmount = 10;\n\n    /// @notice Takes a src amount of tokens and converts it into the dest token\n    /// @dev Takes fee from the _srcAmount before the exchange\n    /// @param exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]\n    /// @param _user User address who called the exchange\n    function sell(ExchangeData memory exData, address payable _user) public payable burnGas(burnAmount) {\n\n        // take fee\n        uint dfsFee = getFee(exData.srcAmount, exData.srcAddr);\n        exData.srcAmount = sub(exData.srcAmount, dfsFee);\n\n        // Perform the exchange\n        (address wrapper, uint destAmount) = _sell(exData);\n\n        // send back any leftover ether or tokens\n        sendLeftover(exData.srcAddr, exData.destAddr, _user);\n\n        // log the event\n        logger.Log(address(this), msg.sender, \"ExchangeSell\", abi.encode(wrapper, exData.srcAddr, exData.destAddr, exData.srcAmount, destAmount));\n    }\n\n    /// @notice Takes a dest amount of tokens and converts it from the src token\n    /// @dev Send always more than needed for the swap, extra will be returned\n    /// @param exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]\n    /// @param _user User address who called the exchange\n    function buy(ExchangeData memory exData, address payable _user) public payable burnGas(burnAmount){\n\n        uint dfsFee = getFee(exData.srcAmount, exData.srcAddr);\n        exData.srcAmount = sub(exData.srcAmount, dfsFee);\n\n        // Perform the exchange\n        (address wrapper, uint srcAmount) = _buy(exData);\n\n        // send back any leftover ether or tokens\n        sendLeftover(exData.srcAddr, exData.destAddr, _user);\n\n        // log the event\n        logger.Log(address(this), msg.sender, \"ExchangeBuy\", abi.encode(wrapper, exData.srcAddr, exData.destAddr, srcAmount, exData.destAmount));\n\n    }\n\n    /// @notice Takes a feePercentage and sends it to wallet\n    /// @param _amount Dai amount of the whole trade\n    /// @param _token Address of the token\n    /// @return feeAmount Amount in Dai owner earned on the fee\n    function getFee(uint256 _amount, address _token) internal returns (uint256 feeAmount) {\n        uint256 fee = SERVICE_FEE;\n\n        if (Discount(DISCOUNT_ADDRESS).isCustomFeeSet(msg.sender)) {\n            fee = Discount(DISCOUNT_ADDRESS).getCustomServiceFee(msg.sender);\n        }\n\n        if (fee == 0) {\n            feeAmount = 0;\n        } else {\n            address walletAddr = _feeRecipient.getFeeAddr();\n\n            feeAmount = _amount / fee;\n            if (_token == KYBER_ETH_ADDRESS) {\n                payable(walletAddr).transfer(feeAmount);\n            } else {\n                ERC20(_token).safeTransfer(walletAddr, feeAmount);\n            }\n        }\n    }\n\n    /// @notice Changes the amount of gas token we burn for each call\n    /// @dev Only callable by the owner\n    /// @param _newBurnAmount New amount of gas tokens to be burned\n    function changeBurnAmount(uint _newBurnAmount) public {\n        require(owner == msg.sender);\n\n        burnAmount = _newBurnAmount;\n    }\n\n}\n"
360     },
361     "contracts/exchangeV3/wrappersV3/KyberWrapperV3.sol": {
362       "content": "pragma solidity ^0.6.0;\n\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../interfaces/KyberNetworkProxyInterface.sol\";\nimport \"../../interfaces/IFeeRecipient.sol\";\nimport \"../../interfaces/ExchangeInterfaceV3.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\ncontract KyberWrapperV3 is DSMath, ExchangeInterfaceV3, AdminAuth {\n\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant KYBER_INTERFACE = 0x9AAb3f75489902f3a48495025729a0AF77d4b11e;\n\n    IFeeRecipient public constant feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);\n\n    using SafeERC20 for ERC20;\n\n    /// @notice Sells a _srcAmount of tokens at Kyber\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Destination amount\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) external override payable returns (uint) {\n        ERC20 srcToken = ERC20(_srcAddr);\n        ERC20 destToken = ERC20(_destAddr);\n\n        address walletAddr = feeRecipient.getFeeAddr();\n\n        KyberNetworkProxyInterface kyberNetworkProxy = KyberNetworkProxyInterface(KYBER_INTERFACE);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcToken.safeApprove(address(kyberNetworkProxy), _srcAmount);\n        }\n\n        uint destAmount = kyberNetworkProxy.trade{value: msg.value}(\n            srcToken,\n            _srcAmount,\n            destToken,\n            msg.sender,\n            uint(-1),\n            0,\n            walletAddr\n        );\n\n        return destAmount;\n    }\n\n    /// @notice Buys a _destAmount of tokens at Kyber\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint srcAmount\n    function buy(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) external override payable returns(uint) {\n        ERC20 srcToken = ERC20(_srcAddr);\n        ERC20 destToken = ERC20(_destAddr);\n\n        address walletAddr = feeRecipient.getFeeAddr();\n\n        uint srcAmount = 0;\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcAmount = srcToken.balanceOf(address(this));\n        } else {\n            srcAmount = msg.value;\n        }\n\n        KyberNetworkProxyInterface kyberNetworkProxy = KyberNetworkProxyInterface(KYBER_INTERFACE);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcToken.safeApprove(address(kyberNetworkProxy), srcAmount);\n        }\n\n        uint destAmount = kyberNetworkProxy.trade{value: msg.value}(\n            srcToken,\n            srcAmount,\n            destToken,\n            msg.sender,\n            _destAmount,\n            0,\n            walletAddr\n        );\n\n        require(destAmount == _destAmount, \"Wrong dest amount\");\n\n        uint srcAmountAfter = 0;\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcAmountAfter = srcToken.balanceOf(address(this));\n        } else {\n            srcAmountAfter = address(this).balance;\n        }\n\n        // Send the leftover from the source token back\n        sendLeftOver(_srcAddr);\n\n        return (srcAmount - srcAmountAfter);\n    }\n\n    /// @notice Return a rate for which we can sell an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return rate Rate\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) public override view returns (uint rate) {\n        (rate, ) = KyberNetworkProxyInterface(KYBER_INTERFACE)\n            .getExpectedRate(ERC20(_srcAddr), ERC20(_destAddr), _srcAmount);\n\n        // multiply with decimal difference in src token\n        rate = rate * (10**(18 - getDecimals(_srcAddr)));\n        // divide with decimal difference in dest token\n        rate = rate / (10**(18 - getDecimals(_destAddr)));\n    }\n\n    /// @notice Return a rate for which we can buy an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return rate Rate\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) public override view returns (uint rate) {\n        uint256 srcRate = getSellRate(_destAddr, _srcAddr, _destAmount, _additionalData);\n        uint256 srcAmount = wmul(srcRate, _destAmount);\n\n        rate = getSellRate(_srcAddr, _destAddr, srcAmount, _additionalData);\n\n        // increase rate by 3% too account for inaccuracy between sell/buy conversion\n        rate = rate + (rate / 30);\n    }\n\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\n    /// @param _srcAddr Source token address\n    function sendLeftOver(address _srcAddr) internal {\n        msg.sender.transfer(address(this).balance);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            ERC20(_srcAddr).safeTransfer(msg.sender, ERC20(_srcAddr).balanceOf(address(this)));\n        }\n    }\n\n    receive() payable external {}\n\n    function getDecimals(address _token) internal view returns (uint256) {\n        if (_token == KYBER_ETH_ADDRESS) return 18;\n\n        return ERC20(_token).decimals();\n    }\n}\n"
363     },
364     "contracts/interfaces/KyberNetworkProxyInterface.sol": {
365       "content": "pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract KyberNetworkProxyInterface {\n    function maxGasPrice() external virtual view returns (uint256);\n\n    function getUserCapInWei(address user) external virtual view returns (uint256);\n\n    function getUserCapInTokenWei(address user, ERC20 token) external virtual view returns (uint256);\n\n    function enabled() external virtual view returns (bool);\n\n    function info(bytes32 id) external virtual view returns (uint256);\n\n    function getExpectedRate(ERC20 src, ERC20 dest, uint256 srcQty)\n        public virtual\n        view\n        returns (uint256 expectedRate, uint256 slippageRate);\n\n    function tradeWithHint(\n        ERC20 src,\n        uint256 srcAmount,\n        ERC20 dest,\n        address destAddress,\n        uint256 maxDestAmount,\n        uint256 minConversionRate,\n        address walletId,\n        bytes memory hint\n    ) public virtual payable returns (uint256);\n\n    function trade(\n        ERC20 src,\n        uint256 srcAmount,\n        ERC20 dest,\n        address destAddress,\n        uint256 maxDestAmount,\n        uint256 minConversionRate,\n        address walletId\n    ) public virtual payable returns (uint256);\n\n    function swapEtherToToken(ERC20 token, uint256 minConversionRate)\n        external virtual\n        payable\n        returns (uint256);\n\n    function swapTokenToEther(ERC20 token, uint256 tokenQty, uint256 minRate)\n        external virtual\n        payable\n        returns (uint256);\n\n    function swapTokenToToken(ERC20 src, uint256 srcAmount, ERC20 dest, uint256 minConversionRate)\n        public virtual\n        returns (uint256);\n}\n"
366     },
367     "contracts/exchangeV3/wrappersV3/UniswapWrapperV3.sol": {
368       "content": "pragma solidity ^0.6.0;\n\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../interfaces/ExchangeInterfaceV3.sol\";\nimport \"../../interfaces/UniswapRouterInterface.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\n/// @title DFS exchange wrapper for UniswapV2\ncontract UniswapWrapperV3 is DSMath, ExchangeInterfaceV3, AdminAuth {\n\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    UniswapRouterInterface public constant router = UniswapRouterInterface(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    using SafeERC20 for ERC20;\n\n    /// @notice Sells a _srcAmount of tokens at UniswapV2\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Destination amount\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) external payable override returns (uint) {\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        uint[] memory amounts;\n        address[] memory path = abi.decode(_additionalData, (address[]));\n\n        ERC20(_srcAddr).safeApprove(address(router), _srcAmount);\n\n        // if we are buying ether\n        if (_destAddr == WETH_ADDRESS) {\n            amounts = router.swapExactTokensForETH(_srcAmount, 1, path, msg.sender, block.timestamp + 1);\n        }\n        // if we are selling token to token\n        else {\n            amounts = router.swapExactTokensForTokens(_srcAmount, 1, path, msg.sender, block.timestamp + 1);\n        }\n\n        return amounts[amounts.length - 1];\n    }\n\n    /// @notice Buys a _destAmount of tokens at UniswapV2\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint srcAmount\n    function buy(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) external override payable returns(uint) {\n\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        uint[] memory amounts;\n        address[] memory path = abi.decode(_additionalData, (address[]));\n\n        ERC20(_srcAddr).safeApprove(address(router), uint(-1));\n\n\n         // if we are buying ether\n        if (_destAddr == WETH_ADDRESS) {\n            amounts = router.swapTokensForExactETH(_destAmount, uint(-1), path, msg.sender, block.timestamp + 1);\n        }\n        // if we are buying token to token\n        else {\n            amounts = router.swapTokensForExactTokens(_destAmount, uint(-1), path, msg.sender, block.timestamp + 1);\n        }\n\n        // Send the leftover from the source token back\n        sendLeftOver(_srcAddr);\n\n        return amounts[0];\n    }\n\n    /// @notice Return a rate for which we can sell an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Rate\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) public override view returns (uint) {\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        address[] memory path = abi.decode(_additionalData, (address[]));\n\n        uint[] memory amounts = router.getAmountsOut(_srcAmount, path);\n        return wdiv(amounts[amounts.length - 1], _srcAmount);\n    }\n\n    /// @notice Return a rate for which we can buy an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint Rate\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) public override view returns (uint) {\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        address[] memory path = abi.decode(_additionalData, (address[]));\n\n        uint[] memory amounts = router.getAmountsIn(_destAmount, path);\n        return wdiv(_destAmount, amounts[0]);\n    }\n\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\n    /// @param _srcAddr Source token address\n    function sendLeftOver(address _srcAddr) internal {\n        msg.sender.transfer(address(this).balance);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            ERC20(_srcAddr).safeTransfer(msg.sender, ERC20(_srcAddr).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Converts Kybers Eth address -> Weth\n    /// @param _src Input address\n    function ethToWethAddr(address _src) internal pure returns (address) {\n        return _src == KYBER_ETH_ADDRESS ? WETH_ADDRESS : _src;\n    }\n\n    function getDecimals(address _token) internal view returns (uint256) {\n        if (_token == KYBER_ETH_ADDRESS) return 18;\n\n        return ERC20(_token).decimals();\n    }\n\n    receive() payable external {}\n}\n"
369     },
370     "contracts/interfaces/UniswapRouterInterface.sol": {
371       "content": "pragma solidity ^0.6.0;\n\nabstract contract UniswapRouterInterface {\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    virtual\n    returns (uint[] memory amounts);\n\n  function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n    ) external virtual returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external virtual\n    returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n    ) external virtual returns (uint[] memory amounts);\n\n    function getAmountsOut(uint amountIn, address[] memory path) public virtual view returns (uint[] memory amounts);\n\n    function getAmountsIn(uint amountOut, address[] memory path) public virtual view returns (uint[] memory amounts);\n}\n"
372     },
373     "contracts/exchange/wrappers/UniswapV2Wrapper.sol": {
374       "content": "pragma solidity ^0.6.0;\n\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../interfaces/ExchangeInterfaceV2.sol\";\nimport \"../../interfaces/UniswapRouterInterface.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\n/// @title DFS exchange wrapper for UniswapV2\ncontract UniswapV2Wrapper is DSMath, ExchangeInterfaceV2, AdminAuth {\n\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    UniswapRouterInterface public constant router = UniswapRouterInterface(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    using SafeERC20 for ERC20;\n\n    /// @notice Sells a _srcAmount of tokens at UniswapV2\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Destination amount\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external payable override returns (uint) {\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        uint[] memory amounts;\n        address[] memory path = new address[](2);\n        path[0] = _srcAddr;\n        path[1] = _destAddr;\n\n        ERC20(_srcAddr).safeApprove(address(router), _srcAmount);\n\n        // if we are buying ether\n        if (_destAddr == WETH_ADDRESS) {\n            amounts = router.swapExactTokensForETH(_srcAmount, 1, path, msg.sender, block.timestamp + 1);\n        }\n        // if we are selling token to token\n        else {\n            amounts = router.swapExactTokensForTokens(_srcAmount, 1, path, msg.sender, block.timestamp + 1);\n        }\n\n        return amounts[amounts.length - 1];\n    }\n\n    /// @notice Buys a _destAmount of tokens at UniswapV2\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint srcAmount\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\n\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        uint[] memory amounts;\n        address[] memory path = new address[](2);\n        path[0] = _srcAddr;\n        path[1] = _destAddr;\n\n        ERC20(_srcAddr).safeApprove(address(router), uint(-1));\n\n\n         // if we are buying ether\n        if (_destAddr == WETH_ADDRESS) {\n            amounts = router.swapTokensForExactETH(_destAmount, uint(-1), path, msg.sender, block.timestamp + 1);\n        }\n        // if we are buying token to token\n        else {\n            amounts = router.swapTokensForExactTokens(_destAmount, uint(-1), path, msg.sender, block.timestamp + 1);\n        }\n\n        // Send the leftover from the source token back\n        sendLeftOver(_srcAddr);\n\n        return amounts[0];\n    }\n\n    /// @notice Return a rate for which we can sell an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Rate\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint) {\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        address[] memory path = new address[](2);\n        path[0] = _srcAddr;\n        path[1] = _destAddr;\n\n        uint[] memory amounts = router.getAmountsOut(_srcAmount, path);\n        return wdiv(amounts[amounts.length - 1], _srcAmount);\n    }\n\n    /// @notice Return a rate for which we can buy an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint Rate\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount) public override view returns (uint) {\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        address[] memory path = new address[](2);\n        path[0] = _srcAddr;\n        path[1] = _destAddr;\n\n        uint[] memory amounts = router.getAmountsIn(_destAmount, path);\n        return wdiv(_destAmount, amounts[0]);\n    }\n\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\n    /// @param _srcAddr Source token address\n    function sendLeftOver(address _srcAddr) internal {\n        msg.sender.transfer(address(this).balance);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            ERC20(_srcAddr).safeTransfer(msg.sender, ERC20(_srcAddr).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Converts Kybers Eth address -> Weth\n    /// @param _src Input address\n    function ethToWethAddr(address _src) internal pure returns (address) {\n        return _src == KYBER_ETH_ADDRESS ? WETH_ADDRESS : _src;\n    }\n\n    function getDecimals(address _token) internal view returns (uint256) {\n        if (_token == KYBER_ETH_ADDRESS) return 18;\n\n        return ERC20(_token).decimals();\n    }\n\n    receive() payable external {}\n}\n"
375     },
376     "contracts/exchange/wrappers/UniswapWrapper.sol": {
377       "content": "pragma solidity ^0.6.0;\n\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../interfaces/KyberNetworkProxyInterface.sol\";\nimport \"../../interfaces/ExchangeInterfaceV2.sol\";\nimport \"../../interfaces/UniswapExchangeInterface.sol\";\nimport \"../../interfaces/UniswapFactoryInterface.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\ncontract UniswapWrapper is DSMath, ExchangeInterfaceV2, AdminAuth {\n\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant UNISWAP_FACTORY = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;\n\n    using SafeERC20 for ERC20;\n\n    /// @notice Sells a _srcAmount of tokens at Uniswap\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Destination amount\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external payable override returns (uint) {\n        address uniswapExchangeAddr;\n        uint destAmount;\n\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        // if we are buying ether\n        if (_destAddr == WETH_ADDRESS) {\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, _srcAmount);\n\n            destAmount = UniswapExchangeInterface(uniswapExchangeAddr).\n                tokenToEthTransferInput(_srcAmount, 1, block.timestamp + 1, msg.sender);\n        }\n        // if we are selling token to token\n        else {\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, _srcAmount);\n\n            destAmount = UniswapExchangeInterface(uniswapExchangeAddr).\n                tokenToTokenTransferInput(_srcAmount, 1, 1, block.timestamp + 1, msg.sender, _destAddr);\n        }\n\n        return destAmount;\n    }\n\n    /// @notice Buys a _destAmount of tokens at Uniswap\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint srcAmount\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\n        address uniswapExchangeAddr;\n        uint srcAmount;\n\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n         // if we are buying ether\n        if (_destAddr == WETH_ADDRESS) {\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, uint(-1));\n\n            srcAmount = UniswapExchangeInterface(uniswapExchangeAddr).\n                tokenToEthTransferOutput(_destAmount, uint(-1), block.timestamp + 1, msg.sender);\n        }\n        // if we are buying token to token\n        else {\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, uint(-1));\n\n            srcAmount = UniswapExchangeInterface(uniswapExchangeAddr).\n                tokenToTokenTransferOutput(_destAmount, uint(-1), uint(-1), block.timestamp + 1, msg.sender, _destAddr);\n        }\n\n        // Send the leftover from the source token back\n        sendLeftOver(_srcAddr);\n\n        return srcAmount;\n    }\n\n    /// @notice Return a rate for which we can sell an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Rate\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint) {\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        if(_srcAddr == WETH_ADDRESS) {\n            address uniswapTokenAddress = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr);\n            return wdiv(UniswapExchangeInterface(uniswapTokenAddress).getEthToTokenInputPrice(_srcAmount), _srcAmount);\n        } else if (_destAddr == WETH_ADDRESS) {\n            address uniswapTokenAddress = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n            return wdiv(UniswapExchangeInterface(uniswapTokenAddress).getTokenToEthInputPrice(_srcAmount), _srcAmount);\n        } else {\n            uint ethBought = UniswapExchangeInterface(UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr)).getTokenToEthInputPrice(_srcAmount);\n            return wdiv(UniswapExchangeInterface(UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr)).getEthToTokenInputPrice(ethBought), _srcAmount);\n        }\n    }\n\n    /// @notice Return a rate for which we can buy an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint Rate\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount) public override view returns (uint) {\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        if(_srcAddr == WETH_ADDRESS) {\n            address uniswapTokenAddress = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr);\n            return wdiv(1 ether, wdiv(UniswapExchangeInterface(uniswapTokenAddress).getEthToTokenOutputPrice(_destAmount), _destAmount));\n        } else if (_destAddr == WETH_ADDRESS) {\n            address uniswapTokenAddress = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n            return wdiv(1 ether, wdiv(UniswapExchangeInterface(uniswapTokenAddress).getTokenToEthOutputPrice(_destAmount), _destAmount));\n        } else {\n            uint ethNeeded = UniswapExchangeInterface(UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr)).getTokenToEthOutputPrice(_destAmount);\n            return wdiv(1 ether, wdiv(UniswapExchangeInterface(UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr)).getEthToTokenOutputPrice(ethNeeded), _destAmount));\n        }\n    }\n\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\n    /// @param _srcAddr Source token address\n    function sendLeftOver(address _srcAddr) internal {\n        msg.sender.transfer(address(this).balance);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            ERC20(_srcAddr).safeTransfer(msg.sender, ERC20(_srcAddr).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Converts Kybers Eth address -> Weth\n    /// @param _src Input address\n    function ethToWethAddr(address _src) internal pure returns (address) {\n        return _src == KYBER_ETH_ADDRESS ? WETH_ADDRESS : _src;\n    }\n\n    receive() payable external {}\n}\n"
378     },
379     "contracts/interfaces/UniswapExchangeInterface.sol": {
380       "content": "pragma solidity ^0.6.0;\n\nabstract contract UniswapExchangeInterface {\n    function getEthToTokenInputPrice(uint256 eth_sold)\n        external virtual\n        view\n        returns (uint256 tokens_bought);\n\n    function getEthToTokenOutputPrice(uint256 tokens_bought)\n        external virtual\n        view\n        returns (uint256 eth_sold);\n\n    function getTokenToEthInputPrice(uint256 tokens_sold)\n        external virtual\n        view\n        returns (uint256 eth_bought);\n\n    function getTokenToEthOutputPrice(uint256 eth_bought)\n        external virtual\n        view\n        returns (uint256 tokens_sold);\n\n    function tokenToEthTransferInput(\n        uint256 tokens_sold,\n        uint256 min_eth,\n        uint256 deadline,\n        address recipient\n    ) external virtual returns (uint256 eth_bought);\n\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient)\n        external virtual\n        payable\n        returns (uint256 tokens_bought);\n\n    function tokenToTokenTransferInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address recipient,\n        address token_addr\n    ) external virtual returns (uint256 tokens_bought);\n\n    function ethToTokenTransferOutput(\n        uint256 tokens_bought,\n        uint256 deadline,\n        address recipient\n    ) external virtual payable returns (uint256  eth_sold);\n\n    function tokenToEthTransferOutput(\n        uint256 eth_bought,\n        uint256 max_tokens,\n        uint256 deadline,\n        address recipient\n    ) external virtual returns (uint256  tokens_sold);\n\n    function tokenToTokenTransferOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address recipient,\n        address token_addr\n    ) external virtual returns (uint256  tokens_sold);\n\n}\n"
381     },
382     "contracts/interfaces/UniswapFactoryInterface.sol": {
383       "content": "pragma solidity ^0.6.0;\n\nabstract contract UniswapFactoryInterface {\n    function getExchange(address token) external view virtual returns (address exchange);\n}\n"
384     },
385     "contracts/exchange/wrappers/KyberWrapper.sol": {
386       "content": "pragma solidity ^0.6.0;\n\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../interfaces/KyberNetworkProxyInterface.sol\";\nimport \"../../interfaces/ExchangeInterfaceV2.sol\";\nimport \"../../interfaces/IFeeRecipient.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\ncontract KyberWrapper is DSMath, ExchangeInterfaceV2, AdminAuth {\n\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant KYBER_INTERFACE = 0x9AAb3f75489902f3a48495025729a0AF77d4b11e;\n\n    IFeeRecipient public constant feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);\n\n    using SafeERC20 for ERC20;\n\n    /// @notice Sells a _srcAmount of tokens at Kyber\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Destination amount\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external override payable returns (uint) {\n        ERC20 srcToken = ERC20(_srcAddr);\n        ERC20 destToken = ERC20(_destAddr);\n\n        address walletAddr = feeRecipient.getFeeAddr();\n\n        KyberNetworkProxyInterface kyberNetworkProxy = KyberNetworkProxyInterface(KYBER_INTERFACE);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcToken.safeApprove(address(kyberNetworkProxy), _srcAmount);\n        }\n\n        uint destAmount = kyberNetworkProxy.trade{value: msg.value}(\n            srcToken,\n            _srcAmount,\n            destToken,\n            msg.sender,\n            uint(-1),\n            0,\n            walletAddr\n        );\n\n        return destAmount;\n    }\n\n    /// @notice Buys a _destAmount of tokens at Kyber\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint srcAmount\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\n        ERC20 srcToken = ERC20(_srcAddr);\n        ERC20 destToken = ERC20(_destAddr);\n\n        address walletAddr = feeRecipient.getFeeAddr();\n\n        uint srcAmount = 0;\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcAmount = srcToken.balanceOf(address(this));\n        } else {\n            srcAmount = msg.value;\n        }\n\n        KyberNetworkProxyInterface kyberNetworkProxy = KyberNetworkProxyInterface(KYBER_INTERFACE);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcToken.safeApprove(address(kyberNetworkProxy), srcAmount);\n        }\n\n        uint destAmount = kyberNetworkProxy.trade{value: msg.value}(\n            srcToken,\n            srcAmount,\n            destToken,\n            msg.sender,\n            _destAmount,\n            0,\n            walletAddr\n        );\n\n        require(destAmount == _destAmount, \"Wrong dest amount\");\n\n        uint srcAmountAfter = 0;\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcAmountAfter = srcToken.balanceOf(address(this));\n        } else {\n            srcAmountAfter = address(this).balance;\n        }\n\n        // Send the leftover from the source token back\n        sendLeftOver(_srcAddr);\n\n        return (srcAmount - srcAmountAfter);\n    }\n\n    /// @notice Return a rate for which we can sell an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return rate Rate\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint rate) {\n        (rate, ) = KyberNetworkProxyInterface(KYBER_INTERFACE)\n            .getExpectedRate(ERC20(_srcAddr), ERC20(_destAddr), _srcAmount);\n\n        // multiply with decimal difference in src token\n        rate = rate * (10**(18 - getDecimals(_srcAddr)));\n        // divide with decimal difference in dest token\n        rate = rate / (10**(18 - getDecimals(_destAddr)));\n    }\n\n    /// @notice Return a rate for which we can buy an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return rate Rate\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount) public override view returns (uint rate) {\n        uint256 srcRate = getSellRate(_destAddr, _srcAddr, _destAmount);\n        uint256 srcAmount = wmul(srcRate, _destAmount);\n\n        rate = getSellRate(_srcAddr, _destAddr, srcAmount);\n\n        // increase rate by 3% too account for inaccuracy between sell/buy conversion\n        rate = rate + (rate / 30);\n    }\n\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\n    /// @param _srcAddr Source token address\n    function sendLeftOver(address _srcAddr) internal {\n        msg.sender.transfer(address(this).balance);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            ERC20(_srcAddr).safeTransfer(msg.sender, ERC20(_srcAddr).balanceOf(address(this)));\n        }\n    }\n\n    receive() payable external {}\n\n    function getDecimals(address _token) internal view returns (uint256) {\n        if (_token == KYBER_ETH_ADDRESS) return 18;\n\n        return ERC20(_token).decimals();\n    }\n}\n"
387     },
388     "contracts/exchange/wrappers/OasisTradeWrapper.sol": {
389       "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/ExchangeInterfaceV2.sol\";\nimport \"../../interfaces/OasisInterface.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\ncontract OasisTradeWrapper is DSMath, ExchangeInterfaceV2, AdminAuth {\n\n    using SafeERC20 for ERC20;\n\n    address public constant OTC_ADDRESS = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Sells a _srcAmount of tokens at Oasis\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Destination amount\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external override payable returns (uint) {\n        address srcAddr = ethToWethAddr(_srcAddr);\n        address destAddr = ethToWethAddr(_destAddr);\n\n        ERC20(srcAddr).safeApprove(OTC_ADDRESS, _srcAmount);\n\n        uint destAmount = OasisInterface(OTC_ADDRESS).sellAllAmount(srcAddr, _srcAmount, destAddr, 0);\n\n        // convert weth -> eth and send back\n        if (destAddr == WETH_ADDRESS) {\n            TokenInterface(WETH_ADDRESS).withdraw(destAmount);\n            msg.sender.transfer(destAmount);\n        } else {\n            ERC20(destAddr).safeTransfer(msg.sender, destAmount);\n        }\n\n        return destAmount;\n    }\n\n    /// @notice Buys a _destAmount of tokens at Oasis\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint srcAmount\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\n        address srcAddr = ethToWethAddr(_srcAddr);\n        address destAddr = ethToWethAddr(_destAddr);\n\n        ERC20(srcAddr).safeApprove(OTC_ADDRESS, uint(-1));\n\n        uint srcAmount = OasisInterface(OTC_ADDRESS).buyAllAmount(destAddr, _destAmount, srcAddr, uint(-1));\n\n        // convert weth -> eth and send back\n        if (destAddr == WETH_ADDRESS) {\n            TokenInterface(WETH_ADDRESS).withdraw(_destAmount);\n            msg.sender.transfer(_destAmount);\n        } else {\n            ERC20(destAddr).safeTransfer(msg.sender, _destAmount);\n        }\n\n        // Send the leftover from the source token back\n        sendLeftOver(srcAddr);\n\n        return srcAmount;\n    }\n\n    /// @notice Return a rate for which we can sell an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Rate\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint) {\n        address srcAddr = ethToWethAddr(_srcAddr);\n        address destAddr = ethToWethAddr(_destAddr);\n\n        return wdiv(OasisInterface(OTC_ADDRESS).getBuyAmount(destAddr, srcAddr, _srcAmount), _srcAmount);\n    }\n\n\n    /// @notice Return a rate for which we can buy an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint Rate\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount) public override view returns (uint) {\n        address srcAddr = ethToWethAddr(_srcAddr);\n        address destAddr = ethToWethAddr(_destAddr);\n\n        return wdiv(1 ether, wdiv(OasisInterface(OTC_ADDRESS).getPayAmount(srcAddr, destAddr, _destAmount), _destAmount));\n    }\n\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\n    /// @param _srcAddr Source token address\n     function sendLeftOver(address _srcAddr) internal {\n        msg.sender.transfer(address(this).balance);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            ERC20(_srcAddr).safeTransfer(msg.sender, ERC20(_srcAddr).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Converts Kybers Eth address -> Weth\n    /// @param _src Input address\n    function ethToWethAddr(address _src) internal pure returns (address) {\n        return _src == KYBER_ETH_ADDRESS ? WETH_ADDRESS : _src;\n    }\n\n\n    receive() payable external {}\n}\n"
390     },
391     "contracts/exchange/Prices.sol": {
392       "content": "pragma solidity ^0.6.0;\n\nimport \"../DS/DSMath.sol\";\nimport \"../interfaces/TokenInterface.sol\";\nimport \"../interfaces/ExchangeInterfaceV2.sol\";\nimport \"./SaverExchangeHelper.sol\";\n\ncontract Prices is DSMath {\n\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    enum ActionType { SELL, BUY }\n\n\n    /// @notice Returns the best estimated price from 2 exchanges\n    /// @param _amount Amount of source tokens you want to exchange\n    /// @param _srcToken Address of the source token\n    /// @param _destToken Address of the destination token\n    /// @param _type Type of action SELL|BUY\n    /// @param _wrappers Array of wrapper addresses to compare\n    /// @return (address, uint) The address of the best exchange and the exchange price\n    function getBestPrice(\n        uint256 _amount,\n        address _srcToken,\n        address _destToken,\n        ActionType _type,\n        address[] memory _wrappers\n    ) public returns (address, uint256) {\n\n        uint256[] memory rates = new uint256[](_wrappers.length);\n        for (uint i=0; i<_wrappers.length; i++) {\n            rates[i] = getExpectedRate(_wrappers[i], _srcToken, _destToken, _amount, _type);\n        }\n\n        return getBiggestRate(_wrappers, rates);\n    }\n\n    /// @notice Return the expected rate from the exchange wrapper\n    /// @dev In case of Oasis/Uniswap handles the different precision tokens\n    /// @param _wrapper Address of exchange wrapper\n    /// @param _srcToken From token\n    /// @param _destToken To token\n    /// @param _amount Amount to be exchanged\n    /// @param _type Type of action SELL|BUY\n    function getExpectedRate(\n        address _wrapper,\n        address _srcToken,\n        address _destToken,\n        uint256 _amount,\n        ActionType _type\n    ) public returns (uint256) {\n        bool success;\n        bytes memory result;\n\n        if (_type == ActionType.SELL) {\n            (success, result) = _wrapper.call(abi.encodeWithSignature(\n                \"getSellRate(address,address,uint256)\",\n                _srcToken,\n                _destToken,\n                _amount\n            ));\n\n        } else {\n            (success, result) = _wrapper.call(abi.encodeWithSignature(\n                \"getBuyRate(address,address,uint256)\",\n                _srcToken,\n                _destToken,\n                _amount\n            ));\n        }\n\n        if (success) {\n            return sliceUint(result, 0);\n        }\n\n        return 0;\n    }\n\n    /// @notice Finds the biggest rate between exchanges, needed for sell rate\n    /// @param _wrappers Array of wrappers to compare\n    /// @param _rates Array of rates to compare\n    function getBiggestRate(\n        address[] memory _wrappers,\n        uint256[] memory _rates\n    ) internal pure returns (address, uint) {\n        uint256 maxIndex = 0;\n\n        // starting from 0 in case there is only one rate in array\n        for (uint256 i=0; i<_rates.length; i++) {\n            if (_rates[i] > _rates[maxIndex]) {\n                maxIndex = i;\n            }\n        }\n\n        return (_wrappers[maxIndex], _rates[maxIndex]);\n    }\n\n    function getDecimals(address _token) internal view returns (uint256) {\n        if (_token == KYBER_ETH_ADDRESS) return 18;\n\n        return ERC20(_token).decimals();\n    }\n\n    function sliceUint(bytes memory bs, uint256 start) internal pure returns (uint256) {\n        require(bs.length >= start + 32, \"slicing out of range\");\n\n        uint256 x;\n        assembly {\n            x := mload(add(bs, add(0x20, start)))\n        }\n\n        return x;\n    }\n}\n"
393     },
394     "contracts/exchangeV3/DFSPricesV3.sol": {
395       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../DS/DSMath.sol\";\nimport \"../interfaces/TokenInterface.sol\";\nimport \"../interfaces/ExchangeInterfaceV3.sol\";\nimport \"../utils/SafeERC20.sol\";\n\ncontract DFSPrices is DSMath {\n\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    enum ActionType { SELL, BUY }\n\n\n    /// @notice Returns the best estimated price from 2 exchanges\n    /// @param _amount Amount of source tokens you want to exchange\n    /// @param _srcToken Address of the source token\n    /// @param _destToken Address of the destination token\n    /// @param _type Type of action SELL|BUY\n    /// @param _wrappers Array of wrapper addresses to compare\n    /// @return (address, uint) The address of the best exchange and the exchange price\n    function getBestPrice(\n        uint256 _amount,\n        address _srcToken,\n        address _destToken,\n        ActionType _type,\n        address[] memory _wrappers,\n        bytes[] memory _additionalData\n    ) public returns (address, uint256) {\n\n        uint256[] memory rates = new uint256[](_wrappers.length);\n        for (uint i=0; i<_wrappers.length; i++) {\n            rates[i] = getExpectedRate(_wrappers[i], _srcToken, _destToken, _amount, _type, _additionalData[i]);\n        }\n\n        return getBiggestRate(_wrappers, rates);\n    }\n\n    /// @notice Return the expected rate from the exchange wrapper\n    /// @dev In case of Oasis/Uniswap handles the different precision tokens\n    /// @param _wrapper Address of exchange wrapper\n    /// @param _srcToken From token\n    /// @param _destToken To token\n    /// @param _amount Amount to be exchanged\n    /// @param _type Type of action SELL|BUY\n    function getExpectedRate(\n        address _wrapper,\n        address _srcToken,\n        address _destToken,\n        uint256 _amount,\n        ActionType _type,\n        bytes memory _additionalData\n    ) public returns (uint256) {\n        bool success;\n        bytes memory result;\n\n        if (_type == ActionType.SELL) {\n            (success, result) = _wrapper.call(abi.encodeWithSignature(\n                \"getSellRate(address,address,uint256,bytes)\",\n                _srcToken,\n                _destToken,\n                _amount,\n                _additionalData\n            ));\n\n        } else {\n            (success, result) = _wrapper.call(abi.encodeWithSignature(\n                \"getBuyRate(address,address,uint256,bytes)\",\n                _srcToken,\n                _destToken,\n                _amount,\n                _additionalData\n            ));\n        }\n\n        if (success) {\n            return sliceUint(result, 0);\n        }\n\n        return 0;\n    }\n\n    /// @notice Finds the biggest rate between exchanges, needed for sell rate\n    /// @param _wrappers Array of wrappers to compare\n    /// @param _rates Array of rates to compare\n    function getBiggestRate(\n        address[] memory _wrappers,\n        uint256[] memory _rates\n    ) internal pure returns (address, uint) {\n        uint256 maxIndex = 0;\n\n        // starting from 0 in case there is only one rate in array\n        for (uint256 i=0; i<_rates.length; i++) {\n            if (_rates[i] > _rates[maxIndex]) {\n                maxIndex = i;\n            }\n        }\n\n        return (_wrappers[maxIndex], _rates[maxIndex]);\n    }\n\n    function getDecimals(address _token) internal view returns (uint256) {\n        if (_token == KYBER_ETH_ADDRESS) return 18;\n\n        return ERC20(_token).decimals();\n    }\n\n    function sliceUint(bytes memory bs, uint256 start) internal pure returns (uint256) {\n        require(bs.length >= start + 32, \"slicing out of range\");\n\n        uint256 x;\n        assembly {\n            x := mload(add(bs, add(0x20, start)))\n        }\n\n        return x;\n    }\n}\n"
396     },
397     "contracts/exchangeV3/offchainWrappersV3/ZeroxWrapper.sol": {
398       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../DFSExchangeHelper.sol\";\nimport \"../../interfaces/OffchainWrapperInterface.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\n\ncontract ZeroxWrapper is OffchainWrapperInterface, DFSExchangeHelper, AdminAuth, DSMath {\n    string public constant ERR_SRC_AMOUNT = \"Not enough funds\";\n    string public constant ERR_PROTOCOL_FEE = \"Not enough eth for protcol fee\";\n    string public constant ERR_TOKENS_SWAPED_ZERO = \"Order success but amount 0\";\n\n    using SafeERC20 for ERC20;\n\n    /// @notice Takes order from 0x and returns bool indicating if it is successful\n    /// @param _exData Exchange data\n    /// @param _type Action type (buy or sell)\n    function takeOrder(\n        ExchangeData memory _exData,\n        ActionType _type\n    ) override public payable returns (bool success, uint256) {\n        // check that contract have enough balance for exchange and protocol fee\n        require(getBalance(_exData.srcAddr) >= _exData.srcAmount, ERR_SRC_AMOUNT);\n        require(getBalance(KYBER_ETH_ADDRESS) >= _exData.offchainData.protocolFee, ERR_PROTOCOL_FEE);\n\n        /// @dev 0x always uses max approve in v1, so we approve the exact amount we want to sell\n        /// @dev safeApprove is modified to always first set approval to 0, then to exact amount\n        if (_type == ActionType.SELL) {\n            ERC20(_exData.srcAddr).safeApprove(_exData.offchainData.allowanceTarget, _exData.srcAmount);\n        } else {\n            uint srcAmount = wdiv(_exData.destAmount, _exData.offchainData.price) + 1; // + 1 so we round up\n            ERC20(_exData.srcAddr).safeApprove(_exData.offchainData.allowanceTarget, srcAmount);\n        }\n        // we know that it will be eth if dest addr is either weth or eth\n        address destAddr = _exData.destAddr == KYBER_ETH_ADDRESS ? EXCHANGE_WETH_ADDRESS : _exData.destAddr;\n\n        uint256 tokensBefore = getBalance(destAddr);\n        (success, ) = _exData.offchainData.exchangeAddr.call{value: _exData.offchainData.protocolFee}(_exData.offchainData.callData);\n        uint256 tokensSwaped = 0;\n\n        if (success) {\n            // get the current balance of the swaped tokens\n            tokensSwaped = getBalance(destAddr) - tokensBefore;\n            require(tokensSwaped > 0, ERR_TOKENS_SWAPED_ZERO);\n        }\n\n        // returns all funds from src addr, dest addr and eth funds (protocol fee leftovers)\n        sendLeftover(_exData.srcAddr, destAddr, msg.sender);\n\n        return (success, tokensSwaped);\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external virtual payable {}\n}\n"
399     },
400     "contracts/exchangeV3/offchainWrappersV3/ScpWrapper.sol": {
401       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../DFSExchangeHelper.sol\";\nimport \"../../interfaces/OffchainWrapperInterface.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\n\ncontract ScpWrapper is OffchainWrapperInterface, DFSExchangeHelper, AdminAuth, DSMath {\n\n    string public constant ERR_SRC_AMOUNT = \"Not enough funds\";\n    string public constant ERR_PROTOCOL_FEE = \"Not enough eth for protcol fee\";\n    string public constant ERR_TOKENS_SWAPED_ZERO = \"Order success but amount 0\";\n\n    using SafeERC20 for ERC20;\n\n    /// @notice Takes order from Scp and returns bool indicating if it is successful\n    /// @param _exData Exchange data\n    /// @param _type Action type (buy or sell)\n    function takeOrder(\n        ExchangeData memory _exData,\n        ActionType _type\n    ) override public payable returns (bool success, uint256) {\n        // check that contract have enough balance for exchange and protocol fee\n        require(getBalance(_exData.srcAddr) >= _exData.srcAmount, ERR_SRC_AMOUNT);\n        require(getBalance(KYBER_ETH_ADDRESS) >= _exData.offchainData.protocolFee, ERR_PROTOCOL_FEE);\n\n        ERC20(_exData.srcAddr).safeApprove(_exData.offchainData.allowanceTarget, _exData.srcAmount);\n\n        // write in the exact amount we are selling/buing in an order\n        if (_type == ActionType.SELL) {\n            writeUint256(_exData.offchainData.callData, 36, _exData.srcAmount);\n        } else {\n            uint srcAmount = wdiv(_exData.destAmount, _exData.offchainData.price) + 1; // + 1 so we round up\n            writeUint256(_exData.offchainData.callData, 36, srcAmount);\n        }\n\n        // we know that it will be eth if dest addr is either weth or eth\n        address destAddr = _exData.destAddr == KYBER_ETH_ADDRESS ? EXCHANGE_WETH_ADDRESS : _exData.destAddr;\n\n        uint256 tokensBefore = getBalance(destAddr);\n        (success, ) = _exData.offchainData.exchangeAddr.call{value: _exData.offchainData.protocolFee}(_exData.offchainData.callData);\n        uint256 tokensSwaped = 0;\n\n\n        if (success) {\n            // get the current balance of the swaped tokens\n            tokensSwaped = getBalance(destAddr) - tokensBefore;\n            require(tokensSwaped > 0, ERR_TOKENS_SWAPED_ZERO);\n        }\n\n        // returns all funds from src addr, dest addr and eth funds (protocol fee leftovers)\n        sendLeftover(_exData.srcAddr, destAddr, msg.sender);\n\n        return (success, tokensSwaped);\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external virtual payable {}\n}\n"
402     },
403     "contracts/aave/AaveHelper.sol": {
404       "content": "pragma solidity ^0.6.0;\n\nimport \"../DS/DSMath.sol\";\nimport \"../DS/DSProxy.sol\";\nimport \"../utils/Discount.sol\";\nimport \"../interfaces/IFeeRecipient.sol\";\nimport \"../interfaces/IAToken.sol\";\nimport \"../interfaces/ILendingPool.sol\";\nimport \"../interfaces/ILendingPoolAddressesProvider.sol\";\nimport \"../interfaces/IPriceOracleGetterAave.sol\";\n\nimport \"../utils/SafeERC20.sol\";\nimport \"../utils/BotRegistry.sol\";\n\ncontract AaveHelper is DSMath {\n\n    using SafeERC20 for ERC20;\n\n    IFeeRecipient public constant feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);\n\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    uint public constant MANUAL_SERVICE_FEE = 400; // 0.25% Fee\n    uint public constant AUTOMATIC_SERVICE_FEE = 333; // 0.3% Fee\n\n    address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;\n\n\taddress public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant AAVE_LENDING_POOL_ADDRESSES = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\n    uint public constant NINETY_NINE_PERCENT_WEI = 990000000000000000;\n    uint16 public constant AAVE_REFERRAL_CODE = 64;\n\n    /// @param _collateralAddress underlying token address\n    /// @param _user users address\n\tfunction getMaxCollateral(address _collateralAddress, address _user) public view returns (uint256) {\n        address lendingPoolAddressDataProvider = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolDataProvider();\n        address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n        uint256 pow10 = 10 ** (18 - _getDecimals(_collateralAddress));\n\n        // fetch all needed data\n        (,uint256 totalCollateralETH, uint256 totalBorrowsETH,,uint256 currentLTV,,,) = ILendingPool(lendingPoolAddressDataProvider).calculateUserGlobalData(_user);\n        (,uint256 tokenLTV,,) = ILendingPool(lendingPoolCoreAddress).getReserveConfiguration(_collateralAddress);\n        uint256 collateralPrice = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_collateralAddress);\n        uint256 userTokenBalance = ILendingPool(lendingPoolCoreAddress).getUserUnderlyingAssetBalance(_collateralAddress, _user);\n        uint256 userTokenBalanceEth = wmul(userTokenBalance * pow10, collateralPrice);\n\n\t\t// if borrow is 0, return whole user balance\n        if (totalBorrowsETH == 0) {\n        \treturn userTokenBalance;\n        }\n\n        uint256 maxCollateralEth = div(sub(mul(currentLTV, totalCollateralETH), mul(totalBorrowsETH, 100)), currentLTV);\n\t\t/// @dev final amount can't be higher than users token balance\n        maxCollateralEth = maxCollateralEth > userTokenBalanceEth ? userTokenBalanceEth : maxCollateralEth;\n\n        // might happen due to wmul precision\n        if (maxCollateralEth >= totalCollateralETH) {\n        \treturn wdiv(totalCollateralETH, collateralPrice) / pow10;\n        }\n\n        // get sum of all other reserves multiplied with their liquidation thresholds by reversing formula\n        uint256 a = sub(wmul(currentLTV, totalCollateralETH), wmul(tokenLTV, userTokenBalanceEth));\n        // add new collateral amount multiplied by its threshold, and then divide with new total collateral\n        uint256 newLiquidationThreshold = wdiv(add(a, wmul(sub(userTokenBalanceEth, maxCollateralEth), tokenLTV)), sub(totalCollateralETH, maxCollateralEth));\n\n        // if new threshold is lower than first one, calculate new max collateral with newLiquidationThreshold\n        if (newLiquidationThreshold < currentLTV) {\n        \tmaxCollateralEth = div(sub(mul(newLiquidationThreshold, totalCollateralETH), mul(totalBorrowsETH, 100)), newLiquidationThreshold);\n        \tmaxCollateralEth = maxCollateralEth > userTokenBalanceEth ? userTokenBalanceEth : maxCollateralEth;\n        }\n\n\t\treturn wmul(wdiv(maxCollateralEth, collateralPrice) / pow10, NINETY_NINE_PERCENT_WEI);\n\t}\n\n\t/// @param _borrowAddress underlying token address\n\t/// @param _user users address\n\tfunction getMaxBorrow(address _borrowAddress, address _user) public view returns (uint256) {\n\t\taddress lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\t\taddress priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n\t\t(,,,,uint256 availableBorrowsETH,,,) = ILendingPool(lendingPoolAddress).getUserAccountData(_user);\n\n\t\tuint256 borrowPrice = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_borrowAddress);\n\n\t\treturn wmul(wdiv(availableBorrowsETH, borrowPrice) / (10 ** (18 - _getDecimals(_borrowAddress))), NINETY_NINE_PERCENT_WEI);\n\t}\n\n    function getMaxBoost(address _borrowAddress, address _collateralAddress, address _user) public view returns (uint256) {\n        address lendingPoolAddressDataProvider = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolDataProvider();\n        address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n        (,uint256 totalCollateralETH, uint256 totalBorrowsETH,,uint256 currentLTV,,,) = ILendingPool(lendingPoolAddressDataProvider).calculateUserGlobalData(_user);\n        (,uint256 tokenLTV,,) = ILendingPool(lendingPoolCoreAddress).getReserveConfiguration(_collateralAddress);\n        totalCollateralETH = div(mul(totalCollateralETH, currentLTV), 100);\n\n        uint256 availableBorrowsETH = wmul(mul(div(sub(totalCollateralETH, totalBorrowsETH), sub(100, tokenLTV)), 100), NINETY_NINE_PERCENT_WEI);\n        uint256 borrowPrice = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_borrowAddress);\n\n        return wdiv(availableBorrowsETH, borrowPrice) / (10 ** (18 - _getDecimals(_borrowAddress)));\n    }\n\n    /// @notice Calculates the fee amount\n    /// @param _amount Amount that is converted\n    /// @param _user Actuall user addr not DSProxy\n    /// @param _gasCost Ether amount of gas we are spending for tx\n    /// @param _tokenAddr token addr. of token we are getting for the fee\n    /// @return feeAmount The amount we took for the fee\n    function getFee(uint _amount, address _user, uint _gasCost, address _tokenAddr) internal returns (uint feeAmount) {\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n        uint fee = MANUAL_SERVICE_FEE;\n\n        if (BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin)) {\n            fee = AUTOMATIC_SERVICE_FEE;\n        }\n\n        if (Discount(DISCOUNT_ADDR).isCustomFeeSet(_user)) {\n            fee = Discount(DISCOUNT_ADDR).getCustomServiceFee(_user);\n        }\n\n        feeAmount = (fee == 0) ? 0 : (_amount / fee);\n\n        if (_gasCost != 0) {\n            uint256 price = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokenAddr);\n\n            _gasCost = wdiv(_gasCost, price) / (10 ** (18 - _getDecimals(_tokenAddr)));\n\n            feeAmount = add(feeAmount, _gasCost);\n        }\n\n        // fee can't go over 20% of the whole amount\n        if (feeAmount > (_amount / 5)) {\n            feeAmount = _amount / 5;\n        }\n\n        address walletAddr = feeRecipient.getFeeAddr();\n\n        if (_tokenAddr == ETH_ADDR) {\n            payable(walletAddr).transfer(feeAmount);\n        } else {\n            ERC20(_tokenAddr).safeTransfer(walletAddr, feeAmount);\n        }\n    }\n\n    /// @notice Calculates the gas cost for transaction\n    /// @param _amount Amount that is converted\n    /// @param _user Actuall user addr not DSProxy\n    /// @param _gasCost Ether amount of gas we are spending for tx\n    /// @param _tokenAddr token addr. of token we are getting for the fee\n    /// @return gasCost The amount we took for the gas cost\n    function getGasCost(uint _amount, address _user, uint _gasCost, address _tokenAddr) internal returns (uint gasCost) {\n\n        if (_gasCost == 0) return 0;\n\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n        uint256 price = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokenAddr);\n\n        _gasCost = wmul(_gasCost, price);\n        gasCost = _gasCost;\n\n        // fee can't go over 20% of the whole amount\n        if (gasCost > (_amount / 5)) {\n            gasCost = _amount / 5;\n        }\n\n        address walletAddr = feeRecipient.getFeeAddr();\n\n        if (_tokenAddr == ETH_ADDR) {\n            payable(walletAddr).transfer(gasCost);\n        } else {\n            ERC20(_tokenAddr).safeTransfer(walletAddr, gasCost);\n        }\n    }\n\n\n    /// @notice Returns the owner of the DSProxy that called the contract\n    function getUserAddress() internal view returns (address) {\n        DSProxy proxy = DSProxy(payable(address(this)));\n\n        return proxy.owner();\n    }\n\n    /// @notice Approves token contract to pull underlying tokens from the DSProxy\n    /// @param _tokenAddr Token we are trying to approve\n    /// @param _caller Address which will gain the approval\n    function approveToken(address _tokenAddr, address _caller) internal {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeApprove(_caller, uint256(-1));\n        }\n    }\n\n    /// @notice Send specific amount from contract to specific user\n    /// @param _token Token we are trying to send\n    /// @param _user User that should receive funds\n    /// @param _amount Amount that should be sent\n    function sendContractBalance(address _token, address _user, uint _amount) public {\n        if (_amount == 0) return;\n\n        if (_token == ETH_ADDR) {\n            payable(_user).transfer(_amount);\n        } else {\n            ERC20(_token).safeTransfer(_user, _amount);\n        }\n    }\n\n    function sendFullContractBalance(address _token, address _user) public {\n        if (_token == ETH_ADDR) {\n            sendContractBalance(_token, _user, address(this).balance);\n        } else {\n            sendContractBalance(_token, _user, ERC20(_token).balanceOf(address(this)));\n        }\n    }\n\n    function _getDecimals(address _token) internal view returns (uint256) {\n        if (_token == ETH_ADDR) return 18;\n\n        return ERC20(_token).decimals();\n    }\n\n    function isAutomation() internal view returns(bool) {\n        return BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin);\n    }\n}\n"
405     },
406     "contracts/aave/saver/AaveSaverReceiver.sol": {
407       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../savings/dydx/ISoloMargin.sol\";\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\nimport \"../../DS/DSProxy.sol\";\nimport \"../AaveHelper.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../../exchangeV3/DFSExchangeData.sol\";\n\n/// @title Import Aave position from account to wallet\ncontract AaveSaverReceiver is AaveHelper, AdminAuth, DFSExchangeData {\n\n    using SafeERC20 for ERC20;\n\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant AAVE_SAVER_PROXY = 0x2a3B273695A045EC263970e3C86c23800a0F04FC;\n    address public constant AAVE_BASIC_PROXY = 0xd042D4E9B4186c545648c7FfFe87125c976D110B;\n    address public constant AETH_ADDRESS = 0x3a3A65aAb0dd2A17E3F1947bA16138cd37d08c04;\n\n    function callFunction(\n        address sender,\n        Account.Info memory account,\n        bytes memory data\n    ) public {\n\n        (\n            bytes memory exchangeDataBytes,\n            uint256 gasCost,\n            bool isRepay,\n            uint256 ethAmount,\n            uint256 txValue,\n            address user,\n            address proxy\n        )\n        = abi.decode(data, (bytes,uint256,bool,uint256,uint256,address,address));\n\n        // withdraw eth\n        TokenInterface(WETH_ADDRESS).withdraw(ethAmount);\n\n        address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n        \n        // deposit eth on behalf of proxy\n        DSProxy(payable(proxy)).execute{value: ethAmount}(AAVE_BASIC_PROXY, abi.encodeWithSignature(\"deposit(address,uint256)\", ETH_ADDR, ethAmount));\n        \n        bytes memory functionData = packFunctionCall(exchangeDataBytes, gasCost, isRepay);\n        DSProxy(payable(proxy)).execute{value: txValue}(AAVE_SAVER_PROXY, functionData);\n\n        // withdraw deposited eth\n        DSProxy(payable(proxy)).execute(AAVE_BASIC_PROXY, abi.encodeWithSignature(\"withdraw(address,address,uint256,bool)\", ETH_ADDR, AETH_ADDRESS, ethAmount, false));\n\n        // deposit eth, get weth and return to sender\n        TokenInterface(WETH_ADDRESS).deposit.value(address(this).balance)();\n        ERC20(WETH_ADDRESS).safeTransfer(proxy, ethAmount+2);\n    }\n\n    function packFunctionCall(bytes memory _exchangeDataBytes, uint256 _gasCost, bool _isRepay) internal returns (bytes memory) {\n        ExchangeData memory exData = unpackExchangeData(_exchangeDataBytes);\n\n        bytes memory functionData;\n\n        if (_isRepay) {\n            functionData = abi.encodeWithSignature(\"repay((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256)\", exData, _gasCost);\n        } else {\n            functionData = abi.encodeWithSignature(\"boost((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256)\", exData, _gasCost);\n        }\n\n        return functionData;\n    }\n\n    /// @dev if contract receive eth, convert it to WETH\n    receive() external payable {\n        // deposit eth and get weth \n        if (msg.sender == owner) {\n            TokenInterface(WETH_ADDRESS).deposit.value(address(this).balance)();\n        }\n    }\n}"
408     },
409     "contracts/reflexer/RaiLoanInfo.sol": {
410       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../DS/DSMath.sol\";\nimport \"../interfaces/reflexer/IGetSafes.sol\";\nimport \"../interfaces/reflexer/ISAFEEngine.sol\";\nimport \"../interfaces/reflexer/ISAFEManager.sol\";\nimport \"../interfaces/reflexer/IOracleRelayer.sol\";\nimport \"../interfaces/reflexer/IMedianOracle.sol\";\nimport \"../interfaces/reflexer/ITaxCollector.sol\";\n\ncontract RaiLoanInfo is DSMath {\n    // mainnet\n    address public constant GET_SAFES_ADDR = 0xdf4BC9aA98cC8eCd90Ba2BEe73aD4a1a9C8d202B;\n    address public constant MANAGER_ADDR = 0xEfe0B4cA532769a3AE758fD82E1426a03A94F185;\n    address public constant SAFE_ENGINE_ADDRESS = 0xCC88a9d330da1133Df3A7bD823B95e52511A6962;\n    address public constant ORACLE_RELAYER_ADDRESS = 0x4ed9C0dCa0479bC64d8f4EB3007126D5791f7851;\n    address public constant MEDIAN_ORACLE_ADDRESS = 0x12A5E1c81B10B264A575930aEae80681DDF595fe;\n    address public constant TAX_COLLECTOR_ADDRESS = 0xcDB05aEda142a1B0D6044C09C64e4226c1a281EB;\n\n    // kovan\n    // address public constant GET_SAFES_ADDR = 0x702dcf4a8C3bBBd243477D5704fc45F2762D3826;\n    // address public constant MANAGER_ADDR = 0x807C8eCb73d9c8203d2b1369E678098B9370F2EA;\n    // address public constant SAFE_ENGINE_ADDRESS = 0x7f63fE955fFF8EA474d990f1Fc8979f2C650edbE;\n    // address public constant ORACLE_RELAYER_ADDRESS = 0xE5Ae4E49bEA485B5E5172EE6b1F99243cB15225c;\n    // address public constant MEDIAN_ORACLE_ADDRESS = 0x82bEAd00751EFA3286c9Dd17e4Ea2570916B3944;\n    // address public constant TAX_COLLECTOR_ADDRESS = 0xc1a94C5ad9FCD79b03F79B34d8C0B0C8192fdc16;\n\n    struct SafeInfo {\n        uint256 safeId;\n        uint256 coll;\n        uint256 debt;\n        address safeAddr;\n        bytes32 collType;\n    }\n\n    struct CollInfo {\n        uint256 debtCeiling;\n        uint256 currDebtAmount;\n        uint256 currRate;\n        uint256 dust;\n        uint256 safetyPrice;\n        uint256 liqPrice;\n        uint256 assetPrice;\n        uint256 liqRatio;\n        uint256 stabilityFee;\n    }\n\n    struct RaiInfo {\n        uint256 redemptionPrice;\n        uint256 currRaiPrice;\n        uint256 redemptionRate;\n    }\n\n    function getCollateralTypeInfo(bytes32 _collType)\n        public\n        returns (CollInfo memory collInfo)\n    {\n        (\n            uint256 debtAmount,\n            uint256 accumulatedRates,\n            uint256 safetyPrice,\n            uint256 debtCeiling,\n            uint256 debtFloor,\n            uint256 liquidationPrice\n        ) = ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);\n\n        (, uint liqRatio) = IOracleRelayer(ORACLE_RELAYER_ADDRESS).collateralTypes(_collType);\n\n        (uint stabilityFee,) = ITaxCollector(TAX_COLLECTOR_ADDRESS).collateralTypes(_collType);\n\n\n        collInfo = CollInfo({\n            debtCeiling: debtCeiling,\n            currDebtAmount: debtAmount,\n            currRate: accumulatedRates,\n            dust: debtFloor,\n            safetyPrice: safetyPrice,\n            liqPrice: liquidationPrice,\n            assetPrice: getPrice(_collType),\n            liqRatio: liqRatio,\n            stabilityFee: stabilityFee\n        });\n    }\n\n    function getCollAndRaiInfo(bytes32 _collType)\n        public\n        returns (CollInfo memory collInfo, RaiInfo memory raiInfo) {\n            collInfo = getCollateralTypeInfo(_collType);\n            raiInfo = getRaiInfo();\n        }\n\n    function getPrice(bytes32 _collType) public returns (uint256) {\n        (, uint256 safetyCRatio) =\n            IOracleRelayer(ORACLE_RELAYER_ADDRESS).collateralTypes(_collType);\n        (, , uint256 safetyPrice, , , ) =\n            ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);\n\n        uint256 redemptionPrice = IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionPrice();\n\n        return rmul(rmul(safetyPrice, redemptionPrice), safetyCRatio);\n    }\n\n    function getRaiInfo() public returns (RaiInfo memory raiInfo) {\n        raiInfo = RaiInfo({\n            redemptionPrice: IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionPrice(),\n            currRaiPrice: IMedianOracle(MEDIAN_ORACLE_ADDRESS).read(),\n            redemptionRate: IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionRate()\n        });\n    }\n\n    function getSafeInfo(uint256 _safeId) public view returns (SafeInfo memory safeInfo) {\n        address safeAddr = ISAFEManager(MANAGER_ADDR).safes(_safeId);\n        bytes32 collType = ISAFEManager(MANAGER_ADDR).collateralTypes(_safeId);\n\n        (uint256 coll, uint256 debt) = ISAFEEngine(SAFE_ENGINE_ADDRESS).safes(collType, safeAddr);\n\n        safeInfo = SafeInfo({\n            safeId: _safeId,\n            coll: coll,\n            debt: debt,\n            safeAddr: safeAddr,\n            collType: collType\n        });\n    }\n\n    function getUserSafes(address _user)\n        public\n        view\n        returns (\n            uint256[] memory ids,\n            address[] memory safes,\n            bytes32[] memory collateralTypes\n        )\n    {\n        return IGetSafes(GET_SAFES_ADDR).getSafesAsc(MANAGER_ADDR, _user);\n    }\n\n    function getUserSafesFullInfo(address _user) public view returns (SafeInfo[] memory safeInfos) {\n        (uint256[] memory ids, , ) = getUserSafes(_user);\n\n        safeInfos = new SafeInfo[](ids.length);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            safeInfos[i] = getSafeInfo(ids[i]);\n        }\n    }\n\n    function getFullInfo(address _user, bytes32 _collType)\n        public\n        returns (\n            CollInfo memory collInfo,\n            RaiInfo memory raiInfo,\n            SafeInfo[] memory safeInfos\n        )\n    {\n        collInfo = getCollateralTypeInfo(_collType);\n        raiInfo = getRaiInfo();\n        safeInfos = getUserSafesFullInfo(_user);\n    }\n}\n"
411     },
412     "contracts/interfaces/reflexer/IGetSafes.sol": {
413       "content": "pragma solidity ^0.6.0;\n\nabstract contract IGetSafes {\n    function getSafesAsc(address manager, address guy) external virtual view returns (uint[] memory ids, address[] memory safes, bytes32[] memory collateralTypes);\n    function getSafesDesc(address manager, address guy) external virtual view returns (uint[] memory ids, address[] memory safes, bytes32[] memory collateralTypes);\n\n}\n"
414     },
415     "contracts/interfaces/reflexer/IMedianOracle.sol": {
416       "content": "pragma solidity ^0.6.0;\n\nabstract contract IMedianOracle {\n    function read() external virtual view returns (uint256);\n}\n"
417     },
418     "contracts/DS/DSProxyFactoryInterface.sol": {
419       "content": "pragma solidity ^0.6.0;\n\nimport \"./DSProxy.sol\";\n\nabstract contract DSProxyFactoryInterface {\n    function build(address owner) public virtual returns (DSProxy proxy);\n}\n"
420     },
421     "contracts/aaveV2/saver/optimized/AaveSaverReceiverOV2.sol": {
422       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../../utils/SafeERC20.sol\";\nimport \"../../../interfaces/TokenInterface.sol\";\nimport \"../../../DS/DSProxy.sol\";\nimport \"../../AaveHelperV2.sol\";\nimport \"../../../auth/AdminAuth.sol\";\nimport \"../../../exchangeV3/DFSExchangeCore.sol\";\n\n/// @title Import Aave position from account to wallet\ncontract AaveSaverReceiverOV2 is AaveHelperV2, AdminAuth, DFSExchangeCore {\n\n    using SafeERC20 for ERC20;\n\n    address public constant AAVE_BASIC_PROXY = 0x234e8219f25F6AF4bE90d40C79DEdE31B1f21d4f;\n\n    function boost(ExchangeData memory _exchangeData, address _market, uint256 _gasCost, address _proxy) internal {\n        (, uint swappedAmount) = _sell(_exchangeData);\n\n        address user = DSAuth(_proxy).owner();\n        swappedAmount -= getGasCost(ILendingPoolAddressesProviderV2(_market).getPriceOracle(), swappedAmount, user, _gasCost, _exchangeData.destAddr);\n\n        // if its eth we need to send it to the basic proxy, if not, we need to approve users proxy to pull tokens\n        uint256 msgValue = 0;\n        address token = _exchangeData.destAddr;\n        // sell always return eth, but deposit differentiate eth vs weth, so we change weth address to eth when we are depoisting\n        if (_exchangeData.destAddr == ETH_ADDR || _exchangeData.destAddr == WETH_ADDRESS) {\n            msgValue = swappedAmount;\n            token = ETH_ADDR;\n        } else {\n            ERC20(_exchangeData.destAddr).safeApprove(_proxy, swappedAmount);\n        }\n        // deposit collateral on behalf of user\n        DSProxy(payable(_proxy)).execute{value: msgValue}(\n            AAVE_BASIC_PROXY,\n            abi.encodeWithSignature(\n                \"deposit(address,address,uint256)\",\n                _market,\n                token,\n                swappedAmount\n                )\n            );\n    }\n\n    function repay(ExchangeData memory _exchangeData, address _market, uint256 _gasCost, address _proxy, uint256 _rateMode, uint _aaveFlashlLoanFee) internal {\n        // we will withdraw exactly the srcAmount, as fee we keep before selling\n        uint valueToWithdraw = _exchangeData.srcAmount;\n        // take out the fee wee need to pay and sell the rest\n        _exchangeData.srcAmount = _exchangeData.srcAmount - _aaveFlashlLoanFee;\n\n        (, uint swappedAmount) = _sell(_exchangeData);\n\n        // set protocol fee left to eth balance of this address\n        // but if destAddr is eth or weth, this also includes that value so we need to substract it\n        uint protocolFeeLeft = address(this).balance;\n\n        address user = DSAuth(_proxy).owner();\n        swappedAmount -= getGasCost(ILendingPoolAddressesProviderV2(_market).getPriceOracle(), swappedAmount, user, _gasCost, _exchangeData.destAddr);\n\n        // if its eth we need to send it to the basic proxy, if not, we need to approve basic proxy to pull tokens\n        uint256 msgValue = 0;\n        if (_exchangeData.destAddr == ETH_ADDR || _exchangeData.destAddr == WETH_ADDRESS) {\n            protocolFeeLeft -= swappedAmount;\n            msgValue = swappedAmount;\n        } else {\n            ERC20(_exchangeData.destAddr).safeApprove(_proxy, swappedAmount);\n        }\n\n        // first payback the loan with swapped amount\n        DSProxy(payable(_proxy)).execute{value: msgValue}(\n            AAVE_BASIC_PROXY,\n            abi.encodeWithSignature(\n                \"payback(address,address,uint256,uint256)\",\n                _market,\n                _exchangeData.destAddr,\n                swappedAmount,\n                _rateMode\n                )\n            );\n\n        // if some tokens left after payback (full repay) we need to return it back to the proxy owner\n        require(user != address(0)); // be sure that we fetched the user correctly\n        if (_exchangeData.destAddr == ETH_ADDR || _exchangeData.destAddr == WETH_ADDRESS) {\n            // keep protocol fee for tx.origin, but the rest of the balance return to the user\n            payable(user).transfer(address(this).balance - protocolFeeLeft);\n        } else {\n            // in case its a token, just return whole value back to the user, as protocol fee is always in eth\n            uint amount = ERC20(_exchangeData.destAddr).balanceOf(address(this));\n            ERC20(_exchangeData.destAddr).safeTransfer(user, amount);\n        }\n\n        // pull the amount we flash loaned in collateral to be able to payback the debt\n        DSProxy(payable(_proxy)).execute(AAVE_BASIC_PROXY, abi.encodeWithSignature(\"withdraw(address,address,uint256)\", _market, _exchangeData.srcAddr, valueToWithdraw));\n    }\n\n    function executeOperation(\n        address[] calldata,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) public returns (bool) {\n        (\n            bytes memory exchangeDataBytes,\n            address market,\n            uint256 gasCost,\n            uint256 rateMode,\n            bool isRepay,\n            address proxy\n        )\n        = abi.decode(params, (bytes,address,uint256,uint256,bool,address));\n\n        address lendingPool = ILendingPoolAddressesProviderV2(market).getLendingPool();\n\n        require(msg.sender == lendingPool, \"Callbacks only allowed from Aave\");\n        require(initiator == proxy, \"initiator isn't proxy\");\n\n        ExchangeData memory exData = unpackExchangeData(exchangeDataBytes);\n        exData.user = DSAuth(proxy).owner();\n        exData.dfsFeeDivider = MANUAL_SERVICE_FEE;\n        if (BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin)) {\n            exData.dfsFeeDivider = AUTOMATIC_SERVICE_FEE;\n        }\n\n        // this is to avoid stack too deep\n        uint fee = premiums[0];\n        uint totalValueToReturn = exData.srcAmount + fee;\n\n        // if its repay, we are using regular flash loan and payback the premiums\n        if (isRepay) {\n            repay(exData, market, gasCost, proxy, rateMode, fee);\n\n            address token = exData.srcAddr;\n            if (token == ETH_ADDR || token == WETH_ADDRESS) {\n                // deposit eth, get weth and return to sender\n                TokenInterface(WETH_ADDRESS).deposit.value(totalValueToReturn)();\n                token = WETH_ADDRESS;\n            }\n\n            ERC20(token).safeApprove(lendingPool, totalValueToReturn);\n        } else {\n            boost(exData, market, gasCost, proxy);\n        }\n\n        tx.origin.transfer(address(this).balance);\n\n        return true;\n    }\n\n    /// @dev allow contract to receive eth from sell\n    receive() external override payable {}\n}\n"
423     },
424     "contracts/aaveV2/import/AaveImportV2.sol": {
425       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../savings/dydx/ISoloMargin.sol\";\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\nimport \"../../DS/DSProxy.sol\";\nimport \"../AaveHelperV2.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\n// weth->eth\n// deposit eth for users proxy\n// borrow users token from proxy\n// repay on behalf of user\n// pull user supply\n// take eth amount from supply (if needed more, borrow it?)\n// return eth to sender\n\n/// @title Import Aave position from account to wallet\ncontract AaveImportV2 is AaveHelperV2, AdminAuth {\n\n    using SafeERC20 for ERC20;\n\n    address public constant BASIC_PROXY = 0xc17c8eB12Ba24D62E69fd57cbd504EEf418867f9;\n    address public constant PULL_TOKENS_PROXY = 0x45431b79F783e0BF0fe7eF32D06A3e061780bfc4;\n\n    function callFunction(\n        address,\n        Account.Info memory,\n        bytes memory data\n    ) public {\n\n        (\n            address market,\n            address collateralToken,\n            address borrowToken,\n            uint256 ethAmount,\n            address proxy\n        )\n        = abi.decode(data, (address,address,address,uint256,address));\n\n        address user = DSProxy(payable(proxy)).owner();\n\n        // withdraw eth\n        TokenInterface(WETH_ADDRESS).withdraw(ethAmount);\n\n        IAaveProtocolDataProviderV2 dataProvider = getDataProvider(market);\n\n        uint256 globalBorrowAmountStable = 0;\n        uint256 globalBorrowAmountVariable = 0;\n\n        { // avoid stack too deep\n            // deposit eth on behalf of proxy\n            DSProxy(payable(proxy)).execute{value: ethAmount}(BASIC_PROXY, abi.encodeWithSignature(\"deposit(address,address,uint256)\", market, ETH_ADDR, ethAmount));\n            // borrow needed amount to repay users borrow\n            (, uint256 borrowsStable, uint256 borrowsVariable,,,,,,) = dataProvider.getUserReserveData(borrowToken, user);\n\n            if (borrowsStable > 0) {\n                DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\"borrow(address,address,uint256,uint256)\", market, borrowToken, borrowsStable, STABLE_ID));\n                globalBorrowAmountStable = borrowsStable;\n            }\n\n            if (borrowsVariable > 0) {\n                DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\"borrow(address,address,uint256,uint256)\", market, borrowToken, borrowsVariable, VARIABLE_ID));\n                globalBorrowAmountVariable = borrowsVariable;\n            }\n        }\n\n        if (globalBorrowAmountVariable > 0) {\n            paybackOnBehalf(market, proxy, globalBorrowAmountVariable, borrowToken, user, VARIABLE_ID);\n        }\n\n        if (globalBorrowAmountStable > 0) {\n            paybackOnBehalf(market, proxy, globalBorrowAmountStable, borrowToken, user, STABLE_ID);\n        }\n\n        (address aToken,,) = dataProvider.getReserveTokensAddresses(collateralToken);\n\n        // pull coll tokens\n        DSProxy(payable(proxy)).execute(PULL_TOKENS_PROXY, abi.encodeWithSignature(\"pullTokens(address,uint256)\", aToken, ERC20(aToken).balanceOf(user)));\n\n        // enable as collateral\n        DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\"setUserUseReserveAsCollateralIfNeeded(address,address)\", market, collateralToken));\n\n        // withdraw deposited eth\n        DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\"withdraw(address,address,uint256)\", market, ETH_ADDR, ethAmount));\n\n        // deposit eth, get weth and return to sender\n        TokenInterface(WETH_ADDRESS).deposit{value: (address(this).balance)}();\n        ERC20(WETH_ADDRESS).safeTransfer(proxy, ethAmount+2);\n    }\n\n    function paybackOnBehalf(address _market, address _proxy, uint _amount, address _token, address _onBehalf, uint _rateMode) internal {\n        // payback on behalf of user\n        if (_token != ETH_ADDR) {\n            ERC20(_token).safeApprove(_proxy, _amount);\n            DSProxy(payable(_proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\"paybackOnBehalf(address,address,uint256,uint256,address)\", _market, _token, _amount, _rateMode, _onBehalf));\n        } else {\n            DSProxy(payable(_proxy)).execute{value: _amount}(BASIC_PROXY, abi.encodeWithSignature(\"paybackOnBehalf(address,address,uint256,uint256,address)\", _market, _token, _amount, _rateMode, _onBehalf));\n        }\n    }\n\n    /// @dev if contract receive eth, convert it to WETH\n    receive() external payable {\n        // deposit eth and get weth\n        if (msg.sender == owner) {\n            TokenInterface(WETH_ADDRESS).deposit{value: (address(this).balance)}();\n        }\n    }\n}\n"
426     },
427     "contracts/aave/import/AaveImport.sol": {
428       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../savings/dydx/ISoloMargin.sol\";\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\nimport \"../../DS/DSProxy.sol\";\nimport \"../AaveHelper.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\n// weth->eth\n// deposit eth for users proxy\n// borrow users token from proxy\n// repay on behalf of user\n// pull user supply\n// take eth amount from supply (if needed more, borrow it?)\n// return eth to sender\n\n/// @title Import Aave position from account to wallet\ncontract AaveImport is AaveHelper, AdminAuth {\n\n    using SafeERC20 for ERC20;\n\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant BASIC_PROXY = 0xF499FB2feb3351aEA373723a6A0e8F6BE6fBF616;\n    address public constant AETH_ADDRESS = 0x3a3A65aAb0dd2A17E3F1947bA16138cd37d08c04;\n\n    address public constant PULL_TOKENS_PROXY = 0x45431b79F783e0BF0fe7eF32D06A3e061780bfc4;\n\n    function callFunction(\n        address,\n        Account.Info memory,\n        bytes memory data\n    ) public {\n\n        (\n            address collateralToken,\n            address borrowToken,\n            uint256 ethAmount,\n            address proxy\n        )\n        = abi.decode(data, (address,address,uint256,address));\n\n        address user = DSProxy(payable(proxy)).owner();\n\n        // withdraw eth\n        TokenInterface(WETH_ADDRESS).withdraw(ethAmount);\n\n        address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n        address aCollateralToken = ILendingPool(lendingPoolCoreAddress).getReserveATokenAddress(collateralToken);\n        address aBorrowToken = ILendingPool(lendingPoolCoreAddress).getReserveATokenAddress(borrowToken);\n        uint256 globalBorrowAmount = 0;\n\n        { // avoid stack too deep\n            // deposit eth on behalf of proxy\n            DSProxy(payable(proxy)).execute{value: ethAmount}(BASIC_PROXY, abi.encodeWithSignature(\"deposit(address,uint256)\", ETH_ADDR, ethAmount));\n            // borrow needed amount to repay users borrow\n            (,uint256 borrowAmount,,uint256 borrowRateMode,,,uint256 originationFee,,,) = ILendingPool(lendingPool).getUserReserveData(borrowToken, user);\n            borrowAmount += originationFee;\n            DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\"borrow(address,uint256,uint256)\", borrowToken, borrowAmount, borrowRateMode));\n            globalBorrowAmount = borrowAmount;\n        }\n\n        // payback on behalf of user\n        if (borrowToken != ETH_ADDR) {\n            ERC20(borrowToken).safeApprove(proxy, globalBorrowAmount);\n            DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\"paybackOnBehalf(address,address,uint256,bool,address)\", borrowToken, aBorrowToken, 0, true, user));\n        } else {\n            DSProxy(payable(proxy)).execute{value: globalBorrowAmount}(BASIC_PROXY, abi.encodeWithSignature(\"paybackOnBehalf(address,address,uint256,bool,address)\", borrowToken, aBorrowToken, 0, true, user));\n        }\n\n         // pull coll tokens\n        DSProxy(payable(proxy)).execute(PULL_TOKENS_PROXY, abi.encodeWithSignature(\"pullTokens(address,uint256)\", aCollateralToken, ERC20(aCollateralToken).balanceOf(user)));\n\n\n        // enable as collateral\n        DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\"setUserUseReserveAsCollateralIfNeeded(address)\", collateralToken));\n\n        // withdraw deposited eth\n        DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\"withdraw(address,address,uint256,bool)\", ETH_ADDR, AETH_ADDRESS, ethAmount, false));\n\n\n        // deposit eth, get weth and return to sender\n        TokenInterface(WETH_ADDRESS).deposit{value: (address(this).balance)}();\n        ERC20(WETH_ADDRESS).safeTransfer(proxy, ethAmount+2);\n    }\n\n    /// @dev if contract receive eth, convert it to WETH\n    receive() external payable {\n        // deposit eth and get weth\n        if (msg.sender == owner) {\n            TokenInterface(WETH_ADDRESS).deposit{value: (address(this).balance)}();\n        }\n    }\n}\n"
429     },
430     "contracts/aave/saver/AaveSaverProxy.sol": {
431       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../AaveHelper.sol\";\nimport \"../../exchangeV3/DFSExchangeCore.sol\";\nimport \"../../interfaces/IAToken.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../utils/GasBurner.sol\";\n\ncontract AaveSaverProxy is GasBurner, DFSExchangeCore, AaveHelper {\n\n\taddress public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n\n    uint public constant VARIABLE_RATE = 2;\n\n\tfunction repay(ExchangeData memory _data, uint _gasCost) public payable burnGas(20) {\n\n\t\taddress lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n\t\taddress lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\t\taddress payable user = payable(getUserAddress());\n\n\t\t// redeem collateral\n\t\taddress aTokenCollateral = ILendingPool(lendingPoolCore).getReserveATokenAddress(_data.srcAddr);\n\t\t// uint256 maxCollateral = IAToken(aTokenCollateral).balanceOf(address(this));\n\t\t// don't swap more than maxCollateral\n\t\t// _data.srcAmount = _data.srcAmount > maxCollateral ? maxCollateral : _data.srcAmount;\n\t\tIAToken(aTokenCollateral).redeem(_data.srcAmount);\n\n\t\tuint256 destAmount = _data.srcAmount;\n\t\tif (_data.srcAddr != _data.destAddr) {\n            _data.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\n            _data.user = user;\n\t\t\t// swap\n\t\t\t(, destAmount) = _sell(_data);\n\t\t\tdestAmount -= getGasCost(destAmount, user, _gasCost, _data.destAddr);\n\t\t} else {\n\t\t\tdestAmount -= getGasCost(destAmount, user, _gasCost, _data.destAddr);\n\t\t}\n\n\t\t// payback\n\t\tif (_data.destAddr == ETH_ADDR) {\n\t\t\tILendingPool(lendingPool).repay{value: destAmount}(_data.destAddr, destAmount, payable(address(this)));\n\t\t} else {\n\t\t\tapproveToken(_data.destAddr, lendingPoolCore);\n\t\t\tILendingPool(lendingPool).repay(_data.destAddr, destAmount, payable(address(this)));\n\t\t}\n\n\t\t// first return 0x fee to msg.sender as it is the address that actually sent 0x fee\n\t\tsendContractBalance(ETH_ADDR, tx.origin, min(address(this).balance, msg.value));\n\t\t// send all leftovers from dest addr to proxy owner\n\t\tsendFullContractBalance(_data.destAddr, user);\n\n\t\tDefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"AaveRepay\", abi.encode(_data.srcAddr, _data.destAddr, _data.srcAmount, destAmount));\n\t}\n\n\tfunction boost(ExchangeData memory _data, uint _gasCost) public payable burnGas(20) {\n\t\taddress lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n\t\taddress lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\t\t(,,,uint256 borrowRateMode,,,,,,bool collateralEnabled) = ILendingPool(lendingPool).getUserReserveData(_data.destAddr, address(this));\n\t\taddress payable user = payable(getUserAddress());\n\n\t\t// skipping this check as its too expensive\n\t\t// uint256 maxBorrow = getMaxBoost(_data.srcAddr, _data.destAddr, address(this));\n\t\t// _data.srcAmount = _data.srcAmount > maxBorrow ? maxBorrow : _data.srcAmount;\n\n\t\t// borrow amount\n\t\tILendingPool(lendingPool).borrow(_data.srcAddr, _data.srcAmount, borrowRateMode == 0 ? VARIABLE_RATE : borrowRateMode, AAVE_REFERRAL_CODE);\n\n\t\tuint256 destAmount;\n\t\tif (_data.destAddr != _data.srcAddr) {\n            _data.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\n            _data.user = user;\n\n\t\t\t// swap\n\t\t\t(, destAmount) = _sell(_data);\n            destAmount -= getGasCost(_data.destAmount, user, _gasCost, _data.destAddr);\n\n\t\t} else {\n\t\t\tdestAmount = _data.srcAmount;\n            destAmount -= getGasCost(_data.destAmount, user, _gasCost, _data.destAddr);\n\n\t\t}\n\n\t\tif (_data.destAddr == ETH_ADDR) {\n\t\t\tILendingPool(lendingPool).deposit{value: destAmount}(_data.destAddr, destAmount, AAVE_REFERRAL_CODE);\n\t\t} else {\n\t\t\tapproveToken(_data.destAddr, lendingPoolCore);\n\t\t\tILendingPool(lendingPool).deposit(_data.destAddr, destAmount, AAVE_REFERRAL_CODE);\n\t\t}\n\n\t\tif (!collateralEnabled) {\n            ILendingPool(lendingPool).setUserUseReserveAsCollateral(_data.destAddr, true);\n        }\n\n\t\t// returning to msg.sender as it is the address that actually sent 0x fee\n\t\tsendContractBalance(ETH_ADDR, tx.origin, min(address(this).balance, msg.value));\n\t\t// send all leftovers from dest addr to proxy owner\n\t\tsendFullContractBalance(_data.destAddr, user);\n\n\t\tDefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"AaveBoost\", abi.encode(_data.srcAddr, _data.destAddr, _data.srcAmount, destAmount));\n\t}\n}\n"
432     },
433     "contracts/aaveV2/saver/AaveSaverProxyV2.sol": {
434       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../AaveHelperV2.sol\";\nimport \"../../exchangeV3/DFSExchangeCore.sol\";\nimport \"../../interfaces/IAToken.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../utils/GasBurner.sol\";\n\ncontract AaveSaverProxyV2 is DFSExchangeCore, AaveHelperV2, GasBurner {\n\n\taddress public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n\n\tfunction repay(address _market, ExchangeData memory _data, uint _rateMode, uint _gasCost) public payable burnGas(20) {\n\t\taddress lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\n\t\tIAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\n\t\taddress payable user = payable(getUserAddress());\n\n\t\tILendingPoolV2(lendingPool).withdraw(_data.srcAddr, _data.srcAmount, address(this));\n\n\t\tuint256 destAmount = _data.srcAmount;\n\t\tif (_data.srcAddr != _data.destAddr) {\n\t\t\t_data.user = user;\n\t\t\t\n\t\t\t_data.dfsFeeDivider = MANUAL_SERVICE_FEE;\n\t\t\tif (BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin)) {\n            \t_data.dfsFeeDivider = AUTOMATIC_SERVICE_FEE;\n        \t}\n\t\t\t\n\t\t\t// swap\n\t\t\t(, destAmount) = _sell(_data);\n\t\t}\n\n\t\t// take gas cost at the end\n\t\tdestAmount -= getGasCost(ILendingPoolAddressesProviderV2(_market).getPriceOracle(), destAmount, user, _gasCost, _data.destAddr);\n\n\t\t// payback\n\t\tif (_data.destAddr == WETH_ADDRESS) {\n\t\t\tTokenInterface(WETH_ADDRESS).deposit.value(destAmount)();\n\t\t}\n\n\t\tapproveToken(_data.destAddr, lendingPool);\n\n\t\t// if destAmount higher than borrow repay whole debt\n\t\tuint borrow;\n\t\tif (_rateMode == STABLE_ID) {\n\t\t\t(,borrow,,,,,,,) = dataProvider.getUserReserveData(_data.destAddr, address(this));\t\n\t\t} else {\n\t\t\t(,,borrow,,,,,,) = dataProvider.getUserReserveData(_data.destAddr, address(this));\n\t\t}\n\t\tILendingPoolV2(lendingPool).repay(_data.destAddr, destAmount > borrow ? borrow : destAmount, _rateMode, payable(address(this)));\n\n\t\t// first return 0x fee to tx.origin as it is the address that actually sent 0x fee\n\t\tsendContractBalance(ETH_ADDR, tx.origin, min(address(this).balance, msg.value));\n\t\t// send all leftovers from dest addr to proxy owner\n\t\tsendFullContractBalance(_data.destAddr, user);\n\n\t\tDefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"AaveV2Repay\", abi.encode(_data.srcAddr, _data.destAddr, _data.srcAmount, destAmount));\n\t}\n\n\tfunction boost(address _market, ExchangeData memory _data, uint _rateMode, uint _gasCost) public payable burnGas(20) {\n\t\taddress lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\n\t\tIAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\n\t\taddress payable user = payable(getUserAddress());\n\n\t\t// borrow amount\n\t\tILendingPoolV2(lendingPool).borrow(_data.srcAddr, _data.srcAmount, _rateMode, AAVE_REFERRAL_CODE, address(this));\n\n\t\t// take gas cost at the beginning\n\t\t_data.srcAmount -= getGasCost(ILendingPoolAddressesProviderV2(_market).getPriceOracle(), _data.srcAmount, user, _gasCost, _data.srcAddr);\n\n\t\tuint256 destAmount;\n\t\tif (_data.destAddr != _data.srcAddr) {\n\t\t\t_data.user = user;\n\t\t\t\n\t\t\t_data.dfsFeeDivider = MANUAL_SERVICE_FEE;\n\t\t\tif (BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin)) {\n            \t_data.dfsFeeDivider = AUTOMATIC_SERVICE_FEE;\n        \t}\n        \t\n\t\t\t(, destAmount) = _sell(_data);\n\t\t} else {\n\t\t\tdestAmount = _data.srcAmount;\n\t\t}\n\n\t\tif (_data.destAddr == WETH_ADDRESS) {\n\t\t\tTokenInterface(WETH_ADDRESS).deposit.value(destAmount)();\n\t\t}\n\n\t\tapproveToken(_data.destAddr, lendingPool);\n\t\tILendingPoolV2(lendingPool).deposit(_data.destAddr, destAmount, address(this), AAVE_REFERRAL_CODE);\n\n\n\t\t(,,,,,,,,bool collateralEnabled) = dataProvider.getUserReserveData(_data.destAddr, address(this));\n\t\tif (!collateralEnabled) {\n            ILendingPoolV2(lendingPool).setUserUseReserveAsCollateral(_data.destAddr, true);\n        }\n\n\t\t// returning to msg.sender as it is the address that actually sent 0x fee\n\t\tsendContractBalance(ETH_ADDR, tx.origin, min(address(this).balance, msg.value));\n\t\t// send all leftovers from dest addr to proxy owner\n\t\tsendFullContractBalance(_data.destAddr, user);\n\n\t\tDefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"AaveV2Boost\", abi.encode(_data.srcAddr, _data.destAddr, _data.srcAmount, destAmount));\n\t}\n}\n"
435     },
436     "contracts/aaveV2/AaveBasicProxyV2.sol": {
437       "content": "pragma solidity ^0.6.0;\n\nimport \"../utils/GasBurner.sol\";\nimport \"../interfaces/TokenInterface.sol\";\nimport \"../interfaces/IAToken.sol\";\nimport \"../interfaces/ILendingPoolV2.sol\";\nimport \"./AaveHelperV2.sol\";\n\nimport \"../utils/SafeERC20.sol\";\n\n/// @title Basic compound interactions through the DSProxy\ncontract AaveBasicProxyV2 is GasBurner, AaveHelperV2 {\n\n    using SafeERC20 for ERC20;\n\n    /// @notice User deposits tokens to the Aave protocol\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @param _market address provider for specific market\n    /// @param _tokenAddr The address of the token to be deposited\n    /// @param _amount Amount of tokens to be deposited\n    function deposit(address _market, address _tokenAddr, uint256 _amount) public burnGas(5) payable {\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\n\n        if (_tokenAddr == ETH_ADDR) {\n            require(msg.value == _amount);\n            TokenInterface(WETH_ADDRESS).deposit{value: _amount}();\n            _tokenAddr = WETH_ADDRESS;\n        } else {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\n        }\n\n        approveToken(_tokenAddr, lendingPool);\n        ILendingPoolV2(lendingPool).deposit(_tokenAddr, _amount, address(this), AAVE_REFERRAL_CODE);\n\n        setUserUseReserveAsCollateralIfNeeded(_market, _tokenAddr);\n    }\n\n    /// @notice User withdraws tokens from the Aave protocol\n    /// @param _market address provider for specific market\n    /// @param _tokenAddr The address of the token to be withdrawn\n    /// @param _amount Amount of tokens to be withdrawn -> send -1 for whole amount\n    function withdraw(address _market, address _tokenAddr, uint256 _amount) public burnGas(8) {\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\n        _tokenAddr = changeToWeth(_tokenAddr);\n\n        if (_tokenAddr == WETH_ADDRESS) {\n            // if weth, pull to proxy and return ETH to user\n            ILendingPoolV2(lendingPool).withdraw(_tokenAddr, _amount, address(this));\n            // needs to use balance of in case that amount is -1 for whole debt\n            TokenInterface(WETH_ADDRESS).withdraw(TokenInterface(WETH_ADDRESS).balanceOf(address(this)));\n            msg.sender.transfer(address(this).balance);\n        } else {\n            // if not eth send directly to user\n            ILendingPoolV2(lendingPool).withdraw(_tokenAddr, _amount, msg.sender);\n        }\n    }\n\n    /// @notice User borrows tokens to the Aave protocol\n    /// @param _market address provider for specific market\n    /// @param _tokenAddr The address of the token to be borrowed\n    /// @param _amount Amount of tokens to be borrowed\n    /// @param _type Send 1 for stable rate and 2 for variable\n    function borrow(address _market, address _tokenAddr, uint256 _amount, uint256 _type) public burnGas(8) {\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\n        _tokenAddr = changeToWeth(_tokenAddr);\n\n        ILendingPoolV2(lendingPool).borrow(_tokenAddr, _amount, _type, AAVE_REFERRAL_CODE, address(this));\n\n        if (_tokenAddr == WETH_ADDRESS) {\n            // we do this so the user gets eth instead of weth\n            TokenInterface(WETH_ADDRESS).withdraw(_amount);\n            _tokenAddr = ETH_ADDR;\n        }\n\n        withdrawTokens(_tokenAddr);\n    }\n\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @notice User paybacks tokens to the Aave protocol\n    /// @param _market address provider for specific market\n    /// @param _tokenAddr The address of the token to be paybacked\n    /// @param _amount Amount of tokens to be payed back\n    function payback(address _market, address _tokenAddr, uint256 _amount, uint256 _rateMode) public burnGas(3) payable {\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\n        _tokenAddr = changeToWeth(_tokenAddr);\n\n        if (_tokenAddr == WETH_ADDRESS) {\n            TokenInterface(WETH_ADDRESS).deposit{value: msg.value}();\n        } else {\n            uint amountToPull = min(_amount, ERC20(_tokenAddr).balanceOf(msg.sender));\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), amountToPull);\n        }\n\n        approveToken(_tokenAddr, lendingPool);\n        ILendingPoolV2(lendingPool).repay(_tokenAddr, _amount, _rateMode, payable(address(this)));\n\n        if (_tokenAddr == WETH_ADDRESS) {\n            // Pull if we have any eth leftover\n            TokenInterface(WETH_ADDRESS).withdraw(ERC20(WETH_ADDRESS).balanceOf(address(this)));\n            _tokenAddr = ETH_ADDR;\n        }\n\n        withdrawTokens(_tokenAddr);\n    }\n\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @notice User paybacks tokens to the Aave protocol\n    /// @param _market address provider for specific market\n    /// @param _tokenAddr The address of the token to be paybacked\n    /// @param _amount Amount of tokens to be payed back\n    function paybackOnBehalf(address _market, address _tokenAddr, uint256 _amount, uint256 _rateMode, address _onBehalf) public burnGas(3) payable {\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\n        _tokenAddr = changeToWeth(_tokenAddr);\n\n        if (_tokenAddr == WETH_ADDRESS) {\n            TokenInterface(WETH_ADDRESS).deposit{value: msg.value}();\n        } else {\n            uint amountToPull = min(_amount, ERC20(_tokenAddr).allowance(msg.sender, address(this)));\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), amountToPull);\n        }\n\n        approveToken(_tokenAddr, lendingPool);\n        ILendingPoolV2(lendingPool).repay(_tokenAddr, _amount, _rateMode, _onBehalf);\n\n        if (_tokenAddr == WETH_ADDRESS) {\n            // we do this so the user gets eth instead of weth\n            TokenInterface(WETH_ADDRESS).withdraw(_amount);\n            _tokenAddr = ETH_ADDR;\n        }\n\n        withdrawTokens(_tokenAddr);\n    }\n\n\n    /// @notice Helper method to withdraw tokens from the DSProxy\n    /// @param _tokenAddr Address of the token to be withdrawn\n    function withdrawTokens(address _tokenAddr) public {\n        uint256 amount = _tokenAddr == ETH_ADDR ? address(this).balance : ERC20(_tokenAddr).balanceOf(address(this));\n\n        if (amount > 0) {\n            if (_tokenAddr != ETH_ADDR) {\n                ERC20(_tokenAddr).safeTransfer(msg.sender, amount);\n            } else {\n                msg.sender.transfer(amount);\n            }\n        }\n    }\n\n    function setUserUseReserveAsCollateralIfNeeded(address _market, address _tokenAddr) public {\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\n        IAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\n\n        (,,,,,,,,bool collateralEnabled) = dataProvider.getUserReserveData(_tokenAddr, address(this));\n\n        if (!collateralEnabled) {\n            ILendingPoolV2(lendingPool).setUserUseReserveAsCollateral(_tokenAddr, true);\n        }\n    }\n\n    function setUserUseReserveAsCollateral(address _market, address _tokenAddr, bool _true) public {\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\n\n        ILendingPoolV2(lendingPool).setUserUseReserveAsCollateral(_tokenAddr, _true);\n    }\n\n    // stable = 1, variable = 2\n    function swapBorrowRateMode(address _market, address _reserve, uint _rateMode) public {\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\n\n        ILendingPoolV2(lendingPool).swapBorrowRateMode(_reserve, _rateMode);\n    }\n\n    function changeToWeth(address _token) private view returns(address) {\n        if (_token == ETH_ADDR) {\n            return WETH_ADDRESS;\n        }\n\n        return _token;\n    }\n\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external virtual payable {}\n}\n"
438     },
439     "contracts/aaveV2/AaveSafetyRatioV2.sol": {
440       "content": "pragma solidity ^0.6.0;\n\nimport \"./AaveHelperV2.sol\";\nimport \"../interfaces/ILendingPoolV2.sol\";\n\ncontract AaveSafetyRatioV2 is AaveHelperV2 {\n\n    function getSafetyRatio(address _market, address _user) public view returns(uint256) {\n        ILendingPoolV2 lendingPool = ILendingPoolV2(ILendingPoolAddressesProviderV2(_market).getLendingPool());\n        \n        (,uint256 totalDebtETH,uint256 availableBorrowsETH,,,) = lendingPool.getUserAccountData(_user);\n\n        if (totalDebtETH == 0) return uint256(0);\n\n        return wdiv(add(totalDebtETH, availableBorrowsETH), totalDebtETH);\n    }\n}"
441     },
442     "contracts/aaveV2/automatic/AaveMonitorV2.sol": {
443       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/GasBurner.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../exchangeV3/DFSExchangeData.sol\";\nimport \"./AaveMonitorProxyV2.sol\";\nimport \"./AaveSubscriptionsV2.sol\";\nimport \"../AaveSafetyRatioV2.sol\";\n\n/// @title Contract implements logic of calling boost/repay in the automatic system\ncontract AaveMonitorV2 is AdminAuth, DSMath, AaveSafetyRatioV2, GasBurner {\n\n    using SafeERC20 for ERC20;\n\n    string public constant NAME = \"AaveMonitorV2\";\n\n    enum Method { Boost, Repay }\n\n    uint public REPAY_GAS_TOKEN = 20;\n    uint public BOOST_GAS_TOKEN = 20;\n\n    uint public MAX_GAS_PRICE = 400000000000; // 400 gwei\n\n    uint public REPAY_GAS_COST = 2000000;\n    uint public BOOST_GAS_COST = 2000000;\n\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n    address public constant AAVE_MARKET_ADDRESS = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;\n\n    AaveMonitorProxyV2 public aaveMonitorProxy;\n    AaveSubscriptionsV2 public subscriptionsContract;\n    address public aaveSaverProxy;\n\n    DefisaverLogger public logger = DefisaverLogger(DEFISAVER_LOGGER);\n\n    modifier onlyApproved() {\n        require(BotRegistry(BOT_REGISTRY_ADDRESS).botList(msg.sender), \"Not auth bot\");\n        _;\n    }\n\n    /// @param _aaveMonitorProxy Proxy contracts that actually is authorized to call DSProxy\n    /// @param _subscriptions Subscriptions contract for Aave positions\n    /// @param _aaveSaverProxy Contract that actually performs Repay/Boost\n    constructor(address _aaveMonitorProxy, address _subscriptions, address _aaveSaverProxy) public {\n        aaveMonitorProxy = AaveMonitorProxyV2(_aaveMonitorProxy);\n        subscriptionsContract = AaveSubscriptionsV2(_subscriptions);\n        aaveSaverProxy = _aaveSaverProxy;\n    }\n\n    /// @notice Bots call this method to repay for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _exData Exchange data\n    /// @param _user The actual address that owns the Aave position\n    function repayFor(\n        DFSExchangeData.ExchangeData memory _exData,\n        address _user,\n        uint256 _rateMode,\n        uint256 _flAmount\n    ) public payable onlyApproved burnGas(REPAY_GAS_TOKEN) {\n\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Repay, _user);\n        require(isAllowed); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(REPAY_GAS_COST);\n\n        aaveMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            aaveSaverProxy,\n            abi.encodeWithSignature(\n                \"repay(address,(address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256,uint256,uint256)\",\n                AAVE_MARKET_ADDRESS,\n                _exData,\n                _rateMode,\n                gasCost,\n                _flAmount\n            )\n        );\n\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Repay, _user);\n        require(isGoodRatio); // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(address(this), _user, \"AutomaticAaveRepayV2\", abi.encode(ratioBefore, ratioAfter));\n    }\n\n    /// @notice Bots call this method to boost for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _exData Exchange data\n    /// @param _user The actual address that owns the Aave position\n    function boostFor(\n        DFSExchangeData.ExchangeData memory _exData,\n        address _user,\n        uint256 _rateMode,\n        uint256 _flAmount\n    ) public payable onlyApproved burnGas(BOOST_GAS_TOKEN) {\n\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Boost, _user);\n        require(isAllowed); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(BOOST_GAS_COST);\n\n        aaveMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            aaveSaverProxy,\n            abi.encodeWithSignature(\n                \"boost(address,(address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256,uint256,uint256)\",\n                AAVE_MARKET_ADDRESS,\n                _exData,\n                _rateMode,\n                gasCost,\n                _flAmount\n            )\n        );\n\n\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Boost, _user);\n        require(isGoodRatio);  // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(address(this), _user, \"AutomaticAaveBoostV2\", abi.encode(ratioBefore, ratioAfter));\n    }\n\n/******************* INTERNAL METHODS ********************************/\n    function returnEth() internal {\n        // return if some eth left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n/******************* STATIC METHODS ********************************/\n\n    /// @notice Checks if Boost/Repay could be triggered for the CDP\n    /// @dev Called by AaveMonitor to enforce the min/max check\n    /// @param _method Type of action to be called\n    /// @param _user The actual address that owns the Aave position\n    /// @return Boolean if it can be called and the ratio\n    function canCall(Method _method, address _user) public view returns(bool, uint) {\n        bool subscribed = subscriptionsContract.isSubscribed(_user);\n        AaveSubscriptionsV2.AaveHolder memory holder = subscriptionsContract.getHolder(_user);\n\n        // check if cdp is subscribed\n        if (!subscribed) return (false, 0);\n\n        // check if boost and boost allowed\n        if (_method == Method.Boost && !holder.boostEnabled) return (false, 0);\n\n        uint currRatio = getSafetyRatio(AAVE_MARKET_ADDRESS, _user);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.minRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.maxRatio, currRatio);\n        }\n    }\n\n    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call\n    /// @param _method Type of action to be called\n    /// @param _user The actual address that owns the Aave position\n    /// @return Boolean if the recent action preformed correctly and the ratio\n    function ratioGoodAfter(Method _method, address _user) public view returns(bool, uint) {\n        AaveSubscriptionsV2.AaveHolder memory holder;\n\n        holder = subscriptionsContract.getHolder(_user);\n\n        uint currRatio = getSafetyRatio(AAVE_MARKET_ADDRESS, _user);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.maxRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.minRatio, currRatio);\n        }\n    }\n\n    /// @notice Calculates gas cost (in Eth) of tx\n    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP\n    /// @param _gasAmount Amount of gas used for the tx\n    function calcGasCost(uint _gasAmount) public view returns (uint) {\n        uint gasPrice = tx.gasprice <= MAX_GAS_PRICE ? tx.gasprice : MAX_GAS_PRICE;\n\n        return mul(gasPrice, _gasAmount);\n    }\n\n/******************* OWNER ONLY OPERATIONS ********************************/\n\n    /// @notice As the code is new, have a emergancy admin saver proxy change\n    function changeAaveSaverProxy(address _newAaveSaverProxy) public onlyAdmin {\n        aaveSaverProxy = _newAaveSaverProxy;\n    }\n\n    /// @notice Allows owner to change gas cost for boost operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for boost method\n    function changeBoostGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        BOOST_GAS_COST = _gasCost;\n    }\n\n    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for repay method\n    function changeRepayGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        REPAY_GAS_COST = _gasCost;\n    }\n\n    /// @notice Allows owner to change max gas price\n    /// @param _maxGasPrice New max gas price\n    function changeMaxGasPrice(uint _maxGasPrice) public onlyOwner {\n        require(_maxGasPrice < 500000000000);\n\n        MAX_GAS_PRICE = _maxGasPrice;\n    }\n\n    /// @notice Allows owner to change gas token amount\n    /// @param _gasTokenAmount New gas token amount\n    /// @param _repay true if repay gas token, false if boost gas token\n    function changeGasTokenAmount(uint _gasTokenAmount, bool _repay) public onlyOwner {\n        if (_repay) {\n            REPAY_GAS_TOKEN = _gasTokenAmount;\n        } else {\n            BOOST_GAS_TOKEN = _gasTokenAmount;\n        }\n    }\n}\n"
444     },
445     "contracts/aaveV2/automatic/AaveMonitorProxyV2.sol": {
446       "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/DSProxyInterface.sol\";\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\n/// @title Contract with the actuall DSProxy permission calls the automation operations\ncontract AaveMonitorProxyV2 is AdminAuth {\n\n    using SafeERC20 for ERC20;\n\n    string public constant NAME = \"AaveMonitorProxyV2\";\n\n    uint public CHANGE_PERIOD;\n    address public monitor;\n    address public newMonitor;\n    address public lastMonitor;\n    uint public changeRequestedTimestamp;\n\n    event MonitorChangeInitiated(address oldMonitor, address newMonitor);\n    event MonitorChangeCanceled();\n    event MonitorChangeFinished(address monitor);\n    event MonitorChangeReverted(address monitor);\n\n\n    modifier onlyMonitor() {\n        require (msg.sender == monitor);\n        _;\n    }\n\n    constructor(uint _changePeriod) public {\n        CHANGE_PERIOD = _changePeriod * 1 hours;\n    }\n\n    /// @notice Only monitor contract is able to call execute on users proxy\n    /// @param _owner Address of cdp owner (users DSProxy address)\n    /// @param _aaveSaverProxy Address of AaveSaverProxy\n    /// @param _data Data to send to AaveSaverProxy\n    function callExecute(address _owner, address _aaveSaverProxy, bytes memory _data) public payable onlyMonitor {\n        // execute reverts if calling specific method fails\n        DSProxyInterface(_owner).execute{value: msg.value}(_aaveSaverProxy, _data);\n\n        // return if anything left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Owner is able to set Monitor contract without any waiting period first time\n    /// @param _monitor Address of Monitor contract\n    function setMonitor(address _monitor) public onlyOwner {\n        require(monitor == address(0));\n        monitor = _monitor;\n    }\n\n    /// @notice Owner is able to start procedure for changing monitor\n    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change\n    /// @param _newMonitor address of new monitor\n    function changeMonitor(address _newMonitor) public onlyOwner {\n        require(changeRequestedTimestamp == 0);\n\n        changeRequestedTimestamp = now;\n        lastMonitor = monitor;\n        newMonitor = _newMonitor;\n\n        emit MonitorChangeInitiated(lastMonitor, newMonitor);\n    }\n\n    /// @notice At any point owner is able to cancel monitor change\n    function cancelMonitorChange() public onlyOwner {\n        require(changeRequestedTimestamp > 0);\n\n        changeRequestedTimestamp = 0;\n        newMonitor = address(0);\n\n        emit MonitorChangeCanceled();\n    }\n\n    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started\n    function confirmNewMonitor() public onlyOwner {\n        require((changeRequestedTimestamp + CHANGE_PERIOD) < now);\n        require(changeRequestedTimestamp != 0);\n        require(newMonitor != address(0));\n\n        monitor = newMonitor;\n        newMonitor = address(0);\n        changeRequestedTimestamp = 0;\n\n        emit MonitorChangeFinished(monitor);\n    }\n\n    /// @notice Its possible to revert monitor to last used monitor\n    function revertMonitor() public onlyOwner {\n        require(lastMonitor != address(0));\n\n        monitor = lastMonitor;\n\n        emit MonitorChangeReverted(monitor);\n    }\n\n    function setChangePeriod(uint _periodInHours) public onlyOwner {\n        require(_periodInHours * 1 hours > CHANGE_PERIOD);\n\n        CHANGE_PERIOD = _periodInHours * 1 hours;\n    }\n}\n"
447     },
448     "contracts/aaveV2/automatic/AaveSubscriptionsV2.sol": {
449       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../auth/AdminAuth.sol\";\n\n/// @title Stores subscription information for Aave automatization\ncontract AaveSubscriptionsV2 is AdminAuth {\n\n    string public constant NAME = \"AaveSubscriptionsV2\";\n\n    struct AaveHolder {\n        address user;\n        uint128 minRatio;\n        uint128 maxRatio;\n        uint128 optimalRatioBoost;\n        uint128 optimalRatioRepay;\n        bool boostEnabled;\n    }\n\n    struct SubPosition {\n        uint arrPos;\n        bool subscribed;\n    }\n\n    AaveHolder[] public subscribers;\n    mapping (address => SubPosition) public subscribersPos;\n\n    uint public changeIndex;\n\n    event Subscribed(address indexed user);\n    event Unsubscribed(address indexed user);\n    event Updated(address indexed user);\n    event ParamUpdates(address indexed user, uint128, uint128, uint128, uint128, bool);\n\n    /// @dev Called by the DSProxy contract which owns the Aave position\n    /// @notice Adds the users Aave poistion in the list of subscriptions so it can be monitored\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalBoost Ratio amount which boost should target\n    /// @param _optimalRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    function subscribe(uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled) external {\n\n        // if boost is not enabled, set max ratio to max uint\n        uint128 localMaxRatio = _boostEnabled ? _maxRatio : uint128(-1);\n        require(checkParams(_minRatio, localMaxRatio), \"Must be correct params\");\n\n        SubPosition storage subInfo = subscribersPos[msg.sender];\n\n        AaveHolder memory subscription = AaveHolder({\n                minRatio: _minRatio,\n                maxRatio: localMaxRatio,\n                optimalRatioBoost: _optimalBoost,\n                optimalRatioRepay: _optimalRepay,\n                user: msg.sender,\n                boostEnabled: _boostEnabled\n            });\n\n        changeIndex++;\n\n        if (subInfo.subscribed) {\n            subscribers[subInfo.arrPos] = subscription;\n\n            emit Updated(msg.sender);\n            emit ParamUpdates(msg.sender, _minRatio, localMaxRatio, _optimalBoost, _optimalRepay, _boostEnabled);\n        } else {\n            subscribers.push(subscription);\n\n            subInfo.arrPos = subscribers.length - 1;\n            subInfo.subscribed = true;\n\n            emit Subscribed(msg.sender);\n        }\n    }\n\n    /// @notice Called by the users DSProxy\n    /// @dev Owner who subscribed cancels his subscription\n    function unsubscribe() external {\n        _unsubscribe(msg.sender);\n    }\n\n    /// @dev Checks limit if minRatio is bigger than max\n    /// @param _minRatio Minimum ratio, bellow which repay can be triggered\n    /// @param _maxRatio Maximum ratio, over which boost can be triggered\n    /// @return Returns bool if the params are correct\n    function checkParams(uint128 _minRatio, uint128 _maxRatio) internal pure returns (bool) {\n\n        if (_minRatio > _maxRatio) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @dev Internal method to remove a subscriber from the list\n    /// @param _user The actual address that owns the Aave position\n    function _unsubscribe(address _user) internal {\n        require(subscribers.length > 0, \"Must have subscribers in the list\");\n\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        require(subInfo.subscribed, \"Must first be subscribed\");\n\n        address lastOwner = subscribers[subscribers.length - 1].user;\n\n        SubPosition storage subInfo2 = subscribersPos[lastOwner];\n        subInfo2.arrPos = subInfo.arrPos;\n\n        subscribers[subInfo.arrPos] = subscribers[subscribers.length - 1];\n        subscribers.pop(); // remove last element and reduce arr length\n\n        changeIndex++;\n        subInfo.subscribed = false;\n        subInfo.arrPos = 0;\n\n        emit Unsubscribed(msg.sender);\n    }\n\n    /// @dev Checks if the user is subscribed\n    /// @param _user The actual address that owns the Aave position\n    /// @return If the user is subscribed\n    function isSubscribed(address _user) public view returns (bool) {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        return subInfo.subscribed;\n    }\n\n    /// @dev Returns subscribtion information about a user\n    /// @param _user The actual address that owns the Aave position\n    /// @return Subscription information about the user if exists\n    function getHolder(address _user) public view returns (AaveHolder memory) {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        return subscribers[subInfo.arrPos];\n    }\n\n    /// @notice Helper method to return all the subscribed CDPs\n    /// @return List of all subscribers\n    function getSubscribers() public view returns (AaveHolder[] memory) {\n        return subscribers;\n    }\n\n    /// @notice Helper method for the frontend, returns all the subscribed CDPs paginated\n    /// @param _page What page of subscribers you want\n    /// @param _perPage Number of entries per page\n    /// @return List of all subscribers for that page\n    function getSubscribersByPage(uint _page, uint _perPage) public view returns (AaveHolder[] memory) {\n        AaveHolder[] memory holders = new AaveHolder[](_perPage);\n\n        uint start = _page * _perPage;\n        uint end = start + _perPage;\n\n        end = (end > holders.length) ? holders.length : end;\n\n        uint count = 0;\n        for (uint i = start; i < end; i++) {\n            holders[count] = subscribers[i];\n            count++;\n        }\n\n        return holders;\n    }\n\n    ////////////// ADMIN METHODS ///////////////////\n\n    /// @notice Admin function to unsubscribe a position\n    /// @param _user The actual address that owns the Aave position\n    function unsubscribeByAdmin(address _user) public onlyOwner {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        if (subInfo.subscribed) {\n            _unsubscribe(_user);\n        }\n    }\n}\n"
450     },
451     "contracts/aaveV2/AaveLoanInfoV2.sol": {
452       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./AaveSafetyRatioV2.sol\";\nimport \"../interfaces/IAaveProtocolDataProviderV2.sol\";\n\ncontract AaveLoanInfoV2 is AaveSafetyRatioV2 {\n\n    struct LoanData {\n        address user;\n        uint128 ratio;\n        address[] collAddr;\n        address[] borrowAddr;\n        uint256[] collAmounts;\n        uint256[] borrowStableAmounts;\n        uint256[] borrowVariableAmounts;\n    }\n\n    struct TokenInfo {\n        address aTokenAddress;\n        address underlyingTokenAddress;\n        uint256 collateralFactor;\n        uint256 price;\n    }\n\n    struct TokenInfoFull {\n        address aTokenAddress;\n        address underlyingTokenAddress;\n        uint256 supplyRate;\n        uint256 borrowRateVariable;\n        uint256 borrowRateStable;\n        uint256 totalSupply;\n        uint256 availableLiquidity;\n        uint256 totalBorrow;\n        uint256 collateralFactor;\n        uint256 liquidationRatio;\n        uint256 price;\n        bool usageAsCollateralEnabled;\n        bool borrowinEnabled;\n        bool stableBorrowRateEnabled;\n    }\n\n    struct ReserveData {\n        uint256 availableLiquidity;\n        uint256 totalStableDebt;\n        uint256 totalVariableDebt;\n        uint256 liquidityRate;\n        uint256 variableBorrowRate;\n        uint256 stableBorrowRate;\n    }\n\n    struct UserToken {\n        address token;\n        uint256 balance;\n        uint256 borrowsStable;\n        uint256 borrowsVariable;\n        uint256 stableBorrowRate;\n        bool enabledAsCollateral;\n    }\n\n    /// @notice Calcualted the ratio of coll/debt for a compound user\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\n    /// @param _user Address of the user\n    function getRatio(address _market, address _user) public view returns (uint256) {\n        // For each asset the account is in\n        return getSafetyRatio(_market, _user);\n    }\n\n    /// @notice Fetches Aave prices for tokens\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\n    /// @param _tokens Arr. of tokens for which to get the prices\n    /// @return prices Array of prices\n    function getPrices(address _market, address[] memory _tokens) public view returns (uint256[] memory prices) {\n        address priceOracleAddress = ILendingPoolAddressesProviderV2(_market).getPriceOracle();\n        prices = IPriceOracleGetterAave(priceOracleAddress).getAssetsPrices(_tokens);\n    }\n\n    /// @notice Fetches Aave collateral factors for tokens\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\n    /// @param _tokens Arr. of tokens for which to get the coll. factors\n    /// @return collFactors Array of coll. factors\n    function getCollFactors(address _market, address[] memory _tokens) public view returns (uint256[] memory collFactors) {\n        IAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\n        collFactors = new uint256[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            (,collFactors[i],,,,,,,,) = dataProvider.getReserveConfigurationData(_tokens[i]);\n        }\n    }\n\n    function getTokenBalances(address _market, address _user, address[] memory _tokens) public view returns (UserToken[] memory userTokens) {\n        IAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\n\n        userTokens = new UserToken[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address asset = _tokens[i];\n            userTokens[i].token = asset;\n\n            (userTokens[i].balance, userTokens[i].borrowsStable, userTokens[i].borrowsVariable,,,userTokens[i].stableBorrowRate,,,userTokens[i].enabledAsCollateral) = dataProvider.getUserReserveData(asset, _user);\n        }\n    }\n\n    /// @notice Calcualted the ratio of coll/debt for an aave user\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\n    /// @param _users Addresses of the user\n    /// @return ratios Array of ratios\n    function getRatios(address _market, address[] memory _users) public view returns (uint256[] memory ratios) {\n        ratios = new uint256[](_users.length);\n\n        for (uint256 i = 0; i < _users.length; ++i) {\n            ratios[i] = getSafetyRatio(_market, _users[i]);\n        }\n    }\n\n    /// @notice Information about reserves\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\n    /// @param _tokenAddresses Array of tokens addresses\n    /// @return tokens Array of reserves infomartion\n    function getTokensInfo(address _market, address[] memory _tokenAddresses) public view returns(TokenInfo[] memory tokens) {\n        IAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\n        address priceOracleAddress = ILendingPoolAddressesProviderV2(_market).getPriceOracle();\n\n        tokens = new TokenInfo[](_tokenAddresses.length);\n\n        for (uint256 i = 0; i < _tokenAddresses.length; ++i) {\n            (,uint256 ltv,,,,,,,,) = dataProvider.getReserveConfigurationData(_tokenAddresses[i]);\n            (address aToken,,) = dataProvider.getReserveTokensAddresses(_tokenAddresses[i]);\n\n            tokens[i] = TokenInfo({\n                aTokenAddress: aToken,\n                underlyingTokenAddress: _tokenAddresses[i],\n                collateralFactor: ltv,\n                price: IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokenAddresses[i])\n            });\n        }\n    }\n\n    function getTokenInfoFull(IAaveProtocolDataProviderV2 _dataProvider, address _priceOracleAddress, address _token) private view returns(TokenInfoFull memory _tokenInfo) {\n        (\n            , // uint256 decimals\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            , //   uint256 liquidationBonus\n            , //   uint256 reserveFactor\n            bool usageAsCollateralEnabled,\n            bool borrowinEnabled,\n            bool stableBorrowRateEnabled,\n            , //   bool isActive\n            //   bool isFrozen\n        ) = _dataProvider.getReserveConfigurationData(_token);\n\n        ReserveData memory t;\n\n        (\n            t.availableLiquidity,\n            t.totalStableDebt,\n            t.totalVariableDebt,\n            t.liquidityRate,\n            t.variableBorrowRate,\n            t.stableBorrowRate,\n            ,\n            ,\n            ,\n\n        ) = _dataProvider.getReserveData(_token);\n\n        (address aToken,,) = _dataProvider.getReserveTokensAddresses(_token);\n\n        uint price = IPriceOracleGetterAave(_priceOracleAddress).getAssetPrice(_token);\n\n        _tokenInfo = TokenInfoFull({\n            aTokenAddress: aToken,\n            underlyingTokenAddress: _token,\n            supplyRate: t.liquidityRate,\n            borrowRateVariable: t.variableBorrowRate,\n            borrowRateStable: t.stableBorrowRate,\n            totalSupply: ERC20(aToken).totalSupply(),\n            availableLiquidity: t.availableLiquidity,\n            totalBorrow: t.totalVariableDebt+t.totalStableDebt,\n            collateralFactor: ltv,\n            liquidationRatio: liquidationThreshold,\n            price: price,\n            usageAsCollateralEnabled: usageAsCollateralEnabled,\n            borrowinEnabled: borrowinEnabled,\n            stableBorrowRateEnabled: stableBorrowRateEnabled\n        });\n    }\n\n    /// @notice Information about reserves\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\n    /// @param _tokenAddresses Array of token addresses\n    /// @return tokens Array of reserves infomartion\n    function getFullTokensInfo(address _market, address[] memory _tokenAddresses) public view returns(TokenInfoFull[] memory tokens) {\n        IAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\n        address priceOracleAddress = ILendingPoolAddressesProviderV2(_market).getPriceOracle();\n\n        tokens = new TokenInfoFull[](_tokenAddresses.length);\n\n        for (uint256 i = 0; i < _tokenAddresses.length; ++i) {\n            tokens[i] = getTokenInfoFull(dataProvider, priceOracleAddress, _tokenAddresses[i]);\n        }\n    }\n\n\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\n    /// @param _user Address of the user\n    /// @return data LoanData information\n    function getLoanData(address _market, address _user) public view returns (LoanData memory data) {\n        IAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\n        address priceOracleAddress = ILendingPoolAddressesProviderV2(_market).getPriceOracle();\n\n        IAaveProtocolDataProviderV2.TokenData[] memory reserves = dataProvider.getAllReservesTokens();\n\n        data = LoanData({\n            user: _user,\n            ratio: 0,\n            collAddr: new address[](reserves.length),\n            borrowAddr: new address[](reserves.length),\n            collAmounts: new uint[](reserves.length),\n            borrowStableAmounts: new uint[](reserves.length),\n            borrowVariableAmounts: new uint[](reserves.length)\n        });\n\n        uint64 collPos = 0;\n        uint64 borrowPos = 0;\n        \n        for (uint64 i = 0; i < reserves.length; i++) {\n            address reserve = reserves[i].tokenAddress;\n\n            (uint256 aTokenBalance, uint256 borrowsStable, uint256 borrowsVariable,,,,,,) = dataProvider.getUserReserveData(reserve, _user);\n            uint256 price = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(reserve);\n\n            if (aTokenBalance > 0) {\n                uint256 userTokenBalanceEth = wmul(aTokenBalance, price) * (10 ** (18 - _getDecimals(reserve)));\n                data.collAddr[collPos] = reserve;\n                data.collAmounts[collPos] = userTokenBalanceEth;\n                collPos++;\n            }\n\n            // Sum up debt in Eth\n            if (borrowsStable > 0) {\n                uint256 userBorrowBalanceEth = wmul(borrowsStable, price) * (10 ** (18 - _getDecimals(reserve)));\n                data.borrowAddr[borrowPos] = reserve;\n                data.borrowStableAmounts[borrowPos] = userBorrowBalanceEth;\n            }\n\n            // Sum up debt in Eth\n            if (borrowsVariable > 0) {\n                uint256 userBorrowBalanceEth = wmul(borrowsVariable, price) * (10 ** (18 - _getDecimals(reserve)));\n                data.borrowAddr[borrowPos] = reserve;\n                data.borrowVariableAmounts[borrowPos] = userBorrowBalanceEth;\n            }\n\n            if (borrowsStable > 0 || borrowsVariable > 0) {\n                borrowPos++;\n            }\n        }\n\n        data.ratio = uint128(getSafetyRatio(_market, _user));\n\n        return data;\n    }\n\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\n    /// @param _users Addresses of the user\n    /// @return loans Array of LoanData information\n    function getLoanDataArr(address _market, address[] memory _users) public view returns (LoanData[] memory loans) {\n        loans = new LoanData[](_users.length);\n\n        for (uint i = 0; i < _users.length; ++i) {\n            loans[i] = getLoanData(_market, _users[i]);\n        }\n    }\n}\n"
453     },
454     "contracts/aave/AaveSafetyRatio.sol": {
455       "content": "pragma solidity ^0.6.0;\n\nimport \"./AaveHelper.sol\";\n\ncontract AaveSafetyRatio is AaveHelper {\n\n    function getSafetyRatio(address _user) public view returns(uint256) {\n        address lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n        (,,uint256 totalBorrowsETH,,uint256 availableBorrowsETH,,,) = ILendingPool(lendingPoolAddress).getUserAccountData(_user);\n\n        if (totalBorrowsETH == 0) return uint256(0);\n\n        return wdiv(add(totalBorrowsETH, availableBorrowsETH), totalBorrowsETH);\n    }\n}"
456     },
457     "contracts/aave/automatic/AaveMonitor.sol": {
458       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/GasBurner.sol\";\nimport \"./AaveMonitorProxy.sol\";\nimport \"./AaveSubscriptions.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../AaveSafetyRatio.sol\";\nimport \"../../exchangeV3/DFSExchangeData.sol\";\n\n/// @title Contract implements logic of calling boost/repay in the automatic system\ncontract AaveMonitor is AdminAuth, DSMath, AaveSafetyRatio, GasBurner {\n\n    using SafeERC20 for ERC20;\n\n    enum Method { Boost, Repay }\n\n    uint public REPAY_GAS_TOKEN = 20;\n    uint public BOOST_GAS_TOKEN = 20;\n\n    uint public MAX_GAS_PRICE = 400000000000; // 400 gwei\n\n    uint public REPAY_GAS_COST = 2000000;\n    uint public BOOST_GAS_COST = 2000000;\n\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n\n    AaveMonitorProxy public aaveMonitorProxy;\n    AaveSubscriptions public subscriptionsContract;\n    address public aaveSaverProxy;\n\n    DefisaverLogger public logger = DefisaverLogger(DEFISAVER_LOGGER);\n\n    modifier onlyApproved() {\n        require(BotRegistry(BOT_REGISTRY_ADDRESS).botList(msg.sender), \"Not auth bot\");\n        _;\n    }\n\n    /// @param _aaveMonitorProxy Proxy contracts that actually is authorized to call DSProxy\n    /// @param _subscriptions Subscriptions contract for Aave positions\n    /// @param _aaveSaverProxy Contract that actually performs Repay/Boost\n    constructor(address _aaveMonitorProxy, address _subscriptions, address _aaveSaverProxy) public {\n        aaveMonitorProxy = AaveMonitorProxy(_aaveMonitorProxy);\n        subscriptionsContract = AaveSubscriptions(_subscriptions);\n        aaveSaverProxy = _aaveSaverProxy;\n    }\n\n    /// @notice Bots call this method to repay for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _exData Exchange data\n    /// @param _user The actual address that owns the Aave position\n    function repayFor(\n        DFSExchangeData.ExchangeData memory _exData,\n        address _user\n    ) public payable onlyApproved burnGas(REPAY_GAS_TOKEN) {\n\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Repay, _user);\n        require(isAllowed); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(REPAY_GAS_COST);\n\n        aaveMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            aaveSaverProxy,\n            abi.encodeWithSignature(\n                \"repay((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256)\",\n                _exData,\n                gasCost\n            )\n        );\n\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Repay, _user);\n        require(isGoodRatio); // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(address(this), _user, \"AutomaticAaveRepay\", abi.encode(ratioBefore, ratioAfter));\n    }\n\n    /// @notice Bots call this method to boost for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _exData Exchange data\n    /// @param _user The actual address that owns the Aave position\n    function boostFor(\n        DFSExchangeData.ExchangeData memory _exData,\n        address _user\n    ) public payable onlyApproved burnGas(BOOST_GAS_TOKEN) {\n\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Boost, _user);\n        require(isAllowed); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(BOOST_GAS_COST);\n\n        aaveMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            aaveSaverProxy,\n            abi.encodeWithSignature(\n                \"boost((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256)\",\n                _exData,\n                gasCost\n            )\n        );\n\n\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Boost, _user);\n        require(isGoodRatio);  // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(address(this), _user, \"AutomaticAaveBoost\", abi.encode(ratioBefore, ratioAfter));\n    }\n\n/******************* INTERNAL METHODS ********************************/\n    function returnEth() internal {\n        // return if some eth left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n/******************* STATIC METHODS ********************************/\n\n    /// @notice Checks if Boost/Repay could be triggered for the CDP\n    /// @dev Called by AaveMonitor to enforce the min/max check\n    /// @param _method Type of action to be called\n    /// @param _user The actual address that owns the Aave position\n    /// @return Boolean if it can be called and the ratio\n    function canCall(Method _method, address _user) public view returns(bool, uint) {\n        bool subscribed = subscriptionsContract.isSubscribed(_user);\n        AaveSubscriptions.AaveHolder memory holder = subscriptionsContract.getHolder(_user);\n\n        // check if cdp is subscribed\n        if (!subscribed) return (false, 0);\n\n        // check if boost and boost allowed\n        if (_method == Method.Boost && !holder.boostEnabled) return (false, 0);\n\n        uint currRatio = getSafetyRatio(_user);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.minRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.maxRatio, currRatio);\n        }\n    }\n\n    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call\n    /// @param _method Type of action to be called\n    /// @param _user The actual address that owns the Aave position\n    /// @return Boolean if the recent action preformed correctly and the ratio\n    function ratioGoodAfter(Method _method, address _user) public view returns(bool, uint) {\n        AaveSubscriptions.AaveHolder memory holder;\n\n        holder= subscriptionsContract.getHolder(_user);\n\n        uint currRatio = getSafetyRatio(_user);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.maxRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.minRatio, currRatio);\n        }\n    }\n\n    /// @notice Calculates gas cost (in Eth) of tx\n    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP\n    /// @param _gasAmount Amount of gas used for the tx\n    function calcGasCost(uint _gasAmount) public view returns (uint) {\n        uint gasPrice = tx.gasprice <= MAX_GAS_PRICE ? tx.gasprice : MAX_GAS_PRICE;\n\n        return mul(gasPrice, _gasAmount);\n    }\n\n/******************* OWNER ONLY OPERATIONS ********************************/\n\n    /// @notice As the code is new, have a emergancy admin saver proxy change\n    function changeAaveSaverProxy(address _newAaveSaverProxy) public onlyAdmin {\n        aaveSaverProxy = _newAaveSaverProxy;\n    }\n\n    /// @notice Allows owner to change gas cost for boost operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for boost method\n    function changeBoostGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        BOOST_GAS_COST = _gasCost;\n    }\n\n    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for repay method\n    function changeRepayGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        REPAY_GAS_COST = _gasCost;\n    }\n\n    /// @notice Allows owner to change max gas price\n    /// @param _maxGasPrice New max gas price\n    function changeMaxGasPrice(uint _maxGasPrice) public onlyOwner {\n        require(_maxGasPrice < 500000000000);\n\n        MAX_GAS_PRICE = _maxGasPrice;\n    }\n\n    /// @notice Allows owner to change gas token amount\n    /// @param _gasTokenAmount New gas token amount\n    /// @param _repay true if repay gas token, false if boost gas token\n    function changeGasTokenAmount(uint _gasTokenAmount, bool _repay) public onlyOwner {\n        if (_repay) {\n            REPAY_GAS_TOKEN = _gasTokenAmount;\n        } else {\n            BOOST_GAS_TOKEN = _gasTokenAmount;\n        }\n    }\n}\n"
459     },
460     "contracts/aave/automatic/AaveMonitorProxy.sol": {
461       "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/DSProxyInterface.sol\";\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\n/// @title Contract with the actuall DSProxy permission calls the automation operations\ncontract AaveMonitorProxy is AdminAuth {\n\n    using SafeERC20 for ERC20;\n\n    uint public CHANGE_PERIOD;\n    address public monitor;\n    address public newMonitor;\n    address public lastMonitor;\n    uint public changeRequestedTimestamp;\n\n    mapping(address => bool) public allowed;\n\n    event MonitorChangeInitiated(address oldMonitor, address newMonitor);\n    event MonitorChangeCanceled();\n    event MonitorChangeFinished(address monitor);\n    event MonitorChangeReverted(address monitor);\n\n    // if someone who is allowed become malicious, owner can't be changed\n    modifier onlyAllowed() {\n        require(allowed[msg.sender] || msg.sender == owner);\n        _;\n    }\n\n    modifier onlyMonitor() {\n        require (msg.sender == monitor);\n        _;\n    }\n\n    constructor(uint _changePeriod) public {\n        CHANGE_PERIOD = _changePeriod * 1 days;\n    }\n\n    /// @notice Only monitor contract is able to call execute on users proxy\n    /// @param _owner Address of cdp owner (users DSProxy address)\n    /// @param _aaveSaverProxy Address of AaveSaverProxy\n    /// @param _data Data to send to AaveSaverProxy\n    function callExecute(address _owner, address _aaveSaverProxy, bytes memory _data) public payable onlyMonitor {\n        // execute reverts if calling specific method fails\n        DSProxyInterface(_owner).execute{value: msg.value}(_aaveSaverProxy, _data);\n\n        // return if anything left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Allowed users are able to set Monitor contract without any waiting period first time\n    /// @param _monitor Address of Monitor contract\n    function setMonitor(address _monitor) public onlyAllowed {\n        require(monitor == address(0));\n        monitor = _monitor;\n    }\n\n    /// @notice Allowed users are able to start procedure for changing monitor\n    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change\n    /// @param _newMonitor address of new monitor\n    function changeMonitor(address _newMonitor) public onlyAllowed {\n        require(changeRequestedTimestamp == 0);\n\n        changeRequestedTimestamp = now;\n        lastMonitor = monitor;\n        newMonitor = _newMonitor;\n\n        emit MonitorChangeInitiated(lastMonitor, newMonitor);\n    }\n\n    /// @notice At any point allowed users are able to cancel monitor change\n    function cancelMonitorChange() public onlyAllowed {\n        require(changeRequestedTimestamp > 0);\n\n        changeRequestedTimestamp = 0;\n        newMonitor = address(0);\n\n        emit MonitorChangeCanceled();\n    }\n\n    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started\n    function confirmNewMonitor() public onlyAllowed {\n        require((changeRequestedTimestamp + CHANGE_PERIOD) < now);\n        require(changeRequestedTimestamp != 0);\n        require(newMonitor != address(0));\n\n        monitor = newMonitor;\n        newMonitor = address(0);\n        changeRequestedTimestamp = 0;\n\n        emit MonitorChangeFinished(monitor);\n    }\n\n    /// @notice Its possible to revert monitor to last used monitor\n    function revertMonitor() public onlyAllowed {\n        require(lastMonitor != address(0));\n\n        monitor = lastMonitor;\n\n        emit MonitorChangeReverted(monitor);\n    }\n\n\n    /// @notice Allowed users are able to add new allowed user\n    /// @param _user Address of user that will be allowed\n    function addAllowed(address _user) public onlyAllowed {\n        allowed[_user] = true;\n    }\n\n    /// @notice Allowed users are able to remove allowed user\n    /// @dev owner is always allowed even if someone tries to remove it from allowed mapping\n    /// @param _user Address of allowed user\n    function removeAllowed(address _user) public onlyAllowed {\n        allowed[_user] = false;\n    }\n\n    function setChangePeriod(uint _periodInDays) public onlyAllowed {\n        require(_periodInDays * 1 days > CHANGE_PERIOD);\n\n        CHANGE_PERIOD = _periodInDays * 1 days;\n    }\n\n    /// @notice In case something is left in contract, owner is able to withdraw it\n    /// @param _token address of token to withdraw balance\n    function withdrawToken(address _token) public onlyOwner {\n        uint balance = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).safeTransfer(msg.sender, balance);\n    }\n\n    /// @notice In case something is left in contract, owner is able to withdraw it\n    function withdrawEth() public onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n}\n"
462     },
463     "contracts/aave/automatic/AaveSubscriptions.sol": {
464       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../auth/AdminAuth.sol\";\n\n/// @title Stores subscription information for Aave automatization\ncontract AaveSubscriptions is AdminAuth {\n\n    struct AaveHolder {\n        address user;\n        uint128 minRatio;\n        uint128 maxRatio;\n        uint128 optimalRatioBoost;\n        uint128 optimalRatioRepay;\n        bool boostEnabled;\n    }\n\n    struct SubPosition {\n        uint arrPos;\n        bool subscribed;\n    }\n\n    AaveHolder[] public subscribers;\n    mapping (address => SubPosition) public subscribersPos;\n\n    uint public changeIndex;\n\n    event Subscribed(address indexed user);\n    event Unsubscribed(address indexed user);\n    event Updated(address indexed user);\n    event ParamUpdates(address indexed user, uint128, uint128, uint128, uint128, bool);\n\n    /// @dev Called by the DSProxy contract which owns the Aave position\n    /// @notice Adds the users Aave poistion in the list of subscriptions so it can be monitored\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalBoost Ratio amount which boost should target\n    /// @param _optimalRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    function subscribe(uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled) external {\n\n        // if boost is not enabled, set max ratio to max uint\n        uint128 localMaxRatio = _boostEnabled ? _maxRatio : uint128(-1);\n        require(checkParams(_minRatio, localMaxRatio), \"Must be correct params\");\n\n        SubPosition storage subInfo = subscribersPos[msg.sender];\n\n        AaveHolder memory subscription = AaveHolder({\n                minRatio: _minRatio,\n                maxRatio: localMaxRatio,\n                optimalRatioBoost: _optimalBoost,\n                optimalRatioRepay: _optimalRepay,\n                user: msg.sender,\n                boostEnabled: _boostEnabled\n            });\n\n        changeIndex++;\n\n        if (subInfo.subscribed) {\n            subscribers[subInfo.arrPos] = subscription;\n\n            emit Updated(msg.sender);\n            emit ParamUpdates(msg.sender, _minRatio, localMaxRatio, _optimalBoost, _optimalRepay, _boostEnabled);\n        } else {\n            subscribers.push(subscription);\n\n            subInfo.arrPos = subscribers.length - 1;\n            subInfo.subscribed = true;\n\n            emit Subscribed(msg.sender);\n        }\n    }\n\n    /// @notice Called by the users DSProxy\n    /// @dev Owner who subscribed cancels his subscription\n    function unsubscribe() external {\n        _unsubscribe(msg.sender);\n    }\n\n    /// @dev Checks limit if minRatio is bigger than max\n    /// @param _minRatio Minimum ratio, bellow which repay can be triggered\n    /// @param _maxRatio Maximum ratio, over which boost can be triggered\n    /// @return Returns bool if the params are correct\n    function checkParams(uint128 _minRatio, uint128 _maxRatio) internal pure returns (bool) {\n\n        if (_minRatio > _maxRatio) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @dev Internal method to remove a subscriber from the list\n    /// @param _user The actual address that owns the Aave position\n    function _unsubscribe(address _user) internal {\n        require(subscribers.length > 0, \"Must have subscribers in the list\");\n\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        require(subInfo.subscribed, \"Must first be subscribed\");\n\n        address lastOwner = subscribers[subscribers.length - 1].user;\n\n        SubPosition storage subInfo2 = subscribersPos[lastOwner];\n        subInfo2.arrPos = subInfo.arrPos;\n\n        subscribers[subInfo.arrPos] = subscribers[subscribers.length - 1];\n        subscribers.pop(); // remove last element and reduce arr length\n\n        changeIndex++;\n        subInfo.subscribed = false;\n        subInfo.arrPos = 0;\n\n        emit Unsubscribed(msg.sender);\n    }\n\n    /// @dev Checks if the user is subscribed\n    /// @param _user The actual address that owns the Aave position\n    /// @return If the user is subscribed\n    function isSubscribed(address _user) public view returns (bool) {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        return subInfo.subscribed;\n    }\n\n    /// @dev Returns subscribtion information about a user\n    /// @param _user The actual address that owns the Aave position\n    /// @return Subscription information about the user if exists\n    function getHolder(address _user) public view returns (AaveHolder memory) {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        return subscribers[subInfo.arrPos];\n    }\n\n    /// @notice Helper method to return all the subscribed CDPs\n    /// @return List of all subscribers\n    function getSubscribers() public view returns (AaveHolder[] memory) {\n        return subscribers;\n    }\n\n    /// @notice Helper method for the frontend, returns all the subscribed CDPs paginated\n    /// @param _page What page of subscribers you want\n    /// @param _perPage Number of entries per page\n    /// @return List of all subscribers for that page\n    function getSubscribersByPage(uint _page, uint _perPage) public view returns (AaveHolder[] memory) {\n        AaveHolder[] memory holders = new AaveHolder[](_perPage);\n\n        uint start = _page * _perPage;\n        uint end = start + _perPage;\n\n        end = (end > holders.length) ? holders.length : end;\n\n        uint count = 0;\n        for (uint i = start; i < end; i++) {\n            holders[count] = subscribers[i];\n            count++;\n        }\n\n        return holders;\n    }\n\n    ////////////// ADMIN METHODS ///////////////////\n\n    /// @notice Admin function to unsubscribe a position\n    /// @param _user The actual address that owns the Aave position\n    function unsubscribeByAdmin(address _user) public onlyOwner {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        if (subInfo.subscribed) {\n            _unsubscribe(_user);\n        }\n    }\n}\n"
465     },
466     "contracts/aave/AaveLoanInfo.sol": {
467       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./AaveSafetyRatio.sol\";\n\ncontract AaveLoanInfo is AaveSafetyRatio {\n\n\tstruct LoanData {\n        address user;\n        uint128 ratio;\n        address[] collAddr;\n        address[] borrowAddr;\n        uint256[] collAmounts;\n        uint256[] borrowAmounts;\n    }\n\n    struct TokenInfo {\n        address aTokenAddress;\n        address underlyingTokenAddress;\n        uint256 collateralFactor;\n        uint256 price;\n    }\n\n    struct TokenInfoFull {\n    \taddress aTokenAddress;\n        address underlyingTokenAddress;\n        uint256 supplyRate;\n        uint256 borrowRate;\n        uint256 borrowRateStable;\n        uint256 totalSupply;\n        uint256 availableLiquidity;\n        uint256 totalBorrow;\n        uint256 collateralFactor;\n        uint256 liquidationRatio;\n        uint256 price;\n        bool usageAsCollateralEnabled;\n    }\n\n    struct UserToken {\n        address token;\n        uint256 balance;\n        uint256 borrows;\n        uint256 borrowRateMode;\n        uint256 borrowRate;\n        bool enabledAsCollateral;\n    }\n\n    /// @notice Calcualted the ratio of coll/debt for a compound user\n    /// @param _user Address of the user\n    function getRatio(address _user) public view returns (uint256) {\n        // For each asset the account is in\n        return getSafetyRatio(_user);\n    }\n\n    /// @notice Fetches Aave prices for tokens\n    /// @param _tokens Arr. of tokens for which to get the prices\n    /// @return prices Array of prices\n    function getPrices(address[] memory _tokens) public view returns (uint256[] memory prices) {\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n        prices = new uint[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            prices[i] = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokens[i]);\n        }\n    }\n\n    /// @notice Fetches Aave collateral factors for tokens\n    /// @param _tokens Arr. of tokens for which to get the coll. factors\n    /// @return collFactors Array of coll. factors\n    function getCollFactors(address[] memory _tokens) public view returns (uint256[] memory collFactors) {\n    \taddress lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        collFactors = new uint256[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n        \t(,collFactors[i],,) = ILendingPool(lendingPoolCoreAddress).getReserveConfiguration(_tokens[i]);\n        }\n    }\n\n    function getTokenBalances(address _user, address[] memory _tokens) public view returns (UserToken[] memory userTokens) {\n    \taddress lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        userTokens = new UserToken[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address asset = _tokens[i];\n            userTokens[i].token = asset;\n\n            (userTokens[i].balance, userTokens[i].borrows,,userTokens[i].borrowRateMode,userTokens[i].borrowRate,,,,,userTokens[i].enabledAsCollateral) = ILendingPool(lendingPoolAddress).getUserReserveData(asset, _user);\n        }\n    }\n\n    /// @notice Calcualted the ratio of coll/debt for an aave user\n    /// @param _users Addresses of the user\n    /// @return ratios Array of ratios\n    function getRatios(address[] memory _users) public view returns (uint256[] memory ratios) {\n        ratios = new uint256[](_users.length);\n\n        for (uint256 i = 0; i < _users.length; ++i) {\n            ratios[i] = getSafetyRatio(_users[i]);\n        }\n    }\n\n    /// @notice Information about reserves\n    /// @param _tokenAddresses Array of tokens addresses\n    /// @return tokens Array of reserves infomartion\n    function getTokensInfo(address[] memory _tokenAddresses) public view returns(TokenInfo[] memory tokens) {\n    \taddress lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n    \taddress priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n        tokens = new TokenInfo[](_tokenAddresses.length);\n\n        for (uint256 i = 0; i < _tokenAddresses.length; ++i) {\n        \t(,uint256 ltv,,) = ILendingPool(lendingPoolCoreAddress).getReserveConfiguration(_tokenAddresses[i]);\n\n            tokens[i] = TokenInfo({\n                aTokenAddress: ILendingPool(lendingPoolCoreAddress).getReserveATokenAddress(_tokenAddresses[i]),\n                underlyingTokenAddress: _tokenAddresses[i],\n                collateralFactor: ltv,\n                price: IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokenAddresses[i])\n            });\n        }\n    }\n\n    /// @notice Information about reserves\n    /// @param _tokenAddresses Array of token addresses\n    /// @return tokens Array of reserves infomartion\n    function getFullTokensInfo(address[] memory _tokenAddresses) public view returns(TokenInfoFull[] memory tokens) {\n    \taddress lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n    \taddress priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n        tokens = new TokenInfoFull[](_tokenAddresses.length);\n\n        for (uint256 i = 0; i < _tokenAddresses.length; ++i) {\n        \t(uint256 ltv, uint256 liqRatio,,, bool usageAsCollateralEnabled, bool borrowingEnabled, bool stableBorrowingEnabled,) = ILendingPool(lendingPoolAddress).getReserveConfigurationData(_tokenAddresses[i]);\n\n            tokens[i] = TokenInfoFull({\n            \taTokenAddress: ILendingPool(lendingPoolCoreAddress).getReserveATokenAddress(_tokenAddresses[i]),\n                underlyingTokenAddress: _tokenAddresses[i],\n                supplyRate: ILendingPool(lendingPoolCoreAddress).getReserveCurrentLiquidityRate(_tokenAddresses[i]),\n                borrowRate: borrowingEnabled ? ILendingPool(lendingPoolCoreAddress).getReserveCurrentVariableBorrowRate(_tokenAddresses[i]) : 0,\n                borrowRateStable: stableBorrowingEnabled ? ILendingPool(lendingPoolCoreAddress).getReserveCurrentStableBorrowRate(_tokenAddresses[i]) : 0,\n                totalSupply: ILendingPool(lendingPoolCoreAddress).getReserveTotalLiquidity(_tokenAddresses[i]),\n                availableLiquidity: ILendingPool(lendingPoolCoreAddress).getReserveAvailableLiquidity(_tokenAddresses[i]),\n                totalBorrow: ILendingPool(lendingPoolCoreAddress).getReserveTotalBorrowsVariable(_tokenAddresses[i]) + ILendingPool(lendingPoolCoreAddress).getReserveTotalBorrowsStable(_tokenAddresses[i]),\n                collateralFactor: ltv,\n                liquidationRatio: liqRatio,\n                price: IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokenAddresses[i]),\n                usageAsCollateralEnabled: usageAsCollateralEnabled\n            });\n        }\n    }\n\n\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether\n    /// @param _user Address of the user\n    /// @return data LoanData information\n    function getLoanData(address _user) public view returns (LoanData memory data) {\n        address lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n        address[] memory reserves = ILendingPool(lendingPoolAddress).getReserves();\n\n        data = LoanData({\n            user: _user,\n            ratio: 0,\n            collAddr: new address[](reserves.length),\n            borrowAddr: new address[](reserves.length),\n            collAmounts: new uint[](reserves.length),\n            borrowAmounts: new uint[](reserves.length)\n        });\n\n        uint64 collPos = 0;\n        uint64 borrowPos = 0;\n\n        for (uint64 i = 0; i < reserves.length; i++) {\n            address reserve = reserves[i];\n\n            (uint256 aTokenBalance, uint256 borrowBalance,,,,,,,,) = ILendingPool(lendingPoolAddress).getUserReserveData(reserve, _user);\n            uint256 price = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(reserves[i]);\n\n            if (aTokenBalance > 0) {\n            \tuint256 userTokenBalanceEth = wmul(aTokenBalance, price) * (10 ** (18 - _getDecimals(reserve)));\n            \tdata.collAddr[collPos] = reserve;\n                data.collAmounts[collPos] = userTokenBalanceEth;\n                collPos++;\n        \t}\n\n            // Sum up debt in Eth\n            if (borrowBalance > 0) {\n            \tuint256 userBorrowBalanceEth = wmul(borrowBalance, price) * (10 ** (18 - _getDecimals(reserve)));\n                data.borrowAddr[borrowPos] = reserve;\n                data.borrowAmounts[borrowPos] = userBorrowBalanceEth;\n                borrowPos++;\n            }\n        }\n\n        data.ratio = uint128(getSafetyRatio(_user));\n\n        return data;\n    }\n\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether\n    /// @param _users Addresses of the user\n    /// @return loans Array of LoanData information\n    function getLoanDataArr(address[] memory _users) public view returns (LoanData[] memory loans) {\n        loans = new LoanData[](_users.length);\n\n        for (uint i = 0; i < _users.length; ++i) {\n            loans[i] = getLoanData(_users[i]);\n        }\n    }\n}\n"
468     },
469     "contracts/exchangeV3/DFSExchange.sol": {
470       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/GasTokenInterface.sol\";\nimport \"./DFSExchangeCore.sol\";\nimport \"../DS/DSMath.sol\";\nimport \"../loggers/DefisaverLogger.sol\";\nimport \"../auth/AdminAuth.sol\";\nimport \"../utils/GasBurner.sol\";\nimport \"../utils/SafeERC20.sol\";\n\ncontract DFSExchange is DFSExchangeCore, AdminAuth, GasBurner {\n\n    using SafeERC20 for ERC20;\n\n    uint256 public constant SERVICE_FEE = 800; // 0.125% Fee\n\n    // solhint-disable-next-line const-name-snakecase\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\n\n    uint public burnAmount = 10;\n\n    /// @notice Takes a src amount of tokens and converts it into the dest token\n    /// @dev Takes fee from the _srcAmount before the exchange\n    /// @param exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]\n    /// @param _user User address who called the exchange\n    function sell(ExchangeData memory exData, address payable _user) public payable burnGas(burnAmount) {\n\n        exData.dfsFeeDivider = SERVICE_FEE;\n        exData.user = _user;\n\n        // Perform the exchange\n        (address wrapper, uint destAmount) = _sell(exData);\n\n        // send back any leftover ether or tokens\n        sendLeftover(exData.srcAddr, exData.destAddr, _user);\n\n        // log the event\n        logger.Log(address(this), msg.sender, \"ExchangeSell\", abi.encode(wrapper, exData.srcAddr, exData.destAddr, exData.srcAmount, destAmount));\n    }\n\n    /// @notice Takes a dest amount of tokens and converts it from the src token\n    /// @dev Send always more than needed for the swap, extra will be returned\n    /// @param exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]\n    /// @param _user User address who called the exchange\n    function buy(ExchangeData memory exData, address payable _user) public payable burnGas(burnAmount){\n\n        exData.dfsFeeDivider = SERVICE_FEE;\n        exData.user = _user;\n\n        // Perform the exchange\n        (address wrapper, uint srcAmount) = _buy(exData);\n\n        // send back any leftover ether or tokens\n        sendLeftover(exData.srcAddr, exData.destAddr, _user);\n\n        // log the event\n        logger.Log(address(this), msg.sender, \"ExchangeBuy\", abi.encode(wrapper, exData.srcAddr, exData.destAddr, srcAmount, exData.destAmount));\n\n    }\n\n    /// @notice Changes the amount of gas token we burn for each call\n    /// @dev Only callable by the owner\n    /// @param _newBurnAmount New amount of gas tokens to be burned\n    function changeBurnAmount(uint _newBurnAmount) public {\n        require(owner == msg.sender);\n\n        burnAmount = _newBurnAmount;\n    }\n\n}\n"
471     },
472     "contracts/exchangeV3/AllowanceProxyV3.sol": {
473       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../auth/AdminAuth.sol\";\nimport \"./DFSExchange.sol\";\nimport \"../utils/SafeERC20.sol\";\n\ncontract AllowanceProxy is AdminAuth {\n\n    using SafeERC20 for ERC20;\n\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    DFSExchange dfsExchange = DFSExchange(0xc2Ce04e2FB4DD20964b4410FcE718b95963a1587);\n\n    function callSell(DFSExchangeCore.ExchangeData memory exData) public payable {\n        pullAndSendTokens(exData.srcAddr, exData.srcAmount);\n\n        dfsExchange.sell{value: msg.value}(exData, msg.sender);\n    }\n\n    function callBuy(DFSExchangeCore.ExchangeData memory exData) public payable {\n        pullAndSendTokens(exData.srcAddr, exData.srcAmount);\n\n        dfsExchange.buy{value: msg.value}(exData, msg.sender);\n    }\n\n    function pullAndSendTokens(address _tokenAddr, uint _amount) internal {\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\n            require(msg.value >= _amount, \"msg.value smaller than amount\");\n        } else {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(dfsExchange), _amount);\n        }\n    }\n\n    function ownerChangeExchange(address payable _newExchange) public onlyOwner {\n        dfsExchange = DFSExchange(_newExchange);\n    }\n}\n"
474     },
475     "contracts/compound/automatic/CompoundMonitor.sol": {
476       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/BotRegistry.sol\";\nimport \"../../utils/GasBurner.sol\";\nimport \"./CompoundMonitorProxy.sol\";\nimport \"./CompoundSubscriptions.sol\";\nimport \"../../interfaces/GasTokenInterface.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../CompoundSafetyRatio.sol\";\nimport \"../../exchangeV3/DFSExchangeData.sol\";\n\n/// @title Contract implements logic of calling boost/repay in the automatic system\ncontract CompoundMonitor is AdminAuth, DSMath, CompoundSafetyRatio, GasBurner {\n\n    using SafeERC20 for ERC20;\n\n    enum Method { Boost, Repay }\n\n    uint public REPAY_GAS_TOKEN = 20;\n    uint public BOOST_GAS_TOKEN = 20;\n\n    uint constant public MAX_GAS_PRICE = 500000000000; // 500 gwei\n\n    uint public REPAY_GAS_COST = 1500000;\n    uint public BOOST_GAS_COST = 1000000;\n\n    address public constant GAS_TOKEN_INTERFACE_ADDRESS = 0x0000000000b3F879cb30FE243b4Dfee438691c04;\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n    address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;\n\n    CompoundMonitorProxy public compoundMonitorProxy;\n    CompoundSubscriptions public subscriptionsContract;\n    address public compoundFlashLoanTakerAddress;\n\n    DefisaverLogger public logger = DefisaverLogger(DEFISAVER_LOGGER);\n\n    modifier onlyApproved() {\n        require(BotRegistry(BOT_REGISTRY_ADDRESS).botList(msg.sender), \"Not auth bot\");\n        _;\n    }\n\n    /// @param _compoundMonitorProxy Proxy contracts that actually is authorized to call DSProxy\n    /// @param _subscriptions Subscriptions contract for Compound positions\n    /// @param _compoundFlashLoanTaker Contract that actually performs Repay/Boost\n    constructor(address _compoundMonitorProxy, address _subscriptions, address _compoundFlashLoanTaker) public {\n        compoundMonitorProxy = CompoundMonitorProxy(_compoundMonitorProxy);\n        subscriptionsContract = CompoundSubscriptions(_subscriptions);\n        compoundFlashLoanTakerAddress = _compoundFlashLoanTaker;\n    }\n\n    /// @notice Bots call this method to repay for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _user The actual address that owns the Compound position\n    function repayFor(\n        DFSExchangeData.ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        address _user\n    ) public payable onlyApproved burnGas(REPAY_GAS_TOKEN) {\n\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Repay, _user);\n        require(isAllowed); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(REPAY_GAS_COST);\n\n        compoundMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            compoundFlashLoanTakerAddress,\n            abi.encodeWithSignature(\n                \"repayWithLoan((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),address[2],uint256)\",\n                _exData,\n                _cAddresses,\n                gasCost\n            )\n        );\n\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Repay, _user);\n        require(isGoodRatio); // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(address(this), _user, \"AutomaticCompoundRepay\", abi.encode(ratioBefore, ratioAfter));\n    }\n\n    /// @notice Bots call this method to boost for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _user The actual address that owns the Compound position\n    function boostFor(\n        DFSExchangeData.ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        address _user\n    ) public payable onlyApproved burnGas(BOOST_GAS_TOKEN) {\n\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Boost, _user);\n        require(isAllowed); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(BOOST_GAS_COST);\n\n        compoundMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            compoundFlashLoanTakerAddress,\n            abi.encodeWithSignature(\n                \"boostWithLoan((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),address[2],uint256)\",\n                _exData,\n                _cAddresses,\n                gasCost\n            )\n        );\n\n\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Boost, _user);\n        require(isGoodRatio);  // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(address(this), _user, \"AutomaticCompoundBoost\", abi.encode(ratioBefore, ratioAfter));\n    }\n\n/******************* INTERNAL METHODS ********************************/\n    function returnEth() internal {\n        // return if some eth left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n/******************* STATIC METHODS ********************************/\n\n    /// @notice Checks if Boost/Repay could be triggered for the CDP\n    /// @dev Called by MCDMonitor to enforce the min/max check\n    /// @param _method Type of action to be called\n    /// @param _user The actual address that owns the Compound position\n    /// @return Boolean if it can be called and the ratio\n    function canCall(Method _method, address _user) public view returns(bool, uint) {\n        bool subscribed = subscriptionsContract.isSubscribed(_user);\n        CompoundSubscriptions.CompoundHolder memory holder = subscriptionsContract.getHolder(_user);\n\n        // check if cdp is subscribed\n        if (!subscribed) return (false, 0);\n\n        // check if boost and boost allowed\n        if (_method == Method.Boost && !holder.boostEnabled) return (false, 0);\n\n        uint currRatio = getSafetyRatio(_user);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.minRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.maxRatio, currRatio);\n        }\n    }\n\n    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call\n    /// @param _method Type of action to be called\n    /// @param _user The actual address that owns the Compound position\n    /// @return Boolean if the recent action preformed correctly and the ratio\n    function ratioGoodAfter(Method _method, address _user) public view returns(bool, uint) {\n        CompoundSubscriptions.CompoundHolder memory holder;\n\n        holder= subscriptionsContract.getHolder(_user);\n\n        uint currRatio = getSafetyRatio(_user);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.maxRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.minRatio, currRatio);\n        }\n    }\n\n    /// @notice Calculates gas cost (in Eth) of tx\n    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP\n    /// @param _gasAmount Amount of gas used for the tx\n    function calcGasCost(uint _gasAmount) public view returns (uint) {\n        uint gasPrice = tx.gasprice <= MAX_GAS_PRICE ? tx.gasprice : MAX_GAS_PRICE;\n\n        return mul(gasPrice, _gasAmount);\n    }\n\n/******************* OWNER ONLY OPERATIONS ********************************/\n\n    /// @notice As the code is new, have a emergancy admin saver proxy change\n    function changeCompoundFlashLoanTaker(address _newCompoundFlashLoanTakerAddress) public onlyAdmin {\n        compoundFlashLoanTakerAddress = _newCompoundFlashLoanTakerAddress;\n    }\n\n    /// @notice Allows owner to change gas cost for boost operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for boost method\n    function changeBoostGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        BOOST_GAS_COST = _gasCost;\n    }\n\n    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for repay method\n    function changeRepayGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        REPAY_GAS_COST = _gasCost;\n    }\n\n    /// @notice If any tokens gets stuck in the contract owner can withdraw it\n    /// @param _tokenAddress Address of the ERC20 token\n    /// @param _to Address of the receiver\n    /// @param _amount The amount to be sent\n    function transferERC20(address _tokenAddress, address _to, uint _amount) public onlyOwner {\n        ERC20(_tokenAddress).safeTransfer(_to, _amount);\n    }\n\n    /// @notice If any Eth gets stuck in the contract owner can withdraw it\n    /// @param _to Address of the receiver\n    /// @param _amount The amount to be sent\n    function transferEth(address payable _to, uint _amount) public onlyOwner {\n        _to.transfer(_amount);\n    }\n}\n"
477     },
478     "contracts/compound/automatic/CompoundMonitorProxy.sol": {
479       "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/DSProxyInterface.sol\";\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\n/// @title Contract with the actuall DSProxy permission calls the automation operations\ncontract CompoundMonitorProxy is AdminAuth {\n\n    using SafeERC20 for ERC20;\n\n    uint public CHANGE_PERIOD;\n    address public monitor;\n    address public newMonitor;\n    address public lastMonitor;\n    uint public changeRequestedTimestamp;\n\n    mapping(address => bool) public allowed;\n\n    event MonitorChangeInitiated(address oldMonitor, address newMonitor);\n    event MonitorChangeCanceled();\n    event MonitorChangeFinished(address monitor);\n    event MonitorChangeReverted(address monitor);\n\n    // if someone who is allowed become malicious, owner can't be changed\n    modifier onlyAllowed() {\n        require(allowed[msg.sender] || msg.sender == owner);\n        _;\n    }\n\n    modifier onlyMonitor() {\n        require (msg.sender == monitor);\n        _;\n    }\n\n    constructor(uint _changePeriod) public {\n        CHANGE_PERIOD = _changePeriod * 1 days;\n    }\n\n    /// @notice Only monitor contract is able to call execute on users proxy\n    /// @param _owner Address of cdp owner (users DSProxy address)\n    /// @param _compoundSaverProxy Address of CompoundSaverProxy\n    /// @param _data Data to send to CompoundSaverProxy\n    function callExecute(address _owner, address _compoundSaverProxy, bytes memory _data) public payable onlyMonitor {\n        // execute reverts if calling specific method fails\n        DSProxyInterface(_owner).execute{value: msg.value}(_compoundSaverProxy, _data);\n\n        // return if anything left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Allowed users are able to set Monitor contract without any waiting period first time\n    /// @param _monitor Address of Monitor contract\n    function setMonitor(address _monitor) public onlyAllowed {\n        require(monitor == address(0));\n        monitor = _monitor;\n    }\n\n    /// @notice Allowed users are able to start procedure for changing monitor\n    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change\n    /// @param _newMonitor address of new monitor\n    function changeMonitor(address _newMonitor) public onlyAllowed {\n        require(changeRequestedTimestamp == 0);\n\n        changeRequestedTimestamp = now;\n        lastMonitor = monitor;\n        newMonitor = _newMonitor;\n\n        emit MonitorChangeInitiated(lastMonitor, newMonitor);\n    }\n\n    /// @notice At any point allowed users are able to cancel monitor change\n    function cancelMonitorChange() public onlyAllowed {\n        require(changeRequestedTimestamp > 0);\n\n        changeRequestedTimestamp = 0;\n        newMonitor = address(0);\n\n        emit MonitorChangeCanceled();\n    }\n\n    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started\n    function confirmNewMonitor() public onlyAllowed {\n        require((changeRequestedTimestamp + CHANGE_PERIOD) < now);\n        require(changeRequestedTimestamp != 0);\n        require(newMonitor != address(0));\n\n        monitor = newMonitor;\n        newMonitor = address(0);\n        changeRequestedTimestamp = 0;\n\n        emit MonitorChangeFinished(monitor);\n    }\n\n    /// @notice Its possible to revert monitor to last used monitor\n    function revertMonitor() public onlyAllowed {\n        require(lastMonitor != address(0));\n\n        monitor = lastMonitor;\n\n        emit MonitorChangeReverted(monitor);\n    }\n\n\n    /// @notice Allowed users are able to add new allowed user\n    /// @param _user Address of user that will be allowed\n    function addAllowed(address _user) public onlyAllowed {\n        allowed[_user] = true;\n    }\n\n    /// @notice Allowed users are able to remove allowed user\n    /// @dev owner is always allowed even if someone tries to remove it from allowed mapping\n    /// @param _user Address of allowed user\n    function removeAllowed(address _user) public onlyAllowed {\n        allowed[_user] = false;\n    }\n\n    function setChangePeriod(uint _periodInDays) public onlyAllowed {\n        require(_periodInDays * 1 days > CHANGE_PERIOD);\n\n        CHANGE_PERIOD = _periodInDays * 1 days;\n    }\n\n    /// @notice In case something is left in contract, owner is able to withdraw it\n    /// @param _token address of token to withdraw balance\n    function withdrawToken(address _token) public onlyOwner {\n        uint balance = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).safeTransfer(msg.sender, balance);\n    }\n\n    /// @notice In case something is left in contract, owner is able to withdraw it\n    function withdrawEth() public onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n}\n"
480     },
481     "contracts/compound/automatic/CompoundSubscriptions.sol": {
482       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../auth/AdminAuth.sol\";\n\n/// @title Stores subscription information for Compound automatization\ncontract CompoundSubscriptions is AdminAuth {\n\n    struct CompoundHolder {\n        address user;\n        uint128 minRatio;\n        uint128 maxRatio;\n        uint128 optimalRatioBoost;\n        uint128 optimalRatioRepay;\n        bool boostEnabled;\n    }\n\n    struct SubPosition {\n        uint arrPos;\n        bool subscribed;\n    }\n\n    CompoundHolder[] public subscribers;\n    mapping (address => SubPosition) public subscribersPos;\n\n    uint public changeIndex;\n\n    event Subscribed(address indexed user);\n    event Unsubscribed(address indexed user);\n    event Updated(address indexed user);\n    event ParamUpdates(address indexed user, uint128, uint128, uint128, uint128, bool);\n\n    /// @dev Called by the DSProxy contract which owns the Compound position\n    /// @notice Adds the users Compound poistion in the list of subscriptions so it can be monitored\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalBoost Ratio amount which boost should target\n    /// @param _optimalRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    function subscribe(uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled) external {\n\n        // if boost is not enabled, set max ratio to max uint\n        uint128 localMaxRatio = _boostEnabled ? _maxRatio : uint128(-1);\n        require(checkParams(_minRatio, localMaxRatio), \"Must be correct params\");\n\n        SubPosition storage subInfo = subscribersPos[msg.sender];\n\n        CompoundHolder memory subscription = CompoundHolder({\n                minRatio: _minRatio,\n                maxRatio: localMaxRatio,\n                optimalRatioBoost: _optimalBoost,\n                optimalRatioRepay: _optimalRepay,\n                user: msg.sender,\n                boostEnabled: _boostEnabled\n            });\n\n        changeIndex++;\n\n        if (subInfo.subscribed) {\n            subscribers[subInfo.arrPos] = subscription;\n\n            emit Updated(msg.sender);\n            emit ParamUpdates(msg.sender, _minRatio, localMaxRatio, _optimalBoost, _optimalRepay, _boostEnabled);\n        } else {\n            subscribers.push(subscription);\n\n            subInfo.arrPos = subscribers.length - 1;\n            subInfo.subscribed = true;\n\n            emit Subscribed(msg.sender);\n        }\n    }\n\n    /// @notice Called by the users DSProxy\n    /// @dev Owner who subscribed cancels his subscription\n    function unsubscribe() external {\n        _unsubscribe(msg.sender);\n    }\n\n    /// @dev Checks limit if minRatio is bigger than max\n    /// @param _minRatio Minimum ratio, bellow which repay can be triggered\n    /// @param _maxRatio Maximum ratio, over which boost can be triggered\n    /// @return Returns bool if the params are correct\n    function checkParams(uint128 _minRatio, uint128 _maxRatio) internal pure returns (bool) {\n\n        if (_minRatio > _maxRatio) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @dev Internal method to remove a subscriber from the list\n    /// @param _user The actual address that owns the Compound position\n    function _unsubscribe(address _user) internal {\n        require(subscribers.length > 0, \"Must have subscribers in the list\");\n\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        require(subInfo.subscribed, \"Must first be subscribed\");\n\n        address lastOwner = subscribers[subscribers.length - 1].user;\n\n        SubPosition storage subInfo2 = subscribersPos[lastOwner];\n        subInfo2.arrPos = subInfo.arrPos;\n\n        subscribers[subInfo.arrPos] = subscribers[subscribers.length - 1];\n        subscribers.pop(); // remove last element and reduce arr length\n\n        changeIndex++;\n        subInfo.subscribed = false;\n        subInfo.arrPos = 0;\n\n        emit Unsubscribed(msg.sender);\n    }\n\n    /// @dev Checks if the user is subscribed\n    /// @param _user The actual address that owns the Compound position\n    /// @return If the user is subscribed\n    function isSubscribed(address _user) public view returns (bool) {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        return subInfo.subscribed;\n    }\n\n    /// @dev Returns subscribtion information about a user\n    /// @param _user The actual address that owns the Compound position\n    /// @return Subscription information about the user if exists\n    function getHolder(address _user) public view returns (CompoundHolder memory) {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        return subscribers[subInfo.arrPos];\n    }\n\n    /// @notice Helper method to return all the subscribed CDPs\n    /// @return List of all subscribers\n    function getSubscribers() public view returns (CompoundHolder[] memory) {\n        return subscribers;\n    }\n\n    /// @notice Helper method for the frontend, returns all the subscribed CDPs paginated\n    /// @param _page What page of subscribers you want\n    /// @param _perPage Number of entries per page\n    /// @return List of all subscribers for that page\n    function getSubscribersByPage(uint _page, uint _perPage) public view returns (CompoundHolder[] memory) {\n        CompoundHolder[] memory holders = new CompoundHolder[](_perPage);\n\n        uint start = _page * _perPage;\n        uint end = start + _perPage;\n\n        end = (end > holders.length) ? holders.length : end;\n\n        uint count = 0;\n        for (uint i = start; i < end; i++) {\n            holders[count] = subscribers[i];\n            count++;\n        }\n\n        return holders;\n    }\n\n    ////////////// ADMIN METHODS ///////////////////\n\n    /// @notice Admin function to unsubscribe a CDP\n    /// @param _user The actual address that owns the Compound position\n    function unsubscribeByAdmin(address _user) public onlyOwner {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        if (subInfo.subscribed) {\n            _unsubscribe(_user);\n        }\n    }\n}\n"
483     },
484     "contracts/compound/CompoundSafetyRatio.sol": {
485       "content": "pragma solidity ^0.6.0;\n\nimport \"../DS/DSMath.sol\";\nimport \"../interfaces/CompoundOracleInterface.sol\";\nimport \"../interfaces/ComptrollerInterface.sol\";\nimport \"../interfaces/CTokenInterface.sol\";\nimport \"./helpers/Exponential.sol\";\n\n\ncontract CompoundSafetyRatio is Exponential, DSMath {\n    // solhint-disable-next-line const-name-snakecase\n    ComptrollerInterface public constant comp = ComptrollerInterface(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n\n    /// @notice Calcualted the ratio of debt / adjusted collateral\n    /// @param _user Address of the user\n    function getSafetyRatio(address _user) public view returns (uint) {\n        // For each asset the account is in\n        address[] memory assets = comp.getAssetsIn(_user);\n        address oracleAddr = comp.oracle();\n\n\n        uint sumCollateral = 0;\n        uint sumBorrow = 0;\n\n        for (uint i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n\n            Exp memory oraclePrice;\n\n            if (cTokenBalance != 0 || borrowBalance != 0) {\n                oraclePrice = Exp({mantissa: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(asset)});\n            }\n\n            // Sum up collateral in Usd\n            if (cTokenBalance != 0) {\n\n                (, uint collFactorMantissa) = comp.markets(address(asset));\n\n                Exp memory collateralFactor = Exp({mantissa: collFactorMantissa});\n                Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n\n                (, Exp memory tokensToUsd) = mulExp3(collateralFactor, exchangeRate, oraclePrice);\n\n                (, sumCollateral) = mulScalarTruncateAddUInt(tokensToUsd, cTokenBalance, sumCollateral);\n            }\n\n            // Sum up debt in Usd\n            if (borrowBalance != 0) {\n                (, sumBorrow) = mulScalarTruncateAddUInt(oraclePrice, borrowBalance, sumBorrow);\n            }\n        }\n\n        if (sumBorrow == 0) return uint(-1);\n\n        uint borrowPowerUsed = (sumBorrow * 10**18) / sumCollateral;\n        return wdiv(1e18, borrowPowerUsed);\n    }\n}\n"
486     },
487     "contracts/compound/CompoundLoanInfo.sol": {
488       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./CompoundSafetyRatio.sol\";\nimport \"./helpers/CompoundSaverHelper.sol\";\n\n\n/// @title Gets data about Compound positions\ncontract CompoundLoanInfo is CompoundSafetyRatio {\n\n    struct LoanData {\n        address user;\n        uint128 ratio;\n        address[] collAddr;\n        address[] borrowAddr;\n        uint[] collAmounts;\n        uint[] borrowAmounts;\n    }\n\n    struct TokenInfo {\n        address cTokenAddress;\n        address underlyingTokenAddress;\n        uint collateralFactor;\n        uint price;\n    }\n\n    struct TokenInfoFull {\n        address underlyingTokenAddress;\n        uint supplyRate;\n        uint borrowRate;\n        uint exchangeRate;\n        uint marketLiquidity;\n        uint totalSupply;\n        uint totalBorrow;\n        uint collateralFactor;\n        uint price;\n        uint borrowCap;\n    }\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant CETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n\n\n    /// @notice Calcualted the ratio of coll/debt for a compound user\n    /// @param _user Address of the user\n    function getRatio(address _user) public view returns (uint) {\n        // For each asset the account is in\n        return getSafetyRatio(_user);\n    }\n\n    /// @notice Fetches Compound prices for tokens\n    /// @param _cTokens Arr. of cTokens for which to get the prices\n    /// @return prices Array of prices\n    function getPrices(address[] memory _cTokens) public view returns (uint[] memory prices) {\n        prices = new uint[](_cTokens.length);\n        address oracleAddr = comp.oracle();\n\n        for (uint i = 0; i < _cTokens.length; ++i) {\n            prices[i] = CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokens[i]);\n        }\n    }\n\n    /// @notice Fetches Compound collateral factors for tokens\n    /// @param _cTokens Arr. of cTokens for which to get the coll. factors\n    /// @return collFactors Array of coll. factors\n    function getCollFactors(address[] memory _cTokens) public view returns (uint[] memory collFactors) {\n        collFactors = new uint[](_cTokens.length);\n\n        for (uint i = 0; i < _cTokens.length; ++i) {\n            (, collFactors[i]) = comp.markets(_cTokens[i]);\n        }\n    }\n\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in usd\n    /// @param _user Address of the user\n    /// @return data LoanData information\n    function getLoanData(address _user) public view returns (LoanData memory data) {\n        address[] memory assets = comp.getAssetsIn(_user);\n        address oracleAddr = comp.oracle();\n\n        data = LoanData({\n            user: _user,\n            ratio: 0,\n            collAddr: new address[](assets.length),\n            borrowAddr: new address[](assets.length),\n            collAmounts: new uint[](assets.length),\n            borrowAmounts: new uint[](assets.length)\n        });\n\n        uint collPos = 0;\n        uint borrowPos = 0;\n\n        for (uint i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n\n            Exp memory oraclePrice;\n\n            if (cTokenBalance != 0 || borrowBalance != 0) {\n                oraclePrice = Exp({mantissa: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(asset)});\n            }\n\n            // Sum up collateral in Usd\n            if (cTokenBalance != 0) {\n                Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n                (, Exp memory tokensToUsd) = mulExp(exchangeRate, oraclePrice);\n\n                data.collAddr[collPos] = asset;\n                (, data.collAmounts[collPos]) = mulScalarTruncate(tokensToUsd, cTokenBalance);\n                collPos++;\n            }\n\n            // Sum up debt in Usd\n            if (borrowBalance != 0) {\n                data.borrowAddr[borrowPos] = asset;\n                (, data.borrowAmounts[borrowPos]) = mulScalarTruncate(oraclePrice, borrowBalance);\n                borrowPos++;\n            }\n        }\n\n        data.ratio = uint128(getSafetyRatio(_user));\n\n        return data;\n    }\n\n    function getTokenBalances(address _user, address[] memory _cTokens) public view returns (uint[] memory balances, uint[] memory borrows) {\n        balances = new uint[](_cTokens.length);\n        borrows = new uint[](_cTokens.length);\n\n        for (uint i = 0; i < _cTokens.length; i++) {\n            address asset = _cTokens[i];\n\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n\n            Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n            (, balances[i]) = mulScalarTruncate(exchangeRate, cTokenBalance);\n\n            borrows[i] = borrowBalance;\n        }\n\n    }\n\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in usd\n    /// @param _users Addresses of the user\n    /// @return loans Array of LoanData information\n    function getLoanDataArr(address[] memory _users) public view returns (LoanData[] memory loans) {\n        loans = new LoanData[](_users.length);\n\n        for (uint i = 0; i < _users.length; ++i) {\n            loans[i] = getLoanData(_users[i]);\n        }\n    }\n\n    /// @notice Calcualted the ratio of coll/debt for a compound user\n    /// @param _users Addresses of the user\n    /// @return ratios Array of ratios\n    function getRatios(address[] memory _users) public view returns (uint[] memory ratios) {\n        ratios = new uint[](_users.length);\n\n        for (uint i = 0; i < _users.length; ++i) {\n            ratios[i] = getSafetyRatio(_users[i]);\n        }\n    }\n\n    /// @notice Information about cTokens\n    /// @param _cTokenAddresses Array of cTokens addresses\n    /// @return tokens Array of cTokens infomartion\n    function getTokensInfo(address[] memory _cTokenAddresses) public returns(TokenInfo[] memory tokens) {\n        tokens = new TokenInfo[](_cTokenAddresses.length);\n        address oracleAddr = comp.oracle();\n\n        for (uint i = 0; i < _cTokenAddresses.length; ++i) {\n            (, uint collFactor) = comp.markets(_cTokenAddresses[i]);\n\n            tokens[i] = TokenInfo({\n                cTokenAddress: _cTokenAddresses[i],\n                underlyingTokenAddress: getUnderlyingAddr(_cTokenAddresses[i]),\n                collateralFactor: collFactor,\n                price: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokenAddresses[i])\n            });\n        }\n    }\n\n    /// @notice Information about cTokens\n    /// @param _cTokenAddresses Array of cTokens addresses\n    /// @return tokens Array of cTokens infomartion\n    function getFullTokensInfo(address[] memory _cTokenAddresses) public returns(TokenInfoFull[] memory tokens) {\n        tokens = new TokenInfoFull[](_cTokenAddresses.length);\n        address oracleAddr = comp.oracle();\n\n        for (uint i = 0; i < _cTokenAddresses.length; ++i) {\n            (, uint collFactor) = comp.markets(_cTokenAddresses[i]);\n            CTokenInterface cToken = CTokenInterface(_cTokenAddresses[i]);\n\n            tokens[i] = TokenInfoFull({\n                underlyingTokenAddress: getUnderlyingAddr(_cTokenAddresses[i]),\n                supplyRate: cToken.supplyRatePerBlock(),\n                borrowRate: cToken.borrowRatePerBlock(),\n                exchangeRate: cToken.exchangeRateCurrent(),\n                marketLiquidity: cToken.getCash(),\n                totalSupply: cToken.totalSupply(),\n                totalBorrow: cToken.totalBorrowsCurrent(),\n                collateralFactor: collFactor,\n                price: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokenAddresses[i]),\n                borrowCap: comp.borrowCaps(_cTokenAddresses[i])\n            });\n        }\n    }\n\n    /// @notice Returns the underlying address of the cToken asset\n    /// @param _cTokenAddress cToken address\n    /// @return Token address of the cToken specified\n    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\n        if (_cTokenAddress == CETH_ADDRESS) {\n            return ETH_ADDRESS;\n        } else {\n            return CTokenInterface(_cTokenAddress).underlying();\n        }\n    }\n}\n"
489     },
490     "contracts/cream/import/CreamBorrowProxy.sol": {
491       "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../interfaces/ComptrollerInterface.sol\";\nimport \"../../utils/SafeERC20.sol\";\n\ncontract CreamBorrowProxy {\n\n    using SafeERC20 for ERC20;\n\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant COMPTROLLER_ADDR = 0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258;\n\n    function borrow(address _cCollToken, address _cBorrowToken, address _borrowToken, uint _amount) public {\n        address[] memory markets = new address[](2);\n        markets[0] = _cCollToken;\n        markets[1] = _cBorrowToken;\n\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\n\n        require(CTokenInterface(_cBorrowToken).borrow(_amount) == 0);\n\n        // withdraw funds to msg.sender\n        if (_borrowToken != ETH_ADDR) {\n            ERC20(_borrowToken).safeTransfer(msg.sender, ERC20(_borrowToken).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n}\n"
492     },
493     "contracts/cream/CreamSafetyRatio.sol": {
494       "content": "pragma solidity ^0.6.0;\n\nimport \"../DS/DSMath.sol\";\nimport \"../interfaces/CompoundOracleInterface.sol\";\nimport \"../interfaces/ComptrollerInterface.sol\";\nimport \"../interfaces/CTokenInterface.sol\";\nimport \"../compound/helpers/Exponential.sol\";\n\n\ncontract CreamSafetyRatio is Exponential, DSMath {\n    // solhint-disable-next-line const-name-snakecase\n    ComptrollerInterface public constant comp = ComptrollerInterface(0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258);\n\n    /// @notice Calcualted the ratio of debt / adjusted collateral\n    /// @param _user Address of the user\n    function getSafetyRatio(address _user) public view returns (uint) {\n        // For each asset the account is in\n        address[] memory assets = comp.getAssetsIn(_user);\n        address oracleAddr = comp.oracle();\n\n\n        uint sumCollateral = 0;\n        uint sumBorrow = 0;\n\n        for (uint i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n\n            Exp memory oraclePrice;\n\n            if (cTokenBalance != 0 || borrowBalance != 0) {\n                oraclePrice = Exp({mantissa: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(asset)});\n            }\n\n            // Sum up collateral in Eth\n            if (cTokenBalance != 0) {\n\n                (, uint collFactorMantissa) = comp.markets(address(asset));\n\n                Exp memory collateralFactor = Exp({mantissa: collFactorMantissa});\n                Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n\n                (, Exp memory tokensToEther) = mulExp3(collateralFactor, exchangeRate, oraclePrice);\n\n                (, sumCollateral) = mulScalarTruncateAddUInt(tokensToEther, cTokenBalance, sumCollateral);\n            }\n\n            // Sum up debt in Eth\n            if (borrowBalance != 0) {\n                (, sumBorrow) = mulScalarTruncateAddUInt(oraclePrice, borrowBalance, sumBorrow);\n            }\n        }\n\n        if (sumBorrow == 0) return uint(-1);\n\n        uint borrowPowerUsed = (sumBorrow * 10**18) / sumCollateral;\n        return wdiv(1e18, borrowPowerUsed);\n    }\n}\n"
495     },
496     "contracts/cream/CreamLoanInfo.sol": {
497       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./CreamSafetyRatio.sol\";\nimport \"./helpers/CreamSaverHelper.sol\";\n\n\n/// @title Gets data about cream positions\ncontract CreamLoanInfo is CreamSafetyRatio {\n\n    struct LoanData {\n        address user;\n        uint128 ratio;\n        address[] collAddr;\n        address[] borrowAddr;\n        uint[] collAmounts;\n        uint[] borrowAmounts;\n    }\n\n    struct TokenInfo {\n        address cTokenAddress;\n        address underlyingTokenAddress;\n        uint collateralFactor;\n        uint price;\n    }\n\n    struct TokenInfoFull {\n        address underlyingTokenAddress;\n        uint supplyRate;\n        uint borrowRate;\n        uint exchangeRate;\n        uint marketLiquidity;\n        uint totalSupply;\n        uint totalBorrow;\n        uint collateralFactor;\n        uint price;\n    }\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant CETH_ADDRESS = 0xD06527D5e56A3495252A528C4987003b712860eE;\n\n\n    /// @notice Calcualted the ratio of coll/debt for a cream user\n    /// @param _user Address of the user\n    function getRatio(address _user) public view returns (uint) {\n        // For each asset the account is in\n        return getSafetyRatio(_user);\n    }\n\n    /// @notice Fetches cream prices for tokens\n    /// @param _cTokens Arr. of cTokens for which to get the prices\n    /// @return prices Array of prices\n    function getPrices(address[] memory _cTokens) public view returns (uint[] memory prices) {\n        prices = new uint[](_cTokens.length);\n        address oracleAddr = comp.oracle();\n\n        for (uint i = 0; i < _cTokens.length; ++i) {\n            prices[i] = CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokens[i]);\n        }\n    }\n\n    /// @notice Fetches cream collateral factors for tokens\n    /// @param _cTokens Arr. of cTokens for which to get the coll. factors\n    /// @return collFactors Array of coll. factors\n    function getCollFactors(address[] memory _cTokens) public view returns (uint[] memory collFactors) {\n        collFactors = new uint[](_cTokens.length);\n\n        for (uint i = 0; i < _cTokens.length; ++i) {\n            (, collFactors[i]) = comp.markets(_cTokens[i]);\n        }\n    }\n\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in eth\n    /// @param _user Address of the user\n    /// @return data LoanData information\n    function getLoanData(address _user) public view returns (LoanData memory data) {\n        address[] memory assets = comp.getAssetsIn(_user);\n        address oracleAddr = comp.oracle();\n\n        data = LoanData({\n            user: _user,\n            ratio: 0,\n            collAddr: new address[](assets.length),\n            borrowAddr: new address[](assets.length),\n            collAmounts: new uint[](assets.length),\n            borrowAmounts: new uint[](assets.length)\n        });\n\n        uint collPos = 0;\n        uint borrowPos = 0;\n\n        for (uint i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n\n            Exp memory oraclePrice;\n\n            if (cTokenBalance != 0 || borrowBalance != 0) {\n                oraclePrice = Exp({mantissa: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(asset)});\n            }\n\n            // Sum up collateral in eth\n            if (cTokenBalance != 0) {\n                Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n                (, Exp memory tokensToEth) = mulExp(exchangeRate, oraclePrice);\n\n                data.collAddr[collPos] = asset;\n                (, data.collAmounts[collPos]) = mulScalarTruncate(tokensToEth, cTokenBalance);\n                collPos++;\n            }\n\n            // Sum up debt in eth\n            if (borrowBalance != 0) {\n                data.borrowAddr[borrowPos] = asset;\n                (, data.borrowAmounts[borrowPos]) = mulScalarTruncate(oraclePrice, borrowBalance);\n                borrowPos++;\n            }\n        }\n\n        data.ratio = uint128(getSafetyRatio(_user));\n\n        return data;\n    }\n\n    function getTokenBalances(address _user, address[] memory _cTokens) public view returns (uint[] memory balances, uint[] memory borrows) {\n        balances = new uint[](_cTokens.length);\n        borrows = new uint[](_cTokens.length);\n\n        for (uint i = 0; i < _cTokens.length; i++) {\n            address asset = _cTokens[i];\n\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n\n            Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n            (, balances[i]) = mulScalarTruncate(exchangeRate, cTokenBalance);\n\n            borrows[i] = borrowBalance;\n        }\n\n    }\n\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in eth\n    /// @param _users Addresses of the user\n    /// @return loans Array of LoanData information\n    function getLoanDataArr(address[] memory _users) public view returns (LoanData[] memory loans) {\n        loans = new LoanData[](_users.length);\n\n        for (uint i = 0; i < _users.length; ++i) {\n            loans[i] = getLoanData(_users[i]);\n        }\n    }\n\n    /// @notice Calcualted the ratio of coll/debt for a cream user\n    /// @param _users Addresses of the user\n    /// @return ratios Array of ratios\n    function getRatios(address[] memory _users) public view returns (uint[] memory ratios) {\n        ratios = new uint[](_users.length);\n\n        for (uint i = 0; i < _users.length; ++i) {\n            ratios[i] = getSafetyRatio(_users[i]);\n        }\n    }\n\n    /// @notice Information about cTokens\n    /// @param _cTokenAddresses Array of cTokens addresses\n    /// @return tokens Array of cTokens infomartion\n    function getTokensInfo(address[] memory _cTokenAddresses) public returns(TokenInfo[] memory tokens) {\n        tokens = new TokenInfo[](_cTokenAddresses.length);\n        address oracleAddr = comp.oracle();\n\n        for (uint i = 0; i < _cTokenAddresses.length; ++i) {\n            (, uint collFactor) = comp.markets(_cTokenAddresses[i]);\n\n            tokens[i] = TokenInfo({\n                cTokenAddress: _cTokenAddresses[i],\n                underlyingTokenAddress: getUnderlyingAddr(_cTokenAddresses[i]),\n                collateralFactor: collFactor,\n                price: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokenAddresses[i])\n            });\n        }\n    }\n\n    /// @notice Information about cTokens\n    /// @param _cTokenAddresses Array of cTokens addresses\n    /// @return tokens Array of cTokens infomartion\n    function getFullTokensInfo(address[] memory _cTokenAddresses) public returns(TokenInfoFull[] memory tokens) {\n        tokens = new TokenInfoFull[](_cTokenAddresses.length);\n        address oracleAddr = comp.oracle();\n\n        for (uint i = 0; i < _cTokenAddresses.length; ++i) {\n            (, uint collFactor) = comp.markets(_cTokenAddresses[i]);\n            CTokenInterface cToken = CTokenInterface(_cTokenAddresses[i]);\n\n            tokens[i] = TokenInfoFull({\n                underlyingTokenAddress: getUnderlyingAddr(_cTokenAddresses[i]),\n                supplyRate: cToken.supplyRatePerBlock(),\n                borrowRate: cToken.borrowRatePerBlock(),\n                exchangeRate: cToken.exchangeRateCurrent(),\n                marketLiquidity: cToken.getCash(),\n                totalSupply: cToken.totalSupply(),\n                totalBorrow: cToken.totalBorrowsCurrent(),\n                collateralFactor: collFactor,\n                price: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokenAddresses[i])\n            });\n        }\n    }\n\n    /// @notice Returns the underlying address of the cToken asset\n    /// @param _cTokenAddress cToken address\n    /// @return Token address of the cToken specified\n    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\n        if (_cTokenAddress == CETH_ADDRESS) {\n            return ETH_ADDRESS;\n        } else {\n            return CTokenInterface(_cTokenAddress).underlying();\n        }\n    }\n}\n"
498     },
499     "contracts/cream/CreamBasicProxy.sol": {
500       "content": "pragma solidity ^0.6.0;\n\nimport \"../utils/GasBurner.sol\";\nimport \"../utils/SafeERC20.sol\";\nimport \"../interfaces/CTokenInterface.sol\";\nimport \"../interfaces/CEtherInterface.sol\";\nimport \"../interfaces/ComptrollerInterface.sol\";\n\n/// @title Basic cream interactions through the DSProxy\ncontract CreamBasicProxy is GasBurner {\n\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant COMPTROLLER_ADDR = 0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258;\n\n    using SafeERC20 for ERC20;\n\n    /// @notice User deposits tokens to the cream protocol\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @param _tokenAddr The address of the token to be deposited\n    /// @param _cTokenAddr CTokens to be deposited\n    /// @param _amount Amount of tokens to be deposited\n    /// @param _inMarket True if the token is already in market for that address\n    function deposit(address _tokenAddr, address _cTokenAddr, uint _amount, bool _inMarket) public burnGas(5) payable {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\n        }\n\n        approveToken(_tokenAddr, _cTokenAddr);\n\n        if (!_inMarket) {\n            enterMarket(_cTokenAddr);\n        }\n\n        if (_tokenAddr != ETH_ADDR) {\n            require(CTokenInterface(_cTokenAddr).mint(_amount) == 0);\n        } else {\n            CEtherInterface(_cTokenAddr).mint{value: msg.value}(); // reverts on fail\n        }\n    }\n\n    /// @notice User withdraws tokens to the cream protocol\n    /// @param _tokenAddr The address of the token to be withdrawn\n    /// @param _cTokenAddr CTokens to be withdrawn\n    /// @param _amount Amount of tokens to be withdrawn\n    /// @param _isCAmount If true _amount is cTokens if falls _amount is underlying tokens\n    function withdraw(address _tokenAddr, address _cTokenAddr, uint _amount, bool _isCAmount) public burnGas(5) {\n\n        if (_isCAmount) {\n            require(CTokenInterface(_cTokenAddr).redeem(_amount) == 0);\n        } else {\n            require(CTokenInterface(_cTokenAddr).redeemUnderlying(_amount) == 0);\n        }\n\n        // withdraw funds to msg.sender\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n\n    }\n\n    /// @notice User borrows tokens to the cream protocol\n    /// @param _tokenAddr The address of the token to be borrowed\n    /// @param _cTokenAddr CTokens to be borrowed\n    /// @param _amount Amount of tokens to be borrowed\n    /// @param _inMarket True if the token is already in market for that address\n    function borrow(address _tokenAddr, address _cTokenAddr, uint _amount, bool _inMarket) public burnGas(8) {\n        if (!_inMarket) {\n            enterMarket(_cTokenAddr);\n        }\n\n        require(CTokenInterface(_cTokenAddr).borrow(_amount) == 0);\n\n        // withdraw funds to msg.sender\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @notice User paybacks tokens to the cream protocol\n    /// @param _tokenAddr The address of the token to be paybacked\n    /// @param _cTokenAddr CTokens to be paybacked\n    /// @param _amount Amount of tokens to be payedback\n    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt\n    function payback(address _tokenAddr, address _cTokenAddr, uint _amount, bool _wholeDebt) public burnGas(5) payable {\n        approveToken(_tokenAddr, _cTokenAddr);\n\n        if (_wholeDebt) {\n            _amount = CTokenInterface(_cTokenAddr).borrowBalanceCurrent(address(this));\n        }\n\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\n\n            require(CTokenInterface(_cTokenAddr).repayBorrow(_amount) == 0);\n        } else {\n            CEtherInterface(_cTokenAddr).repayBorrow{value: msg.value}();\n            msg.sender.transfer(address(this).balance); // send back the extra eth\n        }\n    }\n\n    /// @notice Helper method to withdraw tokens from the DSProxy\n    /// @param _tokenAddr Address of the token to be withdrawn\n    function withdrawTokens(address _tokenAddr) public {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Enters the cream market so it can be deposited/borrowed\n    /// @param _cTokenAddr CToken address of the token\n    function enterMarket(address _cTokenAddr) public {\n        address[] memory markets = new address[](1);\n        markets[0] = _cTokenAddr;\n\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\n    }\n\n    /// @notice Exits the cream market so it can't be deposited/borrowed\n    /// @param _cTokenAddr CToken address of the token\n    function exitMarket(address _cTokenAddr) public {\n        ComptrollerInterface(COMPTROLLER_ADDR).exitMarket(_cTokenAddr);\n    }\n\n    /// @notice Approves CToken contract to pull underlying tokens from the DSProxy\n    /// @param _tokenAddr Token we are trying to approve\n    /// @param _cTokenAddr Address which will gain the approval\n    function approveToken(address _tokenAddr, address _cTokenAddr) internal {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeApprove(_cTokenAddr, uint(-1));\n        }\n    }\n}\n"
501     },
502     "contracts/compound/CompoundBasicProxy.sol": {
503       "content": "pragma solidity ^0.6.0;\n\nimport \"../utils/GasBurner.sol\";\nimport \"../utils/SafeERC20.sol\";\nimport \"../interfaces/CTokenInterface.sol\";\nimport \"../interfaces/CEtherInterface.sol\";\nimport \"../interfaces/ComptrollerInterface.sol\";\n\n/// @title Basic compound interactions through the DSProxy\ncontract CompoundBasicProxy is GasBurner {\n\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant COMPTROLLER_ADDR = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    using SafeERC20 for ERC20;\n\n    /// @notice User deposits tokens to the Compound protocol\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @param _tokenAddr The address of the token to be deposited\n    /// @param _cTokenAddr CTokens to be deposited\n    /// @param _amount Amount of tokens to be deposited\n    /// @param _inMarket True if the token is already in market for that address\n    function deposit(address _tokenAddr, address _cTokenAddr, uint _amount, bool _inMarket) public burnGas(5) payable {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\n        }\n\n        approveToken(_tokenAddr, _cTokenAddr);\n\n        if (!_inMarket) {\n            enterMarket(_cTokenAddr);\n        }\n\n        if (_tokenAddr != ETH_ADDR) {\n            require(CTokenInterface(_cTokenAddr).mint(_amount) == 0);\n        } else {\n            CEtherInterface(_cTokenAddr).mint{value: msg.value}(); // reverts on fail\n        }\n    }\n\n    /// @notice User withdraws tokens to the Compound protocol\n    /// @param _tokenAddr The address of the token to be withdrawn\n    /// @param _cTokenAddr CTokens to be withdrawn\n    /// @param _amount Amount of tokens to be withdrawn\n    /// @param _isCAmount If true _amount is cTokens if falls _amount is underlying tokens\n    function withdraw(address _tokenAddr, address _cTokenAddr, uint _amount, bool _isCAmount) public burnGas(5) {\n\n        if (_isCAmount) {\n            require(CTokenInterface(_cTokenAddr).redeem(_amount) == 0);\n        } else {\n            require(CTokenInterface(_cTokenAddr).redeemUnderlying(_amount) == 0);\n        }\n\n        // withdraw funds to msg.sender\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n\n    }\n\n    /// @notice User borrows tokens to the Compound protocol\n    /// @param _tokenAddr The address of the token to be borrowed\n    /// @param _cTokenAddr CTokens to be borrowed\n    /// @param _amount Amount of tokens to be borrowed\n    /// @param _inMarket True if the token is already in market for that address\n    function borrow(address _tokenAddr, address _cTokenAddr, uint _amount, bool _inMarket) public burnGas(8) {\n        if (!_inMarket) {\n            enterMarket(_cTokenAddr);\n        }\n\n        require(CTokenInterface(_cTokenAddr).borrow(_amount) == 0);\n\n        // withdraw funds to msg.sender\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @notice User paybacks tokens to the Compound protocol\n    /// @param _tokenAddr The address of the token to be paybacked\n    /// @param _cTokenAddr CTokens to be paybacked\n    /// @param _amount Amount of tokens to be payedback\n    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt\n    function payback(address _tokenAddr, address _cTokenAddr, uint _amount, bool _wholeDebt) public burnGas(5) payable {\n        approveToken(_tokenAddr, _cTokenAddr);\n\n        if (_wholeDebt) {\n            _amount = CTokenInterface(_cTokenAddr).borrowBalanceCurrent(address(this));\n        }\n\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\n\n            require(CTokenInterface(_cTokenAddr).repayBorrow(_amount) == 0);\n        } else {\n            CEtherInterface(_cTokenAddr).repayBorrow{value: msg.value}();\n            msg.sender.transfer(address(this).balance); // send back the extra eth\n        }\n    }\n\n    /// @notice Helper method to withdraw tokens from the DSProxy\n    /// @param _tokenAddr Address of the token to be withdrawn\n    function withdrawTokens(address _tokenAddr) public {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Enters the Compound market so it can be deposited/borrowed\n    /// @param _cTokenAddr CToken address of the token\n    function enterMarket(address _cTokenAddr) public {\n        address[] memory markets = new address[](1);\n        markets[0] = _cTokenAddr;\n\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\n    }\n\n    /// @notice Exits the Compound market so it can't be deposited/borrowed\n    /// @param _cTokenAddr CToken address of the token\n    function exitMarket(address _cTokenAddr) public {\n        ComptrollerInterface(COMPTROLLER_ADDR).exitMarket(_cTokenAddr);\n    }\n\n    /// @notice Approves CToken contract to pull underlying tokens from the DSProxy\n    /// @param _tokenAddr Token we are trying to approve\n    /// @param _cTokenAddr Address which will gain the approval\n    function approveToken(address _tokenAddr, address _cTokenAddr) internal {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeApprove(_cTokenAddr, uint(-1));\n        }\n    }\n}\n"
504     },
505     "contracts/compound/comp/CompLeverage.sol": {
506       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./CompBalance.sol\";\nimport \"../../exchangeV3/DFSExchangeCore.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../interfaces/DSProxyInterface.sol\";\nimport \"../CompoundBasicProxy.sol\";\n\ncontract CompLeverage is DFSExchangeCore, CompBalance {\n    address public constant C_COMP_ADDR = 0x70e36f6BF80a52b3B46b3aF8e106CC0ed743E8e4;\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant CETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n    address public constant COMPTROLLER_ADDR = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\n\n    /// @notice Should claim COMP and sell it to the specified token and deposit it back\n    /// @param exchangeData Standard Exchange struct\n    /// @param _cTokensSupply List of cTokens user is supplying\n    /// @param _cTokensBorrow List of cTokens user is borrowing\n    /// @param _cDepositAddr The cToken address of the asset you want to deposit\n    /// @param _inMarket Flag if the cToken is used as collateral\n    function claimAndSell(\n        ExchangeData memory exchangeData,\n        address[] memory _cTokensSupply,\n        address[] memory _cTokensBorrow,\n        address _cDepositAddr,\n        bool _inMarket\n    ) public payable {\n        // Claim COMP token\n        _claim(address(this), _cTokensSupply, _cTokensBorrow);\n\n        uint compBalance = ERC20(COMP_ADDR).balanceOf(address(this));\n        uint depositAmount = 0;\n\n        // Exchange COMP\n        if (exchangeData.srcAddr != address(0)) {\n            exchangeData.user = msg.sender;\n            exchangeData.dfsFeeDivider = 400; // 0.25%\n            exchangeData.srcAmount = compBalance;\n\n            (, depositAmount) = _sell(exchangeData);\n\n            // if we have no deposit after, send back tokens to the user\n            if (_cDepositAddr == address(0)) {\n                if (exchangeData.destAddr != ETH_ADDRESS) {\n                    ERC20(exchangeData.destAddr).safeTransfer(msg.sender, depositAmount);\n                } else {\n                    msg.sender.transfer(address(this).balance);\n                }\n            }\n        }\n\n        // Deposit back a token\n        if (_cDepositAddr != address(0)) {\n            // if we are just depositing COMP without a swap\n            if (_cDepositAddr == C_COMP_ADDR) {\n                depositAmount = compBalance;\n            }\n\n            address tokenAddr = getUnderlyingAddr(_cDepositAddr);\n            deposit(tokenAddr, _cDepositAddr, depositAmount, _inMarket);\n        }\n\n        logger.Log(address(this), msg.sender, \"CompLeverage\", abi.encode(compBalance, depositAmount, _cDepositAddr, exchangeData.destAmount));\n    }\n\n    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\n        if (_cTokenAddress == CETH_ADDRESS) {\n            return ETH_ADDRESS;\n        } else {\n            return CTokenInterface(_cTokenAddress).underlying();\n        }\n    }\n\n    function deposit(address _tokenAddr, address _cTokenAddr, uint _amount, bool _inMarket) public burnGas(5) payable {\n        approveToken(_tokenAddr, _cTokenAddr);\n\n        if (!_inMarket) {\n            enterMarket(_cTokenAddr);\n        }\n\n        if (_tokenAddr != ETH_ADDRESS) {\n            require(CTokenInterface(_cTokenAddr).mint(_amount) == 0);\n        } else {\n            CEtherInterface(_cTokenAddr).mint{value: _amount}(); // reverts on fail\n        }\n    }\n\n     function enterMarket(address _cTokenAddr) public {\n        address[] memory markets = new address[](1);\n        markets[0] = _cTokenAddr;\n\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\n    }\n\n    function approveToken(address _tokenAddr, address _cTokenAddr) internal {\n        if (_tokenAddr != ETH_ADDRESS) {\n            ERC20(_tokenAddr).safeApprove(_cTokenAddr, uint(-1));\n        }\n    }\n}\n"
507     },
508     "contracts/compound/comp/CompBalance.sol": {
509       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../helpers/Exponential.sol\";\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../utils/GasBurner.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../interfaces/ComptrollerInterface.sol\";\n\ncontract CompBalance is Exponential, GasBurner {\n    ComptrollerInterface public constant comp = ComptrollerInterface(\n        0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B\n    );\n    address public constant COMP_ADDR = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n    uint224 public constant compInitialIndex = 1e36;\n\n    function claimComp(\n        address _user,\n        address[] memory _cTokensSupply,\n        address[] memory _cTokensBorrow\n    ) public burnGas(8) {\n        _claim(_user, _cTokensSupply, _cTokensBorrow);\n\n        ERC20(COMP_ADDR).transfer(msg.sender, ERC20(COMP_ADDR).balanceOf(address(this)));\n    }\n\n    function _claim(\n        address _user,\n        address[] memory _cTokensSupply,\n        address[] memory _cTokensBorrow\n    ) internal {\n        address[] memory u = new address[](1);\n        u[0] = _user;\n\n        comp.claimComp(u, _cTokensSupply, false, true);\n        comp.claimComp(u, _cTokensBorrow, true, false);\n    }\n\n    function getBalance(address _user, address[] memory _cTokens) public view returns (uint256) {\n        uint256 compBalance = 0;\n\n        for (uint256 i = 0; i < _cTokens.length; ++i) {\n            compBalance += getSuppyBalance(_cTokens[i], _user);\n            compBalance += getBorrowBalance(_cTokens[i], _user);\n        }\n\n        compBalance = add_(comp.compAccrued(_user), compBalance);\n\n        compBalance += ERC20(COMP_ADDR).balanceOf(_user);\n\n        return compBalance;\n    }\n\n    function getClaimableAssets(address[] memory _cTokens, address _user)\n        public\n        view\n        returns (bool[] memory supplyClaims, bool[] memory borrowClaims)\n    {\n        supplyClaims = new bool[](_cTokens.length);\n        borrowClaims = new bool[](_cTokens.length);\n\n        for (uint256 i = 0; i < _cTokens.length; ++i) {\n            supplyClaims[i] = getSuppyBalance(_cTokens[i], _user) > 0;\n            borrowClaims[i] = getBorrowBalance(_cTokens[i], _user) > 0;\n        }\n    }\n\n    function getSuppyBalance(address _cToken, address _supplier)\n        public\n        view\n        returns (uint256 supplierAccrued)\n    {\n        ComptrollerInterface.CompMarketState memory supplyState = comp.compSupplyState(_cToken);\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\n        Double memory supplierIndex = Double({\n            mantissa: comp.compSupplierIndex(_cToken, _supplier)\n        });\n\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n            supplierIndex.mantissa = compInitialIndex;\n        }\n\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n        uint256 supplierTokens = CTokenInterface(_cToken).balanceOf(_supplier);\n        uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\n        supplierAccrued = supplierDelta;\n    }\n\n    function getBorrowBalance(address _cToken, address _borrower)\n        public\n        view\n        returns (uint256 borrowerAccrued)\n    {\n        ComptrollerInterface.CompMarketState memory borrowState = comp.compBorrowState(_cToken);\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\n        Double memory borrowerIndex = Double({\n            mantissa: comp.compBorrowerIndex(_cToken, _borrower)\n        });\n\n        Exp memory marketBorrowIndex = Exp({mantissa: CTokenInterface(_cToken).borrowIndex()});\n\n        if (borrowerIndex.mantissa > 0) {\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n            uint256 borrowerAmount = div_(\n                CTokenInterface(_cToken).borrowBalanceStored(_borrower),\n                marketBorrowIndex\n            );\n            uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);\n            borrowerAccrued = borrowerDelta;\n        }\n    }\n}\n"
510     },
511     "contracts/compound/import/CompoundBorrowProxy.sol": {
512       "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/ERC20.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../interfaces/ComptrollerInterface.sol\";\nimport \"../../utils/SafeERC20.sol\";\n\ncontract CompoundBorrowProxy {\n\n    using SafeERC20 for ERC20;\n\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant COMPTROLLER_ADDR = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    function borrow(address _cCollToken, address _cBorrowToken, address _borrowToken, uint _amount) public {\n        address[] memory markets = new address[](2);\n        markets[0] = _cCollToken;\n        markets[1] = _cBorrowToken;\n\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\n\n        require(CTokenInterface(_cBorrowToken).borrow(_amount) == 0);\n\n        // withdraw funds to msg.sender\n        if (_borrowToken != ETH_ADDR) {\n            ERC20(_borrowToken).safeTransfer(msg.sender, ERC20(_borrowToken).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n}\n"
513     },
514     "contracts/exchange/AllowanceProxy.sol": {
515       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../auth/AdminAuth.sol\";\nimport \"./SaverExchange.sol\";\nimport \"../utils/SafeERC20.sol\";\n\ncontract AllowanceProxy is AdminAuth {\n\n    using SafeERC20 for ERC20;\n\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // TODO: Real saver exchange address\n    SaverExchange saverExchange = SaverExchange(0x235abFAd01eb1BDa28Ef94087FBAA63E18074926);\n\n    function callSell(SaverExchangeCore.ExchangeData memory exData) public payable {\n        pullAndSendTokens(exData.srcAddr, exData.srcAmount);\n\n        saverExchange.sell{value: msg.value}(exData, msg.sender);\n    }\n\n    function callBuy(SaverExchangeCore.ExchangeData memory exData) public payable {\n        pullAndSendTokens(exData.srcAddr, exData.srcAmount);\n\n        saverExchange.buy{value: msg.value}(exData, msg.sender);\n    }\n\n    function pullAndSendTokens(address _tokenAddr, uint _amount) internal {\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\n            require(msg.value >= _amount, \"msg.value smaller than amount\");\n        } else {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(saverExchange), _amount);\n        }\n    }\n\n    function ownerChangeExchange(address payable _newExchange) public onlyOwner {\n        saverExchange = SaverExchange(_newExchange);\n    }\n}\n"
516     },
517     "contracts/cream/saver/CreamSaverProxy.sol": {
518       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../exchange/SaverExchangeCore.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../helpers/CreamSaverHelper.sol\";\n\n/// @title Contract that implements repay/boost functionality\ncontract CreamSaverProxy is CreamSaverHelper, SaverExchangeCore {\n\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\n\n    /// @notice Withdraws collateral, converts to borrowed token and repays debt\n    /// @dev Called through the DSProxy\n    /// @param _exData Exchange data\n    /// @param _cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    function repay(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost\n    ) public payable {\n        enterMarket(_cAddresses[0], _cAddresses[1]);\n\n        address payable user = payable(getUserAddress());\n\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\n\n        uint collAmount = (_exData.srcAmount > maxColl) ? maxColl : _exData.srcAmount;\n\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(collAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            (, swapAmount) = _sell(_exData);\n            swapAmount -= getFee(swapAmount, user, _gasCost, _cAddresses[1]);\n        } else {\n            swapAmount = collAmount;\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        }\n\n        paybackDebt(swapAmount, _cAddresses[1], borrowToken, user);\n\n        // handle 0x fee\n        tx.origin.transfer(address(this).balance);\n\n        // log amount, collToken, borrowToken\n        logger.Log(address(this), msg.sender, \"CreamRepay\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\n    }\n\n    /// @notice Borrows token, converts to collateral, and adds to position\n    /// @dev Called through the DSProxy\n    /// @param _exData Exchange data\n    /// @param _cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    function boost(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost\n    ) public payable {\n        enterMarket(_cAddresses[0], _cAddresses[1]);\n\n        address payable user = payable(getUserAddress());\n\n        uint maxBorrow = getMaxBorrow(_cAddresses[1], address(this));\n        uint borrowAmount = (_exData.srcAmount > maxBorrow) ? maxBorrow : _exData.srcAmount;\n\n        require(CTokenInterface(_cAddresses[1]).borrow(borrowAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            borrowAmount -= getFee(borrowAmount, user, _gasCost, _cAddresses[1]);\n\n            _exData.srcAmount = borrowAmount;\n            (,swapAmount) = _sell(_exData);\n        } else {\n            swapAmount = borrowAmount;\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        }\n\n        approveCToken(collToken, _cAddresses[0]);\n\n        if (collToken != ETH_ADDRESS) {\n            require(CTokenInterface(_cAddresses[0]).mint(swapAmount) == 0);\n        } else {\n            CEtherInterface(_cAddresses[0]).mint{value: swapAmount}(); // reverts on fail\n        }\n\n        // handle 0x fee\n        tx.origin.transfer(address(this).balance);\n\n        // log amount, collToken, borrowToken\n        logger.Log(address(this), msg.sender, \"CreamBoost\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\n    }\n\n}\n"
519     },
520     "contracts/cream/saver/CreamFlashLoanTaker.sol": {
521       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/GasBurner.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"./CreamSaverProxy.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../auth/ProxyPermission.sol\";\n\n/// @title Entry point for the FL Repay Boosts, called by DSProxy\ncontract CreamFlashLoanTaker is CreamSaverProxy, ProxyPermission, GasBurner {\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    address payable public constant COMPOUND_SAVER_FLASH_LOAN = 0x3ceD2067c0B057611e4E2686Dbe40028962Cc625;\n    address public constant AAVE_POOL_CORE = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n\n    /// @notice Repays the position with it's own fund or with FL if needed\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    function repayWithLoan(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost\n    ) public payable burnGas(25) {\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\n        uint availableLiquidity = getAvailableLiquidity(_exData.srcAddr);\n\n        if (_exData.srcAmount <= maxColl || availableLiquidity == 0) {\n            repay(_exData, _cAddresses, _gasCost);\n        } else {\n            // 0x fee\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\n\n            uint loanAmount = (_exData.srcAmount - maxColl);\n            bytes memory encoded = packExchangeData(_exData);\n            bytes memory paramsData = abi.encode(encoded, _cAddresses, _gasCost, true, address(this));\n\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_cAddresses[0]), loanAmount, paramsData);\n\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            logger.Log(address(this), msg.sender, \"CreamFlashRepay\", abi.encode(loanAmount, _exData.srcAmount, _cAddresses[0]));\n        }\n    }\n\n    /// @notice Boosts the position with it's own fund or with FL if needed\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    function boostWithLoan(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost\n    ) public payable burnGas(20) {\n        uint maxBorrow = getMaxBorrow(_cAddresses[1], address(this));\n        uint availableLiquidity = getAvailableLiquidity(_exData.srcAddr);\n\n        if (_exData.srcAmount <= maxBorrow || availableLiquidity == 0) {\n            boost(_exData, _cAddresses, _gasCost);\n        } else {\n            // 0x fee\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\n\n            uint loanAmount = (_exData.srcAmount - maxBorrow);\n            bytes memory paramsData = abi.encode(packExchangeData(_exData), _cAddresses, _gasCost, false, address(this));\n\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_cAddresses[1]), loanAmount, paramsData);\n\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            logger.Log(address(this), msg.sender, \"CreamFlashBoost\", abi.encode(loanAmount, _exData.srcAmount, _cAddresses[1]));\n        }\n\n    }\n\n    function getAvailableLiquidity(address _tokenAddr) internal view returns (uint liquidity) {\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\n            liquidity = AAVE_POOL_CORE.balance;\n        } else {\n            liquidity = ERC20(_tokenAddr).balanceOf(AAVE_POOL_CORE);\n        }\n    }\n}\n"
522     },
523     "contracts/compound/saver/CompoundFlashLoanTaker.sol": {
524       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/GasBurner.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"./CompoundSaverProxy.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../auth/ProxyPermission.sol\";\n\n/// @title Entry point for the FL Repay Boosts, called by DSProxy\ncontract CompoundFlashLoanTaker is CompoundSaverProxy, ProxyPermission, GasBurner {\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    address payable public constant COMPOUND_SAVER_FLASH_LOAN = 0xeb76a0479F9C7d2ED3A8D376B91E7ea109fb1BBc;\n    address public constant AAVE_POOL_CORE = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n\n    /// @notice Repays the position with it's own fund or with FL if needed\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    function repayWithLoan(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost\n    ) public payable burnGas(25) {\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\n        uint availableLiquidity = getAvailableLiquidity(_exData.srcAddr);\n\n        if (_exData.srcAmount <= maxColl || availableLiquidity == 0) {\n            repay(_exData, _cAddresses, _gasCost);\n        } else {\n            // 0x fee\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\n\n            uint loanAmount = (_exData.srcAmount - maxColl);\n            if (loanAmount > availableLiquidity) loanAmount = availableLiquidity;\n            bytes memory encoded = packExchangeData(_exData);\n            bytes memory paramsData = abi.encode(encoded, _cAddresses, _gasCost, true, address(this));\n\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_cAddresses[0]), loanAmount, paramsData);\n\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            logger.Log(address(this), msg.sender, \"CompoundFlashRepay\", abi.encode(loanAmount, _exData.srcAmount, _cAddresses[0]));\n        }\n    }\n\n    /// @notice Boosts the position with it's own fund or with FL if needed\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    function boostWithLoan(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost\n    ) public payable burnGas(20) {\n        uint maxBorrow = getMaxBorrow(_cAddresses[1], address(this));\n        uint availableLiquidity = getAvailableLiquidity(_exData.srcAddr);\n\n        if (_exData.srcAmount <= maxBorrow || availableLiquidity == 0) {\n            boost(_exData, _cAddresses, _gasCost);\n        } else {\n            // 0x fee\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\n\n            uint loanAmount = (_exData.srcAmount - maxBorrow);\n            if (loanAmount > availableLiquidity) loanAmount = availableLiquidity;\n            bytes memory paramsData = abi.encode(packExchangeData(_exData), _cAddresses, _gasCost, false, address(this));\n\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_cAddresses[1]), loanAmount, paramsData);\n\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            logger.Log(address(this), msg.sender, \"CompoundFlashBoost\", abi.encode(loanAmount, _exData.srcAmount, _cAddresses[1]));\n        }\n\n    }\n\n    function getAvailableLiquidity(address _tokenAddr) internal view returns (uint liquidity) {\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\n            liquidity = AAVE_POOL_CORE.balance;\n        } else {\n            liquidity = ERC20(_tokenAddr).balanceOf(AAVE_POOL_CORE);\n        }\n    }\n}\n"
525     },
526     "contracts/compound/saver/CompoundSaverProxy.sol": {
527       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../exchangeV3/DFSExchangeCore.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../helpers/CompoundSaverHelper.sol\";\n\n/// @title Contract that implements repay/boost functionality\ncontract CompoundSaverProxy is CompoundSaverHelper, DFSExchangeCore {\n\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\n\n    /// @notice Withdraws collateral, converts to borrowed token and repays debt\n    /// @dev Called through the DSProxy\n    /// @param _exData Exchange data\n    /// @param _cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    function repay(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost\n    ) public payable {\n        enterMarket(_cAddresses[0], _cAddresses[1]);\n\n        address payable user = payable(getUserAddress());\n\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\n\n        uint collAmount = (_exData.srcAmount > maxColl) ? maxColl : _exData.srcAmount;\n\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(collAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            _exData.srcAmount = collAmount;\n            _exData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\n            _exData.user = user;\n\n            (, swapAmount) = _sell(_exData);\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        } else {\n            swapAmount = collAmount;\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        }\n\n        paybackDebt(swapAmount, _cAddresses[1], borrowToken, user);\n\n        // handle 0x fee\n        tx.origin.transfer(address(this).balance);\n\n        // log amount, collToken, borrowToken\n        logger.Log(address(this), msg.sender, \"CompoundRepay\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\n    }\n\n    /// @notice Borrows token, converts to collateral, and adds to position\n    /// @dev Called through the DSProxy\n    /// @param _exData Exchange data\n    /// @param _cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    function boost(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost\n    ) public payable {\n        enterMarket(_cAddresses[0], _cAddresses[1]);\n\n        address payable user = payable(getUserAddress());\n\n        uint maxBorrow = getMaxBorrow(_cAddresses[1], address(this));\n        uint borrowAmount = (_exData.srcAmount > maxBorrow) ? maxBorrow : _exData.srcAmount;\n\n        require(CTokenInterface(_cAddresses[1]).borrow(borrowAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            _exData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\n            _exData.user = user;\n\n            _exData.srcAmount = borrowAmount;\n            (, swapAmount) = _sell(_exData);\n\n             swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        } else {\n            swapAmount = borrowAmount;\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        }\n\n        approveCToken(collToken, _cAddresses[0]);\n\n        if (collToken != ETH_ADDRESS) {\n            require(CTokenInterface(_cAddresses[0]).mint(swapAmount) == 0);\n        } else {\n            CEtherInterface(_cAddresses[0]).mint{value: swapAmount}(); // reverts on fail\n        }\n\n        // handle 0x fee\n        tx.origin.transfer(address(this).balance);\n\n        // log amount, collToken, borrowToken\n        logger.Log(address(this), msg.sender, \"CompoundBoost\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\n    }\n\n}\n"
528     },
529     "contracts/compound/import/CompoundImportTaker.sol": {
530       "content": "pragma solidity ^0.6.0;\n\nimport \"../../utils/GasBurner.sol\";\nimport \"../../auth/ProxyPermission.sol\";\n\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../interfaces/ProxyRegistryInterface.sol\";\n\nimport \"../helpers/CompoundSaverHelper.sol\";\n\n/// @title Imports Compound position from the account to DSProxy\ncontract CompoundImportTaker is CompoundSaverHelper, ProxyPermission, GasBurner {\n\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    address payable public constant COMPOUND_IMPORT_FLASH_LOAN = 0x2634e5D477B80B4578dADC2962336929B5E9Ee3A;\n    address public constant PROXY_REGISTRY_ADDRESS = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\n\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\n\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\n    /// @dev User must approve DSProxy to pull _cCollateralToken\n    /// @param _cCollateralToken Collateral we are moving to DSProxy\n    /// @param _cBorrowToken Borrow token we are moving to DSProxy\n    function importLoan(address _cCollateralToken, address _cBorrowToken) external burnGas(20) {\n        uint loanAmount = CTokenInterface(_cBorrowToken).borrowBalanceCurrent(msg.sender);\n        bytes memory paramsData = abi.encode(_cCollateralToken, _cBorrowToken, address(this));\n\n        givePermission(COMPOUND_IMPORT_FLASH_LOAN);\n\n        lendingPool.flashLoan(COMPOUND_IMPORT_FLASH_LOAN, getUnderlyingAddr(_cBorrowToken), loanAmount, paramsData);\n\n        removePermission(COMPOUND_IMPORT_FLASH_LOAN);\n\n        logger.Log(address(this), msg.sender, \"CompoundImport\", abi.encode(loanAmount, 0, _cCollateralToken));\n    }\n}\n"
531     },
532     "contracts/compound/automatic/CompoundSubscriptionsProxy.sol": {
533       "content": "pragma solidity ^0.6.0;\n\nimport \"../../auth/ProxyPermission.sol\";\nimport \"../../interfaces/ICompoundSubscription.sol\";\n\n/// @title SubscriptionsProxy handles authorization and interaction with the Subscriptions contract\ncontract CompoundSubscriptionsProxy is ProxyPermission {\n\n    address public constant COMPOUND_SUBSCRIPTION_ADDRESS = 0x52015EFFD577E08f498a0CCc11905925D58D6207;\n    address public constant COMPOUND_MONITOR_PROXY = 0xB1cF8DE8e791E4Ed1Bd86c03E2fc1f14389Cb10a;\n\n    /// @notice Calls subscription contract and creates a DSGuard if non existent\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalRatioBoost Ratio amount which boost should target\n    /// @param _optimalRatioRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    function subscribe(\n        uint128 _minRatio,\n        uint128 _maxRatio,\n        uint128 _optimalRatioBoost,\n        uint128 _optimalRatioRepay,\n        bool _boostEnabled\n    ) public {\n        givePermission(COMPOUND_MONITOR_PROXY);\n        ICompoundSubscription(COMPOUND_SUBSCRIPTION_ADDRESS).subscribe(\n            _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\n    }\n\n    /// @notice Calls subscription contract and updated existing parameters\n    /// @dev If subscription is non existent this will create one\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalRatioBoost Ratio amount which boost should target\n    /// @param _optimalRatioRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    function update(\n        uint128 _minRatio,\n        uint128 _maxRatio,\n        uint128 _optimalRatioBoost,\n        uint128 _optimalRatioRepay,\n        bool _boostEnabled\n    ) public {\n        ICompoundSubscription(COMPOUND_SUBSCRIPTION_ADDRESS).subscribe(_minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\n    }\n\n    /// @notice Calls the subscription contract to unsubscribe the caller\n    function unsubscribe() public {\n        removePermission(COMPOUND_MONITOR_PROXY);\n        ICompoundSubscription(COMPOUND_SUBSCRIPTION_ADDRESS).unsubscribe();\n    }\n}\n"
534     },
535     "contracts/interfaces/ICompoundSubscription.sol": {
536       "content": "pragma solidity ^0.6.0;\n\nabstract contract ICompoundSubscription {\n    function subscribe(uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled) public virtual;\n    function unsubscribe() public virtual;\n}\n"
537     },
538     "contracts/aaveV2/saver/AaveSaverTakerV2.sol": {
539       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/GasBurner.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../../auth/ProxyPermission.sol\";\nimport \"../../utils/DydxFlashLoanBase.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../interfaces/ProxyRegistryInterface.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\nimport \"../../interfaces/ERC20.sol\";\nimport \"../../exchangeV3/DFSExchangeData.sol\";\n\n/// @title Import Aave position from account to wallet\n/// @dev Contract needs to have enough wei in WETH for all transactions (2 WETH wei per transaction)\ncontract AaveSaverTakerV2 is DydxFlashLoanBase, ProxyPermission, GasBurner, DFSExchangeData {\n\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address payable public constant AAVE_RECEIVER = 0x5a7689F1452d57E92878e0c0Be47cA3525e8Fcc9;\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n    address public constant PROXY_REGISTRY_ADDRESS = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\n\n    function repay(address _market, ExchangeData memory _data, uint _rateMode, uint256 _gasCost, uint _flAmount) public payable {\n        _flashLoan(_market, _data, _rateMode,_gasCost, true, _flAmount);\n    }\n\n    function boost(address _market, ExchangeData memory _data, uint _rateMode, uint256 _gasCost, uint _flAmount) public payable {\n        _flashLoan(_market, _data, _rateMode, _gasCost, false, _flAmount);\n    }\n\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\n    /// @dev User must send 2 wei with this transaction\n    function _flashLoan(address _market, ExchangeData memory _data, uint _rateMode, uint _gasCost, bool _isRepay, uint _flAmount) internal {\n        ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\n\n        uint256 ethAmount = _flAmount;\n\n        // Get marketId from token address\n        uint256 marketId = _getMarketIdFromTokenAddress(WETH_ADDR);\n\n        // Calculate repay amount (_amount + (2 wei))\n        // Approve transfer from\n        uint256 repayAmount = _getRepaymentAmountInternal(ethAmount);\n        ERC20(WETH_ADDR).approve(SOLO_MARGIN_ADDRESS, repayAmount);\n\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\n\n        operations[0] = _getWithdrawAction(marketId, ethAmount, AAVE_RECEIVER);\n        AAVE_RECEIVER.transfer(msg.value);\n        bytes memory encodedData = packExchangeData(_data);\n        operations[1] = _getCallAction(\n            abi.encode(encodedData, _market, _rateMode, _gasCost, _isRepay, ethAmount, msg.value, proxyOwner(), address(this)),\n            AAVE_RECEIVER\n        );\n        operations[2] = _getDepositAction(marketId, repayAmount, address(this));\n\n        Account.Info[] memory accountInfos = new Account.Info[](1);\n        accountInfos[0] = _getAccountInfo();\n\n        givePermission(AAVE_RECEIVER);\n        solo.operate(accountInfos, operations);\n        removePermission(AAVE_RECEIVER);\n    }\n}\n"
540     },
541     "contracts/aaveV2/import/AaveImportTakerV2.sol": {
542       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/GasBurner.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../../auth/ProxyPermission.sol\";\nimport \"../../utils/DydxFlashLoanBase.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../interfaces/ProxyRegistryInterface.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\nimport \"../../interfaces/ERC20.sol\";\n\n\n/// @title Import Aave position from account to wallet\n/// @dev Contract needs to have enough wei in WETH for all transactions (2 WETH wei per transaction)\ncontract AaveImportTakerV2 is DydxFlashLoanBase, ProxyPermission {\n\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    address payable public constant AAVE_IMPORT = 0x1C9B7FBD410Adcd213C5d6CBA12e651300061eaD;\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n    address public constant PROXY_REGISTRY_ADDRESS = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\n\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\n    /// @dev User must send 2 wei with this transaction\n    /// @dev User must approve DSProxy to pull _aCollateralToken\n    /// @param _market Market in which we want to import\n    /// @param _collateralToken Collateral token we are moving to DSProxy\n    /// @param _borrowToken Borrow token we are moving to DSProxy\n    /// @param _ethAmount ETH amount that needs to be pulled from dydx\n    function importLoan(address _market, address _collateralToken, address _borrowToken, uint _ethAmount) public {\n        ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\n\n        // Get marketId from token address\n        uint256 marketId = _getMarketIdFromTokenAddress(WETH_ADDR);\n\n        // Calculate repay amount (_amount + (2 wei))\n        // Approve transfer from\n        uint256 repayAmount = _getRepaymentAmountInternal(_ethAmount);\n        ERC20(WETH_ADDR).approve(SOLO_MARGIN_ADDRESS, repayAmount);\n\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\n\n        operations[0] = _getWithdrawAction(marketId, _ethAmount, AAVE_IMPORT);\n        operations[1] = _getCallAction(\n            abi.encode(_market, _collateralToken, _borrowToken, _ethAmount, address(this)),\n            AAVE_IMPORT\n        );\n        operations[2] = _getDepositAction(marketId, repayAmount, address(this));\n\n        Account.Info[] memory accountInfos = new Account.Info[](1);\n        accountInfos[0] = _getAccountInfo();\n\n        givePermission(AAVE_IMPORT);\n        solo.operate(accountInfos, operations);\n        removePermission(AAVE_IMPORT);\n\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"AaveImport\", abi.encode(_collateralToken, _borrowToken));\n    }\n}\n"
543     },
544     "contracts/aaveV2/automatic/AaveSubscriptionsProxyV2.sol": {
545       "content": "pragma solidity ^0.6.0;\n\nimport \"../../auth/ProxyPermission.sol\";\nimport \"../../interfaces/IAaveSubscription.sol\";\n\n/// @title SubscriptionsProxy handles authorization and interaction with the Subscriptions contract\ncontract AaveSubscriptionsProxyV2 is ProxyPermission {\n\n    string public constant NAME = \"AaveSubscriptionsProxyV2\";\n\n    address public constant AAVE_SUBSCRIPTION_ADDRESS = 0x6B25043BF08182d8e86056C6548847aF607cd7CD;\n    address public constant AAVE_MONITOR_PROXY = 0x380982902872836ceC629171DaeAF42EcC02226e;\n\n    /// @notice Calls subscription contract and creates a DSGuard if non existent\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalRatioBoost Ratio amount which boost should target\n    /// @param _optimalRatioRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    function subscribe(\n        uint128 _minRatio,\n        uint128 _maxRatio,\n        uint128 _optimalRatioBoost,\n        uint128 _optimalRatioRepay,\n        bool _boostEnabled\n    ) public {\n        givePermission(AAVE_MONITOR_PROXY);\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).subscribe(\n            _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\n    }\n\n    /// @notice Calls subscription contract and updated existing parameters\n    /// @dev If subscription is non existent this will create one\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalRatioBoost Ratio amount which boost should target\n    /// @param _optimalRatioRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    function update(\n        uint128 _minRatio,\n        uint128 _maxRatio,\n        uint128 _optimalRatioBoost,\n        uint128 _optimalRatioRepay,\n        bool _boostEnabled\n    ) public {\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).subscribe(_minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\n    }\n\n    /// @notice Calls the subscription contract to unsubscribe the caller\n    function unsubscribe() public {\n        removePermission(AAVE_MONITOR_PROXY);\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).unsubscribe();\n    }\n}\n"
546     },
547     "contracts/interfaces/IAaveSubscription.sol": {
548       "content": "pragma solidity ^0.6.0;\n\nabstract contract IAaveSubscription {\n    function subscribe(uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled) public virtual;\n    function unsubscribe() public virtual;\n}\n"
549     },
550     "contracts/aave/automatic/AaveSubscriptionsProxy.sol": {
551       "content": "pragma solidity ^0.6.0;\n\nimport \"../../auth/ProxyPermission.sol\";\nimport \"../../interfaces/IAaveSubscription.sol\";\n\n/// @title SubscriptionsProxy handles authorization and interaction with the Subscriptions contract\ncontract AaveSubscriptionsProxy is ProxyPermission {\n\n    address public constant AAVE_SUBSCRIPTION_ADDRESS = 0xe08ff7A2BADb634F0b581E675E6B3e583De086FC;\n    address public constant AAVE_MONITOR_PROXY = 0xfA560Dba3a8D0B197cA9505A2B98120DD89209AC;\n\n    /// @notice Calls subscription contract and creates a DSGuard if non existent\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalRatioBoost Ratio amount which boost should target\n    /// @param _optimalRatioRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    function subscribe(\n        uint128 _minRatio,\n        uint128 _maxRatio,\n        uint128 _optimalRatioBoost,\n        uint128 _optimalRatioRepay,\n        bool _boostEnabled\n    ) public {\n        givePermission(AAVE_MONITOR_PROXY);\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).subscribe(\n            _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\n    }\n\n    /// @notice Calls subscription contract and updated existing parameters\n    /// @dev If subscription is non existent this will create one\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalRatioBoost Ratio amount which boost should target\n    /// @param _optimalRatioRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    function update(\n        uint128 _minRatio,\n        uint128 _maxRatio,\n        uint128 _optimalRatioBoost,\n        uint128 _optimalRatioRepay,\n        bool _boostEnabled\n    ) public {\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).subscribe(_minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\n    }\n\n    /// @notice Calls the subscription contract to unsubscribe the caller\n    function unsubscribe() public {\n        removePermission(AAVE_MONITOR_PROXY);\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).unsubscribe();\n    }\n}\n"
552     },
553     "contracts/aave/saver/AaveSaverTaker.sol": {
554       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/GasBurner.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../../auth/ProxyPermission.sol\";\nimport \"../../utils/DydxFlashLoanBase.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../interfaces/ProxyRegistryInterface.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\nimport \"../../interfaces/ERC20.sol\";\nimport \"../../exchangeV3/DFSExchangeData.sol\";\n\n/// @title Import Aave position from account to wallet\n/// @dev Contract needs to have enough wei in WETH for all transactions (2 WETH wei per transaction)\ncontract AaveSaverTaker is DydxFlashLoanBase, ProxyPermission, GasBurner, DFSExchangeData {\n\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address payable public constant AAVE_RECEIVER = 0xf5AE5851288365CAB81283716575Ea6685FD0545;\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n    address public constant PROXY_REGISTRY_ADDRESS = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\n\n    function repay(ExchangeData memory _data, uint256 _gasCost) public payable {\n        _flashLoan(_data, _gasCost, true);\n    }\n\n    function boost(ExchangeData memory _data, uint256 _gasCost) public payable {\n        _flashLoan(_data, _gasCost, false);\n    }\n\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\n    /// @dev User must send 2 wei with this transaction\n    function _flashLoan(ExchangeData memory _data, uint _gasCost, bool _isRepay) internal {\n        ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\n\n        uint256 ethAmount = ERC20(WETH_ADDR).balanceOf(SOLO_MARGIN_ADDRESS);\n\n        // Get marketId from token address\n        uint256 marketId = _getMarketIdFromTokenAddress(WETH_ADDR);\n\n        // Calculate repay amount (_amount + (2 wei))\n        // Approve transfer from\n        uint256 repayAmount = _getRepaymentAmountInternal(ethAmount);\n        ERC20(WETH_ADDR).approve(SOLO_MARGIN_ADDRESS, repayAmount);\n\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\n\n        operations[0] = _getWithdrawAction(marketId, ethAmount, AAVE_RECEIVER);\n        AAVE_RECEIVER.transfer(msg.value);\n        bytes memory encodedData = packExchangeData(_data);\n        operations[1] = _getCallAction(\n            abi.encode(encodedData, _gasCost, _isRepay, ethAmount, msg.value, proxyOwner(), address(this)),\n            AAVE_RECEIVER\n        );\n        operations[2] = _getDepositAction(marketId, repayAmount, address(this));\n\n        Account.Info[] memory accountInfos = new Account.Info[](1);\n        accountInfos[0] = _getAccountInfo();\n\n        givePermission(AAVE_RECEIVER);\n        solo.operate(accountInfos, operations);\n        removePermission(AAVE_RECEIVER);\n    }\n}"
555     },
556     "contracts/aave/import/AaveImportTaker.sol": {
557       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/GasBurner.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../../auth/ProxyPermission.sol\";\nimport \"../../utils/DydxFlashLoanBase.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../interfaces/ProxyRegistryInterface.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\nimport \"../../interfaces/ERC20.sol\";\n\n\n/// @title Import Aave position from account to wallet\n/// @dev Contract needs to have enough wei in WETH for all transactions (2 WETH wei per transaction)\ncontract AaveImportTaker is DydxFlashLoanBase, ProxyPermission {\n\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    address payable public constant AAVE_IMPORT = 0x5cD4239D2AA5b487bA87c3715127eA53685B4926;\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n    address public constant PROXY_REGISTRY_ADDRESS = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\n\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\n    /// @dev User must send 2 wei with this transaction\n    /// @dev User must approve DSProxy to pull _aCollateralToken\n    /// @param _collateralToken Collateral token we are moving to DSProxy\n    /// @param _borrowToken Borrow token we are moving to DSProxy\n    /// @param _ethAmount ETH amount that needs to be pulled from dydx\n    function importLoan(address _collateralToken, address _borrowToken, uint _ethAmount) public {\n        ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\n\n        // Get marketId from token address\n        uint256 marketId = _getMarketIdFromTokenAddress(WETH_ADDR);\n\n        // Calculate repay amount (_amount + (2 wei))\n        // Approve transfer from\n        uint256 repayAmount = _getRepaymentAmountInternal(_ethAmount);\n        ERC20(WETH_ADDR).approve(SOLO_MARGIN_ADDRESS, repayAmount);\n\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\n\n        operations[0] = _getWithdrawAction(marketId, _ethAmount, AAVE_IMPORT);\n        operations[1] = _getCallAction(\n            abi.encode(_collateralToken, _borrowToken, _ethAmount, address(this)),\n            AAVE_IMPORT\n        );\n        operations[2] = _getDepositAction(marketId, repayAmount, address(this));\n\n        Account.Info[] memory accountInfos = new Account.Info[](1);\n        accountInfos[0] = _getAccountInfo();\n\n        givePermission(AAVE_IMPORT);\n        solo.operate(accountInfos, operations);\n        removePermission(AAVE_IMPORT);\n\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"AaveImport\", abi.encode(_collateralToken, _borrowToken));\n    }\n}\n"
558     },
559     "contracts/mcd/automaticV2/SubscriptionsProxyV2.sol": {
560       "content": "pragma solidity ^0.6.0;\n\nimport \"../../DS/DSGuard.sol\";\nimport \"../../DS/DSAuth.sol\";\n\ncontract SubscriptionsInterfaceV2 {\n    function subscribe(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled, bool _nextPriceEnabled) external {}\n    function unsubscribe(uint _cdpId) external {}\n}\n\n/// @title SubscriptionsProxy handles authorization and interaction with the Subscriptions contract\ncontract SubscriptionsProxyV2 {\n\n    address public constant MONITOR_PROXY_ADDRESS = 0x1816A86C4DA59395522a42b871bf11A4E96A1C7a;\n    address public constant OLD_SUBSCRIPTION = 0x83152CAA0d344a2Fd428769529e2d490A88f4393;\n    address public constant FACTORY_ADDRESS = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;\n\n    function migrate(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalRatioBoost, uint128 _optimalRatioRepay, bool _boostEnabled, bool _nextPriceEnabled, address _subscriptions) public {\n        SubscriptionsInterfaceV2(OLD_SUBSCRIPTION).unsubscribe(_cdpId);\n\n        subscribe(_cdpId, _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled, _nextPriceEnabled, _subscriptions);\n    }\n\n    function subscribe(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalRatioBoost, uint128 _optimalRatioRepay, bool _boostEnabled, bool _nextPriceEnabled, address _subscriptions) public {\n\n        address currAuthority = address(DSAuth(address(this)).authority());\n        DSGuard guard = DSGuard(currAuthority);\n\n        if (currAuthority == address(0)) {\n            guard = DSGuardFactory(FACTORY_ADDRESS).newGuard();\n            DSAuth(address(this)).setAuthority(DSAuthority(address(guard)));\n        }\n\n        guard.permit(MONITOR_PROXY_ADDRESS, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n\n        SubscriptionsInterfaceV2(_subscriptions).subscribe(_cdpId, _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled, _nextPriceEnabled);\n    }\n\n    function update(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalRatioBoost, uint128 _optimalRatioRepay, bool _boostEnabled, bool _nextPriceEnabled, address _subscriptions) public {\n        SubscriptionsInterfaceV2(_subscriptions).subscribe(_cdpId, _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled, _nextPriceEnabled);\n    }\n\n    function unsubscribe(uint _cdpId, address _subscriptions) public {\n        SubscriptionsInterfaceV2(_subscriptions).unsubscribe(_cdpId);\n    }\n}\n"
561     },
562     "contracts/compound/saver/CompoundSaverFlashLoan.sol": {
563       "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/FlashLoanReceiverBase.sol\";\nimport \"../../interfaces/DSProxyInterface.sol\";\nimport \"../../exchangeV3/DFSExchangeData.sol\";\n\n/// @title Contract that receives the FL from Aave for Repays/Boost\ncontract CompoundSaverFlashLoan is FlashLoanReceiverBase, DFSExchangeData {\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n\n    address payable public COMPOUND_SAVER_FLASH_PROXY = 0x1597E7dbb1e69Ec2a64C756Fec0DB01F463aa881;\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address public owner;\n\n    using SafeERC20 for ERC20;\n\n    constructor()\n        FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER)\n        public {\n            owner = msg.sender;\n    }\n\n    /// @notice Called by Aave when sending back the FL amount\n    /// @param _reserve The address of the borrowed token\n    /// @param _amount Amount of FL tokens received\n    /// @param _fee FL Aave fee\n    /// @param _params The params that are sent from the original FL caller contract\n   function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n        // Format the call data for DSProxy\n        (bytes memory proxyData, address payable proxyAddr) = packFunctionCall(_amount, _fee, _params);\n\n        // Send Flash loan amount to DSProxy\n        sendLoanToProxy(proxyAddr, _reserve, _amount);\n\n        // Execute the DSProxy call\n        DSProxyInterface(proxyAddr).execute(COMPOUND_SAVER_FLASH_PROXY, proxyData);\n\n        // Repay the loan with the money DSProxy sent back\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Formats function data call so we can call it through DSProxy\n    /// @param _amount Amount of FL\n    /// @param _fee Fee of the FL\n    /// @param _params Saver proxy params\n    /// @return proxyData Formated function call data\n    function packFunctionCall(uint _amount, uint _fee, bytes memory _params) internal pure returns (bytes memory proxyData, address payable) {\n        (\n            bytes memory exDataBytes,\n            address[2] memory cAddresses, // cCollAddress, cBorrowAddress\n            uint256 gasCost,\n            bool isRepay,\n            address payable proxyAddr\n        )\n        = abi.decode(_params, (bytes,address[2],uint256,bool,address));\n\n        ExchangeData memory _exData = unpackExchangeData(exDataBytes);\n\n        uint[2] memory flashLoanData = [_amount, _fee];\n\n        if (isRepay) {\n            proxyData = abi.encodeWithSignature(\"flashRepay((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),address[2],uint256,uint256[2])\", _exData, cAddresses, gasCost, flashLoanData);\n        } else {\n            proxyData = abi.encodeWithSignature(\"flashBoost((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),address[2],uint256,uint256[2])\", _exData, cAddresses, gasCost, flashLoanData);\n        }\n\n        return (proxyData, proxyAddr);\n    }\n\n    /// @notice Send the FL funds received to DSProxy\n    /// @param _proxy DSProxy address\n    /// @param _reserve Token address\n    /// @param _amount Amount of tokens\n    function sendLoanToProxy(address payable _proxy, address _reserve, uint _amount) internal {\n        if (_reserve != ETH_ADDRESS) {\n            ERC20(_reserve).safeTransfer(_proxy, _amount);\n        }\n\n        _proxy.transfer(address(this).balance);\n    }\n\n    receive() external override(FlashLoanReceiverBase) payable {}\n}\n"
564     },
565     "contracts/compound/import/CompoundImportFlashLoan.sol": {
566       "content": "pragma solidity ^0.6.0;\n\nimport \"../../auth/AdminAuth.sol\";\nimport \"../../utils/FlashLoanReceiverBase.sol\";\nimport \"../../interfaces/ProxyRegistryInterface.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../utils/SafeERC20.sol\";\n\n/// @title Receives FL from Aave and imports the position to DSProxy\ncontract CompoundImportFlashLoan is FlashLoanReceiverBase, AdminAuth {\n    using SafeERC20 for ERC20;\n\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER =\n        ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n\n    address public constant COMPOUND_BORROW_PROXY = 0xb7EDC39bE76107e2Cc645f0f6a3D164f5e173Ee2;\n    address public constant PULL_TOKENS_PROXY = 0x45431b79F783e0BF0fe7eF32D06A3e061780bfc4;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor() public FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER) {}\n\n    /// @notice Called by Aave when sending back the FL amount\n    /// @param _reserve The address of the borrowed token\n    /// @param _amount Amount of FL tokens received\n    /// @param _fee FL Aave fee\n    /// @param _params The params that are sent from the original FL caller contract\n    function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params\n    ) external override {\n        (address cCollAddr, address cBorrowAddr, address proxy) =\n            abi.decode(_params, (address, address, address));\n\n        address user = DSProxyInterface(proxy).owner();\n        uint256 usersCTokenBalance = CTokenInterface(cCollAddr).balanceOf(user);\n\n        if (_reserve != EthAddressLib.ethAddress()) {\n            // approve FL tokens so we can repay them\n            ERC20(_reserve).safeApprove(cBorrowAddr, _amount);\n\n            // repay compound debt on behalf of the user\n            require(\n                CTokenInterface(cBorrowAddr).repayBorrowBehalf(user, uint256(-1)) == 0,\n                \"Repay borrow behalf fail\"\n            );\n        } else {\n            CTokenInterface(cBorrowAddr).repayBorrowBehalf{value: _amount}(user); // reverts on fail\n        }\n\n        bytes memory depositProxyCallData = formatDSProxyPullTokensCall(cCollAddr, usersCTokenBalance);\n        DSProxyInterface(proxy).execute(PULL_TOKENS_PROXY, depositProxyCallData);\n\n        // borrow debt now on ds proxy\n        bytes memory borrowProxyCallData =\n            formatDSProxyBorrowCall(cCollAddr, cBorrowAddr, _reserve, (_amount + _fee));\n        DSProxyInterface(proxy).execute(COMPOUND_BORROW_PROXY, borrowProxyCallData);\n\n        // repay the loan with the money DSProxy sent back\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n    }\n\n    /// @notice Formats function data call to pull tokens to DSProxy\n    /// @param _cTokenAddr CToken address of the collateral\n    /// @param _amount Amount of cTokens to pull\n    function formatDSProxyPullTokensCall(\n        address _cTokenAddr,\n        uint256 _amount\n    ) internal pure returns (bytes memory) {\n        return abi.encodeWithSignature(\n            \"pullTokens(address,uint256)\",\n            _cTokenAddr,\n            _amount\n        );\n    }\n\n    /// @notice Formats function data call borrow through DSProxy\n    /// @param _cCollToken CToken address of collateral\n    /// @param _cBorrowToken CToken address we will borrow\n    /// @param _borrowToken Token address we will borrow\n    /// @param _amount Amount that will be borrowed\n    function formatDSProxyBorrowCall(\n        address _cCollToken,\n        address _cBorrowToken,\n        address _borrowToken,\n        uint256 _amount\n    ) internal pure returns (bytes memory) {\n        return abi.encodeWithSignature(\n            \"borrow(address,address,address,uint256)\",\n            _cCollToken,\n            _cBorrowToken,\n            _borrowToken,\n            _amount\n        );\n    }\n}\n"
567     },
568     "contracts/mcd/automaticV2/MCDPriceVerifier.sol": {
569       "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/OsmMom.sol\";\nimport \"../../interfaces/Osm.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../../interfaces/Manager.sol\";\n\ncontract MCDPriceVerifier is AdminAuth {\n\n    OsmMom public osmMom = OsmMom(0x76416A4d5190d071bfed309861527431304aA14f);\n    Manager public manager = Manager(0x5ef30b9986345249bc32d8928B7ee64DE9435E39);\n\n    mapping(address => bool) public authorized;\n\n    function verifyVaultNextPrice(uint _nextPrice, uint _cdpId) public view returns(bool) {\n        require(authorized[msg.sender]);\n\n        bytes32 ilk = manager.ilks(_cdpId);\n\n        return verifyNextPrice(_nextPrice, ilk);\n    }\n\n    function verifyNextPrice(uint _nextPrice, bytes32 _ilk) public view returns(bool) {\n        require(authorized[msg.sender]);\n\n        address osmAddress = osmMom.osms(_ilk);\n\n        uint whitelisted = Osm(osmAddress).bud(address(this));\n        // If contracts doesn't have access return true\n        if (whitelisted != 1) return true;\n\n        (bytes32 price, bool has) = Osm(osmAddress).peep();\n\n        return has ? uint(price) == _nextPrice : false;\n    }\n\n    function setAuthorized(address _address, bool _allowed) public onlyOwner {\n        authorized[_address] = _allowed;\n    }\n}\n"
570     },
571     "contracts/interfaces/OsmMom.sol": {
572       "content": "pragma solidity ^0.6.0;\n\n\nabstract contract OsmMom {\n    mapping (bytes32 => address) public osms;\n}\n"
573     },
574     "contracts/interfaces/Osm.sol": {
575       "content": "pragma solidity ^0.6.0;\n\n\nabstract contract Osm {\n    mapping(address => uint256) public bud;\n\n    function peep() external view virtual returns (bytes32, bool);\n}\n"
576     },
577     "contracts/interfaces/ExchangeInterface.sol": {
578       "content": "pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\n\n//TODO: currenlty only adjusted to kyber, but should be genric interfaces for more dec. exchanges\ninterface ExchangeInterface {\n    function swapEtherToToken(uint256 _ethAmount, address _tokenAddress, uint256 _maxAmount)\n        external\n        payable\n        returns (uint256, uint256);\n\n    function swapTokenToEther(address _tokenAddress, uint256 _amount, uint256 _maxAmount)\n        external\n        returns (uint256);\n\n    function swapTokenToToken(address _src, address _dest, uint256 _amount)\n        external\n        payable\n        returns (uint256);\n\n    function getExpectedRate(address src, address dest, uint256 srcQty)\n        external\n        view\n        returns (uint256 expectedRate);\n}\n"
579     }
580   },
581   "settings": {
582     "optimizer": {
583       "enabled": true,
584       "runs": 200
585     },
586     "outputSelection": {
587       "*": {
588         "*": [
589           "evm.bytecode",
590           "evm.deployedBytecode",
591           "abi"
592         ]
593       }
594     }
595   }
596 }}