1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/MintableSale.sol": {
5       "content": "// LICENSE ATTRIBUTION\n// The MIT License (MIT)\n//\n// Copyright (c) 2020-2021 Alethea Tech PTE LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"./interfaces/IMintableERC721.sol\";\n\n/**\n * @title Mintable Sale\n *\n * @notice Mintable Sale sales fixed amount of NFTs (tokens) for a fixed price in a fixed period of time;\n *      it can be used in a 10k sale campaign and the smart contract is generic and\n *      can sell any type of mintable NFT (see MintableERC721 interface)\n *\n * @dev Technically, all the \"fixed\" parameters can be changed on the go after smart contract is deployed\n *      and operational, but this ability is reserved for quick fix-like adjustments, and to provide\n *      an ability to restart and run a similar sale after the previous one ends\n *\n * @dev When buying a token from this smart contract, next token is minted to the recipient\n *\n * @dev Deployment and setup:\n *      1. Deploy smart contract, specify smart contract address during the deployment:\n *         - Mintable ER721 deployed instance address\n *      2. Execute `initialize` function and set up the sale parameters;\n *         sale is not active until it's initialized\n *\n */\ncontract MintableSale is Ownable {\n  // ----- SLOT.1 (256/256)\n  /**\n   * @notice Price of a single item (token) minted\n   *      When buying several tokens at once the price accumulates accordingly, with no discount\n   *\n   * @dev Maximum item price is ~18.44 ETH\n   */\n  uint64 public itemPrice;\n\n  /**\n   * @dev Next token ID to mint;\n   *      initially this is the first \"free\" ID which can be minted;\n   *      at any point in time this should point to a free, mintable ID\n   *      for the token\n   *\n   * @dev `nextId` cannot be zero, we do not ever mint NFTs with zero IDs\n   */\n  uint32 public nextId = 1;\n\n  /**\n   * @dev Last token ID to mint;\n   *      once `nextId` exceeds `finalId` the sale pauses\n   */\n  uint32 public finalId;\n\n  /**\n   * @notice Sale start unix timestamp; the sale is active after the start (inclusive)\n   */\n  uint32 public saleStart;\n\n  /**\n   * @notice Sale end unix timestamp; the sale is active before the end (exclusive)\n   */\n  uint32 public saleEnd;\n\n  /**\n   * @notice Once set, limits the amount of tokens one can buy in a single transaction;\n   *       When unset (zero) the amount of tokens is limited only by block size and\n   *       amount of tokens left for sale\n   */\n  uint32 public batchLimit;\n\n  /**\n   * @notice Counter of the tokens sold (minted) by this sale smart contract\n   */\n  uint32 public soldCounter;\n\n  // ----- NON-SLOTTED\n  /**\n   * @dev Mintable ERC721 contract address to mint\n   */\n  address public immutable tokenContract;\n\n  /**\n   * @dev Fired in initialize()\n   *\n   * @param _by an address which executed the initialization\n   * @param _itemPrice price of one token created\n   * @param _nextId next ID of the token to mint\n   * @param _finalId final ID of the token to mint\n   * @param _saleStart start of the sale, unix timestamp\n   * @param _saleEnd end of the sale, unix timestamp\n   * @param _batchLimit how many tokens is allowed to buy in a single transaction\n   */\n  event Initialized(\n    address indexed _by,\n    uint64 _itemPrice,\n    uint32 _nextId,\n    uint32 _finalId,\n    uint32 _saleStart,\n    uint32 _saleEnd,\n    uint32 _batchLimit\n  );\n\n  /**\n   * @dev Fired in buy(), buyTo(), buySingle(), and buySingleTo()\n   *\n   * @param _by an address which executed and payed the transaction, probably a buyer\n   * @param _to an address which received token(s) minted\n   * @param _amount number of tokens minted\n   * @param _value ETH amount charged\n   */\n  event Bought(address indexed _by, address indexed _to, uint256 _amount, uint256 _value);\n\n  /**\n   * @dev Fired in withdraw() and withdrawTo()\n   *\n   * @param _by an address which executed the withdrawal\n   * @param _to an address which received the ETH withdrawn\n   * @param _value ETH amount withdrawn\n   */\n  event Withdrawn(address indexed _by, address indexed _to, uint256 _value);\n\n  /**\n   * @dev Creates/deploys MintableSale and binds it to Mintable ERC721\n   *      smart contract on construction\n   *\n   * @param _tokenContract deployed Mintable ERC721 smart contract; sale will mint ERC721\n   *      tokens of that type to the recipient\n   */\n  constructor(address _tokenContract) {\n    // verify the input is set\n    require(_tokenContract != address(0), \"token contract is not set\");\n\n    // verify input is valid smart contract of the expected interfaces\n    require(\n      IERC165(_tokenContract).supportsInterface(type(IMintableERC721).interfaceId)\n      && IERC165(_tokenContract).supportsInterface(type(IMintableERC721).interfaceId),\n      \"unexpected token contract type\"\n    );\n\n    // assign the addresses\n    tokenContract = _tokenContract;\n  }\n\n  /**\n   * @notice Number of tokens left on sale\n   *\n   * @dev Doesn't take into account if sale is active or not,\n   *      if `nextId - finalId < 1` returns zero\n   *\n   * @return number of tokens left on sale\n   */\n  function itemsOnSale() public view returns(uint32) {\n    // calculate items left on sale, taking into account that\n    // finalId is on sale (inclusive bound)\n    return finalId > nextId? finalId + 1 - nextId: 0;\n  }\n\n  /**\n   * @notice Number of tokens available on sale\n   *\n   * @dev Takes into account if sale is active or not, doesn't throw,\n   *      returns zero if sale is inactive\n   *\n   * @return number of tokens available on sale\n   */\n  function itemsAvailable() public view returns(uint32) {\n    // delegate to itemsOnSale() if sale is active, return zero otherwise\n    return isActive()? itemsOnSale(): 0;\n  }\n\n  /**\n   * @notice Active sale is an operational sale capable of minting and selling tokens\n   *\n   * @dev The sale is active when all the requirements below are met:\n   *      1. Price is set (`itemPrice` is not zero)\n   *      2. `finalId` is not reached (`nextId <= finalId`)\n   *      3. current timestamp is between `saleStart` (inclusive) and `saleEnd` (exclusive)\n   *\n   * @dev Function is marked as virtual to be overridden in the helper test smart contract (mock)\n   *      in order to test how it affects the sale process\n   *\n   * @return true if sale is active (operational) and can sell tokens, false otherwise\n   */\n  function isActive() public view virtual returns(bool) {\n    // evaluate sale state based on the internal state variables and return\n    return itemPrice > 0 && nextId <= finalId && saleStart <= block.timestamp && saleEnd > block.timestamp;\n  }\n\n  /**\n   * @dev Restricted access function to set up sale parameters, all at once,\n   *      or any subset of them\n   *\n   * @dev To skip parameter initialization, set it to `-1`,\n   *      that is a maximum value for unsigned integer of the corresponding type;\n   *      `_aliSource` and `_aliValue` must both be either set or skipped\n   *\n   * @dev Example: following initialization will update only _itemPrice and _batchLimit,\n   *      leaving the rest of the fields unchanged\n   *      initialize(\n   *          100000000000000000,\n   *          0xFFFFFFFF,\n   *          0xFFFFFFFF,\n   *          0xFFFFFFFF,\n   *          0xFFFFFFFF,\n   *          10\n   *      )\n   *\n   * @dev Requires next ID to be greater than zero (strict): `_nextId > 0`\n   *\n   * @dev Requires transaction sender to have `ROLE_SALE_MANAGER` role\n   *\n   * @param _itemPrice price of one token created;\n   *      setting the price to zero deactivates the sale\n   * @param _nextId next ID of the token to mint, will be increased\n   *      in smart contract storage after every successful buy\n   * @param _finalId final ID of the token to mint; sale is capable of producing\n   *      `_finalId - _nextId + 1` tokens\n   * @param _saleStart start of the sale, unix timestamp\n   * @param _saleEnd end of the sale, unix timestamp; sale is active only\n   *      when current time is within _saleStart (inclusive) and _saleEnd (exclusive)\n   * @param _batchLimit how many tokens is allowed to buy in a single transaction,\n   *      set to zero to disable the limit\n   */\n  function initialize(\n    uint64 _itemPrice,  // <<<--- keep type in sync with the body type(uint64).max !!!\n    uint32 _nextId,  // <<<--- keep type in sync with the body type(uint32).max !!!\n    uint32 _finalId,  // <<<--- keep type in sync with the body type(uint32).max !!!\n    uint32 _saleStart,  // <<<--- keep type in sync with the body type(uint32).max !!!\n    uint32 _saleEnd,  // <<<--- keep type in sync with the body type(uint32).max !!!\n    uint32 _batchLimit  // <<<--- keep type in sync with the body type(uint32).max !!!\n  ) public onlyOwner {\n    // verify the inputs\n    require(_nextId > 0, \"zero nextId\");\n\n    // no need to verify extra parameters - \"incorrect\" values will deactivate the sale\n\n    // initialize contract state based on the values supplied\n    // take into account our convention that value `-1` means \"do not set\"\n    // 0xFFFFFFFFFFFFFFFF, 64 bits\n    if(_itemPrice != type(uint64).max) {\n      itemPrice = _itemPrice;\n    }\n    // 0xFFFFFFFF, 32 bits\n    if(_nextId != type(uint32).max) {\n      nextId = _nextId;\n    }\n    // 0xFFFFFFFF, 32 bits\n    if(_finalId != type(uint32).max) {\n      finalId = _finalId;\n    }\n    // 0xFFFFFFFF, 32 bits\n    if(_saleStart != type(uint32).max) {\n      saleStart = _saleStart;\n    }\n    // 0xFFFFFFFF, 32 bits\n    if(_saleEnd != type(uint32).max) {\n      saleEnd = _saleEnd;\n    }\n    // 0xFFFFFFFF, 32 bits\n    if(_batchLimit != type(uint32).max) {\n      batchLimit = _batchLimit;\n    }\n\n    // emit an event - read values from the storage since not all of them might be set\n    emit Initialized(\n      msg.sender,\n      itemPrice,\n      nextId,\n      finalId,\n      saleStart,\n      saleEnd,\n      batchLimit\n    );\n  }\n\n  /**\n   * @notice Buys several (at least two) tokens in a batch.\n   *      Accepts ETH as payment and mints a token\n   *\n   * @param _amount amount of tokens to create, two or more\n   */\n  function buy(uint32 _amount) public payable {\n    // delegate to `buyTo` with the transaction sender set to be a recipient\n    buyTo(msg.sender, _amount);\n  }\n\n  /**\n   * @notice Buys several (at least two) tokens in a batch to an address specified.\n   *      Accepts ETH as payment and mints tokens\n   *\n   * @param _to address to mint tokens to\n   * @param _amount amount of tokens to create, two or more\n   */\n  function buyTo(address _to, uint32 _amount) public payable {\n    // verify the inputs\n    require(_to != address(0), \"recipient not set\");\n    require(_amount > 1 && (batchLimit == 0 || _amount <= batchLimit), \"incorrect amount\");\n\n    // verify there is enough items available to buy the amount\n    // verifies sale is in active state under the hood\n    require(itemsAvailable() >= _amount, \"inactive sale or not enough items available\");\n\n    // calculate the total price required and validate the transaction value\n    uint256 totalPrice = uint256(itemPrice) * _amount;\n    require(msg.value >= totalPrice, \"not enough funds\");\n\n    // mint token to to the recipient\n    IMintableERC721(tokenContract).mintBatch(_to, nextId, _amount);\n\n    // increment `nextId`\n    nextId += _amount;\n    // increment `soldCounter`\n    soldCounter += _amount;\n\n    // if ETH amount supplied exceeds the price\n    if(msg.value > totalPrice) {\n      // send excess amount back to sender\n      payable(msg.sender).transfer(msg.value - totalPrice);\n    }\n\n    // emit en event\n    emit Bought(msg.sender, _to, _amount, totalPrice);\n  }\n\n  /**\n   * @notice Buys single token.\n   *      Accepts ETH as payment and mints a token\n   */\n  function buySingle() public payable {\n    // delegate to `buySingleTo` with the transaction sender set to be a recipient\n    buySingleTo(msg.sender);\n  }\n\n  /**\n   * @notice Buys single token to an address specified.\n   *      Accepts ETH as payment and mints a token\n   *\n   * @param _to address to mint token to\n   */\n  function buySingleTo(address _to) public payable {\n    // verify the inputs and transaction value\n    require(_to != address(0), \"recipient not set\");\n    require(msg.value >= itemPrice, \"not enough funds\");\n\n    // verify sale is in active state\n    require(isActive(), \"inactive sale\");\n\n    // mint token to the recipient\n    IMintableERC721(tokenContract).mint(_to, nextId);\n\n    // increment `nextId`\n    nextId++;\n    // increment `soldCounter`\n    soldCounter++;\n\n    // if ETH amount supplied exceeds the price\n    if(msg.value > itemPrice) {\n      // send excess amount back to sender\n      payable(msg.sender).transfer(msg.value - itemPrice);\n    }\n\n    // emit en event\n    emit Bought(msg.sender, _to, 1, itemPrice);\n  }\n\n  /**\n   * @dev Restricted access function to withdraw ETH on the contract balance,\n   *      sends ETH back to transaction sender\n   */\n  function withdraw() public {\n    // delegate to `withdrawTo`\n    withdrawTo(msg.sender);\n  }\n\n  /**\n   * @dev Restricted access function to withdraw ETH on the contract balance,\n   *      sends ETH to the address specified\n   *\n   * @param _to an address to send ETH to\n   */\n  function withdrawTo(address _to) public onlyOwner {\n    // verify withdrawal address is set\n    require(_to != address(0), \"address not set\");\n\n    // ETH value to send\n    uint256 _value = address(this).balance;\n\n    // verify sale balance is positive (non-zero)\n    require(_value > 0, \"zero balance\");\n\n    // send the entire balance to the transaction sender\n    payable(_to).transfer(_value);\n\n    // emit en event\n    emit Withdrawn(msg.sender, _to, _value);\n  }\n}\n"
6     },
7     "@openzeppelin/contracts/access/Ownable.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
9     },
10     "@openzeppelin/contracts/interfaces/IERC165.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
12     },
13     "@openzeppelin/contracts/interfaces/IERC721.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
15     },
16     "contracts/interfaces/IMintableERC721.sol": {
17       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IMintableERC721 {\n\t/**\n\t * @notice Checks if specified token exists\n\t *\n\t * @dev Returns whether the specified token ID has an ownership\n\t *      information associated with it\n\t *\n\t * @param _tokenId ID of the token to query existence for\n\t * @return whether the token exists (true - exists, false - doesn't exist)\n\t */\n\tfunction exists(uint256 _tokenId) external view returns(bool);\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMint` instead of `mint`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction mint(address _to, uint256 _tokenId) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _tokenId ID of the first token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) external;\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId) external;\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) external;\n}\n"
18     },
19     "@openzeppelin/contracts/utils/Context.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
21     },
22     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
24     },
25     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
27     }
28   },
29   "settings": {
30     "optimizer": {
31       "enabled": true,
32       "runs": 200
33     },
34     "outputSelection": {
35       "*": {
36         "*": [
37           "evm.bytecode",
38           "evm.deployedBytecode",
39           "devdoc",
40           "userdoc",
41           "metadata",
42           "abi"
43         ]
44       }
45     },
46     "libraries": {}
47   }
48 }}