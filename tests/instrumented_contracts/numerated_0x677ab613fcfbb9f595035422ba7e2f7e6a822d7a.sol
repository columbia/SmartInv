1 {"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn\u0027t, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"Base64.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// [MIT License]\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos \u003cbrecht@loopring.org\u003e\nlibrary Base64 {\n    bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /// @notice Encodes some bytes to the base64 representation\n    function encode(bytes memory data) internal pure returns (string memory) {\n        uint256 len = data.length;\n        if (len == 0) return \"\";\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((len + 2) / 3);\n\n        // Add some extra buffer at the end\n        bytes memory result = new bytes(encodedLen + 32);\n\n        bytes memory table = TABLE;\n\n        assembly {\n            let tablePtr := add(table, 1)\n            let resultPtr := add(result, 32)\n\n            for {\n                let i := 0\n            } lt(i, len) {\n\n            } {\n                i := add(i, 3)\n                let input := and(mload(add(data, i)), 0xffffff)\n\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n                out := shl(224, out)\n\n                mstore(resultPtr, out)\n\n                resultPtr := add(resultPtr, 4)\n            }\n\n            switch mod(len, 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n\n            mstore(result, encodedLen)\n        }\n\n        return string(result);\n    }\n}\n"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"Daemonica.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// https://kanon.art - K21\n// https://daemonica.io\n//\n//\n//                                   $@@@@@@@@@@@$$$\n//                               $$@@@@@@$$$$$$$$$$$$$$##\n//                           $$$$$$$$$$$$$$$$$#########***\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\n//                     ##$$$$$$$$$$$$#######****!!!!=========\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\n//                 *#################*#***!*!!======;;;:::\n//                ################********!!!!====;;;:::~~~~~\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\n//            ******#**********!*!!!!=!===;;::~~~-,........\n//           ***************!*!!!!====;;:::~~-,,..........\n//         !************!!!!!!===;;::~~--,............\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\n//        =!!!!!!!!!=!==;;;::~~-,,...........\n//        =!!!!!!!!!====;;;;:::~~--,........\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\n//          ---~~~-----,,,,,........,---,.\n//           ,,--------,,,,,,.........\n//             .,,,,,,,,,,,,......\n//                ...............\n//                    .........\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\nimport \"./ReentrancyGuard.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./IERC721Enumerable.sol\";\n\nimport \"./OccultMath.sol\";\nimport \"./Helpers.sol\";\n\n\ninterface IBase64 is IERC721Enumerable, IERC721Metadata {}\n\ninterface IDaemonica {\n  function getTau(address _hodler) external view returns (string[] memory);\n  function getTheta(uint256 _tokenId, uint8 _modulo, string[] memory _tau) external view returns (uint8[8][8] memory);\n  function isQualified(address _hodler) external view returns (bool);\n}\n\n\n/** @title Daemonica contract\n  * @author @0xAnimist\n  * @notice \"Daemonica generates an ever-changing 8 x 8 numerical matrix from base64-encoded\n  * onchain art. Each matrix is associated with an \"Entity,\" which in turn can cast \"Xe_ntities.\"\n  * The n dimensional relationships that exist within and between each Entity and Xe_ntity can be\n  * freely interpreted and understood. Use Daemonica however you wish.\" ‚Äìartist\n  */\ncontract Daemonica is Ownable, ReentrancyGuard {\n\n  uint8 public totalDims = 0;\n\n  uint8 public totalAddedDims = 0;\n  uint8 public maxAddableDims = 128;\n  mapping (string =\u003e address) public dimAdder;\n\n\n  uint8 public totalOwnerAddedDims = 0;\n  uint8 public maxOwnerAddableDims = 128;\n  bool public presale = true;\n\n  address public artist;\n  uint256 public artistBalance = 0;\n  uint256 public ownerBalance = 0;\n\n  mapping (string =\u003e IBase64) private dims;\n  mapping (uint8 =\u003e string) private symbolStringByIndex;\n  mapping (string =\u003e uint8) private symbolIndexByString;\n\n\n  /** @notice Allows only the artist to broadcast a message\n    * @param  _artist Artists\u0027s address\n    * @param  _message Artist\u0027s message\n    */\n  event Broadcast(address indexed _artist, string _message);\n\n\n  /** @notice Only the artist can call function\n    */\n  modifier onlyArtist() {\n    require(artist == _msgSender(), \"caller is not the artist\");\n    _;\n  }\n\n  /** @notice Only the artist or owner can call function\n    */\n  modifier onlyAdmin() {\n    require(artist == _msgSender() || owner() == _msgSender(), \"caller is not the artist or owner\");\n    _;\n  }\n\n\n  /** @notice Requires dim with symbol _symbol to be initialized\n    * @param  _symbol Symbol associated with the dim\u0027s contract\n    */\n  modifier dimExists(string memory _symbol) {\n    require(Helpers.compareStrings(symbolStringByIndex[symbolIndexByString[_symbol]],_symbol), \"dim not exist\");\n    _;\n  }\n\n\n  /** @notice Allows only the artist to broadcast a message\n    * @param  _message Artist\u0027s message\n    */\n  function artistBroadcast(string memory _message) external onlyArtist {\n    emit Broadcast(msg.sender, _message);\n  }\n\n\n  /** @notice Allows the owner to set the presale flag\n    * @param  _value the new value\n    */\n  function setPresale(bool _value) external onlyOwner {\n    presale = _value;\n  }\n\n\n  /** @notice Returns lists of all dims by symbol and address\n    * @dev    different contracts with the same symbol cannot be registered, only the first registered will be accepted\n    * @return string array of each dim symbol\n    * @return address array of each dim contract address\n    */\n  function getDims() external view returns (string[] memory, address[] memory) {\n    string[] memory symbols = new string[](totalDims);\n    address[] memory addresses = new address[](totalDims);\n    for(uint8 i = 0; i \u003c totalDims; i++){\n      symbols[i] = symbolStringByIndex[i];\n      addresses[i] = address(dims[symbols[i]]);\n    }\n    return (symbols, addresses);\n  }\n\n\n  /** @notice Registers a new dim\n    * @dev    different contracts with the same symbol cannot be registered, only the first registered will be accepted\n    * @param  _address  Contract address of dim to register\n    */\n  function registerDim(address _address) internal {\n    IBase64 dim = IBase64(_address);\n\n    //name the new dim symbolically and increment the dims counter\n    string memory symbol = dim.symbol();\n    require(!Helpers.compareStrings(dim.symbol(), \"\"), \"requires symbol\");\n    require(!Helpers.compareStrings(symbolStringByIndex[symbolIndexByString[symbol]],symbol), \"symbol already registered\");\n\n    //ensure the new dim is base64 encoded\n    require(isValidLootverseURI(dim.tokenURI(1)));//test it against the first token\n\n    symbolStringByIndex[totalDims] = symbol;\n    symbolIndexByString[symbol] = totalDims;\n    totalDims++;\n\n    dims[symbol] = dim;\n    dimAdder[symbol] = _msgSender();\n  }\n\n\n  /** @notice Allows owner to add a dim with a quota of maxOwnerAddableDims\n    * @param  _address  Contract address of dim to register\n    */\n  function adminAddDim(address _address) external onlyAdmin {\n    require(totalOwnerAddedDims \u003c maxOwnerAddableDims, \"owner quota exceeded\");\n    registerDim(_address);\n    totalOwnerAddedDims++;\n  }\n\n\n  /** @notice Anyone can add a valid dim for 1 ether\n    * @param  _address  Contract address of dim to register\n    */\n  function addDim(address _address) external payable nonReentrant {\n    require(!presale, \"not yet\");\n    require(msg.value \u003e= 1 ether, \"costs 1 eth\");\n    require(totalAddedDims \u003c maxAddableDims, \"public quota exceeded\");\n    registerDim(_address);\n    totalAddedDims++;\n    ownerBalance += msg.value/2;\n    artistBalance += msg.value/2;//TODO (msg.value - msg.value/2);\n  }\n\n  /** @notice Refunds a dimAdder if owner has to delete the dim the added in case\n    * of emergency\n    * @param  _symbol Symbol of the dim being removed that needs refunding\n    */\n  function refund(string memory _symbol) internal {\n    require(address(this).balance \u003e= 1 ether, \"owner cannot afford refund\");\n    payable(dimAdder[_symbol]).transfer(1 ether);\n\n    uint256 half = (1 ether)/2;\n    if(ownerBalance \u003e= half){\n      if(artistBalance \u003e= half){\n        ownerBalance -= half;\n        artistBalance -= half;\n      }else{\n        ownerBalance -= (1 ether) - artistBalance;\n        artistBalance = 0;\n      }\n    }else{\n      artistBalance -= (1 ether) - ownerBalance;\n      ownerBalance = 0;\n    }\n  }\n\n\n  /** @notice Allows owner to remove a dim and refund the dimAdder\n    * @dev  Emergency use only\n    * @param  _symbol Symbol of the dim to remove\n    */\n  function adminRemoveDim(string memory _symbol) external onlyAdmin dimExists(_symbol) {\n    require(totalDims \u003e 0, \"no dims\");\n\n    refund(_symbol);\n\n    delete(dims[_symbol]);//delete the interface\n    //refactor the mappings\n    for(uint8 i = symbolIndexByString[_symbol]; i \u003c totalDims; i++){\n      symbolStringByIndex[i] = symbolStringByIndex[i+1];\n      symbolIndexByString[symbolStringByIndex[i]] = i;\n    }\n    //delete the mappings\n    delete(symbolIndexByString[_symbol]);\n    delete(symbolStringByIndex[totalDims]);\n    //decrement the count\n    totalDims--;\n\n\n  }\n\n\n  /** @notice Returns true if the given tokenURI() return value has a valid base64 header, payload, and its contract has a valid symbol\n    * @param  _str  Return value from tokenURI() to test\n    * @return  true or false\n    */\n  function isValidLootverseURI(string memory _str) internal pure returns (bool) {\n    require(Helpers.compareStrings(\"data:application/json;base64,\", Helpers.substring(_str, 0, 29)), \u0027Invalid prefix\u0027);\n    string memory payload = Helpers.substring(_str, 29, 0);\n    require( OccultMath.isValidBase64String(payload), \"non-base64 chars\");\n    return true;\n  }\n\n\n  /** @notice Returns true if _hodler holds tokens from any dim in _animolist\n    * @param  _hodler would be _hodler\n    * @return True or false\n    */\n  function isQualified(address _hodler) external view returns (bool){\n    for(uint8 i = 0; i \u003c totalDims; i++){\n      if(dims[symbolStringByIndex[i]].balanceOf(_hodler) \u003e 0){\n        return true;\n      }\n    }\n    return false;\n  }\n\n\n  /** @notice ùúè = tau, a rarely used Greek symbol, *facta bruta* :( ùúè symbolizes  ( life | regeneration | resurrection | the power to find new life paths or choices )+. A striking phonetic relationship exists between ùúè and \"tao\", the Chinese term for ( the way | the true path | inner compass )+. *Hic et nunc*, the Daemonican way is death * life, or Œ∏ùúè=X(Œæ).\n    * @dev    Returns any dims in which the _hodler owns at least one token of any tokenId\n    * @param  _hodler entity hodler\n    * @return A string array of the symbols of one or more tokens from each dim held by the hodler\n    */\n  function getTau(address _hodler) public view returns (string[] memory){\n    string[] memory tau;\n    uint8 count = 0;\n\n    if(_hodler == address(0)){//no hodler, default to first dim\n      tau = new string[](1);\n      tau[count++] = symbolStringByIndex[0];\n      return tau;\n    }else{\n      tau = new string[](totalDims);\n\n      for(uint8 i = 0; i \u003c totalDims; i++){\n        if(dims[symbolStringByIndex[i]].balanceOf(_hodler) \u003e 0){\n          tau[count++] = symbolStringByIndex[i];\n        }\n      }\n\n      if(count == 0){//default to first dim\n        string[] memory output = new string[](1);\n        output[0] = symbolStringByIndex[0];\n        return output;\n      }else{//splice to length\n        string[] memory output = new string[](count);\n        for(uint8 i = 0; i \u003c count; i++){\n          output[i] = tau[i];\n        }\n        return output;\n      }\n    }\n  }\n\n\n  /** @notice Œ∏ = theta, symbol of change in angle or rotation. *Thanatos* (death) hides in this symbol. There is no Œæ without Œ∏, no *existentialia* without change. Œ∏ is also therefore a talismanic sign for passage to the ‚Äúunderworld‚Äù, to a realm closer to life‚Äôs origins.\n    * @dev    Returns theta, the 8x8 base-_modulo frequency matrix of an entity\n    * @param  _tokenId  tokenId of the entity being queried\n    * @param  _modulo   caps all values at base-_modulo\n    * @param  _tau      tau is the dimensions of _tokenId\u0027s hodler\n    */\n  function getTheta(uint256 _tokenId, uint8 _modulo, string[] memory _tau) external view returns (uint8[8][8] memory) {\n    bytes[] memory bytePayloads = new bytes[](_tau.length);\n\n    for(uint8 i = 0; i \u003c _tau.length; i++){\n      bytePayloads[i] = bytes(Helpers.substring(dims[_tau[i]].tokenURI(_tokenId), 29, 0));\n    }\n\n    uint8[8][8] memory thetas = OccultMath.sixtyFourier(bytePayloads, _modulo);\n\n    return thetas;\n  }\n\n\n  /** @notice Allows owner to withdraw available balance\n    */\n  function ownerWithdrawAvailableBalance() public nonReentrant onlyOwner {\n      uint256 b = ownerBalance;\n      ownerBalance = 0;\n      payable(msg.sender).transfer(b);\n  }\n\n  /** @notice Allows artist to withdraw available balance\n    */\n  function artistWithdrawAvailableBalance() public nonReentrant onlyArtist {\n      uint256 b = artistBalance;\n      artistBalance = 0;\n      payable(msg.sender).transfer(b);\n  }\n\n\n  /** @notice Daemonica constructor\n    * @param _artist The Ethereum address of the artist\n    */\n  constructor (address _artist) {\n    artist = _artist;\n  }\n\n\n}\n"},"Entity.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// https://kanon.art - K21\n// https://daemonica.io\n//\n//\n//                                   $@@@@@@@@@@@$$$\n//                               $$@@@@@@$$$$$$$$$$$$$$##\n//                           $$$$$$$$$$$$$$$$$#########***\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\n//                     ##$$$$$$$$$$$$#######****!!!!=========\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\n//                 *#################*#***!*!!======;;;:::\n//                ################********!!!!====;;;:::~~~~~\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\n//            ******#**********!*!!!!=!===;;::~~~-,........\n//           ***************!*!!!!====;;:::~~-,,..........\n//         !************!!!!!!===;;::~~--,............\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\n//        =!!!!!!!!!=!==;;;::~~-,,...........\n//        =!!!!!!!!!====;;;;:::~~--,........\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\n//          ---~~~-----,,,,,........,---,.\n//           ,,--------,,,,,,.........\n//             .,,,,,,,,,,,,......\n//                ...............\n//                    .........\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\nimport \"./ReentrancyGuard.sol\";\nimport \"./ERC721Enumerable.sol\";\n\n\nimport \"./OccultMath.sol\";\nimport \"./Base64.sol\";\nimport \"./Daemonica.sol\";\nimport \"./Manifest.sol\";\nimport \"./Xe_ntity.sol\";\nimport \"./Helpers.sol\";\nimport \"./Sacred.sol\";\n\n\ninterface IEntity is IERC721Enumerable, IERC721Metadata {\n  function getModulo() external view returns (uint8);\n  function getTick(uint256 _tokenId, uint256 _tick) external view returns (uint8[8][8] memory, string[] memory, uint256);\n}\n\n\n/** @title Daemonica Entity contract\n  * @author @0xAnimist\n  * @notice Orchestrates the manifestation of n-dimensional Daemonica entities\n  */\ncontract Entity is ERC721Enumerable, ReentrancyGuard, Ownable {\n\n  bool public initialized = false;\n\n  IDaemonica daemonica;\n  IXe_ntity xe_ntity;\n\n  address public artist;\n  uint256 public artistBalance = 0;\n  uint256 public ownerBalance = 0;\n\n  bool public publicsale = false;\n  uint256 public maxperhodler = 3;\n  uint256 public maxperanimo = 3;\n\n  uint256 public entitySupply;\n  uint256 public ownerArtistQuota = 320;\n  uint256 public ownerArtistClaimed = 0;\n  uint256 public maxEntities = 4108;//4428-320\n  uint8 public modulo;\n  uint256 public offering;\n\n  struct Tick {\n    uint256 newday;//timestamp\n    uint256 xe_ntityId;//0 for self\n    string[] tau;//dims\n  }\n\n  mapping (uint256 =\u003e Tick[]) public ticks;\n\n\n\n   /** @notice Xe_ntity interface loaded on initialization\n     */\n   modifier onlyInitialized() {\n     require(initialized, \"not initialized\");\n     _;\n   }\n\n\n   /**  @notice Set the value of the publicsale flag\n     *  @dev Only owner\n     *  @param _publicsale New value of the publicsale flag\n     *  @param _maxperhodler New value of the per-address maximum\n     *  @param _maxperanimo New value of the per-animo maximum\n     */\n   function setSaleTerms(bool _publicsale, uint256 _maxperhodler, uint256 _maxperanimo) external onlyOwner {\n     _publicsale = _publicsale;\n     maxperhodler = _maxperhodler;\n     maxperanimo = _maxperanimo;\n   }\n\n   /**  @notice Increase the total entity supply up to a limit maxEntities - artistQuota - ownerQuota\n     *  @dev Only owner\n     *  @param _addition Number of entities to add\n     */\n   function increaseSupply(uint256 _addition) external onlyOwner {\n     require((_addition + entitySupply) \u003c= 4108, \"too many\");\n     entitySupply += _addition;\n   }\n\n\n   /**  @notice Returns modulo state variable\n     *  @return modulo\n     */\n   function getModulo() external view returns (uint8){\n     return modulo;\n   }\n\n   /**  @notice Returns current tick for an entity with _tokenId\n     *  @param  _tokenId  TokenId of the entity\n     *  @return The current tick\n     */\n   function getTickCount(uint256 _tokenId) public view returns (uint256){\n     if(_exists(_tokenId)){\n       return (ticks[_tokenId].length - 1);\n     }else{\n       return 0;\n     }\n   }\n\n   /**  @notice Returns an entity\u0027s theta and tau for a given tick value\n     *  @dev  Future tick values are returned with the present value of tau\n     *  @param  _tokenId tokenId of the entity\n     *  @param  _tick Tick value\n     *  @return theta values (8x8 matrix of numbers from 0 to modulo)\n     *  @return tau array of dims\n     */\n   function getTick(uint256 _tokenId, uint256 _tick) public view returns (uint8[8][8] memory, string[] memory, uint256) {\n     string[] memory tau;\n     uint8[8][8] memory theta;\n     uint256 newday;\n\n     //future ticks default to present\n     if(!_exists(_tokenId)){\n       //require(_tick == 0, \"no future without animo\");\n       tau = daemonica.getTau(address(0));\n       newday = 0;\n       theta = daemonica.getTheta(_tokenId, modulo, tau);\n       return (theta, tau, newday);\n     }else{\n       if(_tick \u003c getTickCount(_tokenId)){//all past ticks\n         tau = ticks[_tokenId][_tick].tau;\n         newday = ticks[_tokenId][_tick].newday;\n       }else{//current and future ticks\n         tau = daemonica.getTau(ownerOf(_tokenId));//all current and future ticks use current tau\n         newday = block.timestamp;\n       }\n     }\n\n     theta = daemonica.getTheta(_tokenId, modulo, tau);\n\n     for(uint256 i = 0; i \u003c _tick; i++){\n       theta = OccultMath.sub888(theta, OccultMath.syzygy888(theta, modulo));\n     }\n\n     return (theta, tau, newday);\n   }\n\n\n\n   /**  @notice Calculates and returns base64 encoded entity metadata and image SVG\n     *  @dev Uses the Manifest library\n     *  @param _tokenId tokenId of the entity to render\n     */\n   function tokenURI(uint256 _tokenId) override public view returns (string memory) {\n     return tokenURI(_tokenId, getTickCount(_tokenId));\n   }\n\n\n\n   /**  @notice Calculates and returns base64 encoded entity metadata and image SVG for a given moment in the entity\u0027s timeline\n     *  @dev Uses the Manifest library\n     *  @param _tokenId tokenId of the entity to render\n     *  @param _tick Moment in the entity\u0027s timeline to render\n     */\n   function tokenURI(uint256 _tokenId, uint256 _tick) public view returns (string memory) {\n     uint8[8][8] memory theta;\n     string[] memory tau;\n     uint256 newday;\n\n     if(_exists(_tokenId)){\n       (theta, tau, newday) = getTick(_tokenId, _tick);\n       return Manifest.entity(_tokenId, theta, tau, _tick, newday);\n     }else{\n       tau = daemonica.getTau(address(0));\n       theta = daemonica.getTheta(_tokenId, modulo, tau);\n       return Manifest.entity(_tokenId, theta, tau, 0, 0);\n     }\n   }\n\n   /**  @notice Mints the next available entity if msg.sender and msg.value qualifies\n     */\n  function animo() external payable {\n    animoMulti(1);\n  }\n\n\n   /**  @notice Mints the next available _n entities if msg.sender and msg.value qualifies\n     *  @dev _n is gated by maxperanimo and maxperhodler\n     *  @param _n The number of entities to mint\n     */\n  function animoMulti(uint256 _n) public payable nonReentrant {\n    if(_msgSender() == owner()){\n      require((ownerArtistClaimed + _n) \u003c ownerArtistQuota, \"no more, owner and artist\");\n    }else{\n      if(maxperanimo \u003e 0){\n        require(_n \u003c= maxperanimo, \"too many at one time\");\n      }\n      require((totalSupply() + _n) \u003c= entitySupply, \"no more\");\n      require((offering * _n) \u003c= msg.value, \"insufficient offering\");\n      require(daemonica.isQualified(_msgSender()), \"must hodl \u003e= 1 qualified token\");\n      if(maxperhodler \u003e 0){//maxperhodler == 0 == unlimited\n        require((balanceOf(_msgSender()) + _n) \u003c= maxperhodler, \"quota exceeded\");\n      }\n      ownerBalance += msg.value/2;\n      artistBalance += (msg.value - (msg.value/2));\n    }\n\n    for(uint256 i = 0; i \u003c _n; i++){\n      _safeMint(_msgSender(), totalSupply());//start at 0\n      ticks[totalSupply()-1].push(Tick(block.timestamp, 0, daemonica.getTau(_msgSender())));\n    }\n\n  }\n\n\n  /**  @notice Casts an entity with a xe_ntity\n    *  @param _tokenId tokenId of the entity to cast\n    */\n  function cast(uint256 _tokenId) external payable nonReentrant onlyInitialized {\n    require(offering / 10 \u003c= msg.value, \"offer up\");\n    require(ownerOf(_tokenId) == _msgSender(), \"not hodler\");//also throws if !_exists()\n\n    string[] memory tau = daemonica.getTau(_msgSender());\n    uint256 xe_ntityId = xe_ntity.cast(_msgSender(), _tokenId, (ticks[_tokenId].length-1));\n    ticks[_tokenId].push(Tick(block.timestamp, xe_ntityId, tau));\n\n    ownerBalance += msg.value/2;\n    artistBalance += (msg.value - msg.value/2);\n  }\n\n\n  /** @notice Allows owner or artist to withdraw available balance\n    */\n  function withdrawAvailableBalance() external nonReentrant {\n    if(_msgSender() == owner()){\n      uint256 b = ownerBalance;\n      ownerBalance = 0;\n      payable(_msgSender()).transfer(b);\n    }else if(_msgSender() == artist){\n      uint256 b = artistBalance;\n      artistBalance = 0;\n      payable(_msgSender()).transfer(b);\n    }\n  }\n\n\n  /**  @notice Initializes the Xe_ntity interface\n    *  @param _xe_ntityAddress address of the Xe_ntity contract\n    */\n  function initialize(address _xe_ntityAddress) external onlyOwner {\n    require(!initialized, \"already initialized\");\n    xe_ntity = IXe_ntity(_xe_ntityAddress);\n    initialized = true;\n  }\n\n\n\n  /**  @notice Entity constructor\n    *  @param _artist address of the artist\n    *  @param _entitySupply initial supply of entities\n    *  @param _modulo puts a ceiling on entity matrix values\n    *  @param _offering cost of animo/minting an entity and 1/10 cost of casting an entity and minting a xe_ntity\n    *  @param _daemonicaAddress address of the Daemonica contract\n    */\n  constructor(\n    address _artist,\n    uint256 _entitySupply,\n    uint256 _modulo,\n    uint256 _offering,\n    address _daemonicaAddress\n  ) ERC721(\"Daemonican Entities\", \"DAE0\") Ownable() {\n      //STATE\n      artist = address(_artist);\n      entitySupply = _entitySupply;\n      modulo = uint8(_modulo);\n      offering = _offering;\n      daemonica = IDaemonica(_daemonicaAddress);\n  }\n\n}\n"},"ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"ERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./Address.sol\";\nimport \"./Context.sol\";\nimport \"./Strings.sol\";\nimport \"./ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 =\u003e address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address =\u003e uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 =\u003e address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address =\u003e mapping(address =\u003e bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length \u003e 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\u0027s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``\u0027s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"},"ERC721Enumerable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 =\u003e uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 =\u003e uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index \u003c ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index \u003c ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\u0027s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``\u0027s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension\u0027s ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension\u0027s token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension\u0027s ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from\u0027s tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\u0027s index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension\u0027s token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an \u0027if\u0027 statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\u0027s index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"},"Helpers.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// https://kanon.art - K21\n// https://daemonica.io\n//\n//\n//                                   $@@@@@@@@@@@$$$\n//                               $$@@@@@@$$$$$$$$$$$$$$##\n//                           $$$$$$$$$$$$$$$$$#########***\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\n//                     ##$$$$$$$$$$$$#######****!!!!=========\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\n//                 *#################*#***!*!!======;;;:::\n//                ################********!!!!====;;;:::~~~~~\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\n//            ******#**********!*!!!!=!===;;::~~~-,........\n//           ***************!*!!!!====;;:::~~-,,..........\n//         !************!!!!!!===;;::~~--,............\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\n//        =!!!!!!!!!=!==;;;::~~-,,...........\n//        =!!!!!!!!!====;;;;:::~~--,........\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\n//          ---~~~-----,,,,,........,---,.\n//           ,,--------,,,,,,.........\n//             .,,,,,,,,,,,,......\n//                ...............\n//                    .........\n\npragma solidity ^0.8.0;\n\n\n/** @title Daemonica helper functions\n  * @author @0xAnimist\n  * @notice Misc support for Daemonica contract suite\n  */\nlibrary Helpers{\n\n  /** @notice Converts boolean to a string\n    * @param  value The boolean value\n    * @return A string that reads \"true\" or \"false\"\n    */\n  function boolToString(bool value) public pure returns (string memory) {\n    if(value){\n      return \"true\";\n    }else{\n      return \"false\";\n    }\n  }\n\n  /** @notice Converts uint256 to a string\n    * @param  value The uint256 value\n    * @return A string that represents the numerical value of the input\n    */\n  function toString(uint256 value) public pure returns (string memory) {\n  // Inspired by OraclizeAPI\u0027s implementation - MIT license\n  // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n      if (value == 0) {\n          return \"0\";\n      }\n      uint256 temp = value;\n      uint256 digits;\n      while (temp != 0) {\n          digits++;\n          temp /= 10;\n      }\n      bytes memory buffer = new bytes(digits);\n      while (value != 0) {\n          digits -= 1;\n          buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n          value /= 10;\n      }\n      return string(buffer);\n  }\n\n  /** @notice Converts uint8 to a string\n    * @param  value The uint8 value\n    * @return A string that represents the numerical value of the input\n    */\n  function toString8(uint8 value) public pure returns (string memory) {\n    if (value == 0) {\n      return \"00\";\n    }\n\n    uint8 temp = value;\n    uint8 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer;\n    if(digits == 1){\n      buffer = new bytes(2);\n      buffer[0] = bytes1(uint8(48));\n      buffer[1] = bytes1(uint8(48 + uint8(value % 10)));\n    }else{\n      buffer = new bytes(digits);\n      while (value != 0) {\n        digits -= 1;\n        buffer[digits] = bytes1(uint8(48 + uint8(value % 10)));\n        value /= 10;\n      }\n    }\n\n    return string(buffer);\n  }\n\n\n\n  /** @notice Returns a _delimiter delimited string of all the values in an 8 uint8 long array\n    * @param  _array Array of uint8 values to concatenate\n    * @param  _delimiter String to delimit each value\n    * @return Concatenated string of all the values delimited by _delimiter\n    */\n  function stringifyRow(uint8[8] memory _array, string memory _delimiter) internal pure returns (string memory) {\n    string memory output = string(abi.encodePacked(\n      \u0027\u003ctspan x=\"153\"\u003e\u0027,toString8(_array[0]),\u0027\u003c/tspan\u003e\u0027,_delimiter,\n      \u0027\u003ctspan x=\"198\"\u003e\u0027,toString8(_array[1]),\u0027\u003c/tspan\u003e\u0027,_delimiter,\n      \u0027\u003ctspan x=\"243\"\u003e\u0027,toString8(_array[2]),\u0027\u003c/tspan\u003e\u0027,_delimiter\n    ));\n\n    output = string(abi.encodePacked(\n      output,\n      \u0027\u003ctspan x=\"288\"\u003e\u0027,toString8(_array[3]),\u0027\u003c/tspan\u003e\u0027,_delimiter,\n      \u0027\u003ctspan x=\"333\"\u003e\u0027,toString8(_array[4]),\u0027\u003c/tspan\u003e\u0027,_delimiter,\n      \u0027\u003ctspan x=\"378\"\u003e\u0027,toString8(_array[5]),\u0027\u003c/tspan\u003e\u0027,_delimiter\n    ));\n\n    return string(abi.encodePacked(\n      output,\n      \u0027\u003ctspan x=\"423\"\u003e\u0027,toString8(_array[6]),\u0027\u003c/tspan\u003e\u0027,_delimiter,\n      \u0027\u003ctspan x=\"468\"\u003e\u0027,toString8(_array[7]),\u0027\u003c/tspan\u003e\u0027,_delimiter\n    ));\n  }\n\n  /** @notice Compares two strings\n    * @param  _a First string to compare\n    * @param  _b Second string to compare\n    * @return True if equal, false if not\n    */\n  function compareStrings(string memory _a, string memory _b) public pure returns (bool) {\n    return (keccak256(abi.encodePacked((_a))) == keccak256(abi.encodePacked((_b))));\n  }\n\n\n  /** @notice Returns a substring of the given string\n    * @param  str The string\n    * @param  startIndex Starting index determining the substring to return\n    * @param  endIndex Ending index determining the substring to return\n    * @return Substring parsed from the string\n    */\n  function substring(string memory str, uint startIndex, uint endIndex) public pure returns (string memory) {\n      bytes memory strBytes = bytes(str);\n      if(endIndex == 0){\n        endIndex = strBytes.length;\n      }\n      bytes memory result = new bytes(endIndex-startIndex);\n      for(uint i = startIndex; i \u003c endIndex; i++) {\n          result[i-startIndex] = strBytes[i];\n      }\n      return string(result);\n  }\n\n\n  /** @notice Returns a pseudorandom number from a string input\n    * @param  input A string to seed the pseudorandom number generator\n    * @return  A pseudorandom uint256 number based on the input string\n    */\n  function random(string memory input) internal pure returns (uint256) {\n      return uint256(keccak256(abi.encodePacked(input)));\n  }\n\n\n}\n"},"IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``\u0027s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"},"IERC721Custodian.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// https://kanon.art - K21\n// https://daemonica.io\n//\n//\n//                                   $@@@@@@@@@@@$$$\n//                               $$@@@@@@$$$$$$$$$$$$$$##\n//                           $$$$$$$$$$$$$$$$$#########***\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\n//                     ##$$$$$$$$$$$$#######****!!!!=========\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\n//                 *#################*#***!*!!======;;;:::\n//                ################********!!!!====;;;:::~~~~~\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\n//            ******#**********!*!!!!=!===;;::~~~-,........\n//           ***************!*!!!!====;;:::~~-,,..........\n//         !************!!!!!!===;;::~~--,............\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\n//        =!!!!!!!!!=!==;;;::~~-,,...........\n//        =!!!!!!!!!====;;;;:::~~--,........\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\n//          ---~~~-----,,,,,........,---,.\n//           ,,--------,,,,,,.........\n//             .,,,,,,,,,,,,......\n//                ...............\n//                    .........\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC721 NFT Custodian contract interface\n * @author 0xAnimist\n * @notice For binding two NFTs together\n */\ninterface IERC721Custodian is IERC721 {\n\n  /** @notice Returns the guardian token contract and tokenId for a given source\n    * @param _sourceContract The ERC721 source contract for a token in guardianship\n    * @param _sourceTokenId The tokenId of a ERC721 source token in guardianship\n    * @return The contract address of the guardian token\n    * @return The tokenId of the guardian token\n    */\n  function getGuardianToken(\n    address _sourceContract,\n    uint256 _sourceTokenId\n  ) external view returns (address, uint256);\n\n\n  /** @notice Returns the owner address of a guardian token\n    * @param _sourceContract The ERC721 source contract for a token in guardianship\n    * @param _sourceTokenId The tokenId of a ERC721 source token in guardianship\n    * @return The Ethereum address of the guardian token\u0027s owner\n    */\n  function getGuardianOwner(\n    address _sourceContract,\n    uint256 _sourceTokenId\n  ) external view returns (address);\n\n\n  /** @notice Returns the message sent by the source NFT owner when they put it\n    * into guardianship\n    * @param _sourceContract The ERC721 source contract for a token in guardianship\n    * @param _xe_ntityId The tokenId of a ERC721 source token in guardianship\n    * @return The message\n    */\n  function getBindingMessage(\n    address _sourceContract,\n    uint256 _xe_ntityId\n  ) external view returns (bytes memory);\n\n\n  /** @notice Binds the source NFT to the guardian NFT, giving the guardian token\n    * owner the right to claim it at any time by unbinding\n    * @param _sourceContract The ERC721 source contract for a token in guardianship\n    * @param _sourceTokenId The tokenId of a ERC721 source token in guardianship\n    * @param _guardianContract The ERC721 guardian contract\n    * @param _guardianTokenId The tokenId of a ERC721 guardian token\n    */\n  function bind(\n    address _sourceContract,\n    uint256 _sourceTokenId,\n    address _guardianContract,\n    uint256 _guardianTokenId\n  ) external;\n\n\n  /** @notice Binds the source NFT to the guardian NFT with a message, giving the\n    * guardian token owner the right to claim it at any time by unbinding\n    * @param _sourceContract The ERC721 source contract for a token in guardianship\n    * @param _sourceTokenId The tokenId of a ERC721 source token in guardianship\n    * @param _guardianContract The ERC721 guardian contract\n    * @param _guardianTokenId The tokenId of a ERC721 guardian token\n    * @param _data The message\n    */\n  function bind(\n    address _sourceContract,\n    uint256 _sourceTokenId,\n    address _guardianContract,\n    uint256 _guardianTokenId,\n    bytes memory _data\n  ) external;\n\n\n  /** @notice Unbinds the source NFT from the guardian NFT, giving the guardian\n    * token owner the ownership of the source NFT\n    * @param _sourceContract The ERC721 source contract for a token in guardianship\n    * @param _sourceTokenId The tokenId of a ERC721 source token in guardianship\n    */\n  function unbind(\n    address _sourceContract,\n    uint256 _sourceTokenId\n  ) external;\n\n\n  /** @notice Unbinds the source NFT from the guardian NFT with a message, giving\n    * the guardian token owner the ownership of the source NFT\n    * @param _sourceContract The ERC721 source contract for a token in guardianship\n    * @param _sourceTokenId The tokenId of a ERC721 source token in guardianship\n    * @param _data The message\n    */\n  function unbind(\n    address _sourceContract,\n    uint256 _sourceTokenId,\n    bytes memory _data\n  ) external;\n\n}\n"},"IERC721Enumerable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``\u0027s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"},"IERC721Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"},"IERC721Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"Manifest.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// https://kanon.art - K21\n// https://daemonica.io\n//\n//\n//                                   $@@@@@@@@@@@$$$\n//                               $$@@@@@@$$$$$$$$$$$$$$##\n//                           $$$$$$$$$$$$$$$$$#########***\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\n//                     ##$$$$$$$$$$$$#######****!!!!=========\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\n//                 *#################*#***!*!!======;;;:::\n//                ################********!!!!====;;;:::~~~~~\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\n//            ******#**********!*!!!!=!===;;::~~~-,........\n//           ***************!*!!!!====;;:::~~-,,..........\n//         !************!!!!!!===;;::~~--,............\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\n//        =!!!!!!!!!=!==;;;::~~-,,...........\n//        =!!!!!!!!!====;;;;:::~~--,........\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\n//          ---~~~-----,,,,,........,---,.\n//           ,,--------,,,,,,.........\n//             .,,,,,,,,,,,,......\n//                ...............\n//                    .........\n\npragma solidity ^0.8.0;\n\nimport \"./Base64.sol\";\nimport \"./Helpers.sol\";\nimport \"./Sacred.sol\";\n\n\n\n/** @title Daemonica Manifest library\n  * @author @0xAnimist\n  * @notice Manifests Daemonica entities\n  */\nlibrary Manifest {\n\n   string public constant DELIMITER = \" \";\n\n\n   /** @notice Packs numerical matrix values into a DELIMITER-delimited string\n     * @param _theta The 8 x 8 matrix of uint8 values\n     * @return String representation of the matrix\n     */\n   function packSvg(uint8[8][8] memory _theta) public pure returns (string memory) {\n     string[17] memory parts;\n     parts[0] = \u0027\u003csvg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 666 888\"\u003e\u003cstyle\u003e.en { fill: #973036; font-family: serif; font-size: 30px; letter-spacing: 3px; white-space: pre; text-align: justify; text-justify: inter-word;}\u003c/style\u003e\u003crect width=\"100%\" height=\"100%\" fill=\"black\"/\u003e\u003ctext y=\"150\" class=\"en\"\u003e\u0027;\n\n     parts[1] = Helpers.stringifyRow(_theta[0], DELIMITER);//row 0\n\n     parts[2] = \u0027\u003c/text\u003e\u003ctext y=\"195\" class=\"en\"\u003e\u0027;\n\n     parts[3] = Helpers.stringifyRow(_theta[1], DELIMITER);//row 1\n\n     parts[4] = \u0027\u003c/text\u003e\u003ctext y=\"240\" class=\"en\"\u003e\u0027;\n\n     parts[5] = Helpers.stringifyRow(_theta[2], DELIMITER);//row 2\n\n     parts[6] = \u0027\u003c/text\u003e\u003ctext y=\"285\" class=\"en\"\u003e\u0027;\n\n     parts[7] = Helpers.stringifyRow(_theta[3], DELIMITER);//row 3\n\n     parts[8] = \u0027\u003c/text\u003e\u003ctext y=\"330\" class=\"en\"\u003e\u0027;\n\n     parts[9] = Helpers.stringifyRow(_theta[4], DELIMITER);//row 4\n\n     parts[10] = \u0027\u003c/text\u003e\u003ctext y=\"375\" class=\"en\"\u003e\u0027;\n\n     parts[11] = Helpers.stringifyRow(_theta[5], DELIMITER);//row 5\n\n     parts[12] = \u0027\u003c/text\u003e\u003ctext y=\"420\" class=\"en\"\u003e\u0027;\n\n     parts[13] = Helpers.stringifyRow(_theta[6], DELIMITER);//row 6\n\n     parts[14] = \u0027\u003c/text\u003e\u003ctext y=\"465\" class=\"en\"\u003e\u0027;\n\n     parts[15] = Helpers.stringifyRow(_theta[7], DELIMITER);//row 7\n\n     parts[16] = \u0027\u003c/text\u003e\u003c/svg\u003e\u0027;\n\n     string memory output = string(abi.encodePacked(parts[0], parts[1], parts[2], parts[3], parts[4], parts[5], parts[6], parts[7], parts[8]));\n     output = string(abi.encodePacked(output, parts[9], parts[10], parts[11], parts[12], parts[13], parts[14], parts[15], parts[16]));\n\n     return output;\n   }\n\n\n   /** @notice Packs an entity\u0027s attributes into a string for rendering as metadata\n     * @param _tau The dims of an entity at the given moment in 3d time\n     * @param _tick The tick value of an entity at the given moment in 3d time\n     */\n   function packAttributes(string[] memory _tau, uint256 _tick) public pure returns (string memory) {\n     string memory attributes = string(abi.encodePacked(\n       \u0027\"attributes\": [{ \"tick\": \u0027,\n       Helpers.toString(_tick),\n       \u0027},{ \"trait_type\": \"dimensions\", \"value\": \u0027,\n       Helpers.toString(_tau.length),\n       \u0027}\u0027\n     ));\n\n     if(_tau.length \u003e 0){\n       for(uint8 i = 0; i \u003c _tau.length-1; i++){\n         attributes = string(abi.encodePacked(attributes, \u0027,{ \"trait_type\": \"dimension\", \"value\": \"\u0027, _tau[i], \u0027\"}\u0027));\n       }\n       return string(abi.encodePacked(attributes, \u0027,{ \"trait_type\": \"dimension\", \"value\": \"\u0027, _tau[_tau.length-1], \u0027\"}],\u0027));\n     }else{\n       return string(abi.encodePacked(attributes, \u0027],\u0027));\n     }\n   }\n\n\n   /** @notice Manifests a Daemonica entity\n     * @param _tokenId The _tokenId of the entity to render\n     * @param _theta The matrix of frequency values of the entity at the given moment in 3d time\n     * @param _tau The dims of an entity at the given moment in 3d time\n     * @param _tick The tick value of an entity at the given moment in 3d time\n     * @param _newday The corresponding block.timestamp to the given moment in 3d time\n     */\n   function entity(\n     uint256 _tokenId,\n     uint8[8][8] memory _theta,\n     string[] memory _tau,\n     uint256 _tick,\n     uint256 _newday\n   ) public pure returns (string memory) {\n     string memory svg = packSvg(_theta);\n\n     string memory attributes;\n\n     if(_newday \u003e 0){\n       attributes = string(abi.encodePacked(\n         \u0027\"manifested\": \u0027,\n         Helpers.toString(_newday),\n         \u0027,\u0027,\n         attributes,\n         packAttributes(_tau, _tick)\n       ));\n     }else{\n       attributes = string(abi.encodePacked(\u0027\"manifested\": 0,\u0027));\n     }\n\n     string memory json = Base64.encode(\n       bytes(\n         string(\n           abi.encodePacked(\n             \u0027{\"name\": \"\u0027,\n             Sacred.callBy(_tokenId),\n             \u0027\", \"description\": \"Daemonican entity \u0027,\n             Helpers.toString(_tokenId),\n             \u0027\\u002F8888: \u0027,\n             \u0027\\u03BE = Xi, *in intentione recta*. Ludwig Wittgenstein used \\u03BE as a variable in Tractatus Logico-Philosophicus to represent aspects of his \\u201Cpropositions\\u201D. He was a mystic who hid his incantations in his philosophy, like how 6.522 + 2.003 = 7. A Daemonican entity is also a proposition, *qualitas occulta*.\u0027,\n             \u0027\", \u0027,\n             attributes,\n             \u0027\"image\": \"data:image/svg+xml;base64,\u0027,\n             Base64.encode(bytes(svg)), \u0027\"}\u0027\n           )\n         )\n       )\n     );\n\n     return string(abi.encodePacked(\u0027data:application/json;base64,\u0027, json));\n   }\n\n}\n"},"OccultMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// https://kanon.art - K21\n// https://daemonica.io\n//\n//\n//                                   $@@@@@@@@@@@$$$\n//                               $$@@@@@@$$$$$$$$$$$$$$##\n//                           $$$$$$$$$$$$$$$$$#########***\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\n//                     ##$$$$$$$$$$$$#######****!!!!=========\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\n//                 *#################*#***!*!!======;;;:::\n//                ################********!!!!====;;;:::~~~~~\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\n//            ******#**********!*!!!!=!===;;::~~~-,........\n//           ***************!*!!!!====;;:::~~-,,..........\n//         !************!!!!!!===;;::~~--,............\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\n//        =!!!!!!!!!=!==;;;::~~-,,...........\n//        =!!!!!!!!!====;;;;:::~~--,........\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\n//          ---~~~-----,,,,,........,---,.\n//           ,,--------,,,,,,.........\n//             .,,,,,,,,,,,,......\n//                ...............\n//                    .........\n\npragma solidity ^0.8.0;\n\n\n/*\n * @title OccultMath library\n * @author @0xAnimist\n * @notice Unsafe Math\n */\nlibrary OccultMath {\n\n  string public constant defaultTic = \":\";\n  string public constant defaultNthPrimeOpen = \"(\";\n  string public constant defaultNthPrimeClose = \")\";\n  string public constant defaultDeplex = \"-P\";\n\n  struct Index {\n    uint8 i;\n    uint8 j;\n  }\n\n\n  /** @notice Slices an array\n    * @param _array The array\n    * @param _length The length of the resulting array\n    * @return An array with the first _length values of the input array, _array\n    */\n  function slice(uint256[] memory _array, uint256 _length) public pure returns (uint256[] memory){\n    uint256[] memory output = new uint256[](_length);\n\n    for (uint256 i = 0; i \u003c _length; i++) {\n        output[i] = _array[i];\n    }\n\n    return output;\n  }\n\n\n  /** @notice Square root of a number\n    * @param y The number\n    * @return z Square root of the number, y\n    */\n  function sqrt(uint256 y) public pure returns (uint256 z) {\n      if (y \u003e 3) {\n          z = y;\n          uint256 x = y / 2 + 1;\n          while (x \u003c z) {\n              z = x;\n              x = (y / x + x) / 2;\n          }\n      } else if (y != 0) {\n          z = 1;\n      }\n  }\n\n\n  /** @notice Returns the smallest factor of a number\n    * @param _number The number\n    * @return Smallest factor of the number, _number\n    */\n  function smallestFactor(uint _number) public pure returns (uint256){\n    require(_number \u003e= 2, \"Number must be greater than or equal to 2\");\n\n    if((_number % 2) == 0){\n      return 2;\n    }\n\n    uint end = sqrt(_number);\n\n\t\tfor(uint i = 3; i \u003c= end; i += 2) {\n\t\t\tif (_number % i == 0)\n\t\t\t\treturn i;\n\t\t}\n\t\treturn _number;\n\t}\n\n\n  /** @notice Returns an array of the factors of a number\n    * @param _number The number\n    * @return Array of factors of the number, _number\n    */\n  function factorize(uint256 _number) public pure returns (uint256[] memory){\n    uint n = _number;\n    uint[] memory factors = new uint[](100);\n    uint len = 0;\n\n\t\twhile (n \u003e 1) {\n\t\t\tuint smallest = smallestFactor(n);\n      require(len \u003c 100, \"factor overflow\");\n      factors[len] = smallest;\n      len = len + 1;\n      n = n / smallest;\n\t\t}\n\n    uint[] memory output = slice(factors, len);\n\n\t\treturn output;\n  }\n\n\n  /** @notice Returns an array of the prime numbers between _first and _last\n    * @param _first The smallest number to consider\n    * @param _last The largest number to consider\n    * @return Array of prime numbers between _first and _last\n    */\n  function listPrimes(uint256 _first, uint256 _last) public pure returns (uint256[] memory){\n    // Validate input and initialize storage for primes\n    require(_first \u003e 1, \"The starting number must be a positive integer greater than 1\");\n    require(_last \u003e _first, \"The range of search values must be greater than 0\");\n\n    uint firstPrime = 2;\n\n    uint len = _last - firstPrime + 1;\n    uint256[] memory list = new uint256[](len);\n\n    // Generate list of all natural numbers in [_first, _first+_total]\n    for(uint i = 0; i \u003c len; i++){\n      list[i] = i + firstPrime;\n    }\n\n    // Find primes and eliminate their multiples\n    uint256 limit = sqrt(len);\n    for(uint256 i = 0; i \u003c= limit; i++) {\n      if(list[i] != 0) {\n        for(uint256 pos = i + list[i]; pos \u003c len; pos += list[i]) {\n          list[pos] = 0;\n        }\n      }\n    }\n\n    uint256 primesTotal = 0;\n    uint256 primesIndex = 0;\n\n    for(uint256 i = 0; i \u003c len; i++){\n      if(list[i] != 0){\n        primesTotal++;\n      }\n    }\n\n    uint256[] memory primesList = new uint256[](primesTotal);\n\n    // Populate primes[] with all prime numbers in order\n    for (uint256 i = 0; i \u003c len; i++) {\n      if(list[i] != 0){\n        primesList[primesIndex++] = list[i];\n      }\n    }\n\n    // Trim primes from given start and return\n    if (_first != 2) {\n      uint returnTotal = 0;\n      for(uint i = 0; i \u003c primesTotal; i++){\n        if(primesList[i] \u003e= _first){\n          returnTotal = returnTotal + 1;\n        }\n      }\n\n      uint256[] memory sliced = new uint256[](returnTotal);\n      uint diff = primesTotal - returnTotal;\n\n      for (uint256 i = 0; i \u003c returnTotal; i++) {\n        sliced[i] = primesList[i+diff];\n      }\n      return sliced;\n    }\n\n    return primesList;\n  }\n\n\n  /** @notice Returns the base-_base syzygetic pair of a given 8 x 8 matrix of uint8 values\n    * @param _entity The matrix of an entity\n    * @param _base The numerical base of the operation\n    * @return The base-_base syzygetic pair matrix\n    */\n  function syzygy888(uint8[8][8] memory _entity, uint8 _base) public pure returns (uint8[8][8] memory) {\n    uint8[8][8] memory pair;\n    for(uint8 i = 0; i \u003c 8; i++){\n      for(uint8 j = 0; j \u003c 8; j++){\n        require(_entity[i][j] \u003c _base, \"entity value out of range\");\n        pair[i][j] = _base - 1 - _entity[i][j];\n      }\n    }\n    return pair;\n  }\n\n\n  /** @notice Returns the base-_base syzygetic pair of a given uint8 value\n    * @param _i The uint8 value\n    * @param _base The numerical base of the operation\n    * @return The base-_base syzygetic pair value\n    */\n  function getSyzygyPartner8(uint8 _i, uint8 _base) public pure returns (uint8) {\n    require(_i \u003c= _base, \"pair out of range\");\n    return _base - 1 - _i;\n  }\n\n\n  /** @notice Returns the absolute value of the difference between uint8 values in\n    * corresponding cells in two 8 x 8 matrices\n    * @param _a The first matrix\n    * @param _b The second matrix\n    * @return The matrix of absolute value differences\n    */\n  function sub888(uint8[8][8] memory _a, uint8[8][8] memory _b) public pure returns (uint8[8][8] memory) {\n    uint8[8][8] memory diff;\n    for(uint8 i = 0; i \u003c 8; i++){\n      for(uint8 j = 0; j \u003c 8; j++){\n        if(_a[i][j] \u003e= _b[i][j]){\n          diff[i][j] = _a[i][j] - _b[i][j];\n        }else{\n          diff[i][j] = _b[i][j] - _a[i][j];\n        }\n      }\n    }\n    return diff;\n\n  }\n\n\n\n  /** @notice Implements the canonical version of D.C. Barker\u0027s Tic Xenotation\n    * @param _number The number to encode\n    * @return The encoded string value\n    */\n  function encodeTX(uint256 _number) public view returns (string memory) {\n    return encodeTX(_number, defaultTic, defaultNthPrimeOpen, defaultNthPrimeClose, defaultDeplex);\n  }\n\n\n  /** @notice Implements a customizable version of D.C. Barker\u0027s Tic Xenotation\n    * @param _number The number to encode\n    * @param tic The tic string\n    * @param nthPrimeOpen Open parenthesis\n    * @param nthPrimeClose Close parenthesis\n    * @param deplexToken Deplex token\n    * @return The encoded string value\n    */\n  function encodeTX(\n    uint256 _number,\n    string memory tic,//canonically \":\"\n    string memory nthPrimeOpen,//canonically \"(\"\n    string memory nthPrimeClose,//canonically \")\"\n    string memory deplexToken//canonically \"-P\"\n  ) public view returns (string memory) {\n    //zero\n    if(_number == 0){\n      return string(abi.encodePacked(nthPrimeOpen, nthPrimeOpen, deplexToken, nthPrimeClose, nthPrimeClose, tic));\n    }\n\n    //one\n    if(_number == 1){\n      return string(abi.encodePacked(nthPrimeOpen, deplexToken, nthPrimeClose, tic));\n    }\n\n    //1st prime\n    if(_number == 2){\n      return tic;\n    }\n\n    //2nd prime\n    if(_number == 3){\n      return string(abi.encodePacked(nthPrimeOpen, tic, nthPrimeClose));\n    }\n\n    //initialize primes\n    uint256[] memory primes = listPrimes(2, _number);\n\n    //initialize hyprimes\n    uint256[] memory hyprimes = new uint256[](primes[primes.length-1]+1);\n    for(uint256 i = 0; i \u003c primes.length; i++){\n      hyprimes[primes[i]] = i+1; //+1 because primes is 0-based array and hyprimes is 1-based\n    }\n\n    if(primes[primes.length-1] == _number){//ie. if _number is prime it would be the last in the primes array\n      //nth prime\n      uint256 ordinate = hyprimes[_number];\n\n      string memory output;\n\n      if(hyprimes[ordinate] != 0){//ie. if ordinate is prime\n        //_number is hyprime\n        output = string(\n          abi.encodePacked(\n            encodeTX(\n              ordinate,\n              tic,\n              nthPrimeOpen,\n              nthPrimeClose,\n              deplexToken\n            )));\n      }else{\n        //_number is !hyprime\n        uint[] memory ordinateFactors = factorize(ordinate);\n\n        for(uint i = 0; i \u003c ordinateFactors.length; i++){\n          output = string(\n            abi.encodePacked(\n              encodeTX(\n                ordinateFactors[i],\n                tic,\n                nthPrimeOpen,\n                nthPrimeClose,\n                deplexToken\n              ), output));\n        }\n      }\n      return string(abi.encodePacked(nthPrimeOpen, output, nthPrimeClose));\n    }else{\n      uint[] memory factors = factorize(_number);\n      string memory output = encodeTX(\n        factors[0],\n        tic,\n        nthPrimeOpen,\n        nthPrimeClose,\n        deplexToken\n      );\n\n      for(uint i = 1; i \u003c factors.length; i++){\n        //encode left to right from the largest factor to the smallest\n        output = string(\n          abi.encodePacked(\n            encodeTX(\n              factors[i],\n              tic,\n              nthPrimeOpen,\n              nthPrimeClose,\n              deplexToken\n            ), output));\n      }\n\n      return output;\n    }\n  }\n\n\n  /** @notice Returns the 2d base64 8 x 8 alphanumeric gematria matrix\n    * @return The Gematrix\n    */\n  function getGEMATRIX() public pure returns (uint8[8][8] memory){\n\n    uint8[8][8] memory GEMATRIX = [\n      [ 65,  66,  67,  68,  69,  70,  71,  72], // A B C D E F G H\n      [ 73,  74,  75,  76,  77,  78,  79,  80], // I J K L M N O P\n      [ 81,  82,  83,  84,  85,  86,  87,  88], // Q R S T U V W X\n      [ 89,  90,  97,  98,  99, 100, 101, 102], // Y Z a b c d e f\n      [103, 104, 105, 106, 107, 108, 109, 110], // g h i j k l m n\n      [111, 112, 113, 114, 115, 116, 117, 118], // o p q r s t u v\n      [119, 120, 121, 122,  48,  49,  50,  51], // w x y z 0 1 2 3\n      [ 52,  53,  54,  55,  56,  57,  43,  47]  // 4 5 6 7 8 9 + /\n    ];\n\n    return GEMATRIX;\n  }\n\n\n  /** @notice An occult Fourier transform that onverts base64 tokenURI values of\n    * an array of onchain NFTs into base-_modulo frequency values conformal mapped\n    * (surjective) to the Gematrix\n    * @dev For doing onchain art exegesis\n    * @return The resulting 8 x 8 uint8 matrix of frequency values\n    */\n  function sixtyFourier(bytes[] memory _tokenURIs, uint8 _modulo) public pure returns (uint8[8][8] memory) {\n    require(_modulo \u003c= 256, \"Mod \u003e 2^8\");//modulo cannot exceed max value of uint8\n    uint8[8][8] memory GEMATRIX = getGEMATRIX();\n\n    //build a linear index of the GEMATRIX\n    Index[] memory index = new Index[](123);//122 is the highest value in the GEMATRIX\n\n    //fill in the index values that point on map\n    for(uint8 i = 0; i \u003c 8; i++){\n      for(uint8 j = 0; j \u003c 8; j++){\n        index[GEMATRIX[i][j]] = Index(i,j);\n      }\n    }\n\n    //construct the frequency cipher\n    uint8[8][8] memory frequencies;\n    uint8 zero = 0;\n\n    for(uint8 t = 0; t \u003c _tokenURIs.length; t++){\n\n      for(uint256 b = 0; b \u003c _tokenURIs[t].length; b++){\n        uint8 char = uint8(bytes1(_tokenURIs[t][b]));\n        if(char != 61){//skip \"=\"\n          uint8 i = index[char].i;//TODO plex variable down uint8 i = index[uint8(_tokenURIs[t][d])].i\n          uint8 j = index[char].j;//TODO plex variable down uint8 j = index[uint8(_tokenURIs[t][d])].j;\n\n          //map frequency onto a _modulo-degree circle\n          //since we are counting one-by-one, this is equivalent to % _modulo\n          if(frequencies[i][j] == (_modulo - 1)){\n            frequencies[i][j] = zero;\n          }else{\n            frequencies[i][j]++;\n          }\n        }\n\n      }\n    }\n\n    return frequencies;\n  }\n\n\n  function isBase64Character(bytes1 _c) public pure returns (bool) {\n    uint8 _cint = uint8(_c);\n    //+\n    if(_cint == 43 || _cint == 47){//+/\n      return true;\n    }else if(_cint \u003e= 48 \u0026\u0026 _cint \u003c= 57){//0-9\n      return true;\n    }else if(_cint \u003e= 65 \u0026\u0026 _cint \u003c= 90){//A-Z\n      return true;\n    }else if(_cint \u003e= 97 \u0026\u0026 _cint \u003c= 122) {//a-z\n      return true;\n    }\n    return false;\n  }\n\n\n  function isValidBase64String(string memory _string) public pure returns (bool) {\n    bytes memory data = bytes(_string);\n    require( (data.length % 4) == 0, \"!= %4\");\n\n    for (uint i = 0; i \u003c data.length; i++) {\n      bytes1 c = data[i];\n      if(!isBase64Character(c)){\n        if(i \u003e= (data.length - 3)){//last two bytes may be = for padding\n          if(uint8(c) != 61){//=\n            return false;\n          }\n        }else{\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\u0027s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"},"Sacred.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// https://kanon.art - K21\n// https://daemonica.io\n//\n//\n//                                   $@@@@@@@@@@@$$$\n//                               $$@@@@@@$$$$$$$$$$$$$$##\n//                           $$$$$$$$$$$$$$$$$#########***\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\n//                     ##$$$$$$$$$$$$#######****!!!!=========\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\n//                 *#################*#***!*!!======;;;:::\n//                ################********!!!!====;;;:::~~~~~\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\n//            ******#**********!*!!!!=!===;;::~~~-,........\n//           ***************!*!!!!====;;:::~~-,,..........\n//         !************!!!!!!===;;::~~--,............\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\n//        =!!!!!!!!!=!==;;;::~~-,,...........\n//        =!!!!!!!!!====;;;;:::~~--,........\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\n//          ---~~~-----,,,,,........,---,.\n//           ,,--------,,,,,,.........\n//             .,,,,,,,,,,,,......\n//                ...............\n//                    .........\n\npragma solidity ^0.8.0;\n\nimport \"./Helpers.sol\";\n\n\n/*\n * @title Sacred contract\n * @author @0xAnimist\n * @notice Used for pseudorandomly assigning sacred names\n */\nlibrary Sacred {\n\n  uint8 public constant tokensPerName = 4;\n  uint8 public constant totalNgrams = 89;\n  string public constant nameDelimiter = \".\";\n\n\n  /** @notice Returns a sacred syllable from a host of languages, ancient and\n    * contemporary, based on the _index\n    * @param _index The index value from 0-88\n    * @return The sacred syllable ngram\n    */\n  function ngram(uint8 _index) public pure returns (string memory) {\n    string[totalNgrams] memory ngrams = [\n      //Sanskrit sacred seeds\n      \"\\u0101\\u1E25\",//birth of the universe\n      \"o\\u1E43\",//opening syllable\n      \"h\\u016B\\u1E43\",//closing syllable\n      \"dh\\u012B\\u1E25\",//perfect wisdom\n      \"pha\\u1E6D\",//ancient magical word\n      \"au\",//Sanskrit, \"o\"\n\n      //Sanskrit consonants, Egyptian and Maori terms\n      \"akh\",//Egyptian\n      \"ua\",//Egyptian: \"one who becomes eight\" / \"growth comes to be\"\n      \"kh\",//Egyptian: \"pool of water rises up\"\n      \"qet\",//Egyptian: fire, grain, Serpent, \"pedestal gives circle\"\n      \"ka\",//Sanskrit, Egypt\n      \"kha\",//Sanskrit\n      \"ba\",//Sanskrit, Egypt\n      \"bha\",//Sanskrit\n      \"la\",//Sanskrit\n      \"\\u1E6Da\",//Sanskrit\n      \"\\u1E6Dha\",//Sanskrit\n      \"pa\",//Sanskrit, Maori\n      \"pha\",//Sanskrit\n      \"ga\",//Sanskrit\n      \"gha\",//Sanskrit\n      \"ja\",//Sanskrit\n      \"jha\",//Sanskrit\n      \"\\u1E0Da\",//Sanskrit\n      \"\\u1E0Dha\",//Sanskrit\n      \"\\u00F1a\",//Sanskrit\n      \"ya\",//Sanskrit, Dogon\n      \"ra\",//Sanskrit, Egyptian\n      \"\\u015Ba\",//Sanskrit\n\n      //Dogon\n      \"\\u0119mm\\u0119\",//from female sorghum\n      \"p\\u014D\",//digitaria\n      \"sigi\",//Sigui, Sirius\n      \"tolo\",//star\n\n      //Angels\n      \"el\",\n      \"ael\",\n      \"iel\",\n      \"al\",\n      \"iah\",\n      \"vehu\",\n      \"jel\",\n      \"nik\",\n      \"sit\",\n      \"man\",\n      \"leu\",\n\n      //Goetia\n      \"mon\",\n      \"eth\",\n      \"deus\",\n      \"aga\",\n      \"bar\",\n      \"ast\",\n      \"mur\",\n      \"ion\",\n      \"tri\",\n      \"nab\",\n      \"ius\",\n\n      //Faerie\n      \"tit\",\n      \"mabd\",\n      \"elf\",\n      \"gno\",\n      \"tua\",\n      \"d\\u00E9\",\n      \"aos\",\n      \"s\\u00ED\",\n\n      //Q\u0027ero\n      \"ayni\",\n      \"hua\",\n      \"nee\",\n      \"ska\",\n\n      //Greek\n      \"nym\",\n      \"pan\",\n      \"syb\",\n\n      //Urbit\n      \"zod\",\n      \"bin\",\n      \"ryx\",\n\n      //Chinese\n      \"tian\",\n      \"ren\",\n      \"jing\",\n      \"dao\",\n      \"zhi\",\n      \"ye\",\n      \"xu\",\n      \"shi\",\n      \"gu\\u01D0\",\n\n      //Shintoism\n      \"ama\",\n      \"chi\",\n      \"edo\",\n      \"gi\",\n      \"kon\",\n      \"oni\",\n      \"sei\"\n    ];\n\n    return ngrams[_index];\n  }\n\n\n  /** @notice Pseudorandomly selects and punctuates an ngram\n    * @param _tokenId The _tokenId of the token name to reveal\n    * @param _index The index of the ngram (for names with \u003e 1 ngram)\n    * @return The resulting ngram\n    */\n  function pluckNGram(uint256 _tokenId, uint256 _index) public pure returns (string memory) {\n      uint256 rand = Helpers.random(string(abi.encodePacked(Helpers.toString(_index), Helpers.toString(_tokenId))));\n      string memory output = ngram(uint8(rand % totalNgrams));\n      //punctuate pseudorandomly\n      if(_index \u003c (tokensPerName - 1)){\n        uint256 daemonicPotential  = rand % 33;\n        if (daemonicPotential \u003e= 13) {\n            output = string(abi.encodePacked(output, nameDelimiter));\n        }\n      }\n\n      return output;\n  }\n\n\n  /** @notice Reveals the name of a token\n    * @param _tokenId The _tokenId of the token name to reveal\n    * @return The name of _tokenId\n    */\n  function callBy(uint256 _tokenId) public pure returns (string memory) {\n    string memory name = \"\";\n\n    for(uint i = 0; i \u003c tokensPerName; i++){\n      name = string(abi.encodePacked(name, pluckNGram(_tokenId, i)));\n    }\n\n    return name;\n  }\n\n\n}\n"},"Strings.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI\u0027s implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp \u003e\u003e= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value \u0026 0xf];\n            value \u003e\u003e= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"},"Xe_ntity.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// https://kanon.art - K21\n// https://daemonica.io\n//\n//\n//                                   $@@@@@@@@@@@$$$\n//                               $$@@@@@@$$$$$$$$$$$$$$##\n//                           $$$$$$$$$$$$$$$$$#########***\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\n//                     ##$$$$$$$$$$$$#######****!!!!=========\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\n//                 *#################*#***!*!!======;;;:::\n//                ################********!!!!====;;;:::~~~~~\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\n//            ******#**********!*!!!!=!===;;::~~~-,........\n//           ***************!*!!!!====;;:::~~-,,..........\n//         !************!!!!!!===;;::~~--,............\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\n//        =!!!!!!!!!=!==;;;::~~-,,...........\n//        =!!!!!!!!!====;;;;:::~~--,........\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\n//          ---~~~-----,,,,,........,---,.\n//           ,,--------,,,,,,.........\n//             .,,,,,,,,,,,,......\n//                ...............\n//                    .........\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\nimport \"./ERC721Enumerable.sol\";\nimport \"./ReentrancyGuard.sol\";\n\nimport \"./IERC721Custodian.sol\";\n\nimport \"./OccultMath.sol\";\nimport \"./Entity.sol\";\nimport \"./Base64.sol\";\nimport \"./Helpers.sol\";\n\n\ninterface IXe_ntity {\n  function cast(address _hodler, uint256 _entityId, uint256 _tick) external returns (uint256);\n}\n\n/**\n * @title Daemonica Xe_ntity contract\n * @author @0xAnimist\n * @notice Orchestrates the casting and binding of n-dimensional Daemonica xe_entities\n */\ncontract Xe_ntity is ERC721Enumerable, ReentrancyGuard, Ownable {\n\n  IEntity entity;\n  IERC721Custodian custodian;\n  bool public bindable = false;\n\n  address public artist;\n  uint256 public offering;\n  bool public initialized = false;\n  uint256 public artistBalance = 0;\n  uint256 public ownerBalance = 0;\n\n  string private tic = \"*\";\n  string private nthPrimeOpen = \"`   `\";\n  string private nthPrimeClose = \"     \";\n  string private deplexToken = \"ha\";\n  string private ROW_DELIMITER = \"no\";\n  string private COL_DELIMITER = \"ys\";\n\n\n  /*\n   *  \"Quasiparticle of intensive multiplicity. Tics (or castings) are intrinsically\n   *  several components of autonomously numbering anorganic populations, propagating\n   *  by contagion between segmentary divisions in the order of nature. Ticks ‚Äì\n   *  as nonqualitative differentially-decomposable counting marks ‚Äì each designate\n   *  a multitude comprehended as a singular variation in tic(k)-density.\"\n   *  -Ccru, *Ccru: Writings 1997-2003*, Time Spiral Press\n   */\n  struct Cast {\n    uint256 tick;\n    uint256 entityId;\n  }\n  mapping (uint256 =\u003e Cast) public castings;\n\n\n  /** @notice Only the Daemonica entity contract can call function\n    */\n  modifier onlyEntity() {\n    require(msg.sender == address(entity), \"onlyEntity\");//TODO _msgSender()\n    _;\n  }\n\n\n  /** @notice Only the Daemonica xe_ntity hodler can call function\n    */\n  modifier onlyHodler(uint256 _xe_ntityId) {\n    require(_exists(_xe_ntityId), \"does not exist\");\n    require(ownerOf(_xe_ntityId) == _msgSender(), \"not hodler\");\n    _;\n  }\n\n\n  /** @notice Returns the attributes of the xe_ntity with _tokenId\n    * @param _tokenId The _tokenId of the xe_ntity\n    * @return Attributes for rendering with tokenURI\n    */\n  function packAttributes(uint256 _tokenId) public view returns (string memory) {\n    return string(abi.encodePacked(\n      \u0027\"attributes\": [{ \"entity\": \u0027,\n      Helpers.toString(castings[_tokenId].entityId),\n      \u0027},{ \"tick\": \u0027,\n      Helpers.toString(castings[_tokenId].entityId),\n      \u0027}],\u0027\n    ));\n  }\n\n\n  /**  @notice Calculates and returns base64 encoded xe_ntity metadata and image SVG\n    *  encoded using Tic Xenotation from the OccultMath library\n    *  @param _tokenId tokenId of the xe_ntity to render\n    */\n  function tokenURI(uint256 _tokenId) override public view returns (string memory) {\n     string memory X = \"\";\n\n     if(_exists(_tokenId)){\n       uint8[8][8] memory theta;\n       (theta,,) = entity.getTick(castings[_tokenId].entityId, castings[_tokenId].tick);\n\n       uint8[8][8] memory antiTheta = OccultMath.syzygy888(theta, entity.getModulo());\n\n       for(uint8 i = 0; i \u003c 8; i++){\n         for(uint8 j = 0; j \u003c 8; j++){\n           X = string(abi.encodePacked(\n             X,\n             OccultMath.encodeTX(antiTheta[i][j], tic, nthPrimeOpen, nthPrimeClose, deplexToken),\n             COL_DELIMITER\n           ));\n         }\n         X = string(abi.encodePacked(X, ROW_DELIMITER));\n       }\n     }else{\n       X = \"not yet cast\";\n     }\n\n     string memory prefix = \u0027\u003csvg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 666 888\"\u003e\u003cstyle\u003e.xen { color: black; font-family: serif; font-size: 19px; line-height: 19px; white-space: break-spaces; }\u003c/style\u003e\u003crect width=\"100%\" height=\"100%\" fill=\"red\" /\u003e\u003cforeignObject x=\"90\" y=\"90\" width=\"486\" height=\"798\" class=\"xen\"\u003e\u003cdiv xmlns=\"http://www.w3.org/1999/xhtml\"\u003e\u0027;\n\n     string memory postfix = \u0027\u003c/div\u003e\u003c/foreignObject\u003e\u003c/svg\u003e\u0027;\n\n     string memory output = string(abi.encodePacked(prefix, X, postfix));\n\n     string memory json = Base64.encode(\n       bytes(\n         string(\n           abi.encodePacked(\n             \u0027{\"name\": \"Xe_ntity #\u0027,\n             Helpers.toString(_tokenId),\n             \u0027\", \"description\": \"Functions are secularized incantations as code. A Xe_ntity is X where X(entity) = entity^. Participants that own an entity can cast a xe_ntity from it, transforming the entity in the process. *Ens divinum cognoscibile per inspirationem est subiectum*=?\",\u0027,\n             packAttributes(_tokenId),\n             \u0027\"image\": \"data:image/svg+xml;base64,\u0027,\n             Base64.encode(bytes(output)), \u0027\"}\u0027\n           )\n         )\n       )\n     );\n\n     return string(abi.encodePacked(\u0027data:application/json;base64,\u0027, json));\n\n  }\n\n  /**  @notice Casts an entity with a xe_ntity, minting the xe_ntity\n    *  @param _hodler Owner of the entity\n    *  @param _entityId tokenId of the entity to cast\n    *  @param _tick 3d time parameter that chronicles how many casts the entity has undergone\n    */\n  function cast(address _hodler, uint256 _entityId, uint256 _tick) external nonReentrant onlyEntity returns (uint256){\n    _safeMint(_hodler, totalSupply()+1);//start at 1\n    castings[totalSupply()] = Cast(_tick, _entityId);\n    return totalSupply();\n  }\n\n\n  /**  @notice Binds the ownership of a xe_ntity to another ERC721 NFT\n    * @param _xe_ntityId The tokenId of the xe_ntity to bind\n    * @param _guardianContract The ERC721 guardian contract\n    * @param _guardianTokenId The tokenId of a ERC721 guardian token\n    */\n  function bind(\n    uint256 _xe_ntityId,\n    address _guardianContract,\n    uint256 _guardianTokenId\n  ) public payable {\n    bind(_xe_ntityId, _guardianContract, _guardianTokenId, \"\");\n  }\n\n\n  /**  @notice Binds the ownership of a xe_ntity to another ERC721 NFT with a message\n    * @param _xe_ntityId The tokenId of the xe_ntity to bind\n    * @param _guardianContract The ERC721 guardian contract\n    * @param _guardianTokenId The tokenId of a ERC721 guardian token\n    * @param _data The message\n    */\n  function bind(\n    uint256 _xe_ntityId,\n    address _guardianContract,\n    uint256 _guardianTokenId,\n    bytes memory _data\n  ) public payable nonReentrant {\n    require(bindable, \"not bindable\");\n    require(_msgSender() == ownerOf(_xe_ntityId), \"not yours to bind\");\n    require(msg.value \u003e= offering, \"insufficient offering\");\n\n    custodian.bind(address(this), _xe_ntityId, _guardianContract, _guardianTokenId, _data);\n\n    ownerBalance += msg.value/2;\n    artistBalance += (msg.value - (msg.value/2));\n  }\n\n\n  /** @notice Unbinds the xe_ntity from the guardian NFT, giving the guardian\n    * token owner the ownership of the xe_ntity\n    * @param _xe_ntityId The tokenId of the bound xe_ntity\n    */\n  function unbind(\n    uint256 _xe_ntityId\n  ) public payable {\n    unbind(_xe_ntityId, \"\");\n  }\n\n\n  /** @notice Unbinds the xe_ntity from the guardian NFT with a message, giving\n    * the guardian token owner the ownership of the xe_ntity\n    * @param _xe_ntityId The tokenId of the bound xe_ntity\n    * @param _data The message\n    */\n  function unbind(\n    uint256 _xe_ntityId,\n    bytes memory _data\n  ) public payable nonReentrant {\n    require(_msgSender() == custodian.getGuardianOwner(address(this), _xe_ntityId), \"not yours to unbind\");\n    require(msg.value \u003e= offering, \"insufficient offering\");\n\n    custodian.unbind(address(this), _xe_ntityId, _data);\n\n    ownerBalance += msg.value/2;\n    artistBalance += (msg.value - (msg.value/2));\n  }\n\n\n  /** @notice Returns the guardian token contract and tokenId for a given xe_ntity\n    * @param _xe_ntityId The tokenId of the bound xe_ntity\n    * @return The contract address of the guardian token\n    * @return The tokenId of the guardian token\n    */\n  function getGuardianToken(\n    uint256 _xe_ntityId\n  ) external view returns (address, uint256) {\n    return custodian.getGuardianToken(address(this), _xe_ntityId);\n  }\n\n\n  /** @notice Returns the owner address of a guardian token\n    * @param _xe_ntityId The tokenId of the bound xe_ntity\n    * @return The Ethereum address of the guardian token\u0027s owner\n    */\n  function getGuardianOwner(\n    uint256 _xe_ntityId\n  ) external view returns (address) {\n    return custodian.getGuardianOwner(address(this), _xe_ntityId);\n  }\n\n\n  /** @notice Returns the message sent by the source NFT owner when they put it\n    * into guardianship\n    * @param _xe_ntityId The tokenId of the bound xe_ntity\n    * @return The message\n    */\n  function getBindingMessage(\n    uint256 _xe_ntityId\n  ) external view returns (bytes memory) {\n    return custodian.getBindingMessage(address(this), _xe_ntityId);\n  }\n\n  /** @notice Sets the address of the guardian contract and initiates binding\n    * @param _custodianAddress The Ethereum address of the guardian contract\n    * @param _bindable The new value of the bindable flag\n    */\n  function setCustodian(address _custodianAddress, bool _bindable) external onlyOwner {\n    custodian = IERC721Custodian(_custodianAddress);\n    bindable = _bindable;\n  }\n\n\n  /** @notice Allows owner or artist to withdraw available balance\n    */\n  function withdrawAvailableBalance() external nonReentrant {\n    if(_msgSender() == owner()){\n      uint256 b = ownerBalance;\n      ownerBalance = 0;\n      payable(_msgSender()).transfer(b);\n    }else if(_msgSender() == artist){\n      uint256 b = artistBalance;\n      artistBalance = 0;\n      payable(_msgSender()).transfer(b);\n    }\n  }\n\n  /**  @notice Initializes the Entity interface\n    *  @param _entityAddress address of the Entity contract\n    */\n  function initialize(address _entityAddress) external onlyOwner {\n    require(!initialized, \"already initialized\");\n    entity = IEntity(_entityAddress);\n    initialized = true;\n  }\n\n\n  /**  @notice Xe_ntity constructor\n    *  @param _artist address of the artist\n    *  @param _offering cost of binding a xe_ntity\n    */\n  constructor(address _artist, uint256 _offering) ERC721(\"Daemonic Xe_ntities\", \"XEN0\") Ownable() {\n    artist = _artist;\n    offering = _offering;\n  }\n\n}\n"}}