1 {{
2   "language": "Solidity",
3   "sources": {
4     "/home/adam/axion-rnb/contracts/NativeSwap.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.25 <0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/IToken.sol\";\nimport \"./interfaces/IAuction.sol\";\n\ncontract NativeSwap {\n    using SafeMath for uint256;\n\n    event TokensSwapped(\n        address indexed account,\n        uint256 indexed stepsFromStart,\n        uint256 userAmount,\n        uint256 penaltyAmount\n    );\n\n    uint256 public start;\n    uint256 public period;\n    uint256 public stepTimestamp;\n    IERC20 public swapToken;\n    IToken public mainToken;\n    IAuction public auction;\n\n    bool public init_;\n\n    mapping(address => uint256) public swapTokenBalanceOf;\n\n    constructor() public {\n        init_ = false;\n    }\n\n    function init(\n        uint256 _period,\n        uint256 _stepTimestamp,\n        address _swapToken,\n        address _mainToken,\n        address _auction\n    ) external {\n        require(!init_, \"init is active\");\n        period = _period;\n        stepTimestamp = _stepTimestamp;\n        swapToken = IERC20(_swapToken);\n        mainToken = IToken(_mainToken);\n        auction = IAuction(_auction);\n        start = now;\n        init_ = true;\n    }\n\n    function deposit(uint256 _amount) external {\n        require(\n            swapToken.transferFrom(msg.sender, address(this), _amount),\n            \"NativeSwap: transferFrom error\"\n        );\n        swapTokenBalanceOf[msg.sender] = swapTokenBalanceOf[msg.sender].add(\n            _amount\n        );\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(_amount >= swapTokenBalanceOf[msg.sender], \"balance < amount\");\n        swapTokenBalanceOf[msg.sender] = swapTokenBalanceOf[msg.sender].sub(\n            _amount\n        );\n        swapToken.transfer(msg.sender, _amount);\n    }\n\n    function swapNativeToken() external {\n        uint256 stepsFromStart = calculateStepsFromStart();\n        require(stepsFromStart <= period, \"swapNativeToken: swap is over\");\n        uint256 amount = swapTokenBalanceOf[msg.sender];\n        uint256 deltaPenalty = calculateDeltaPenalty(amount);\n        uint256 amountOut = amount.sub(deltaPenalty);\n        require(amount > 0, \"swapNativeToken: amount == 0\");\n        swapTokenBalanceOf[msg.sender] = 0;\n        mainToken.mint(address(auction), deltaPenalty);\n        auction.callIncomeDailyTokensTrigger(deltaPenalty);\n        mainToken.mint(msg.sender, amountOut);\n\n        emit TokensSwapped(msg.sender, stepsFromStart, amount, deltaPenalty);\n    }\n\n    function calculateDeltaPenalty(uint256 amount)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 stepsFromStart = calculateStepsFromStart();\n        if (stepsFromStart > period) return amount;\n        return amount.mul(stepsFromStart).div(period);\n    }\n\n    function calculateStepsFromStart() public view returns (uint256) {\n        return now.sub(start).div(stepTimestamp);\n    }\n}\n"
6     },
7     "/home/adam/axion-rnb/contracts/interfaces/IAuction.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\ninterface IAuction {\n    function callIncomeDailyTokensTrigger(uint256 amount) external;\n\n    function callIncomeWeeklyTokensTrigger(uint256 amount) external;\n}\n"
9     },
10     "/home/adam/axion-rnb/contracts/interfaces/IToken.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\ninterface IToken {\n    function mint(address to, uint256 amount) external;\n\n    function burn(address from, uint256 amount) external;\n}\n"
12     },
13     "@openzeppelin/contracts/math/SafeMath.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
15     },
16     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
18     }
19   },
20   "settings": {
21     "remappings": [],
22     "optimizer": {
23       "enabled": true,
24       "runs": 0
25     },
26     "evmVersion": "istanbul",
27     "libraries": {
28       "": {}
29     },
30     "outputSelection": {
31       "*": {
32         "*": [
33           "evm.bytecode",
34           "evm.deployedBytecode",
35           "abi"
36         ]
37       }
38     }
39   }
40 }}