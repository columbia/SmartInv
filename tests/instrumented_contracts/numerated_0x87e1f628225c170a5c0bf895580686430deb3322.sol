1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/SingleSidedReinsurancePool.sol": {
5       "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IMigration.sol\";\nimport \"./interfaces/IRiskPoolFactory.sol\";\nimport \"./interfaces/IRewarderFactory.sol\";\nimport \"./interfaces/ISingleSidedReinsurancePool.sol\";\nimport \"./interfaces/ISyntheticSSRPFactory.sol\";\nimport \"./interfaces/IRewarder.sol\";\nimport \"./interfaces/IRiskPool.sol\";\nimport \"./libraries/TransferHelper.sol\";\n\ncontract SingleSidedReinsurancePool is ISingleSidedReinsurancePool, ReentrancyGuard {\n    address public owner;\n    address public claimAssessor;\n    address public migrateTo;\n    address public syntheticSSRP;\n\n    uint256 public LOCK_TIME = 1 days;\n    uint256 public constant ACC_UNO_PRECISION = 1e18;\n    uint256 public STAKING_START_TIME;\n\n    address public rewarder;\n    address public override riskPool;\n    struct PoolInfo {\n        uint128 lastRewardBlock;\n        uint128 accUnoPerShare;\n        uint256 unoMultiplierPerBlock;\n    }\n\n    struct UserInfo {\n        uint256 lastWithdrawTime;\n        uint256 rewardDebt;\n        uint256 amount;\n    }\n\n    mapping(address => UserInfo) public userInfo;\n\n    PoolInfo public poolInfo;\n\n    event RiskPoolCreated(address indexed _SSRP, address indexed _pool);\n    event StakedInPool(address indexed _staker, address indexed _pool, uint256 _amount);\n    event LeftPool(address indexed _staker, address indexed _pool, uint256 _requestAmount);\n    event LogUpdatePool(uint128 _lastRewardBlock, uint256 _lpSupply, uint256 _accUnoPerShare);\n    event Harvest(address indexed _user, address indexed _receiver, uint256 _amount);\n    event LogLeaveFromPendingSSRP(address indexed _user, uint256 _withdrawLpAmount, uint256 _withdrawUnoAmount);\n    event PolicyClaim(address indexed _user, uint256 _claimAmount);\n    event LogLpTransferInSSRP(address indexed _from, address indexed _to, uint256 _amount);\n    event LogCreateRewarder(address indexed _SSRP, address indexed _rewarder, address _currency);\n    event LogCreateSyntheticSSRP(address indexed _SSRP, address indexed _syntheticSSRP, address indexed _lpToken);\n    event LogCancelWithdrawRequest(address indexed _user, uint256 _cancelAmount, uint256 _cancelAmountInUno);\n    event LogMigrate(address indexed _user, address indexed _migrateTo, uint256 _migratedAmount);\n\n    constructor(address _owner, address _claimAssessor) {\n        owner = _owner;\n        claimAssessor = _claimAssessor;\n        STAKING_START_TIME = block.timestamp + 3 days;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"UnoRe: Forbidden\");\n        _;\n    }\n\n    modifier onlyClaimAssessor() {\n        require(msg.sender == claimAssessor, \"UnoRe: Forbidden\");\n        _;\n    }\n\n    modifier isStartTime() {\n        require(block.timestamp >= STAKING_START_TIME, \"UnoRe: not available time\");\n        _;\n    }\n\n    function setRewardMultiplier(uint256 _rewardMultiplier) external onlyOwner {\n        require(_rewardMultiplier > 0, \"UnoRe: zero value\");\n        poolInfo.unoMultiplierPerBlock = _rewardMultiplier;\n    }\n\n    function setClaimAssessor(address _claimAssessor) external onlyOwner {\n        require(_claimAssessor != address(0), \"UnoRe: zero address\");\n        claimAssessor = _claimAssessor;\n    }\n\n    function setMigrateTo(address _migrateTo) external onlyOwner {\n        require(_migrateTo != address(0), \"UnoRe: zero address\");\n        migrateTo = _migrateTo;\n    }\n\n    function setMinLPCapital(uint256 _minLPCapital) external onlyOwner {\n        require(_minLPCapital > 0, \"UnoRe: not allow zero value\");\n        IRiskPool(riskPool).setMinLPCapital(_minLPCapital);\n    }\n\n    function setLockTime(uint256 _lockTime) external onlyOwner {\n        require(_lockTime > 0, \"UnoRe: not allow zero lock time\");\n        LOCK_TIME = _lockTime;\n    }\n\n    function setStakingStartTime(uint256 _startTime) external onlyOwner {\n        require(_startTime > 0, \"UnoRe: not allow zero start time\");\n        STAKING_START_TIME = _startTime;\n    }\n\n    /**\n     * @dev create Risk pool with UNO from SSRP owner\n     */\n    function createRiskPool(\n        string calldata _name,\n        string calldata _symbol,\n        address _factory,\n        address _currency,\n        uint256 _rewardMultiplier\n    ) external onlyOwner nonReentrant {\n        require(riskPool == address(0), \"UnoRe: risk pool created already\");\n        riskPool = IRiskPoolFactory(_factory).newRiskPool(_name, _symbol, address(this), _currency);\n        poolInfo.lastRewardBlock = uint128(block.number);\n        poolInfo.accUnoPerShare = 0;\n        poolInfo.unoMultiplierPerBlock = _rewardMultiplier;\n        emit RiskPoolCreated(address(this), riskPool);\n    }\n\n    function createRewarder(\n        address _operator,\n        address _factory,\n        address _currency\n    ) external onlyOwner nonReentrant {\n        require(_factory != address(0), \"UnoRe: rewarder factory no exist\");\n        rewarder = IRewarderFactory(_factory).newRewarder(_operator, _currency, address(this));\n        emit LogCreateRewarder(address(this), rewarder, _currency);\n    }\n\n    function createSyntheticSSRP(address _owner, address _factory) external onlyOwner nonReentrant {\n        require(_owner != address(0), \"UnoRe: zero owner address\");\n        require(_factory != address(0), \"UnoRe:zero factory address\");\n        require(riskPool != address(0), \"UnoRe:zero LP token address\");\n        syntheticSSRP = ISyntheticSSRPFactory(_factory).newSyntheticSSRP(_owner, riskPool);\n        emit LogCreateSyntheticSSRP(address(this), syntheticSSRP, riskPool);\n    }\n\n    function migrate() external nonReentrant {\n        require(migrateTo != address(0), \"UnoRe: zero address\");\n        _harvest(msg.sender);\n        uint256 amount = userInfo[msg.sender].amount;\n        bool isUnLocked = block.timestamp - userInfo[msg.sender].lastWithdrawTime > LOCK_TIME;\n        uint256 migratedAmount = IRiskPool(riskPool).migrateLP(msg.sender, migrateTo, isUnLocked);\n        IMigration(migrateTo).onMigration(msg.sender, amount, \"\");\n        userInfo[msg.sender].amount = 0;\n        userInfo[msg.sender].rewardDebt = 0;\n        emit LogMigrate(msg.sender, migrateTo, migratedAmount);\n    }\n\n    function pendingUno(address _to) external view returns (uint256 pending) {\n        uint256 tokenSupply = IERC20(riskPool).totalSupply();\n        uint128 accUnoPerShare = poolInfo.accUnoPerShare;\n        if (block.number > poolInfo.lastRewardBlock && tokenSupply != 0) {\n            uint256 blocks = block.number - uint256(poolInfo.lastRewardBlock);\n            uint256 unoReward = blocks * poolInfo.unoMultiplierPerBlock;\n            accUnoPerShare = accUnoPerShare + uint128((unoReward * ACC_UNO_PRECISION) / tokenSupply);\n        }\n        uint256 userBalance = userInfo[_to].amount;\n        pending = (userBalance * uint256(accUnoPerShare)) / ACC_UNO_PRECISION - userInfo[_to].rewardDebt;\n    }\n\n    function updatePool() public override {\n        if (block.number > poolInfo.lastRewardBlock) {\n            uint256 tokenSupply = IERC20(riskPool).totalSupply();\n            if (tokenSupply > 0) {\n                uint256 blocks = block.number - uint256(poolInfo.lastRewardBlock);\n                uint256 unoReward = blocks * poolInfo.unoMultiplierPerBlock;\n                poolInfo.accUnoPerShare = poolInfo.accUnoPerShare + uint128(((unoReward * ACC_UNO_PRECISION) / tokenSupply));\n            }\n            poolInfo.lastRewardBlock = uint128(block.number);\n            emit LogUpdatePool(poolInfo.lastRewardBlock, tokenSupply, poolInfo.accUnoPerShare);\n        }\n    }\n\n    function enterInPool(uint256 _amount) external override isStartTime nonReentrant {\n        require(_amount != 0, \"UnoRe: ZERO Value\");\n        updatePool();\n        address token = IRiskPool(riskPool).currency();\n        uint256 lpPriceUno = IRiskPool(riskPool).lpPriceUno();\n        TransferHelper.safeTransferFrom(token, msg.sender, riskPool, _amount);\n        IRiskPool(riskPool).enter(msg.sender, _amount);\n        userInfo[msg.sender].rewardDebt =\n            userInfo[msg.sender].rewardDebt +\n            ((_amount * 1e18 * uint256(poolInfo.accUnoPerShare)) / lpPriceUno) /\n            ACC_UNO_PRECISION;\n        userInfo[msg.sender].amount = userInfo[msg.sender].amount + ((_amount * 1e18) / lpPriceUno);\n        emit StakedInPool(msg.sender, riskPool, _amount);\n    }\n\n    /**\n     * @dev WR will be in pending for 10 days at least\n     */\n    function leaveFromPoolInPending(uint256 _amount) external override isStartTime nonReentrant {\n        _harvest(msg.sender);\n        // Withdraw desired amount from pool\n        uint256 amount = userInfo[msg.sender].amount;\n        uint256 lpPriceUno = IRiskPool(riskPool).lpPriceUno();\n        (uint256 pendingAmount, , ) = IRiskPool(riskPool).getWithdrawRequest(msg.sender);\n        require(((amount - pendingAmount) * lpPriceUno) / 1e18 >= _amount, \"UnoRe: withdraw amount overflow\");\n        IRiskPool(riskPool).leaveFromPoolInPending(msg.sender, _amount);\n\n        userInfo[msg.sender].lastWithdrawTime = block.timestamp;\n        emit LeftPool(msg.sender, riskPool, _amount);\n    }\n\n    /**\n     * @dev user can submit claim again and receive his funds into his wallet after 10 days since last WR.\n     */\n    function leaveFromPending() external override isStartTime nonReentrant {\n        require(block.timestamp - userInfo[msg.sender].lastWithdrawTime >= LOCK_TIME, \"UnoRe: Locked time\");\n        _harvest(msg.sender);\n        uint256 amount = userInfo[msg.sender].amount;\n        (uint256 pendingAmount, , ) = IRiskPool(riskPool).getWithdrawRequest(msg.sender);\n        uint256 accumulatedUno = (amount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION;\n        userInfo[msg.sender].rewardDebt =\n            accumulatedUno -\n            ((pendingAmount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION);\n        (uint256 withdrawAmount, uint256 withdrawAmountInUNO) = IRiskPool(riskPool).leaveFromPending(msg.sender);\n        userInfo[msg.sender].amount = amount - withdrawAmount;\n        emit LogLeaveFromPendingSSRP(msg.sender, withdrawAmount, withdrawAmountInUNO);\n    }\n\n    function lpTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external override nonReentrant {\n        require(msg.sender == address(riskPool), \"UnoRe: not allow others transfer\");\n        if (_from != syntheticSSRP && _to != syntheticSSRP) {\n            _harvest(_from);\n            uint256 amount = userInfo[_from].amount;\n            (uint256 pendingAmount, , ) = IRiskPool(riskPool).getWithdrawRequest(_from);\n            require(amount - pendingAmount >= _amount, \"UnoRe: balance overflow\");\n            uint256 accumulatedUno = (amount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION;\n            userInfo[_from].rewardDebt = accumulatedUno - ((_amount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION);\n            userInfo[_from].amount = amount - _amount;\n\n            userInfo[_to].rewardDebt =\n                userInfo[_to].rewardDebt +\n                ((_amount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION);\n            userInfo[_to].amount = userInfo[_to].amount + _amount;\n\n            emit LogLpTransferInSSRP(_from, _to, _amount);\n        }\n    }\n\n    function harvest(address _to) external override isStartTime nonReentrant {\n        _harvest(_to);\n    }\n\n    function _harvest(address _to) private {\n        updatePool();\n        uint256 amount = userInfo[_to].amount;\n        uint256 accumulatedUno = (amount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION;\n        uint256 _pendingUno = accumulatedUno - userInfo[_to].rewardDebt;\n\n        // Effects\n        userInfo[msg.sender].rewardDebt = accumulatedUno;\n        uint256 rewardAmount = 0;\n\n        if (rewarder != address(0) && _pendingUno != 0) {\n            rewardAmount = IRewarder(rewarder).onReward(_to, _pendingUno);\n        }\n\n        emit Harvest(msg.sender, _to, rewardAmount);\n    }\n\n    function cancelWithdrawRequest() external nonReentrant {\n        (uint256 cancelAmount, uint256 cancelAmountInUno) = IRiskPool(riskPool).cancelWithrawRequest(msg.sender);\n        emit LogCancelWithdrawRequest(msg.sender, cancelAmount, cancelAmountInUno);\n    }\n\n    function policyClaim(address _to, uint256 _amount) external onlyClaimAssessor isStartTime nonReentrant {\n        require(_to != address(0), \"UnoRe: zero address\");\n        require(_amount > 0, \"UnoRe: zero amount\");\n        uint256 realClaimAmount = IRiskPool(riskPool).policyClaim(_to, _amount);\n        emit PolicyClaim(_to, realClaimAmount);\n    }\n\n    function getStakedAmountPerUser(address _to) external view returns (uint256 unoAmount, uint256 lpAmount) {\n        lpAmount = userInfo[_to].amount;\n        uint256 lpPriceUno = IRiskPool(riskPool).lpPriceUno();\n        unoAmount = (lpAmount * lpPriceUno) / 1e18;\n    }\n\n    /**\n     * @dev get withdraw request amount in pending per user in UNO\n     */\n    function getWithdrawRequestPerUser(address _user)\n        external\n        view\n        returns (\n            uint256 pendingAmount,\n            uint256 pendingAmountInUno,\n            uint256 originUnoAmount,\n            uint256 requestTime\n        )\n    {\n        uint256 lpPriceUno = IRiskPool(riskPool).lpPriceUno();\n        (pendingAmount, requestTime, originUnoAmount) = IRiskPool(riskPool).getWithdrawRequest(_user);\n        pendingAmountInUno = (pendingAmount * lpPriceUno) / 1e18;\n    }\n\n    /**\n     * @dev get total withdraw request amount in pending for the risk pool in UNO\n     */\n    function getTotalWithdrawPendingAmount() external view returns (uint256) {\n        return IRiskPool(riskPool).getTotalWithdrawRequestAmount();\n    }\n}\n"
6     },
7     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
9     },
10     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
12     },
13     "contracts/interfaces/IMigration.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\ninterface IMigration {\n    function onMigration(\n        address who_,\n        uint256 amount_,\n        bytes memory data_\n    ) external;\n}\n"
15     },
16     "contracts/interfaces/IRiskPoolFactory.sol": {
17       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.0;\n\ninterface IRiskPoolFactory {\n    function newRiskPool(\n        string calldata _name,\n        string calldata _symbol,\n        address _pool,\n        address _currency\n    ) external returns (address);\n}\n"
18     },
19     "contracts/interfaces/IRewarderFactory.sol": {
20       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.0;\n\ninterface IRewarderFactory {\n    function newRewarder(\n        address _operator,\n        address _currency,\n        address _pool\n    ) external returns (address);\n}\n"
21     },
22     "contracts/interfaces/ISingleSidedReinsurancePool.sol": {
23       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.0;\n\ninterface ISingleSidedReinsurancePool {\n    function updatePool() external;\n\n    function enterInPool(uint256 _amount) external;\n\n    function leaveFromPoolInPending(uint256 _amount) external;\n\n    function leaveFromPending() external;\n\n    function harvest(address _to) external;\n\n    function lpTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external;\n\n    function riskPool() external view returns (address);\n}\n"
24     },
25     "contracts/interfaces/ISyntheticSSRPFactory.sol": {
26       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.0;\n\ninterface ISyntheticSSRPFactory {\n    function newSyntheticSSRP(address _owner, address _lpToken) external returns (address);\n}\n"
27     },
28     "contracts/interfaces/IRewarder.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\ninterface IRewarder {\n    function currency() external view returns (address);\n\n    function onReward(address to, uint256 unoAmount) external payable returns (uint256);\n}\n"
30     },
31     "contracts/interfaces/IRiskPool.sol": {
32       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.0;\n\ninterface IRiskPool {\n    function enter(address _from, uint256 _amount) external;\n\n    function leaveFromPoolInPending(address _to, uint256 _amount) external;\n\n    function leaveFromPending(address _to) external returns (uint256, uint256);\n\n    function cancelWithrawRequest(address _to) external returns (uint256, uint256);\n\n    function policyClaim(address _to, uint256 _amount) external returns (uint256 realClaimAmount);\n\n    function migrateLP(\n        address _to,\n        address _migrateTo,\n        bool _isUnLocked\n    ) external returns (uint256);\n\n    function setMinLPCapital(uint256 _minLPCapital) external;\n\n    function currency() external view returns (address);\n\n    function getTotalWithdrawRequestAmount() external view returns (uint256);\n\n    function getWithdrawRequest(address _to)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function lpPriceUno() external view returns (uint256);\n}\n"
33     },
34     "contracts/libraries/TransferHelper.sol": {
35       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.0;\n\n// from Uniswap TransferHelper library\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper::safeApprove: approve failed\");\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper::safeTransfer: transfer failed\");\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper::transferFrom: transferFrom failed\");\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"TransferHelper::safeTransferETH: ETH transfer failed\");\n    }\n}\n"
36     }
37   },
38   "settings": {
39     "optimizer": {
40       "enabled": true,
41       "runs": 500
42     },
43     "outputSelection": {
44       "*": {
45         "*": [
46           "evm.bytecode",
47           "evm.deployedBytecode",
48           "devdoc",
49           "userdoc",
50           "metadata",
51           "abi"
52         ]
53       }
54     },
55     "metadata": {
56       "useLiteralContent": true
57     },
58     "libraries": {}
59   }
60 }}