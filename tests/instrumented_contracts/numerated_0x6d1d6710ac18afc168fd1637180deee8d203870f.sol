1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "berlin",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "enabled": true,
12       "runs": 1000000
13     },
14     "remappings": [],
15     "outputSelection": {
16       "*": {
17         "*": [
18           "evm.bytecode",
19           "evm.deployedBytecode",
20           "abi"
21         ]
22       }
23     }
24   },
25   "sources": {
26     "@openzeppelin/contracts/access/Ownable.sol": {
27       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
28     },
29     "@openzeppelin/contracts/math/SafeMath.sol": {
30       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
31     },
32     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
33       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
34     },
35     "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
36       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
37     },
38     "@openzeppelin/contracts/utils/Address.sol": {
39       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
40     },
41     "@openzeppelin/contracts/utils/Context.sol": {
42       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
43     },
44     "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
45       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
46     },
47     "contracts/interfaces/uniswap/IUniswapV2Pair.sol": {
48       "content": "/*\n * Copyright (C) 2020-2021 The Wolfpack\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\n *\n * This file is derived from Uniswap, available under the GNU General Public\n * License 3.0. https://uniswap.org/\n *\n * SPDX-License-Identifier: Apache-2.0 AND GPL-3.0-or-later\n * See the file LICENSES/README.md for more information.\n */\n\npragma solidity >=0.6.0;\n\ninterface IUniswapV2Pair {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  // solhint-disable-next-line func-name-mixedcase\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  // solhint-disable-next-line func-name-mixedcase\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n"
49     },
50     "contracts/src/investment/UniV2StakeFarm.sol": {
51       "content": "/*\n * Copyright (C) 2020-2021 The Wolfpack\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\n *\n * SPDX-License-Identifier: Apache-2.0\n * See the file LICENSES/README.md for more information.\n */\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport './interfaces/IController.sol';\nimport './interfaces/IFarm.sol';\nimport './interfaces/IStakeFarm.sol';\nimport '../../interfaces/uniswap/IUniswapV2Pair.sol';\n\ncontract UniV2StakeFarm is IFarm, IStakeFarm, Ownable, ReentrancyGuard {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  /* ========== STATE VARIABLES ========== */\n\n  IUniswapV2Pair public stakingToken;\n  uint256 public override periodFinish = 0;\n  uint256 public rewardRate = 0;\n  uint256 public rewardsDuration = 7 days;\n  uint256 public lastUpdateTime;\n  uint256 public rewardPerTokenStored;\n  uint256 private availableRewards;\n\n  mapping(address => uint256) public userRewardPerTokenPaid;\n  mapping(address => uint256) public rewards;\n  // TODO: Remove next 2 lines after dapp launch (special reward condition)\n  mapping(address => uint256) private firstStakeTime;\n  uint256 private constant ETH_LIMIT = 2e17;\n\n  uint256 private _totalSupply;\n  mapping(address => uint256) private _balances;\n\n  // Unique name of this farm instance, used in controller\n  string private _farmName;\n  // Uniswap route to get price for token 0 in pair\n  IUniswapV2Pair public immutable route;\n  // The address of the controller\n  IController public controller;\n  // The direction of the uniswap pairs\n  uint8 public pairDirection;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(\n    address _owner,\n    string memory _name,\n    address _stakingToken,\n    address _rewardToken,\n    address _controller,\n    address _route\n  ) {\n    _farmName = _name;\n    stakingToken = IUniswapV2Pair(_stakingToken);\n    controller = IController(_controller);\n    route = IUniswapV2Pair(_route);\n\n    address routeLink;\n\n    /**\n     * @dev Calculate the sort order of the keys once to save gas in further steps\n     *\n     * Our token sort order is:\n     * - stakeToken: token0[routeLink], token1[rewardToken]\n     * - route:      token0[routeLink], token1[stableCoin]\n     *\n     * If the sort order differs, we set one bit for each of both\n     */\n    if (stakingToken.token0() == _rewardToken) {\n      pairDirection = 1;\n      routeLink = stakingToken.token1();\n    } else routeLink = stakingToken.token0();\n\n    if (\n      address(_route) != address(0) &&\n      IUniswapV2Pair(_route).token1() == routeLink\n    ) pairDirection |= 2;\n    transferOwnership(_owner);\n  }\n\n  /* ========== VIEWS ========== */\n\n  function farmName() external view override returns (string memory) {\n    return _farmName;\n  }\n\n  function totalSupply() external view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account) external view returns (uint256) {\n    return _balances[account];\n  }\n\n  function lastTimeRewardApplicable() public view returns (uint256) {\n    // solhint-disable-next-line not-rely-on-time\n    return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n  }\n\n  function rewardPerToken() public view returns (uint256) {\n    if (_totalSupply == 0) {\n      return rewardPerTokenStored;\n    }\n    return\n      rewardPerTokenStored.add(\n        lastTimeRewardApplicable()\n          .sub(lastUpdateTime)\n          .mul(rewardRate)\n          .mul(1e18)\n          .div(_totalSupply)\n      );\n  }\n\n  function earned(address account) public view returns (uint256) {\n    return\n      _balances[account]\n        .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n        .div(1e18)\n        .add(rewards[account]);\n  }\n\n  function getRewardForDuration() external view returns (uint256) {\n    return rewardRate.mul(rewardsDuration);\n  }\n\n  function getUIData(address _user) external view returns (uint256[9] memory) {\n    (uint112 reserve0, uint112 reserve1, uint256 price) = _getTokenUiData();\n    uint256[9] memory result =\n      [\n        // Pool\n        stakingToken.totalSupply(),\n        (uint256(reserve0)),\n        (uint256(reserve1)),\n        price,\n        // Stake\n        _totalSupply,\n        _balances[_user],\n        rewardsDuration,\n        rewardRate.mul(rewardsDuration),\n        earned(_user)\n      ];\n    return result;\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  function stake(uint256 amount)\n    external\n    override\n    nonReentrant\n    updateReward(msg.sender)\n  {\n    require(amount > 0, 'Cannot stake 0');\n\n    /*(uint256 fee) = */\n    controller.onDeposit(amount);\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[msg.sender] = _balances[msg.sender].add(amount);\n    IERC20(address(stakingToken)).safeTransferFrom(\n      msg.sender,\n      address(this),\n      amount\n    );\n\n    // TODO: Remove after launch\n    if (\n      firstStakeTime[msg.sender] == 0 &&\n      _ethAmount(_balances[msg.sender]) >= ETH_LIMIT\n      // solhint-disable-next-line not-rely-on-time\n    ) firstStakeTime[msg.sender] = block.timestamp;\n\n    emit Staked(msg.sender, amount);\n  }\n\n  function unstake(uint256 amount)\n    public\n    override\n    nonReentrant\n    updateReward(msg.sender)\n  {\n    require(amount > 0, 'Cannot withdraw 0');\n\n    /*(uint256 fee) = */\n    controller.onWithdraw(amount);\n\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\n    IERC20(address(stakingToken)).safeTransfer(msg.sender, amount);\n\n    // TODO: Remove after launch\n    if (\n      firstStakeTime[msg.sender] > 0 &&\n      (_balances[msg.sender] == 0 ||\n        _ethAmount(_balances[msg.sender]) < ETH_LIMIT)\n    ) firstStakeTime[msg.sender] = 0;\n\n    emit Unstaked(msg.sender, amount);\n  }\n\n  function transfer(address recipient, uint256 amount)\n    external\n    override\n    updateReward(msg.sender)\n    updateReward(recipient)\n  {\n    require(recipient != address(0), 'invalid address');\n    require(amount > 0, 'zero amount');\n\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfered(msg.sender, recipient, amount);\n  }\n\n  function getReward() public override nonReentrant updateReward(msg.sender) {\n    uint256 reward = rewards[msg.sender];\n    if (reward > 0) {\n      rewards[msg.sender] = 0;\n      availableRewards = availableRewards.sub(reward);\n      controller.payOutRewards(msg.sender, reward);\n      emit RewardPaid(msg.sender, reward);\n    }\n  }\n\n  function exit() external override {\n    unstake(_balances[msg.sender]);\n    getReward();\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  function setController(address newController)\n    external\n    override\n    onlyController\n  {\n    controller = IController(newController);\n    emit ControllerChanged(newController);\n  }\n\n  function notifyRewardAmount(uint256 reward)\n    external\n    override\n    onlyController\n    updateReward(address(0))\n  {\n    // solhint-disable-next-line not-rely-on-time\n    if (block.timestamp >= periodFinish) {\n      rewardRate = reward.div(rewardsDuration);\n    } else {\n      // solhint-disable-next-line not-rely-on-time\n      uint256 remaining = periodFinish.sub(block.timestamp);\n      uint256 leftover = remaining.mul(rewardRate);\n      rewardRate = reward.add(leftover).div(rewardsDuration);\n    }\n    availableRewards = availableRewards.add(reward);\n\n    // Ensure the provided reward amount is not more than the balance in the\n    // contract.\n    //\n    // This keeps the reward rate in the right range, preventing overflows due\n    // to very high values of rewardRate in the earned and rewardsPerToken\n    // functions.\n    //\n    // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n    //\n    require(\n      rewardRate <= availableRewards.div(rewardsDuration),\n      'Provided reward too high'\n    );\n\n    // solhint-disable-next-line not-rely-on-time\n    lastUpdateTime = block.timestamp;\n    // solhint-disable-next-line not-rely-on-time\n    periodFinish = block.timestamp.add(rewardsDuration);\n\n    emit RewardAdded(reward);\n  }\n\n  // We don't have any rebalancing here\n  // solhint-disable-next-line no-empty-blocks\n  function rebalance() external override onlyController {}\n\n  // Added to support recovering LP Rewards from other systems to be distributed to holders\n  function recoverERC20(address tokenAddress, uint256 tokenAmount)\n    external\n    onlyOwner\n  {\n    // Cannot recover the staking token or the rewards token\n    require(\n      tokenAddress != address(stakingToken),\n      'pool tokens not recoverable'\n    );\n    IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  function setRewardsDuration(uint256 _rewardsDuration)\n    external\n    override\n    onlyOwner\n  {\n    require(\n      // solhint-disable-next-line not-rely-on-time\n      periodFinish == 0 || block.timestamp > periodFinish,\n      'reward period not finished'\n    );\n    rewardsDuration = _rewardsDuration;\n    emit RewardsDurationUpdated(rewardsDuration);\n  }\n\n  /* ========== PRIVATE ========== */\n\n  function _ethAmount(uint256 amountToken) private view returns (uint256) {\n    (uint112 reserve0, uint112 reserve1, ) = stakingToken.getReserves();\n\n    // RouteLink is token1, swap\n    if ((pairDirection & 1) != 0) reserve0 = reserve1;\n\n    return (uint256(reserve0).mul(amountToken)).div(stakingToken.totalSupply());\n  }\n\n  /**\n   * @dev Returns the reserves in order: ETH -> Token, ETH/stable\n   */\n  function _getTokenUiData()\n    internal\n    view\n    returns (\n      uint112,\n      uint112,\n      uint256\n    )\n  {\n    (uint112 reserve0, uint112 reserve1, ) = stakingToken.getReserves();\n    (uint112 reserve0R, uint112 reserve1R, ) =\n      address(route) != address(0) ? route.getReserves() : (1, 1, 0);\n\n    uint112 swap;\n\n    // RouteLink is token1, swap\n    if ((pairDirection & 1) != 0) {\n      swap = reserve0;\n      reserve0 = reserve1;\n      reserve1 = swap;\n    }\n\n    // RouteLink is token1, swap\n    if ((pairDirection & 2) != 0) {\n      swap = reserve0R;\n      reserve0R = reserve1R;\n      reserve1R = swap;\n    }\n\n    return (reserve0, reserve1, uint256(reserve0R).mul(1e18).div(reserve1R));\n  }\n\n  /* ========== MODIFIERS ========== */\n\n  modifier onlyController {\n    require(_msgSender() == address(controller), 'not controller');\n    _;\n  }\n\n  modifier updateReward(address account) {\n    rewardPerTokenStored = rewardPerToken();\n    lastUpdateTime = lastTimeRewardApplicable();\n    if (account != address(0)) {\n      rewards[account] = earned(account);\n      userRewardPerTokenPaid[account] = rewardPerTokenStored;\n    }\n    _;\n  }\n\n  /* ========== EVENTS ========== */\n\n  event RewardAdded(uint256 reward);\n  event Staked(address indexed user, uint256 amount);\n  event Unstaked(address indexed user, uint256 amount);\n  event Transfered(address indexed from, address indexed to, uint256 amount);\n  event RewardPaid(address indexed user, uint256 reward);\n  event RewardsDurationUpdated(uint256 newDuration);\n  event Recovered(address token, uint256 amount);\n  event ControllerChanged(address newController);\n}\n"
52     },
53     "contracts/src/investment/interfaces/IController.sol": {
54       "content": "/*\n * Copyright (C) 2020-2021 The Wolfpack\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\n *\n * SPDX-License-Identifier: Apache-2.0\n * See the file LICENSES/README.md for more information.\n */\n\npragma solidity >=0.6.0 <0.8.0;\n\ninterface IController {\n  /**\n   * @dev Revert on failure, return deposit fee in 1e-18/fee notation on success\n   */\n  function onDeposit(uint256 amount) external view returns (uint256 fee);\n\n  /**\n   * @dev Revert on failure, return withdrawal fee in 1e-18/fee notation on success\n   */\n  function onWithdraw(uint256 amount) external view returns (uint256 fee);\n\n  /**\n   * @dev Distribute rewards to sender and fee to internal contracts\n   */\n  function payOutRewards(address recipient, uint256 amount) external;\n}\n"
55     },
56     "contracts/src/investment/interfaces/IFarm.sol": {
57       "content": "/*\n * Copyright (C) 2020-2021 The Wolfpack\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\n *\n * SPDX-License-Identifier: Apache-2.0\n * See the file LICENSES/README.md for more information.\n */\n\npragma solidity >=0.6.0 <0.8.0;\n\ninterface IFarm {\n  /**\n   * @dev Return a unique farm name\n   */\n  function farmName() external view returns (string memory);\n\n  /**\n   * @dev Return when reward period is finished (UTC timestamp)\n   */\n  function periodFinish() external view returns (uint256);\n\n  /**\n   * @dev Sets a new controller, can only called by current controller\n   */\n  function setController(address newController) external;\n\n  /**\n   * @dev This function must be called initially and close at the time the\n   * reward period ends\n   */\n  function notifyRewardAmount(uint256 reward) external;\n\n  /**\n   * @dev Set the duration of farm rewards, to continue rewards,\n   * notifyRewardAmount() has to called for the next period\n   */\n  function setRewardsDuration(uint256 _rewardsDuration) external;\n\n  /**\n   * @dev Rebalance strategies (if implemented)\n   */\n  function rebalance() external;\n}\n"
58     },
59     "contracts/src/investment/interfaces/IStakeFarm.sol": {
60       "content": "/*\n * Copyright (C) 2020-2021 The Wolfpack\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\n *\n * SPDX-License-Identifier: Apache-2.0\n * See the file LICENSES/README.md for more information.\n */\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title IStakeFarm\n *\n * @dev IStakeFarm is the business logic interface to staking farms.\n */\n\ninterface IStakeFarm {\n  /**\n   * @dev Stake amount of ERC20 tokens and earn rewards\n   */\n  function stake(uint256 amount) external;\n\n  /**\n   * @dev Unstake amount of previous staked tokens, rewards will not be claimed\n   */\n  function unstake(uint256 amount) external;\n\n  /**\n   * @dev Claim rewards harvested during stake time\n   */\n  function getReward() external;\n\n  /**\n   * @dev Unstake and getRewards in a single step\n   */\n  function exit() external;\n\n  /**\n   * @dev Transfer amount of stake from msg.sender to recipient.\n   */\n  function transfer(address recipient, uint256 amount) external;\n}\n"
61     }
62   }
63 }}