1 {{
2   "language": "Solidity",
3   "sources": {
4     "src/SalePlatform.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"./interfaces/IQuantumArt.sol\";\nimport \"./interfaces/IQuantumMintPass.sol\";\nimport \"./interfaces/IQuantumUnlocked.sol\";\nimport \"./interfaces/IQuantumKeyRing.sol\";\nimport \"./ContinuousDutchAuction.sol\";\nimport \"@rari-capital/solmate/src/auth/Auth.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\ncontract SalePlatform is ContinuousDutchAuction, ReentrancyGuard, Auth {\n    using BitMaps for BitMaps.BitMap;\n    using Strings for uint256;\n\n    struct Sale {\n        uint128 price;\n        uint64 start;\n        uint64 limit;\n    }\n\n    struct MPClaim {\n        uint64 mpId;\n        uint64 start;\n        uint128 price;\n    }\n\n    struct Whitelist {\n        uint192 price;\n        uint64 start;\n        bytes32 merkleRoot;\n    }\n\n    event Purchased(uint256 indexed dropId, uint256 tokenId, address to);\n    event DropCreated(uint256 dropId);\n\n    //mapping dropId => struct\n    mapping (uint256 => Sale) public sales;\n    mapping (uint256 => MPClaim) public mpClaims;\n    mapping (uint256 => Whitelist) public whitelists;\n    uint256 public defaultArtistCut; //10000 * percentage\n    IQuantumArt public quantum;\n    IQuantumMintPass public mintpass;\n    IQuantumUnlocked public keyUnlocks;\n    IQuantumKeyRing public keyRing;\n    address[] public privilegedContracts;\n\n    BitMaps.BitMap private _disablingLimiter;\n    mapping (uint256 => BitMaps.BitMap) private _claimedWL;\n    mapping (address => BitMaps.BitMap) private _alreadyBought;\n    mapping (uint256 => uint256) private _overridedArtistCut; // dropId -> cut\n    address payable private _quantumTreasury;\n\n    //TODO: Better drop mechanism\n    struct UnlockSale {\n        uint128 price;\n        uint64 start;\n        uint64 period;\n        address artist;\n        uint256 overrideArtistcut;\n        uint256[] enabledKeyRanges;\n    }\n\n    uint private constant SEPARATOR = 10**4;\n    uint128 private _nextUnlockDropId;\n    //TODO: CLEAN UP\n    mapping(uint256 => mapping(uint256 => bool)) keyUnlockClaims;\n    //TODO: Seperate sales mechanisms for target sales is not right.\n    mapping (uint256 => UnlockSale) public keySales;\n\n    constructor(\n        address deployedQuantum,\n        address deployedMP,\n        address deployedKeyRing,\n        address deployedUnlocks,\n        address admin,\n        address payable treasury,\n        address authority) Auth(admin, Authority(authority)) {\n        quantum = IQuantumArt(deployedQuantum);\n        mintpass = IQuantumMintPass(deployedMP);\n        keyRing = IQuantumKeyRing(deployedKeyRing);\n        keyUnlocks = IQuantumUnlocked(deployedUnlocks);\n        _quantumTreasury = treasury;\n        defaultArtistCut = 8000; //default 80% for artist\n    }\n\n    modifier checkCaller {\n        require(msg.sender.code.length == 0, \"Contract forbidden\");\n        _;\n    }\n\n    modifier isFirstTime(uint256 dropId) {\n        if (!_disablingLimiter.get(dropId)) {\n            require(!_alreadyBought[msg.sender].get(dropId), string(abi.encodePacked(\"Already bought drop \", dropId.toString())));\n            _alreadyBought[msg.sender].set(dropId);\n        }\n        _;\n    }\n\n    function setPrivilegedContracts(address[] calldata contracts) requiresAuth public {\n        privilegedContracts = contracts;\n    }\n\n    function withdraw(address payable to) requiresAuth public {\n        Address.sendValue(to, address(this).balance);\n    }\n\n    function premint(uint256 dropId, address[] calldata recipients) requiresAuth public {\n        for(uint256 i = 0; i < recipients.length; i++) {\n            uint256 tokenId = quantum.mintTo(dropId, recipients[i]);\n            emit Purchased(dropId, tokenId, recipients[i]);\n        }\n    }\n\n    function setMintpass(address deployedMP) requiresAuth public {\n        mintpass = IQuantumMintPass(deployedMP);\n    }\n\n    function setQuantum(address deployedQuantum) requiresAuth public {\n        quantum = IQuantumArt(deployedQuantum);\n    }\n\n    function setKeyRing(address deployedKeyRing) requiresAuth public {\n        keyRing = IQuantumKeyRing(deployedKeyRing);\n    }\n\n    function setKeyUnlocks(address deployedUnlocks) requiresAuth public {\n        keyUnlocks = IQuantumUnlocked(deployedUnlocks);\n    }\n\n    function setDefaultArtistCut(uint256 cut) requiresAuth public {\n        defaultArtistCut = cut;\n    }\n    \n    function createSale(uint256 dropId, uint128 price, uint64 start, uint64 limit) requiresAuth public {\n        sales[dropId] = Sale(price, start, limit);\n    }\n\n    function createMPClaim(uint256 dropId, uint64 mpId, uint64 start, uint128 price) requiresAuth public {\n        mpClaims[dropId] = MPClaim(mpId, start, price);\n    }\n\n    function createWLClaim(uint256 dropId, uint192 price, uint64 start, bytes32 root) requiresAuth public {\n        whitelists[dropId] = Whitelist(price, start, root);\n    }\n\n    function flipUint64(uint64 x) internal pure returns (uint64) {\n        return x > 0 ? 0 : type(uint64).max;\n    }\n\n    function flipSaleState(uint256 dropId) requiresAuth public {\n        sales[dropId].start = flipUint64(sales[dropId].start);\n    }\n\n    function flipMPClaimState(uint256 dropId) requiresAuth public {\n        mpClaims[dropId].start = flipUint64(mpClaims[dropId].start);\n    }\n\n    function flipWLState(uint256 dropId) requiresAuth public {\n        whitelists[dropId].start = flipUint64(whitelists[dropId].start);\n    }\n\n    function flipLimiterForDrop(uint256 dropId) requiresAuth public {\n        if (_disablingLimiter.get(dropId)) {\n            _disablingLimiter.unset(dropId);\n        } else {\n            _disablingLimiter.set(dropId);\n        }\n    }\n\n    function overrideArtistcut(uint256 dropId, uint256 cut) requiresAuth public {\n        _overridedArtistCut[dropId] = cut;\n    }\n\n    function overrideUnlockArtistCut(uint256 dropId, uint256 cut) requiresAuth public {\n        keySales[dropId].overrideArtistcut = cut;\n    }\n\n    function setAuction(\n        uint256 auctionId,\n        uint256 startingPrice,\n        uint128 decreasingConstant,\n        uint64 start,\n        uint64 period\n    ) public override requiresAuth {\n        super.setAuction(auctionId, startingPrice, decreasingConstant, start, period);\n    }\n\n    function curatedPayout(address artist, uint256 dropId, uint256 amount) internal {\n        uint256 artistCut = _overridedArtistCut[dropId] == 0 ? defaultArtistCut : _overridedArtistCut[dropId];\n        uint256 payout_ = (amount*artistCut)/10000;\n        Address.sendValue(payable(artist), payout_);\n        Address.sendValue(_quantumTreasury, amount - payout_);\n    }\n\n    function genericPayout(address artist, uint256 amount, uint256 cut) internal {\n        uint256 artistCut = cut == 0 ? defaultArtistCut : cut;\n        uint256 payout_ = (amount*artistCut)/10000;\n        Address.sendValue(payable(artist), payout_);\n        Address.sendValue(_quantumTreasury, amount - payout_);\n    }\n\n    function _isPrivileged(address user) internal view returns (bool) {\n        uint256 length = privilegedContracts.length;\n        unchecked {\n            for(uint i; i < length; i++) {\n                /// @dev using this interface because has balanceOf\n                if (IQuantumArt(privilegedContracts[i]).balanceOf(user) > 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function purchase(uint256 dropId, uint256 amount) nonReentrant checkCaller isFirstTime(dropId) payable public {\n        Sale memory sale = sales[dropId];\n        require(block.timestamp >= sale.start, \"PURCHASE:SALE INACTIVE\");\n        require(amount <= sale.limit, \"PURCHASE:OVER LIMIT\");\n        require(msg.value == amount * sale.price, \"PURCHASE:INCORRECT MSG.VALUE\");\n        for(uint256 i = 0; i < amount; i++) {\n            uint256 tokenId = quantum.mintTo(dropId, msg.sender);\n            emit Purchased(dropId, tokenId, msg.sender);\n        }\n        curatedPayout(quantum.getArtist(dropId), dropId, msg.value);\n    }\n\n\n    function purchaseThroughAuction(uint256 dropId) nonReentrant checkCaller isFirstTime(dropId) payable public {\n        Auction memory auction = _auctions[dropId];\n        // if 5 minutes before public auction\n        // if holder -> special treatment\n        uint256 userPaid = auction.startingPrice;\n        if (\n            block.timestamp <= auction.start && \n            block.timestamp >= auction.start - 300 &&\n            _isPrivileged(msg.sender)\n        ) {\n            require(msg.value == userPaid, \"PURCHASE:INCORRECT MSG.VALUE\");\n\n        } else {\n            userPaid = verifyBid(dropId);\n        }\n        uint256 tokenId = quantum.mintTo(dropId, msg.sender);\n        emit Purchased(dropId, tokenId, msg.sender);\n        curatedPayout(quantum.getArtist(dropId), dropId, userPaid);\n    }\n\n    \n    function unlockWithKey(uint256 keyId, uint128 dropId, uint256 variant) nonReentrant checkCaller payable public {\n        require(keyRing.ownerOf(keyId) == msg.sender, \"PURCHASE:NOT KEY OWNER\");\n        require(!keyUnlockClaims[dropId][keyId], \"PURCHASE:KEY ALREADY USED\");\n        require(variant>0 && variant<13, \"PURCHASE:INVALID VARIANT\");\n\n        UnlockSale memory sale = keySales[dropId];\n        //Check is a valid key range (to limit to particular keys)\n        bool inRange = false;\n        if (sale.enabledKeyRanges.length > 0) {\n            for (uint256 i=0; i<sale.enabledKeyRanges.length; i++) {\n                if ((keyId >= (sale.enabledKeyRanges[i] * SEPARATOR)) && (keyId < (((sale.enabledKeyRanges[i]+1) * SEPARATOR)-1))) inRange = true;\n            }\n        } \n        else inRange = true;\n        require(inRange, \"PURCHASE:SALE NOT AVAILABLE TO THIS KEY\");\n        require(block.timestamp >= sale.start, \"PURCHASE:SALE NOT STARTED\");\n        require(block.timestamp <= (sale.start + sale.period), \"PURCHASE:SALE EXPIRED\");\n        require(msg.value == sale.price, \"PURCHASE:INCORRECT MSG.VALUE\");\n\n        uint256 tokenId = keyUnlocks.mint(msg.sender, dropId, variant);\n        keyUnlockClaims[dropId][keyId] = true;\n        emit Purchased(dropId, tokenId, msg.sender);\n        genericPayout(sale.artist, msg.value, sale.overrideArtistcut);\n    }\n\n    function createUnlockSale(uint128 price, uint64 start, uint64 period, address artist, uint256[] calldata enabledKeyRanges) requiresAuth public {\n        emit DropCreated(_nextUnlockDropId);\n        uint256[] memory blankRanges;\n        keySales[_nextUnlockDropId++] = UnlockSale(price, start, period, artist, 0, blankRanges);\n        for (uint i=0; i<enabledKeyRanges.length; i++) keySales[_nextUnlockDropId-1].enabledKeyRanges.push(enabledKeyRanges[i]);\n    }\n\n    function isKeyUsed(uint256 dropId, uint256 keyId) public view returns (bool) {\n        return keyUnlockClaims[dropId][keyId];\n    }\n\n    function claimWithMintPass(uint256 dropId, uint256 amount) nonReentrant payable public {\n        MPClaim memory mpClaim = mpClaims[dropId];\n        require(block.timestamp >= mpClaim.start, \"MP: CLAIMING INACTIVE\");\n        require(msg.value == amount * mpClaim.price, \"MP:WRONG MSG.VALUE\");\n        mintpass.burnFromRedeem(msg.sender, mpClaim.mpId, amount); //burn mintpasses\n        for(uint256 i = 0; i < amount; i++) {\n            uint256 tokenId = quantum.mintTo(dropId, msg.sender);\n            emit Purchased(dropId, tokenId, msg.sender);\n        }\n        if (msg.value > 0) curatedPayout(quantum.getArtist(dropId), dropId, msg.value);\n    }\n\n    function purchaseThroughWhitelist(uint256 dropId, uint256 amount, uint256 index, bytes32[] calldata merkleProof) nonReentrant external payable {\n        Whitelist memory whitelist = whitelists[dropId];\n        require(block.timestamp >= whitelist.start, \"WL:INACTIVE\");\n        require(msg.value == whitelist.price * amount, \"WL: INVALID MSG.VALUE\");\n        require(!_claimedWL[dropId].get(index), \"WL:ALREADY CLAIMED\");\n        bytes32 node = keccak256(abi.encodePacked(msg.sender, amount, index));\n        require(MerkleProof.verify(merkleProof, whitelist.merkleRoot, node),\"WL:INVALID PROOF\");\n        _claimedWL[dropId].set(index);\n        uint256 tokenId = quantum.mintTo(dropId, msg.sender);\n        emit Purchased(dropId, tokenId, msg.sender);\n        curatedPayout(quantum.getArtist(dropId), dropId, msg.value);\n    }\n\n    function isWLClaimed(uint256 dropId, uint256 index) public view returns (bool) {\n        return _claimedWL[dropId].get(index);\n    }\n}"
6     },
7     "src/interfaces/IQuantumArt.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IQuantumArt {\n    function mintTo(uint256 dropId, address artist) external returns (uint256);\n    function burn(uint256 tokenId) external;\n    function getArtist(uint256 dropId) external view returns (address);\n    function balanceOf(address user) external view returns (uint256);\n}\n"
9     },
10     "src/interfaces/IQuantumMintPass.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IQuantumMintPass {\n    function burnFromRedeem(address user, uint256 mpId, uint256 amount) external;\n}\n"
12     },
13     "src/interfaces/IQuantumUnlocked.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IQuantumUnlocked {\n    function mint(address to, uint128 dropId, uint256 variant) external returns (uint256);\n}"
15     },
16     "src/interfaces/IQuantumKeyRing.sol": {
17       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IQuantumKeyRing {\n    function make(address to, uint256 id, uint256 amount) external;\n    function ownerOf(uint256 tokenId) external view returns (address);\n}"
18     },
19     "src/ContinuousDutchAuction.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nabstract contract ContinuousDutchAuction {\n\n    struct Auction {\n        uint256 startingPrice;\n        uint128 decreasingConstant;\n        uint64 start;\n        uint64 period; //period in seconds : MAX IS 18 HOURS\n    }\n\n    mapping (uint => Auction) internal _auctions;\n\n    function auctions(uint256 auctionId) public view returns (\n        uint256 startingPrice,\n        uint128 decreasingConstant,\n        uint64 start,\n        uint64 period,\n        bool active\n    ) {\n        Auction memory auction = _auctions[auctionId];\n        startingPrice = auction.startingPrice;\n        decreasingConstant = auction.decreasingConstant;\n        start = auction.start;\n        period = auction.period;\n        active = start > 0 && block.timestamp >= start;\n    }\n\n    function setAuction(\n        uint256 auctionId,\n        uint256 startingPrice,\n        uint128 decreasingConstant,\n        uint64 start,\n        uint64 period\n    ) virtual public {\n        unchecked {\n            require(startingPrice - decreasingConstant * period <= startingPrice, \"setAuction: floor price underflow\");\n        }\n        _auctions[auctionId] = Auction(startingPrice, decreasingConstant, start, period);\n    }\n\n    function getPrice(uint256 auctionId) virtual public view returns (uint256 price) {\n        Auction memory auction = _auctions[auctionId];\n        //only compute correct price if necessary\n        if (block.timestamp < auction.start) price = auction.startingPrice;\n        else if (block.timestamp >= auction.start + auction.period) price = auction.startingPrice - auction.period * auction.decreasingConstant;\n        else price = auction.startingPrice - (auction.decreasingConstant * (block.timestamp - auction.start));\n    }\n\n    function verifyBid(uint256 auctionId) internal returns (uint256) {\n        Auction memory auction = _auctions[auctionId];\n        require(auction.start > 0, \"AUCTION:NOT CREATED\");\n        require(block.timestamp >= auction.start, \"PURCHASE:AUCTION NOT STARTED\");\n        uint256 pricePaid = getPrice(auctionId);\n        require(msg.value >= pricePaid, \"PURCHASE:INCORRECT MSG.VALUE\");\n        if (msg.value - pricePaid > 0) Address.sendValue(payable(msg.sender), msg.value-pricePaid); //refund difference\n        return pricePaid;\n    }\n}"
21     },
22     "@rari-capital/solmate/src/auth/Auth.sol": {
23       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\nabstract contract Auth {\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    address public owner;\n\n    Authority public authority;\n\n    constructor(address _owner, Authority _authority) {\n        owner = _owner;\n        authority = _authority;\n\n        emit OwnerUpdated(msg.sender, _owner);\n        emit AuthorityUpdated(msg.sender, _authority);\n    }\n\n    modifier requiresAuth() {\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\n    }\n\n    function setAuthority(Authority newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\n\n        authority = newAuthority;\n\n        emit AuthorityUpdated(msg.sender, newAuthority);\n    }\n\n    function setOwner(address newOwner) public virtual requiresAuth {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\ninterface Authority {\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) external view returns (bool);\n}\n"
24     },
25     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
27     },
28     "@openzeppelin/contracts/utils/Strings.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
30     },
31     "@openzeppelin/contracts/utils/structs/BitMaps.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/BitMaps.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\n * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\n */\nlibrary BitMaps {\n    struct BitMap {\n        mapping(uint256 => uint256) _data;\n    }\n\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        return bitmap._data[bucket] & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index` to the boolean `value`.\n     */\n    function setTo(\n        BitMap storage bitmap,\n        uint256 index,\n        bool value\n    ) internal {\n        if (value) {\n            set(bitmap, index);\n        } else {\n            unset(bitmap, index);\n        }\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] |= mask;\n    }\n\n    /**\n     * @dev Unsets the bit at `index`.\n     */\n    function unset(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] &= ~mask;\n    }\n}\n"
33     },
34     "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
36     },
37     "@openzeppelin/contracts/utils/Address.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
39     }
40   },
41   "settings": {
42     "optimizer": {
43       "enabled": true,
44       "runs": 10000
45     },
46     "outputSelection": {
47       "*": {
48         "*": [
49           "evm.bytecode",
50           "evm.deployedBytecode",
51           "devdoc",
52           "userdoc",
53           "metadata",
54           "abi"
55         ]
56       }
57     },
58     "libraries": {}
59   }
60 }}