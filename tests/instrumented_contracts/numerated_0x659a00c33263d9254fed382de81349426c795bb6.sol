1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/l1/L1DAIBridge.sol": {
5       "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.6;\n\ninterface TokenLike {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool success);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface StarkNetLike {\n    function sendMessageToL2(\n        uint256 to,\n        uint256 selector,\n        uint256[] calldata payload\n    ) external returns (bytes32);\n\n    function consumeMessageFromL2(\n        uint256 from,\n        uint256[] calldata payload\n    ) external returns (bytes32);\n\n    function startL1ToL2MessageCancellation(\n        uint256 toAddress,\n        uint256 selector,\n        uint256[] calldata payload,\n        uint256 nonce\n    ) external;\n\n    function cancelL1ToL2Message(\n        uint256 toAddress,\n        uint256 selector,\n        uint256[] calldata payload,\n        uint256 nonce\n    ) external;\n}\n\ncontract L1DAIBridge {\n    // --- Auth ---\n    mapping(address => uint256) public wards;\n\n    function rely(address usr) external auth {\n        wards[usr] = 1;\n        emit Rely(usr);\n    }\n\n    function deny(address usr) external auth {\n        wards[usr] = 0;\n        emit Deny(usr);\n    }\n\n    modifier auth() {\n        require(wards[msg.sender] == 1, \"L1DAIBridge/not-authorized\");\n        _;\n    }\n\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n\n\n    uint256 public isOpen = 1;\n\n    modifier whenOpen() {\n        require(isOpen == 1, \"L1DAIBridge/closed\");\n        _;\n    }\n\n    function close() external auth {\n        isOpen = 0;\n        emit Closed();\n    }\n\n    event Closed();\n\n    address public immutable starkNet;\n    address public immutable dai;\n    uint256 public immutable l2Dai;\n    address public immutable escrow;\n    uint256 public immutable l2DaiBridge;\n\n    uint256 public ceiling = 0;\n    uint256 public maxDeposit = type(uint256).max;\n\n    uint256 constant HANDLE_WITHDRAW = 0;\n\n    // src/starkware/cairo/lang/cairo_constants.py\n    //  2 ** 251 + 17 * 2 ** 192 + 1;\n    uint256 constant SN_PRIME =\n        3618502788666131213697322783095070105623107215331596699973092056135872020481;\n\n    //  from starkware.starknet.compiler.compile import get_selector_from_name\n    //  print(get_selector_from_name('handle_deposit'))\n    uint256 constant DEPOSIT =\n        1285101517810983806491589552491143496277809242732141897358598292095611420389;\n\n    //  print(get_selector_from_name('handle_force_withdrawal'))\n    uint256 constant FORCE_WITHDRAW =\n        1137729855293860737061629600728503767337326808607526258057644140918272132445;\n\n    event LogCeiling(uint256 ceiling);\n    event LogMaxDeposit(uint256 maxDeposit);\n    event LogDeposit(address indexed l1Sender, uint256 amount, uint256 l2Recipient);\n    event LogWithdrawal(address indexed l1Recipient, uint256 amount);\n    event LogForceWithdrawal(address indexed l1Recipient, uint256 amount, uint256 indexed l2Sender);\n    event LogStartDepositCancellation(uint256 indexed l2Receipient, uint256 amount, uint256 nonce);\n    event LogCancelDeposit(\n        uint256 indexed l2Recipient, address l1Recipient, uint256 amount, uint256 nonce\n    );\n\n    constructor(\n        address _starkNet,\n        address _dai,\n        uint256 _l2Dai,\n        address _escrow,\n        uint256 _l2DaiBridge\n    ) {\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n\n        starkNet = _starkNet;\n        dai = _dai;\n        l2Dai = _l2Dai;\n        escrow = _escrow;\n        l2DaiBridge = _l2DaiBridge;\n    }\n\n    function setCeiling(uint256 _ceiling) external auth whenOpen {\n        ceiling = _ceiling;\n        emit LogCeiling(_ceiling);\n    }\n\n    function setMaxDeposit(uint256 _maxDeposit) external auth whenOpen {\n        maxDeposit = _maxDeposit;\n        emit LogMaxDeposit(_maxDeposit);\n    }\n\n    // slither-disable-next-line similar-names\n    function deposit(\n        uint256 amount,\n        uint256 l2Recipient\n    ) external whenOpen {\n        emit LogDeposit(msg.sender, amount, l2Recipient);\n\n        require(l2Recipient != 0 && l2Recipient != l2Dai && l2Recipient < SN_PRIME, \"L1DAIBridge/invalid-address\");\n\n        require(amount <= maxDeposit, \"L1DAIBridge/above-max-deposit\");\n\n        TokenLike(dai).transferFrom(msg.sender, escrow, amount);\n\n        require(\n            TokenLike(dai).balanceOf(escrow) <= ceiling,\n            \"L1DAIBridge/above-ceiling\"\n        );\n\n        uint256[] memory payload = new uint256[](4);\n        payload[0] = l2Recipient;\n        (payload[1], payload[2]) = toSplitUint(amount);\n        payload[3] = uint256(uint160(msg.sender));\n\n        StarkNetLike(starkNet).sendMessageToL2(l2DaiBridge, DEPOSIT, payload);\n    }\n\n    function toSplitUint(uint256 value) internal pure returns (uint256, uint256) {\n      uint256 low = value & ((1 << 128) - 1);\n      uint256 high = value >> 128;\n      return (low, high);\n    }\n\n    // slither-disable-next-line similar-names\n    function withdraw(uint256 amount, address l1Recipient) external {\n        emit LogWithdrawal(l1Recipient, amount);\n\n        uint256[] memory payload = new uint256[](4);\n        payload[0] = HANDLE_WITHDRAW;\n        payload[1] = uint256(uint160(msg.sender));\n        (payload[2], payload[3]) = toSplitUint(amount);\n\n        StarkNetLike(starkNet).consumeMessageFromL2(l2DaiBridge, payload);\n        TokenLike(dai).transferFrom(escrow, l1Recipient, amount);\n    }\n\n    function forceWithdrawal(uint256 amount, uint256 l2Sender) external whenOpen {\n        emit LogForceWithdrawal(msg.sender, amount, l2Sender);\n\n        uint256[] memory payload = new uint256[](4);\n        payload[0] = l2Sender;\n        payload[1] = uint256(uint160(msg.sender));\n        (payload[2], payload[3]) = toSplitUint(amount);\n\n        StarkNetLike(starkNet).sendMessageToL2(l2DaiBridge, FORCE_WITHDRAW, payload);\n    }\n\n    function startDepositCancellation(\n        uint256 amount,\n        uint256 l2Recipient,\n        uint256 nonce\n    ) external {\n        emit LogStartDepositCancellation(l2Recipient, amount, nonce);\n\n        uint256[] memory payload = new uint256[](4);\n        payload[0] = l2Recipient;\n        (payload[1], payload[2]) = toSplitUint(amount);\n        payload[3] = uint256(uint160(msg.sender));\n\n        StarkNetLike(starkNet).startL1ToL2MessageCancellation(l2DaiBridge, DEPOSIT, payload, nonce);\n    }\n\n    function cancelDeposit(\n        uint256 amount,\n        uint256 l2Recipient,\n        // slither-disable-next-line similar-names\n        address l1Recipient,\n        uint256 nonce\n    ) external {\n        emit LogCancelDeposit(l2Recipient, l1Recipient, amount, nonce);\n\n        uint256[] memory payload = new uint256[](4);\n        payload[0] = l2Recipient;\n        (payload[1], payload[2]) = toSplitUint(amount);\n        payload[3] = uint256(uint160(msg.sender));\n\n        StarkNetLike(starkNet).cancelL1ToL2Message(l2DaiBridge, DEPOSIT, payload, nonce);\n        TokenLike(dai).transferFrom(escrow, l1Recipient, amount);\n    }\n}\n"
6     }
7   },
8   "settings": {
9     "metadata": {
10       "bytecodeHash": "none"
11     },
12     "optimizer": {
13       "enabled": true,
14       "runs": 800
15     },
16     "outputSelection": {
17       "*": {
18         "*": [
19           "evm.bytecode",
20           "evm.deployedBytecode",
21           "devdoc",
22           "userdoc",
23           "metadata",
24           "abi"
25         ]
26       }
27     },
28     "libraries": {}
29   }
30 }}