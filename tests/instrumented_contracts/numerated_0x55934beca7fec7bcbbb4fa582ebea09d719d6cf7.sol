1 {"Address.sol":{"content":"pragma solidity 0.5.17;\n\n\n/**\n * @title Address\n * @dev Check if the address is a contract using eip-1052\n */\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 \u0026\u0026 codehash != accountHash);\n    }\n}"},"Context.sol":{"content":"pragma solidity 0.5.17;\n\n\ncontract Context {\n    constructor () internal { }\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n}\n"},"DextokenPool.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity 0.5.17;\n\nimport \"./Math.sol\";\nimport \"./SafeMath.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./ReentrancyGuard.sol\";\nimport \"./IDextokenPool.sol\";\nimport \"./IDextokenFactory.sol\";\nimport \"./LPToken.sol\";\n\n\ncontract DextokenPool is LPToken, IDextokenPool, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    /// AMM fee\n    uint public constant FEE_BASE      = 10**4; // 0.01%\n    uint public constant FEE_FACTOR    = 30;\n\n    IDextokenFactory public factory;\n\n    /// The collateral token\n    IERC20 public WETH;\n\n    /// Pooling\n    uint public totalLiquidity;\n    IERC20 public token0;\n\n    /// Speculative AMM\n    struct AMM {\n        uint Ct;\n        uint Pt;\n        uint Nt;\n        uint lastUpdateTime;\n    }\n\n    /// AMM states\n    AMM private _AMM;\n\n    modifier updatePriceTick() {    \n        _;\n        /// step the price tick (t+1)\n        _AMM.lastUpdateTime = _lastPriceTickApplicable();      \n    }\n\n    constructor() public {\n        factory = IDextokenFactory(msg.sender);\n        _AMM.lastUpdateTime = 0;\n        totalLiquidity = 0;\n    }\n\n    function initialize(address _token0, address _token1, uint _Ct, uint _Pt) \n        external \n    {\n        require(msg.sender == address(factory), \u0027initialize: Forbidden\u0027);\n\n        token0 = IERC20(_token0); \n        require(_Ct \u003c= token0.totalSupply(), \"initialize: Invalid _Ct\");     \n        \n        /// snapshot of the pooled token\n        _AMM.Ct = _Ct;\n        _AMM.Pt = _Pt;\n        _AMM.Nt = _AMM.Pt.mul(_AMM.Ct).div(1e18);\n\n        /// The collateral token\n        WETH = IERC20(_token1);        \n    }\n\n    function deposit(uint amount) \n        external \n        nonReentrant\n        updatePriceTick()\n    {\n        require(amount \u003e 0, \"deposit: invalid amount\");\n        uint _totalBalance = getPoolBalance();\n        address _token0 = address(token0);\n        uint _Ct = _AMM.Ct.add(amount);\n        uint _Nt = _AMM.Nt;\n\n        // liquidity at price tick (t)\n        uint spotPrice = getSpotPrice(_Ct, _Nt);\n        uint liquidity = spotPrice.mul(amount);\n        require(liquidity \u003e 0, \"deposit: invalid user liquidity\");\n\n        _totalBalance = _totalBalance.add(amount);\n        uint _totalLiquidity = totalLiquidity.add(liquidity);\n\n        // mint liquidity tokens\n        uint mintedTokens = _calcLiquidityToken(_totalLiquidity, _totalBalance, liquidity);\n\n        /// calculate the virtual collateral tokens at price tick (t)\n        uint _Mb = WETH.balanceOf(address(this)).mul(mintedTokens).div(totalSupply().add(mintedTokens));\n\n        // move price tick to (t+1) \n        _AMM.Ct = _Ct;\n        _AMM.Nt = _Nt.add(_Mb);\n        totalLiquidity = _totalLiquidity;\n\n        // mint liquidity token at price tick (t+1)\n        _mintLiquidityToken(msg.sender, mintedTokens);\n        _tokenSafeTransferFrom(_token0, msg.sender, address(this), amount);\n        emit TokenDeposit(_token0, msg.sender, amount, spotPrice);        \n    }\n\n    function withdraw(uint tokens) \n        external \n        nonReentrant\n        updatePriceTick()\n    {\n        require(tokens \u003e 0, \"withdraw: invalid tokens\");\n        require(totalSupply() \u003e 0, \"withdraw: insufficient liquidity\");\n        require(balanceOf(msg.sender) \u003e= tokens, \"withdraw: insufficient tokens\");\n        address _token0 = address(token0);\n      \n        // liquidity at price tick (t)\n        uint amount = liquidityTokenToAmount(tokens);\n\n        /// calculate the collateral token shares\n        uint balance = WETH.balanceOf(address(this));\n        uint amountOut = balance.mul(tokens).div(totalSupply());\n\n        /// Ensure the amountOut is not more than the balance in the contract.\n        /// Preventing underflow due to very low values of the balance.        \n        require(amountOut \u003c= balance, \"withdraw: insufficient ETH balance\");\n\n        // prepare for price tick (t+1)\n        uint _Ct = _AMM.Ct;\n        uint _Nt = _AMM.Nt;\n        _Ct = _Ct.sub(amount);\n        _Nt = _Nt.sub(amountOut);\n\n        // liquidity at price tick (t+1)        \n        uint spotPrice = getSpotPrice(_Ct, _Nt);\n        totalLiquidity = spotPrice.mul(getPoolBalance().sub(amount));\n\n        _AMM.Ct = _Ct;\n        _AMM.Nt = _Nt;\n\n        _tokenSafeTransfer(_token0, msg.sender, amount);\n        _tokenSafeTransfer(address(WETH), msg.sender, amountOut);\n\n        _burnLiquidityToken(msg.sender, tokens);\n        emit TokenWithdraw(_token0, msg.sender, amount, spotPrice);\n    }\n\n    function swapExactETHForTokens(\n        uint amountIn,\n        uint minAmountOut,\n        uint maxPrice,\n        uint deadline\n    )\n        external \n        nonReentrant\n        returns (uint)\n    {\n        require(WETH.balanceOf(msg.sender) \u003e= amountIn, \"swapExactETHForTokens: Insufficient ETH balance\");\n        require(deadline \u003e _lastPriceTickApplicable(), \"swapExactETHForTokens: Invalid transaction\");\n        require(amountIn \u003e 0, \"swapExactETHForTokens: Invalid amountIn\");\n        uint spotPrice;\n        IERC20 _WETH = WETH;\n\n        /// the price tick at (t)\n        /// increase the collateral token supply including interests rate        \n        {\n            spotPrice = getSpotPrice(_AMM.Ct, _AMM.Nt.add(amountIn));\n            require(spotPrice \u003c= maxPrice, \"swapExactETHForTokens: Invalid price slippage\");\n        }\n\n        /// check amount out without fees\n        uint amountOut = amountIn.mul(1e18).div(spotPrice);\n        require(amountOut \u003e= minAmountOut, \"swapExactETHForTokens: Invalid amountOut\");\n\n        /// split fees and check exact amount out\n        uint feeAmountIn = _calcFees(amountIn);\n        uint exactAmountIn = amountIn.sub(feeAmountIn);\n        uint exactAmountOut = exactAmountIn.mul(1e18).div(spotPrice);\n\n        /// increase the collateral token supply\n        _AMM.Nt = _AMM.Nt.add(exactAmountIn);\n        spotPrice = getSpotPrice(_AMM.Ct.sub(exactAmountOut), _AMM.Nt);\n        totalLiquidity = spotPrice.mul(getPoolBalance().sub(exactAmountOut));\n\n        /// transfer the collateral tokens in\n        _tokenSafeTransferFrom(address(_WETH), msg.sender, address(this), amountIn);\n        \n        /// transfer fees\n        _tokenSafeTransfer(address(_WETH), factory.getFeePool(), feeAmountIn);\n\n        /// move to the next price tick (t+1)\n        _withdrawAndTransfer(msg.sender, exactAmountOut);\n\n        emit SwapExactETHForTokens(address(this), exactAmountOut, amountIn, spotPrice, msg.sender);\n        return exactAmountOut;\n    } \n\n    function swapExactTokensForETH(\n        uint amountIn,\n        uint minAmountOut,\n        uint minPrice,\n        uint deadline\n    )\n        external \n        nonReentrant\n        returns (uint)\n    {\n        require(token0.balanceOf(msg.sender) \u003e= amountIn, \"swapExactTokensForETH: Insufficient user balance\");    \n        require(deadline \u003e _lastPriceTickApplicable(), \"swapExactTokensForETH: Invalid order\");\n        require(amountIn \u003e 0, \"swapExactTokensForETH: Invalid amountIn\");\n        uint _Nt = _AMM.Nt;\n        IERC20 _WETH = WETH;\n\n        /// add liquidity at the price tick (t)\n        uint spotPrice = getSpotPrice(_AMM.Ct.add(amountIn), _Nt);\n        require(spotPrice \u003e= minPrice, \"swapExactTokensForETH: Invalid price slippage\");\n\n        /// user receives\n        uint amountOut = spotPrice.mul(amountIn).div(1e18);\n        require(_WETH.balanceOf(address(this)) \u003e= amountOut, \"swapExactTokensForETH: Insufficient ETH liquidity\");\n        require(amountOut \u003e= minAmountOut, \"swapExactTokensForETH: Invalid amountOut\");\n\n        /// split fees\n        uint feeAmountOut = _calcFees(amountOut);\n        uint exactAmountOut = amountOut.sub(feeAmountOut);\n\n        /// decrease the collateral token, and add liquidity \n        /// providers\u0027 fee shares back to the pool\n        _AMM.Nt = _Nt.sub(exactAmountOut);\n\n        totalLiquidity = spotPrice.mul(getPoolBalance().add(amountIn));\n\n        /// move the next price tick (t+1)\n        _depositAndTransfer(msg.sender, amountIn);\n\n        /// transfer the collateral token out\n        _tokenSafeTransfer(address(_WETH), msg.sender, exactAmountOut);\n\n        emit SwapExactTokensForETH(address(this), exactAmountOut, amountIn, spotPrice, msg.sender);\n        return exactAmountOut;\n    }\n\n    function getLastUpdateTime() external view returns (uint) {\n        return _AMM.lastUpdateTime;\n    }  \n\n    function getCirculatingSupply() external view returns (uint) {\n        return _AMM.Ct;\n    }    \n\n    function getUserbase() external view returns (uint) {\n        return _AMM.Nt;\n    }\n\n    function getToken() external view returns (address) {\n        return address(token0);\n    }\n\n    function getTotalLiquidity() external view returns (uint) {\n        return totalLiquidity.div(1e18);\n    }  \n\n    function liquidityOf(address account) external view returns (uint) {\n        return balanceOf(account);\n    }\n\n    function liquiditySharesOf(address account) external view returns (uint) {\n        uint userTokens = balanceOf(account);\n        if (userTokens == 0) {\n            return 0;\n        }\n        return totalSupply()\n            .mul(1e18)\n            .div(userTokens);\n    }  \n\n    function mean() public view returns (uint) {\n        return _AMM.Nt\n            .mul(_AMM.Pt);\n    }\n\n    function getPoolBalance() public view returns (uint) {\n        return token0.balanceOf(address(this));\n    }\n\n    function getPrice() public view returns (uint) {\n        return _AMM.Nt.mul(1e18).div(_AMM.Ct);\n    }   \n\n    function getSpotPrice(uint _Ct, uint _Nt) public pure returns (uint) {\n        return _Nt.mul(1e18).div(_Ct);\n    }\n\n    function liquidityTokenToAmount(uint token) public view returns (uint) {\n        if (totalSupply() == 0) {\n            return 0;\n        }        \n        return getPoolBalance()\n            .mul(token)\n            .div(totalSupply());\n    }  \n\n    function liquidityFromAmount(uint amount) public view returns (uint) {\n        return getPrice().mul(amount); \n    }\n\n    function _depositAndTransfer(address account, uint amount) \n        internal\n        updatePriceTick()\n    {\n        _AMM.Ct = _AMM.Ct.add(amount);    \n        _tokenSafeTransferFrom(address(token0), account, address(this), amount);\n    }\n\n    function _withdrawAndTransfer(address account, uint amount) \n        internal\n        updatePriceTick()\n    {\n        _AMM.Ct = _AMM.Ct.sub(amount);    \n        _tokenSafeTransfer(address(token0), account, amount);\n    }\n    \n    function _lastPriceTickApplicable() internal view returns (uint) {\n        return Math.max(block.timestamp, _AMM.lastUpdateTime);\n    }\n\n    function _mintLiquidityToken(address to, uint amount) internal {\n        _mint(address(this), amount);\n        _transfer(address(this), to, amount);\n    }\n\n    function _burnLiquidityToken(address from, uint amount) internal {\n        _transfer(from, address(this), amount);\n        _burn(address(this), amount);\n    } \n\n    function _calcFees(uint amount) internal pure returns (uint) {\n        return amount.mul(FEE_FACTOR).div(FEE_BASE);\n    }\n\n    function _calcLiquidityToken(\n        uint _totalLiquidity, \n        uint _totalBalance, \n        uint _liquidity\n    ) \n        internal \n        pure \n        returns (uint) \n    {\n        if (_totalLiquidity == 0) {\n            return 0;\n        }    \n        return _totalBalance\n            .mul(_liquidity)\n            .div(_totalLiquidity);\n    }\n\n    function _tokenSafeTransfer(\n        address token,\n        address to,\n        uint amount\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, amount));\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \"_tokenSafeTransfer failed\");\n    }\n\n    function _tokenSafeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint amount\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, amount));\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \"_tokenSafeTransferFrom failed\");\n    }                    \n}"},"ERC20.sol":{"content":"pragma solidity 0.5.17;\n\nimport \"./Context.sol\";\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n\n/**\n * @dev The ERC20 standard implementation.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint;\n\n    mapping (address =\u003e uint) private _balances;\n    mapping (address =\u003e mapping (address =\u003e uint)) private _allowances;\n\n    uint private _totalSupply;\n\n    function totalSupply() public view returns (uint) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n"},"ERC20Detailed.sol":{"content":"pragma solidity 0.5.17;\n\nimport \"./IERC20.sol\";\n\n\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"},"IDextokenFactory.sol":{"content":"pragma solidity 0.5.17;\n\n\ninterface IDextokenFactory {\n    function getFeePool() external view returns (address);\n}"},"IDextokenPool.sol":{"content":"pragma solidity 0.5.17;\n\n\ninterface IDextokenPool {\n    event TokenDeposit(\n        address indexed token, \n        address indexed account, \n        uint amount,\n        uint spotPrice\n    );\n\n    event TokenWithdraw(\n        address indexed token, \n        address indexed account, \n        uint amount,\n        uint spotPrice\n    );\n\n    event SwapExactETHForTokens(\n        address indexed poolOut, \n        uint amountOut, \n        uint amountIn,\n        uint spotPrice,\n        address indexed account\n    );\n\n    event SwapExactTokensForETH(\n        address indexed poolOut, \n        uint amountOut, \n        uint amountIn, \n        uint spotPrice,\n        address indexed account\n    );\n\n    /// Speculative AMM\n    function initialize(address _token0, address _token1, uint _Ct, uint _Pt) external;\n    function mean() external view returns (uint);\n    function getLastUpdateTime() external view returns (uint);\n    function getCirculatingSupply() external view returns (uint);\n    function getUserbase() external view returns (uint);\n    function getPrice() external view returns (uint);\n    function getSpotPrice(uint _Ct, uint _Nt) external pure returns (uint);\n\tfunction getToken() external view returns (address);\n\n    /// Pool Management\n    function getPoolBalance() external view returns (uint);    \n    function getTotalLiquidity() external view returns (uint);\n    function liquidityOf(address account) external view returns (uint);\n    function liquiditySharesOf(address account) external view returns (uint);\n    function liquidityTokenToAmount(uint token) external view returns (uint);\n    function liquidityFromAmount(uint amount) external view returns (uint);\n    function deposit(uint amount) external;\n    function withdraw(uint tokens) external;\n\n    /// Trading\n    function swapExactETHForTokens(\n        uint amountIn,\n        uint minAmountOut,\n        uint maxPrice,\n        uint deadline\n    ) external returns (uint);\n\n    function swapExactTokensForETH(\n        uint amountIn,\n        uint minAmountOut,\n        uint minPrice,\n        uint deadline\n    ) external returns (uint);\n}"},"IERC20.sol":{"content":"pragma solidity 0.5.17;\n\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function transfer(address recipient, uint amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}"},"IWETH.sol":{"content":"pragma solidity 0.5.17;\n\n\ninterface IWETH {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function balanceOf(address) external view returns (uint);\n\n    function allowance(address, address) external view returns (uint);\n\n    function deposit() external payable;\n\n    function withdraw(uint wad) external;\n\n    function totalSupply() external view returns (uint);\n\n    function approve(address guy, uint wad) external returns (bool);\n\n    function transfer(address dst, uint wad) external returns (bool);\n\n    function transferFrom(address src, address dst, uint wad) external returns (bool);\n}"},"LPToken.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity 0.5.17;\n\nimport \"./ERC20.sol\";\n\n\ncontract LPToken is ERC20 {\n    string public constant name     = \"DEXG Liquidity Pool\";\n    string public constant symbol   = \"DEXG-LP\";\n    uint8  public constant decimals = 18;\n}"},"Math.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"},"Owned.sol":{"content":"pragma solidity ^0.5.17;\n\ncontract Ownable {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() public {\n        owner = msg.sender;\n        newOwner = address(0);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyNewOwner() {\n        require(msg.sender != address(0));\n        require(msg.sender == newOwner);\n        _;\n    }\n    \n    function isOwner(address account) public view returns (bool) {\n        if(account == owner) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0));\n        newOwner = _newOwner;\n    }\n\n    function acceptOwnership() public onlyNewOwner {\n        emit OwnershipTransferred(owner, newOwner);        \n        owner = newOwner;\n        newOwner = address(0);\n    }\n}"},"Pausable.sol":{"content":"pragma solidity ^0.5.17;\n\nimport \"./Owned.sol\";\n\n\ncontract Pausable is Ownable {\n    event Paused(address account);\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    constructor () public {\n        _paused = false;\n    }    \n\n    modifier whenNotPaused() {\n        require(!_paused);\n        _;\n    }\n\n    modifier whenPaused() {\n        require(_paused);\n        _;\n    }\n\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    function pause() public onlyOwner whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() public onlyOwner whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}"},"ReentrancyGuard.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\n * available, which can be aplied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n"},"SafeERC20.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n\nlibrary SafeERC20 {\n    using SafeMath for uint;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length \u003e 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity 0.5.17;\n\n\nlibrary SafeMath {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n    function sub(uint a, uint b) internal pure returns (uint) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        require(b \u003c= a, errorMessage);\n        uint c = a - b;\n\n        return c;\n    }\n    function mul(uint a, uint b) internal pure returns (uint) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n    function div(uint a, uint b) internal pure returns (uint) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint c = a / b;\n\n        return c;\n    }\n}"}}