1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/HATVaults.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n// Disclaimer https://github.com/hats-finance/hats-contracts/blob/main/DISCLAIMER.md\n\npragma solidity 0.8.6;\nimport \"./interfaces/ISwapRouter.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"./HATMaster.sol\";\nimport \"./tokenlock/ITokenLockFactory.sol\";\nimport \"./Governable.sol\";\n\n\ncontract  HATVaults is Governable, HATMaster {\n    using SafeMath  for uint256;\n    using SafeERC20 for IERC20;\n\n    struct PendingApproval {\n        address beneficiary;\n        uint256 severity;\n        address approver;\n    }\n\n    struct ClaimReward {\n        uint256 hackerVestedReward;\n        uint256 hackerReward;\n        uint256 committeeReward;\n        uint256 swapAndBurn;\n        uint256 governanceHatReward;\n        uint256 hackerHatReward;\n    }\n\n    struct PendingRewardsLevels {\n        uint256 timestamp;\n        uint256[] rewardsLevels;\n    }\n\n    struct GeneralParameters {\n        uint256 hatVestingDuration;\n        uint256 hatVestingPeriods;\n        uint256 withdrawPeriod;\n        uint256 safetyPeriod; //withdraw disable period in seconds\n        uint256 setRewardsLevelsDelay;\n        uint256 withdrawRequestEnablePeriod;\n        uint256 withdrawRequestPendingPeriod;\n        uint256 claimFee;  //claim fee in ETH\n    }\n\n    //pid -> committee address\n    mapping(uint256=>address) public committees;\n    mapping(address => uint256) public swapAndBurns;\n    //hackerAddress ->(token->amount)\n    mapping(address => mapping(address => uint256)) public hackersHatRewards;\n    //token -> amount\n    mapping(address => uint256) public governanceHatRewards;\n    //pid -> PendingApproval\n    mapping(uint256 => PendingApproval) public pendingApprovals;\n    //poolId -> (address -> requestTime)\n    mapping(uint256 => mapping(address => uint256)) public withdrawRequests;\n    //poolId -> PendingRewardsLevels\n    mapping(uint256 => PendingRewardsLevels) public pendingRewardsLevels;\n\n    mapping(uint256 => bool) public poolDepositPause;\n\n    GeneralParameters public generalParameters;\n\n    uint256 internal constant REWARDS_LEVEL_DENOMINATOR = 10000;\n    ITokenLockFactory public immutable tokenLockFactory;\n    ISwapRouter public immutable uniSwapRouter;\n    uint256 public constant MINIMUM_DEPOSIT = 1e6;\n\n    modifier onlyCommittee(uint256 _pid) {\n        require(committees[_pid] == msg.sender, \"only committee\");\n        _;\n    }\n\n    modifier noPendingApproval(uint256 _pid) {\n        require(pendingApprovals[_pid].beneficiary == address(0), \"pending approval exist\");\n        _;\n    }\n\n    modifier noSafetyPeriod() {\n      //disable withdraw for safetyPeriod (e.g 1 hour) each withdrawPeriod(e.g 11 hours)\n      // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp % (generalParameters.withdrawPeriod + generalParameters.safetyPeriod) <\n        generalParameters.withdrawPeriod,\n        \"safety period\");\n        _;\n    }\n\n    event SetCommittee(uint256 indexed _pid, address indexed _committee);\n\n    event AddPool(uint256 indexed _pid,\n                uint256 indexed _allocPoint,\n                address indexed _lpToken,\n                address _committee,\n                string _descriptionHash,\n                uint256[] _rewardsLevels,\n                RewardsSplit _rewardsSplit,\n                uint256 _rewardVestingDuration,\n                uint256 _rewardVestingPeriods);\n\n    event SetPool(uint256 indexed _pid, uint256 indexed _allocPoint, bool indexed _registered, string _descriptionHash);\n    event Claim(address indexed _claimer, string _descriptionHash);\n    event SetRewardsSplit(uint256 indexed _pid, RewardsSplit _rewardsSplit);\n    event SetRewardsLevels(uint256 indexed _pid, uint256[] _rewardsLevels);\n    event PendingRewardsLevelsLog(uint256 indexed _pid, uint256[] _rewardsLevels, uint256 _timeStamp);\n\n    event SwapAndSend(uint256 indexed _pid,\n                    address indexed _beneficiary,\n                    uint256 indexed _amountSwaped,\n                    uint256 _amountReceived,\n                    address _tokenLock);\n\n    event SwapAndBurn(uint256 indexed _pid, uint256 indexed _amountSwaped, uint256 indexed _amountBurned);\n    event SetVestingParams(uint256 indexed _pid, uint256 indexed _duration, uint256 indexed _periods);\n    event SetHatVestingParams(uint256 indexed _duration, uint256 indexed _periods);\n\n    event ClaimApprove(address indexed _approver,\n                    uint256 indexed _pid,\n                    address indexed _beneficiary,\n                    uint256 _severity,\n                    address _tokenLock,\n                    ClaimReward _claimReward);\n\n    event PendingApprovalLog(uint256 indexed _pid,\n                            address indexed _beneficiary,\n                            uint256 indexed _severity,\n                            address _approver);\n\n    event WithdrawRequest(uint256 indexed _pid,\n                        address indexed _beneficiary,\n                        uint256 indexed _withdrawEnableTime);\n\n    event SetWithdrawSafetyPeriod(uint256 indexed _withdrawPeriod, uint256 indexed _safetyPeriod);\n\n    event RewardDepositors(uint256 indexed _pid, uint256 indexed _amount);\n\n    /**\n   * @dev constructor -\n   * @param _rewardsToken the reward token address (HAT)\n   * @param _rewardPerBlock the reward amount per block the contract will reward pools\n   * @param _startBlock start block of of which the contract will start rewarding from.\n   * @param _multiplierPeriod a fix period value. each period will have its own multiplier value.\n   *        which set the reward for each period. e.g a value of 100000 means that each such period is 100000 blocks.\n   * @param _hatGovernance the governance address.\n   *        Some of the contracts functions are limited only to governance :\n   *         addPool,setPool,dismissPendingApprovalClaim,approveClaim,\n   *         setHatVestingParams,setVestingParams,setRewardsSplit\n   * @param _uniSwapRouter uni swap v3 router to be used to swap tokens for HAT token.\n   * @param _tokenLockFactory address of the token lock factory to be used\n   *        to create a vesting contract for the approved claim reporter.\n */\n    constructor(\n        address _rewardsToken,\n        uint256 _rewardPerBlock,\n        uint256 _startBlock,\n        uint256 _multiplierPeriod,\n        address _hatGovernance,\n        ISwapRouter _uniSwapRouter,\n        ITokenLockFactory _tokenLockFactory\n    // solhint-disable-next-line func-visibility\n    ) HATMaster(HATToken(_rewardsToken), _rewardPerBlock, _startBlock, _multiplierPeriod) {\n        Governable.initialize(_hatGovernance);\n        uniSwapRouter = _uniSwapRouter;\n        tokenLockFactory = _tokenLockFactory;\n        generalParameters = GeneralParameters({\n            hatVestingDuration: 90 days,\n            hatVestingPeriods:90,\n            withdrawPeriod: 11 hours,\n            safetyPeriod: 1 hours,\n            setRewardsLevelsDelay: 2 days,\n            withdrawRequestEnablePeriod: 7 days,\n            withdrawRequestPendingPeriod: 7 days,\n            claimFee: 0\n        });\n    }\n\n      /**\n     * @dev pendingApprovalClaim - called by a committee to set a pending approval claim.\n     * The pending approval need to be approved or dismissed  by the hats governance.\n     * This function should be called only on a safety period, where withdrawn is disable.\n     * Upon a call to this function by the committee the pool withdrawn will be disable\n     * till governance will approve or dismiss this pending approval.\n     * @param _pid pool id\n     * @param _beneficiary the approval claim beneficiary\n     * @param _severity approval claim severity\n   */\n    function pendingApprovalClaim(uint256 _pid, address _beneficiary, uint256 _severity)\n    external\n    onlyCommittee(_pid)\n    noPendingApproval(_pid) {\n        require(_beneficiary != address(0), \"beneficiary is zero\");\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp % (generalParameters.withdrawPeriod + generalParameters.safetyPeriod) >=\n        generalParameters.withdrawPeriod,\n        \"none safety period\");\n        require(_severity < poolsRewards[_pid].rewardsLevels.length, \"_severity is not in the range\");\n\n        pendingApprovals[_pid] = PendingApproval({\n            beneficiary: _beneficiary,\n            severity: _severity,\n            approver: msg.sender\n        });\n        emit PendingApprovalLog(_pid, _beneficiary, _severity, msg.sender);\n    }\n\n    /**\n     * @dev setWithdrawRequestParams - called by hats governance to set withdraw request params\n     * @param _withdrawRequestPendingPeriod - the time period where the withdraw request is pending.\n     * @param _withdrawRequestEnablePeriod - the time period where the withdraw is enable for a withdraw request.\n    */\n    function setWithdrawRequestParams(uint256 _withdrawRequestPendingPeriod, uint256  _withdrawRequestEnablePeriod)\n    external\n    onlyGovernance {\n        generalParameters.withdrawRequestPendingPeriod = _withdrawRequestPendingPeriod;\n        generalParameters.withdrawRequestEnablePeriod = _withdrawRequestEnablePeriod;\n    }\n\n  /**\n   * @dev dismissPendingApprovalClaim - called by hats governance to dismiss a pending approval claim.\n   * @param _pid pool id\n  */\n    function dismissPendingApprovalClaim(uint256 _pid) external onlyGovernance {\n        delete pendingApprovals[_pid];\n    }\n\n    /**\n   * @dev approveClaim - called by hats governance to approve a pending approval claim.\n   * @param _pid pool id\n */\n    function approveClaim(uint256 _pid) external onlyGovernance nonReentrant {\n        require(pendingApprovals[_pid].beneficiary != address(0), \"no pending approval\");\n        PoolReward storage poolReward = poolsRewards[_pid];\n        PendingApproval memory pendingApproval = pendingApprovals[_pid];\n        delete pendingApprovals[_pid];\n\n        IERC20 lpToken = poolInfo[_pid].lpToken;\n        ClaimReward memory claimRewards = calcClaimRewards(_pid, pendingApproval.severity);\n        poolInfo[_pid].balance = poolInfo[_pid].balance.sub(\n                            claimRewards.hackerReward\n                            .add(claimRewards.hackerVestedReward)\n                            .add(claimRewards.committeeReward)\n                            .add(claimRewards.swapAndBurn)\n                            .add(claimRewards.hackerHatReward)\n                            .add(claimRewards.governanceHatReward));\n        address tokenLock;\n        if (claimRewards.hackerVestedReward > 0) {\n        //hacker get its reward to a vesting contract\n            tokenLock = tokenLockFactory.createTokenLock(\n            address(lpToken),\n            0x000000000000000000000000000000000000dEaD, //this address as owner, so it can do nothing.\n            pendingApproval.beneficiary,\n            claimRewards.hackerVestedReward,\n            // solhint-disable-next-line not-rely-on-time\n            block.timestamp, //start\n            // solhint-disable-next-line not-rely-on-time\n            block.timestamp + poolReward.vestingDuration, //end\n            poolReward.vestingPeriods,\n            0, //no release start\n            0, //no cliff\n            ITokenLock.Revocability.Disabled,\n            false\n        );\n            lpToken.safeTransfer(tokenLock, claimRewards.hackerVestedReward);\n        }\n        lpToken.safeTransfer(pendingApproval.beneficiary, claimRewards.hackerReward);\n        lpToken.safeTransfer(pendingApproval.approver, claimRewards.committeeReward);\n        //storing the amount of token which can be swap and burned so it could be swapAndBurn in a seperate tx.\n        swapAndBurns[address(lpToken)] = swapAndBurns[address(lpToken)].add(claimRewards.swapAndBurn);\n        governanceHatRewards[address(lpToken)] =\n        governanceHatRewards[address(lpToken)].add(claimRewards.governanceHatReward);\n        hackersHatRewards[pendingApproval.beneficiary][address(lpToken)] =\n        hackersHatRewards[pendingApproval.beneficiary][address(lpToken)].add(claimRewards.hackerHatReward);\n\n        emit ClaimApprove(msg.sender,\n                        _pid,\n                        pendingApproval.beneficiary,\n                        pendingApproval.severity,\n                        tokenLock,\n                        claimRewards);\n        assert(poolInfo[_pid].balance > 0);\n    }\n\n    /**\n     * @dev rewardDepositors - add funds to pool to reward depositors.\n     * The funds will be given to depositors pro rata upon withdraw\n     * @param _pid pool id\n     * @param _amount amount to add\n    */\n    function rewardDepositors(uint256 _pid, uint256 _amount) external {\n        require(poolInfo[_pid].balance.add(_amount).div(MINIMUM_DEPOSIT) < poolInfo[_pid].totalUsersAmount,\n        \"amount to reward is too big\");\n        poolInfo[_pid].lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n        poolInfo[_pid].balance = poolInfo[_pid].balance.add(_amount);\n        emit RewardDepositors(_pid, _amount);\n    }\n\n    /**\n     * @dev setClaimFee - called by hats governance to set claim fee\n     * @param _fee claim fee in ETH\n    */\n    function setClaimFee(uint256 _fee) external onlyGovernance {\n        generalParameters.claimFee = _fee;\n    }\n\n    /**\n     * @dev setWithdrawSafetyPeriod - called by hats governance to set Withdraw Period\n     * @param _withdrawPeriod withdraw enable period\n     * @param _safetyPeriod withdraw disable period\n    */\n    function setWithdrawSafetyPeriod(uint256 _withdrawPeriod, uint256 _safetyPeriod) external onlyGovernance {\n        generalParameters.withdrawPeriod = _withdrawPeriod;\n        generalParameters.safetyPeriod = _safetyPeriod;\n        emit SetWithdrawSafetyPeriod(generalParameters.withdrawPeriod, generalParameters.safetyPeriod);\n    }\n\n    //_descriptionHash - a hash of an ipfs encrypted file which describe the claim.\n    // this can be use later on by the claimer to prove her claim\n    function claim(string memory _descriptionHash) external payable {\n        if (generalParameters.claimFee > 0) {\n            require(msg.value >= generalParameters.claimFee, \"not enough fee payed\");\n            // solhint-disable-next-line indent\n            payable(governance()).transfer(msg.value);\n        }\n        emit Claim(msg.sender, _descriptionHash);\n    }\n\n    /**\n   * @dev setVestingParams - set pool vesting params for rewarding claim reporter with the pool token\n   * @param _pid pool id\n   * @param _duration duration of the vesting period\n   * @param _periods the vesting periods\n */\n    function setVestingParams(uint256 _pid, uint256 _duration, uint256 _periods) external onlyGovernance {\n        require(_duration < 120 days, \"vesting duration is too long\");\n        require(_periods > 0, \"vesting periods cannot be zero\");\n        require(_duration >= _periods, \"vesting duration smaller than periods\");\n        poolsRewards[_pid].vestingDuration = _duration;\n        poolsRewards[_pid].vestingPeriods = _periods;\n        emit SetVestingParams(_pid, _duration, _periods);\n    }\n\n    /**\n   * @dev setHatVestingParams - set HAT vesting params for rewarding claim reporter with HAT token\n   * the function can be called only by governance.\n   * @param _duration duration of the vesting period\n   * @param _periods the vesting periods\n */\n    function setHatVestingParams(uint256 _duration, uint256 _periods) external onlyGovernance {\n        require(_duration < 180 days, \"vesting duration is too long\");\n        require(_periods > 0, \"vesting periods cannot be zero\");\n        require(_duration >= _periods, \"vesting duration smaller than periods\");\n        generalParameters.hatVestingDuration = _duration;\n        generalParameters.hatVestingPeriods = _periods;\n        emit SetHatVestingParams(_duration, _periods);\n    }\n\n    /**\n   * @dev setRewardsSplit - set the pool token rewards split upon an approval\n   * the function can be called only by governance.\n   * the sum of the rewards split should be less than 10000 (less than 100%)\n   * @param _pid pool id\n   * @param _rewardsSplit split\n   * and sent to the hacker(claim reported)\n */\n    function setRewardsSplit(uint256 _pid, RewardsSplit memory _rewardsSplit)\n    external\n    onlyGovernance noPendingApproval(_pid) noSafetyPeriod {\n        validateSplit(_rewardsSplit);\n        poolsRewards[_pid].rewardsSplit = _rewardsSplit;\n        emit SetRewardsSplit(_pid, _rewardsSplit);\n    }\n\n    /**\n   * @dev setRewardsLevelsDelay - set the timelock delay for setting rewars level\n   * @param _delay time delay\n */\n    function setRewardsLevelsDelay(uint256 _delay)\n    external\n    onlyGovernance {\n        require(_delay >= 2 days, \"delay is too short\");\n        generalParameters.setRewardsLevelsDelay = _delay;\n    }\n\n    /**\n   * @dev setPendingRewardsLevels - set pending request to set pool token rewards level.\n   * the reward level represent the percentage of the pool's token which will be split as a reward.\n   * the function can be called only by the pool committee.\n   * cannot be called if there already pending approval.\n   * each level should be less than 10000\n   * @param _pid pool id\n   * @param _rewardsLevels the reward levels array\n */\n    function setPendingRewardsLevels(uint256 _pid, uint256[] memory _rewardsLevels)\n    external\n    onlyCommittee(_pid) noPendingApproval(_pid) {\n        pendingRewardsLevels[_pid].rewardsLevels = checkRewardsLevels(_rewardsLevels);\n        // solhint-disable-next-line not-rely-on-time\n        pendingRewardsLevels[_pid].timestamp = block.timestamp;\n        emit PendingRewardsLevelsLog(_pid, _rewardsLevels, pendingRewardsLevels[_pid].timestamp);\n    }\n\n  /**\n   * @dev setRewardsLevels - set the pool token rewards level of already pending set rewards level.\n   * see pendingRewardsLevels\n   * the reward level represent the percentage of the pool's token which will be split as a reward.\n   * the function can be called only by the pool committee.\n   * cannot be called if there already pending approval.\n   * each level should be less than 10000\n   * @param _pid pool id\n */\n    function setRewardsLevels(uint256 _pid)\n    external\n    onlyCommittee(_pid) noPendingApproval(_pid) {\n        require(pendingRewardsLevels[_pid].timestamp > 0, \"no pending set rewards levels\");\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp - pendingRewardsLevels[_pid].timestamp > generalParameters.setRewardsLevelsDelay,\n        \"cannot confirm setRewardsLevels at this time\");\n        poolsRewards[_pid].rewardsLevels = pendingRewardsLevels[_pid].rewardsLevels;\n        delete pendingRewardsLevels[_pid];\n        emit SetRewardsLevels(_pid, poolsRewards[_pid].rewardsLevels);\n    }\n\n    /**\n   * @dev committeeCheckIn - committee check in.\n   * deposit is enable only after committee check in\n   * @param _pid pool id\n */\n    function committeeCheckIn(uint256 _pid) external onlyCommittee(_pid) {\n        poolsRewards[_pid].committeeCheckIn = true;\n    }\n\n\n    /**\n   * @dev setCommittee - set new committee address.\n   * @param _pid pool id\n   * @param _committee new committee address\n */\n    function setCommittee(uint256 _pid, address _committee)\n    external {\n        require(_committee != address(0), \"committee is zero\");\n        //governance can update committee only if committee was not checked in yet.\n        if (msg.sender == governance() && committees[_pid] != msg.sender) {\n            require(!poolsRewards[_pid].committeeCheckIn, \"Committee already checked in\");\n        } else {\n            require(committees[_pid] == msg.sender, \"Only committee\");\n        }\n\n        committees[_pid] = _committee;\n\n        emit SetCommittee(_pid, _committee);\n    }\n\n    /**\n   * @dev addPool - only Governance\n   * @param _allocPoint the pool allocation point\n   * @param _lpToken pool token\n   * @param _committee pool committee address\n   * @param _rewardsLevels pool reward levels(sevirities)\n     each level is a number between 0 and 10000.\n   * @param _rewardsSplit pool reward split.\n     each entry is a number between 0 and 10000.\n     total splits should be equal to 10000\n   * @param _descriptionHash the hash of the pool description.\n   * @param _rewardVestingParams vesting params\n   *        _rewardVestingParams[0] - vesting duration\n   *        _rewardVestingParams[1] - vesting periods\n */\n    function addPool(uint256 _allocPoint,\n                    address _lpToken,\n                    address _committee,\n                    uint256[] memory _rewardsLevels,\n                    RewardsSplit memory _rewardsSplit,\n                    string memory _descriptionHash,\n                    uint256[2] memory _rewardVestingParams)\n    external\n    onlyGovernance {\n        require(_rewardVestingParams[0] < 120 days, \"vesting duration is too long\");\n        require(_rewardVestingParams[1] > 0, \"vesting periods cannot be zero\");\n        require(_rewardVestingParams[0] >= _rewardVestingParams[1], \"vesting duration smaller than periods\");\n        require(_committee != address(0), \"committee is zero\");\n        add(_allocPoint, IERC20(_lpToken));\n        uint256 poolId = poolInfo.length-1;\n        committees[poolId] = _committee;\n        uint256[] memory rewardsLevels = checkRewardsLevels(_rewardsLevels);\n\n        RewardsSplit memory rewardsSplit = (_rewardsSplit.hackerVestedReward == 0 && _rewardsSplit.hackerReward == 0) ?\n        getDefaultRewardsSplit() : _rewardsSplit;\n\n        validateSplit(rewardsSplit);\n        poolsRewards[poolId] = PoolReward({\n            rewardsLevels: rewardsLevels,\n            rewardsSplit: rewardsSplit,\n            committeeCheckIn: false,\n            vestingDuration: _rewardVestingParams[0],\n            vestingPeriods: _rewardVestingParams[1]\n        });\n\n        emit AddPool(poolId,\n                    _allocPoint,\n                    address(_lpToken),\n                    _committee,\n                    _descriptionHash,\n                    rewardsLevels,\n                    rewardsSplit,\n                    _rewardVestingParams[0],\n                    _rewardVestingParams[1]);\n    }\n\n    /**\n   * @dev setPool\n   * @param _pid the pool id\n   * @param _allocPoint the pool allocation point\n   * @param _registered does this pool is registered (default true).\n   * @param _depositPause pause pool deposit (default false).\n   * This parameter can be used by the UI to include or exclude the pool\n   * @param _descriptionHash the hash of the pool description.\n */\n    function setPool(uint256 _pid,\n                    uint256 _allocPoint,\n                    bool _registered,\n                    bool _depositPause,\n                    string memory _descriptionHash)\n    external onlyGovernance {\n        require(poolInfo[_pid].lpToken != IERC20(address(0)), \"pool does not exist\");\n        set(_pid, _allocPoint);\n        poolDepositPause[_pid] = _depositPause;\n        emit SetPool(_pid, _allocPoint, _registered, _descriptionHash);\n    }\n\n    /**\n    * @dev swapBurnSend swap lptoken to HAT.\n    * send to beneficiary and governance its hats rewards .\n    * burn the rest of HAT.\n    * only governance are authorized to call this function.\n    * @param _pid the pool id\n    * @param _beneficiary beneficiary\n    * @param _amountOutMinimum minimum output of HATs at swap\n    * @param _fees the fees for the multi path swap\n    **/\n    function swapBurnSend(uint256 _pid,\n                        address _beneficiary,\n                        uint256 _amountOutMinimum,\n                        uint24[2] memory _fees)\n    external\n    onlyGovernance {\n        IERC20 token = poolInfo[_pid].lpToken;\n        uint256 amountToSwapAndBurn = swapAndBurns[address(token)];\n        uint256 amountForHackersHatRewards = hackersHatRewards[_beneficiary][address(token)];\n        uint256 amount = amountToSwapAndBurn.add(amountForHackersHatRewards).add(governanceHatRewards[address(token)]);\n        require(amount > 0, \"amount is zero\");\n        swapAndBurns[address(token)] = 0;\n        governanceHatRewards[address(token)] = 0;\n        hackersHatRewards[_beneficiary][address(token)] = 0;\n        uint256 hatsReceived = swapTokenForHAT(amount, token, _fees, _amountOutMinimum);\n        uint256 burntHats = hatsReceived.mul(amountToSwapAndBurn).div(amount);\n        if (burntHats > 0) {\n            HAT.burn(burntHats);\n        }\n        emit SwapAndBurn(_pid, amount, burntHats);\n        address tokenLock;\n        uint256 hackerReward = hatsReceived.mul(amountForHackersHatRewards).div(amount);\n        if (hackerReward > 0) {\n           //hacker get its reward via vesting contract\n            tokenLock = tokenLockFactory.createTokenLock(\n                address(HAT),\n                0x000000000000000000000000000000000000dEaD, //this address as owner, so it can do nothing.\n                _beneficiary,\n                hackerReward,\n                // solhint-disable-next-line not-rely-on-time\n                block.timestamp, //start\n                // solhint-disable-next-line not-rely-on-time\n                block.timestamp + generalParameters.hatVestingDuration, //end\n                generalParameters.hatVestingPeriods,\n                0, //no release start\n                0, //no cliff\n                ITokenLock.Revocability.Disabled,\n                true\n            );\n            HAT.transfer(tokenLock, hackerReward);\n        }\n        emit SwapAndSend(_pid, _beneficiary, amount, hackerReward, tokenLock);\n        HAT.transfer(governance(), hatsReceived.sub(hackerReward).sub(burntHats));\n    }\n\n    /**\n    * @dev withdrawRequest submit a withdraw request\n    * @param _pid the pool id\n    **/\n    function withdrawRequest(uint256 _pid) external {\n      // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp > withdrawRequests[_pid][msg.sender] + generalParameters.withdrawRequestEnablePeriod,\n        \"pending withdraw request exist\");\n        // solhint-disable-next-line not-rely-on-time\n        withdrawRequests[_pid][msg.sender] = block.timestamp + generalParameters.withdrawRequestPendingPeriod;\n        emit WithdrawRequest(_pid, msg.sender, withdrawRequests[_pid][msg.sender]);\n    }\n\n    /**\n    * @dev deposit deposit to pool\n    * @param _pid the pool id\n    * @param _amount amount of pool's token to deposit\n    **/\n    function deposit(uint256 _pid, uint256 _amount) external {\n        require(!poolDepositPause[_pid], \"deposit paused\");\n        require(_amount >= MINIMUM_DEPOSIT, \"amount less than 1e6\");\n        //clear withdraw request\n        withdrawRequests[_pid][msg.sender] = 0;\n        _deposit(_pid, _amount);\n    }\n\n    /**\n    * @dev withdraw  - withdraw user's pool share.\n    * user need first to submit a withdraw request.\n    * @param _pid the pool id\n    * @param _shares amount of shares user wants to withdraw\n    **/\n    function withdraw(uint256 _pid, uint256 _shares) external {\n        checkWithdrawRequest(_pid);\n        _withdraw(_pid, _shares);\n    }\n\n    /**\n    * @dev emergencyWithdraw withdraw all user's pool share without claim for reward.\n    * user need first to submit a withdraw request.\n    * @param _pid the pool id\n    **/\n    function emergencyWithdraw(uint256 _pid) external {\n        checkWithdrawRequest(_pid);\n        _emergencyWithdraw(_pid);\n    }\n\n    function getPoolRewardsLevels(uint256 _pid) external view returns(uint256[] memory) {\n        return poolsRewards[_pid].rewardsLevels;\n    }\n\n    function getPoolRewards(uint256 _pid) external view returns(PoolReward memory) {\n        return poolsRewards[_pid];\n    }\n\n    // GET INFO for UI\n    /**\n    * @dev getRewardPerBlock return the current pool reward per block\n    * @param _pid1 the pool id.\n    *        if _pid1 = 0 , it return the current block reward for whole pools.\n    *        otherwise it return the current block reward for _pid1-1.\n    * @return rewardPerBlock\n    **/\n    function getRewardPerBlock(uint256 _pid1) external view returns (uint256) {\n        if (_pid1 == 0) {\n            return getRewardForBlocksRange(block.number-1, block.number, 1, 1);\n        } else {\n            return getRewardForBlocksRange(block.number-1,\n                                        block.number,\n                                        poolInfo[_pid1 - 1].allocPoint,\n                                        globalPoolUpdates[globalPoolUpdates.length-1].totalAllocPoint);\n        }\n    }\n\n    function pendingReward(uint256 _pid, address _user) external view returns (uint256) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 rewardPerShare = pool.rewardPerShare;\n\n        if (block.number > pool.lastRewardBlock && pool.totalUsersAmount > 0) {\n            uint256 reward = calcPoolReward(_pid, pool.lastRewardBlock, globalPoolUpdates.length-1);\n            rewardPerShare = rewardPerShare.add(reward.mul(1e12).div(pool.totalUsersAmount));\n        }\n        return user.amount.mul(rewardPerShare).div(1e12).sub(user.rewardDebt);\n    }\n\n    function getGlobalPoolUpdatesLength() external view returns (uint256) {\n        return globalPoolUpdates.length;\n    }\n\n    function getStakedAmount(uint _pid, address _user) external view returns (uint256) {\n        UserInfo storage user = userInfo[_pid][_user];\n        return  user.amount;\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    function calcClaimRewards(uint256 _pid, uint256 _severity)\n    public\n    view\n    returns(ClaimReward memory claimRewards) {\n        uint256 totalSupply = poolInfo[_pid].balance;\n        require(totalSupply > 0, \"totalSupply is zero\");\n        require(_severity < poolsRewards[_pid].rewardsLevels.length, \"_severity is not in the range\");\n        //hackingRewardAmount\n        uint256 claimRewardAmount =\n        totalSupply.mul(poolsRewards[_pid].rewardsLevels[_severity]);\n        claimRewards.hackerVestedReward =\n        claimRewardAmount.mul(poolsRewards[_pid].rewardsSplit.hackerVestedReward)\n        .div(REWARDS_LEVEL_DENOMINATOR*REWARDS_LEVEL_DENOMINATOR);\n        claimRewards.hackerReward =\n        claimRewardAmount.mul(poolsRewards[_pid].rewardsSplit.hackerReward)\n        .div(REWARDS_LEVEL_DENOMINATOR*REWARDS_LEVEL_DENOMINATOR);\n        claimRewards.committeeReward =\n        claimRewardAmount.mul(poolsRewards[_pid].rewardsSplit.committeeReward)\n        .div(REWARDS_LEVEL_DENOMINATOR*REWARDS_LEVEL_DENOMINATOR);\n        claimRewards.swapAndBurn =\n        claimRewardAmount.mul(poolsRewards[_pid].rewardsSplit.swapAndBurn)\n        .div(REWARDS_LEVEL_DENOMINATOR*REWARDS_LEVEL_DENOMINATOR);\n        claimRewards.governanceHatReward =\n        claimRewardAmount.mul(poolsRewards[_pid].rewardsSplit.governanceHatReward)\n        .div(REWARDS_LEVEL_DENOMINATOR*REWARDS_LEVEL_DENOMINATOR);\n        claimRewards.hackerHatReward =\n        claimRewardAmount.mul(poolsRewards[_pid].rewardsSplit.hackerHatReward)\n        .div(REWARDS_LEVEL_DENOMINATOR*REWARDS_LEVEL_DENOMINATOR);\n    }\n\n    function getDefaultRewardsSplit() public pure returns (RewardsSplit memory) {\n        return RewardsSplit({\n            hackerVestedReward: 6000,\n            hackerReward: 2000,\n            committeeReward: 500,\n            swapAndBurn: 0,\n            governanceHatReward: 1000,\n            hackerHatReward: 500\n        });\n    }\n\n    function validateSplit(RewardsSplit memory _rewardsSplit) internal pure {\n        require(_rewardsSplit.hackerVestedReward\n            .add(_rewardsSplit.hackerReward)\n            .add(_rewardsSplit.committeeReward)\n            .add(_rewardsSplit.swapAndBurn)\n            .add(_rewardsSplit.governanceHatReward)\n            .add(_rewardsSplit.hackerHatReward) == REWARDS_LEVEL_DENOMINATOR,\n        \"total split % should be 10000\");\n    }\n\n    function checkWithdrawRequest(uint256 _pid) internal noPendingApproval(_pid) noSafetyPeriod {\n      // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp > withdrawRequests[_pid][msg.sender] &&\n      // solhint-disable-next-line not-rely-on-time\n                block.timestamp < withdrawRequests[_pid][msg.sender] + generalParameters.withdrawRequestEnablePeriod,\n                \"withdraw request not valid\");\n        withdrawRequests[_pid][msg.sender] = 0;\n    }\n\n    function swapTokenForHAT(uint256 _amount,\n                            IERC20 _token,\n                            uint24[2] memory _fees,\n                            uint256 _amountOutMinimum)\n    internal\n    returns (uint256 hatsReceived)\n    {\n        if (address(_token) == address(HAT)) {\n            return _amount;\n        }\n        require(_token.approve(address(uniSwapRouter), _amount), \"token approve failed\");\n        uint256 hatBalanceBefore = HAT.balanceOf(address(this));\n        address weth = uniSwapRouter.WETH9();\n        bytes memory path;\n        if (address(_token) == weth) {\n            path = abi.encodePacked(address(_token), _fees[0], address(HAT));\n        } else {\n            path = abi.encodePacked(address(_token), _fees[0], weth, _fees[1], address(HAT));\n        }\n        hatsReceived = uniSwapRouter.exactInput(ISwapRouter.ExactInputParams({\n            path: path,\n            recipient: address(this),\n            // solhint-disable-next-line not-rely-on-time\n            deadline: block.timestamp,\n            amountIn: _amount,\n            amountOutMinimum: _amountOutMinimum\n        }));\n        require(HAT.balanceOf(address(this)) - hatBalanceBefore >= _amountOutMinimum, \"wrong amount received\");\n    }\n\n    /**\n   * @dev checkRewardsLevels - check rewards levels.\n   * each level should be less than 10000\n   * if _rewardsLevels length is 0 a default reward levels will be return\n   * default reward levels = [2000, 4000, 6000, 8000]\n   * @param _rewardsLevels the reward levels array\n   * @return rewardsLevels\n */\n    function checkRewardsLevels(uint256[] memory _rewardsLevels)\n    private\n    pure\n    returns (uint256[] memory rewardsLevels) {\n\n        uint256 i;\n        if (_rewardsLevels.length == 0) {\n            rewardsLevels = new uint256[](4);\n            for (i; i < 4; i++) {\n              //defaultRewardLevels = [2000, 4000, 6000, 8000];\n                rewardsLevels[i] = 2000*(i+1);\n            }\n        } else {\n            for (i; i < _rewardsLevels.length; i++) {\n                require(_rewardsLevels[i] < REWARDS_LEVEL_DENOMINATOR, \"reward level can not be more than 10000\");\n            }\n            rewardsLevels = _rewardsLevels;\n        }\n    }\n}\n"
6     },
7     "contracts/interfaces/ISwapRouter.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function WETH9() external pure returns (address);\n}\n"
9     },
10     "openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
12     },
13     "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
15     },
16     "contracts/HATMaster.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// Disclaimer https://github.com/hats-finance/hats-contracts/blob/main/DISCLAIMER.md\n\npragma solidity 0.8.6;\n\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-solidity/contracts/utils/math/SafeMath.sol\";\nimport \"./HATToken.sol\";\nimport \"openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\";\n\n\ncontract HATMaster is ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    struct UserInfo {\n        uint256 amount;     // The user share of the pool based on the amount of lpToken the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n      //\n      // We do some fancy math here. Basically, any point in time, the amount of HATs\n      // entitled to a user but is pending to be distributed is:\n      //\n      //   pending reward = (user.amount * pool.rewardPerShare) - user.rewardDebt\n      //\n      // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n      //   1. The pool's `rewardPerShare` (and `lastRewardBlock`) gets updated.\n      //   2. User receives the pending reward sent to his/her address.\n      //   3. User's `amount` gets updated.\n      //   4. User's `rewardDebt` gets updated.\n    }\n\n    struct PoolUpdate {\n        uint256 blockNumber;// update blocknumber\n        uint256 totalAllocPoint; //totalAllocPoint\n    }\n\n    struct RewardsSplit {\n        //the percentage of the total reward to reward the hacker via vesting contract(claim reported)\n        uint256 hackerVestedReward;\n        //the percentage of the total reward to reward the hacker(claim reported)\n        uint256 hackerReward;\n        // the percentage of the total reward to be sent to the committee\n        uint256 committeeReward;\n        // the percentage of the total reward to be swap to HAT and to be burned\n        uint256 swapAndBurn;\n        // the percentage of the total reward to be swap to HAT and sent to governance\n        uint256 governanceHatReward;\n        // the percentage of the total reward to be swap to HAT and sent to the hacker\n        uint256 hackerHatReward;\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken;\n        uint256 allocPoint;\n        uint256 lastRewardBlock;\n        uint256 rewardPerShare;\n        uint256 totalUsersAmount;\n        uint256 lastProcessedTotalAllocPoint;\n        uint256 balance;\n    }\n\n    // Info of each pool.\n    struct PoolReward {\n        RewardsSplit rewardsSplit;\n        uint256[]  rewardsLevels;\n        bool committeeCheckIn;\n        uint256 vestingDuration;\n        uint256 vestingPeriods;\n    }\n\n    HATToken public immutable HAT;\n    uint256 public immutable REWARD_PER_BLOCK;\n    uint256 public immutable START_BLOCK;\n    uint256 public immutable MULTIPLIER_PERIOD;\n\n    // Info of each pool.\n    PoolInfo[] public poolInfo;\n    PoolUpdate[] public globalPoolUpdates;\n    mapping(address => uint256) public poolId1; // poolId1 count from 1, subtraction 1 before using with poolInfo\n    // Info of each user that stakes LP tokens. pid => user address => info\n    mapping (uint256 => mapping (address => UserInfo)) public userInfo;\n    //pid -> PoolReward\n    mapping (uint256=>PoolReward) internal poolsRewards;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event SendReward(address indexed user, uint256 indexed pid, uint256 amount, uint256 requestedAmount);\n    event MassUpdatePools(uint256 _fromPid, uint256 _toPid);\n\n    constructor(\n        HATToken _hat,\n        uint256 _rewardPerBlock,\n        uint256 _startBlock,\n        uint256 _multiplierPeriod\n    // solhint-disable-next-line func-visibility\n    ) {\n        HAT = _hat;\n        REWARD_PER_BLOCK = _rewardPerBlock;\n        START_BLOCK = _startBlock;\n        MULTIPLIER_PERIOD = _multiplierPeriod;\n    }\n\n  /**\n   * @dev massUpdatePools - Update reward variables for all pools\n   * Be careful of gas spending!\n   * @param _fromPid update pools range from this pool id\n   * @param _toPid update pools range to this pool id\n   */\n    function massUpdatePools(uint256 _fromPid, uint256 _toPid) external {\n        require(_toPid <= poolInfo.length, \"pool range is too big\");\n        require(_fromPid <= _toPid, \"invalid pool range\");\n        for (uint256 pid = _fromPid; pid < _toPid; ++pid) {\n            updatePool(pid);\n        }\n        emit MassUpdatePools(_fromPid, _toPid);\n    }\n\n    function claimReward(uint256 _pid) external {\n        _deposit(_pid, 0);\n    }\n\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        uint256 lastRewardBlock = pool.lastRewardBlock;\n        if (block.number <= lastRewardBlock) {\n            return;\n        }\n        uint256 totalUsersAmount = pool.totalUsersAmount;\n        uint256 lastPoolUpdate = globalPoolUpdates.length-1;\n        if (totalUsersAmount == 0) {\n            pool.lastRewardBlock = block.number;\n            pool.lastProcessedTotalAllocPoint = lastPoolUpdate;\n            return;\n        }\n        uint256 reward = calcPoolReward(_pid, lastRewardBlock, lastPoolUpdate);\n        uint256 amountCanMint = HAT.minters(address(this));\n        reward = amountCanMint < reward ? amountCanMint : reward;\n        if (reward > 0) {\n            HAT.mint(address(this), reward);\n        }\n        pool.rewardPerShare = pool.rewardPerShare.add(reward.mul(1e12).div(totalUsersAmount));\n        pool.lastRewardBlock = block.number;\n        pool.lastProcessedTotalAllocPoint = lastPoolUpdate;\n    }\n\n    /**\n     * @dev getMultiplier - multiply blocks with relevant multiplier for specific range\n     * @param _from range's from block\n     * @param _to range's to block\n     * will revert if from < START_BLOCK or _to < _from\n     */\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256 result) {\n        uint256[25] memory rewardMultipliers = [uint256(4413), 4413, 8825, 7788, 6873, 6065,\n                                            5353, 4724, 4169, 3679, 3247, 2865,\n                                            2528, 2231, 1969, 1738, 1534, 1353,\n                                            1194, 1054, 930, 821, 724, 639, 0];\n        uint256 max = rewardMultipliers.length;\n        uint256 i = (_from - START_BLOCK) / MULTIPLIER_PERIOD + 1;\n        for (; i < max; i++) {\n            uint256 endBlock = MULTIPLIER_PERIOD * i + START_BLOCK;\n            if (_to <= endBlock) {\n                break;\n            }\n            result += (endBlock - _from) * rewardMultipliers[i-1];\n            _from = endBlock;\n        }\n        result += (_to - _from) * rewardMultipliers[i > max ? (max-1) : (i-1)];\n    }\n\n    function getRewardForBlocksRange(uint256 _from, uint256 _to, uint256 _allocPoint, uint256 _totalAllocPoint)\n    public\n    view\n    returns (uint256 reward) {\n        if (_totalAllocPoint > 0) {\n            reward = getMultiplier(_from, _to).mul(REWARD_PER_BLOCK).mul(_allocPoint).div(_totalAllocPoint).div(100);\n        }\n    }\n\n    /**\n     * @dev calcPoolReward -\n     * calculate rewards for a pool by iterating over the history of totalAllocPoints updates.\n     * and sum up all rewards periods from pool.lastRewardBlock till current block number.\n     * @param _pid pool id\n     * @param _from block starting calculation\n     * @param _lastPoolUpdate lastPoolUpdate\n     * @return reward\n     */\n    function calcPoolReward(uint256 _pid, uint256 _from, uint256 _lastPoolUpdate) public view returns(uint256 reward) {\n        uint256 poolAllocPoint = poolInfo[_pid].allocPoint;\n        uint256 i = poolInfo[_pid].lastProcessedTotalAllocPoint;\n        for (; i < _lastPoolUpdate; i++) {\n            uint256 nextUpdateBlock = globalPoolUpdates[i+1].blockNumber;\n            reward =\n            reward.add(getRewardForBlocksRange(_from,\n                                            nextUpdateBlock,\n                                            poolAllocPoint,\n                                            globalPoolUpdates[i].totalAllocPoint));\n            _from = nextUpdateBlock;\n        }\n        return reward.add(getRewardForBlocksRange(_from,\n                                                block.number,\n                                                poolAllocPoint,\n                                                globalPoolUpdates[i].totalAllocPoint));\n    }\n\n    function _deposit(uint256 _pid, uint256 _amount) internal nonReentrant {\n        require(poolsRewards[_pid].committeeCheckIn, \"committee not checked in yet\");\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) {\n            uint256 pending = user.amount.mul(pool.rewardPerShare).div(1e12).sub(user.rewardDebt);\n            if (pending > 0) {\n                safeTransferReward(msg.sender, pending, _pid);\n            }\n        }\n        if (_amount > 0) {\n            uint256 lpSupply = pool.balance;\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n            pool.balance = pool.balance.add(_amount);\n            uint256 factoredAmount = _amount;\n            if (pool.totalUsersAmount > 0) {\n                factoredAmount = pool.totalUsersAmount.mul(_amount).div(lpSupply);\n            }\n            user.amount = user.amount.add(factoredAmount);\n            pool.totalUsersAmount = pool.totalUsersAmount.add(factoredAmount);\n        }\n        user.rewardDebt = user.amount.mul(pool.rewardPerShare).div(1e12);\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    function _withdraw(uint256 _pid, uint256 _amount) internal nonReentrant {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"withdraw: not enough user balance\");\n\n        updatePool(_pid);\n        uint256 pending = user.amount.mul(pool.rewardPerShare).div(1e12).sub(user.rewardDebt);\n        if (pending > 0) {\n            safeTransferReward(msg.sender, pending, _pid);\n        }\n        if (_amount > 0) {\n            user.amount = user.amount.sub(_amount);\n            uint256 amountToWithdraw = _amount.mul(pool.balance).div(pool.totalUsersAmount);\n            pool.balance = pool.balance.sub(amountToWithdraw);\n            pool.lpToken.safeTransfer(msg.sender, amountToWithdraw);\n            pool.totalUsersAmount = pool.totalUsersAmount.sub(_amount);\n        }\n        user.rewardDebt = user.amount.mul(pool.rewardPerShare).div(1e12);\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function _emergencyWithdraw(uint256 _pid) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount > 0, \"user.amount = 0\");\n        uint256 factoredBalance = user.amount.mul(pool.balance).div(pool.totalUsersAmount);\n        pool.totalUsersAmount = pool.totalUsersAmount.sub(user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n        pool.balance = pool.balance.sub(factoredBalance);\n        pool.lpToken.safeTransfer(msg.sender, factoredBalance);\n        emit EmergencyWithdraw(msg.sender, _pid, factoredBalance);\n    }\n\n    // -------- For manage pool ---------\n    function add(uint256 _allocPoint, IERC20 _lpToken) internal {\n        require(poolId1[address(_lpToken)] == 0, \"HATMaster::add: lpToken is already in pool\");\n        poolId1[address(_lpToken)] = poolInfo.length + 1;\n        uint256 lastRewardBlock = block.number > START_BLOCK ? block.number : START_BLOCK;\n        uint256 totalAllocPoint = (globalPoolUpdates.length == 0) ? _allocPoint :\n        globalPoolUpdates[globalPoolUpdates.length-1].totalAllocPoint.add(_allocPoint);\n\n        if (globalPoolUpdates.length > 0 &&\n            globalPoolUpdates[globalPoolUpdates.length-1].blockNumber == block.number) {\n           //already update in this block\n            globalPoolUpdates[globalPoolUpdates.length-1].totalAllocPoint = totalAllocPoint;\n        } else {\n            globalPoolUpdates.push(PoolUpdate({\n                blockNumber: block.number,\n                totalAllocPoint: totalAllocPoint\n            }));\n        }\n\n        poolInfo.push(PoolInfo({\n            lpToken: _lpToken,\n            allocPoint: _allocPoint,\n            lastRewardBlock: lastRewardBlock,\n            rewardPerShare: 0,\n            totalUsersAmount: 0,\n            lastProcessedTotalAllocPoint: globalPoolUpdates.length-1,\n            balance: 0\n        }));\n    }\n\n    function set(uint256 _pid, uint256 _allocPoint) internal {\n        updatePool(_pid);\n        uint256 totalAllocPoint =\n        globalPoolUpdates[globalPoolUpdates.length-1].totalAllocPoint\n        .sub(poolInfo[_pid].allocPoint).add(_allocPoint);\n\n        if (globalPoolUpdates[globalPoolUpdates.length-1].blockNumber == block.number) {\n           //already update in this block\n            globalPoolUpdates[globalPoolUpdates.length-1].totalAllocPoint = totalAllocPoint;\n        } else {\n            globalPoolUpdates.push(PoolUpdate({\n                blockNumber: block.number,\n                totalAllocPoint: totalAllocPoint\n            }));\n        }\n        poolInfo[_pid].allocPoint = _allocPoint;\n    }\n\n    // Safe HAT transfer function, just in case if rounding error causes pool to not have enough HATs.\n    function safeTransferReward(address _to, uint256 _amount, uint256 _pid) internal {\n        uint256 hatBalance = HAT.balanceOf(address(this));\n        if (_amount > hatBalance) {\n            HAT.transfer(_to, hatBalance);\n            emit SendReward(_to, _pid, hatBalance, _amount);\n        } else {\n            HAT.transfer(_to, _amount);\n            emit SendReward(_to, _pid, _amount, _amount);\n        }\n    }\n}\n"
18     },
19     "contracts/tokenlock/ITokenLockFactory.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./ITokenLock.sol\";\n\ninterface ITokenLockFactory {\n    // -- Factory --\n    function setMasterCopy(address _masterCopy) external;\n\n    function createTokenLock(\n        address _token,\n        address _owner,\n        address _beneficiary,\n        uint256 _managedAmount,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _periods,\n        uint256 _releaseStartTime,\n        uint256 _vestingCliffTime,\n        ITokenLock.Revocability _revocable,\n        bool _canDelegate\n    ) external returns(address contractAddress);\n}\n"
21     },
22     "contracts/Governable.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an governance) that can be granted exclusive access to\n * specific functions.\n *\n * The governance account will be passed on initialization of the contract. This\n * can later be changed with {setPendingGovernance and then transferGovernorship  after 2 days}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyGovernance`, which can be applied to your functions to restrict their use to\n * the governance.\n */\ncontract Governable {\n    address private _governance;\n    address public governancePending;\n    uint256 public setGovernancePendingAt;\n    uint256 public constant TIME_LOCK_DELAY = 2 days;\n\n\n    /// @notice An event thats emitted when a new governance address is set\n    event GovernorshipTransferred(address indexed _previousGovernance, address indexed _newGovernance);\n    /// @notice An event thats emitted when a new governance address is pending\n    event GovernancePending(address indexed _previousGovernance, address indexed _newGovernance, uint256 _at);\n\n    /**\n     * @dev Throws if called by any account other than the governance.\n     */\n    modifier onlyGovernance() {\n        require(msg.sender == _governance, \"only governance\");\n        _;\n    }\n\n    /**\n     * @dev setPendingGovernance set a pending governance address.\n     * NOTE: transferGovernorship can be called after a time delay of 2 days.\n     */\n    function setPendingGovernance(address _newGovernance) external  onlyGovernance {\n        require(_newGovernance != address(0), \"Governable:new governance is the zero address\");\n        governancePending = _newGovernance;\n        // solhint-disable-next-line not-rely-on-time\n        setGovernancePendingAt = block.timestamp;\n        emit GovernancePending(_governance, _newGovernance, setGovernancePendingAt);\n    }\n\n    /**\n     * @dev transferGovernorship transfer governorship to the pending governance address.\n     * NOTE: transferGovernorship can be called after a time delay of 2 days from the latest setPendingGovernance.\n     */\n    function transferGovernorship() external onlyGovernance {\n        require(setGovernancePendingAt > 0, \"Governable: no pending governance\");\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp - setGovernancePendingAt > TIME_LOCK_DELAY,\n        \"Governable: cannot confirm governance at this time\");\n        emit GovernorshipTransferred(_governance, governancePending);\n        _governance = governancePending;\n        setGovernancePendingAt = 0;\n    }\n\n    /**\n     * @dev Returns the address of the current governance.\n     */\n    function governance() public view returns (address) {\n        return _governance;\n    }\n\n    /**\n     * @dev Initializes the contract setting the initial governance.\n     */\n    function initialize(address _initialGovernance) internal {\n        _governance = _initialGovernance;\n        emit GovernorshipTransferred(address(0), _initialGovernance);\n    }\n}\n"
24     },
25     "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
27     },
28     "openzeppelin-solidity/contracts/utils/Address.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
30     },
31     "openzeppelin-solidity/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
33     },
34     "openzeppelin-solidity/contracts/utils/Context.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
36     },
37     "openzeppelin-solidity/contracts/utils/math/SafeMath.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
39     },
40     "contracts/HATToken.sol": {
41       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\nimport \"openzeppelin-solidity/contracts/utils/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\n\ncontract HATToken is IERC20 {\n\n    struct PendingMinter {\n        uint256 seedAmount;\n        uint256 setMinterPendingAt;\n    }\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice EIP-20 token name for this token\n    // solhint-disable-next-line const-name-snakecase\n    string public constant name = \"hats.finance\";\n\n    /// @notice EIP-20 token symbol for this token\n    // solhint-disable-next-line const-name-snakecase\n    string public constant symbol = \"HAT\";\n\n    /// @notice EIP-20 token decimals for this token\n    // solhint-disable-next-line const-name-snakecase\n    uint8 public constant decimals = 18;\n\n    /// @notice Total number of tokens in circulation\n    uint public override totalSupply;\n\n    address public governance;\n    address public governancePending;\n    uint256 public setGovernancePendingAt;\n    uint256 public immutable timeLockDelay;\n    uint256 public constant CAP = 10000000e18;\n\n    /// @notice Address which may mint new tokens\n    /// minter -> minting seedAmount\n    mapping (address => uint256) public minters;\n\n    /// @notice Address which may mint new tokens\n    /// minter -> minting seedAmount\n    mapping (address => PendingMinter) public pendingMinters;\n\n    // @notice Allowance amounts on behalf of others\n    mapping (address => mapping (address => uint96)) internal allowances;\n\n    // @notice Official record of token balances for each account\n    mapping (address => uint96) internal balances;\n\n    /// @notice A record of each accounts delegate\n    mapping (address => address) public delegates;\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n    keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n    keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice The EIP-712 typehash for the permit struct used by the contract\n    bytes32 public constant PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /// @notice An event thats emitted when a new minter address is pending\n    event MinterPending(address indexed minter, uint256 seedAmount, uint256 at);\n    /// @notice An event thats emitted when the minter address is changed\n    event MinterChanged(address indexed minter, uint256 seedAmount);\n    /// @notice An event thats emitted when a new governance address is pending\n    event GovernancePending(address indexed oldGovernance, address indexed newGovernance, uint256 at);\n    /// @notice An event thats emitted when a new governance address is set\n    event GovernanceChanged(address indexed oldGovernance, address indexed newGovernance);\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /**\n     * @notice Construct a new HAT token\n     */\n    // solhint-disable-next-line func-visibility\n    constructor(address _governance, uint256 _timeLockDelay) {\n        governance = _governance;\n        timeLockDelay = _timeLockDelay;\n    }\n\n    function setPendingGovernance(address _governance) external {\n        require(msg.sender == governance, \"HAT:!governance\");\n        require(_governance != address(0), \"HAT:!_governance\");\n        governancePending = _governance;\n        // solhint-disable-next-line not-rely-on-time\n        setGovernancePendingAt = block.timestamp;\n        emit GovernancePending(governance, _governance, setGovernancePendingAt);\n    }\n\n    function confirmGovernance() external {\n        require(msg.sender == governance, \"HAT:!governance\");\n        require(setGovernancePendingAt > 0, \"HAT:!governancePending\");\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp - setGovernancePendingAt > timeLockDelay,\n        \"HAT: cannot confirm governance at this time\");\n        emit GovernanceChanged(governance, governancePending);\n        governance = governancePending;\n        setGovernancePendingAt = 0;\n    }\n\n    function setPendingMinter(address _minter, uint256 _cap) external {\n        require(msg.sender == governance, \"HAT::!governance\");\n        pendingMinters[_minter].seedAmount = _cap;\n        // solhint-disable-next-line not-rely-on-time\n        pendingMinters[_minter].setMinterPendingAt = block.timestamp;\n        emit MinterPending(_minter, _cap, pendingMinters[_minter].setMinterPendingAt);\n    }\n\n    function confirmMinter(address _minter) external {\n        require(msg.sender == governance, \"HAT::mint: only the governance can confirm minter\");\n        require(pendingMinters[_minter].setMinterPendingAt > 0, \"HAT:: no pending minter was set\");\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp - pendingMinters[_minter].setMinterPendingAt > timeLockDelay,\n        \"HATToken: cannot confirm at this time\");\n        minters[_minter] = pendingMinters[_minter].seedAmount;\n        pendingMinters[_minter].setMinterPendingAt = 0;\n        emit MinterChanged(_minter, pendingMinters[_minter].seedAmount);\n    }\n\n    function burn(uint256 _amount) external {\n        return _burn(msg.sender, _amount);\n    }\n\n    function mint(address _account, uint _amount) external {\n        require(minters[msg.sender] >= _amount, \"HATToken: amount greater than limitation\");\n        minters[msg.sender] = SafeMath.sub(minters[msg.sender], _amount);\n        _mint(_account, _amount);\n    }\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external override view returns (uint) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint rawAmount) external override returns (bool) {\n        uint96 amount;\n        if (rawAmount == type(uint256).max) {\n            amount = type(uint96).max;\n        } else {\n            amount = safe96(rawAmount, \"HAT::approve: amount exceeds 96 bits\");\n        }\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint addedValue) external virtual returns (bool) {\n        require(spender != address(0), \"HAT: increaseAllowance to the zero address\");\n        uint96 valueToAdd = safe96(addedValue, \"HAT::increaseAllowance: addedValue exceeds 96 bits\");\n        allowances[msg.sender][spender] =\n        add96(allowances[msg.sender][spender], valueToAdd, \"HAT::increaseAllowance: overflows\");\n        emit Approval(msg.sender, spender, allowances[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint subtractedValue) external virtual returns (bool) {\n        require(spender != address(0), \"HAT: decreaseAllowance to the zero address\");\n        uint96 valueTosubtract = safe96(subtractedValue, \"HAT::decreaseAllowance: subtractedValue exceeds 96 bits\");\n        allowances[msg.sender][spender] = sub96(allowances[msg.sender][spender], valueTosubtract,\n        \"HAT::decreaseAllowance: spender allowance is less than subtractedValue\");\n        emit Approval(msg.sender, spender, allowances[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @notice Triggers an approval from owner to spends\n     * @param owner The address to approve from\n     * @param spender The address to be approved\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @param deadline The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function permit(address owner, address spender, uint rawAmount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        uint96 amount;\n        if (rawAmount == type(uint256).max) {\n            amount = type(uint96).max;\n        } else {\n            amount = safe96(rawAmount, \"HAT::permit: amount exceeds 96 bits\");\n        }\n\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, rawAmount, nonces[owner]++, deadline));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"HAT::permit: invalid signature\");\n        require(signatory == owner, \"HAT::permit: unauthorized\");\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp <= deadline, \"HAT::permit: signature expired\");\n\n        allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view override returns (uint) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint rawAmount) external override returns (bool) {\n        uint96 amount = safe96(rawAmount, \"HAT::transfer: amount exceeds 96 bits\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint rawAmount) external override returns (bool) {\n        address spender = msg.sender;\n        uint96 spenderAllowance = allowances[src][spender];\n        uint96 amount = safe96(rawAmount, \"HAT::approve: amount exceeds 96 bits\");\n\n        if (spender != src && spenderAllowance != type(uint96).max) {\n            uint96 newAllowance = sub96(spenderAllowance, amount,\n            \"HAT::transferFrom: transfer amount exceeds spender allowance\");\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) external {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external {\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"HAT::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"HAT::delegateBySig: invalid nonce\");\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp <= expiry, \"HAT::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint96) {\n        require(blockNumber < block.number, \"HAT::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    /**\n     * @notice Mint new tokens\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to be minted\n     */\n    function _mint(address dst, uint rawAmount) internal {\n        require(dst != address(0), \"HAT::mint: cannot transfer to the zero address\");\n        require(SafeMath.add(totalSupply, rawAmount) <= CAP, \"ERC20Capped: CAP exceeded\");\n\n        // mint the amount\n        uint96 amount = safe96(rawAmount, \"HAT::mint: amount exceeds 96 bits\");\n        totalSupply = safe96(SafeMath.add(totalSupply, amount), \"HAT::mint: totalSupply exceeds 96 bits\");\n\n        // transfer the amount to the recipient\n        balances[dst] = add96(balances[dst], amount, \"HAT::mint: transfer amount overflows\");\n        emit Transfer(address(0), dst, amount);\n\n        // move delegates\n        _moveDelegates(address(0), delegates[dst], amount);\n    }\n\n    /**\n     * Burn tokens\n     * @param src The address of the source account\n     * @param rawAmount The number of tokens to be burned\n     */\n    function _burn(address src, uint rawAmount) internal {\n        require(src != address(0), \"HAT::burn: cannot burn to the zero address\");\n\n        // burn the amount\n        uint96 amount = safe96(rawAmount, \"HAT::burn: amount exceeds 96 bits\");\n        totalSupply = safe96(SafeMath.sub(totalSupply, amount), \"HAT::mint: totalSupply exceeds 96 bits\");\n\n        // reduce the amount from src address\n        balances[src] = sub96(balances[src], amount, \"HAT::burn: burn amount exceeds balance\");\n        emit Transfer(src, address(0), amount);\n\n        // move delegates\n        _moveDelegates(delegates[src], address(0), amount);\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _transferTokens(address src, address dst, uint96 amount) internal {\n        require(src != address(0), \"HAT::_transferTokens: cannot transfer from the zero address\");\n        require(dst != address(0), \"HAT::_transferTokens: cannot transfer to the zero address\");\n\n        balances[src] = sub96(balances[src], amount, \"HAT::_transferTokens: transfer amount exceeds balance\");\n        balances[dst] = add96(balances[dst], amount, \"HAT::_transferTokens: transfer amount overflows\");\n        emit Transfer(src, dst, amount);\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"HAT::_moveVotes: vote amount underflows\");\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, \"HAT::_moveVotes: vote amount overflows\");\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\n        uint32 blockNumber = safe32(block.number, \"HAT::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function getChainId() internal view returns (uint) {\n        uint256 chainId;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}\n"
42     },
43     "openzeppelin-solidity/contracts/security/ReentrancyGuard.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
45     },
46     "contracts/tokenlock/ITokenLock.sol": {
47       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\npragma experimental ABIEncoderV2;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\ninterface ITokenLock {\n    enum Revocability { NotSet, Enabled, Disabled }\n\n    // -- Balances --\n\n    function currentBalance() external view returns (uint256);\n\n    // -- Time & Periods --\n\n    function currentTime() external view returns (uint256);\n\n    function duration() external view returns (uint256);\n\n    function sinceStartTime() external view returns (uint256);\n\n    function amountPerPeriod() external view returns (uint256);\n\n    function periodDuration() external view returns (uint256);\n\n    function currentPeriod() external view returns (uint256);\n\n    function passedPeriods() external view returns (uint256);\n\n    // -- Locking & Release Schedule --\n\n    function availableAmount() external view returns (uint256);\n\n    function vestedAmount() external view returns (uint256);\n\n    function releasableAmount() external view returns (uint256);\n\n    function totalOutstandingAmount() external view returns (uint256);\n\n    function surplusAmount() external view returns (uint256);\n\n    // -- Value Transfer --\n\n    function release() external;\n\n    function withdrawSurplus(uint256 _amount) external;\n\n    function revoke() external;\n}\n"
48     }
49   },
50   "settings": {
51     "optimizer": {
52       "enabled": true,
53       "runs": 200
54     },
55     "outputSelection": {
56       "*": {
57         "*": [
58           "evm.bytecode",
59           "evm.deployedBytecode",
60           "abi"
61         ]
62       }
63     },
64     "libraries": {}
65   }
66 }}