1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/AlchemyFactory.sol": {
5       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.6;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"./libraries/CloneLibrary.sol\";\r\n\r\n\r\n/// @author Alchemy Team\r\n/// @title AlchemyFactory\r\n/// @notice Factory contract to create new instances of Alchemy\r\ncontract AlchemyFactory {\r\n    using CloneLibrary for address;\r\n\r\n    // event that is emitted when a new Alchemy Contract was minted\r\n    event NewAlchemy(address alchemy, address governor, address timelock);\r\n\r\n    // the Alchemy governance token\r\n    IERC20 public alch;\r\n\r\n    // the factory owner\r\n    address payable public factoryOwner;\r\n    address payable public alchemyRouter;\r\n    address public alchemyImplementation;\r\n    address public governorAlphaImplementation;\r\n    address public timelockImplementation;\r\n\r\n    constructor(\r\n        IERC20 _alch,\r\n        address _alchemyImplementation,\r\n        address _governorAlphaImplementation,\r\n        address _timelockImplementation,\r\n        address payable _alchemyRouter\r\n    )\r\n    {\r\n        alch = _alch;\r\n        factoryOwner = msg.sender;\r\n        alchemyImplementation = _alchemyImplementation;\r\n        governorAlphaImplementation = _governorAlphaImplementation;\r\n        timelockImplementation = _timelockImplementation;\r\n        alchemyRouter =_alchemyRouter;\r\n    }\r\n\r\n    /**\r\n     * @dev distributes the ALCH token supply\r\n     *\r\n     * @param amount the amount to distribute\r\n    */\r\n    function distributeAlch(uint amount) internal {\r\n        if (alch.balanceOf(address(this)) >= amount) {\r\n            alch.transfer(msg.sender, amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev mints a new Alchemy Contract\r\n     *\r\n     * @param nftAddress_ the initial nft address to add to the contract\r\n     * @param owner_ the owner of the contract\r\n     * @param tokenId_ the token id of the nft to be added\r\n     * @param totalSupply_ the total supply of the erc20\r\n     * @param name_ the token name\r\n     * @param symbol_ the token symbol\r\n     * @param buyoutPrice_ the buyout price to buyout the dao\r\n     * @param votingPeriod_ the voting period for the DAO in blocks\r\n     * @param timelockDelay_ the timelock delay in seconds\r\n     * @return alchemy - the address of the newly generated alchemy contract\r\n     * governor - the address of the new governor alpha\r\n     * timelock - the address of the new timelock\r\n    */\r\n    function NFTDAOMint(\r\n        IERC721 nftAddress_,\r\n        address owner_,\r\n        uint256 tokenId_,\r\n        uint256 totalSupply_,\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint256 buyoutPrice_,\r\n        uint256 votingPeriod_,\r\n        uint256 timelockDelay_\r\n    ) public returns (address alchemy, address governor, address timelock) {\r\n        alchemy = alchemyImplementation.createClone();\r\n        governor = governorAlphaImplementation.createClone();\r\n        timelock = timelockImplementation.createClone();\r\n\r\n        nftAddress_.transferFrom(msg.sender, alchemy, tokenId_);\r\n\r\n        IGovernorAlpha(governor).initialize(\r\n            alchemy,\r\n            timelock,\r\n            totalSupply_,\r\n            votingPeriod_\r\n        );\r\n\r\n        ITimelock(timelock).initialize(governor, timelockDelay_);\r\n\r\n        IAlchemy(alchemy).initialize(\r\n            nftAddress_,\r\n            owner_,\r\n            tokenId_,\r\n            totalSupply_,\r\n            name_,\r\n            symbol_,\r\n            buyoutPrice_,\r\n            address(this),\r\n            governor,\r\n            timelock\r\n        );\r\n\r\n        // distribute gov token\r\n        distributeAlch(100 * 10 ** 18);\r\n\r\n        emit NewAlchemy(alchemy, governor, timelock);\r\n    }\r\n\r\n    /**\r\n     * @dev lets the owner transfer alch token to another address\r\n     *\r\n     * @param dst the address to send the tokens\r\n     * @param amount the token amount\r\n    */\r\n    function transferAlch(address dst, uint256 amount) external {\r\n        require(msg.sender == factoryOwner, \"Only owner\");\r\n        alch.transfer(dst, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev lets the owner change the ownership to another address\r\n     *\r\n     * @param newOwner the address of the new owner\r\n    */\r\n    function newFactoryOwner(address payable newOwner) external {\r\n        require(msg.sender == factoryOwner, \"Only owner\");\r\n        factoryOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev lets the owner change the address to another address\r\n     *\r\n     * @param newAlchemyImplementation_ the new address\r\n    */\r\n    function newAlchemyImplementation(address newAlchemyImplementation_) external {\r\n        require(msg.sender == factoryOwner, \"Only owner\");\r\n        alchemyImplementation = newAlchemyImplementation_;\r\n    }\r\n\r\n    /**\r\n     * @dev lets the owner change the address to another address\r\n     *\r\n     * @param newGovernorAlphaImplementation_ the new address\r\n    */\r\n    function newGovernorAlphaImplementation(address newGovernorAlphaImplementation_) external {\r\n        require(msg.sender == factoryOwner, \"Only owner\");\r\n        governorAlphaImplementation = newGovernorAlphaImplementation_;\r\n    }\r\n\r\n    /**\r\n     * @dev lets the owner change the address to another address\r\n     *\r\n     * @param newTimelockImplementation_ the new address\r\n    */\r\n    function newTimelockImplementation(address newTimelockImplementation_) external {\r\n        require(msg.sender == factoryOwner, \"Only owner\");\r\n        timelockImplementation = newTimelockImplementation_;\r\n    }\r\n\r\n    /**\r\n     * @dev lets the owner change the address to another address\r\n     *\r\n     * @param newRouter the address of the new router\r\n    */\r\n    function newAlchemyRouter(address payable newRouter) external {\r\n        require(msg.sender == factoryOwner, \"Only owner\");\r\n        alchemyRouter = newRouter;\r\n    }\r\n\r\n    /**\r\n     * @dev gets the address of the current alchemy router\r\n     *\r\n     * @return the address of the alchemy router\r\n    */\r\n    function getAlchemyRouter() public view returns (address payable) {\r\n        return alchemyRouter;\r\n    }\r\n}\r\n\r\n\r\ninterface IAlchemy {\r\n    function initialize(\r\n        IERC721 nftAddress_,\r\n        address owner_,\r\n        uint256 tokenId_,\r\n        uint256 totalSupply_,\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint256 buyoutPrice_,\r\n        address factoryContract,\r\n        address governor_,\r\n        address timelock_\r\n    ) external;\r\n}\r\n\r\n\r\ninterface IGovernorAlpha {\r\n    function initialize(\r\n        address nft_,\r\n        address timelock_,\r\n        uint supply_,\r\n        uint votingPeriod_\r\n    ) external;\r\n}\r\n\r\n\r\ninterface ITimelock {\r\n    function initialize(address admin_, uint delay_) external;\r\n}"
6     },
7     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
9     },
10     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
12     },
13     "contracts/libraries/CloneLibrary.sol": {
14       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\n\r\n/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2018 Murray Software, LLC.\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n//solhint-disable max-line-length\r\n//solhint-disable no-inline-assembly\r\n\r\n\r\n/**\r\n * EIP 1167 Proxy Deployment\r\n * Originally from https://github.com/optionality/clone-factory/\r\n */\r\nlibrary CloneLibrary {\r\n\r\n    function createClone(address target) internal returns (address result) {\r\n        // Reserve 55 bytes for the deploy code + 17 bytes as a buffer to prevent overwriting\r\n        // other memory in the final mstore\r\n        bytes memory cloneBuffer = new bytes(72);\r\n        assembly {\r\n            let clone := add(cloneBuffer, 32)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), shl(96, target))\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            result := create(0, clone, 0x37)\r\n        }\r\n    }\r\n\r\n\r\n    function isClone(address target, address query) internal view returns (bool result) {\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\r\n            mstore(add(clone, 0xa), shl(96, target))\r\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n\r\n            let other := add(clone, 0x40)\r\n            extcodecopy(query, other, 0, 0x2d)\r\n            result := and(\r\n                eq(mload(clone), mload(other)),\r\n                eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\r\n            )\r\n        }\r\n    }\r\n}"
15     },
16     "@openzeppelin/contracts/introspection/IERC165.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
18     }
19   },
20   "settings": {
21     "optimizer": {
22       "enabled": false,
23       "runs": 200
24     },
25     "outputSelection": {
26       "*": {
27         "*": [
28           "evm.bytecode",
29           "evm.deployedBytecode",
30           "abi"
31         ]
32       }
33     },
34     "libraries": {}
35   }
36 }}