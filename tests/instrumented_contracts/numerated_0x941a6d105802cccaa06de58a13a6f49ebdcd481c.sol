1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "istanbul",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "enabled": true,
12       "runs": 1000
13     },
14     "remappings": [],
15     "outputSelection": {
16       "*": {
17         "*": [
18           "evm.bytecode",
19           "evm.deployedBytecode",
20           "devdoc",
21           "userdoc",
22           "metadata",
23           "abi"
24         ]
25       }
26     }
27   },
28   "sources": {
29     "contracts/solidity/NFTXMarketplace0xZap.sol": {
30       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./testing/IERC1155.sol\";\nimport \"./testing/ERC721Holder.sol\";\nimport \"./testing/ERC1155Holder.sol\";\nimport \"./util/Ownable.sol\";\nimport \"./util/ReentrancyGuard.sol\";\nimport \"./util/SafeERC20.sol\";\n\n\n/**\n * @notice A partial WETH interface.\n */\n\ninterface IWETH {\n  function deposit() external payable;\n  function transfer(address to, uint value) external returns (bool);\n  function withdraw(uint) external;\n  function balanceOf(address to) external view returns (uint256);\n}\n\n\n/**\n * @notice Sets up a marketplace zap to interact with the 0x protocol. The 0x contract that\n * is hit later on handles the token conversion based on parameters that are sent from the\n * frontend.\n * \n * @author Twade\n */\n\ncontract NFTXMarketplace0xZap is Ownable, ReentrancyGuard, ERC721Holder, ERC1155Holder {\n\n  using SafeERC20 for IERC20;\n\n  /// @notice Allows zap to be paused\n  bool public paused = false;\n\n  /// @notice Sets our 0x swap target\n  address payable private immutable swapTarget;\n  \n  /// @notice An interface for the WETH contract\n  IWETH public immutable WETH;\n\n  /// @notice An interface for the NFTX Vault Factory contract\n  INFTXVaultFactory public immutable nftxFactory;\n  address public immutable feeDistributor;\n\n  /// @notice The vToken threshold below which dust is sent to feeDistributor, else back to the user\n  uint256 public dustThreshold;\n\n  /// @notice A mapping of NFTX Vault IDs to their address corresponding vault contract address\n  mapping(uint256 => address) public nftxVaultAddresses;\n\n  // Set a constant address for specific contracts that need special logic\n  address constant CRYPTO_PUNKS = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n\n  /// @notice Emitted by the `buyAndRedeem` function.\n  /// @param count The number of tokens affected by the event\n  /// @param ethSpent The amount of ETH spent in the buy\n  /// @param to The user affected by the event\n  event Buy(uint256 count, uint256 ethSpent, address to);\n\n  /// @notice Emitted by the `mintAndSell` functions.\n  /// @param count The number of tokens affected by the event\n  /// @param ethReceived The amount of ETH received in the sell\n  /// @param to The user affected by the event\n  event Sell(uint256 count, uint256 ethReceived, address to);\n\n  /// @notice Emitted by the `buyAndSwap` functions.\n  /// @param count The number of tokens affected by the event\n  /// @param ethSpent The amount of ETH spent in the swap\n  /// @param to The user affected by the event\n  event Swap(uint256 count, uint256 ethSpent, address to);\n\n  /// @notice Emitted when dust is returned after a transaction.\n  /// @param ethAmount Amount of ETH returned to user\n  /// @param vTokenAmount Amount of vToken returned to user\n  /// @param to The user affected by the event\n  event DustReturned(uint256 ethAmount, uint256 vTokenAmount, address to);\n\n\n  /**\n   * @notice Initialises our zap by setting contract addresses onto their\n   * respective interfaces.\n   * \n   * @param _nftxFactory NFTX Vault Factory contract address\n   * @param _WETH WETH contract address\n   * @param _swapTarget The swap target specified by the 0x protocol\n   */\n\n  constructor(address _nftxFactory, address _WETH, address payable _swapTarget, uint256 _dustThreshold) Ownable() ReentrancyGuard() {\n    nftxFactory = INFTXVaultFactory(_nftxFactory);\n    WETH = IWETH(_WETH);\n    swapTarget = _swapTarget;\n    feeDistributor = INFTXVaultFactory(_nftxFactory).feeDistributor();\n    dustThreshold = _dustThreshold;\n  }\n\n\n  /**\n   * @notice Mints tokens from our NFTX vault and sells them on 0x.\n   * \n   * @param vaultId The ID of the NFTX vault\n   * @param ids An array of token IDs to be minted\n   * @param swapCallData The `data` field from the API response\n   * @param to The recipient of ETH from the tx\n   */\n\n  function mintAndSell721(\n    uint256 vaultId,\n    uint256[] calldata ids,\n    bytes calldata swapCallData,\n    address payable to\n  ) external nonReentrant onlyOwnerIfPaused {\n    // Check that we aren't burning tokens or sending to ourselves\n    require(to != address(0) && to != address(this), 'Invalid recipient');\n\n    // Check that we have been provided IDs\n    require(ids.length != 0, 'Must send IDs');\n\n    // Mint our 721s against the vault\n    address vault = _mint721(vaultId, ids);\n\n    // Sell our vault token for WETH\n    uint256 amount = _fillQuote(vault, address(WETH), swapCallData);\n\n    // convert WETH to ETH and send to `to`\n    _transferAllWETH(to);\n\n    // Emit our sale event\n    emit Sell(ids.length, amount, to);\n\n    // Handle vault token dust\n    _transferDust(vault, false);\n  }\n\n\n  /**\n   * @notice Purchases vault tokens from 0x with WETH and then swaps the tokens for\n   * either random or specific token IDs from the vault. The specified recipient will\n   * receive the ERC721 tokens, as well as any WETH dust that is left over from the tx.\n   * \n   * @param vaultId The ID of the NFTX vault\n   * @param idsIn An array of random token IDs to be minted\n   * @param specificIds An array of any specific token IDs to be minted\n   * @param swapCallData The `data` field from the API response\n   * @param to The recipient of the token IDs from the tx\n   */\n\n  function buyAndSwap721(\n    uint256 vaultId, \n    uint256[] calldata idsIn, \n    uint256[] calldata specificIds,\n    bytes calldata swapCallData,\n    address payable to\n  ) external payable nonReentrant onlyOwnerIfPaused {\n    // Check that we aren't burning tokens or sending to ourselves\n    require(to != address(0) && to != address(this), 'Invalid recipient');\n\n    // Check that we have been provided IDs\n    require(idsIn.length != 0, 'Must send IDs');\n\n    // Check that we have a message value sent\n    require(msg.value > 0, 'Invalid amount');\n\n    // Wrap ETH into WETH for our contract from the sender\n    WETH.deposit{value: msg.value}();\n\n    // Get our NFTX vault\n    address vault = _vaultAddress(vaultId);\n\n    // Buy enough vault tokens to fuel our buy\n    uint256 amount = _fillQuote(address(WETH), vault, swapCallData);\n\n    // Swap our tokens for the IDs requested\n    _swap721(vaultId, idsIn, specificIds, to);\n    emit Swap(idsIn.length, amount, to);\n\n    // Transfer dust ETH to sender and handle vault token dust\n    _transferDust(vault, true);\n  }\n\n\n  /**\n   * @notice Purchases vault tokens from 0x with WETH and then redeems the tokens for\n   * either random or specific token IDs from the vault. The specified recipient will\n   * receive the ERC721 tokens, as well as any WETH dust that is left over from the tx.\n   * \n   * @param vaultId The ID of the NFTX vault\n   * @param amount The number of tokens to buy\n   * @param specificIds An array of any specific token IDs to be minted\n   * @param swapCallData The `data` field from the API response\n   * @param to The recipient of the token IDs from the tx\n   */\n\n  function buyAndRedeem(\n    uint256 vaultId,\n    uint256 amount,\n    uint256[] calldata specificIds, \n    bytes calldata swapCallData,\n    address payable to\n  ) external payable nonReentrant onlyOwnerIfPaused {\n    // Check that we aren't burning tokens or sending to ourselves\n    require(to != address(0) && to != address(this), 'Invalid recipient');\n\n    // Check that we have an amount specified\n    require(amount > 0, 'Must send amount');\n\n    // Wrap ETH into WETH for our contract from the sender\n    WETH.deposit{value: msg.value}();\n\n    // Get our vault address information\n    address vault = _vaultAddress(vaultId);\n\n    // Buy vault tokens that will cover our transaction\n    uint256 quoteAmount = _fillQuote(address(WETH), vault, swapCallData);\n\n    // check if received sufficient vault tokens\n    require(quoteAmount >= amount * 1e18, 'Insufficient vault tokens');\n\n    // Redeem token IDs from the vault\n    _redeem(vaultId, amount, specificIds, to);\n    emit Buy(amount, quoteAmount, to);\n\n    // Transfer dust ETH to sender and handle vault token dust\n    _transferDust(vault, true);\n  }\n\n\n  /**\n   * @notice Mints tokens from our NFTX vault and sells them on 0x.\n   * \n   * @param vaultId The ID of the NFTX vault\n   * @param ids An array of token IDs to be minted\n   * @param amounts The number of the corresponding ID to be minted\n   * @param swapCallData The `data` field from the API response\n   * @param to The recipient of ETH from the tx\n   */\n\n  function mintAndSell1155(\n    uint256 vaultId,\n    uint256[] calldata ids,\n    uint256[] calldata amounts,\n    bytes calldata swapCallData,\n    address payable to\n  ) external nonReentrant onlyOwnerIfPaused {\n    // Check that we aren't burning tokens or sending to ourselves\n    require(to != address(0) && to != address(this), 'Invalid recipient');\n\n    // Get a sum of the total number of IDs we have sent up, and validate that\n    // the data sent through is valid.\n    (, uint totalAmount) = _validate1155Ids(ids, amounts);\n\n    // Mint our 1155s against the vault\n    address vault = _mint1155(vaultId, ids, amounts);\n\n    // Sell our vault token for WETH\n    uint256 amount = _fillQuote(vault, address(WETH), swapCallData);\n\n    // convert WETH to ETH and send to `to`\n    _transferAllWETH(to);\n\n    // Emit our sale event\n    emit Sell(totalAmount, amount, to);\n\n    // Handle vault token dust\n    _transferDust(vault, false);\n  }\n\n\n  /**\n   * @notice Purchases vault tokens from 0x with WETH and then swaps the tokens for\n   * either random or specific token IDs from the vault. The specified recipient will\n   * receive the ERC1155 tokens, as well as any WETH dust that is left over from the tx.\n   * \n   * @param vaultId The ID of the NFTX vault\n   * @param idsIn An array of random token IDs to be minted\n   * @param specificIds An array of any specific token IDs to be minted\n   * @param swapCallData The `data` field from the API response\n   * @param to The recipient of token IDs from the tx\n   */\n\n  function buyAndSwap1155(\n    uint256 vaultId, \n    uint256[] calldata idsIn,\n    uint256[] calldata amounts,\n    uint256[] calldata specificIds,\n    bytes calldata swapCallData,\n    address payable to\n  ) external payable nonReentrant onlyOwnerIfPaused {\n    // Check that we aren't burning tokens or sending to ourselves\n    require(to != address(0) && to != address(this), 'Invalid recipient');\n\n    // Check that we have a message value sent\n    require(msg.value > 0, 'Invalid amount');\n\n    // Get a sum of the total number of IDs we have sent up, and validate that\n    // the data sent through is valid.\n    (, uint totalAmount) = _validate1155Ids(idsIn, amounts);\n\n    // Wrap ETH into WETH for our contract from the sender\n    WETH.deposit{value: msg.value}();\n\n    // Get our NFTX vault\n    address vault = _vaultAddress(vaultId);\n\n    // Buy enough vault tokens to fuel our buy\n    uint256 amount = _fillQuote(address(WETH), vault, swapCallData);\n\n    // Swap our tokens for the IDs requested\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\n    emit Swap(totalAmount, amount, to);\n\n    // Transfer dust ETH to sender and handle vault token dust\n    _transferDust(vault, true);\n  }\n\n\n  /**\n   * @param vaultId The ID of the NFTX vault\n   * @param ids An array of token IDs to be minted\n   */\n\n  function _mint721(uint256 vaultId, uint256[] memory ids) internal returns (address) {\n    // Get our vault address information\n    address vault = _vaultAddress(vaultId);\n\n    // Transfer tokens from the message sender to the vault\n    address assetAddress = INFTXVault(vault).assetAddress();\n    uint256 length = ids.length;\n\n    for (uint256 i; i < length;) {\n      transferFromERC721(assetAddress, ids[i], vault);\n\n      if (assetAddress == CRYPTO_PUNKS) {\n        _approveERC721(assetAddress, ids[i], vault);\n      }\n\n      unchecked { ++i; }\n    }\n\n    // Mint our tokens from the vault to this contract\n    uint256[] memory emptyIds;\n    INFTXVault(vault).mint(ids, emptyIds);\n\n    return vault;\n  }\n\n\n  /**\n   * @param vaultId The ID of the NFTX vault\n   * @param ids An array of token IDs to be minted\n   * @param amounts An array of amounts whose indexes map to the ids array\n   */\n\n  function _mint1155(uint256 vaultId, uint256[] memory ids, uint256[] memory amounts) internal returns (address) {\n    // Get our vault address information\n    address vault = _vaultAddress(vaultId);\n\n    // Transfer tokens from the message sender to the vault\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n    IERC1155(assetAddress).setApprovalForAll(vault, true);\n\n    // Mint our tokens from the vault to this contract\n    INFTXVault(vault).mint(ids, amounts);\n\n    return vault;\n  }\n\n\n  /**\n   * \n   * @param vaultId The ID of the NFTX vault\n   * @param idsIn An array of token IDs to be minted\n   * @param idsOut An array of token IDs to be redeemed\n   * @param to The recipient of the idsOut from the tx\n   */\n\n  function _swap721(\n    uint256 vaultId, \n    uint256[] memory idsIn,\n    uint256[] memory idsOut,\n    address to\n  ) internal returns (address) {\n    // Get our vault address information\n    address vault = _vaultAddress(vaultId);\n\n    // Transfer tokens to zap\n    address assetAddress = INFTXVault(vault).assetAddress();\n    uint256 length = idsIn.length;\n\n    for (uint256 i; i < length;) {\n      transferFromERC721(assetAddress, idsIn[i], vault);\n\n      if (assetAddress == CRYPTO_PUNKS) {\n        _approveERC721(assetAddress, idsIn[i], vault);\n      }\n\n      unchecked { ++i; }\n    }\n\n    // Swap our tokens\n    uint256[] memory emptyIds;\n    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);\n\n    return vault;\n  }\n\n\n  /**\n   * @notice Swaps 1155 tokens, transferring them from the recipient to this contract, and\n   * then sending them to the NFTX vault, that sends them to the recipient.\n   * \n   * @param vaultId The ID of the NFTX vault\n   * @param idsIn The IDs owned by the sender to be swapped\n   * @param amounts The number of each corresponding ID being swapped\n   * @param idsOut The requested IDs to be swapped for\n   * @param to The recipient of the swapped tokens\n   * \n   * @return address The address of the NFTX vault\n   */\n\n  function _swap1155(\n    uint256 vaultId, \n    uint256[] memory idsIn,\n    uint256[] memory amounts,\n    uint256[] memory idsOut,\n    address to\n  ) internal returns (address) {\n    // Get our vault address information\n    address vault = _vaultAddress(vaultId);\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, \"\");\n    IERC1155(assetAddress).setApprovalForAll(vault, true);\n    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);\n    \n    return vault;\n  }\n\n\n  /**\n   * @notice Redeems tokens from a vault to a recipient.\n   * \n   * @param vaultId The ID of the NFTX vault\n   * @param amount The number of tokens to be redeemed\n   * @param specificIds Specified token IDs if desired, otherwise will be _random_\n   * @param to The recipient of the token\n   */\n\n  function _redeem(uint256 vaultId, uint256 amount, uint256[] memory specificIds, address to) internal {\n    INFTXVault(_vaultAddress(vaultId)).redeemTo(amount, specificIds, to);\n  }\n\n\n  /**\n   * @notice Transfers our ERC721 tokens to a specified recipient.\n   * \n   * @param assetAddr Address of the asset being transferred\n   * @param tokenId The ID of the token being transferred\n   * @param to The address the token is being transferred to\n   */\n\n  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {\n    bytes memory data;\n\n    if (assetAddr == CRYPTO_PUNKS) {\n      // Fix here for frontrun attack.\n      bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n      (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n      (address nftOwner) = abi.decode(result, (address));\n      require(checkSuccess && nftOwner == msg.sender, \"Not the NFT owner\");\n      data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n    } else {\n      // We push to the vault to avoid an unneeded transfer.\n      data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n    }\n\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n\n  /**\n   * @notice Approves our ERC721 tokens to be transferred.\n   * \n   * @dev This is only required to provide special logic for Cryptopunks.\n   * \n   * @param assetAddr Address of the asset being transferred\n   * @param tokenId The ID of the token being transferred\n   * @param to The address the token is being transferred to\n   */\n\n  function _approveERC721(address assetAddr, uint256 tokenId, address to) internal virtual {\n    if (assetAddr != CRYPTO_PUNKS) {\n      return;\n    }\n\n    bytes memory data = abi.encodeWithSignature(\"offerPunkForSaleToAddress(uint256,uint256,address)\", tokenId, 0, to);\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n\n  /**\n   * @notice Swaps ERC20->ERC20 tokens held by this contract using a 0x-API quote.\n   * \n   * @dev Must attach ETH equal to the `value` field from the API response.\n   * \n   * @param sellToken The `sellTokenAddress` field from the API response\n   * @param buyToken The `buyTokenAddress` field from the API response\n   * @param swapCallData The `data` field from the API response\n   */\n\n  function _fillQuote(\n    address sellToken,\n    address buyToken,\n    bytes calldata swapCallData\n  ) internal returns (uint256) {\n    // Track our balance of the buyToken to determine how much we've bought.\n    uint256 boughtAmount = IERC20(buyToken).balanceOf(address(this));\n\n    // Give `swapTarget` an infinite allowance to spend this contract's `sellToken`.\n    // Note that for some tokens (e.g., USDT, KNC), you must first reset any existing\n    // allowance to 0 before being able to update it.\n    require(IERC20(sellToken).approve(swapTarget, type(uint256).max), 'Unable to approve contract');\n\n    // Call the encoded swap function call on the contract at `swapTarget`\n    (bool success,) = swapTarget.call(swapCallData);\n    require(success, 'SWAP_CALL_FAILED');\n\n    // Use our current buyToken balance to determine how much we've bought.\n    return IERC20(buyToken).balanceOf(address(this)) - boughtAmount;\n  }\n\n\n  /**\n   * @notice Transfers remaining ETH to msg.sender.\n   * And transfers vault token dust to feeDistributor if below dustThreshold, else to msg.sender \n   * \n   * @param vault Address of the vault token\n   * @param isWETHDust Checks and transfers WETH dust if boolean is true\n   */\n\n  function _transferDust(address vault, bool isWETHDust) internal {\n    uint256 remaining;\n    if(isWETHDust) {\n      remaining = _transferAllWETH(msg.sender);\n    }\n\n    uint256 dustBalance = IERC20(vault).balanceOf(address(this));\n    address dustRecipient;\n    if(dustBalance > 0) {\n      if (dustBalance > dustThreshold) {\n        dustRecipient = msg.sender;\n      } else {\n        dustRecipient = feeDistributor;\n      }\n\n      IERC20(vault).transfer(dustRecipient, dustBalance);\n    }\n\n    emit DustReturned(remaining, dustBalance, dustRecipient);\n  }\n\n  function _transferAllWETH(address recipient) internal returns(uint256 amount) {\n    amount = WETH.balanceOf(address(this));\n    if (amount > 0) {\n      // Unwrap our WETH into ETH and transfer it to the recipient\n      WETH.withdraw(amount);\n      (bool success, ) = payable(recipient).call{value: amount}(\"\");\n      require(success, \"Unable to send unwrapped WETH\");\n    }\n  }\n\n\n  /**\n   * @notice Allows 1155 IDs and amounts to be validated.\n   * \n   * @param ids The IDs of the 1155 tokens.\n   * @param amounts The number of each corresponding token to process.\n   * \n   * @return totalIds The number of different IDs being sent.\n   * @return totalAmount The total number of IDs being processed.\n   */\n\n  function _validate1155Ids(\n    uint[] calldata ids,\n    uint[] calldata amounts\n  ) internal pure returns (\n    uint totalIds,\n    uint totalAmount\n  ) {\n    totalIds = ids.length;\n\n    // Check that we have been provided IDs\n    require(totalIds != 0, 'Must send IDs');\n    require(totalIds <= amounts.length, 'Must define amounts against IDs');\n\n    // Sum the amounts for our emitted events\n    for (uint i; i < totalIds;) {\n      require(amounts[i] > 0, 'Invalid 1155 amount');\n\n      unchecked {\n        totalAmount += amounts[i];\n        ++i;\n      }\n    }\n  }\n\n\n  /**\n   * @notice Maps a cached NFTX vault address against a vault ID.\n   * \n   * @param vaultId The ID of the NFTX vault\n   */\n\n  function _vaultAddress(uint256 vaultId) internal returns (address) {\n    if (nftxVaultAddresses[vaultId] == address(0)) {\n      nftxVaultAddresses[vaultId] = nftxFactory.vault(vaultId);\n    }\n\n    require(nftxVaultAddresses[vaultId] != address(0), 'Vault does not exist');\n\n    return nftxVaultAddresses[vaultId];\n  }\n\n\n  /**\n   * @notice Allows our zap to be paused to prevent any processing.\n   * \n   * @param _paused New pause state\n   */\n\n  function pause(bool _paused) external onlyOwner {\n    paused = _paused;\n  }\n\n  /**\n   * @notice Allows owner to modify dustThreshold value\n   * \n   * @param _dustThreshold New dustThreshold\n   */\n\n  function setDustThreshold(uint256 _dustThreshold) external onlyOwner {\n    dustThreshold = _dustThreshold;\n  }\n\n\n  /**\n   * @notice Allows our owner to withdraw and tokens in the contract.\n   * \n   * @param token The address of the token to be rescued\n   */\n\n  function rescue(address token) external onlyOwner {\n    if (token == address(0)) {\n      (bool success, ) = payable(msg.sender).call{value: address(this).balance}(\"\");\n      require(success, \"Address: unable to send value\");\n    } else {\n      IERC20(token).safeTransfer(msg.sender, IERC20(token).balanceOf(address(this)));\n    }\n  }\n\n\n  /**\n   * @notice A modifier that only allows the owner to interact with the function\n   * if the contract is paused. If the contract is not paused then anyone can\n   * interact with the function.\n   */\n\n  modifier onlyOwnerIfPaused() {\n    require(!paused || msg.sender == owner(), \"Zap is paused\");\n    _;\n  }\n\n\n  /**\n   * @notice Allows our contract to receive any assets.\n   */\n\n  receive() external payable {}\n\n}"
31     },
32     "contracts/solidity/interface/INFTXEligibility.sol": {
33       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface INFTXEligibility {\n    // Read functions.\n    function name() external pure returns (string memory);\n\n    function finalized() external view returns (bool);\n\n    function targetAsset() external pure returns (address);\n\n    function checkAllEligible(uint256[] calldata tokenIds)\n        external\n        view\n        returns (bool);\n\n    function checkEligible(uint256[] calldata tokenIds)\n        external\n        view\n        returns (bool[] memory);\n\n    function checkAllIneligible(uint256[] calldata tokenIds)\n        external\n        view\n        returns (bool);\n\n    function checkIsEligible(uint256 tokenId) external view returns (bool);\n\n    // Write functions.\n    function __NFTXEligibility_init_bytes(bytes calldata configData) external;\n\n    function beforeMintHook(uint256[] calldata tokenIds) external;\n\n    function afterMintHook(uint256[] calldata tokenIds) external;\n\n    function beforeRedeemHook(uint256[] calldata tokenIds) external;\n\n    function afterRedeemHook(uint256[] calldata tokenIds) external;\n}\n"
34     },
35     "contracts/solidity/interface/INFTXVault.sol": {
36       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/IERC20Upgradeable.sol\";\nimport \"./INFTXVaultFactory.sol\";\nimport \"./INFTXEligibility.sol\";\n\ninterface INFTXVault is IERC20Upgradeable {\n    function manager() external view returns (address);\n\n    function assetAddress() external view returns (address);\n\n    function vaultFactory() external view returns (INFTXVaultFactory);\n\n    function eligibilityStorage() external view returns (INFTXEligibility);\n\n    function is1155() external view returns (bool);\n\n    function allowAllItems() external view returns (bool);\n\n    function enableMint() external view returns (bool);\n\n    function enableRandomRedeem() external view returns (bool);\n\n    function enableTargetRedeem() external view returns (bool);\n\n    function enableRandomSwap() external view returns (bool);\n\n    function enableTargetSwap() external view returns (bool);\n\n    function vaultId() external view returns (uint256);\n\n    function nftIdAt(uint256 holdingsIndex) external view returns (uint256);\n\n    function allHoldings() external view returns (uint256[] memory);\n\n    function totalHoldings() external view returns (uint256);\n\n    function mintFee() external view returns (uint256);\n\n    function randomRedeemFee() external view returns (uint256);\n\n    function targetRedeemFee() external view returns (uint256);\n\n    function randomSwapFee() external view returns (uint256);\n\n    function targetSwapFee() external view returns (uint256);\n\n    function vaultFees()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    event VaultInit(\n        uint256 indexed vaultId,\n        address assetAddress,\n        bool is1155,\n        bool allowAllItems\n    );\n\n    event ManagerSet(address manager);\n    event EligibilityDeployed(uint256 moduleIndex, address eligibilityAddr);\n    // event CustomEligibilityDeployed(address eligibilityAddr);\n\n    event EnableMintUpdated(bool enabled);\n    event EnableRandomRedeemUpdated(bool enabled);\n    event EnableTargetRedeemUpdated(bool enabled);\n    event EnableRandomSwapUpdated(bool enabled);\n    event EnableTargetSwapUpdated(bool enabled);\n\n    event Minted(uint256[] nftIds, uint256[] amounts, address to);\n    event Redeemed(uint256[] nftIds, uint256[] specificIds, address to);\n    event Swapped(\n        uint256[] nftIds,\n        uint256[] amounts,\n        uint256[] specificIds,\n        uint256[] redeemedIds,\n        address to\n    );\n\n    function __NFTXVault_init(\n        string calldata _name,\n        string calldata _symbol,\n        address _assetAddress,\n        bool _is1155,\n        bool _allowAllItems\n    ) external;\n\n    function finalizeVault() external;\n\n    function setVaultMetadata(string memory name_, string memory symbol_)\n        external;\n\n    function setVaultFeatures(\n        bool _enableMint,\n        bool _enableRandomRedeem,\n        bool _enableTargetRedeem,\n        bool _enableRandomSwap,\n        bool _enableTargetSwap\n    ) external;\n\n    function setFees(\n        uint256 _mintFee,\n        uint256 _randomRedeemFee,\n        uint256 _targetRedeemFee,\n        uint256 _randomSwapFee,\n        uint256 _targetSwapFee\n    ) external;\n\n    function disableVaultFees() external;\n\n    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.\n    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow\n    // a similar interface.\n    function deployEligibilityStorage(\n        uint256 moduleIndex,\n        bytes calldata initData\n    ) external returns (address);\n\n    // The manager has control over options like fees and features\n    function setManager(address _manager) external;\n\n    function mint(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts /* ignored for ERC721 vaults */\n    ) external returns (uint256);\n\n    function mintTo(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        address to\n    ) external returns (uint256);\n\n    function redeem(uint256 amount, uint256[] calldata specificIds)\n        external\n        returns (uint256[] calldata);\n\n    function redeemTo(\n        uint256 amount,\n        uint256[] calldata specificIds,\n        address to\n    ) external returns (uint256[] calldata);\n\n    function swap(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        uint256[] calldata specificIds\n    ) external returns (uint256[] calldata);\n\n    function swapTo(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        uint256[] calldata specificIds,\n        address to\n    ) external returns (uint256[] calldata);\n\n    function allValidNFTs(uint256[] calldata tokenIds)\n        external\n        view\n        returns (bool);\n}\n"
37     },
38     "contracts/solidity/interface/INFTXVaultFactory.sol": {
39       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../proxy/IBeacon.sol\";\n\ninterface INFTXVaultFactory is IBeacon {\n    // Read functions.\n    function numVaults() external view returns (uint256);\n\n    function zapContract() external view returns (address);\n\n    function zapContracts(address addr) external view returns (bool);\n\n    function feeDistributor() external view returns (address);\n\n    function eligibilityManager() external view returns (address);\n\n    function vault(uint256 vaultId) external view returns (address);\n\n    function allVaults() external view returns (address[] memory);\n\n    function vaultsForAsset(address asset)\n        external\n        view\n        returns (address[] memory);\n\n    function isLocked(uint256 id) external view returns (bool);\n\n    function excludedFromFees(address addr) external view returns (bool);\n\n    function factoryMintFee() external view returns (uint64);\n\n    function factoryRandomRedeemFee() external view returns (uint64);\n\n    function factoryTargetRedeemFee() external view returns (uint64);\n\n    function factoryRandomSwapFee() external view returns (uint64);\n\n    function factoryTargetSwapFee() external view returns (uint64);\n\n    function vaultFees(uint256 vaultId)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    event NewFeeDistributor(address oldDistributor, address newDistributor);\n    event NewZapContract(address oldZap, address newZap);\n    event UpdatedZapContract(address zap, bool excluded);\n    event FeeExclusion(address feeExcluded, bool excluded);\n    event NewEligibilityManager(address oldEligManager, address newEligManager);\n    event NewVault(\n        uint256 indexed vaultId,\n        address vaultAddress,\n        address assetAddress\n    );\n    event UpdateVaultFees(\n        uint256 vaultId,\n        uint256 mintFee,\n        uint256 randomRedeemFee,\n        uint256 targetRedeemFee,\n        uint256 randomSwapFee,\n        uint256 targetSwapFee\n    );\n    event DisableVaultFees(uint256 vaultId);\n    event UpdateFactoryFees(\n        uint256 mintFee,\n        uint256 randomRedeemFee,\n        uint256 targetRedeemFee,\n        uint256 randomSwapFee,\n        uint256 targetSwapFee\n    );\n\n    // Write functions.\n    function __NFTXVaultFactory_init(\n        address _vaultImpl,\n        address _feeDistributor\n    ) external;\n\n    function createVault(\n        string calldata name,\n        string calldata symbol,\n        address _assetAddress,\n        bool is1155,\n        bool allowAllItems\n    ) external returns (uint256);\n\n    function setFeeDistributor(address _feeDistributor) external;\n\n    function setEligibilityManager(address _eligibilityManager) external;\n\n    function setZapContract(address _zapContract, bool _excluded) external;\n\n    function setFeeExclusion(address _excludedAddr, bool excluded) external;\n\n    function setFactoryFees(\n        uint256 mintFee,\n        uint256 randomRedeemFee,\n        uint256 targetRedeemFee,\n        uint256 randomSwapFee,\n        uint256 targetSwapFee\n    ) external;\n\n    function setVaultFees(\n        uint256 vaultId,\n        uint256 mintFee,\n        uint256 randomRedeemFee,\n        uint256 targetRedeemFee,\n        uint256 randomSwapFee,\n        uint256 targetSwapFee\n    ) external;\n\n    function disableVaultFees(uint256 vaultId) external;\n}\n"
40     },
41     "contracts/solidity/proxy/IBeacon.sol": {
42       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function childImplementation() external view returns (address);\n\n    function upgradeChildTo(address newImplementation) external;\n}\n"
43     },
44     "contracts/solidity/testing/Context.sol": {
45       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
46     },
47     "contracts/solidity/testing/ERC1155Holder.sol": {
48       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
49     },
50     "contracts/solidity/testing/ERC1155Receiver.sol": {
51       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155Receiver.sol\";\nimport \"./ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n}\n"
52     },
53     "contracts/solidity/testing/ERC165.sol": {
54       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}"
55     },
56     "contracts/solidity/testing/ERC721Holder.sol": {
57       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
58     },
59     "contracts/solidity/testing/IERC1155.sol": {
60       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"
61     },
62     "contracts/solidity/testing/IERC1155Receiver.sol": {
63       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
64     },
65     "contracts/solidity/testing/IERC165.sol": {
66       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
67     },
68     "contracts/solidity/testing/IERC20.sol": {
69       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
70     },
71     "contracts/solidity/testing/IERC20Permit.sol": {
72       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
73     },
74     "contracts/solidity/testing/IERC721Receiver.sol": {
75       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
76     },
77     "contracts/solidity/token/IERC20Upgradeable.sol": {
78       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
79     },
80     "contracts/solidity/util/Address.sol": {
81       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
82     },
83     "contracts/solidity/util/Ownable.sol": {
84       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../testing/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
85     },
86     "contracts/solidity/util/ReentrancyGuard.sol": {
87       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
88     },
89     "contracts/solidity/util/SafeERC20.sol": {
90       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../testing/IERC20.sol\";\nimport \"../testing/IERC20Permit.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(\n                oldAllowance >= value,\n                \"SafeERC20: decreased allowance below zero\"\n            );\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(\n                token,\n                abi.encodeWithSelector(\n                    token.approve.selector,\n                    spender,\n                    newAllowance\n                )\n            );\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(\n            nonceAfter == nonceBefore + 1,\n            \"SafeERC20: permit did not succeed\"\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n"
91     }
92   }
93 }}