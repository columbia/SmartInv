1 /**
2  *Submitted for verification at Etherscan.io on 2023-02-25
3 */
4 
5 // SPDX-License-Identifier: MIT
6 pragma solidity ^0.8.0;
7 
8 
9 library Bytecode {
10   error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);
11 
12   /**
13     @notice Generate a creation code that results on a contract with `_code` as bytecode
14     @param _code The returning value of the resulting `creationCode`
15     @return creationCode (constructor) for new contract
16   */
17   function creationCodeFor(bytes memory _code) internal pure returns (bytes memory) {
18     /*
19       0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size
20       0x01    0x80         0x80        DUP1                size size
21       0x02    0x60         0x600e      PUSH1 14            14 size size
22       0x03    0x60         0x6000      PUSH1 00            0 14 size size
23       0x04    0x39         0x39        CODECOPY            size
24       0x05    0x60         0x6000      PUSH1 00            0 size
25       0x06    0xf3         0xf3        RETURN
26       <CODE>
27     */
28 
29     return abi.encodePacked(
30       hex"63",
31       uint32(_code.length),
32       hex"80_60_0E_60_00_39_60_00_F3",
33       _code
34     );
35   }
36 
37   /**
38     @notice Returns the size of the code on a given address
39     @param _addr Address that may or may not contain code
40     @return size of the code on the given `_addr`
41   */
42   function codeSize(address _addr) internal view returns (uint256 size) {
43     assembly { size := extcodesize(_addr) }
44   }
45 
46   /**
47     @notice Returns the code of a given address
48     @dev It will fail if `_end < _start`
49     @param _addr Address that may or may not contain code
50     @param _start number of bytes of code to skip on read
51     @param _end index before which to end extraction
52     @return oCode read from `_addr` deployed bytecode
53 
54     Forked from: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd
55   */
56   function codeAt(address _addr, uint256 _start, uint256 _end) internal view returns (bytes memory oCode) {
57     uint256 csize = codeSize(_addr);
58     if (csize == 0) return bytes("");
59 
60     if (_start > csize) return bytes("");
61     if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end); 
62 
63     unchecked {
64       uint256 reqSize = _end - _start;
65       uint256 maxSize = csize - _start;
66 
67       uint256 size = maxSize < reqSize ? maxSize : reqSize;
68 
69       assembly {
70         // allocate output byte array - this could also be done without assembly
71         // by using o_code = new bytes(size)
72         oCode := mload(0x40)
73         // new "memory end" including padding
74         mstore(0x40, add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f))))
75         // store length in memory
76         mstore(oCode, size)
77         // actually retrieve the code, this needs assembly
78         extcodecopy(_addr, add(oCode, 0x20), _start, size)
79       }
80     }
81   }
82 }
83 pragma solidity ^0.8.0;
84 
85 /**
86   @title A key-value storage with auto-generated keys for storing chunks of data with a lower write & read cost.
87   @author Agustin Aguilar <aa@horizon.io>
88   Readme: https://github.com/0xsequence/sstore2#readme
89 */
90 library SSTORE2 {
91   error WriteError();
92 
93   /**
94     @notice Stores `_data` and returns `pointer` as key for later retrieval
95     @dev The pointer is a contract address with `_data` as code
96     @param _data to be written
97     @return pointer Pointer to the written `_data`
98   */
99   function write(bytes memory _data) internal returns (address pointer) {
100     // Append 00 to _data so contract can't be called
101     // Build init code
102     bytes memory code = Bytecode.creationCodeFor(
103       abi.encodePacked(
104         hex'00',
105         _data
106       )
107     );
108 
109     // Deploy contract using create
110     assembly { pointer := create(0, add(code, 32), mload(code)) }
111 
112     // Address MUST be non-zero
113     if (pointer == address(0)) revert WriteError();
114   }
115 
116   /**
117     @notice Reads the contents of the `_pointer` code as data, skips the first byte 
118     @dev The function is intended for reading pointers generated by `write`
119     @param _pointer to be read
120     @return data read from `_pointer` contract
121   */
122   function read(address _pointer) internal view returns (bytes memory) {
123     return Bytecode.codeAt(_pointer, 1, type(uint256).max);
124   }
125 
126   /**
127     @notice Reads the contents of the `_pointer` code as data, skips the first byte 
128     @dev The function is intended for reading pointers generated by `write`
129     @param _pointer to be read
130     @param _start number of bytes to skip
131     @return data read from `_pointer` contract
132   */
133   function read(address _pointer, uint256 _start) internal view returns (bytes memory) {
134     return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);
135   }
136 
137   /**
138     @notice Reads the contents of the `_pointer` code as data, skips the first byte 
139     @dev The function is intended for reading pointers generated by `write`
140     @param _pointer to be read
141     @param _start number of bytes to skip
142     @param _end index before which to end extraction
143     @return data read from `_pointer` contract
144   */
145   function read(address _pointer, uint256 _start, uint256 _end) internal view returns (bytes memory) {
146     return Bytecode.codeAt(_pointer, _start + 1, _end + 1);
147   }
148 }
149 
150 pragma solidity >=0.8.0 <0.9.0;
151 
152 
153 library BytesLib {
154     function concat(
155         bytes memory _preBytes,
156         bytes memory _postBytes
157     )
158         internal
159         pure
160         returns (bytes memory)
161     {
162         bytes memory tempBytes;
163 
164         assembly {
165             // Get a location of some free memory and store it in tempBytes as
166             // Solidity does for memory variables.
167             tempBytes := mload(0x40)
168 
169             // Store the length of the first bytes array at the beginning of
170             // the memory for tempBytes.
171             let length := mload(_preBytes)
172             mstore(tempBytes, length)
173 
174             // Maintain a memory counter for the current write location in the
175             // temp bytes array by adding the 32 bytes for the array length to
176             // the starting location.
177             let mc := add(tempBytes, 0x20)
178             // Stop copying when the memory counter reaches the length of the
179             // first bytes array.
180             let end := add(mc, length)
181 
182             for {
183                 // Initialize a copy counter to the start of the _preBytes data,
184                 // 32 bytes into its memory.
185                 let cc := add(_preBytes, 0x20)
186             } lt(mc, end) {
187                 // Increase both counters by 32 bytes each iteration.
188                 mc := add(mc, 0x20)
189                 cc := add(cc, 0x20)
190             } {
191                 // Write the _preBytes data into the tempBytes memory 32 bytes
192                 // at a time.
193                 mstore(mc, mload(cc))
194             }
195 
196             // Add the length of _postBytes to the current length of tempBytes
197             // and store it as the new length in the first 32 bytes of the
198             // tempBytes memory.
199             length := mload(_postBytes)
200             mstore(tempBytes, add(length, mload(tempBytes)))
201 
202             // Move the memory counter back from a multiple of 0x20 to the
203             // actual end of the _preBytes data.
204             mc := end
205             // Stop copying when the memory counter reaches the new combined
206             // length of the arrays.
207             end := add(mc, length)
208 
209             for {
210                 let cc := add(_postBytes, 0x20)
211             } lt(mc, end) {
212                 mc := add(mc, 0x20)
213                 cc := add(cc, 0x20)
214             } {
215                 mstore(mc, mload(cc))
216             }
217 
218             // Update the free-memory pointer by padding our last write location
219             // to 32 bytes: add 31 bytes to the end of tempBytes to move to the
220             // next 32 byte block, then round down to the nearest multiple of
221             // 32. If the sum of the length of the two arrays is zero then add
222             // one before rounding down to leave a blank 32 bytes (the length block with 0).
223             mstore(0x40, and(
224               add(add(end, iszero(add(length, mload(_preBytes)))), 31),
225               not(31) // Round down to the nearest 32 bytes.
226             ))
227         }
228 
229         return tempBytes;
230     }
231 
232     function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {
233         assembly {
234             // Read the first 32 bytes of _preBytes storage, which is the length
235             // of the array. (We don't need to use the offset into the slot
236             // because arrays use the entire slot.)
237             let fslot := sload(_preBytes.slot)
238             // Arrays of 31 bytes or less have an even value in their slot,
239             // while longer arrays have an odd value. The actual length is
240             // the slot divided by two for odd values, and the lowest order
241             // byte divided by two for even values.
242             // If the slot is even, bitwise and the slot with 255 and divide by
243             // two to get the length. If the slot is odd, bitwise and the slot
244             // with -1 and divide by two.
245             let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)
246             let mlength := mload(_postBytes)
247             let newlength := add(slength, mlength)
248             // slength can contain both the length and contents of the array
249             // if length < 32 bytes so let's prepare for that
250             // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage
251             switch add(lt(slength, 32), lt(newlength, 32))
252             case 2 {
253                 // Since the new array still fits in the slot, we just need to
254                 // update the contents of the slot.
255                 // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length
256                 sstore(
257                     _preBytes.slot,
258                     // all the modifications to the slot are inside this
259                     // next block
260                     add(
261                         // we can just add to the slot contents because the
262                         // bytes we want to change are the LSBs
263                         fslot,
264                         add(
265                             mul(
266                                 div(
267                                     // load the bytes from memory
268                                     mload(add(_postBytes, 0x20)),
269                                     // zero all bytes to the right
270                                     exp(0x100, sub(32, mlength))
271                                 ),
272                                 // and now shift left the number of bytes to
273                                 // leave space for the length in the slot
274                                 exp(0x100, sub(32, newlength))
275                             ),
276                             // increase length by the double of the memory
277                             // bytes length
278                             mul(mlength, 2)
279                         )
280                     )
281                 )
282             }
283             case 1 {
284                 // The stored value fits in the slot, but the combined value
285                 // will exceed it.
286                 // get the keccak hash to get the contents of the array
287                 mstore(0x0, _preBytes.slot)
288                 let sc := add(keccak256(0x0, 0x20), div(slength, 32))
289 
290                 // save new length
291                 sstore(_preBytes.slot, add(mul(newlength, 2), 1))
292 
293                 // The contents of the _postBytes array start 32 bytes into
294                 // the structure. Our first read should obtain the `submod`
295                 // bytes that can fit into the unused space in the last word
296                 // of the stored array. To get this, we read 32 bytes starting
297                 // from `submod`, so the data we read overlaps with the array
298                 // contents by `submod` bytes. Masking the lowest-order
299                 // `submod` bytes allows us to add that value directly to the
300                 // stored value.
301 
302                 let submod := sub(32, slength)
303                 let mc := add(_postBytes, submod)
304                 let end := add(_postBytes, mlength)
305                 let mask := sub(exp(0x100, submod), 1)
306 
307                 sstore(
308                     sc,
309                     add(
310                         and(
311                             fslot,
312                             0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00
313                         ),
314                         and(mload(mc), mask)
315                     )
316                 )
317 
318                 for {
319                     mc := add(mc, 0x20)
320                     sc := add(sc, 1)
321                 } lt(mc, end) {
322                     sc := add(sc, 1)
323                     mc := add(mc, 0x20)
324                 } {
325                     sstore(sc, mload(mc))
326                 }
327 
328                 mask := exp(0x100, sub(mc, end))
329 
330                 sstore(sc, mul(div(mload(mc), mask), mask))
331             }
332             default {
333                 // get the keccak hash to get the contents of the array
334                 mstore(0x0, _preBytes.slot)
335                 // Start copying to the last used word of the stored array.
336                 let sc := add(keccak256(0x0, 0x20), div(slength, 32))
337 
338                 // save new length
339                 sstore(_preBytes.slot, add(mul(newlength, 2), 1))
340 
341                 // Copy over the first `submod` bytes of the new data as in
342                 // case 1 above.
343                 let slengthmod := mod(slength, 32)
344                 let mlengthmod := mod(mlength, 32)
345                 let submod := sub(32, slengthmod)
346                 let mc := add(_postBytes, submod)
347                 let end := add(_postBytes, mlength)
348                 let mask := sub(exp(0x100, submod), 1)
349 
350                 sstore(sc, add(sload(sc), and(mload(mc), mask)))
351 
352                 for {
353                     sc := add(sc, 1)
354                     mc := add(mc, 0x20)
355                 } lt(mc, end) {
356                     sc := add(sc, 1)
357                     mc := add(mc, 0x20)
358                 } {
359                     sstore(sc, mload(mc))
360                 }
361 
362                 mask := exp(0x100, sub(mc, end))
363 
364                 sstore(sc, mul(div(mload(mc), mask), mask))
365             }
366         }
367     }
368 
369     function slice(
370         bytes memory _bytes,
371         uint256 _start,
372         uint256 _length
373     )
374         internal
375         pure
376         returns (bytes memory)
377     {
378         require(_length + 31 >= _length, "slice_overflow");
379         require(_bytes.length >= _start + _length, "slice_outOfBounds");
380 
381         bytes memory tempBytes;
382 
383         assembly {
384             switch iszero(_length)
385             case 0 {
386                 // Get a location of some free memory and store it in tempBytes as
387                 // Solidity does for memory variables.
388                 tempBytes := mload(0x40)
389 
390                 // The first word of the slice result is potentially a partial
391                 // word read from the original array. To read it, we calculate
392                 // the length of that partial word and start copying that many
393                 // bytes into the array. The first word we copy will start with
394                 // data we don't care about, but the last `lengthmod` bytes will
395                 // land at the beginning of the contents of the new array. When
396                 // we're done copying, we overwrite the full first word with
397                 // the actual length of the slice.
398                 let lengthmod := and(_length, 31)
399 
400                 // The multiplication in the next line is necessary
401                 // because when slicing multiples of 32 bytes (lengthmod == 0)
402                 // the following copy loop was copying the origin's length
403                 // and then ending prematurely not copying everything it should.
404                 let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))
405                 let end := add(mc, _length)
406 
407                 for {
408                     // The multiplication in the next line has the same exact purpose
409                     // as the one above.
410                     let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
411                 } lt(mc, end) {
412                     mc := add(mc, 0x20)
413                     cc := add(cc, 0x20)
414                 } {
415                     mstore(mc, mload(cc))
416                 }
417 
418                 mstore(tempBytes, _length)
419 
420                 //update free-memory pointer
421                 //allocating the array padded to 32 bytes like the compiler does now
422                 mstore(0x40, and(add(mc, 31), not(31)))
423             }
424             //if we want a zero-length slice let's just return a zero-length array
425             default {
426                 tempBytes := mload(0x40)
427                 //zero out the 32 bytes slice we are about to return
428                 //we need to do it because Solidity does not garbage collect
429                 mstore(tempBytes, 0)
430 
431                 mstore(0x40, add(tempBytes, 0x20))
432             }
433         }
434 
435         return tempBytes;
436     }
437 
438     function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {
439         require(_bytes.length >= _start + 20, "toAddress_outOfBounds");
440         address tempAddress;
441 
442         assembly {
443             tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)
444         }
445 
446         return tempAddress;
447     }
448 
449     function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {
450         require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");
451         uint8 tempUint;
452 
453         assembly {
454             tempUint := mload(add(add(_bytes, 0x1), _start))
455         }
456 
457         return tempUint;
458     }
459 
460     function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {
461         require(_bytes.length >= _start + 2, "toUint16_outOfBounds");
462         uint16 tempUint;
463 
464         assembly {
465             tempUint := mload(add(add(_bytes, 0x2), _start))
466         }
467 
468         return tempUint;
469     }
470 
471     function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {
472         require(_bytes.length >= _start + 4, "toUint32_outOfBounds");
473         uint32 tempUint;
474 
475         assembly {
476             tempUint := mload(add(add(_bytes, 0x4), _start))
477         }
478 
479         return tempUint;
480     }
481 
482     function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {
483         require(_bytes.length >= _start + 8, "toUint64_outOfBounds");
484         uint64 tempUint;
485 
486         assembly {
487             tempUint := mload(add(add(_bytes, 0x8), _start))
488         }
489 
490         return tempUint;
491     }
492 
493     function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {
494         require(_bytes.length >= _start + 12, "toUint96_outOfBounds");
495         uint96 tempUint;
496 
497         assembly {
498             tempUint := mload(add(add(_bytes, 0xc), _start))
499         }
500 
501         return tempUint;
502     }
503 
504     function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {
505         require(_bytes.length >= _start + 16, "toUint128_outOfBounds");
506         uint128 tempUint;
507 
508         assembly {
509             tempUint := mload(add(add(_bytes, 0x10), _start))
510         }
511 
512         return tempUint;
513     }
514 
515     function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {
516         require(_bytes.length >= _start + 32, "toUint256_outOfBounds");
517         uint256 tempUint;
518 
519         assembly {
520             tempUint := mload(add(add(_bytes, 0x20), _start))
521         }
522 
523         return tempUint;
524     }
525 
526     function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {
527         require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");
528         bytes32 tempBytes32;
529 
530         assembly {
531             tempBytes32 := mload(add(add(_bytes, 0x20), _start))
532         }
533 
534         return tempBytes32;
535     }
536 
537     function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {
538         bool success = true;
539 
540         assembly {
541             let length := mload(_preBytes)
542 
543             // if lengths don't match the arrays are not equal
544             switch eq(length, mload(_postBytes))
545             case 1 {
546                 // cb is a circuit breaker in the for loop since there's
547                 //  no said feature for inline assembly loops
548                 // cb = 1 - don't breaker
549                 // cb = 0 - break
550                 let cb := 1
551 
552                 let mc := add(_preBytes, 0x20)
553                 let end := add(mc, length)
554 
555                 for {
556                     let cc := add(_postBytes, 0x20)
557                 // the next line is the loop condition:
558                 // while(uint256(mc < end) + cb == 2)
559                 } eq(add(lt(mc, end), cb), 2) {
560                     mc := add(mc, 0x20)
561                     cc := add(cc, 0x20)
562                 } {
563                     // if any of these checks fails then arrays are not equal
564                     if iszero(eq(mload(mc), mload(cc))) {
565                         // unsuccess:
566                         success := 0
567                         cb := 0
568                     }
569                 }
570             }
571             default {
572                 // unsuccess:
573                 success := 0
574             }
575         }
576 
577         return success;
578     }
579 
580     function equalStorage(
581         bytes storage _preBytes,
582         bytes memory _postBytes
583     )
584         internal
585         view
586         returns (bool)
587     {
588         bool success = true;
589 
590         assembly {
591             // we know _preBytes_offset is 0
592             let fslot := sload(_preBytes.slot)
593             // Decode the length of the stored array like in concatStorage().
594             let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)
595             let mlength := mload(_postBytes)
596 
597             // if lengths don't match the arrays are not equal
598             switch eq(slength, mlength)
599             case 1 {
600                 // slength can contain both the length and contents of the array
601                 // if length < 32 bytes so let's prepare for that
602                 // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage
603                 if iszero(iszero(slength)) {
604                     switch lt(slength, 32)
605                     case 1 {
606                         // blank the last byte which is the length
607                         fslot := mul(div(fslot, 0x100), 0x100)
608 
609                         if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {
610                             // unsuccess:
611                             success := 0
612                         }
613                     }
614                     default {
615                         // cb is a circuit breaker in the for loop since there's
616                         //  no said feature for inline assembly loops
617                         // cb = 1 - don't breaker
618                         // cb = 0 - break
619                         let cb := 1
620 
621                         // get the keccak hash to get the contents of the array
622                         mstore(0x0, _preBytes.slot)
623                         let sc := keccak256(0x0, 0x20)
624 
625                         let mc := add(_postBytes, 0x20)
626                         let end := add(mc, mlength)
627 
628                         // the next line is the loop condition:
629                         // while(uint256(mc < end) + cb == 2)
630                         for {} eq(add(lt(mc, end), cb), 2) {
631                             sc := add(sc, 1)
632                             mc := add(mc, 0x20)
633                         } {
634                             if iszero(eq(sload(sc), mload(mc))) {
635                                 // unsuccess:
636                                 success := 0
637                                 cb := 0
638                             }
639                         }
640                     }
641                 }
642             }
643             default {
644                 // unsuccess:
645                 success := 0
646             }
647         }
648 
649         return success;
650     }
651 }
652 
653 
654 
655 /**
656  *Submitted for verification at Etherscan.io on 2023-02-17
657 */
658 
659 // File: @openzeppelin/contracts/utils/structs/EnumerableSet.sol
660 
661 
662 // OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)
663 // This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.
664 
665 pragma solidity ^0.8.0;
666 
667 /**
668  * @dev Library for managing
669  * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
670  * types.
671  *
672  * Sets have the following properties:
673  *
674  * - Elements are added, removed, and checked for existence in constant time
675  * (O(1)).
676  * - Elements are enumerated in O(n). No guarantees are made on the ordering.
677  *
678  * ```
679  * contract Example {
680  *     // Add the library methods
681  *     using EnumerableSet for EnumerableSet.AddressSet;
682  *
683  *     // Declare a set state variable
684  *     EnumerableSet.AddressSet private mySet;
685  * }
686  * ```
687  *
688  * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)
689  * and `uint256` (`UintSet`) are supported.
690  *
691  * [WARNING]
692  * ====
693  * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure
694  * unusable.
695  * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.
696  *
697  * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an
698  * array of EnumerableSet.
699  * ====
700  */
701 library EnumerableSet {
702     // To implement this library for multiple types with as little code
703     // repetition as possible, we write it in terms of a generic Set type with
704     // bytes32 values.
705     // The Set implementation uses private functions, and user-facing
706     // implementations (such as AddressSet) are just wrappers around the
707     // underlying Set.
708     // This means that we can only create new EnumerableSets for types that fit
709     // in bytes32.
710 
711     struct Set {
712         // Storage of set values
713         bytes32[] _values;
714         // Position of the value in the `values` array, plus 1 because index 0
715         // means a value is not in the set.
716         mapping(bytes32 => uint256) _indexes;
717     }
718 
719     /**
720      * @dev Add a value to a set. O(1).
721      *
722      * Returns true if the value was added to the set, that is if it was not
723      * already present.
724      */
725     function _add(Set storage set, bytes32 value) private returns (bool) {
726         if (!_contains(set, value)) {
727             set._values.push(value);
728             // The value is stored at length-1, but we add 1 to all indexes
729             // and use 0 as a sentinel value
730             set._indexes[value] = set._values.length;
731             return true;
732         } else {
733             return false;
734         }
735     }
736 
737     /**
738      * @dev Removes a value from a set. O(1).
739      *
740      * Returns true if the value was removed from the set, that is if it was
741      * present.
742      */
743     function _remove(Set storage set, bytes32 value) private returns (bool) {
744         // We read and store the value's index to prevent multiple reads from the same storage slot
745         uint256 valueIndex = set._indexes[value];
746 
747         if (valueIndex != 0) {
748             // Equivalent to contains(set, value)
749             // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
750             // the array, and then remove the last element (sometimes called as 'swap and pop').
751             // This modifies the order of the array, as noted in {at}.
752 
753             uint256 toDeleteIndex = valueIndex - 1;
754             uint256 lastIndex = set._values.length - 1;
755 
756             if (lastIndex != toDeleteIndex) {
757                 bytes32 lastValue = set._values[lastIndex];
758 
759                 // Move the last value to the index where the value to delete is
760                 set._values[toDeleteIndex] = lastValue;
761                 // Update the index for the moved value
762                 set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex
763             }
764 
765             // Delete the slot where the moved value was stored
766             set._values.pop();
767 
768             // Delete the index for the deleted slot
769             delete set._indexes[value];
770 
771             return true;
772         } else {
773             return false;
774         }
775     }
776 
777     /**
778      * @dev Returns true if the value is in the set. O(1).
779      */
780     function _contains(Set storage set, bytes32 value) private view returns (bool) {
781         return set._indexes[value] != 0;
782     }
783 
784     /**
785      * @dev Returns the number of values on the set. O(1).
786      */
787     function _length(Set storage set) private view returns (uint256) {
788         return set._values.length;
789     }
790 
791     /**
792      * @dev Returns the value stored at position `index` in the set. O(1).
793      *
794      * Note that there are no guarantees on the ordering of values inside the
795      * array, and it may change when more values are added or removed.
796      *
797      * Requirements:
798      *
799      * - `index` must be strictly less than {length}.
800      */
801     function _at(Set storage set, uint256 index) private view returns (bytes32) {
802         return set._values[index];
803     }
804 
805     /**
806      * @dev Return the entire set in an array
807      *
808      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
809      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
810      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
811      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
812      */
813     function _values(Set storage set) private view returns (bytes32[] memory) {
814         return set._values;
815     }
816 
817     // Bytes32Set
818 
819     struct Bytes32Set {
820         Set _inner;
821     }
822 
823     /**
824      * @dev Add a value to a set. O(1).
825      *
826      * Returns true if the value was added to the set, that is if it was not
827      * already present.
828      */
829     function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
830         return _add(set._inner, value);
831     }
832 
833     /**
834      * @dev Removes a value from a set. O(1).
835      *
836      * Returns true if the value was removed from the set, that is if it was
837      * present.
838      */
839     function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
840         return _remove(set._inner, value);
841     }
842 
843     /**
844      * @dev Returns true if the value is in the set. O(1).
845      */
846     function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
847         return _contains(set._inner, value);
848     }
849 
850     /**
851      * @dev Returns the number of values in the set. O(1).
852      */
853     function length(Bytes32Set storage set) internal view returns (uint256) {
854         return _length(set._inner);
855     }
856 
857     /**
858      * @dev Returns the value stored at position `index` in the set. O(1).
859      *
860      * Note that there are no guarantees on the ordering of values inside the
861      * array, and it may change when more values are added or removed.
862      *
863      * Requirements:
864      *
865      * - `index` must be strictly less than {length}.
866      */
867     function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
868         return _at(set._inner, index);
869     }
870 
871     /**
872      * @dev Return the entire set in an array
873      *
874      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
875      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
876      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
877      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
878      */
879     function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {
880         bytes32[] memory store = _values(set._inner);
881         bytes32[] memory result;
882 
883         /// @solidity memory-safe-assembly
884         assembly {
885             result := store
886         }
887 
888         return result;
889     }
890 
891     // AddressSet
892 
893     struct AddressSet {
894         Set _inner;
895     }
896 
897     /**
898      * @dev Add a value to a set. O(1).
899      *
900      * Returns true if the value was added to the set, that is if it was not
901      * already present.
902      */
903     function add(AddressSet storage set, address value) internal returns (bool) {
904         return _add(set._inner, bytes32(uint256(uint160(value))));
905     }
906 
907     /**
908      * @dev Removes a value from a set. O(1).
909      *
910      * Returns true if the value was removed from the set, that is if it was
911      * present.
912      */
913     function remove(AddressSet storage set, address value) internal returns (bool) {
914         return _remove(set._inner, bytes32(uint256(uint160(value))));
915     }
916 
917     /**
918      * @dev Returns true if the value is in the set. O(1).
919      */
920     function contains(AddressSet storage set, address value) internal view returns (bool) {
921         return _contains(set._inner, bytes32(uint256(uint160(value))));
922     }
923 
924     /**
925      * @dev Returns the number of values in the set. O(1).
926      */
927     function length(AddressSet storage set) internal view returns (uint256) {
928         return _length(set._inner);
929     }
930 
931     /**
932      * @dev Returns the value stored at position `index` in the set. O(1).
933      *
934      * Note that there are no guarantees on the ordering of values inside the
935      * array, and it may change when more values are added or removed.
936      *
937      * Requirements:
938      *
939      * - `index` must be strictly less than {length}.
940      */
941     function at(AddressSet storage set, uint256 index) internal view returns (address) {
942         return address(uint160(uint256(_at(set._inner, index))));
943     }
944 
945     /**
946      * @dev Return the entire set in an array
947      *
948      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
949      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
950      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
951      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
952      */
953     function values(AddressSet storage set) internal view returns (address[] memory) {
954         bytes32[] memory store = _values(set._inner);
955         address[] memory result;
956 
957         /// @solidity memory-safe-assembly
958         assembly {
959             result := store
960         }
961 
962         return result;
963     }
964 
965     // UintSet
966 
967     struct UintSet {
968         Set _inner;
969     }
970 
971     /**
972      * @dev Add a value to a set. O(1).
973      *
974      * Returns true if the value was added to the set, that is if it was not
975      * already present.
976      */
977     function add(UintSet storage set, uint256 value) internal returns (bool) {
978         return _add(set._inner, bytes32(value));
979     }
980 
981     /**
982      * @dev Removes a value from a set. O(1).
983      *
984      * Returns true if the value was removed from the set, that is if it was
985      * present.
986      */
987     function remove(UintSet storage set, uint256 value) internal returns (bool) {
988         return _remove(set._inner, bytes32(value));
989     }
990 
991     /**
992      * @dev Returns true if the value is in the set. O(1).
993      */
994     function contains(UintSet storage set, uint256 value) internal view returns (bool) {
995         return _contains(set._inner, bytes32(value));
996     }
997 
998     /**
999      * @dev Returns the number of values in the set. O(1).
1000      */
1001     function length(UintSet storage set) internal view returns (uint256) {
1002         return _length(set._inner);
1003     }
1004 
1005     /**
1006      * @dev Returns the value stored at position `index` in the set. O(1).
1007      *
1008      * Note that there are no guarantees on the ordering of values inside the
1009      * array, and it may change when more values are added or removed.
1010      *
1011      * Requirements:
1012      *
1013      * - `index` must be strictly less than {length}.
1014      */
1015     function at(UintSet storage set, uint256 index) internal view returns (uint256) {
1016         return uint256(_at(set._inner, index));
1017     }
1018 
1019     /**
1020      * @dev Return the entire set in an array
1021      *
1022      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
1023      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
1024      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
1025      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
1026      */
1027     function values(UintSet storage set) internal view returns (uint256[] memory) {
1028         bytes32[] memory store = _values(set._inner);
1029         uint256[] memory result;
1030 
1031         /// @solidity memory-safe-assembly
1032         assembly {
1033             result := store
1034         }
1035 
1036         return result;
1037     }
1038 }
1039 
1040 // File: @openzeppelin/contracts/utils/StorageSlot.sol
1041 
1042 
1043 // OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)
1044 
1045 pragma solidity ^0.8.0;
1046 
1047 /**
1048  * @dev Library for reading and writing primitive types to specific storage slots.
1049  *
1050  * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.
1051  * This library helps with reading and writing to such slots without the need for inline assembly.
1052  *
1053  * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.
1054  *
1055  * Example usage to set ERC1967 implementation slot:
1056  * ```
1057  * contract ERC1967 {
1058  *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
1059  *
1060  *     function _getImplementation() internal view returns (address) {
1061  *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
1062  *     }
1063  *
1064  *     function _setImplementation(address newImplementation) internal {
1065  *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");
1066  *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
1067  *     }
1068  * }
1069  * ```
1070  *
1071  * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._
1072  */
1073 library StorageSlot {
1074     struct AddressSlot {
1075         address value;
1076     }
1077 
1078     struct BooleanSlot {
1079         bool value;
1080     }
1081 
1082     struct Bytes32Slot {
1083         bytes32 value;
1084     }
1085 
1086     struct Uint256Slot {
1087         uint256 value;
1088     }
1089 
1090     /**
1091      * @dev Returns an `AddressSlot` with member `value` located at `slot`.
1092      */
1093     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
1094         /// @solidity memory-safe-assembly
1095         assembly {
1096             r.slot := slot
1097         }
1098     }
1099 
1100     /**
1101      * @dev Returns an `BooleanSlot` with member `value` located at `slot`.
1102      */
1103     function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {
1104         /// @solidity memory-safe-assembly
1105         assembly {
1106             r.slot := slot
1107         }
1108     }
1109 
1110     /**
1111      * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.
1112      */
1113     function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {
1114         /// @solidity memory-safe-assembly
1115         assembly {
1116             r.slot := slot
1117         }
1118     }
1119 
1120     /**
1121      * @dev Returns an `Uint256Slot` with member `value` located at `slot`.
1122      */
1123     function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
1124         /// @solidity memory-safe-assembly
1125         assembly {
1126             r.slot := slot
1127         }
1128     }
1129 }
1130 
1131 // File: @openzeppelin/contracts/utils/Address.sol
1132 
1133 
1134 // OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)
1135 
1136 pragma solidity ^0.8.1;
1137 
1138 /**
1139  * @dev Collection of functions related to the address type
1140  */
1141 library Address {
1142     /**
1143      * @dev Returns true if `account` is a contract.
1144      *
1145      * [IMPORTANT]
1146      * ====
1147      * It is unsafe to assume that an address for which this function returns
1148      * false is an externally-owned account (EOA) and not a contract.
1149      *
1150      * Among others, `isContract` will return false for the following
1151      * types of addresses:
1152      *
1153      *  - an externally-owned account
1154      *  - a contract in construction
1155      *  - an address where a contract will be created
1156      *  - an address where a contract lived, but was destroyed
1157      * ====
1158      *
1159      * [IMPORTANT]
1160      * ====
1161      * You shouldn't rely on `isContract` to protect against flash loan attacks!
1162      *
1163      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
1164      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
1165      * constructor.
1166      * ====
1167      */
1168     function isContract(address account) internal view returns (bool) {
1169         // This method relies on extcodesize/address.code.length, which returns 0
1170         // for contracts in construction, since the code is only stored at the end
1171         // of the constructor execution.
1172 
1173         return account.code.length > 0;
1174     }
1175 
1176     /**
1177      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
1178      * `recipient`, forwarding all available gas and reverting on errors.
1179      *
1180      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
1181      * of certain opcodes, possibly making contracts go over the 2300 gas limit
1182      * imposed by `transfer`, making them unable to receive funds via
1183      * `transfer`. {sendValue} removes this limitation.
1184      *
1185      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
1186      *
1187      * IMPORTANT: because control is transferred to `recipient`, care must be
1188      * taken to not create reentrancy vulnerabilities. Consider using
1189      * {ReentrancyGuard} or the
1190      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
1191      */
1192     function sendValue(address payable recipient, uint256 amount) internal {
1193         require(address(this).balance >= amount, "Address: insufficient balance");
1194 
1195         (bool success, ) = recipient.call{value: amount}("");
1196         require(success, "Address: unable to send value, recipient may have reverted");
1197     }
1198 
1199     /**
1200      * @dev Performs a Solidity function call using a low level `call`. A
1201      * plain `call` is an unsafe replacement for a function call: use this
1202      * function instead.
1203      *
1204      * If `target` reverts with a revert reason, it is bubbled up by this
1205      * function (like regular Solidity function calls).
1206      *
1207      * Returns the raw returned data. To convert to the expected return value,
1208      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
1209      *
1210      * Requirements:
1211      *
1212      * - `target` must be a contract.
1213      * - calling `target` with `data` must not revert.
1214      *
1215      * _Available since v3.1._
1216      */
1217     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1218         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
1219     }
1220 
1221     /**
1222      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
1223      * `errorMessage` as a fallback revert reason when `target` reverts.
1224      *
1225      * _Available since v3.1._
1226      */
1227     function functionCall(
1228         address target,
1229         bytes memory data,
1230         string memory errorMessage
1231     ) internal returns (bytes memory) {
1232         return functionCallWithValue(target, data, 0, errorMessage);
1233     }
1234 
1235     /**
1236      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
1237      * but also transferring `value` wei to `target`.
1238      *
1239      * Requirements:
1240      *
1241      * - the calling contract must have an ETH balance of at least `value`.
1242      * - the called Solidity function must be `payable`.
1243      *
1244      * _Available since v3.1._
1245      */
1246     function functionCallWithValue(
1247         address target,
1248         bytes memory data,
1249         uint256 value
1250     ) internal returns (bytes memory) {
1251         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1252     }
1253 
1254     /**
1255      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
1256      * with `errorMessage` as a fallback revert reason when `target` reverts.
1257      *
1258      * _Available since v3.1._
1259      */
1260     function functionCallWithValue(
1261         address target,
1262         bytes memory data,
1263         uint256 value,
1264         string memory errorMessage
1265     ) internal returns (bytes memory) {
1266         require(address(this).balance >= value, "Address: insufficient balance for call");
1267         (bool success, bytes memory returndata) = target.call{value: value}(data);
1268         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1269     }
1270 
1271     /**
1272      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
1273      * but performing a static call.
1274      *
1275      * _Available since v3.3._
1276      */
1277     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1278         return functionStaticCall(target, data, "Address: low-level static call failed");
1279     }
1280 
1281     /**
1282      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
1283      * but performing a static call.
1284      *
1285      * _Available since v3.3._
1286      */
1287     function functionStaticCall(
1288         address target,
1289         bytes memory data,
1290         string memory errorMessage
1291     ) internal view returns (bytes memory) {
1292         (bool success, bytes memory returndata) = target.staticcall(data);
1293         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1294     }
1295 
1296     /**
1297      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
1298      * but performing a delegate call.
1299      *
1300      * _Available since v3.4._
1301      */
1302     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
1303         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
1304     }
1305 
1306     /**
1307      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
1308      * but performing a delegate call.
1309      *
1310      * _Available since v3.4._
1311      */
1312     function functionDelegateCall(
1313         address target,
1314         bytes memory data,
1315         string memory errorMessage
1316     ) internal returns (bytes memory) {
1317         (bool success, bytes memory returndata) = target.delegatecall(data);
1318         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1319     }
1320 
1321     /**
1322      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
1323      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
1324      *
1325      * _Available since v4.8._
1326      */
1327     function verifyCallResultFromTarget(
1328         address target,
1329         bool success,
1330         bytes memory returndata,
1331         string memory errorMessage
1332     ) internal view returns (bytes memory) {
1333         if (success) {
1334             if (returndata.length == 0) {
1335                 // only check isContract if the call was successful and the return data is empty
1336                 // otherwise we already know that it was a contract
1337                 require(isContract(target), "Address: call to non-contract");
1338             }
1339             return returndata;
1340         } else {
1341             _revert(returndata, errorMessage);
1342         }
1343     }
1344 
1345     /**
1346      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
1347      * revert reason or using the provided one.
1348      *
1349      * _Available since v4.3._
1350      */
1351     function verifyCallResult(
1352         bool success,
1353         bytes memory returndata,
1354         string memory errorMessage
1355     ) internal pure returns (bytes memory) {
1356         if (success) {
1357             return returndata;
1358         } else {
1359             _revert(returndata, errorMessage);
1360         }
1361     }
1362 
1363     function _revert(bytes memory returndata, string memory errorMessage) private pure {
1364         // Look for revert reason and bubble it up if present
1365         if (returndata.length > 0) {
1366             // The easiest way to bubble the revert reason is using memory via assembly
1367             /// @solidity memory-safe-assembly
1368             assembly {
1369                 let returndata_size := mload(returndata)
1370                 revert(add(32, returndata), returndata_size)
1371             }
1372         } else {
1373             revert(errorMessage);
1374         }
1375     }
1376 }
1377 
1378 // File: @openzeppelin/contracts/utils/math/Math.sol
1379 
1380 
1381 // OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)
1382 
1383 pragma solidity ^0.8.0;
1384 
1385 /**
1386  * @dev Standard math utilities missing in the Solidity language.
1387  */
1388 library Math {
1389     enum Rounding {
1390         Down, // Toward negative infinity
1391         Up, // Toward infinity
1392         Zero // Toward zero
1393     }
1394 
1395     /**
1396      * @dev Returns the largest of two numbers.
1397      */
1398     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1399         return a > b ? a : b;
1400     }
1401 
1402     /**
1403      * @dev Returns the smallest of two numbers.
1404      */
1405     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1406         return a < b ? a : b;
1407     }
1408 
1409     /**
1410      * @dev Returns the average of two numbers. The result is rounded towards
1411      * zero.
1412      */
1413     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1414         // (a + b) / 2 can overflow.
1415         return (a & b) + (a ^ b) / 2;
1416     }
1417 
1418     /**
1419      * @dev Returns the ceiling of the division of two numbers.
1420      *
1421      * This differs from standard division with `/` in that it rounds up instead
1422      * of rounding down.
1423      */
1424     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1425         // (a + b - 1) / b can overflow on addition, so we distribute.
1426         return a == 0 ? 0 : (a - 1) / b + 1;
1427     }
1428 
1429     /**
1430      * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
1431      * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
1432      * with further edits by Uniswap Labs also under MIT license.
1433      */
1434     function mulDiv(
1435         uint256 x,
1436         uint256 y,
1437         uint256 denominator
1438     ) internal pure returns (uint256 result) {
1439         unchecked {
1440             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1441             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1442             // variables such that product = prod1 * 2^256 + prod0.
1443             uint256 prod0; // Least significant 256 bits of the product
1444             uint256 prod1; // Most significant 256 bits of the product
1445             assembly {
1446                 let mm := mulmod(x, y, not(0))
1447                 prod0 := mul(x, y)
1448                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1449             }
1450 
1451             // Handle non-overflow cases, 256 by 256 division.
1452             if (prod1 == 0) {
1453                 return prod0 / denominator;
1454             }
1455 
1456             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1457             require(denominator > prod1);
1458 
1459             ///////////////////////////////////////////////
1460             // 512 by 256 division.
1461             ///////////////////////////////////////////////
1462 
1463             // Make division exact by subtracting the remainder from [prod1 prod0].
1464             uint256 remainder;
1465             assembly {
1466                 // Compute remainder using mulmod.
1467                 remainder := mulmod(x, y, denominator)
1468 
1469                 // Subtract 256 bit number from 512 bit number.
1470                 prod1 := sub(prod1, gt(remainder, prod0))
1471                 prod0 := sub(prod0, remainder)
1472             }
1473 
1474             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1475             // See https://cs.stackexchange.com/q/138556/92363.
1476 
1477             // Does not overflow because the denominator cannot be zero at this stage in the function.
1478             uint256 twos = denominator & (~denominator + 1);
1479             assembly {
1480                 // Divide denominator by twos.
1481                 denominator := div(denominator, twos)
1482 
1483                 // Divide [prod1 prod0] by twos.
1484                 prod0 := div(prod0, twos)
1485 
1486                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1487                 twos := add(div(sub(0, twos), twos), 1)
1488             }
1489 
1490             // Shift in bits from prod1 into prod0.
1491             prod0 |= prod1 * twos;
1492 
1493             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1494             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1495             // four bits. That is, denominator * inv = 1 mod 2^4.
1496             uint256 inverse = (3 * denominator) ^ 2;
1497 
1498             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1499             // in modular arithmetic, doubling the correct bits in each step.
1500             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1501             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1502             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1503             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1504             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1505             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1506 
1507             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1508             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1509             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1510             // is no longer required.
1511             result = prod0 * inverse;
1512             return result;
1513         }
1514     }
1515 
1516     /**
1517      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
1518      */
1519     function mulDiv(
1520         uint256 x,
1521         uint256 y,
1522         uint256 denominator,
1523         Rounding rounding
1524     ) internal pure returns (uint256) {
1525         uint256 result = mulDiv(x, y, denominator);
1526         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1527             result += 1;
1528         }
1529         return result;
1530     }
1531 
1532     /**
1533      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
1534      *
1535      * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
1536      */
1537     function sqrt(uint256 a) internal pure returns (uint256) {
1538         if (a == 0) {
1539             return 0;
1540         }
1541 
1542         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1543         //
1544         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1545         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1546         //
1547         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1548         //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1549         //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1550         //
1551         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1552         uint256 result = 1 << (log2(a) >> 1);
1553 
1554         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1555         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1556         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1557         // into the expected uint128 result.
1558         unchecked {
1559             result = (result + a / result) >> 1;
1560             result = (result + a / result) >> 1;
1561             result = (result + a / result) >> 1;
1562             result = (result + a / result) >> 1;
1563             result = (result + a / result) >> 1;
1564             result = (result + a / result) >> 1;
1565             result = (result + a / result) >> 1;
1566             return min(result, a / result);
1567         }
1568     }
1569 
1570     /**
1571      * @notice Calculates sqrt(a), following the selected rounding direction.
1572      */
1573     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1574         unchecked {
1575             uint256 result = sqrt(a);
1576             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1577         }
1578     }
1579 
1580     /**
1581      * @dev Return the log in base 2, rounded down, of a positive value.
1582      * Returns 0 if given 0.
1583      */
1584     function log2(uint256 value) internal pure returns (uint256) {
1585         uint256 result = 0;
1586         unchecked {
1587             if (value >> 128 > 0) {
1588                 value >>= 128;
1589                 result += 128;
1590             }
1591             if (value >> 64 > 0) {
1592                 value >>= 64;
1593                 result += 64;
1594             }
1595             if (value >> 32 > 0) {
1596                 value >>= 32;
1597                 result += 32;
1598             }
1599             if (value >> 16 > 0) {
1600                 value >>= 16;
1601                 result += 16;
1602             }
1603             if (value >> 8 > 0) {
1604                 value >>= 8;
1605                 result += 8;
1606             }
1607             if (value >> 4 > 0) {
1608                 value >>= 4;
1609                 result += 4;
1610             }
1611             if (value >> 2 > 0) {
1612                 value >>= 2;
1613                 result += 2;
1614             }
1615             if (value >> 1 > 0) {
1616                 result += 1;
1617             }
1618         }
1619         return result;
1620     }
1621 
1622     /**
1623      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
1624      * Returns 0 if given 0.
1625      */
1626     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1627         unchecked {
1628             uint256 result = log2(value);
1629             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1630         }
1631     }
1632 
1633     /**
1634      * @dev Return the log in base 10, rounded down, of a positive value.
1635      * Returns 0 if given 0.
1636      */
1637     function log10(uint256 value) internal pure returns (uint256) {
1638         uint256 result = 0;
1639         unchecked {
1640             if (value >= 10**64) {
1641                 value /= 10**64;
1642                 result += 64;
1643             }
1644             if (value >= 10**32) {
1645                 value /= 10**32;
1646                 result += 32;
1647             }
1648             if (value >= 10**16) {
1649                 value /= 10**16;
1650                 result += 16;
1651             }
1652             if (value >= 10**8) {
1653                 value /= 10**8;
1654                 result += 8;
1655             }
1656             if (value >= 10**4) {
1657                 value /= 10**4;
1658                 result += 4;
1659             }
1660             if (value >= 10**2) {
1661                 value /= 10**2;
1662                 result += 2;
1663             }
1664             if (value >= 10**1) {
1665                 result += 1;
1666             }
1667         }
1668         return result;
1669     }
1670 
1671     /**
1672      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
1673      * Returns 0 if given 0.
1674      */
1675     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1676         unchecked {
1677             uint256 result = log10(value);
1678             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1679         }
1680     }
1681 
1682     /**
1683      * @dev Return the log in base 256, rounded down, of a positive value.
1684      * Returns 0 if given 0.
1685      *
1686      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
1687      */
1688     function log256(uint256 value) internal pure returns (uint256) {
1689         uint256 result = 0;
1690         unchecked {
1691             if (value >> 128 > 0) {
1692                 value >>= 128;
1693                 result += 16;
1694             }
1695             if (value >> 64 > 0) {
1696                 value >>= 64;
1697                 result += 8;
1698             }
1699             if (value >> 32 > 0) {
1700                 value >>= 32;
1701                 result += 4;
1702             }
1703             if (value >> 16 > 0) {
1704                 value >>= 16;
1705                 result += 2;
1706             }
1707             if (value >> 8 > 0) {
1708                 result += 1;
1709             }
1710         }
1711         return result;
1712     }
1713 
1714     /**
1715      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
1716      * Returns 0 if given 0.
1717      */
1718     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1719         unchecked {
1720             uint256 result = log256(value);
1721             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1722         }
1723     }
1724 }
1725 
1726 // File: @openzeppelin/contracts/utils/Strings.sol
1727 
1728 
1729 // OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)
1730 
1731 pragma solidity ^0.8.0;
1732 
1733 
1734 /**
1735  * @dev String operations.
1736  */
1737 library Strings {
1738     bytes16 private constant _SYMBOLS = "0123456789abcdef";
1739     uint8 private constant _ADDRESS_LENGTH = 20;
1740 
1741     /**
1742      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
1743      */
1744     function toString(uint256 value) internal pure returns (string memory) {
1745         unchecked {
1746             uint256 length = Math.log10(value) + 1;
1747             string memory buffer = new string(length);
1748             uint256 ptr;
1749             /// @solidity memory-safe-assembly
1750             assembly {
1751                 ptr := add(buffer, add(32, length))
1752             }
1753             while (true) {
1754                 ptr--;
1755                 /// @solidity memory-safe-assembly
1756                 assembly {
1757                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1758                 }
1759                 value /= 10;
1760                 if (value == 0) break;
1761             }
1762             return buffer;
1763         }
1764     }
1765 
1766     /**
1767      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
1768      */
1769     function toHexString(uint256 value) internal pure returns (string memory) {
1770         unchecked {
1771             return toHexString(value, Math.log256(value) + 1);
1772         }
1773     }
1774 
1775     /**
1776      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
1777      */
1778     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
1779         bytes memory buffer = new bytes(2 * length + 2);
1780         buffer[0] = "0";
1781         buffer[1] = "x";
1782         for (uint256 i = 2 * length + 1; i > 1; --i) {
1783             buffer[i] = _SYMBOLS[value & 0xf];
1784             value >>= 4;
1785         }
1786         require(value == 0, "Strings: hex length insufficient");
1787         return string(buffer);
1788     }
1789 
1790     /**
1791      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
1792      */
1793     function toHexString(address addr) internal pure returns (string memory) {
1794         return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
1795     }
1796 }
1797 
1798 // File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
1799 
1800 
1801 // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)
1802 
1803 pragma solidity ^0.8.0;
1804 
1805 /**
1806  * @title ERC721 token receiver interface
1807  * @dev Interface for any contract that wants to support safeTransfers
1808  * from ERC721 asset contracts.
1809  */
1810 interface IERC721Receiver {
1811     /**
1812      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
1813      * by `operator` from `from`, this function is called.
1814      *
1815      * It must return its Solidity selector to confirm the token transfer.
1816      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
1817      *
1818      * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
1819      */
1820     function onERC721Received(
1821         address operator,
1822         address from,
1823         uint256 tokenId,
1824         bytes calldata data
1825     ) external returns (bytes4);
1826 }
1827 
1828 // File: solidity-bits/contracts/Popcount.sol
1829 
1830 
1831 /**
1832    _____       ___     ___ __           ____  _ __      
1833   / ___/____  / (_)___/ (_) /___  __   / __ )(_) /______
1834   \__ \/ __ \/ / / __  / / __/ / / /  / __  / / __/ ___/
1835  ___/ / /_/ / / / /_/ / / /_/ /_/ /  / /_/ / / /_(__  ) 
1836 /____/\____/_/_/\__,_/_/\__/\__, /  /_____/_/\__/____/  
1837                            /____/                        
1838 
1839 - npm: https://www.npmjs.com/package/solidity-bits
1840 - github: https://github.com/estarriolvetch/solidity-bits
1841 
1842  */
1843 
1844 pragma solidity ^0.8.0;
1845 
1846 library Popcount {
1847     uint256 private constant m1 = 0x5555555555555555555555555555555555555555555555555555555555555555;
1848     uint256 private constant m2 = 0x3333333333333333333333333333333333333333333333333333333333333333;
1849     uint256 private constant m4 = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;
1850     uint256 private constant h01 = 0x0101010101010101010101010101010101010101010101010101010101010101;
1851 
1852     function popcount256A(uint256 x) internal pure returns (uint256 count) {
1853         unchecked{
1854             for (count=0; x!=0; count++)
1855                 x &= x - 1;
1856         }
1857     }
1858 
1859     function popcount256B(uint256 x) internal pure returns (uint256) {
1860         if (x == type(uint256).max) {
1861             return 256;
1862         }
1863         unchecked {
1864             x -= (x >> 1) & m1;             //put count of each 2 bits into those 2 bits
1865             x = (x & m2) + ((x >> 2) & m2); //put count of each 4 bits into those 4 bits 
1866             x = (x + (x >> 4)) & m4;        //put count of each 8 bits into those 8 bits 
1867             x = (x * h01) >> 248;  //returns left 8 bits of x + (x<<8) + (x<<16) + (x<<24) + ... 
1868         }
1869         return x;
1870     }
1871 }
1872 // File: solidity-bits/contracts/BitScan.sol
1873 
1874 
1875 /**
1876    _____       ___     ___ __           ____  _ __      
1877   / ___/____  / (_)___/ (_) /___  __   / __ )(_) /______
1878   \__ \/ __ \/ / / __  / / __/ / / /  / __  / / __/ ___/
1879  ___/ / /_/ / / / /_/ / / /_/ /_/ /  / /_/ / / /_(__  ) 
1880 /____/\____/_/_/\__,_/_/\__/\__, /  /_____/_/\__/____/  
1881                            /____/                        
1882 
1883 - npm: https://www.npmjs.com/package/solidity-bits
1884 - github: https://github.com/estarriolvetch/solidity-bits
1885 
1886  */
1887 
1888 pragma solidity ^0.8.0;
1889 
1890 
1891 library BitScan {
1892     uint256 constant private DEBRUIJN_256 = 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff;
1893     bytes constant private LOOKUP_TABLE_256 = hex"0001020903110a19042112290b311a3905412245134d2a550c5d32651b6d3a7506264262237d468514804e8d2b95569d0d495ea533a966b11c886eb93bc176c9071727374353637324837e9b47af86c7155181ad4fd18ed32c9096db57d59ee30e2e4a6a5f92a6be3498aae067ddb2eb1d5989b56fd7baf33ca0c2ee77e5caf7ff0810182028303840444c545c646c7425617c847f8c949c48a4a8b087b8c0c816365272829aaec650acd0d28fdad4e22d6991bd97dfdcea58b4d6f29fede4f6fe0f1f2f3f4b5b6b607b8b93a3a7b7bf357199c5abcfd9e168bcdee9b3f1ecf5fd1e3e5a7a8aa2b670c4ced8bbe8f0f4fc3d79a1c3cde7effb78cce6facbf9f8";
1894 
1895     /**
1896         @dev Isolate the least significant set bit.
1897      */ 
1898     function isolateLS1B256(uint256 bb) pure internal returns (uint256) {
1899         require(bb > 0);
1900         unchecked {
1901             return bb & (0 - bb);
1902         }
1903     } 
1904 
1905     /**
1906         @dev Isolate the most significant set bit.
1907      */ 
1908     function isolateMS1B256(uint256 bb) pure internal returns (uint256) {
1909         require(bb > 0);
1910         unchecked {
1911             bb |= bb >> 128;
1912             bb |= bb >> 64;
1913             bb |= bb >> 32;
1914             bb |= bb >> 16;
1915             bb |= bb >> 8;
1916             bb |= bb >> 4;
1917             bb |= bb >> 2;
1918             bb |= bb >> 1;
1919             
1920             return (bb >> 1) + 1;
1921         }
1922     } 
1923 
1924     /**
1925         @dev Find the index of the lest significant set bit. (trailing zero count)
1926      */ 
1927     function bitScanForward256(uint256 bb) pure internal returns (uint8) {
1928         unchecked {
1929             return uint8(LOOKUP_TABLE_256[(isolateLS1B256(bb) * DEBRUIJN_256) >> 248]);
1930         }   
1931     }
1932 
1933     /**
1934         @dev Find the index of the most significant set bit.
1935      */ 
1936     function bitScanReverse256(uint256 bb) pure internal returns (uint8) {
1937         unchecked {
1938             return 255 - uint8(LOOKUP_TABLE_256[((isolateMS1B256(bb) * DEBRUIJN_256) >> 248)]);
1939         }   
1940     }
1941 
1942     function log2(uint256 bb) pure internal returns (uint8) {
1943         unchecked {
1944             return uint8(LOOKUP_TABLE_256[(isolateMS1B256(bb) * DEBRUIJN_256) >> 248]);
1945         } 
1946     }
1947 }
1948 
1949 // File: solidity-bits/contracts/BitMaps.sol
1950 
1951 
1952 /**
1953    _____       ___     ___ __           ____  _ __      
1954   / ___/____  / (_)___/ (_) /___  __   / __ )(_) /______
1955   \__ \/ __ \/ / / __  / / __/ / / /  / __  / / __/ ___/
1956  ___/ / /_/ / / / /_/ / / /_/ /_/ /  / /_/ / / /_(__  ) 
1957 /____/\____/_/_/\__,_/_/\__/\__, /  /_____/_/\__/____/  
1958                            /____/                        
1959 
1960 - npm: https://www.npmjs.com/package/solidity-bits
1961 - github: https://github.com/estarriolvetch/solidity-bits
1962 
1963  */
1964 pragma solidity ^0.8.0;
1965 
1966 
1967 
1968 /**
1969  * @dev This Library is a modified version of Openzeppelin's BitMaps library with extra features.
1970  *
1971  * 1. Functions of finding the index of the closest set bit from a given index are added.
1972  *    The indexing of each bucket is modifed to count from the MSB to the LSB instead of from the LSB to the MSB.
1973  *    The modification of indexing makes finding the closest previous set bit more efficient in gas usage.
1974  * 2. Setting and unsetting the bitmap consecutively.
1975  * 3. Accounting number of set bits within a given range.   
1976  *
1977 */
1978 
1979 /**
1980  * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.
1981  * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].
1982  */
1983 
1984 library BitMaps {
1985     using BitScan for uint256;
1986     uint256 private constant MASK_INDEX_ZERO = (1 << 255);
1987     uint256 private constant MASK_FULL = type(uint256).max;
1988 
1989     struct BitMap {
1990         mapping(uint256 => uint256) _data;
1991     }
1992 
1993     /**
1994      * @dev Returns whether the bit at `index` is set.
1995      */
1996     function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {
1997         uint256 bucket = index >> 8;
1998         uint256 mask = MASK_INDEX_ZERO >> (index & 0xff);
1999         return bitmap._data[bucket] & mask != 0;
2000     }
2001 
2002     /**
2003      * @dev Sets the bit at `index` to the boolean `value`.
2004      */
2005     function setTo(
2006         BitMap storage bitmap,
2007         uint256 index,
2008         bool value
2009     ) internal {
2010         if (value) {
2011             set(bitmap, index);
2012         } else {
2013             unset(bitmap, index);
2014         }
2015     }
2016 
2017     /**
2018      * @dev Sets the bit at `index`.
2019      */
2020     function set(BitMap storage bitmap, uint256 index) internal {
2021         uint256 bucket = index >> 8;
2022         uint256 mask = MASK_INDEX_ZERO >> (index & 0xff);
2023         bitmap._data[bucket] |= mask;
2024     }
2025 
2026     /**
2027      * @dev Unsets the bit at `index`.
2028      */
2029     function unset(BitMap storage bitmap, uint256 index) internal {
2030         uint256 bucket = index >> 8;
2031         uint256 mask = MASK_INDEX_ZERO >> (index & 0xff);
2032         bitmap._data[bucket] &= ~mask;
2033     }
2034 
2035 
2036     /**
2037      * @dev Consecutively sets `amount` of bits starting from the bit at `startIndex`.
2038      */    
2039     function setBatch(BitMap storage bitmap, uint256 startIndex, uint256 amount) internal {
2040         uint256 bucket = startIndex >> 8;
2041 
2042         uint256 bucketStartIndex = (startIndex & 0xff);
2043 
2044         unchecked {
2045             if(bucketStartIndex + amount < 256) {
2046                 bitmap._data[bucket] |= MASK_FULL << (256 - amount) >> bucketStartIndex;
2047             } else {
2048                 bitmap._data[bucket] |= MASK_FULL >> bucketStartIndex;
2049                 amount -= (256 - bucketStartIndex);
2050                 bucket++;
2051 
2052                 while(amount > 256) {
2053                     bitmap._data[bucket] = MASK_FULL;
2054                     amount -= 256;
2055                     bucket++;
2056                 }
2057 
2058                 bitmap._data[bucket] |= MASK_FULL << (256 - amount);
2059             }
2060         }
2061     }
2062 
2063 
2064     /**
2065      * @dev Consecutively unsets `amount` of bits starting from the bit at `startIndex`.
2066      */    
2067     function unsetBatch(BitMap storage bitmap, uint256 startIndex, uint256 amount) internal {
2068         uint256 bucket = startIndex >> 8;
2069 
2070         uint256 bucketStartIndex = (startIndex & 0xff);
2071 
2072         unchecked {
2073             if(bucketStartIndex + amount < 256) {
2074                 bitmap._data[bucket] &= ~(MASK_FULL << (256 - amount) >> bucketStartIndex);
2075             } else {
2076                 bitmap._data[bucket] &= ~(MASK_FULL >> bucketStartIndex);
2077                 amount -= (256 - bucketStartIndex);
2078                 bucket++;
2079 
2080                 while(amount > 256) {
2081                     bitmap._data[bucket] = 0;
2082                     amount -= 256;
2083                     bucket++;
2084                 }
2085 
2086                 bitmap._data[bucket] &= ~(MASK_FULL << (256 - amount));
2087             }
2088         }
2089     }
2090 
2091     /**
2092      * @dev Returns number of set bits within a range.
2093      */
2094     function popcountA(BitMap storage bitmap, uint256 startIndex, uint256 amount) internal view returns(uint256 count) {
2095         uint256 bucket = startIndex >> 8;
2096 
2097         uint256 bucketStartIndex = (startIndex & 0xff);
2098 
2099         unchecked {
2100             if(bucketStartIndex + amount < 256) {
2101                 count +=  Popcount.popcount256A(
2102                     bitmap._data[bucket] & (MASK_FULL << (256 - amount) >> bucketStartIndex)
2103                 );
2104             } else {
2105                 count += Popcount.popcount256A(
2106                     bitmap._data[bucket] & (MASK_FULL >> bucketStartIndex)
2107                 );
2108                 amount -= (256 - bucketStartIndex);
2109                 bucket++;
2110 
2111                 while(amount > 256) {
2112                     count += Popcount.popcount256A(bitmap._data[bucket]);
2113                     amount -= 256;
2114                     bucket++;
2115                 }
2116                 count += Popcount.popcount256A(
2117                     bitmap._data[bucket] & (MASK_FULL << (256 - amount))
2118                 );
2119             }
2120         }
2121     }
2122 
2123     /**
2124      * @dev Returns number of set bits within a range.
2125      */
2126     function popcountB(BitMap storage bitmap, uint256 startIndex, uint256 amount) internal view returns(uint256 count) {
2127         uint256 bucket = startIndex >> 8;
2128 
2129         uint256 bucketStartIndex = (startIndex & 0xff);
2130 
2131         unchecked {
2132             if(bucketStartIndex + amount < 256) {
2133                 count +=  Popcount.popcount256B(
2134                     bitmap._data[bucket] & (MASK_FULL << (256 - amount) >> bucketStartIndex)
2135                 );
2136             } else {
2137                 count += Popcount.popcount256B(
2138                     bitmap._data[bucket] & (MASK_FULL >> bucketStartIndex)
2139                 );
2140                 amount -= (256 - bucketStartIndex);
2141                 bucket++;
2142 
2143                 while(amount > 256) {
2144                     count += Popcount.popcount256B(bitmap._data[bucket]);
2145                     amount -= 256;
2146                     bucket++;
2147                 }
2148                 count += Popcount.popcount256B(
2149                     bitmap._data[bucket] & (MASK_FULL << (256 - amount))
2150                 );
2151             }
2152         }
2153     }
2154 
2155 
2156     /**
2157      * @dev Find the closest index of the set bit before `index`.
2158      */
2159     function scanForward(BitMap storage bitmap, uint256 index) internal view returns (uint256 setBitIndex) {
2160         uint256 bucket = index >> 8;
2161 
2162         // index within the bucket
2163         uint256 bucketIndex = (index & 0xff);
2164 
2165         // load a bitboard from the bitmap.
2166         uint256 bb = bitmap._data[bucket];
2167 
2168         // offset the bitboard to scan from `bucketIndex`.
2169         bb = bb >> (0xff ^ bucketIndex); // bb >> (255 - bucketIndex)
2170         
2171         if(bb > 0) {
2172             unchecked {
2173                 setBitIndex = (bucket << 8) | (bucketIndex -  bb.bitScanForward256());    
2174             }
2175         } else {
2176             while(true) {
2177                 require(bucket > 0, "BitMaps: The set bit before the index doesn't exist.");
2178                 unchecked {
2179                     bucket--;
2180                 }
2181                 // No offset. Always scan from the least significiant bit now.
2182                 bb = bitmap._data[bucket];
2183                 
2184                 if(bb > 0) {
2185                     unchecked {
2186                         setBitIndex = (bucket << 8) | (255 -  bb.bitScanForward256());
2187                         break;
2188                     }
2189                 } 
2190             }
2191         }
2192     }
2193 
2194     function getBucket(BitMap storage bitmap, uint256 bucket) internal view returns (uint256) {
2195         return bitmap._data[bucket];
2196     }
2197 }
2198 
2199 // File: @openzeppelin/contracts/security/ReentrancyGuard.sol
2200 
2201 
2202 // OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)
2203 
2204 pragma solidity ^0.8.0;
2205 
2206 /**
2207  * @dev Contract module that helps prevent reentrant calls to a function.
2208  *
2209  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
2210  * available, which can be applied to functions to make sure there are no nested
2211  * (reentrant) calls to them.
2212  *
2213  * Note that because there is a single `nonReentrant` guard, functions marked as
2214  * `nonReentrant` may not call one another. This can be worked around by making
2215  * those functions `private`, and then adding `external` `nonReentrant` entry
2216  * points to them.
2217  *
2218  * TIP: If you would like to learn more about reentrancy and alternative ways
2219  * to protect against it, check out our blog post
2220  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
2221  */
2222 abstract contract ReentrancyGuard {
2223     // Booleans are more expensive than uint256 or any type that takes up a full
2224     // word because each write operation emits an extra SLOAD to first read the
2225     // slot's contents, replace the bits taken up by the boolean, and then write
2226     // back. This is the compiler's defense against contract upgrades and
2227     // pointer aliasing, and it cannot be disabled.
2228 
2229     // The values being non-zero value makes deployment a bit more expensive,
2230     // but in exchange the refund on every call to nonReentrant will be lower in
2231     // amount. Since refunds are capped to a percentage of the total
2232     // transaction's gas, it is best to keep them low in cases like this one, to
2233     // increase the likelihood of the full refund coming into effect.
2234     uint256 private constant _NOT_ENTERED = 1;
2235     uint256 private constant _ENTERED = 2;
2236 
2237     uint256 private _status;
2238 
2239     constructor() {
2240         _status = _NOT_ENTERED;
2241     }
2242 
2243     /**
2244      * @dev Prevents a contract from calling itself, directly or indirectly.
2245      * Calling a `nonReentrant` function from another `nonReentrant`
2246      * function is not supported. It is possible to prevent this from happening
2247      * by making the `nonReentrant` function external, and making it call a
2248      * `private` function that does the actual work.
2249      */
2250     modifier nonReentrant() {
2251         _nonReentrantBefore();
2252         _;
2253         _nonReentrantAfter();
2254     }
2255 
2256     function _nonReentrantBefore() private {
2257         // On the first call to nonReentrant, _status will be _NOT_ENTERED
2258         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
2259 
2260         // Any calls to nonReentrant after this point will fail
2261         _status = _ENTERED;
2262     }
2263 
2264     function _nonReentrantAfter() private {
2265         // By storing the original value once again, a refund is triggered (see
2266         // https://eips.ethereum.org/EIPS/eip-2200)
2267         _status = _NOT_ENTERED;
2268     }
2269 }
2270 
2271 // File: @openzeppelin/contracts/utils/introspection/IERC165.sol
2272 
2273 
2274 // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
2275 
2276 pragma solidity ^0.8.0;
2277 
2278 /**
2279  * @dev Interface of the ERC165 standard, as defined in the
2280  * https://eips.ethereum.org/EIPS/eip-165[EIP].
2281  *
2282  * Implementers can declare support of contract interfaces, which can then be
2283  * queried by others ({ERC165Checker}).
2284  *
2285  * For an implementation, see {ERC165}.
2286  */
2287 interface IERC165 {
2288     /**
2289      * @dev Returns true if this contract implements the interface defined by
2290      * `interfaceId`. See the corresponding
2291      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
2292      * to learn more about how these ids are created.
2293      *
2294      * This function call must use less than 30 000 gas.
2295      */
2296     function supportsInterface(bytes4 interfaceId) external view returns (bool);
2297 }
2298 
2299 // File: @openzeppelin/contracts/token/ERC721/IERC721.sol
2300 
2301 
2302 // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)
2303 
2304 pragma solidity ^0.8.0;
2305 
2306 
2307 /**
2308  * @dev Required interface of an ERC721 compliant contract.
2309  */
2310 interface IERC721 is IERC165 {
2311     /**
2312      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
2313      */
2314     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
2315 
2316     /**
2317      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
2318      */
2319     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
2320 
2321     /**
2322      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
2323      */
2324     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
2325 
2326     /**
2327      * @dev Returns the number of tokens in ``owner``'s account.
2328      */
2329     function balanceOf(address owner) external view returns (uint256 balance);
2330 
2331     /**
2332      * @dev Returns the owner of the `tokenId` token.
2333      *
2334      * Requirements:
2335      *
2336      * - `tokenId` must exist.
2337      */
2338     function ownerOf(uint256 tokenId) external view returns (address owner);
2339 
2340     /**
2341      * @dev Safely transfers `tokenId` token from `from` to `to`.
2342      *
2343      * Requirements:
2344      *
2345      * - `from` cannot be the zero address.
2346      * - `to` cannot be the zero address.
2347      * - `tokenId` token must exist and be owned by `from`.
2348      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
2349      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
2350      *
2351      * Emits a {Transfer} event.
2352      */
2353     function safeTransferFrom(
2354         address from,
2355         address to,
2356         uint256 tokenId,
2357         bytes calldata data
2358     ) external;
2359 
2360     /**
2361      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
2362      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
2363      *
2364      * Requirements:
2365      *
2366      * - `from` cannot be the zero address.
2367      * - `to` cannot be the zero address.
2368      * - `tokenId` token must exist and be owned by `from`.
2369      * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
2370      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
2371      *
2372      * Emits a {Transfer} event.
2373      */
2374     function safeTransferFrom(
2375         address from,
2376         address to,
2377         uint256 tokenId
2378     ) external;
2379 
2380     /**
2381      * @dev Transfers `tokenId` token from `from` to `to`.
2382      *
2383      * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
2384      * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
2385      * understand this adds an external call which potentially creates a reentrancy vulnerability.
2386      *
2387      * Requirements:
2388      *
2389      * - `from` cannot be the zero address.
2390      * - `to` cannot be the zero address.
2391      * - `tokenId` token must be owned by `from`.
2392      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
2393      *
2394      * Emits a {Transfer} event.
2395      */
2396     function transferFrom(
2397         address from,
2398         address to,
2399         uint256 tokenId
2400     ) external;
2401 
2402     /**
2403      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
2404      * The approval is cleared when the token is transferred.
2405      *
2406      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
2407      *
2408      * Requirements:
2409      *
2410      * - The caller must own the token or be an approved operator.
2411      * - `tokenId` must exist.
2412      *
2413      * Emits an {Approval} event.
2414      */
2415     function approve(address to, uint256 tokenId) external;
2416 
2417     /**
2418      * @dev Approve or remove `operator` as an operator for the caller.
2419      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
2420      *
2421      * Requirements:
2422      *
2423      * - The `operator` cannot be the caller.
2424      *
2425      * Emits an {ApprovalForAll} event.
2426      */
2427     function setApprovalForAll(address operator, bool _approved) external;
2428 
2429     /**
2430      * @dev Returns the account approved for `tokenId` token.
2431      *
2432      * Requirements:
2433      *
2434      * - `tokenId` must exist.
2435      */
2436     function getApproved(uint256 tokenId) external view returns (address operator);
2437 
2438     /**
2439      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
2440      *
2441      * See {setApprovalForAll}
2442      */
2443     function isApprovedForAll(address owner, address operator) external view returns (bool);
2444 }
2445 
2446 // File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
2447 
2448 
2449 // OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)
2450 
2451 pragma solidity ^0.8.0;
2452 
2453 
2454 /**
2455  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
2456  * @dev See https://eips.ethereum.org/EIPS/eip-721
2457  */
2458 interface IERC721Metadata is IERC721 {
2459     /**
2460      * @dev Returns the token collection name.
2461      */
2462     function name() external view returns (string memory);
2463 
2464     /**
2465      * @dev Returns the token collection symbol.
2466      */
2467     function symbol() external view returns (string memory);
2468 
2469     /**
2470      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
2471      */
2472     function tokenURI(uint256 tokenId) external view returns (string memory);
2473 }
2474 
2475 // File: @openzeppelin/contracts/utils/introspection/ERC165.sol
2476 
2477 
2478 // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
2479 
2480 pragma solidity ^0.8.0;
2481 
2482 
2483 /**
2484  * @dev Implementation of the {IERC165} interface.
2485  *
2486  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
2487  * for the additional interface id that will be supported. For example:
2488  *
2489  * ```solidity
2490  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
2491  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
2492  * }
2493  * ```
2494  *
2495  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
2496  */
2497 abstract contract ERC165 is IERC165 {
2498     /**
2499      * @dev See {IERC165-supportsInterface}.
2500      */
2501     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
2502         return interfaceId == type(IERC165).interfaceId;
2503     }
2504 }
2505 
2506 // File: @openzeppelin/contracts/interfaces/IERC2981.sol
2507 
2508 
2509 // OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)
2510 
2511 pragma solidity ^0.8.0;
2512 
2513 
2514 /**
2515  * @dev Interface for the NFT Royalty Standard.
2516  *
2517  * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal
2518  * support for royalty payments across all NFT marketplaces and ecosystem participants.
2519  *
2520  * _Available since v4.5._
2521  */
2522 interface IERC2981 is IERC165 {
2523     /**
2524      * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of
2525      * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.
2526      */
2527     function royaltyInfo(uint256 tokenId, uint256 salePrice)
2528         external
2529         view
2530         returns (address receiver, uint256 royaltyAmount);
2531 }
2532 
2533 // File: @openzeppelin/contracts/token/common/ERC2981.sol
2534 
2535 
2536 // OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)
2537 
2538 pragma solidity ^0.8.0;
2539 
2540 
2541 
2542 /**
2543  * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.
2544  *
2545  * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for
2546  * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.
2547  *
2548  * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the
2549  * fee is specified in basis points by default.
2550  *
2551  * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See
2552  * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to
2553  * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.
2554  *
2555  * _Available since v4.5._
2556  */
2557 abstract contract ERC2981 is IERC2981, ERC165 {
2558     struct RoyaltyInfo {
2559         address receiver;
2560         uint96 royaltyFraction;
2561     }
2562 
2563     RoyaltyInfo private _defaultRoyaltyInfo;
2564     mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;
2565 
2566     /**
2567      * @dev See {IERC165-supportsInterface}.
2568      */
2569     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {
2570         return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);
2571     }
2572 
2573     /**
2574      * @inheritdoc IERC2981
2575      */
2576     function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {
2577         RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];
2578 
2579         if (royalty.receiver == address(0)) {
2580             royalty = _defaultRoyaltyInfo;
2581         }
2582 
2583         uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();
2584 
2585         return (royalty.receiver, royaltyAmount);
2586     }
2587 
2588     /**
2589      * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a
2590      * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an
2591      * override.
2592      */
2593     function _feeDenominator() internal pure virtual returns (uint96) {
2594         return 10000;
2595     }
2596 
2597     /**
2598      * @dev Sets the royalty information that all ids in this contract will default to.
2599      *
2600      * Requirements:
2601      *
2602      * - `receiver` cannot be the zero address.
2603      * - `feeNumerator` cannot be greater than the fee denominator.
2604      */
2605     function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {
2606         require(feeNumerator <= _feeDenominator(), "ERC2981: royalty fee will exceed salePrice");
2607         require(receiver != address(0), "ERC2981: invalid receiver");
2608 
2609         _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);
2610     }
2611 
2612     /**
2613      * @dev Removes default royalty information.
2614      */
2615     function _deleteDefaultRoyalty() internal virtual {
2616         delete _defaultRoyaltyInfo;
2617     }
2618 
2619     /**
2620      * @dev Sets the royalty information for a specific token id, overriding the global default.
2621      *
2622      * Requirements:
2623      *
2624      * - `receiver` cannot be the zero address.
2625      * - `feeNumerator` cannot be greater than the fee denominator.
2626      */
2627     function _setTokenRoyalty(
2628         uint256 tokenId,
2629         address receiver,
2630         uint96 feeNumerator
2631     ) internal virtual {
2632         require(feeNumerator <= _feeDenominator(), "ERC2981: royalty fee will exceed salePrice");
2633         require(receiver != address(0), "ERC2981: Invalid parameters");
2634 
2635         _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);
2636     }
2637 
2638     /**
2639      * @dev Resets royalty information for the token id back to the global default.
2640      */
2641     function _resetTokenRoyalty(uint256 tokenId) internal virtual {
2642         delete _tokenRoyaltyInfo[tokenId];
2643     }
2644 }
2645 
2646 // File: @openzeppelin/contracts/utils/Context.sol
2647 
2648 
2649 // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
2650 
2651 pragma solidity ^0.8.0;
2652 
2653 /**
2654  * @dev Provides information about the current execution context, including the
2655  * sender of the transaction and its data. While these are generally available
2656  * via msg.sender and msg.data, they should not be accessed in such a direct
2657  * manner, since when dealing with meta-transactions the account sending and
2658  * paying for execution may not be the actual sender (as far as an application
2659  * is concerned).
2660  *
2661  * This contract is only required for intermediate, library-like contracts.
2662  */
2663 abstract contract Context {
2664     function _msgSender() internal view virtual returns (address) {
2665         return msg.sender;
2666     }
2667 
2668     function _msgData() internal view virtual returns (bytes calldata) {
2669         return msg.data;
2670     }
2671 }
2672 
2673 // File: erc721psi/contracts/ERC721Psi.sol
2674 
2675 
2676 /**
2677   ______ _____   _____ ______ ___  __ _  _  _ 
2678  |  ____|  __ \ / ____|____  |__ \/_ | || || |
2679  | |__  | |__) | |        / /   ) || | \| |/ |
2680  |  __| |  _  /| |       / /   / / | |\_   _/ 
2681  | |____| | \ \| |____  / /   / /_ | |  | |   
2682  |______|_|  \_\\_____|/_/   |____||_|  |_|   
2683 
2684  - github: https://github.com/estarriolvetch/ERC721Psi
2685  - npm: https://www.npmjs.com/package/erc721psi
2686                                           
2687  */
2688 
2689 pragma solidity ^0.8.0;
2690 
2691 contract ERC721Psi is Context, ERC165, IERC721, IERC721Metadata {
2692     using Address for address;
2693     using Strings for uint256;
2694     using BitMaps for BitMaps.BitMap;
2695 
2696     BitMaps.BitMap internal _batchHead;
2697 
2698     string private _name;
2699     string private _symbol;
2700 
2701     // Mapping from token ID to owner address
2702     mapping(uint256 => address) internal _owners;
2703     uint256 internal _currentIndex;
2704 
2705     mapping(uint256 => address) private _tokenApprovals;
2706     mapping(address => mapping(address => bool)) private _operatorApprovals;
2707 
2708     /**
2709      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
2710      */
2711     constructor(string memory name_, string memory symbol_) {
2712         _name = name_;
2713         _symbol = symbol_;
2714         _currentIndex = _startTokenId();
2715     }
2716 
2717     /**
2718      * @dev Returns the starting token ID.
2719      * To change the starting token ID, please override this function.
2720      */
2721     function _startTokenId() internal pure virtual returns (uint256) {
2722         // It will become modifiable in the future versions
2723         return 0;
2724     }
2725 
2726     /**
2727      * @dev Returns the next token ID to be minted.
2728      */
2729     function _nextTokenId() internal view virtual returns (uint256) {
2730         return _currentIndex;
2731     }
2732 
2733     /**
2734      * @dev Returns the total amount of tokens minted in the contract.
2735      */
2736     function _totalMinted() internal view virtual returns (uint256) {
2737         return _currentIndex - _startTokenId();
2738     }
2739 
2740 
2741     /**
2742      * @dev See {IERC165-supportsInterface}.
2743      */
2744     function supportsInterface(bytes4 interfaceId)
2745         public
2746         view
2747         virtual
2748         override(ERC165, IERC165)
2749         returns (bool)
2750     {
2751         return
2752             interfaceId == type(IERC721).interfaceId ||
2753             interfaceId == type(IERC721Metadata).interfaceId ||
2754             super.supportsInterface(interfaceId);
2755     }
2756 
2757     /**
2758      * @dev See {IERC721-balanceOf}.
2759      */
2760     function balanceOf(address owner) 
2761         public 
2762         view 
2763         virtual 
2764         override 
2765         returns (uint) 
2766     {
2767         require(owner != address(0), "ERC721Psi: balance query for the zero address");
2768 
2769         uint count;
2770         for( uint i = _startTokenId(); i < _nextTokenId(); ++i ){
2771             if(_exists(i)){
2772                 if( owner == ownerOf(i)){
2773                     ++count;
2774                 }
2775             }
2776         }
2777         return count;
2778     }
2779 
2780     /**
2781      * @dev See {IERC721-ownerOf}.
2782      */
2783     function ownerOf(uint256 tokenId)
2784         public
2785         view
2786         virtual
2787         override
2788         returns (address)
2789     {
2790         (address owner, ) = _ownerAndBatchHeadOf(tokenId);
2791         return owner;
2792     }
2793 
2794     function _ownerAndBatchHeadOf(uint256 tokenId) internal view virtual returns (address owner, uint256 tokenIdBatchHead){
2795         require(_exists(tokenId), "ERC721Psi: owner query for nonexistent token");
2796         tokenIdBatchHead = _getBatchHead(tokenId);
2797         owner = _owners[tokenIdBatchHead];
2798     }
2799 
2800     /**
2801      * @dev See {IERC721Metadata-name}.
2802      */
2803     function name() public view virtual override returns (string memory) {
2804         return _name;
2805     }
2806 
2807     /**
2808      * @dev See {IERC721Metadata-symbol}.
2809      */
2810     function symbol() public view virtual override returns (string memory) {
2811         return _symbol;
2812     }
2813 
2814     /**
2815      * @dev See {IERC721Metadata-tokenURI}.
2816      */
2817     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
2818         require(_exists(tokenId), "ERC721Psi: URI query for nonexistent token");
2819 
2820         string memory baseURI = _baseURI();
2821         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
2822     }
2823 
2824     /**
2825      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
2826      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
2827      * by default, can be overriden in child contracts.
2828      */
2829     function _baseURI() internal view virtual returns (string memory) {
2830         return "";
2831     }
2832 
2833 
2834     /**
2835      * @dev See {IERC721-approve}.
2836      */
2837     function approve(address to, uint256 tokenId) public virtual override {
2838         address owner = ownerOf(tokenId);
2839         require(to != owner, "ERC721Psi: approval to current owner");
2840 
2841         require(
2842             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
2843             "ERC721Psi: approve caller is not owner nor approved for all"
2844         );
2845 
2846         _approve(to, tokenId);
2847     }
2848 
2849     /**
2850      * @dev See {IERC721-getApproved}.
2851      */
2852     function getApproved(uint256 tokenId)
2853         public
2854         view
2855         virtual
2856         override
2857         returns (address)
2858     {
2859         require(
2860             _exists(tokenId),
2861             "ERC721Psi: approved query for nonexistent token"
2862         );
2863 
2864         return _tokenApprovals[tokenId];
2865     }
2866 
2867     /**
2868      * @dev See {IERC721-setApprovalForAll}.
2869      */
2870     function setApprovalForAll(address operator, bool approved)
2871         public
2872         virtual
2873         override
2874     {
2875         require(operator != _msgSender(), "ERC721Psi: approve to caller");
2876 
2877         _operatorApprovals[_msgSender()][operator] = approved;
2878         emit ApprovalForAll(_msgSender(), operator, approved);
2879     }
2880 
2881     /**
2882      * @dev See {IERC721-isApprovedForAll}.
2883      */
2884     function isApprovedForAll(address owner, address operator)
2885         public
2886         view
2887         virtual
2888         override
2889         returns (bool)
2890     {
2891         return _operatorApprovals[owner][operator];
2892     }
2893 
2894     /**
2895      * @dev See {IERC721-transferFrom}.
2896      */
2897     function transferFrom(
2898         address from,
2899         address to,
2900         uint256 tokenId
2901     ) public virtual override {
2902         //solhint-disable-next-line max-line-length
2903         require(
2904             _isApprovedOrOwner(_msgSender(), tokenId),
2905             "ERC721Psi: transfer caller is not owner nor approved"
2906         );
2907 
2908         _transfer(from, to, tokenId);
2909     }
2910 
2911     /**
2912      * @dev See {IERC721-safeTransferFrom}.
2913      */
2914     function safeTransferFrom(
2915         address from,
2916         address to,
2917         uint256 tokenId
2918     ) public virtual override {
2919         safeTransferFrom(from, to, tokenId, "");
2920     }
2921 
2922     /**
2923      * @dev See {IERC721-safeTransferFrom}.
2924      */
2925     function safeTransferFrom(
2926         address from,
2927         address to,
2928         uint256 tokenId,
2929         bytes memory _data
2930     ) public virtual override {
2931         require(
2932             _isApprovedOrOwner(_msgSender(), tokenId),
2933             "ERC721Psi: transfer caller is not owner nor approved"
2934         );
2935         _safeTransfer(from, to, tokenId, _data);
2936     }
2937 
2938     /**
2939      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
2940      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
2941      *
2942      * `_data` is additional data, it has no specified format and it is sent in call to `to`.
2943      *
2944      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
2945      * implement alternative mechanisms to perform token transfer, such as signature-based.
2946      *
2947      * Requirements:
2948      *
2949      * - `from` cannot be the zero address.
2950      * - `to` cannot be the zero address.
2951      * - `tokenId` token must exist and be owned by `from`.
2952      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
2953      *
2954      * Emits a {Transfer} event.
2955      */
2956     function _safeTransfer(
2957         address from,
2958         address to,
2959         uint256 tokenId,
2960         bytes memory _data
2961     ) internal virtual {
2962         _transfer(from, to, tokenId);
2963         require(
2964             _checkOnERC721Received(from, to, tokenId, 1,_data),
2965             "ERC721Psi: transfer to non ERC721Receiver implementer"
2966         );
2967     }
2968 
2969     /**
2970      * @dev Returns whether `tokenId` exists.
2971      *
2972      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
2973      *
2974      * Tokens start existing when they are minted (`_mint`).
2975      */
2976     function _exists(uint256 tokenId) internal view virtual returns (bool) {
2977         return tokenId < _nextTokenId() && _startTokenId() <= tokenId;
2978     }
2979 
2980     /**
2981      * @dev Returns whether `spender` is allowed to manage `tokenId`.
2982      *
2983      * Requirements:
2984      *
2985      * - `tokenId` must exist.
2986      */
2987     function _isApprovedOrOwner(address spender, uint256 tokenId)
2988         internal
2989         view
2990         virtual
2991         returns (bool)
2992     {
2993         require(
2994             _exists(tokenId),
2995             "ERC721Psi: operator query for nonexistent token"
2996         );
2997         address owner = ownerOf(tokenId);
2998         return (spender == owner ||
2999             getApproved(tokenId) == spender ||
3000             isApprovedForAll(owner, spender));
3001     }
3002 
3003     /**
3004      * @dev Safely mints `quantity` tokens and transfers them to `to`.
3005      *
3006      * Requirements:
3007      *
3008      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called for each safe transfer.
3009      * - `quantity` must be greater than 0.
3010      *
3011      * Emits a {Transfer} event.
3012      */
3013     function _safeMint(address to, uint256 quantity) internal virtual {
3014         _safeMint(to, quantity, "");
3015     }
3016 
3017     
3018     function _safeMint(
3019         address to,
3020         uint256 quantity,
3021         bytes memory _data
3022     ) internal virtual {
3023         uint256 nextTokenId = _nextTokenId();
3024         _mint(to, quantity);
3025         require(
3026             _checkOnERC721Received(address(0), to, nextTokenId, quantity, _data),
3027             "ERC721Psi: transfer to non ERC721Receiver implementer"
3028         );
3029     }
3030 
3031 
3032     function _mint(
3033         address to,
3034         uint256 quantity
3035     ) internal virtual {
3036         uint256 nextTokenId = _nextTokenId();
3037         
3038         require(quantity > 0, "ERC721Psi: quantity must be greater 0");
3039         require(to != address(0), "ERC721Psi: mint to the zero address");
3040         
3041         _beforeTokenTransfers(address(0), to, nextTokenId, quantity);
3042         _currentIndex += quantity;
3043         _owners[nextTokenId] = to;
3044         _batchHead.set(nextTokenId);
3045         _afterTokenTransfers(address(0), to, nextTokenId, quantity);
3046         
3047         // Emit events
3048         for(uint256 tokenId=nextTokenId; tokenId < nextTokenId + quantity; tokenId++){
3049             emit Transfer(address(0), to, tokenId);
3050         } 
3051     }
3052 
3053 
3054 
3055     /**
3056      * @dev Transfers `tokenId` from `from` to `to`.
3057      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
3058      *
3059      * Requirements:
3060      *
3061      * - `to` cannot be the zero address.
3062      * - `tokenId` token must be owned by `from`.
3063      *
3064      * Emits a {Transfer} event.
3065      */
3066     function _transfer(
3067         address from,
3068         address to,
3069         uint256 tokenId
3070     ) internal virtual {
3071         (address owner, uint256 tokenIdBatchHead) = _ownerAndBatchHeadOf(tokenId);
3072 
3073         require(
3074             owner == from,
3075             "ERC721Psi: transfer of token that is not own"
3076         );
3077         require(to != address(0), "ERC721Psi: transfer to the zero address");
3078 
3079         _beforeTokenTransfers(from, to, tokenId, 1);
3080 
3081         // Clear approvals from the previous owner
3082         _approve(address(0), tokenId);   
3083 
3084         uint256 subsequentTokenId = tokenId + 1;
3085 
3086         if(!_batchHead.get(subsequentTokenId) &&  
3087             subsequentTokenId < _nextTokenId()
3088         ) {
3089             _owners[subsequentTokenId] = from;
3090             _batchHead.set(subsequentTokenId);
3091         }
3092 
3093         _owners[tokenId] = to;
3094         if(tokenId != tokenIdBatchHead) {
3095             _batchHead.set(tokenId);
3096         }
3097 
3098         emit Transfer(from, to, tokenId);
3099 
3100         _afterTokenTransfers(from, to, tokenId, 1);
3101     }
3102 
3103     /**
3104      * @dev Approve `to` to operate on `tokenId`
3105      *
3106      * Emits a {Approval} event.
3107      */
3108     function _approve(address to, uint256 tokenId) internal virtual {
3109         _tokenApprovals[tokenId] = to;
3110         emit Approval(ownerOf(tokenId), to, tokenId);
3111     }
3112 
3113     /**
3114      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
3115      * The call is not executed if the target address is not a contract.
3116      *
3117      * @param from address representing the previous owner of the given token ID
3118      * @param to target address that will receive the tokens
3119      * @param startTokenId uint256 the first ID of the tokens to be transferred
3120      * @param quantity uint256 amount of the tokens to be transfered.
3121      * @param _data bytes optional data to send along with the call
3122      * @return r bool whether the call correctly returned the expected magic value
3123      */
3124     function _checkOnERC721Received(
3125         address from,
3126         address to,
3127         uint256 startTokenId,
3128         uint256 quantity,
3129         bytes memory _data
3130     ) private returns (bool r) {
3131         if (to.isContract()) {
3132             r = true;
3133             for(uint256 tokenId = startTokenId; tokenId < startTokenId + quantity; tokenId++){
3134                 try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
3135                     r = r && retval == IERC721Receiver.onERC721Received.selector;
3136                 } catch (bytes memory reason) {
3137                     if (reason.length == 0) {
3138                         revert("ERC721Psi: transfer to non ERC721Receiver implementer");
3139                     } else {
3140                         assembly {
3141                             revert(add(32, reason), mload(reason))
3142                         }
3143                     }
3144                 }
3145             }
3146             return r;
3147         } else {
3148             return true;
3149         }
3150     }
3151 
3152     function _getBatchHead(uint256 tokenId) internal view returns (uint256 tokenIdBatchHead) {
3153         tokenIdBatchHead = _batchHead.scanForward(tokenId); 
3154     }
3155 
3156 
3157     function totalSupply() public virtual view returns (uint256) {
3158         return _totalMinted();
3159     }
3160 
3161     /**
3162      * @dev Returns an array of token IDs owned by `owner`.
3163      *
3164      * This function scans the ownership mapping and is O(`totalSupply`) in complexity.
3165      * It is meant to be called off-chain.
3166      *
3167      * This function is compatiable with ERC721AQueryable.
3168      */
3169     function tokensOfOwner(address owner) external view virtual returns (uint256[] memory) {
3170         unchecked {
3171             uint256 tokenIdsIdx;
3172             uint256 tokenIdsLength = balanceOf(owner);
3173             uint256[] memory tokenIds = new uint256[](tokenIdsLength);
3174             for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {
3175                 if (_exists(i)) {
3176                     if (ownerOf(i) == owner) {
3177                         tokenIds[tokenIdsIdx++] = i;
3178                     }
3179                 }
3180             }
3181             return tokenIds;   
3182         }
3183     }
3184 
3185     /**
3186      * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.
3187      *
3188      * startTokenId - the first token id to be transferred
3189      * quantity - the amount to be transferred
3190      *
3191      * Calling conditions:
3192      *
3193      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
3194      * transferred to `to`.
3195      * - When `from` is zero, `tokenId` will be minted for `to`.
3196      */
3197     function _beforeTokenTransfers(
3198         address from,
3199         address to,
3200         uint256 startTokenId,
3201         uint256 quantity
3202     ) internal virtual {}
3203 
3204     /**
3205      * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes
3206      * minting.
3207      *
3208      * startTokenId - the first token id to be transferred
3209      * quantity - the amount to be transferred
3210      *
3211      * Calling conditions:
3212      *
3213      * - when `from` and `to` are both non-zero.
3214      * - `from` and `to` are never both zero.
3215      */
3216     function _afterTokenTransfers(
3217         address from,
3218         address to,
3219         uint256 startTokenId,
3220         uint256 quantity
3221     ) internal virtual {}
3222 }
3223 // File: erc721psi/contracts/extension/ERC721PsiBurnable.sol
3224 
3225 
3226 /**
3227   ______ _____   _____ ______ ___  __ _  _  _ 
3228  |  ____|  __ \ / ____|____  |__ \/_ | || || |
3229  | |__  | |__) | |        / /   ) || | \| |/ |
3230  |  __| |  _  /| |       / /   / / | |\_   _/ 
3231  | |____| | \ \| |____  / /   / /_ | |  | |   
3232  |______|_|  \_\\_____|/_/   |____||_|  |_|   
3233                                               
3234                                             
3235  */
3236 pragma solidity ^0.8.0;
3237 
3238 
3239 
3240 
3241 abstract contract ERC721PsiBurnable is ERC721Psi {
3242     using BitMaps for BitMaps.BitMap;
3243     BitMaps.BitMap internal _burnedToken;
3244 
3245     /**
3246      * @dev Destroys `tokenId`.
3247      * The approval is cleared when the token is burned.
3248      *
3249      * Requirements:
3250      *
3251      * - `tokenId` must exist.
3252      *
3253      * Emits a {Transfer} event.
3254      */
3255     function _burn(uint256 tokenId) internal virtual {
3256         address from = ownerOf(tokenId);
3257         _beforeTokenTransfers(from, address(0), tokenId, 1);
3258         _burnedToken.set(tokenId);
3259         
3260         emit Transfer(from, address(0), tokenId);
3261 
3262         _afterTokenTransfers(from, address(0), tokenId, 1);
3263     }
3264 
3265     /**
3266      * @dev Returns whether `tokenId` exists.
3267      *
3268      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
3269      *
3270      * Tokens start existing when they are minted (`_mint`),
3271      * and stop existing when they are burned (`_burn`).
3272      */
3273     function _exists(uint256 tokenId) internal view override virtual returns (bool){
3274         if(_burnedToken.get(tokenId)) {
3275             return false;
3276         } 
3277         return super._exists(tokenId);
3278     }
3279 
3280     /**
3281      * @dev See {IERC721Enumerable-totalSupply}.
3282      */
3283     function totalSupply() public view virtual override returns (uint256) {
3284         return _totalMinted() - _burned();
3285     }
3286 
3287     /**
3288      * @dev Returns number of token burned.
3289      */
3290     function _burned() internal view returns (uint256 burned){
3291         uint256 startBucket = _startTokenId() >> 8;
3292         uint256 lastBucket = (_nextTokenId() >> 8) + 1;
3293 
3294         for(uint256 i=startBucket; i < lastBucket; i++) {
3295             uint256 bucket = _burnedToken.getBucket(i);
3296             burned += _popcount(bucket);
3297         }
3298     }
3299 
3300     /**
3301      * @dev Returns number of set bits.
3302      */
3303     function _popcount(uint256 x) private pure returns (uint256 count) {
3304         unchecked{
3305             for (count=0; x!=0; count++)
3306                 x &= x - 1;
3307         }
3308     }
3309 }
3310 // File: @openzeppelin/contracts/access/Ownable.sol
3311 
3312 
3313 // OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)
3314 
3315 pragma solidity ^0.8.0;
3316 
3317 
3318 /**
3319  * @dev Contract module which provides a basic access control mechanism, where
3320  * there is an account (an owner) that can be granted exclusive access to
3321  * specific functions.
3322  *
3323  * By default, the owner account will be the one that deploys the contract. This
3324  * can later be changed with {transferOwnership}.
3325  *
3326  * This module is used through inheritance. It will make available the modifier
3327  * `onlyOwner`, which can be applied to your functions to restrict their use to
3328  * the owner.
3329  */
3330 abstract contract Ownable is Context {
3331     address private _owner;
3332 
3333     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
3334 
3335     /**
3336      * @dev Initializes the contract setting the deployer as the initial owner.
3337      */
3338     constructor() {
3339         _transferOwnership(_msgSender());
3340     }
3341 
3342     /**
3343      * @dev Throws if called by any account other than the owner.
3344      */
3345     modifier onlyOwner() {
3346         _checkOwner();
3347         _;
3348     }
3349 
3350     /**
3351      * @dev Returns the address of the current owner.
3352      */
3353     function owner() public view virtual returns (address) {
3354         return _owner;
3355     }
3356 
3357     /**
3358      * @dev Throws if the sender is not the owner.
3359      */
3360     function _checkOwner() internal view virtual {
3361         require(owner() == _msgSender(), "Ownable: caller is not the owner");
3362     }
3363 
3364     /**
3365      * @dev Leaves the contract without owner. It will not be possible to call
3366      * `onlyOwner` functions anymore. Can only be called by the current owner.
3367      *
3368      * NOTE: Renouncing ownership will leave the contract without an owner,
3369      * thereby removing any functionality that is only available to the owner.
3370      */
3371     function renounceOwnership() public virtual onlyOwner {
3372         _transferOwnership(address(0));
3373     }
3374 
3375     /**
3376      * @dev Transfers ownership of the contract to a new account (`newOwner`).
3377      * Can only be called by the current owner.
3378      */
3379     function transferOwnership(address newOwner) public virtual onlyOwner {
3380         require(newOwner != address(0), "Ownable: new owner is the zero address");
3381         _transferOwnership(newOwner);
3382     }
3383 
3384     /**
3385      * @dev Transfers ownership of the contract to a new account (`newOwner`).
3386      * Internal function without access restriction.
3387      */
3388     function _transferOwnership(address newOwner) internal virtual {
3389         address oldOwner = _owner;
3390         _owner = newOwner;
3391         emit OwnershipTransferred(oldOwner, newOwner);
3392     }
3393 }
3394 
3395 // File: EXO/NEW/EXO.sol
3396 
3397 pragma solidity >=0.6.0;
3398 
3399 /// @title Base64
3400 /// @author Brecht Devos - <brecht@loopring.org>
3401 /// @notice Provides functions for encoding/decoding base64
3402 library Base64 {
3403     string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
3404     bytes  internal constant TABLE_DECODE = hex"0000000000000000000000000000000000000000000000000000000000000000"
3405                                             hex"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000"
3406                                             hex"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000"
3407                                             hex"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000";
3408 
3409     function encode(bytes memory data) internal pure returns (string memory) {
3410         if (data.length == 0) return '';
3411 
3412         // load the table into memory
3413         string memory table = TABLE_ENCODE;
3414 
3415         // multiply by 4/3 rounded up
3416         uint256 encodedLen = 4 * ((data.length + 2) / 3);
3417 
3418         // add some extra buffer at the end required for the writing
3419         string memory result = new string(encodedLen + 32);
3420 
3421         assembly {
3422             // set the actual output length
3423             mstore(result, encodedLen)
3424 
3425             // prepare the lookup table
3426             let tablePtr := add(table, 1)
3427 
3428             // input ptr
3429             let dataPtr := data
3430             let endPtr := add(dataPtr, mload(data))
3431 
3432             // result ptr, jump over length
3433             let resultPtr := add(result, 32)
3434 
3435             // run over the input, 3 bytes at a time
3436             for {} lt(dataPtr, endPtr) {}
3437             {
3438                 // read 3 bytes
3439                 dataPtr := add(dataPtr, 3)
3440                 let input := mload(dataPtr)
3441 
3442                 // write 4 characters
3443                 mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
3444                 resultPtr := add(resultPtr, 1)
3445                 mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
3446                 resultPtr := add(resultPtr, 1)
3447                 mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))
3448                 resultPtr := add(resultPtr, 1)
3449                 mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))
3450                 resultPtr := add(resultPtr, 1)
3451             }
3452 
3453             // padding with '='
3454             switch mod(mload(data), 3)
3455             case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }
3456             case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }
3457         }
3458 
3459         return result;
3460     }
3461 
3462     function decode(string memory _data) internal pure returns (bytes memory) {
3463         bytes memory data = bytes(_data);
3464 
3465         if (data.length == 0) return new bytes(0);
3466         require(data.length % 4 == 0, "invalid base64 decoder input");
3467 
3468         // load the table into memory
3469         bytes memory table = TABLE_DECODE;
3470 
3471         // every 4 characters represent 3 bytes
3472         uint256 decodedLen = (data.length / 4) * 3;
3473 
3474         // add some extra buffer at the end required for the writing
3475         bytes memory result = new bytes(decodedLen + 32);
3476 
3477         assembly {
3478             // padding with '='
3479             let lastBytes := mload(add(data, mload(data)))
3480             if eq(and(lastBytes, 0xFF), 0x3d) {
3481                 decodedLen := sub(decodedLen, 1)
3482                 if eq(and(lastBytes, 0xFFFF), 0x3d3d) {
3483                     decodedLen := sub(decodedLen, 1)
3484                 }
3485             }
3486 
3487             // set the actual output length
3488             mstore(result, decodedLen)
3489 
3490             // prepare the lookup table
3491             let tablePtr := add(table, 1)
3492 
3493             // input ptr
3494             let dataPtr := data
3495             let endPtr := add(dataPtr, mload(data))
3496 
3497             // result ptr, jump over length
3498             let resultPtr := add(result, 32)
3499 
3500             // run over the input, 4 characters at a time
3501             for {} lt(dataPtr, endPtr) {}
3502             {
3503                // read 4 characters
3504                dataPtr := add(dataPtr, 4)
3505                let input := mload(dataPtr)
3506 
3507                // write 3 bytes
3508                let output := add(
3509                    add(
3510                        shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),
3511                        shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),
3512                    add(
3513                        shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),
3514                                and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)
3515                     )
3516                 )
3517                 mstore(resultPtr, shl(232, output))
3518                 resultPtr := add(resultPtr, 3)
3519             }
3520         }
3521 
3522         return result;
3523     }
3524 }
3525 
3526 
3527 
3528 
3529 
3530 
3531 pragma solidity ^0.8.7;
3532 
3533 
3534 abstract contract MerkleProof {
3535     mapping(uint256 => bytes32) internal _wlMerkleRoot;
3536     mapping(uint256 => bytes32) internal _alMerkleRoot;
3537 
3538     uint256 public phaseId;
3539     function _setWlMerkleRoot(bytes32 merkleRoot_) internal virtual {
3540         _wlMerkleRoot[phaseId] = merkleRoot_;
3541     }
3542 
3543     function _setWlMerkleRootWithId(uint256 _phaseId,bytes32 merkleRoot_) internal virtual {
3544         _wlMerkleRoot[_phaseId] = merkleRoot_;
3545     }
3546     function isWhitelisted(address address_, uint256 _phaseId, uint256 wlCount, bytes32[] memory proof_) public view returns (bool) {
3547         bytes32 _leaf = keccak256(abi.encodePacked(address_, wlCount));
3548         for (uint256 i = 0; i < proof_.length; i++) {
3549             _leaf = _leaf < proof_[i] ? keccak256(abi.encodePacked(_leaf, proof_[i])) : keccak256(abi.encodePacked(proof_[i], _leaf));
3550         }
3551         return _leaf == _wlMerkleRoot[_phaseId];
3552     }
3553 
3554     function _setAlMerkleRootWithId(uint256 _phaseId,bytes32 merkleRoot_) internal virtual {
3555         _alMerkleRoot[_phaseId] = merkleRoot_;
3556     }
3557 
3558     function _setAlMerkleRoot(bytes32 merkleRoot_) internal virtual {
3559         _alMerkleRoot[phaseId] = merkleRoot_;
3560     }
3561 
3562     function isAllowlisted(address address_,uint256 _alId, bytes32[] memory proof_) public view returns (bool) {
3563         bytes32 _leaf = keccak256(abi.encodePacked(address_));
3564         for (uint256 i = 0; i < proof_.length; i++) {
3565             _leaf = _leaf < proof_[i] ? keccak256(abi.encodePacked(_leaf, proof_[i])) : keccak256(abi.encodePacked(proof_[i], _leaf));
3566         }
3567         return _leaf == _alMerkleRoot[_alId];
3568     }
3569 
3570 }
3571 
3572 pragma solidity ^0.8.9;
3573 abstract contract Operable is Context {
3574     mapping(address => bool) _operators;
3575     modifier onlyOperator() {
3576         _checkOperatorRole(_msgSender());
3577         _;
3578     }
3579     function isOperator(address _operator) public view returns (bool) {
3580         return _operators[_operator];
3581     }
3582     function _grantOperatorRole(address _candidate) internal {
3583         require(
3584             !_operators[_candidate],
3585             string(
3586                 abi.encodePacked(
3587                     "account ",
3588                     Strings.toHexString(uint160(_msgSender()), 20),
3589                     " is already has an operator role"
3590                 )
3591             )
3592         );
3593         _operators[_candidate] = true;
3594     }
3595     function _revokeOperatorRole(address _candidate) internal {
3596         _checkOperatorRole(_candidate);
3597         delete _operators[_candidate];
3598     }
3599     function _checkOperatorRole(address _operator) internal view {
3600         require(
3601             _operators[_operator],
3602             string(
3603                 abi.encodePacked(
3604                     "account ",
3605                     Strings.toHexString(uint160(_msgSender()), 20),
3606                     " is not an operator"
3607                 )
3608             )
3609         );
3610     }
3611 }
3612 
3613 pragma solidity ^0.8.13;
3614 
3615 interface IOperatorFilterRegistry {
3616     function isOperatorAllowed(address registrant, address operator) external view returns (bool);
3617     function register(address registrant) external;
3618     function registerAndSubscribe(address registrant, address subscription) external;
3619     function registerAndCopyEntries(address registrant, address registrantToCopy) external;
3620     function unregister(address addr) external;
3621     function updateOperator(address registrant, address operator, bool filtered) external;
3622     function updateOperators(address registrant, address[] calldata operators, bool filtered) external;
3623     function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;
3624     function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;
3625     function subscribe(address registrant, address registrantToSubscribe) external;
3626     function unsubscribe(address registrant, bool copyExistingEntries) external;
3627     function subscriptionOf(address addr) external returns (address registrant);
3628     function subscribers(address registrant) external returns (address[] memory);
3629     function subscriberAt(address registrant, uint256 index) external returns (address);
3630     function copyEntriesOf(address registrant, address registrantToCopy) external;
3631     function isOperatorFiltered(address registrant, address operator) external returns (bool);
3632     function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);
3633     function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);
3634     function filteredOperators(address addr) external returns (address[] memory);
3635     function filteredCodeHashes(address addr) external returns (bytes32[] memory);
3636     function filteredOperatorAt(address registrant, uint256 index) external returns (address);
3637     function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);
3638     function isRegistered(address addr) external returns (bool);
3639     function codeHashOf(address addr) external returns (bytes32);
3640 }
3641 
3642 pragma solidity ^0.8.13;
3643 
3644 
3645 /**
3646  * @title  OperatorFilterer
3647  * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another
3648  *         registrant's entries in the OperatorFilterRegistry.
3649  * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:
3650  *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.
3651  *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.
3652  */
3653 abstract contract OperatorFilterer {
3654     error OperatorNotAllowed(address operator);
3655     bool public operatorFilteringEnabled = true;
3656 
3657     IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =
3658         IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);
3659 
3660     constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {
3661         // If an inheriting token contract is deployed to a network without the registry deployed, the modifier
3662         // will not revert, but the contract will need to be registered with the registry once it is deployed in
3663         // order for the modifier to filter addresses.
3664         if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {
3665             if (subscribe) {
3666                 OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);
3667             } else {
3668                 if (subscriptionOrRegistrantToCopy != address(0)) {
3669                     OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);
3670                 } else {
3671                     OPERATOR_FILTER_REGISTRY.register(address(this));
3672                 }
3673             }
3674         }
3675     }
3676 
3677     modifier onlyAllowedOperator(address from) virtual {
3678         // Check registry code length to facilitate testing in environments without a deployed registry.
3679         if (address(OPERATOR_FILTER_REGISTRY).code.length > 0 && operatorFilteringEnabled) {
3680             // Allow spending tokens from addresses with balance
3681             // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred
3682             // from an EOA.
3683             if (from == msg.sender) {
3684                 _;
3685                 return;
3686             }
3687             if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), msg.sender)) {
3688                 revert OperatorNotAllowed(msg.sender);
3689             }
3690         }
3691         _;
3692     }
3693 
3694     modifier onlyAllowedOperatorApproval(address operator) virtual {
3695         // Check registry code length to facilitate testing in environments without a deployed registry.
3696         if (address(OPERATOR_FILTER_REGISTRY).code.length > 0 && operatorFilteringEnabled) {
3697             if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {
3698                 revert OperatorNotAllowed(operator);
3699             }
3700         }
3701         _;
3702     }
3703 }
3704 
3705 
3706 pragma solidity ^0.8.13;
3707 /**
3708  * @title  DefaultOperatorFilterer
3709  * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.
3710  */
3711 abstract contract DefaultOperatorFilterer is OperatorFilterer {
3712     address constant DEFAULT_SUBSCRIPTION = address(0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6);
3713 
3714     constructor() OperatorFilterer(DEFAULT_SUBSCRIPTION, true) {}
3715 }
3716 
3717 
3718 
3719 
3720 
3721 pragma solidity >=0.7.0 <0.9.0;
3722 
3723 interface IContractAllowListProxy {
3724     function isAllowed(address _transferer, uint256 _level)
3725         external
3726         view
3727         returns (bool);
3728 }
3729 
3730 pragma solidity >=0.8.0;
3731 
3732 /// @title IERC721RestrictApprove
3733 /// @dev Approve
3734 /// @author Lavulite
3735 
3736 interface IERC721RestrictApprove {
3737     /**
3738      * @dev CAL
3739      */
3740     event CalLevelChanged(address indexed operator, uint256 indexed level);
3741     
3742     /**
3743      * @dev LocalContractAllowListn
3744      */
3745     event LocalCalAdded(address indexed operator, address indexed transferer);
3746 
3747     /**
3748      * @dev LocalContractAllowListn
3749      */
3750     event LocalCalRemoved(address indexed operator, address indexed transferer);
3751 
3752     /**
3753      * @dev CALCAL
3754      */
3755     function setCALLevel(uint256 level) external;
3756 
3757     /**
3758      * @dev CAL
3759      */
3760     function setCAL(address calAddress) external;
3761 
3762     /**
3763      * @dev CAL
3764      */
3765     function addLocalContractAllowList(address transferer) external;
3766 
3767     /**
3768      * @dev CAL
3769      */
3770     function removeLocalContractAllowList(address transferer) external;
3771 
3772     /**
3773      * @dev CAL
3774      */
3775     function getLocalContractAllowList() external view returns(address[] memory);
3776 
3777 }
3778 
3779 pragma solidity >=0.8.0;
3780 
3781 /// @title AntiScamERC721A
3782 /// @dev Readme
3783 
3784 abstract contract ERC721RestrictApprove is ERC721PsiBurnable, IERC721RestrictApprove {
3785     using EnumerableSet for EnumerableSet.AddressSet;
3786 
3787     IContractAllowListProxy public CAL;
3788     EnumerableSet.AddressSet localAllowedAddresses;
3789 
3790     modifier onlyHolder(uint256 tokenId) {
3791         require(
3792             msg.sender == ownerOf(tokenId),
3793             "RestrictApprove: operation is only holder."
3794         );
3795         _;
3796     }
3797 
3798     /*//////////////////////////////////////////////////////////////
3799     
3800     //////////////////////////////////////////////////////////////*/
3801     bool public enableRestrict = true;
3802 
3803     // token lock
3804     mapping(uint256 => uint256) public tokenCALLevel;
3805 
3806     // wallet lock
3807     mapping(address => uint256) public walletCALLevel;
3808 
3809     // contract lock
3810     uint256 public CALLevel = 1;
3811 
3812     /*///////////////////////////////////////////////////////////////
3813     Approve
3814     //////////////////////////////////////////////////////////////*/
3815     function _addLocalContractAllowList(address transferer)
3816         internal
3817         virtual
3818     {
3819         localAllowedAddresses.add(transferer);
3820         emit LocalCalAdded(msg.sender, transferer);
3821     }
3822 
3823     function _removeLocalContractAllowList(address transferer)
3824         internal
3825         virtual
3826     {
3827         localAllowedAddresses.remove(transferer);
3828         emit LocalCalRemoved(msg.sender, transferer);
3829     }
3830 
3831     function _getLocalContractAllowList()
3832         internal
3833         virtual
3834         view
3835         returns(address[] memory)
3836     {
3837         return localAllowedAddresses.values();
3838     }
3839 
3840     function _isLocalAllowed(address transferer)
3841         internal
3842         view
3843         virtual
3844         returns (bool)
3845     {
3846         return localAllowedAddresses.contains(transferer);
3847     }
3848 
3849     function _isAllowed(address transferer)
3850         internal
3851         view
3852         virtual
3853         returns (bool)
3854     {
3855         return _isAllowed(msg.sender, transferer);
3856     }
3857 
3858     function _isAllowed(uint256 tokenId, address transferer)
3859         internal
3860         view
3861         virtual
3862         returns (bool)
3863     {
3864         uint256 level = _getCALLevel(msg.sender, tokenId);
3865         return _isAllowed(transferer, level);
3866     }
3867 
3868     function _isAllowed(address holder, address transferer)
3869         internal
3870         view
3871         virtual
3872         returns (bool)
3873     {
3874         uint256 level = _getCALLevel(holder);
3875         return _isAllowed(transferer, level);
3876     }
3877 
3878     function _isAllowed(address transferer, uint256 level)
3879         internal
3880         view
3881         virtual
3882         returns (bool)
3883     {
3884         if (!enableRestrict) {
3885             return true;
3886         }
3887 
3888         return _isLocalAllowed(transferer) || CAL.isAllowed(transferer, level);
3889     }
3890 
3891     function _getCALLevel(address holder, uint256 tokenId)
3892         internal
3893         view
3894         virtual
3895         returns (uint256)
3896     {
3897         if (tokenCALLevel[tokenId] > 0) {
3898             return tokenCALLevel[tokenId];
3899         }
3900 
3901         return _getCALLevel(holder);
3902     }
3903 
3904     function _getCALLevel(address holder)
3905         internal
3906         view
3907         virtual
3908         returns (uint256)
3909     {
3910         if (walletCALLevel[holder] > 0) {
3911             return walletCALLevel[holder];
3912         }
3913 
3914         return CALLevel;
3915     }
3916 
3917     function _setCAL(address _cal) internal virtual {
3918         CAL = IContractAllowListProxy(_cal);
3919     }
3920 
3921     function _deleteTokenCALLevel(uint256 tokenId) internal virtual {
3922         delete tokenCALLevel[tokenId];
3923     }
3924 
3925     function setTokenCALLevel(uint256 tokenId, uint256 level)
3926         external
3927         virtual
3928         onlyHolder(tokenId)
3929     {
3930         tokenCALLevel[tokenId] = level;
3931     }
3932 
3933     function setWalletCALLevel(uint256 level)
3934         external
3935         virtual
3936     {
3937         walletCALLevel[msg.sender] = level;
3938     }
3939 
3940     /*///////////////////////////////////////////////////////////////
3941                               OVERRIDES
3942     //////////////////////////////////////////////////////////////*/
3943 
3944     function isApprovedForAll(address owner, address operator)
3945         public
3946         view
3947         virtual
3948         override
3949         returns (bool)
3950     {
3951         if (_isAllowed(owner, operator) == false) {
3952             return false;
3953         }
3954         return super.isApprovedForAll(owner, operator);
3955     }
3956 
3957     function setApprovalForAll(address operator, bool approved)
3958         public
3959         virtual
3960         override
3961     {
3962         require(
3963             _isAllowed(operator) || approved == false,
3964             "RestrictApprove: Can not approve locked token"
3965         );
3966         super.setApprovalForAll(operator, approved);
3967     }
3968 
3969     function _beforeApprove(address to, uint256 tokenId)
3970         internal
3971         virtual
3972     {
3973         if (to != address(0)) {
3974             require(_isAllowed(tokenId, to), "RestrictApprove: The contract is not allowed.");
3975         }
3976     }
3977 
3978     function approve(address to, uint256 tokenId)
3979         public
3980         virtual
3981         override
3982     {
3983         _beforeApprove(to, tokenId);
3984         super.approve(to, tokenId);
3985     }
3986 
3987     function _afterTokenTransfers(
3988         address from,
3989         address, /*to*/
3990         uint256 startTokenId,
3991         uint256 /*quantity*/
3992     ) internal virtual override {
3993         // startTokenId TokenID
3994         if (from != address(0)) {
3995             // CAL
3996             _deleteTokenCALLevel(startTokenId);
3997         }
3998     }
3999 
4000     function supportsInterface(bytes4 interfaceId)
4001         public
4002         view
4003         virtual
4004         override
4005         returns (bool)
4006     {
4007         return
4008             interfaceId == type(IERC721RestrictApprove).interfaceId ||
4009             super.supportsInterface(interfaceId);
4010     }
4011 }
4012 
4013 
4014 pragma solidity ^0.8.7;
4015 /*
4016 
4017 
4018 
4019 
4020 
4021 
4022 */
4023 contract AEBBEGINS is Ownable, ERC721RestrictApprove, ReentrancyGuard, MerkleProof, ERC2981, DefaultOperatorFilterer,Operable {
4024   //Project Settings
4025   mapping(uint256 => uint256) public alMintPrice;
4026   uint256 public psMintPrice = 0.05 ether;
4027   uint256 public wlMintPrice;  
4028   mapping(uint256 => uint256) public maxMintsPerAL;
4029   uint256 public maxMintsPerPS = 2;
4030   uint256 public maxMintsPerALOT = 30;
4031   uint256 public maxMintsPerPSOT = 2;
4032   uint256 public maxSupply;
4033   uint256 public mintable;
4034   uint256 public revealed;
4035   uint256 public nowPhaseWl;
4036   uint256 public nowPhaseAl;
4037   uint256 public nowPhasePs;
4038 
4039   address internal _withdrawWallet;
4040   address internal _aa;
4041   address internal _bb;
4042   address internal _cc;
4043   address internal _dd;
4044   address internal _ee;
4045   address internal _ff;
4046 
4047   uint256 internal _aaPerc;
4048   uint256 internal _bbPerc;
4049   uint256 internal _ccPerc;
4050   uint256 internal _ddPerc;
4051   uint256 internal _eePerc;
4052   uint256 internal _ffPerc;
4053 
4054   //URI
4055   string internal hiddenURI;
4056   string internal _baseTokenURI;
4057   string public _baseExtension = ".json";
4058 
4059   //flags
4060   mapping(uint256 => bool) public isWlSaleEnabled;
4061   mapping(uint256 => bool) public isAlSaleEnabled;
4062   bool public isPublicSaleEnabled;
4063   bool internal lockBurn = true;
4064 
4065   //mint records.
4066   mapping(uint256 => uint256) public phaseIds;
4067   mapping(uint256 => mapping(address => uint256)) internal _wlMinted;
4068   mapping(uint256 => mapping(uint256 => mapping(address => uint256))) internal _alMinted;
4069   mapping(uint256 => mapping(address => uint256)) internal _psMinted;
4070   
4071   constructor (
4072     address _royaltyReceiver,
4073     uint96 _royaltyFraction,
4074     uint256 _aaPercAdd
4075   ) ERC721Psi ("AEB BEGINS","AEB") {
4076     _grantOperatorRole(msg.sender);
4077     _grantOperatorRole(_royaltyReceiver);
4078     _setDefaultRoyalty(_royaltyReceiver,_royaltyFraction);
4079     //CAL initialization
4080     setCALLevel(1);
4081     _setCAL(0xF2A78c73ffBAB6ECc3548Acc54B546ace279312E);//Ethereum mainnet proxy
4082     _addLocalContractAllowList(0x1E0049783F008A0085193E00003D00cd54003c71);//OpenSea
4083     _addLocalContractAllowList(0x4feE7B061C97C9c496b01DbcE9CDb10c02f0a0Be);//Rarible
4084     maxMintsPerAL[0] = 10;//fcfs
4085     maxMintsPerAL[1] = 30;//VVIP1
4086     maxMintsPerAL[2] = 20;//VVIP2
4087     maxMintsPerAL[3] = 20;//VIP1
4088     maxMintsPerAL[4] = 20;//VIP2
4089     maxMintsPerAL[5] = 10;//VIP3
4090     maxMintsPerAL[6] = 10;//VIP4
4091     maxMintsPerAL[7] = 10;//kaku
4092 
4093     alMintPrice[0] = 0.05 ether;//fcfs
4094     alMintPrice[1] = 0.02 ether;//VVIP1
4095     alMintPrice[2] = 0.03 ether;//VVIP2
4096     alMintPrice[3] = 0.025 ether;//VIP1
4097     alMintPrice[4] = 0.035 ether;//VIP2
4098     alMintPrice[5] = 0.04 ether;//VIP3
4099     alMintPrice[6] = 0.045 ether;//VIP4
4100     alMintPrice[7] = 0.05 ether;//k
4101     
4102     hiddenURI = "https://arweave.net/QQCSg9F1i63yAUu7NRLT5ncvDE3HCrqFxpl6K8iboh4";
4103     _aa = msg.sender;
4104     _aaPerc = _aaPercAdd;
4105   }
4106   //start from 1.adjust.
4107   function _startTokenId() internal pure virtual override returns (uint256) {
4108         return 1;
4109   }
4110   //set Default Royalty._feeNumerator 500 = 5% Royalty
4111   function setDefaultRoyalty(address _receiver, uint96 _feeNumerator) external virtual onlyOperator {
4112       _setDefaultRoyalty(_receiver, _feeNumerator);
4113   }
4114   //for ERC2981
4115   function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721RestrictApprove, ERC2981) returns (bool) {
4116     return super.supportsInterface(interfaceId);
4117   }
4118   //for ERC2981 Opensea
4119   function contractURI() external view virtual returns (string memory) {
4120         return _formatContractURI();
4121   }
4122   //make contractURI
4123   function _formatContractURI() internal view returns (string memory) {
4124     (address receiver, uint256 royaltyFraction) = royaltyInfo(0,_feeDenominator());//tokenid=0
4125     return string(
4126       abi.encodePacked(
4127         "data:application/json;base64,",
4128         Base64.encode(
4129           bytes(
4130             abi.encodePacked(
4131                 '{"seller_fee_basis_points":', Strings.toString(royaltyFraction),
4132                 ', "fee_recipient":"', Strings.toHexString(uint256(uint160(receiver)), 20), '"}'
4133             )
4134           )
4135         )
4136       )
4137     );
4138   }
4139   //set maxSupply.only owner.
4140   function setMaxSupply(uint256 _maxSupply) external virtual onlyOperator {
4141     maxSupply = _maxSupply;
4142   }
4143   //set mintable.only owner.
4144   function setMintable(uint256 _mintable) external virtual onlyOperator {
4145     mintable = _mintable;
4146   }
4147     // GET phaseId.
4148   function getPhaseIds(uint256 _alId) external view virtual returns (uint256){
4149     return phaseIds[_alId];
4150   }
4151     // SET phaseId.
4152   function setPhaseId(uint256 _alId,uint256 _phaseId) external virtual onlyOperator {
4153     phaseIds[_alId] = _phaseId;
4154   }
4155     // SET phaseId.
4156   function setPhaseIdWithReset(uint256 _alId,uint256 _phaseId) external virtual onlyOperator {
4157     phaseIds[_alId] = _phaseId;
4158     nowPhaseAl += 1;
4159   }
4160   function setNowPhaseWl(uint256 _nowPhaseWl) external virtual onlyOperator {
4161     nowPhaseWl = _nowPhaseWl;
4162   }
4163   function setNowPhaseAl(uint256 _nowPhaseAl) external virtual onlyOperator {
4164     nowPhaseAl = _nowPhaseAl;
4165   }
4166   function setNowPhasePs(uint256 _nowPhasePs) external virtual onlyOperator {
4167     nowPhasePs = _nowPhasePs;
4168   }
4169   // SET PRICES.
4170   //WL.Price
4171   function setWlPrice(uint256 newPrice) external virtual onlyOperator {
4172     wlMintPrice = newPrice;
4173   }
4174   //AL.Price
4175   function setAlPrice(uint256 _alId,uint256 newPrice) external virtual onlyOperator {
4176     alMintPrice[_alId] = newPrice;
4177   }
4178   //PS.Price
4179   function setPsPrice(uint256 newPrice) external virtual onlyOperator {
4180     psMintPrice = newPrice;
4181   }
4182   //set reveal.only owner.
4183   function setReveal(uint256 newRevealNum) external virtual onlyOperator {
4184     revealed = newRevealNum;
4185   }
4186   //return _isRevealed()
4187   function _isRevealed(uint256 _tokenId) internal view virtual returns (bool){
4188     return _tokenId <= revealed;
4189   }
4190   // GET MINTED COUNT.
4191   function wlMinted(address _address) external view virtual returns (uint256){
4192     return _wlMinted[nowPhaseWl][_address];
4193   }
4194   function alMinted(address _address) external view virtual returns (uint256){
4195     return _alMinted[nowPhaseAl][phaseIds[nowPhaseAl]][_address];
4196   }
4197   function alIdMinted(uint256 _nowPhaseAl,address _address) external view virtual returns (uint256){
4198     return _alMinted[_nowPhaseAl][phaseIds[_nowPhaseAl]][_address];
4199   }
4200   function psMinted(address _address) external view virtual returns (uint256){
4201     return _psMinted[nowPhasePs][_address];
4202   }
4203   // SET MAX MINTS.
4204   //get.AL.mxmints
4205   function getAlMaxMints() external view virtual returns (uint256){
4206     return maxMintsPerAL[phaseId];
4207   }
4208   //set.AL.mxmints
4209   function setAlMaxMints(uint256 _alId,uint256 _max) external virtual onlyOperator {
4210     maxMintsPerAL[_alId] = _max;
4211   }
4212   //PS.mxmints
4213   function setPsMaxMints(uint256 _max) external virtual onlyOperator {
4214     maxMintsPerPS = _max;
4215   }
4216   // SET SALES ENABLE.
4217   //WL.SaleEnable
4218   function setWhitelistSaleEnable(uint256 _phaseId,bool bool_) external virtual onlyOperator {
4219     isWlSaleEnabled[_phaseId] = bool_;
4220   }
4221 
4222   //AL.SaleEnable
4223   function setAllowlistSaleEnable(uint256 _alId,bool bool_) external virtual onlyOperator {
4224     isAlSaleEnabled[_alId] = bool_;
4225   }
4226   //PS.SaleEnable
4227   function setPublicSaleEnable(bool bool_) external virtual onlyOperator {
4228     isPublicSaleEnabled = bool_;
4229   }
4230 
4231   function setMerkleRootWl(bytes32 merkleRoot_) external virtual onlyOperator {
4232     _setWlMerkleRoot(merkleRoot_);
4233   }
4234 
4235   function setMerkleRootWlWithId(uint256 _phaseId,bytes32 merkleRoot_) external virtual onlyOperator {
4236     _setWlMerkleRootWithId(_phaseId,merkleRoot_);
4237   }
4238 
4239   function setMerkleRootAlWithId(uint256 _phaseId,bytes32 merkleRoot_) external virtual onlyOperator {
4240     _setAlMerkleRootWithId(_phaseId,merkleRoot_);
4241   }
4242   //set HiddenBaseURI.only owner.
4243   function setHiddenURI(string memory uri_) external virtual onlyOperator {
4244     hiddenURI = uri_;
4245   }
4246   //return _currentIndex
4247   function getCurrentIndex() external view virtual returns (uint256){
4248     return _nextTokenId() -1;
4249   }
4250   /** @dev set BaseURI at after reveal. only owner. */
4251   function setBaseURI(string memory uri_) external virtual onlyOperator {
4252     _baseTokenURI = uri_;
4253   }
4254 
4255   function setBaseExtension(string memory _newBaseExtension) external onlyOperator
4256   {
4257     _baseExtension = _newBaseExtension;
4258   }
4259 
4260   /** @dev BaseURI.internal. */
4261   function _currentBaseURI() internal view returns (string memory){
4262     return _baseTokenURI;
4263   }
4264 
4265   function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
4266     require(_exists(_tokenId), "URI query for nonexistent token");
4267     if(_isRevealed(_tokenId)){
4268         return string(abi.encodePacked(_currentBaseURI(), Strings.toString(_tokenId), _baseExtension));
4269     }
4270     return hiddenURI;
4271   }
4272   
4273   /** @dev owner mint.transfer to _address.only owner. */
4274   function ownerMintSafe(uint256 _amount, address _address) external virtual onlyOperator { 
4275     require((_amount + totalSupply()) <= (maxSupply) || maxSupply == 0, "No more NFTs");
4276     _safeMint(_address, _amount);
4277   }
4278   
4279   //WL mint.
4280   function whitelistMint(uint256 _phaseId,uint256 _amount, uint256 wlcount, bytes32[] memory proof_) external payable virtual nonReentrant {
4281     require(isWlSaleEnabled[_phaseId], "whitelistMint is Paused");
4282     require(isWhitelisted(msg.sender,_phaseId, wlcount, proof_), "You are not whitelisted!");
4283     require(wlcount > 0, "You have no WL!");
4284     require(wlcount >= _amount, "whitelistMint: Over max mints per wallet");
4285     require(wlcount >= _wlMinted[_phaseId][msg.sender] + _amount, "You have no whitelistMint left");
4286     require(msg.value == wlMintPrice * _amount, "ETH value is not correct");
4287     require((_amount + totalSupply()) <= (mintable) || mintable == 0, "No more NFTs");
4288     _wlMinted[_phaseId][msg.sender] += _amount;
4289     _safeMint(msg.sender, _amount);
4290   }
4291   
4292   //AL mint.
4293   function allowlistMint(uint256 _alId,uint256 _amount, bytes32[] memory proof_) external payable virtual nonReentrant {
4294     require(isAlSaleEnabled[_alId], "allowlistMint is Paused");
4295     require(isAllowlisted(msg.sender,_alId, proof_), "You are not whitelisted!");
4296     require(maxMintsPerALOT >= _amount, "allowlistMint: Over max mints per one time");
4297     require(maxMintsPerAL[_alId] >= _amount, "allowlistMint: Over max mints per wallet");
4298     require(maxMintsPerAL[_alId] >= _alMinted[_alId][phaseIds[_alId]][msg.sender] + _amount, "You have no whitelistMint left");
4299     require(msg.value == alMintPrice[_alId] * _amount, "ETH value is not correct");
4300     require((_amount + totalSupply()) <= (mintable) || mintable == 0, "No more NFTs");
4301     _alMinted[_alId][phaseIds[_alId]][msg.sender] += _amount;
4302     _safeMint(msg.sender, _amount);
4303   }
4304 
4305   //Public mint.
4306   function publicMint(uint256 _amount) external payable virtual nonReentrant {
4307     require(isPublicSaleEnabled, "publicMint is Paused");
4308     require(maxMintsPerPSOT >= _amount, "publicMint: Over max mints per one time");
4309     require(maxMintsPerPS >= _amount, "publicMint: Over max mints per wallet");
4310     require(maxMintsPerPS >= _psMinted[nowPhasePs][msg.sender] + _amount, "You have no publicMint left");
4311     require(msg.value == psMintPrice * _amount, "ETH value is not correct");
4312     require((_amount + totalSupply()) <= (mintable) || mintable == 0, "No more NFTs");
4313     _psMinted[nowPhasePs][msg.sender] += _amount;
4314     _safeMint(msg.sender, _amount);
4315   }
4316 
4317   /** @dev receive. */
4318   function receiveToDeb() external payable virtual onlyOperator nonReentrant {
4319       require(msg.value > 0, "ETH value is not correct");
4320   }
4321 
4322   /** @dev widraw ETH from this contract.only operator. */
4323   function withdraw() external payable virtual onlyOperator nonReentrant{
4324     require((_aa != address(0) && _aaPerc != 0) || _aa == address(0),"please set withdraw Address_aa and percentage.");
4325     require((_bb != address(0) && _bbPerc != 0) || _bb == address(0),"please set withdraw Address_bb and percentage.");
4326     require((_cc != address(0) && _ccPerc != 0) || _cc == address(0),"please set withdraw Address_cc and percentage.");
4327     require((_dd != address(0) && _ddPerc != 0) || _dd == address(0),"please set withdraw Address_dd and percentage.");
4328     require((_ee != address(0) && _eePerc != 0) || _ee == address(0),"please set withdraw Address_ee and percentage.");
4329     require((_ff != address(0) && _ffPerc != 0) || _ff == address(0),"please set withdraw Address_ff and percentage.");
4330     uint256 _ethBalance = address(this).balance;
4331     bool os;
4332     if(_aa != address(0)){//if _aa has.
4333         (os, ) = payable(_aa).call{value: (_ethBalance * _aaPerc/10000)}("");
4334         require(os, "Failed to withdraw_aa Ether");
4335     }
4336     if(_bb != address(0)){//if _bb has.
4337         (os, ) = payable(_bb).call{value: (_ethBalance * _bbPerc/10000)}("");
4338         require(os, "Failed to withdraw_bb Ether");
4339     }
4340     if(_cc != address(0)){//if _cc has.
4341         (os, ) = payable(_cc).call{value: (_ethBalance * _ccPerc/10000)}("");
4342         require(os, "Failed to withdraw_cc Ether");
4343     }
4344     if(_dd != address(0)){//if _dd has.
4345         (os, ) = payable(_dd).call{value: (_ethBalance * _ddPerc/10000)}("");
4346         require(os, "Failed to withdraw_dd Ether");
4347     }
4348     if(_ee != address(0)){//if _ee has.
4349         (os, ) = payable(_ee).call{value: (_ethBalance * _eePerc/10000)}("");
4350         require(os, "Failed to withdraw_ee Ether");
4351     }
4352     if(_ff != address(0)){//if _ff has.
4353         (os, ) = payable(_ff).call{value: (_ethBalance * _ffPerc/10000)}("");
4354         require(os, "Failed to withdraw_ff Ether");
4355     }
4356     _ethBalance = address(this).balance;
4357     if(_withdrawWallet != address(0)){//if _withdrawWallet has.
4358         (os, ) = payable(_withdrawWallet).call{value: (_ethBalance)}("");
4359     }else{
4360         (os, ) = payable(owner()).call{value: (_ethBalance)}("");
4361     }
4362     require(os, "Failed to withdraw Ether");
4363   }
4364 
4365     //burn
4366     function burn(uint256 tokenId) external virtual {
4367         require(ownerOf(tokenId) == msg.sender, "isnt owner token");
4368         require(lockBurn == false, "not allow");
4369         _burn(tokenId);
4370     }
4371     // //set.LockBurn
4372     function setLockBurn(bool bool_) external virtual onlyOperator {
4373         lockBurn = bool_;
4374     }
4375 
4376   //return wallet owned tokenids.
4377   function walletOfOwner(address _address) external view virtual returns (uint256[] memory) {
4378     uint256 ownerTokenCount = balanceOf(_address);
4379     uint256[] memory tokenIds = new uint256[](ownerTokenCount);
4380     //search from all tonkenid. so spend high gas values.attention.
4381     uint256 tokenindex = 0;
4382     for (uint256 i = _startTokenId(); i < (_nextTokenId() -1); i++) {
4383       if(_address == this.tryOwnerOf(i)) tokenIds[tokenindex++] = i;
4384     }
4385     return tokenIds;
4386   }
4387 
4388     //try catch vaersion ownerOf. support burned tokenid.
4389     function tryOwnerOf(uint256 tokenId) external view  virtual returns (address) {
4390         try this.ownerOf(tokenId) returns (address _address) {
4391             return(_address);
4392         } catch {
4393             return (address(0));//return 0x0 if error.
4394         }
4395     }
4396 
4397 
4398   /**
4399     @dev set aa's wallet and fraction.withdraw to this wallet.only operator.
4400     */
4401   function setWallet__aa(address _owner,uint256 _perc) external virtual onlyOperator {
4402     _aa = _owner;
4403     _aaPerc = _perc;
4404   }
4405 
4406   /**
4407     @dev set bb's wallet and fraction.withdraw to this wallet.only operator.
4408     */
4409   function setWallet__bb(address _owner,uint256 _perc) external virtual onlyOperator {
4410     _bb = _owner;
4411     _bbPerc = _perc;
4412   }
4413 
4414   /**
4415     @dev set cc's wallet and fraction.withdraw to this wallet.only operator.
4416     */
4417   function setWallet__cc(address _owner,uint256 _perc) external virtual onlyOperator {
4418     _cc = _owner;
4419     _ccPerc = _perc;
4420   }
4421 
4422   /**
4423     @dev set dd's wallet and fraction.withdraw to this wallet.only operator.
4424     */
4425   function setWallet__dd(address _owner,uint256 _perc) external virtual onlyOperator {
4426     _dd = _owner;
4427     _ddPerc = _perc;
4428   }
4429 
4430   /**
4431     @dev set ee's wallet and fraction.withdraw to this wallet.only operator.
4432     */
4433   function setWallet__ee(address _owner,uint256 _perc) external virtual onlyOperator {
4434     _ee = _owner;
4435     _eePerc = _perc;
4436   }
4437 
4438   /**
4439     @dev set ff's wallet and fraction.withdraw to this wallet.only operator.
4440     */
4441   function setWallet__ff(address _owner,uint256 _perc) external virtual onlyOperator {
4442     _ff = _owner;
4443     _ffPerc = _perc;
4444   }
4445   /**
4446     @dev set withdraw's wallet.withdraw to this wallet.only operator.
4447     */
4448   function setWallet__ww(address _owner) external virtual onlyOperator {
4449     _withdrawWallet = _owner;
4450   }
4451 
4452     //OPENSEA.OPERATORFilterer.START
4453     /**
4454      * @notice Set the state of the OpenSea operator filter
4455      * @param value Flag indicating if the operator filter should be applied to transfers and approvals
4456      */
4457     function setOperatorFilteringEnabled(bool value) external onlyOperator {
4458         operatorFilteringEnabled = value;
4459     }
4460 
4461     function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {
4462         super.setApprovalForAll(operator, approved);
4463     }
4464 
4465     function approve(address operator, uint256 tokenId) public override onlyAllowedOperatorApproval(operator) {
4466         super.approve(operator, tokenId);
4467     }
4468 
4469     function transferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {
4470         super.transferFrom(from, to, tokenId);
4471     }
4472 
4473     function safeTransferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {
4474         super.safeTransferFrom(from, to, tokenId);
4475     }
4476 
4477     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)
4478         public
4479         override
4480         onlyAllowedOperator(from)
4481     {
4482         super.safeTransferFrom(from, to, tokenId, data);
4483     }
4484     //OPENSEA.OPERATORFilterer.END
4485 
4486     /*///////////////////////////////////////////////////////////////
4487                     OVERRIDES ERC721RestrictApprove
4488     //////////////////////////////////////////////////////////////*/
4489     function addLocalContractAllowList(address transferer)
4490         external
4491         override
4492         onlyOperator
4493     {
4494         _addLocalContractAllowList(transferer);
4495     }
4496 
4497     function removeLocalContractAllowList(address transferer)
4498         external
4499         override
4500         onlyOperator
4501     {
4502         _removeLocalContractAllowList(transferer);
4503     }
4504 
4505     function getLocalContractAllowList()
4506         external
4507         override
4508         view
4509         returns(address[] memory)
4510     {
4511         return _getLocalContractAllowList();
4512     }
4513 
4514     function setCALLevel(uint256 level) public override onlyOperator {
4515         CALLevel = level;
4516     }
4517 
4518     function setCAL(address calAddress) external override onlyOperator {
4519         _setCAL(calAddress);
4520     }
4521 
4522     /**
4523         @dev Operable.Role.ADD
4524      */
4525     function grantOperatorRole(address _candidate) external onlyOwner {
4526         _grantOperatorRole(_candidate);
4527     }
4528     /**
4529         @dev Operable.Role.REMOVE
4530      */
4531     function revokeOperatorRole(address _candidate) external onlyOwner {
4532         _revokeOperatorRole(_candidate);
4533     }
4534     
4535 }
4536 //CODE.BY.FRICKLIK