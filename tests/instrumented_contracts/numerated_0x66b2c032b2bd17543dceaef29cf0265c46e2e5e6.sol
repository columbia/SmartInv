1 {{
2   "language": "Solidity",
3   "sources": {
4     "/contracts/cryptofoxes/CryptoFoxesShop.sol": {
5       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"./CryptoFoxesShopWithdraw.sol\";\r\nimport \"./CryptoFoxesShopProducts.sol\";\r\n\r\ncontract CryptoFoxesShop is Ownable, CryptoFoxesShopProducts, CryptoFoxesShopWithdraw, ReentrancyGuard{\r\n\r\n    mapping(string => uint256) public purchasedProduct;\r\n    mapping(string => mapping(address => uint256)) public purchasedProductWallet;\r\n\r\n    uint256 public purchaseId;\r\n\r\n    event Purchase(address indexed _owner, string indexed _slug, uint256 _quantity, uint256 _id);\r\n\r\n    constructor(address _cryptoFoxesSteak) CryptoFoxesShopWithdraw(_cryptoFoxesSteak) {}\r\n\r\n    //////////////////////////////////////////////////\r\n    //      TESTER                                  //\r\n    //////////////////////////////////////////////////\r\n\r\n    function checkPurchase(string memory _slug, uint256 _quantity, address _wallet) private{\r\n\r\n        require(products[_slug].enable && _quantity > 0,\"Product not available\");\r\n\r\n        if(products[_slug].start > 0 && products[_slug].end > 0){\r\n            require(products[_slug].start <= block.timestamp && block.timestamp <= products[_slug].end, \"Product not available\");\r\n        }\r\n\r\n        if (products[_slug].quantityMax > 0) {\r\n            require(purchasedProduct[_slug] + _quantity <= products[_slug].quantityMax, \"Product sold out\");\r\n            purchasedProduct[_slug] += _quantity;\r\n        }\r\n\r\n        if(products[_slug].maxPerWallet > 0){\r\n            require(purchasedProductWallet[_slug][_wallet] + _quantity <= products[_slug].maxPerWallet, \"Max per wallet limit\");\r\n            purchasedProductWallet[_slug][_wallet] += _quantity;\r\n        }\r\n    }\r\n\r\n    function _compareStrings(string memory a, string memory b) private pure returns (bool) {\r\n        return keccak256(bytes(a)) == keccak256(bytes(b));\r\n    }\r\n\r\n    //////////////////////////////////////////////////\r\n    //      PURCHASE                               //\r\n    //////////////////////////////////////////////////\r\n\r\n    function purchase(string memory _slug, uint256 _quantity) public nonReentrant {\r\n        _purchase(_msgSender(), _slug, _quantity);\r\n    }\r\n\r\n    function purchaseCart(string[] memory _slugs, uint256[] memory _quantities) public nonReentrant {\r\n        _purchaseCart(_msgSender(), _slugs, _quantities);\r\n    }\r\n\r\n    function _purchase(address _wallet, string memory _slug, uint256 _quantity) private {\r\n\r\n        checkPurchase(_slug, _quantity, _wallet);\r\n\r\n        uint256 price = products[_slug].price * _quantity;\r\n\r\n        if(price > 0){\r\n            cryptoFoxesSteak.transferFrom(_wallet, address(this), price);\r\n        }\r\n\r\n        purchaseId += 1;\r\n        emit Purchase(_msgSender(), _slug, _quantity, purchaseId);\r\n    }\r\n\r\n    function _purchaseCart(address _wallet, string[] memory _slugs, uint256[] memory _quantities) private  {\r\n        require(_slugs.length == _quantities.length, \"Bad data length\");\r\n\r\n        uint256 price = 0;\r\n        for (uint256 i = 0; i < _slugs.length; i++) {\r\n            for (uint256 j = 0; j < i; j++) {\r\n                if(_compareStrings(_slugs[j], _slugs[i]) == true) {\r\n                    revert(\"Duplicate slug\");\r\n                }\r\n            }\r\n            checkPurchase(_slugs[i], _quantities[i], _wallet);\r\n            price += products[_slugs[i]].price * _quantities[i];\r\n        }\r\n\r\n        if(price > 0){\r\n            cryptoFoxesSteak.transferFrom(_wallet, address(this), price);\r\n        }\r\n\r\n        for (uint256 i = 0; i < _slugs.length; i++) {\r\n            purchaseId += 1;\r\n            emit Purchase(_wallet, _slugs[i], _quantities[i], purchaseId);\r\n        }\r\n    }\r\n\r\n    //////////////////////////////////////////////////\r\n    //      PURCHASE BY CONTRACT                   //\r\n    //////////////////////////////////////////////////\r\n\r\n    function purchaseByContract(address _wallet, string memory _slug, uint256 _quantity) public isFoxContract {\r\n        _purchase(_wallet, _slug, _quantity);\r\n    }\r\n\r\n    function purchaseCartByContract(address _wallet, string[] memory _slugs, uint256[] memory _quantities) public isFoxContract {\r\n        _purchaseCart(_wallet, _slugs, _quantities);\r\n    }\r\n\r\n    //////////////////////////////////////////////////\r\n    //      PRODUCT GETTER                          //\r\n    //////////////////////////////////////////////////\r\n\r\n    function getProductPrice(string memory _slug, uint256 _quantity) public view returns(uint256){\r\n        return products[_slug].price * _quantity;\r\n    }\r\n    function getProductStock(string memory _slug) public view returns(uint256){\r\n        return products[_slug].quantityMax - getTotalProductPurchased(_slug);\r\n    }\r\n    function getTotalProductPurchased(string memory _slug) public view returns(uint256){\r\n        return purchasedProduct[_slug];\r\n    }\r\n    function getTotalProductPurchasedWallet(string memory _slug, address _wallet) public view returns(uint256){\r\n        return purchasedProductWallet[_slug][_wallet];\r\n    }\r\n}"
6     },
7     "/contracts/cryptofoxes/interfaces/ICryptoFoxesSteakBurnableShop.sol": {
8       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./ICryptoFoxesSteakBurnable.sol\";\r\n\r\n// @author: miinded.com\r\n\r\ninterface ICryptoFoxesSteakBurnableShop is IERC20, ICryptoFoxesSteakBurnable {\r\n    function burn(uint256 _amount) external;\r\n}"
9     },
10     "/contracts/cryptofoxes/interfaces/ICryptoFoxesSteakBurnable.sol": {
11       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\nimport \"./ICryptoFoxesSteak.sol\";\r\n\r\n// @author: miinded.com\r\n\r\ninterface ICryptoFoxesSteakBurnable is ICryptoFoxesSteak {\r\n    function burnSteaks(address _to, uint256 _amount) external;\r\n}"
12     },
13     "/contracts/cryptofoxes/interfaces/ICryptoFoxesSteak.sol": {
14       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// @author: miinded.com\r\n\r\ninterface ICryptoFoxesSteak {\r\n    function addRewards(address _to, uint256 _amount) external;\r\n    function withdrawRewards(address _to) external;\r\n    function isPaused() external view returns(bool);\r\n    function dateEndRewards() external view returns(uint256);\r\n}"
15     },
16     "/contracts/cryptofoxes/interfaces/ICryptoFoxesShopStruct.sol": {
17       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// @author: miinded.com\r\n\r\ninterface ICryptoFoxesShopStruct {\r\n\r\n    struct Product {\r\n        uint256 price;\r\n        uint256 start;\r\n        uint256 end;\r\n        uint256 maxPerWallet; // 0 for infinity\r\n        uint256 quantityMax; // 0 for infinity\r\n        bool enable;\r\n        bool isValid;\r\n    }\r\n\r\n}"
18     },
19     "/contracts/cryptofoxes/interfaces/ICryptoFoxesShopProducts.sol": {
20       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./ICryptoFoxesShopStruct.sol\";\r\n\r\n// @author: miinded.com\r\n\r\ninterface ICryptoFoxesShopProducts is ICryptoFoxesShopStruct {\r\n\r\n    function getProducts() external view returns(Product[] memory);\r\n    function getProduct(string calldata _slug) external view returns(Product memory);\r\n}"
21     },
22     "/contracts/cryptofoxes/CryptoFoxesShopWithdraw.sol": {
23       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./CryptoFoxesAllowed.sol\";\r\nimport \"./interfaces/ICryptoFoxesSteakBurnableShop.sol\";\r\n\r\ncontract CryptoFoxesShopWithdraw is CryptoFoxesAllowed {\r\n    using SafeMath for uint256;\r\n\r\n    struct Part {\r\n        address wallet;\r\n        uint256 part;\r\n        uint256 timestamp;\r\n    }\r\n    uint256 startIndexParts = 0;\r\n\r\n    Part[] public parts;\r\n\r\n    ICryptoFoxesSteakBurnableShop public cryptoFoxesSteak;\r\n\r\n    constructor(address _cryptoFoxesSteak) {\r\n        cryptoFoxesSteak = ICryptoFoxesSteakBurnableShop(_cryptoFoxesSteak);\r\n\r\n        parts.push(Part(address(0), 90, block.timestamp));\r\n    }\r\n\r\n    function changePart(Part[] memory _parts) public isFoxContractOrOwner{\r\n        startIndexParts = parts.length;\r\n        for(uint256 i = 0; i < _parts.length; i++){\r\n            parts.push(Part(_parts[i].wallet, _parts[i].part, block.timestamp));\r\n        }\r\n    }\r\n\r\n    function getParts() public view returns(Part[] memory){\r\n        return parts;\r\n    }\r\n\r\n    //////////////////////////////////////////////////\r\n    //      WITHDRAW                                //\r\n    //////////////////////////////////////////////////\r\n\r\n    function withdrawAndBurn() public isFoxContractOrOwner {\r\n        uint256 balance = cryptoFoxesSteak.balanceOf(address(this));\r\n        require(balance > 0);\r\n\r\n        for (uint256 i = startIndexParts; i < parts.length; i++) {\r\n            if (parts[i].part == 0) {\r\n                continue;\r\n            }\r\n            if (parts[i].wallet == address(0)) {\r\n                cryptoFoxesSteak.burn(balance.mul(parts[i].part).div(100));\r\n            } else {\r\n                cryptoFoxesSteak.transfer(parts[i].wallet, balance.mul(parts[i].part).div(100));\r\n            }\r\n        }\r\n\r\n        cryptoFoxesSteak.transfer(owner(), cryptoFoxesSteak.balanceOf(address(this)));\r\n    }\r\n}"
24     },
25     "/contracts/cryptofoxes/CryptoFoxesShopProducts.sol": {
26       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./interfaces/ICryptoFoxesShopProducts.sol\";\r\nimport \"./CryptoFoxesAllowed.sol\";\r\n\r\ncontract CryptoFoxesShopProducts is ICryptoFoxesShopProducts, CryptoFoxesAllowed{\r\n\r\n    mapping(string => Product) public products;\r\n    string[] public productSlugs;\r\n\r\n    //////////////////////////////////////////////////\r\n    //      PRODUCT SETTER                          //\r\n    //////////////////////////////////////////////////\r\n\r\n    function addProduct(string memory _slug, Product memory _product) public isFoxContractOrOwner{\r\n        require(!products[_slug].isValid, \"Product slug already exist\");\r\n        require(_product.isValid, \"Missing isValid param\");\r\n        products[_slug] = _product;\r\n        productSlugs.push(_slug);\r\n    }\r\n\r\n    function editProduct(string memory _slug, Product memory _product) public isFoxContractOrOwner{\r\n        require(products[_slug].isValid, \"Product slug does not exist\");\r\n        require(_product.isValid, \"Missing isValid param\");\r\n\r\n        if(products[_slug].maxPerWallet == 0){\r\n            require(_product.maxPerWallet == 0, \"maxPerWallet == 0, need to change slug\");\r\n        }\r\n\r\n        products[_slug] = _product;\r\n    }\r\n\r\n    function statusProduct(string memory _slug, bool _enable) public isFoxContractOrOwner {\r\n        require(products[_slug].isValid, \"Product slug does not exist\");\r\n        products[_slug].enable = _enable;\r\n    }\r\n\r\n    //////////////////////////////////////////////////\r\n    //      PRODUCT GETTER                          //\r\n    //////////////////////////////////////////////////\r\n\r\n    function getProduct(string memory _slug) public override view returns(Product memory) {\r\n        return products[_slug];\r\n    }\r\n    function getProducts() public override view returns(Product[] memory) {\r\n        Product[] memory prods = new Product[](productSlugs.length);\r\n        for(uint256 i = 0; i < productSlugs.length; i ++){\r\n            prods[i] = products[productSlugs[i]];\r\n        }\r\n        return prods;\r\n    }\r\n    function getSlugs() public view returns(string[] memory) {\r\n        return productSlugs;\r\n    }\r\n\r\n}"
27     },
28     "/contracts/cryptofoxes/CryptoFoxesAllowed.sol": {
29       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./interfaces/ICryptoFoxesSteak.sol\";\r\n\r\n// @author: miinded.com\r\n\r\nabstract contract CryptoFoxesAllowed is Ownable {\r\n\r\n    mapping (address => bool) public allowedContracts;\r\n\r\n    modifier isFoxContract() {\r\n        require(allowedContracts[_msgSender()] == true, \"Not allowed\");\r\n        _;\r\n    }\r\n    \r\n    modifier isFoxContractOrOwner() {\r\n        require(allowedContracts[_msgSender()] == true || _msgSender() == owner(), \"Not allowed\");\r\n        _;\r\n    }\r\n\r\n    function setAllowedContract(address _contract, bool _allowed) public onlyOwner {\r\n        allowedContracts[_contract] = _allowed;\r\n    }\r\n\r\n}"
30     },
31     "@openzeppelin/contracts/utils/math/SafeMath.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
33     },
34     "@openzeppelin/contracts/utils/Context.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
36     },
37     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
39     },
40     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
41       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
42     },
43     "@openzeppelin/contracts/access/Ownable.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
45     }
46   },
47   "settings": {
48     "remappings": [],
49     "optimizer": {
50       "enabled": true,
51       "runs": 1500
52     },
53     "evmVersion": "london",
54     "libraries": {},
55     "outputSelection": {
56       "*": {
57         "*": [
58           "evm.bytecode",
59           "evm.deployedBytecode",
60           "devdoc",
61           "userdoc",
62           "metadata",
63           "abi"
64         ]
65       }
66     }
67   }
68 }}