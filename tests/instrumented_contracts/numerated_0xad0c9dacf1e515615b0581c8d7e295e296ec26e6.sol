1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/upgrades/GraphProxy.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./GraphProxyStorage.sol\";\n\n/**\n * @title Graph Proxy\n * @dev Graph Proxy contract used to delegate call implementation contracts and support upgrades.\n * This contract should NOT define storage as it is managed by GraphProxyStorage.\n * This contract implements a proxy that is upgradeable by an admin.\n * https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies#transparent-proxies-and-function-clashes\n */\ncontract GraphProxy is GraphProxyStorage {\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless\n     * the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless\n     * the sender is the admin or pending implementation.\n     */\n    modifier ifAdminOrPendingImpl() {\n        if (msg.sender == _admin() || msg.sender == _pendingImplementation()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Contract constructor.\n     * @param _impl Address of the initial implementation\n     * @param _admin Address of the proxy admin\n     */\n    constructor(address _impl, address _admin) {\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        assert(\n            IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\n        );\n        assert(\n            PENDING_IMPLEMENTATION_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.pendingImplementation\")) - 1)\n        );\n\n        _setAdmin(_admin);\n        _setPendingImplementation(_impl);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin and implementation can call this function.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdminOrPendingImpl returns (address) {\n        return _admin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdminOrPendingImpl returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Returns the current pending implementation.\n     *\n     * NOTE: Only the admin can call this function.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x9e5eddc59e0b171f57125ab86bee043d9128098c3a6b9adb4f2e86333c2f6f8c`\n     */\n    function pendingImplementation() external ifAdminOrPendingImpl returns (address) {\n        return _pendingImplementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * NOTE: Only the admin can call this function.\n     */\n    function setAdmin(address _newAdmin) external ifAdmin {\n        require(_newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n        _setAdmin(_newAdmin);\n    }\n\n    /**\n     * @dev Upgrades to a new implementation contract.\n     * @param _newImplementation Address of implementation contract\n     *\n     * NOTE: Only the admin can call this function.\n     */\n    function upgradeTo(address _newImplementation) external ifAdmin {\n        _setPendingImplementation(_newImplementation);\n    }\n\n    /**\n     * @dev Admin function for new implementation to accept its role as implementation.\n     */\n    function acceptUpgrade() external ifAdminOrPendingImpl {\n        _acceptUpgrade();\n    }\n\n    /**\n     * @dev Admin function for new implementation to accept its role as implementation.\n     */\n    function acceptUpgradeAndCall(bytes calldata data) external ifAdminOrPendingImpl {\n        _acceptUpgrade();\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _implementation().delegatecall(data);\n        require(success);\n    }\n\n    /**\n     * @dev Admin function for new implementation to accept its role as implementation.\n     */\n    function _acceptUpgrade() internal {\n        address _pendingImplementation = _pendingImplementation();\n        require(Address.isContract(_pendingImplementation), \"Implementation must be a contract\");\n        require(\n            _pendingImplementation != address(0) && msg.sender == _pendingImplementation,\n            \"Caller must be the pending implementation\"\n        );\n\n        _setImplementation(_pendingImplementation);\n        _setPendingImplementation(address(0));\n    }\n\n    /**\n     * @dev Delegates the current call to implementation.\n     * This function does not return to its internal call site, it will return directly to the\n     * external caller.\n     */\n    function _fallback() internal {\n        require(msg.sender != _admin(), \"Cannot fallback to proxy target\");\n\n        assembly {\n            // (a) get free memory pointer\n            let ptr := mload(0x40)\n\n            // (b) get address of the implementation\n            let impl := and(sload(IMPLEMENTATION_SLOT), 0xffffffffffffffffffffffffffffffffffffffff)\n\n            // (1) copy incoming call data\n            calldatacopy(ptr, 0, calldatasize())\n\n            // (2) forward call to logic contract\n            let result := delegatecall(gas(), impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n\n            // (3) retrieve return data\n            returndatacopy(ptr, 0, size)\n\n            // (4) forward return data back to caller\n            switch result\n                case 0 {\n                    revert(ptr, size)\n                }\n                default {\n                    return(ptr, size)\n                }\n        }\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to implementation. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to implementation. Will run if call data\n     * is empty.\n     */\n    receive() external payable {\n        _fallback();\n    }\n}\n"
6     },
7     "@openzeppelin/contracts/utils/Address.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
9     },
10     "contracts/upgrades/GraphProxyStorage.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\n\n/**\n * @title Graph Proxy Storage\n * @dev Contract functions related to getting and setting proxy storage.\n * This contract does not actually define state variables managed by the compiler\n * but uses fixed slot locations.\n */\ncontract GraphProxyStorage {\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32\n        internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Storage slot with the address of the pending implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.pendingImplementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32\n        internal constant PENDING_IMPLEMENTATION_SLOT = 0x9e5eddc59e0b171f57125ab86bee043d9128098c3a6b9adb4f2e86333c2f6f8c;\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32\n        internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when pendingImplementation is changed.\n     */\n    event PendingImplementationUpdated(\n        address indexed oldPendingImplementation,\n        address indexed newPendingImplementation\n    );\n\n    /**\n     * @dev Emitted when pendingImplementation is accepted,\n     * which means contract implementation is updated.\n     */\n    event ImplementationUpdated(\n        address indexed oldImplementation,\n        address indexed newImplementation\n    );\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminUpdated(address indexed oldAdmin, address indexed newAdmin);\n\n    /**\n     * @dev Modifier to check whether the `msg.sender` is the admin.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == _admin(), \"Caller must be admin\");\n        _;\n    }\n\n    /**\n     * @return adm The admin slot.\n     */\n    function _admin() internal view returns (address adm) {\n        bytes32 slot = ADMIN_SLOT;\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Sets the address of the proxy admin.\n     * @param _newAdmin Address of the new proxy admin\n     */\n    function _setAdmin(address _newAdmin) internal {\n        bytes32 slot = ADMIN_SLOT;\n        assembly {\n            sstore(slot, _newAdmin)\n        }\n\n        emit AdminUpdated(_admin(), _newAdmin);\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     * @return impl Address of the current implementation\n     */\n    function _implementation() internal view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Returns the current pending implementation.\n     * @return impl Address of the current pending implementation\n     */\n    function _pendingImplementation() internal view returns (address impl) {\n        bytes32 slot = PENDING_IMPLEMENTATION_SLOT;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Sets the implementation address of the proxy.\n     * @param _newImplementation Address of the new implementation\n     */\n    function _setImplementation(address _newImplementation) internal {\n        address oldImplementation = _implementation();\n\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            sstore(slot, _newImplementation)\n        }\n\n        emit ImplementationUpdated(oldImplementation, _newImplementation);\n    }\n\n    /**\n     * @dev Sets the pending implementation address of the proxy.\n     * @param _newImplementation Address of the new pending implementation\n     */\n    function _setPendingImplementation(address _newImplementation) internal {\n        address oldPendingImplementation = _pendingImplementation();\n\n        bytes32 slot = PENDING_IMPLEMENTATION_SLOT;\n        assembly {\n            sstore(slot, _newImplementation)\n        }\n\n        emit PendingImplementationUpdated(oldPendingImplementation, _newImplementation);\n    }\n}\n"
12     }
13   },
14   "settings": {
15     "optimizer": {
16       "enabled": true,
17       "runs": 200
18     },
19     "outputSelection": {
20       "*": {
21         "*": [
22           "evm.bytecode",
23           "evm.deployedBytecode",
24           "abi"
25         ]
26       }
27     },
28     "libraries": {}
29   }
30 }}