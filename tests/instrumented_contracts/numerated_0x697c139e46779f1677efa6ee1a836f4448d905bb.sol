1 // SPDX-License-Identifier: MIT
2 pragma solidity ^0.8.0;
3 
4 
5 library Bytecode {
6   error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);
7 
8   /**
9     @notice Generate a creation code that results on a contract with `_code` as bytecode
10     @param _code The returning value of the resulting `creationCode`
11     @return creationCode (constructor) for new contract
12   */
13   function creationCodeFor(bytes memory _code) internal pure returns (bytes memory) {
14     /*
15       0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size
16       0x01    0x80         0x80        DUP1                size size
17       0x02    0x60         0x600e      PUSH1 14            14 size size
18       0x03    0x60         0x6000      PUSH1 00            0 14 size size
19       0x04    0x39         0x39        CODECOPY            size
20       0x05    0x60         0x6000      PUSH1 00            0 size
21       0x06    0xf3         0xf3        RETURN
22       <CODE>
23     */
24 
25     return abi.encodePacked(
26       hex"63",
27       uint32(_code.length),
28       hex"80_60_0E_60_00_39_60_00_F3",
29       _code
30     );
31   }
32 
33   /**
34     @notice Returns the size of the code on a given address
35     @param _addr Address that may or may not contain code
36     @return size of the code on the given `_addr`
37   */
38   function codeSize(address _addr) internal view returns (uint256 size) {
39     assembly { size := extcodesize(_addr) }
40   }
41 
42   /**
43     @notice Returns the code of a given address
44     @dev It will fail if `_end < _start`
45     @param _addr Address that may or may not contain code
46     @param _start number of bytes of code to skip on read
47     @param _end index before which to end extraction
48     @return oCode read from `_addr` deployed bytecode
49 
50     Forked from: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd
51   */
52   function codeAt(address _addr, uint256 _start, uint256 _end) internal view returns (bytes memory oCode) {
53     uint256 csize = codeSize(_addr);
54     if (csize == 0) return bytes("");
55 
56     if (_start > csize) return bytes("");
57     if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end); 
58 
59     unchecked {
60       uint256 reqSize = _end - _start;
61       uint256 maxSize = csize - _start;
62 
63       uint256 size = maxSize < reqSize ? maxSize : reqSize;
64 
65       assembly {
66         // allocate output byte array - this could also be done without assembly
67         // by using o_code = new bytes(size)
68         oCode := mload(0x40)
69         // new "memory end" including padding
70         mstore(0x40, add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f))))
71         // store length in memory
72         mstore(oCode, size)
73         // actually retrieve the code, this needs assembly
74         extcodecopy(_addr, add(oCode, 0x20), _start, size)
75       }
76     }
77   }
78 }
79 pragma solidity ^0.8.0;
80 
81 /**
82   @title A key-value storage with auto-generated keys for storing chunks of data with a lower write & read cost.
83   @author Agustin Aguilar <aa@horizon.io>
84   Readme: https://github.com/0xsequence/sstore2#readme
85 */
86 library SSTORE2 {
87   error WriteError();
88 
89   /**
90     @notice Stores `_data` and returns `pointer` as key for later retrieval
91     @dev The pointer is a contract address with `_data` as code
92     @param _data to be written
93     @return pointer Pointer to the written `_data`
94   */
95   function write(bytes memory _data) internal returns (address pointer) {
96     // Append 00 to _data so contract can't be called
97     // Build init code
98     bytes memory code = Bytecode.creationCodeFor(
99       abi.encodePacked(
100         hex'00',
101         _data
102       )
103     );
104 
105     // Deploy contract using create
106     assembly { pointer := create(0, add(code, 32), mload(code)) }
107 
108     // Address MUST be non-zero
109     if (pointer == address(0)) revert WriteError();
110   }
111 
112   /**
113     @notice Reads the contents of the `_pointer` code as data, skips the first byte 
114     @dev The function is intended for reading pointers generated by `write`
115     @param _pointer to be read
116     @return data read from `_pointer` contract
117   */
118   function read(address _pointer) internal view returns (bytes memory) {
119     return Bytecode.codeAt(_pointer, 1, type(uint256).max);
120   }
121 
122   /**
123     @notice Reads the contents of the `_pointer` code as data, skips the first byte 
124     @dev The function is intended for reading pointers generated by `write`
125     @param _pointer to be read
126     @param _start number of bytes to skip
127     @return data read from `_pointer` contract
128   */
129   function read(address _pointer, uint256 _start) internal view returns (bytes memory) {
130     return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);
131   }
132 
133   /**
134     @notice Reads the contents of the `_pointer` code as data, skips the first byte 
135     @dev The function is intended for reading pointers generated by `write`
136     @param _pointer to be read
137     @param _start number of bytes to skip
138     @param _end index before which to end extraction
139     @return data read from `_pointer` contract
140   */
141   function read(address _pointer, uint256 _start, uint256 _end) internal view returns (bytes memory) {
142     return Bytecode.codeAt(_pointer, _start + 1, _end + 1);
143   }
144 }
145 
146 pragma solidity >=0.8.0 <0.9.0;
147 
148 
149 library BytesLib {
150     function concat(
151         bytes memory _preBytes,
152         bytes memory _postBytes
153     )
154         internal
155         pure
156         returns (bytes memory)
157     {
158         bytes memory tempBytes;
159 
160         assembly {
161             // Get a location of some free memory and store it in tempBytes as
162             // Solidity does for memory variables.
163             tempBytes := mload(0x40)
164 
165             // Store the length of the first bytes array at the beginning of
166             // the memory for tempBytes.
167             let length := mload(_preBytes)
168             mstore(tempBytes, length)
169 
170             // Maintain a memory counter for the current write location in the
171             // temp bytes array by adding the 32 bytes for the array length to
172             // the starting location.
173             let mc := add(tempBytes, 0x20)
174             // Stop copying when the memory counter reaches the length of the
175             // first bytes array.
176             let end := add(mc, length)
177 
178             for {
179                 // Initialize a copy counter to the start of the _preBytes data,
180                 // 32 bytes into its memory.
181                 let cc := add(_preBytes, 0x20)
182             } lt(mc, end) {
183                 // Increase both counters by 32 bytes each iteration.
184                 mc := add(mc, 0x20)
185                 cc := add(cc, 0x20)
186             } {
187                 // Write the _preBytes data into the tempBytes memory 32 bytes
188                 // at a time.
189                 mstore(mc, mload(cc))
190             }
191 
192             // Add the length of _postBytes to the current length of tempBytes
193             // and store it as the new length in the first 32 bytes of the
194             // tempBytes memory.
195             length := mload(_postBytes)
196             mstore(tempBytes, add(length, mload(tempBytes)))
197 
198             // Move the memory counter back from a multiple of 0x20 to the
199             // actual end of the _preBytes data.
200             mc := end
201             // Stop copying when the memory counter reaches the new combined
202             // length of the arrays.
203             end := add(mc, length)
204 
205             for {
206                 let cc := add(_postBytes, 0x20)
207             } lt(mc, end) {
208                 mc := add(mc, 0x20)
209                 cc := add(cc, 0x20)
210             } {
211                 mstore(mc, mload(cc))
212             }
213 
214             // Update the free-memory pointer by padding our last write location
215             // to 32 bytes: add 31 bytes to the end of tempBytes to move to the
216             // next 32 byte block, then round down to the nearest multiple of
217             // 32. If the sum of the length of the two arrays is zero then add
218             // one before rounding down to leave a blank 32 bytes (the length block with 0).
219             mstore(0x40, and(
220               add(add(end, iszero(add(length, mload(_preBytes)))), 31),
221               not(31) // Round down to the nearest 32 bytes.
222             ))
223         }
224 
225         return tempBytes;
226     }
227 
228     function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {
229         assembly {
230             // Read the first 32 bytes of _preBytes storage, which is the length
231             // of the array. (We don't need to use the offset into the slot
232             // because arrays use the entire slot.)
233             let fslot := sload(_preBytes.slot)
234             // Arrays of 31 bytes or less have an even value in their slot,
235             // while longer arrays have an odd value. The actual length is
236             // the slot divided by two for odd values, and the lowest order
237             // byte divided by two for even values.
238             // If the slot is even, bitwise and the slot with 255 and divide by
239             // two to get the length. If the slot is odd, bitwise and the slot
240             // with -1 and divide by two.
241             let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)
242             let mlength := mload(_postBytes)
243             let newlength := add(slength, mlength)
244             // slength can contain both the length and contents of the array
245             // if length < 32 bytes so let's prepare for that
246             // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage
247             switch add(lt(slength, 32), lt(newlength, 32))
248             case 2 {
249                 // Since the new array still fits in the slot, we just need to
250                 // update the contents of the slot.
251                 // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length
252                 sstore(
253                     _preBytes.slot,
254                     // all the modifications to the slot are inside this
255                     // next block
256                     add(
257                         // we can just add to the slot contents because the
258                         // bytes we want to change are the LSBs
259                         fslot,
260                         add(
261                             mul(
262                                 div(
263                                     // load the bytes from memory
264                                     mload(add(_postBytes, 0x20)),
265                                     // zero all bytes to the right
266                                     exp(0x100, sub(32, mlength))
267                                 ),
268                                 // and now shift left the number of bytes to
269                                 // leave space for the length in the slot
270                                 exp(0x100, sub(32, newlength))
271                             ),
272                             // increase length by the double of the memory
273                             // bytes length
274                             mul(mlength, 2)
275                         )
276                     )
277                 )
278             }
279             case 1 {
280                 // The stored value fits in the slot, but the combined value
281                 // will exceed it.
282                 // get the keccak hash to get the contents of the array
283                 mstore(0x0, _preBytes.slot)
284                 let sc := add(keccak256(0x0, 0x20), div(slength, 32))
285 
286                 // save new length
287                 sstore(_preBytes.slot, add(mul(newlength, 2), 1))
288 
289                 // The contents of the _postBytes array start 32 bytes into
290                 // the structure. Our first read should obtain the `submod`
291                 // bytes that can fit into the unused space in the last word
292                 // of the stored array. To get this, we read 32 bytes starting
293                 // from `submod`, so the data we read overlaps with the array
294                 // contents by `submod` bytes. Masking the lowest-order
295                 // `submod` bytes allows us to add that value directly to the
296                 // stored value.
297 
298                 let submod := sub(32, slength)
299                 let mc := add(_postBytes, submod)
300                 let end := add(_postBytes, mlength)
301                 let mask := sub(exp(0x100, submod), 1)
302 
303                 sstore(
304                     sc,
305                     add(
306                         and(
307                             fslot,
308                             0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00
309                         ),
310                         and(mload(mc), mask)
311                     )
312                 )
313 
314                 for {
315                     mc := add(mc, 0x20)
316                     sc := add(sc, 1)
317                 } lt(mc, end) {
318                     sc := add(sc, 1)
319                     mc := add(mc, 0x20)
320                 } {
321                     sstore(sc, mload(mc))
322                 }
323 
324                 mask := exp(0x100, sub(mc, end))
325 
326                 sstore(sc, mul(div(mload(mc), mask), mask))
327             }
328             default {
329                 // get the keccak hash to get the contents of the array
330                 mstore(0x0, _preBytes.slot)
331                 // Start copying to the last used word of the stored array.
332                 let sc := add(keccak256(0x0, 0x20), div(slength, 32))
333 
334                 // save new length
335                 sstore(_preBytes.slot, add(mul(newlength, 2), 1))
336 
337                 // Copy over the first `submod` bytes of the new data as in
338                 // case 1 above.
339                 let slengthmod := mod(slength, 32)
340                 let mlengthmod := mod(mlength, 32)
341                 let submod := sub(32, slengthmod)
342                 let mc := add(_postBytes, submod)
343                 let end := add(_postBytes, mlength)
344                 let mask := sub(exp(0x100, submod), 1)
345 
346                 sstore(sc, add(sload(sc), and(mload(mc), mask)))
347 
348                 for {
349                     sc := add(sc, 1)
350                     mc := add(mc, 0x20)
351                 } lt(mc, end) {
352                     sc := add(sc, 1)
353                     mc := add(mc, 0x20)
354                 } {
355                     sstore(sc, mload(mc))
356                 }
357 
358                 mask := exp(0x100, sub(mc, end))
359 
360                 sstore(sc, mul(div(mload(mc), mask), mask))
361             }
362         }
363     }
364 
365     function slice(
366         bytes memory _bytes,
367         uint256 _start,
368         uint256 _length
369     )
370         internal
371         pure
372         returns (bytes memory)
373     {
374         require(_length + 31 >= _length, "slice_overflow");
375         require(_bytes.length >= _start + _length, "slice_outOfBounds");
376 
377         bytes memory tempBytes;
378 
379         assembly {
380             switch iszero(_length)
381             case 0 {
382                 // Get a location of some free memory and store it in tempBytes as
383                 // Solidity does for memory variables.
384                 tempBytes := mload(0x40)
385 
386                 // The first word of the slice result is potentially a partial
387                 // word read from the original array. To read it, we calculate
388                 // the length of that partial word and start copying that many
389                 // bytes into the array. The first word we copy will start with
390                 // data we don't care about, but the last `lengthmod` bytes will
391                 // land at the beginning of the contents of the new array. When
392                 // we're done copying, we overwrite the full first word with
393                 // the actual length of the slice.
394                 let lengthmod := and(_length, 31)
395 
396                 // The multiplication in the next line is necessary
397                 // because when slicing multiples of 32 bytes (lengthmod == 0)
398                 // the following copy loop was copying the origin's length
399                 // and then ending prematurely not copying everything it should.
400                 let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))
401                 let end := add(mc, _length)
402 
403                 for {
404                     // The multiplication in the next line has the same exact purpose
405                     // as the one above.
406                     let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
407                 } lt(mc, end) {
408                     mc := add(mc, 0x20)
409                     cc := add(cc, 0x20)
410                 } {
411                     mstore(mc, mload(cc))
412                 }
413 
414                 mstore(tempBytes, _length)
415 
416                 //update free-memory pointer
417                 //allocating the array padded to 32 bytes like the compiler does now
418                 mstore(0x40, and(add(mc, 31), not(31)))
419             }
420             //if we want a zero-length slice let's just return a zero-length array
421             default {
422                 tempBytes := mload(0x40)
423                 //zero out the 32 bytes slice we are about to return
424                 //we need to do it because Solidity does not garbage collect
425                 mstore(tempBytes, 0)
426 
427                 mstore(0x40, add(tempBytes, 0x20))
428             }
429         }
430 
431         return tempBytes;
432     }
433 
434     function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {
435         require(_bytes.length >= _start + 20, "toAddress_outOfBounds");
436         address tempAddress;
437 
438         assembly {
439             tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)
440         }
441 
442         return tempAddress;
443     }
444 
445     function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {
446         require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");
447         uint8 tempUint;
448 
449         assembly {
450             tempUint := mload(add(add(_bytes, 0x1), _start))
451         }
452 
453         return tempUint;
454     }
455 
456     function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {
457         require(_bytes.length >= _start + 2, "toUint16_outOfBounds");
458         uint16 tempUint;
459 
460         assembly {
461             tempUint := mload(add(add(_bytes, 0x2), _start))
462         }
463 
464         return tempUint;
465     }
466 
467     function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {
468         require(_bytes.length >= _start + 4, "toUint32_outOfBounds");
469         uint32 tempUint;
470 
471         assembly {
472             tempUint := mload(add(add(_bytes, 0x4), _start))
473         }
474 
475         return tempUint;
476     }
477 
478     function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {
479         require(_bytes.length >= _start + 8, "toUint64_outOfBounds");
480         uint64 tempUint;
481 
482         assembly {
483             tempUint := mload(add(add(_bytes, 0x8), _start))
484         }
485 
486         return tempUint;
487     }
488 
489     function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {
490         require(_bytes.length >= _start + 12, "toUint96_outOfBounds");
491         uint96 tempUint;
492 
493         assembly {
494             tempUint := mload(add(add(_bytes, 0xc), _start))
495         }
496 
497         return tempUint;
498     }
499 
500     function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {
501         require(_bytes.length >= _start + 16, "toUint128_outOfBounds");
502         uint128 tempUint;
503 
504         assembly {
505             tempUint := mload(add(add(_bytes, 0x10), _start))
506         }
507 
508         return tempUint;
509     }
510 
511     function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {
512         require(_bytes.length >= _start + 32, "toUint256_outOfBounds");
513         uint256 tempUint;
514 
515         assembly {
516             tempUint := mload(add(add(_bytes, 0x20), _start))
517         }
518 
519         return tempUint;
520     }
521 
522     function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {
523         require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");
524         bytes32 tempBytes32;
525 
526         assembly {
527             tempBytes32 := mload(add(add(_bytes, 0x20), _start))
528         }
529 
530         return tempBytes32;
531     }
532 
533     function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {
534         bool success = true;
535 
536         assembly {
537             let length := mload(_preBytes)
538 
539             // if lengths don't match the arrays are not equal
540             switch eq(length, mload(_postBytes))
541             case 1 {
542                 // cb is a circuit breaker in the for loop since there's
543                 //  no said feature for inline assembly loops
544                 // cb = 1 - don't breaker
545                 // cb = 0 - break
546                 let cb := 1
547 
548                 let mc := add(_preBytes, 0x20)
549                 let end := add(mc, length)
550 
551                 for {
552                     let cc := add(_postBytes, 0x20)
553                 // the next line is the loop condition:
554                 // while(uint256(mc < end) + cb == 2)
555                 } eq(add(lt(mc, end), cb), 2) {
556                     mc := add(mc, 0x20)
557                     cc := add(cc, 0x20)
558                 } {
559                     // if any of these checks fails then arrays are not equal
560                     if iszero(eq(mload(mc), mload(cc))) {
561                         // unsuccess:
562                         success := 0
563                         cb := 0
564                     }
565                 }
566             }
567             default {
568                 // unsuccess:
569                 success := 0
570             }
571         }
572 
573         return success;
574     }
575 
576     function equalStorage(
577         bytes storage _preBytes,
578         bytes memory _postBytes
579     )
580         internal
581         view
582         returns (bool)
583     {
584         bool success = true;
585 
586         assembly {
587             // we know _preBytes_offset is 0
588             let fslot := sload(_preBytes.slot)
589             // Decode the length of the stored array like in concatStorage().
590             let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)
591             let mlength := mload(_postBytes)
592 
593             // if lengths don't match the arrays are not equal
594             switch eq(slength, mlength)
595             case 1 {
596                 // slength can contain both the length and contents of the array
597                 // if length < 32 bytes so let's prepare for that
598                 // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage
599                 if iszero(iszero(slength)) {
600                     switch lt(slength, 32)
601                     case 1 {
602                         // blank the last byte which is the length
603                         fslot := mul(div(fslot, 0x100), 0x100)
604 
605                         if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {
606                             // unsuccess:
607                             success := 0
608                         }
609                     }
610                     default {
611                         // cb is a circuit breaker in the for loop since there's
612                         //  no said feature for inline assembly loops
613                         // cb = 1 - don't breaker
614                         // cb = 0 - break
615                         let cb := 1
616 
617                         // get the keccak hash to get the contents of the array
618                         mstore(0x0, _preBytes.slot)
619                         let sc := keccak256(0x0, 0x20)
620 
621                         let mc := add(_postBytes, 0x20)
622                         let end := add(mc, mlength)
623 
624                         // the next line is the loop condition:
625                         // while(uint256(mc < end) + cb == 2)
626                         for {} eq(add(lt(mc, end), cb), 2) {
627                             sc := add(sc, 1)
628                             mc := add(mc, 0x20)
629                         } {
630                             if iszero(eq(sload(sc), mload(mc))) {
631                                 // unsuccess:
632                                 success := 0
633                                 cb := 0
634                             }
635                         }
636                     }
637                 }
638             }
639             default {
640                 // unsuccess:
641                 success := 0
642             }
643         }
644 
645         return success;
646     }
647 }
648 
649 
650 
651 /**
652  *Submitted for verification at Etherscan.io on 2023-02-17
653 */
654 
655 // File: @openzeppelin/contracts/utils/structs/EnumerableSet.sol
656 
657 
658 // OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)
659 // This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.
660 
661 pragma solidity ^0.8.0;
662 
663 /**
664  * @dev Library for managing
665  * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
666  * types.
667  *
668  * Sets have the following properties:
669  *
670  * - Elements are added, removed, and checked for existence in constant time
671  * (O(1)).
672  * - Elements are enumerated in O(n). No guarantees are made on the ordering.
673  *
674  * ```
675  * contract Example {
676  *     // Add the library methods
677  *     using EnumerableSet for EnumerableSet.AddressSet;
678  *
679  *     // Declare a set state variable
680  *     EnumerableSet.AddressSet private mySet;
681  * }
682  * ```
683  *
684  * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)
685  * and `uint256` (`UintSet`) are supported.
686  *
687  * [WARNING]
688  * ====
689  * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure
690  * unusable.
691  * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.
692  *
693  * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an
694  * array of EnumerableSet.
695  * ====
696  */
697 library EnumerableSet {
698     // To implement this library for multiple types with as little code
699     // repetition as possible, we write it in terms of a generic Set type with
700     // bytes32 values.
701     // The Set implementation uses private functions, and user-facing
702     // implementations (such as AddressSet) are just wrappers around the
703     // underlying Set.
704     // This means that we can only create new EnumerableSets for types that fit
705     // in bytes32.
706 
707     struct Set {
708         // Storage of set values
709         bytes32[] _values;
710         // Position of the value in the `values` array, plus 1 because index 0
711         // means a value is not in the set.
712         mapping(bytes32 => uint256) _indexes;
713     }
714 
715     /**
716      * @dev Add a value to a set. O(1).
717      *
718      * Returns true if the value was added to the set, that is if it was not
719      * already present.
720      */
721     function _add(Set storage set, bytes32 value) private returns (bool) {
722         if (!_contains(set, value)) {
723             set._values.push(value);
724             // The value is stored at length-1, but we add 1 to all indexes
725             // and use 0 as a sentinel value
726             set._indexes[value] = set._values.length;
727             return true;
728         } else {
729             return false;
730         }
731     }
732 
733     /**
734      * @dev Removes a value from a set. O(1).
735      *
736      * Returns true if the value was removed from the set, that is if it was
737      * present.
738      */
739     function _remove(Set storage set, bytes32 value) private returns (bool) {
740         // We read and store the value's index to prevent multiple reads from the same storage slot
741         uint256 valueIndex = set._indexes[value];
742 
743         if (valueIndex != 0) {
744             // Equivalent to contains(set, value)
745             // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
746             // the array, and then remove the last element (sometimes called as 'swap and pop').
747             // This modifies the order of the array, as noted in {at}.
748 
749             uint256 toDeleteIndex = valueIndex - 1;
750             uint256 lastIndex = set._values.length - 1;
751 
752             if (lastIndex != toDeleteIndex) {
753                 bytes32 lastValue = set._values[lastIndex];
754 
755                 // Move the last value to the index where the value to delete is
756                 set._values[toDeleteIndex] = lastValue;
757                 // Update the index for the moved value
758                 set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex
759             }
760 
761             // Delete the slot where the moved value was stored
762             set._values.pop();
763 
764             // Delete the index for the deleted slot
765             delete set._indexes[value];
766 
767             return true;
768         } else {
769             return false;
770         }
771     }
772 
773     /**
774      * @dev Returns true if the value is in the set. O(1).
775      */
776     function _contains(Set storage set, bytes32 value) private view returns (bool) {
777         return set._indexes[value] != 0;
778     }
779 
780     /**
781      * @dev Returns the number of values on the set. O(1).
782      */
783     function _length(Set storage set) private view returns (uint256) {
784         return set._values.length;
785     }
786 
787     /**
788      * @dev Returns the value stored at position `index` in the set. O(1).
789      *
790      * Note that there are no guarantees on the ordering of values inside the
791      * array, and it may change when more values are added or removed.
792      *
793      * Requirements:
794      *
795      * - `index` must be strictly less than {length}.
796      */
797     function _at(Set storage set, uint256 index) private view returns (bytes32) {
798         return set._values[index];
799     }
800 
801     /**
802      * @dev Return the entire set in an array
803      *
804      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
805      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
806      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
807      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
808      */
809     function _values(Set storage set) private view returns (bytes32[] memory) {
810         return set._values;
811     }
812 
813     // Bytes32Set
814 
815     struct Bytes32Set {
816         Set _inner;
817     }
818 
819     /**
820      * @dev Add a value to a set. O(1).
821      *
822      * Returns true if the value was added to the set, that is if it was not
823      * already present.
824      */
825     function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
826         return _add(set._inner, value);
827     }
828 
829     /**
830      * @dev Removes a value from a set. O(1).
831      *
832      * Returns true if the value was removed from the set, that is if it was
833      * present.
834      */
835     function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
836         return _remove(set._inner, value);
837     }
838 
839     /**
840      * @dev Returns true if the value is in the set. O(1).
841      */
842     function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
843         return _contains(set._inner, value);
844     }
845 
846     /**
847      * @dev Returns the number of values in the set. O(1).
848      */
849     function length(Bytes32Set storage set) internal view returns (uint256) {
850         return _length(set._inner);
851     }
852 
853     /**
854      * @dev Returns the value stored at position `index` in the set. O(1).
855      *
856      * Note that there are no guarantees on the ordering of values inside the
857      * array, and it may change when more values are added or removed.
858      *
859      * Requirements:
860      *
861      * - `index` must be strictly less than {length}.
862      */
863     function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
864         return _at(set._inner, index);
865     }
866 
867     /**
868      * @dev Return the entire set in an array
869      *
870      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
871      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
872      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
873      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
874      */
875     function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {
876         bytes32[] memory store = _values(set._inner);
877         bytes32[] memory result;
878 
879         /// @solidity memory-safe-assembly
880         assembly {
881             result := store
882         }
883 
884         return result;
885     }
886 
887     // AddressSet
888 
889     struct AddressSet {
890         Set _inner;
891     }
892 
893     /**
894      * @dev Add a value to a set. O(1).
895      *
896      * Returns true if the value was added to the set, that is if it was not
897      * already present.
898      */
899     function add(AddressSet storage set, address value) internal returns (bool) {
900         return _add(set._inner, bytes32(uint256(uint160(value))));
901     }
902 
903     /**
904      * @dev Removes a value from a set. O(1).
905      *
906      * Returns true if the value was removed from the set, that is if it was
907      * present.
908      */
909     function remove(AddressSet storage set, address value) internal returns (bool) {
910         return _remove(set._inner, bytes32(uint256(uint160(value))));
911     }
912 
913     /**
914      * @dev Returns true if the value is in the set. O(1).
915      */
916     function contains(AddressSet storage set, address value) internal view returns (bool) {
917         return _contains(set._inner, bytes32(uint256(uint160(value))));
918     }
919 
920     /**
921      * @dev Returns the number of values in the set. O(1).
922      */
923     function length(AddressSet storage set) internal view returns (uint256) {
924         return _length(set._inner);
925     }
926 
927     /**
928      * @dev Returns the value stored at position `index` in the set. O(1).
929      *
930      * Note that there are no guarantees on the ordering of values inside the
931      * array, and it may change when more values are added or removed.
932      *
933      * Requirements:
934      *
935      * - `index` must be strictly less than {length}.
936      */
937     function at(AddressSet storage set, uint256 index) internal view returns (address) {
938         return address(uint160(uint256(_at(set._inner, index))));
939     }
940 
941     /**
942      * @dev Return the entire set in an array
943      *
944      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
945      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
946      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
947      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
948      */
949     function values(AddressSet storage set) internal view returns (address[] memory) {
950         bytes32[] memory store = _values(set._inner);
951         address[] memory result;
952 
953         /// @solidity memory-safe-assembly
954         assembly {
955             result := store
956         }
957 
958         return result;
959     }
960 
961     // UintSet
962 
963     struct UintSet {
964         Set _inner;
965     }
966 
967     /**
968      * @dev Add a value to a set. O(1).
969      *
970      * Returns true if the value was added to the set, that is if it was not
971      * already present.
972      */
973     function add(UintSet storage set, uint256 value) internal returns (bool) {
974         return _add(set._inner, bytes32(value));
975     }
976 
977     /**
978      * @dev Removes a value from a set. O(1).
979      *
980      * Returns true if the value was removed from the set, that is if it was
981      * present.
982      */
983     function remove(UintSet storage set, uint256 value) internal returns (bool) {
984         return _remove(set._inner, bytes32(value));
985     }
986 
987     /**
988      * @dev Returns true if the value is in the set. O(1).
989      */
990     function contains(UintSet storage set, uint256 value) internal view returns (bool) {
991         return _contains(set._inner, bytes32(value));
992     }
993 
994     /**
995      * @dev Returns the number of values in the set. O(1).
996      */
997     function length(UintSet storage set) internal view returns (uint256) {
998         return _length(set._inner);
999     }
1000 
1001     /**
1002      * @dev Returns the value stored at position `index` in the set. O(1).
1003      *
1004      * Note that there are no guarantees on the ordering of values inside the
1005      * array, and it may change when more values are added or removed.
1006      *
1007      * Requirements:
1008      *
1009      * - `index` must be strictly less than {length}.
1010      */
1011     function at(UintSet storage set, uint256 index) internal view returns (uint256) {
1012         return uint256(_at(set._inner, index));
1013     }
1014 
1015     /**
1016      * @dev Return the entire set in an array
1017      *
1018      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
1019      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
1020      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
1021      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
1022      */
1023     function values(UintSet storage set) internal view returns (uint256[] memory) {
1024         bytes32[] memory store = _values(set._inner);
1025         uint256[] memory result;
1026 
1027         /// @solidity memory-safe-assembly
1028         assembly {
1029             result := store
1030         }
1031 
1032         return result;
1033     }
1034 }
1035 
1036 // File: @openzeppelin/contracts/utils/StorageSlot.sol
1037 
1038 
1039 // OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)
1040 
1041 pragma solidity ^0.8.0;
1042 
1043 /**
1044  * @dev Library for reading and writing primitive types to specific storage slots.
1045  *
1046  * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.
1047  * This library helps with reading and writing to such slots without the need for inline assembly.
1048  *
1049  * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.
1050  *
1051  * Example usage to set ERC1967 implementation slot:
1052  * ```
1053  * contract ERC1967 {
1054  *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
1055  *
1056  *     function _getImplementation() internal view returns (address) {
1057  *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
1058  *     }
1059  *
1060  *     function _setImplementation(address newImplementation) internal {
1061  *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");
1062  *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
1063  *     }
1064  * }
1065  * ```
1066  *
1067  * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._
1068  */
1069 library StorageSlot {
1070     struct AddressSlot {
1071         address value;
1072     }
1073 
1074     struct BooleanSlot {
1075         bool value;
1076     }
1077 
1078     struct Bytes32Slot {
1079         bytes32 value;
1080     }
1081 
1082     struct Uint256Slot {
1083         uint256 value;
1084     }
1085 
1086     /**
1087      * @dev Returns an `AddressSlot` with member `value` located at `slot`.
1088      */
1089     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
1090         /// @solidity memory-safe-assembly
1091         assembly {
1092             r.slot := slot
1093         }
1094     }
1095 
1096     /**
1097      * @dev Returns an `BooleanSlot` with member `value` located at `slot`.
1098      */
1099     function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {
1100         /// @solidity memory-safe-assembly
1101         assembly {
1102             r.slot := slot
1103         }
1104     }
1105 
1106     /**
1107      * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.
1108      */
1109     function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {
1110         /// @solidity memory-safe-assembly
1111         assembly {
1112             r.slot := slot
1113         }
1114     }
1115 
1116     /**
1117      * @dev Returns an `Uint256Slot` with member `value` located at `slot`.
1118      */
1119     function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
1120         /// @solidity memory-safe-assembly
1121         assembly {
1122             r.slot := slot
1123         }
1124     }
1125 }
1126 
1127 // File: @openzeppelin/contracts/utils/Address.sol
1128 
1129 
1130 // OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)
1131 
1132 pragma solidity ^0.8.1;
1133 
1134 /**
1135  * @dev Collection of functions related to the address type
1136  */
1137 library Address {
1138     /**
1139      * @dev Returns true if `account` is a contract.
1140      *
1141      * [IMPORTANT]
1142      * ====
1143      * It is unsafe to assume that an address for which this function returns
1144      * false is an externally-owned account (EOA) and not a contract.
1145      *
1146      * Among others, `isContract` will return false for the following
1147      * types of addresses:
1148      *
1149      *  - an externally-owned account
1150      *  - a contract in construction
1151      *  - an address where a contract will be created
1152      *  - an address where a contract lived, but was destroyed
1153      * ====
1154      *
1155      * [IMPORTANT]
1156      * ====
1157      * You shouldn't rely on `isContract` to protect against flash loan attacks!
1158      *
1159      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
1160      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
1161      * constructor.
1162      * ====
1163      */
1164     function isContract(address account) internal view returns (bool) {
1165         // This method relies on extcodesize/address.code.length, which returns 0
1166         // for contracts in construction, since the code is only stored at the end
1167         // of the constructor execution.
1168 
1169         return account.code.length > 0;
1170     }
1171 
1172     /**
1173      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
1174      * `recipient`, forwarding all available gas and reverting on errors.
1175      *
1176      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
1177      * of certain opcodes, possibly making contracts go over the 2300 gas limit
1178      * imposed by `transfer`, making them unable to receive funds via
1179      * `transfer`. {sendValue} removes this limitation.
1180      *
1181      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
1182      *
1183      * IMPORTANT: because control is transferred to `recipient`, care must be
1184      * taken to not create reentrancy vulnerabilities. Consider using
1185      * {ReentrancyGuard} or the
1186      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
1187      */
1188     function sendValue(address payable recipient, uint256 amount) internal {
1189         require(address(this).balance >= amount, "Address: insufficient balance");
1190 
1191         (bool success, ) = recipient.call{value: amount}("");
1192         require(success, "Address: unable to send value, recipient may have reverted");
1193     }
1194 
1195     /**
1196      * @dev Performs a Solidity function call using a low level `call`. A
1197      * plain `call` is an unsafe replacement for a function call: use this
1198      * function instead.
1199      *
1200      * If `target` reverts with a revert reason, it is bubbled up by this
1201      * function (like regular Solidity function calls).
1202      *
1203      * Returns the raw returned data. To convert to the expected return value,
1204      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
1205      *
1206      * Requirements:
1207      *
1208      * - `target` must be a contract.
1209      * - calling `target` with `data` must not revert.
1210      *
1211      * _Available since v3.1._
1212      */
1213     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1214         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
1215     }
1216 
1217     /**
1218      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
1219      * `errorMessage` as a fallback revert reason when `target` reverts.
1220      *
1221      * _Available since v3.1._
1222      */
1223     function functionCall(
1224         address target,
1225         bytes memory data,
1226         string memory errorMessage
1227     ) internal returns (bytes memory) {
1228         return functionCallWithValue(target, data, 0, errorMessage);
1229     }
1230 
1231     /**
1232      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
1233      * but also transferring `value` wei to `target`.
1234      *
1235      * Requirements:
1236      *
1237      * - the calling contract must have an ETH balance of at least `value`.
1238      * - the called Solidity function must be `payable`.
1239      *
1240      * _Available since v3.1._
1241      */
1242     function functionCallWithValue(
1243         address target,
1244         bytes memory data,
1245         uint256 value
1246     ) internal returns (bytes memory) {
1247         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1248     }
1249 
1250     /**
1251      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
1252      * with `errorMessage` as a fallback revert reason when `target` reverts.
1253      *
1254      * _Available since v3.1._
1255      */
1256     function functionCallWithValue(
1257         address target,
1258         bytes memory data,
1259         uint256 value,
1260         string memory errorMessage
1261     ) internal returns (bytes memory) {
1262         require(address(this).balance >= value, "Address: insufficient balance for call");
1263         (bool success, bytes memory returndata) = target.call{value: value}(data);
1264         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1265     }
1266 
1267     /**
1268      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
1269      * but performing a static call.
1270      *
1271      * _Available since v3.3._
1272      */
1273     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1274         return functionStaticCall(target, data, "Address: low-level static call failed");
1275     }
1276 
1277     /**
1278      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
1279      * but performing a static call.
1280      *
1281      * _Available since v3.3._
1282      */
1283     function functionStaticCall(
1284         address target,
1285         bytes memory data,
1286         string memory errorMessage
1287     ) internal view returns (bytes memory) {
1288         (bool success, bytes memory returndata) = target.staticcall(data);
1289         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1290     }
1291 
1292     /**
1293      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
1294      * but performing a delegate call.
1295      *
1296      * _Available since v3.4._
1297      */
1298     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
1299         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
1300     }
1301 
1302     /**
1303      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
1304      * but performing a delegate call.
1305      *
1306      * _Available since v3.4._
1307      */
1308     function functionDelegateCall(
1309         address target,
1310         bytes memory data,
1311         string memory errorMessage
1312     ) internal returns (bytes memory) {
1313         (bool success, bytes memory returndata) = target.delegatecall(data);
1314         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1315     }
1316 
1317     /**
1318      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
1319      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
1320      *
1321      * _Available since v4.8._
1322      */
1323     function verifyCallResultFromTarget(
1324         address target,
1325         bool success,
1326         bytes memory returndata,
1327         string memory errorMessage
1328     ) internal view returns (bytes memory) {
1329         if (success) {
1330             if (returndata.length == 0) {
1331                 // only check isContract if the call was successful and the return data is empty
1332                 // otherwise we already know that it was a contract
1333                 require(isContract(target), "Address: call to non-contract");
1334             }
1335             return returndata;
1336         } else {
1337             _revert(returndata, errorMessage);
1338         }
1339     }
1340 
1341     /**
1342      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
1343      * revert reason or using the provided one.
1344      *
1345      * _Available since v4.3._
1346      */
1347     function verifyCallResult(
1348         bool success,
1349         bytes memory returndata,
1350         string memory errorMessage
1351     ) internal pure returns (bytes memory) {
1352         if (success) {
1353             return returndata;
1354         } else {
1355             _revert(returndata, errorMessage);
1356         }
1357     }
1358 
1359     function _revert(bytes memory returndata, string memory errorMessage) private pure {
1360         // Look for revert reason and bubble it up if present
1361         if (returndata.length > 0) {
1362             // The easiest way to bubble the revert reason is using memory via assembly
1363             /// @solidity memory-safe-assembly
1364             assembly {
1365                 let returndata_size := mload(returndata)
1366                 revert(add(32, returndata), returndata_size)
1367             }
1368         } else {
1369             revert(errorMessage);
1370         }
1371     }
1372 }
1373 
1374 // File: @openzeppelin/contracts/utils/math/Math.sol
1375 
1376 
1377 // OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)
1378 
1379 pragma solidity ^0.8.0;
1380 
1381 /**
1382  * @dev Standard math utilities missing in the Solidity language.
1383  */
1384 library Math {
1385     enum Rounding {
1386         Down, // Toward negative infinity
1387         Up, // Toward infinity
1388         Zero // Toward zero
1389     }
1390 
1391     /**
1392      * @dev Returns the largest of two numbers.
1393      */
1394     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1395         return a > b ? a : b;
1396     }
1397 
1398     /**
1399      * @dev Returns the smallest of two numbers.
1400      */
1401     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1402         return a < b ? a : b;
1403     }
1404 
1405     /**
1406      * @dev Returns the average of two numbers. The result is rounded towards
1407      * zero.
1408      */
1409     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1410         // (a + b) / 2 can overflow.
1411         return (a & b) + (a ^ b) / 2;
1412     }
1413 
1414     /**
1415      * @dev Returns the ceiling of the division of two numbers.
1416      *
1417      * This differs from standard division with `/` in that it rounds up instead
1418      * of rounding down.
1419      */
1420     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1421         // (a + b - 1) / b can overflow on addition, so we distribute.
1422         return a == 0 ? 0 : (a - 1) / b + 1;
1423     }
1424 
1425     /**
1426      * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
1427      * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
1428      * with further edits by Uniswap Labs also under MIT license.
1429      */
1430     function mulDiv(
1431         uint256 x,
1432         uint256 y,
1433         uint256 denominator
1434     ) internal pure returns (uint256 result) {
1435         unchecked {
1436             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1437             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1438             // variables such that product = prod1 * 2^256 + prod0.
1439             uint256 prod0; // Least significant 256 bits of the product
1440             uint256 prod1; // Most significant 256 bits of the product
1441             assembly {
1442                 let mm := mulmod(x, y, not(0))
1443                 prod0 := mul(x, y)
1444                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1445             }
1446 
1447             // Handle non-overflow cases, 256 by 256 division.
1448             if (prod1 == 0) {
1449                 return prod0 / denominator;
1450             }
1451 
1452             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1453             require(denominator > prod1);
1454 
1455             ///////////////////////////////////////////////
1456             // 512 by 256 division.
1457             ///////////////////////////////////////////////
1458 
1459             // Make division exact by subtracting the remainder from [prod1 prod0].
1460             uint256 remainder;
1461             assembly {
1462                 // Compute remainder using mulmod.
1463                 remainder := mulmod(x, y, denominator)
1464 
1465                 // Subtract 256 bit number from 512 bit number.
1466                 prod1 := sub(prod1, gt(remainder, prod0))
1467                 prod0 := sub(prod0, remainder)
1468             }
1469 
1470             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1471             // See https://cs.stackexchange.com/q/138556/92363.
1472 
1473             // Does not overflow because the denominator cannot be zero at this stage in the function.
1474             uint256 twos = denominator & (~denominator + 1);
1475             assembly {
1476                 // Divide denominator by twos.
1477                 denominator := div(denominator, twos)
1478 
1479                 // Divide [prod1 prod0] by twos.
1480                 prod0 := div(prod0, twos)
1481 
1482                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1483                 twos := add(div(sub(0, twos), twos), 1)
1484             }
1485 
1486             // Shift in bits from prod1 into prod0.
1487             prod0 |= prod1 * twos;
1488 
1489             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1490             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1491             // four bits. That is, denominator * inv = 1 mod 2^4.
1492             uint256 inverse = (3 * denominator) ^ 2;
1493 
1494             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1495             // in modular arithmetic, doubling the correct bits in each step.
1496             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1497             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1498             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1499             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1500             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1501             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1502 
1503             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1504             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1505             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1506             // is no longer required.
1507             result = prod0 * inverse;
1508             return result;
1509         }
1510     }
1511 
1512     /**
1513      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
1514      */
1515     function mulDiv(
1516         uint256 x,
1517         uint256 y,
1518         uint256 denominator,
1519         Rounding rounding
1520     ) internal pure returns (uint256) {
1521         uint256 result = mulDiv(x, y, denominator);
1522         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1523             result += 1;
1524         }
1525         return result;
1526     }
1527 
1528     /**
1529      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
1530      *
1531      * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
1532      */
1533     function sqrt(uint256 a) internal pure returns (uint256) {
1534         if (a == 0) {
1535             return 0;
1536         }
1537 
1538         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1539         //
1540         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1541         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1542         //
1543         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1544         //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1545         //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1546         //
1547         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1548         uint256 result = 1 << (log2(a) >> 1);
1549 
1550         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1551         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1552         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1553         // into the expected uint128 result.
1554         unchecked {
1555             result = (result + a / result) >> 1;
1556             result = (result + a / result) >> 1;
1557             result = (result + a / result) >> 1;
1558             result = (result + a / result) >> 1;
1559             result = (result + a / result) >> 1;
1560             result = (result + a / result) >> 1;
1561             result = (result + a / result) >> 1;
1562             return min(result, a / result);
1563         }
1564     }
1565 
1566     /**
1567      * @notice Calculates sqrt(a), following the selected rounding direction.
1568      */
1569     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1570         unchecked {
1571             uint256 result = sqrt(a);
1572             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1573         }
1574     }
1575 
1576     /**
1577      * @dev Return the log in base 2, rounded down, of a positive value.
1578      * Returns 0 if given 0.
1579      */
1580     function log2(uint256 value) internal pure returns (uint256) {
1581         uint256 result = 0;
1582         unchecked {
1583             if (value >> 128 > 0) {
1584                 value >>= 128;
1585                 result += 128;
1586             }
1587             if (value >> 64 > 0) {
1588                 value >>= 64;
1589                 result += 64;
1590             }
1591             if (value >> 32 > 0) {
1592                 value >>= 32;
1593                 result += 32;
1594             }
1595             if (value >> 16 > 0) {
1596                 value >>= 16;
1597                 result += 16;
1598             }
1599             if (value >> 8 > 0) {
1600                 value >>= 8;
1601                 result += 8;
1602             }
1603             if (value >> 4 > 0) {
1604                 value >>= 4;
1605                 result += 4;
1606             }
1607             if (value >> 2 > 0) {
1608                 value >>= 2;
1609                 result += 2;
1610             }
1611             if (value >> 1 > 0) {
1612                 result += 1;
1613             }
1614         }
1615         return result;
1616     }
1617 
1618     /**
1619      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
1620      * Returns 0 if given 0.
1621      */
1622     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1623         unchecked {
1624             uint256 result = log2(value);
1625             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1626         }
1627     }
1628 
1629     /**
1630      * @dev Return the log in base 10, rounded down, of a positive value.
1631      * Returns 0 if given 0.
1632      */
1633     function log10(uint256 value) internal pure returns (uint256) {
1634         uint256 result = 0;
1635         unchecked {
1636             if (value >= 10**64) {
1637                 value /= 10**64;
1638                 result += 64;
1639             }
1640             if (value >= 10**32) {
1641                 value /= 10**32;
1642                 result += 32;
1643             }
1644             if (value >= 10**16) {
1645                 value /= 10**16;
1646                 result += 16;
1647             }
1648             if (value >= 10**8) {
1649                 value /= 10**8;
1650                 result += 8;
1651             }
1652             if (value >= 10**4) {
1653                 value /= 10**4;
1654                 result += 4;
1655             }
1656             if (value >= 10**2) {
1657                 value /= 10**2;
1658                 result += 2;
1659             }
1660             if (value >= 10**1) {
1661                 result += 1;
1662             }
1663         }
1664         return result;
1665     }
1666 
1667     /**
1668      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
1669      * Returns 0 if given 0.
1670      */
1671     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1672         unchecked {
1673             uint256 result = log10(value);
1674             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1675         }
1676     }
1677 
1678     /**
1679      * @dev Return the log in base 256, rounded down, of a positive value.
1680      * Returns 0 if given 0.
1681      *
1682      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
1683      */
1684     function log256(uint256 value) internal pure returns (uint256) {
1685         uint256 result = 0;
1686         unchecked {
1687             if (value >> 128 > 0) {
1688                 value >>= 128;
1689                 result += 16;
1690             }
1691             if (value >> 64 > 0) {
1692                 value >>= 64;
1693                 result += 8;
1694             }
1695             if (value >> 32 > 0) {
1696                 value >>= 32;
1697                 result += 4;
1698             }
1699             if (value >> 16 > 0) {
1700                 value >>= 16;
1701                 result += 2;
1702             }
1703             if (value >> 8 > 0) {
1704                 result += 1;
1705             }
1706         }
1707         return result;
1708     }
1709 
1710     /**
1711      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
1712      * Returns 0 if given 0.
1713      */
1714     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1715         unchecked {
1716             uint256 result = log256(value);
1717             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1718         }
1719     }
1720 }
1721 
1722 // File: @openzeppelin/contracts/utils/Strings.sol
1723 
1724 
1725 // OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)
1726 
1727 pragma solidity ^0.8.0;
1728 
1729 
1730 /**
1731  * @dev String operations.
1732  */
1733 library Strings {
1734     bytes16 private constant _SYMBOLS = "0123456789abcdef";
1735     uint8 private constant _ADDRESS_LENGTH = 20;
1736 
1737     /**
1738      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
1739      */
1740     function toString(uint256 value) internal pure returns (string memory) {
1741         unchecked {
1742             uint256 length = Math.log10(value) + 1;
1743             string memory buffer = new string(length);
1744             uint256 ptr;
1745             /// @solidity memory-safe-assembly
1746             assembly {
1747                 ptr := add(buffer, add(32, length))
1748             }
1749             while (true) {
1750                 ptr--;
1751                 /// @solidity memory-safe-assembly
1752                 assembly {
1753                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1754                 }
1755                 value /= 10;
1756                 if (value == 0) break;
1757             }
1758             return buffer;
1759         }
1760     }
1761 
1762     /**
1763      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
1764      */
1765     function toHexString(uint256 value) internal pure returns (string memory) {
1766         unchecked {
1767             return toHexString(value, Math.log256(value) + 1);
1768         }
1769     }
1770 
1771     /**
1772      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
1773      */
1774     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
1775         bytes memory buffer = new bytes(2 * length + 2);
1776         buffer[0] = "0";
1777         buffer[1] = "x";
1778         for (uint256 i = 2 * length + 1; i > 1; --i) {
1779             buffer[i] = _SYMBOLS[value & 0xf];
1780             value >>= 4;
1781         }
1782         require(value == 0, "Strings: hex length insufficient");
1783         return string(buffer);
1784     }
1785 
1786     /**
1787      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
1788      */
1789     function toHexString(address addr) internal pure returns (string memory) {
1790         return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
1791     }
1792 }
1793 
1794 // File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
1795 
1796 
1797 // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)
1798 
1799 pragma solidity ^0.8.0;
1800 
1801 /**
1802  * @title ERC721 token receiver interface
1803  * @dev Interface for any contract that wants to support safeTransfers
1804  * from ERC721 asset contracts.
1805  */
1806 interface IERC721Receiver {
1807     /**
1808      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
1809      * by `operator` from `from`, this function is called.
1810      *
1811      * It must return its Solidity selector to confirm the token transfer.
1812      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
1813      *
1814      * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
1815      */
1816     function onERC721Received(
1817         address operator,
1818         address from,
1819         uint256 tokenId,
1820         bytes calldata data
1821     ) external returns (bytes4);
1822 }
1823 
1824 // File: solidity-bits/contracts/Popcount.sol
1825 
1826 
1827 /**
1828    _____       ___     ___ __           ____  _ __      
1829   / ___/____  / (_)___/ (_) /___  __   / __ )(_) /______
1830   \__ \/ __ \/ / / __  / / __/ / / /  / __  / / __/ ___/
1831  ___/ / /_/ / / / /_/ / / /_/ /_/ /  / /_/ / / /_(__  ) 
1832 /____/\____/_/_/\__,_/_/\__/\__, /  /_____/_/\__/____/  
1833                            /____/                        
1834 
1835 - npm: https://www.npmjs.com/package/solidity-bits
1836 - github: https://github.com/estarriolvetch/solidity-bits
1837 
1838  */
1839 
1840 pragma solidity ^0.8.0;
1841 
1842 library Popcount {
1843     uint256 private constant m1 = 0x5555555555555555555555555555555555555555555555555555555555555555;
1844     uint256 private constant m2 = 0x3333333333333333333333333333333333333333333333333333333333333333;
1845     uint256 private constant m4 = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;
1846     uint256 private constant h01 = 0x0101010101010101010101010101010101010101010101010101010101010101;
1847 
1848     function popcount256A(uint256 x) internal pure returns (uint256 count) {
1849         unchecked{
1850             for (count=0; x!=0; count++)
1851                 x &= x - 1;
1852         }
1853     }
1854 
1855     function popcount256B(uint256 x) internal pure returns (uint256) {
1856         if (x == type(uint256).max) {
1857             return 256;
1858         }
1859         unchecked {
1860             x -= (x >> 1) & m1;             //put count of each 2 bits into those 2 bits
1861             x = (x & m2) + ((x >> 2) & m2); //put count of each 4 bits into those 4 bits 
1862             x = (x + (x >> 4)) & m4;        //put count of each 8 bits into those 8 bits 
1863             x = (x * h01) >> 248;  //returns left 8 bits of x + (x<<8) + (x<<16) + (x<<24) + ... 
1864         }
1865         return x;
1866     }
1867 }
1868 // File: solidity-bits/contracts/BitScan.sol
1869 
1870 
1871 /**
1872    _____       ___     ___ __           ____  _ __      
1873   / ___/____  / (_)___/ (_) /___  __   / __ )(_) /______
1874   \__ \/ __ \/ / / __  / / __/ / / /  / __  / / __/ ___/
1875  ___/ / /_/ / / / /_/ / / /_/ /_/ /  / /_/ / / /_(__  ) 
1876 /____/\____/_/_/\__,_/_/\__/\__, /  /_____/_/\__/____/  
1877                            /____/                        
1878 
1879 - npm: https://www.npmjs.com/package/solidity-bits
1880 - github: https://github.com/estarriolvetch/solidity-bits
1881 
1882  */
1883 
1884 pragma solidity ^0.8.0;
1885 
1886 
1887 library BitScan {
1888     uint256 constant private DEBRUIJN_256 = 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff;
1889     bytes constant private LOOKUP_TABLE_256 = hex"0001020903110a19042112290b311a3905412245134d2a550c5d32651b6d3a7506264262237d468514804e8d2b95569d0d495ea533a966b11c886eb93bc176c9071727374353637324837e9b47af86c7155181ad4fd18ed32c9096db57d59ee30e2e4a6a5f92a6be3498aae067ddb2eb1d5989b56fd7baf33ca0c2ee77e5caf7ff0810182028303840444c545c646c7425617c847f8c949c48a4a8b087b8c0c816365272829aaec650acd0d28fdad4e22d6991bd97dfdcea58b4d6f29fede4f6fe0f1f2f3f4b5b6b607b8b93a3a7b7bf357199c5abcfd9e168bcdee9b3f1ecf5fd1e3e5a7a8aa2b670c4ced8bbe8f0f4fc3d79a1c3cde7effb78cce6facbf9f8";
1890 
1891     /**
1892         @dev Isolate the least significant set bit.
1893      */ 
1894     function isolateLS1B256(uint256 bb) pure internal returns (uint256) {
1895         require(bb > 0);
1896         unchecked {
1897             return bb & (0 - bb);
1898         }
1899     } 
1900 
1901     /**
1902         @dev Isolate the most significant set bit.
1903      */ 
1904     function isolateMS1B256(uint256 bb) pure internal returns (uint256) {
1905         require(bb > 0);
1906         unchecked {
1907             bb |= bb >> 128;
1908             bb |= bb >> 64;
1909             bb |= bb >> 32;
1910             bb |= bb >> 16;
1911             bb |= bb >> 8;
1912             bb |= bb >> 4;
1913             bb |= bb >> 2;
1914             bb |= bb >> 1;
1915             
1916             return (bb >> 1) + 1;
1917         }
1918     } 
1919 
1920     /**
1921         @dev Find the index of the lest significant set bit. (trailing zero count)
1922      */ 
1923     function bitScanForward256(uint256 bb) pure internal returns (uint8) {
1924         unchecked {
1925             return uint8(LOOKUP_TABLE_256[(isolateLS1B256(bb) * DEBRUIJN_256) >> 248]);
1926         }   
1927     }
1928 
1929     /**
1930         @dev Find the index of the most significant set bit.
1931      */ 
1932     function bitScanReverse256(uint256 bb) pure internal returns (uint8) {
1933         unchecked {
1934             return 255 - uint8(LOOKUP_TABLE_256[((isolateMS1B256(bb) * DEBRUIJN_256) >> 248)]);
1935         }   
1936     }
1937 
1938     function log2(uint256 bb) pure internal returns (uint8) {
1939         unchecked {
1940             return uint8(LOOKUP_TABLE_256[(isolateMS1B256(bb) * DEBRUIJN_256) >> 248]);
1941         } 
1942     }
1943 }
1944 
1945 // File: solidity-bits/contracts/BitMaps.sol
1946 
1947 
1948 /**
1949    _____       ___     ___ __           ____  _ __      
1950   / ___/____  / (_)___/ (_) /___  __   / __ )(_) /______
1951   \__ \/ __ \/ / / __  / / __/ / / /  / __  / / __/ ___/
1952  ___/ / /_/ / / / /_/ / / /_/ /_/ /  / /_/ / / /_(__  ) 
1953 /____/\____/_/_/\__,_/_/\__/\__, /  /_____/_/\__/____/  
1954                            /____/                        
1955 
1956 - npm: https://www.npmjs.com/package/solidity-bits
1957 - github: https://github.com/estarriolvetch/solidity-bits
1958 
1959  */
1960 pragma solidity ^0.8.0;
1961 
1962 
1963 
1964 /**
1965  * @dev This Library is a modified version of Openzeppelin's BitMaps library with extra features.
1966  *
1967  * 1. Functions of finding the index of the closest set bit from a given index are added.
1968  *    The indexing of each bucket is modifed to count from the MSB to the LSB instead of from the LSB to the MSB.
1969  *    The modification of indexing makes finding the closest previous set bit more efficient in gas usage.
1970  * 2. Setting and unsetting the bitmap consecutively.
1971  * 3. Accounting number of set bits within a given range.   
1972  *
1973 */
1974 
1975 /**
1976  * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.
1977  * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].
1978  */
1979 
1980 library BitMaps {
1981     using BitScan for uint256;
1982     uint256 private constant MASK_INDEX_ZERO = (1 << 255);
1983     uint256 private constant MASK_FULL = type(uint256).max;
1984 
1985     struct BitMap {
1986         mapping(uint256 => uint256) _data;
1987     }
1988 
1989     /**
1990      * @dev Returns whether the bit at `index` is set.
1991      */
1992     function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {
1993         uint256 bucket = index >> 8;
1994         uint256 mask = MASK_INDEX_ZERO >> (index & 0xff);
1995         return bitmap._data[bucket] & mask != 0;
1996     }
1997 
1998     /**
1999      * @dev Sets the bit at `index` to the boolean `value`.
2000      */
2001     function setTo(
2002         BitMap storage bitmap,
2003         uint256 index,
2004         bool value
2005     ) internal {
2006         if (value) {
2007             set(bitmap, index);
2008         } else {
2009             unset(bitmap, index);
2010         }
2011     }
2012 
2013     /**
2014      * @dev Sets the bit at `index`.
2015      */
2016     function set(BitMap storage bitmap, uint256 index) internal {
2017         uint256 bucket = index >> 8;
2018         uint256 mask = MASK_INDEX_ZERO >> (index & 0xff);
2019         bitmap._data[bucket] |= mask;
2020     }
2021 
2022     /**
2023      * @dev Unsets the bit at `index`.
2024      */
2025     function unset(BitMap storage bitmap, uint256 index) internal {
2026         uint256 bucket = index >> 8;
2027         uint256 mask = MASK_INDEX_ZERO >> (index & 0xff);
2028         bitmap._data[bucket] &= ~mask;
2029     }
2030 
2031 
2032     /**
2033      * @dev Consecutively sets `amount` of bits starting from the bit at `startIndex`.
2034      */    
2035     function setBatch(BitMap storage bitmap, uint256 startIndex, uint256 amount) internal {
2036         uint256 bucket = startIndex >> 8;
2037 
2038         uint256 bucketStartIndex = (startIndex & 0xff);
2039 
2040         unchecked {
2041             if(bucketStartIndex + amount < 256) {
2042                 bitmap._data[bucket] |= MASK_FULL << (256 - amount) >> bucketStartIndex;
2043             } else {
2044                 bitmap._data[bucket] |= MASK_FULL >> bucketStartIndex;
2045                 amount -= (256 - bucketStartIndex);
2046                 bucket++;
2047 
2048                 while(amount > 256) {
2049                     bitmap._data[bucket] = MASK_FULL;
2050                     amount -= 256;
2051                     bucket++;
2052                 }
2053 
2054                 bitmap._data[bucket] |= MASK_FULL << (256 - amount);
2055             }
2056         }
2057     }
2058 
2059 
2060     /**
2061      * @dev Consecutively unsets `amount` of bits starting from the bit at `startIndex`.
2062      */    
2063     function unsetBatch(BitMap storage bitmap, uint256 startIndex, uint256 amount) internal {
2064         uint256 bucket = startIndex >> 8;
2065 
2066         uint256 bucketStartIndex = (startIndex & 0xff);
2067 
2068         unchecked {
2069             if(bucketStartIndex + amount < 256) {
2070                 bitmap._data[bucket] &= ~(MASK_FULL << (256 - amount) >> bucketStartIndex);
2071             } else {
2072                 bitmap._data[bucket] &= ~(MASK_FULL >> bucketStartIndex);
2073                 amount -= (256 - bucketStartIndex);
2074                 bucket++;
2075 
2076                 while(amount > 256) {
2077                     bitmap._data[bucket] = 0;
2078                     amount -= 256;
2079                     bucket++;
2080                 }
2081 
2082                 bitmap._data[bucket] &= ~(MASK_FULL << (256 - amount));
2083             }
2084         }
2085     }
2086 
2087     /**
2088      * @dev Returns number of set bits within a range.
2089      */
2090     function popcountA(BitMap storage bitmap, uint256 startIndex, uint256 amount) internal view returns(uint256 count) {
2091         uint256 bucket = startIndex >> 8;
2092 
2093         uint256 bucketStartIndex = (startIndex & 0xff);
2094 
2095         unchecked {
2096             if(bucketStartIndex + amount < 256) {
2097                 count +=  Popcount.popcount256A(
2098                     bitmap._data[bucket] & (MASK_FULL << (256 - amount) >> bucketStartIndex)
2099                 );
2100             } else {
2101                 count += Popcount.popcount256A(
2102                     bitmap._data[bucket] & (MASK_FULL >> bucketStartIndex)
2103                 );
2104                 amount -= (256 - bucketStartIndex);
2105                 bucket++;
2106 
2107                 while(amount > 256) {
2108                     count += Popcount.popcount256A(bitmap._data[bucket]);
2109                     amount -= 256;
2110                     bucket++;
2111                 }
2112                 count += Popcount.popcount256A(
2113                     bitmap._data[bucket] & (MASK_FULL << (256 - amount))
2114                 );
2115             }
2116         }
2117     }
2118 
2119     /**
2120      * @dev Returns number of set bits within a range.
2121      */
2122     function popcountB(BitMap storage bitmap, uint256 startIndex, uint256 amount) internal view returns(uint256 count) {
2123         uint256 bucket = startIndex >> 8;
2124 
2125         uint256 bucketStartIndex = (startIndex & 0xff);
2126 
2127         unchecked {
2128             if(bucketStartIndex + amount < 256) {
2129                 count +=  Popcount.popcount256B(
2130                     bitmap._data[bucket] & (MASK_FULL << (256 - amount) >> bucketStartIndex)
2131                 );
2132             } else {
2133                 count += Popcount.popcount256B(
2134                     bitmap._data[bucket] & (MASK_FULL >> bucketStartIndex)
2135                 );
2136                 amount -= (256 - bucketStartIndex);
2137                 bucket++;
2138 
2139                 while(amount > 256) {
2140                     count += Popcount.popcount256B(bitmap._data[bucket]);
2141                     amount -= 256;
2142                     bucket++;
2143                 }
2144                 count += Popcount.popcount256B(
2145                     bitmap._data[bucket] & (MASK_FULL << (256 - amount))
2146                 );
2147             }
2148         }
2149     }
2150 
2151 
2152     /**
2153      * @dev Find the closest index of the set bit before `index`.
2154      */
2155     function scanForward(BitMap storage bitmap, uint256 index) internal view returns (uint256 setBitIndex) {
2156         uint256 bucket = index >> 8;
2157 
2158         // index within the bucket
2159         uint256 bucketIndex = (index & 0xff);
2160 
2161         // load a bitboard from the bitmap.
2162         uint256 bb = bitmap._data[bucket];
2163 
2164         // offset the bitboard to scan from `bucketIndex`.
2165         bb = bb >> (0xff ^ bucketIndex); // bb >> (255 - bucketIndex)
2166         
2167         if(bb > 0) {
2168             unchecked {
2169                 setBitIndex = (bucket << 8) | (bucketIndex -  bb.bitScanForward256());    
2170             }
2171         } else {
2172             while(true) {
2173                 require(bucket > 0, "BitMaps: The set bit before the index doesn't exist.");
2174                 unchecked {
2175                     bucket--;
2176                 }
2177                 // No offset. Always scan from the least significiant bit now.
2178                 bb = bitmap._data[bucket];
2179                 
2180                 if(bb > 0) {
2181                     unchecked {
2182                         setBitIndex = (bucket << 8) | (255 -  bb.bitScanForward256());
2183                         break;
2184                     }
2185                 } 
2186             }
2187         }
2188     }
2189 
2190     function getBucket(BitMap storage bitmap, uint256 bucket) internal view returns (uint256) {
2191         return bitmap._data[bucket];
2192     }
2193 }
2194 
2195 // File: @openzeppelin/contracts/security/ReentrancyGuard.sol
2196 
2197 
2198 // OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)
2199 
2200 pragma solidity ^0.8.0;
2201 
2202 /**
2203  * @dev Contract module that helps prevent reentrant calls to a function.
2204  *
2205  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
2206  * available, which can be applied to functions to make sure there are no nested
2207  * (reentrant) calls to them.
2208  *
2209  * Note that because there is a single `nonReentrant` guard, functions marked as
2210  * `nonReentrant` may not call one another. This can be worked around by making
2211  * those functions `private`, and then adding `external` `nonReentrant` entry
2212  * points to them.
2213  *
2214  * TIP: If you would like to learn more about reentrancy and alternative ways
2215  * to protect against it, check out our blog post
2216  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
2217  */
2218 abstract contract ReentrancyGuard {
2219     // Booleans are more expensive than uint256 or any type that takes up a full
2220     // word because each write operation emits an extra SLOAD to first read the
2221     // slot's contents, replace the bits taken up by the boolean, and then write
2222     // back. This is the compiler's defense against contract upgrades and
2223     // pointer aliasing, and it cannot be disabled.
2224 
2225     // The values being non-zero value makes deployment a bit more expensive,
2226     // but in exchange the refund on every call to nonReentrant will be lower in
2227     // amount. Since refunds are capped to a percentage of the total
2228     // transaction's gas, it is best to keep them low in cases like this one, to
2229     // increase the likelihood of the full refund coming into effect.
2230     uint256 private constant _NOT_ENTERED = 1;
2231     uint256 private constant _ENTERED = 2;
2232 
2233     uint256 private _status;
2234 
2235     constructor() {
2236         _status = _NOT_ENTERED;
2237     }
2238 
2239     /**
2240      * @dev Prevents a contract from calling itself, directly or indirectly.
2241      * Calling a `nonReentrant` function from another `nonReentrant`
2242      * function is not supported. It is possible to prevent this from happening
2243      * by making the `nonReentrant` function external, and making it call a
2244      * `private` function that does the actual work.
2245      */
2246     modifier nonReentrant() {
2247         _nonReentrantBefore();
2248         _;
2249         _nonReentrantAfter();
2250     }
2251 
2252     function _nonReentrantBefore() private {
2253         // On the first call to nonReentrant, _status will be _NOT_ENTERED
2254         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
2255 
2256         // Any calls to nonReentrant after this point will fail
2257         _status = _ENTERED;
2258     }
2259 
2260     function _nonReentrantAfter() private {
2261         // By storing the original value once again, a refund is triggered (see
2262         // https://eips.ethereum.org/EIPS/eip-2200)
2263         _status = _NOT_ENTERED;
2264     }
2265 }
2266 
2267 // File: @openzeppelin/contracts/utils/introspection/IERC165.sol
2268 
2269 
2270 // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
2271 
2272 pragma solidity ^0.8.0;
2273 
2274 /**
2275  * @dev Interface of the ERC165 standard, as defined in the
2276  * https://eips.ethereum.org/EIPS/eip-165[EIP].
2277  *
2278  * Implementers can declare support of contract interfaces, which can then be
2279  * queried by others ({ERC165Checker}).
2280  *
2281  * For an implementation, see {ERC165}.
2282  */
2283 interface IERC165 {
2284     /**
2285      * @dev Returns true if this contract implements the interface defined by
2286      * `interfaceId`. See the corresponding
2287      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
2288      * to learn more about how these ids are created.
2289      *
2290      * This function call must use less than 30 000 gas.
2291      */
2292     function supportsInterface(bytes4 interfaceId) external view returns (bool);
2293 }
2294 
2295 // File: @openzeppelin/contracts/token/ERC721/IERC721.sol
2296 
2297 
2298 // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)
2299 
2300 pragma solidity ^0.8.0;
2301 
2302 
2303 /**
2304  * @dev Required interface of an ERC721 compliant contract.
2305  */
2306 interface IERC721 is IERC165 {
2307     /**
2308      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
2309      */
2310     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
2311 
2312     /**
2313      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
2314      */
2315     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
2316 
2317     /**
2318      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
2319      */
2320     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
2321 
2322     /**
2323      * @dev Returns the number of tokens in ``owner``'s account.
2324      */
2325     function balanceOf(address owner) external view returns (uint256 balance);
2326 
2327     /**
2328      * @dev Returns the owner of the `tokenId` token.
2329      *
2330      * Requirements:
2331      *
2332      * - `tokenId` must exist.
2333      */
2334     function ownerOf(uint256 tokenId) external view returns (address owner);
2335 
2336     /**
2337      * @dev Safely transfers `tokenId` token from `from` to `to`.
2338      *
2339      * Requirements:
2340      *
2341      * - `from` cannot be the zero address.
2342      * - `to` cannot be the zero address.
2343      * - `tokenId` token must exist and be owned by `from`.
2344      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
2345      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
2346      *
2347      * Emits a {Transfer} event.
2348      */
2349     function safeTransferFrom(
2350         address from,
2351         address to,
2352         uint256 tokenId,
2353         bytes calldata data
2354     ) external;
2355 
2356     /**
2357      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
2358      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
2359      *
2360      * Requirements:
2361      *
2362      * - `from` cannot be the zero address.
2363      * - `to` cannot be the zero address.
2364      * - `tokenId` token must exist and be owned by `from`.
2365      * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
2366      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
2367      *
2368      * Emits a {Transfer} event.
2369      */
2370     function safeTransferFrom(
2371         address from,
2372         address to,
2373         uint256 tokenId
2374     ) external;
2375 
2376     /**
2377      * @dev Transfers `tokenId` token from `from` to `to`.
2378      *
2379      * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
2380      * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
2381      * understand this adds an external call which potentially creates a reentrancy vulnerability.
2382      *
2383      * Requirements:
2384      *
2385      * - `from` cannot be the zero address.
2386      * - `to` cannot be the zero address.
2387      * - `tokenId` token must be owned by `from`.
2388      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
2389      *
2390      * Emits a {Transfer} event.
2391      */
2392     function transferFrom(
2393         address from,
2394         address to,
2395         uint256 tokenId
2396     ) external;
2397 
2398     /**
2399      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
2400      * The approval is cleared when the token is transferred.
2401      *
2402      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
2403      *
2404      * Requirements:
2405      *
2406      * - The caller must own the token or be an approved operator.
2407      * - `tokenId` must exist.
2408      *
2409      * Emits an {Approval} event.
2410      */
2411     function approve(address to, uint256 tokenId) external;
2412 
2413     /**
2414      * @dev Approve or remove `operator` as an operator for the caller.
2415      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
2416      *
2417      * Requirements:
2418      *
2419      * - The `operator` cannot be the caller.
2420      *
2421      * Emits an {ApprovalForAll} event.
2422      */
2423     function setApprovalForAll(address operator, bool _approved) external;
2424 
2425     /**
2426      * @dev Returns the account approved for `tokenId` token.
2427      *
2428      * Requirements:
2429      *
2430      * - `tokenId` must exist.
2431      */
2432     function getApproved(uint256 tokenId) external view returns (address operator);
2433 
2434     /**
2435      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
2436      *
2437      * See {setApprovalForAll}
2438      */
2439     function isApprovedForAll(address owner, address operator) external view returns (bool);
2440 }
2441 
2442 // File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
2443 
2444 
2445 // OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)
2446 
2447 pragma solidity ^0.8.0;
2448 
2449 
2450 /**
2451  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
2452  * @dev See https://eips.ethereum.org/EIPS/eip-721
2453  */
2454 interface IERC721Metadata is IERC721 {
2455     /**
2456      * @dev Returns the token collection name.
2457      */
2458     function name() external view returns (string memory);
2459 
2460     /**
2461      * @dev Returns the token collection symbol.
2462      */
2463     function symbol() external view returns (string memory);
2464 
2465     /**
2466      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
2467      */
2468     function tokenURI(uint256 tokenId) external view returns (string memory);
2469 }
2470 
2471 // File: @openzeppelin/contracts/utils/introspection/ERC165.sol
2472 
2473 
2474 // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
2475 
2476 pragma solidity ^0.8.0;
2477 
2478 
2479 /**
2480  * @dev Implementation of the {IERC165} interface.
2481  *
2482  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
2483  * for the additional interface id that will be supported. For example:
2484  *
2485  * ```solidity
2486  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
2487  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
2488  * }
2489  * ```
2490  *
2491  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
2492  */
2493 abstract contract ERC165 is IERC165 {
2494     /**
2495      * @dev See {IERC165-supportsInterface}.
2496      */
2497     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
2498         return interfaceId == type(IERC165).interfaceId;
2499     }
2500 }
2501 
2502 // File: @openzeppelin/contracts/interfaces/IERC2981.sol
2503 
2504 
2505 // OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)
2506 
2507 pragma solidity ^0.8.0;
2508 
2509 
2510 /**
2511  * @dev Interface for the NFT Royalty Standard.
2512  *
2513  * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal
2514  * support for royalty payments across all NFT marketplaces and ecosystem participants.
2515  *
2516  * _Available since v4.5._
2517  */
2518 interface IERC2981 is IERC165 {
2519     /**
2520      * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of
2521      * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.
2522      */
2523     function royaltyInfo(uint256 tokenId, uint256 salePrice)
2524         external
2525         view
2526         returns (address receiver, uint256 royaltyAmount);
2527 }
2528 
2529 // File: @openzeppelin/contracts/token/common/ERC2981.sol
2530 
2531 
2532 // OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)
2533 
2534 pragma solidity ^0.8.0;
2535 
2536 
2537 
2538 /**
2539  * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.
2540  *
2541  * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for
2542  * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.
2543  *
2544  * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the
2545  * fee is specified in basis points by default.
2546  *
2547  * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See
2548  * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to
2549  * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.
2550  *
2551  * _Available since v4.5._
2552  */
2553 abstract contract ERC2981 is IERC2981, ERC165 {
2554     struct RoyaltyInfo {
2555         address receiver;
2556         uint96 royaltyFraction;
2557     }
2558 
2559     RoyaltyInfo private _defaultRoyaltyInfo;
2560     mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;
2561 
2562     /**
2563      * @dev See {IERC165-supportsInterface}.
2564      */
2565     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {
2566         return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);
2567     }
2568 
2569     /**
2570      * @inheritdoc IERC2981
2571      */
2572     function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {
2573         RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];
2574 
2575         if (royalty.receiver == address(0)) {
2576             royalty = _defaultRoyaltyInfo;
2577         }
2578 
2579         uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();
2580 
2581         return (royalty.receiver, royaltyAmount);
2582     }
2583 
2584     /**
2585      * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a
2586      * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an
2587      * override.
2588      */
2589     function _feeDenominator() internal pure virtual returns (uint96) {
2590         return 10000;
2591     }
2592 
2593     /**
2594      * @dev Sets the royalty information that all ids in this contract will default to.
2595      *
2596      * Requirements:
2597      *
2598      * - `receiver` cannot be the zero address.
2599      * - `feeNumerator` cannot be greater than the fee denominator.
2600      */
2601     function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {
2602         require(feeNumerator <= _feeDenominator(), "ERC2981: royalty fee will exceed salePrice");
2603         require(receiver != address(0), "ERC2981: invalid receiver");
2604 
2605         _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);
2606     }
2607 
2608     /**
2609      * @dev Removes default royalty information.
2610      */
2611     function _deleteDefaultRoyalty() internal virtual {
2612         delete _defaultRoyaltyInfo;
2613     }
2614 
2615     /**
2616      * @dev Sets the royalty information for a specific token id, overriding the global default.
2617      *
2618      * Requirements:
2619      *
2620      * - `receiver` cannot be the zero address.
2621      * - `feeNumerator` cannot be greater than the fee denominator.
2622      */
2623     function _setTokenRoyalty(
2624         uint256 tokenId,
2625         address receiver,
2626         uint96 feeNumerator
2627     ) internal virtual {
2628         require(feeNumerator <= _feeDenominator(), "ERC2981: royalty fee will exceed salePrice");
2629         require(receiver != address(0), "ERC2981: Invalid parameters");
2630 
2631         _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);
2632     }
2633 
2634     /**
2635      * @dev Resets royalty information for the token id back to the global default.
2636      */
2637     function _resetTokenRoyalty(uint256 tokenId) internal virtual {
2638         delete _tokenRoyaltyInfo[tokenId];
2639     }
2640 }
2641 
2642 // File: @openzeppelin/contracts/utils/Context.sol
2643 
2644 
2645 // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
2646 
2647 pragma solidity ^0.8.0;
2648 
2649 /**
2650  * @dev Provides information about the current execution context, including the
2651  * sender of the transaction and its data. While these are generally available
2652  * via msg.sender and msg.data, they should not be accessed in such a direct
2653  * manner, since when dealing with meta-transactions the account sending and
2654  * paying for execution may not be the actual sender (as far as an application
2655  * is concerned).
2656  *
2657  * This contract is only required for intermediate, library-like contracts.
2658  */
2659 abstract contract Context {
2660     function _msgSender() internal view virtual returns (address) {
2661         return msg.sender;
2662     }
2663 
2664     function _msgData() internal view virtual returns (bytes calldata) {
2665         return msg.data;
2666     }
2667 }
2668 
2669 // File: erc721psi/contracts/ERC721Psi.sol
2670 
2671 
2672 /**
2673   ______ _____   _____ ______ ___  __ _  _  _ 
2674  |  ____|  __ \ / ____|____  |__ \/_ | || || |
2675  | |__  | |__) | |        / /   ) || | \| |/ |
2676  |  __| |  _  /| |       / /   / / | |\_   _/ 
2677  | |____| | \ \| |____  / /   / /_ | |  | |   
2678  |______|_|  \_\\_____|/_/   |____||_|  |_|   
2679 
2680  - github: https://github.com/estarriolvetch/ERC721Psi
2681  - npm: https://www.npmjs.com/package/erc721psi
2682                                           
2683  */
2684 
2685 pragma solidity ^0.8.0;
2686 
2687 contract ERC721Psi is Context, ERC165, IERC721, IERC721Metadata {
2688     using Address for address;
2689     using Strings for uint256;
2690     using BitMaps for BitMaps.BitMap;
2691 
2692     BitMaps.BitMap internal _batchHead;
2693 
2694     string private _name;
2695     string private _symbol;
2696 
2697     // Mapping from token ID to owner address
2698     mapping(uint256 => address) internal _owners;
2699     uint256 internal _currentIndex;
2700 
2701     mapping(uint256 => address) private _tokenApprovals;
2702     mapping(address => mapping(address => bool)) private _operatorApprovals;
2703 
2704     /**
2705      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
2706      */
2707     constructor(string memory name_, string memory symbol_) {
2708         _name = name_;
2709         _symbol = symbol_;
2710         _currentIndex = _startTokenId();
2711     }
2712 
2713     /**
2714      * @dev Returns the starting token ID.
2715      * To change the starting token ID, please override this function.
2716      */
2717     function _startTokenId() internal pure virtual returns (uint256) {
2718         // It will become modifiable in the future versions
2719         return 0;
2720     }
2721 
2722     /**
2723      * @dev Returns the next token ID to be minted.
2724      */
2725     function _nextTokenId() internal view virtual returns (uint256) {
2726         return _currentIndex;
2727     }
2728 
2729     /**
2730      * @dev Returns the total amount of tokens minted in the contract.
2731      */
2732     function _totalMinted() internal view virtual returns (uint256) {
2733         return _currentIndex - _startTokenId();
2734     }
2735 
2736 
2737     /**
2738      * @dev See {IERC165-supportsInterface}.
2739      */
2740     function supportsInterface(bytes4 interfaceId)
2741         public
2742         view
2743         virtual
2744         override(ERC165, IERC165)
2745         returns (bool)
2746     {
2747         return
2748             interfaceId == type(IERC721).interfaceId ||
2749             interfaceId == type(IERC721Metadata).interfaceId ||
2750             super.supportsInterface(interfaceId);
2751     }
2752 
2753     /**
2754      * @dev See {IERC721-balanceOf}.
2755      */
2756     function balanceOf(address owner) 
2757         public 
2758         view 
2759         virtual 
2760         override 
2761         returns (uint) 
2762     {
2763         require(owner != address(0), "ERC721Psi: balance query for the zero address");
2764 
2765         uint count;
2766         for( uint i = _startTokenId(); i < _nextTokenId(); ++i ){
2767             if(_exists(i)){
2768                 if( owner == ownerOf(i)){
2769                     ++count;
2770                 }
2771             }
2772         }
2773         return count;
2774     }
2775 
2776     /**
2777      * @dev See {IERC721-ownerOf}.
2778      */
2779     function ownerOf(uint256 tokenId)
2780         public
2781         view
2782         virtual
2783         override
2784         returns (address)
2785     {
2786         (address owner, ) = _ownerAndBatchHeadOf(tokenId);
2787         return owner;
2788     }
2789 
2790     function _ownerAndBatchHeadOf(uint256 tokenId) internal view virtual returns (address owner, uint256 tokenIdBatchHead){
2791         require(_exists(tokenId), "ERC721Psi: owner query for nonexistent token");
2792         tokenIdBatchHead = _getBatchHead(tokenId);
2793         owner = _owners[tokenIdBatchHead];
2794     }
2795 
2796     /**
2797      * @dev See {IERC721Metadata-name}.
2798      */
2799     function name() public view virtual override returns (string memory) {
2800         return _name;
2801     }
2802 
2803     /**
2804      * @dev See {IERC721Metadata-symbol}.
2805      */
2806     function symbol() public view virtual override returns (string memory) {
2807         return _symbol;
2808     }
2809 
2810     /**
2811      * @dev See {IERC721Metadata-tokenURI}.
2812      */
2813     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
2814         require(_exists(tokenId), "ERC721Psi: URI query for nonexistent token");
2815 
2816         string memory baseURI = _baseURI();
2817         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
2818     }
2819 
2820     /**
2821      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
2822      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
2823      * by default, can be overriden in child contracts.
2824      */
2825     function _baseURI() internal view virtual returns (string memory) {
2826         return "";
2827     }
2828 
2829 
2830     /**
2831      * @dev See {IERC721-approve}.
2832      */
2833     function approve(address to, uint256 tokenId) public virtual override {
2834         address owner = ownerOf(tokenId);
2835         require(to != owner, "ERC721Psi: approval to current owner");
2836 
2837         require(
2838             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
2839             "ERC721Psi: approve caller is not owner nor approved for all"
2840         );
2841 
2842         _approve(to, tokenId);
2843     }
2844 
2845     /**
2846      * @dev See {IERC721-getApproved}.
2847      */
2848     function getApproved(uint256 tokenId)
2849         public
2850         view
2851         virtual
2852         override
2853         returns (address)
2854     {
2855         require(
2856             _exists(tokenId),
2857             "ERC721Psi: approved query for nonexistent token"
2858         );
2859 
2860         return _tokenApprovals[tokenId];
2861     }
2862 
2863     /**
2864      * @dev See {IERC721-setApprovalForAll}.
2865      */
2866     function setApprovalForAll(address operator, bool approved)
2867         public
2868         virtual
2869         override
2870     {
2871         require(operator != _msgSender(), "ERC721Psi: approve to caller");
2872 
2873         _operatorApprovals[_msgSender()][operator] = approved;
2874         emit ApprovalForAll(_msgSender(), operator, approved);
2875     }
2876 
2877     /**
2878      * @dev See {IERC721-isApprovedForAll}.
2879      */
2880     function isApprovedForAll(address owner, address operator)
2881         public
2882         view
2883         virtual
2884         override
2885         returns (bool)
2886     {
2887         return _operatorApprovals[owner][operator];
2888     }
2889 
2890     /**
2891      * @dev See {IERC721-transferFrom}.
2892      */
2893     function transferFrom(
2894         address from,
2895         address to,
2896         uint256 tokenId
2897     ) public virtual override {
2898         //solhint-disable-next-line max-line-length
2899         require(
2900             _isApprovedOrOwner(_msgSender(), tokenId),
2901             "ERC721Psi: transfer caller is not owner nor approved"
2902         );
2903 
2904         _transfer(from, to, tokenId);
2905     }
2906 
2907     /**
2908      * @dev See {IERC721-safeTransferFrom}.
2909      */
2910     function safeTransferFrom(
2911         address from,
2912         address to,
2913         uint256 tokenId
2914     ) public virtual override {
2915         safeTransferFrom(from, to, tokenId, "");
2916     }
2917 
2918     /**
2919      * @dev See {IERC721-safeTransferFrom}.
2920      */
2921     function safeTransferFrom(
2922         address from,
2923         address to,
2924         uint256 tokenId,
2925         bytes memory _data
2926     ) public virtual override {
2927         require(
2928             _isApprovedOrOwner(_msgSender(), tokenId),
2929             "ERC721Psi: transfer caller is not owner nor approved"
2930         );
2931         _safeTransfer(from, to, tokenId, _data);
2932     }
2933 
2934     /**
2935      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
2936      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
2937      *
2938      * `_data` is additional data, it has no specified format and it is sent in call to `to`.
2939      *
2940      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
2941      * implement alternative mechanisms to perform token transfer, such as signature-based.
2942      *
2943      * Requirements:
2944      *
2945      * - `from` cannot be the zero address.
2946      * - `to` cannot be the zero address.
2947      * - `tokenId` token must exist and be owned by `from`.
2948      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
2949      *
2950      * Emits a {Transfer} event.
2951      */
2952     function _safeTransfer(
2953         address from,
2954         address to,
2955         uint256 tokenId,
2956         bytes memory _data
2957     ) internal virtual {
2958         _transfer(from, to, tokenId);
2959         require(
2960             _checkOnERC721Received(from, to, tokenId, 1,_data),
2961             "ERC721Psi: transfer to non ERC721Receiver implementer"
2962         );
2963     }
2964 
2965     /**
2966      * @dev Returns whether `tokenId` exists.
2967      *
2968      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
2969      *
2970      * Tokens start existing when they are minted (`_mint`).
2971      */
2972     function _exists(uint256 tokenId) internal view virtual returns (bool) {
2973         return tokenId < _nextTokenId() && _startTokenId() <= tokenId;
2974     }
2975 
2976     /**
2977      * @dev Returns whether `spender` is allowed to manage `tokenId`.
2978      *
2979      * Requirements:
2980      *
2981      * - `tokenId` must exist.
2982      */
2983     function _isApprovedOrOwner(address spender, uint256 tokenId)
2984         internal
2985         view
2986         virtual
2987         returns (bool)
2988     {
2989         require(
2990             _exists(tokenId),
2991             "ERC721Psi: operator query for nonexistent token"
2992         );
2993         address owner = ownerOf(tokenId);
2994         return (spender == owner ||
2995             getApproved(tokenId) == spender ||
2996             isApprovedForAll(owner, spender));
2997     }
2998 
2999     /**
3000      * @dev Safely mints `quantity` tokens and transfers them to `to`.
3001      *
3002      * Requirements:
3003      *
3004      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called for each safe transfer.
3005      * - `quantity` must be greater than 0.
3006      *
3007      * Emits a {Transfer} event.
3008      */
3009     function _safeMint(address to, uint256 quantity) internal virtual {
3010         _safeMint(to, quantity, "");
3011     }
3012 
3013     
3014     function _safeMint(
3015         address to,
3016         uint256 quantity,
3017         bytes memory _data
3018     ) internal virtual {
3019         uint256 nextTokenId = _nextTokenId();
3020         _mint(to, quantity);
3021         require(
3022             _checkOnERC721Received(address(0), to, nextTokenId, quantity, _data),
3023             "ERC721Psi: transfer to non ERC721Receiver implementer"
3024         );
3025     }
3026 
3027 
3028     function _mint(
3029         address to,
3030         uint256 quantity
3031     ) internal virtual {
3032         uint256 nextTokenId = _nextTokenId();
3033         
3034         require(quantity > 0, "ERC721Psi: quantity must be greater 0");
3035         require(to != address(0), "ERC721Psi: mint to the zero address");
3036         
3037         _beforeTokenTransfers(address(0), to, nextTokenId, quantity);
3038         _currentIndex += quantity;
3039         _owners[nextTokenId] = to;
3040         _batchHead.set(nextTokenId);
3041         _afterTokenTransfers(address(0), to, nextTokenId, quantity);
3042         
3043         // Emit events
3044         for(uint256 tokenId=nextTokenId; tokenId < nextTokenId + quantity; tokenId++){
3045             emit Transfer(address(0), to, tokenId);
3046         } 
3047     }
3048 
3049 
3050 
3051     /**
3052      * @dev Transfers `tokenId` from `from` to `to`.
3053      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
3054      *
3055      * Requirements:
3056      *
3057      * - `to` cannot be the zero address.
3058      * - `tokenId` token must be owned by `from`.
3059      *
3060      * Emits a {Transfer} event.
3061      */
3062     function _transfer(
3063         address from,
3064         address to,
3065         uint256 tokenId
3066     ) internal virtual {
3067         (address owner, uint256 tokenIdBatchHead) = _ownerAndBatchHeadOf(tokenId);
3068 
3069         require(
3070             owner == from,
3071             "ERC721Psi: transfer of token that is not own"
3072         );
3073         require(to != address(0), "ERC721Psi: transfer to the zero address");
3074 
3075         _beforeTokenTransfers(from, to, tokenId, 1);
3076 
3077         // Clear approvals from the previous owner
3078         _approve(address(0), tokenId);   
3079 
3080         uint256 subsequentTokenId = tokenId + 1;
3081 
3082         if(!_batchHead.get(subsequentTokenId) &&  
3083             subsequentTokenId < _nextTokenId()
3084         ) {
3085             _owners[subsequentTokenId] = from;
3086             _batchHead.set(subsequentTokenId);
3087         }
3088 
3089         _owners[tokenId] = to;
3090         if(tokenId != tokenIdBatchHead) {
3091             _batchHead.set(tokenId);
3092         }
3093 
3094         emit Transfer(from, to, tokenId);
3095 
3096         _afterTokenTransfers(from, to, tokenId, 1);
3097     }
3098 
3099     /**
3100      * @dev Approve `to` to operate on `tokenId`
3101      *
3102      * Emits a {Approval} event.
3103      */
3104     function _approve(address to, uint256 tokenId) internal virtual {
3105         _tokenApprovals[tokenId] = to;
3106         emit Approval(ownerOf(tokenId), to, tokenId);
3107     }
3108 
3109     /**
3110      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
3111      * The call is not executed if the target address is not a contract.
3112      *
3113      * @param from address representing the previous owner of the given token ID
3114      * @param to target address that will receive the tokens
3115      * @param startTokenId uint256 the first ID of the tokens to be transferred
3116      * @param quantity uint256 amount of the tokens to be transfered.
3117      * @param _data bytes optional data to send along with the call
3118      * @return r bool whether the call correctly returned the expected magic value
3119      */
3120     function _checkOnERC721Received(
3121         address from,
3122         address to,
3123         uint256 startTokenId,
3124         uint256 quantity,
3125         bytes memory _data
3126     ) private returns (bool r) {
3127         if (to.isContract()) {
3128             r = true;
3129             for(uint256 tokenId = startTokenId; tokenId < startTokenId + quantity; tokenId++){
3130                 try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
3131                     r = r && retval == IERC721Receiver.onERC721Received.selector;
3132                 } catch (bytes memory reason) {
3133                     if (reason.length == 0) {
3134                         revert("ERC721Psi: transfer to non ERC721Receiver implementer");
3135                     } else {
3136                         assembly {
3137                             revert(add(32, reason), mload(reason))
3138                         }
3139                     }
3140                 }
3141             }
3142             return r;
3143         } else {
3144             return true;
3145         }
3146     }
3147 
3148     function _getBatchHead(uint256 tokenId) internal view returns (uint256 tokenIdBatchHead) {
3149         tokenIdBatchHead = _batchHead.scanForward(tokenId); 
3150     }
3151 
3152 
3153     function totalSupply() public virtual view returns (uint256) {
3154         return _totalMinted();
3155     }
3156 
3157     /**
3158      * @dev Returns an array of token IDs owned by `owner`.
3159      *
3160      * This function scans the ownership mapping and is O(`totalSupply`) in complexity.
3161      * It is meant to be called off-chain.
3162      *
3163      * This function is compatiable with ERC721AQueryable.
3164      */
3165     function tokensOfOwner(address owner) external view virtual returns (uint256[] memory) {
3166         unchecked {
3167             uint256 tokenIdsIdx;
3168             uint256 tokenIdsLength = balanceOf(owner);
3169             uint256[] memory tokenIds = new uint256[](tokenIdsLength);
3170             for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {
3171                 if (_exists(i)) {
3172                     if (ownerOf(i) == owner) {
3173                         tokenIds[tokenIdsIdx++] = i;
3174                     }
3175                 }
3176             }
3177             return tokenIds;   
3178         }
3179     }
3180 
3181     /**
3182      * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.
3183      *
3184      * startTokenId - the first token id to be transferred
3185      * quantity - the amount to be transferred
3186      *
3187      * Calling conditions:
3188      *
3189      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
3190      * transferred to `to`.
3191      * - When `from` is zero, `tokenId` will be minted for `to`.
3192      */
3193     function _beforeTokenTransfers(
3194         address from,
3195         address to,
3196         uint256 startTokenId,
3197         uint256 quantity
3198     ) internal virtual {}
3199 
3200     /**
3201      * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes
3202      * minting.
3203      *
3204      * startTokenId - the first token id to be transferred
3205      * quantity - the amount to be transferred
3206      *
3207      * Calling conditions:
3208      *
3209      * - when `from` and `to` are both non-zero.
3210      * - `from` and `to` are never both zero.
3211      */
3212     function _afterTokenTransfers(
3213         address from,
3214         address to,
3215         uint256 startTokenId,
3216         uint256 quantity
3217     ) internal virtual {}
3218 }
3219 // File: erc721psi/contracts/extension/ERC721PsiBurnable.sol
3220 
3221 
3222 /**
3223   ______ _____   _____ ______ ___  __ _  _  _ 
3224  |  ____|  __ \ / ____|____  |__ \/_ | || || |
3225  | |__  | |__) | |        / /   ) || | \| |/ |
3226  |  __| |  _  /| |       / /   / / | |\_   _/ 
3227  | |____| | \ \| |____  / /   / /_ | |  | |   
3228  |______|_|  \_\\_____|/_/   |____||_|  |_|   
3229                                               
3230                                             
3231  */
3232 pragma solidity ^0.8.0;
3233 
3234 
3235 
3236 
3237 abstract contract ERC721PsiBurnable is ERC721Psi {
3238     using BitMaps for BitMaps.BitMap;
3239     BitMaps.BitMap internal _burnedToken;
3240 
3241     /**
3242      * @dev Destroys `tokenId`.
3243      * The approval is cleared when the token is burned.
3244      *
3245      * Requirements:
3246      *
3247      * - `tokenId` must exist.
3248      *
3249      * Emits a {Transfer} event.
3250      */
3251     function _burn(uint256 tokenId) internal virtual {
3252         address from = ownerOf(tokenId);
3253         _beforeTokenTransfers(from, address(0), tokenId, 1);
3254         _burnedToken.set(tokenId);
3255         
3256         emit Transfer(from, address(0), tokenId);
3257 
3258         _afterTokenTransfers(from, address(0), tokenId, 1);
3259     }
3260 
3261     /**
3262      * @dev Returns whether `tokenId` exists.
3263      *
3264      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
3265      *
3266      * Tokens start existing when they are minted (`_mint`),
3267      * and stop existing when they are burned (`_burn`).
3268      */
3269     function _exists(uint256 tokenId) internal view override virtual returns (bool){
3270         if(_burnedToken.get(tokenId)) {
3271             return false;
3272         } 
3273         return super._exists(tokenId);
3274     }
3275 
3276     /**
3277      * @dev See {IERC721Enumerable-totalSupply}.
3278      */
3279     function totalSupply() public view virtual override returns (uint256) {
3280         return _totalMinted() - _burned();
3281     }
3282 
3283     /**
3284      * @dev Returns number of token burned.
3285      */
3286     function _burned() internal view returns (uint256 burned){
3287         uint256 startBucket = _startTokenId() >> 8;
3288         uint256 lastBucket = (_nextTokenId() >> 8) + 1;
3289 
3290         for(uint256 i=startBucket; i < lastBucket; i++) {
3291             uint256 bucket = _burnedToken.getBucket(i);
3292             burned += _popcount(bucket);
3293         }
3294     }
3295 
3296     /**
3297      * @dev Returns number of set bits.
3298      */
3299     function _popcount(uint256 x) private pure returns (uint256 count) {
3300         unchecked{
3301             for (count=0; x!=0; count++)
3302                 x &= x - 1;
3303         }
3304     }
3305 }
3306 // File: @openzeppelin/contracts/access/Ownable.sol
3307 
3308 
3309 // OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)
3310 
3311 pragma solidity ^0.8.0;
3312 
3313 
3314 /**
3315  * @dev Contract module which provides a basic access control mechanism, where
3316  * there is an account (an owner) that can be granted exclusive access to
3317  * specific functions.
3318  *
3319  * By default, the owner account will be the one that deploys the contract. This
3320  * can later be changed with {transferOwnership}.
3321  *
3322  * This module is used through inheritance. It will make available the modifier
3323  * `onlyOwner`, which can be applied to your functions to restrict their use to
3324  * the owner.
3325  */
3326 abstract contract Ownable is Context {
3327     address private _owner;
3328 
3329     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
3330 
3331     /**
3332      * @dev Initializes the contract setting the deployer as the initial owner.
3333      */
3334     constructor() {
3335         _transferOwnership(_msgSender());
3336     }
3337 
3338     /**
3339      * @dev Throws if called by any account other than the owner.
3340      */
3341     modifier onlyOwner() {
3342         _checkOwner();
3343         _;
3344     }
3345 
3346     /**
3347      * @dev Returns the address of the current owner.
3348      */
3349     function owner() public view virtual returns (address) {
3350         return _owner;
3351     }
3352 
3353     /**
3354      * @dev Throws if the sender is not the owner.
3355      */
3356     function _checkOwner() internal view virtual {
3357         require(owner() == _msgSender(), "Ownable: caller is not the owner");
3358     }
3359 
3360     /**
3361      * @dev Leaves the contract without owner. It will not be possible to call
3362      * `onlyOwner` functions anymore. Can only be called by the current owner.
3363      *
3364      * NOTE: Renouncing ownership will leave the contract without an owner,
3365      * thereby removing any functionality that is only available to the owner.
3366      */
3367     function renounceOwnership() public virtual onlyOwner {
3368         _transferOwnership(address(0));
3369     }
3370 
3371     /**
3372      * @dev Transfers ownership of the contract to a new account (`newOwner`).
3373      * Can only be called by the current owner.
3374      */
3375     function transferOwnership(address newOwner) public virtual onlyOwner {
3376         require(newOwner != address(0), "Ownable: new owner is the zero address");
3377         _transferOwnership(newOwner);
3378     }
3379 
3380     /**
3381      * @dev Transfers ownership of the contract to a new account (`newOwner`).
3382      * Internal function without access restriction.
3383      */
3384     function _transferOwnership(address newOwner) internal virtual {
3385         address oldOwner = _owner;
3386         _owner = newOwner;
3387         emit OwnershipTransferred(oldOwner, newOwner);
3388     }
3389 }
3390 
3391 // File: EXO/NEW/EXO.sol
3392 
3393 pragma solidity >=0.6.0;
3394 
3395 /// @title Base64
3396 /// @author Brecht Devos - <brecht@loopring.org>
3397 /// @notice Provides functions for encoding/decoding base64
3398 library Base64 {
3399     string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
3400     bytes  internal constant TABLE_DECODE = hex"0000000000000000000000000000000000000000000000000000000000000000"
3401                                             hex"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000"
3402                                             hex"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000"
3403                                             hex"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000";
3404 
3405     function encode(bytes memory data) internal pure returns (string memory) {
3406         if (data.length == 0) return '';
3407 
3408         // load the table into memory
3409         string memory table = TABLE_ENCODE;
3410 
3411         // multiply by 4/3 rounded up
3412         uint256 encodedLen = 4 * ((data.length + 2) / 3);
3413 
3414         // add some extra buffer at the end required for the writing
3415         string memory result = new string(encodedLen + 32);
3416 
3417         assembly {
3418             // set the actual output length
3419             mstore(result, encodedLen)
3420 
3421             // prepare the lookup table
3422             let tablePtr := add(table, 1)
3423 
3424             // input ptr
3425             let dataPtr := data
3426             let endPtr := add(dataPtr, mload(data))
3427 
3428             // result ptr, jump over length
3429             let resultPtr := add(result, 32)
3430 
3431             // run over the input, 3 bytes at a time
3432             for {} lt(dataPtr, endPtr) {}
3433             {
3434                 // read 3 bytes
3435                 dataPtr := add(dataPtr, 3)
3436                 let input := mload(dataPtr)
3437 
3438                 // write 4 characters
3439                 mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
3440                 resultPtr := add(resultPtr, 1)
3441                 mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
3442                 resultPtr := add(resultPtr, 1)
3443                 mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))
3444                 resultPtr := add(resultPtr, 1)
3445                 mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))
3446                 resultPtr := add(resultPtr, 1)
3447             }
3448 
3449             // padding with '='
3450             switch mod(mload(data), 3)
3451             case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }
3452             case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }
3453         }
3454 
3455         return result;
3456     }
3457 
3458     function decode(string memory _data) internal pure returns (bytes memory) {
3459         bytes memory data = bytes(_data);
3460 
3461         if (data.length == 0) return new bytes(0);
3462         require(data.length % 4 == 0, "invalid base64 decoder input");
3463 
3464         // load the table into memory
3465         bytes memory table = TABLE_DECODE;
3466 
3467         // every 4 characters represent 3 bytes
3468         uint256 decodedLen = (data.length / 4) * 3;
3469 
3470         // add some extra buffer at the end required for the writing
3471         bytes memory result = new bytes(decodedLen + 32);
3472 
3473         assembly {
3474             // padding with '='
3475             let lastBytes := mload(add(data, mload(data)))
3476             if eq(and(lastBytes, 0xFF), 0x3d) {
3477                 decodedLen := sub(decodedLen, 1)
3478                 if eq(and(lastBytes, 0xFFFF), 0x3d3d) {
3479                     decodedLen := sub(decodedLen, 1)
3480                 }
3481             }
3482 
3483             // set the actual output length
3484             mstore(result, decodedLen)
3485 
3486             // prepare the lookup table
3487             let tablePtr := add(table, 1)
3488 
3489             // input ptr
3490             let dataPtr := data
3491             let endPtr := add(dataPtr, mload(data))
3492 
3493             // result ptr, jump over length
3494             let resultPtr := add(result, 32)
3495 
3496             // run over the input, 4 characters at a time
3497             for {} lt(dataPtr, endPtr) {}
3498             {
3499                // read 4 characters
3500                dataPtr := add(dataPtr, 4)
3501                let input := mload(dataPtr)
3502 
3503                // write 3 bytes
3504                let output := add(
3505                    add(
3506                        shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),
3507                        shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),
3508                    add(
3509                        shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),
3510                                and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)
3511                     )
3512                 )
3513                 mstore(resultPtr, shl(232, output))
3514                 resultPtr := add(resultPtr, 3)
3515             }
3516         }
3517 
3518         return result;
3519     }
3520 }
3521 
3522 
3523 
3524 
3525 
3526 
3527 pragma solidity ^0.8.7;
3528 
3529 
3530 abstract contract MerkleProof {
3531     bytes32 internal _wlMerkleRoot;
3532     mapping(uint256 => bytes32) internal _alMerkleRoot;
3533     uint256 public phaseId;
3534 
3535     function _setWlMerkleRoot(bytes32 merkleRoot_) internal virtual {
3536         _wlMerkleRoot = merkleRoot_;
3537     }
3538     function isWhitelisted(address address_, uint256 wlCount, bytes32[] memory proof_) public view returns (bool) {
3539         bytes32 _leaf = keccak256(abi.encodePacked(address_, wlCount));
3540         for (uint256 i = 0; i < proof_.length; i++) {
3541             _leaf = _leaf < proof_[i] ? keccak256(abi.encodePacked(_leaf, proof_[i])) : keccak256(abi.encodePacked(proof_[i], _leaf));
3542         }
3543         return _leaf == _wlMerkleRoot;
3544     }
3545 
3546     function _setAlMerkleRootWithId(uint256 _phaseId,bytes32 merkleRoot_) internal virtual {
3547         _alMerkleRoot[_phaseId] = merkleRoot_;
3548     }
3549 
3550     function _setAlMerkleRoot(bytes32 merkleRoot_) internal virtual {
3551         _alMerkleRoot[phaseId] = merkleRoot_;
3552     }
3553 
3554     function isAllowlisted(address address_,uint256 _phaseId, bytes32[] memory proof_) public view returns (bool) {
3555         bytes32 _leaf = keccak256(abi.encodePacked(address_));
3556         for (uint256 i = 0; i < proof_.length; i++) {
3557             _leaf = _leaf < proof_[i] ? keccak256(abi.encodePacked(_leaf, proof_[i])) : keccak256(abi.encodePacked(proof_[i], _leaf));
3558         }
3559         return _leaf == _alMerkleRoot[_phaseId];
3560     }
3561 
3562 }
3563 
3564 pragma solidity ^0.8.9;
3565 abstract contract Operable is Context {
3566     mapping(address => bool) _operators;
3567     modifier onlyOperator() {
3568         _checkOperatorRole(_msgSender());
3569         _;
3570     }
3571     function isOperator(address _operator) public view returns (bool) {
3572         return _operators[_operator];
3573     }
3574     function _grantOperatorRole(address _candidate) internal {
3575         require(
3576             !_operators[_candidate],
3577             string(
3578                 abi.encodePacked(
3579                     "account ",
3580                     Strings.toHexString(uint160(_msgSender()), 20),
3581                     " is already has an operator role"
3582                 )
3583             )
3584         );
3585         _operators[_candidate] = true;
3586     }
3587     function _revokeOperatorRole(address _candidate) internal {
3588         _checkOperatorRole(_candidate);
3589         delete _operators[_candidate];
3590     }
3591     function _checkOperatorRole(address _operator) internal view {
3592         require(
3593             _operators[_operator],
3594             string(
3595                 abi.encodePacked(
3596                     "account ",
3597                     Strings.toHexString(uint160(_msgSender()), 20),
3598                     " is not an operator"
3599                 )
3600             )
3601         );
3602     }
3603 }
3604 
3605 pragma solidity ^0.8.13;
3606 
3607 interface IOperatorFilterRegistry {
3608     function isOperatorAllowed(address registrant, address operator) external view returns (bool);
3609     function register(address registrant) external;
3610     function registerAndSubscribe(address registrant, address subscription) external;
3611     function registerAndCopyEntries(address registrant, address registrantToCopy) external;
3612     function unregister(address addr) external;
3613     function updateOperator(address registrant, address operator, bool filtered) external;
3614     function updateOperators(address registrant, address[] calldata operators, bool filtered) external;
3615     function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;
3616     function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;
3617     function subscribe(address registrant, address registrantToSubscribe) external;
3618     function unsubscribe(address registrant, bool copyExistingEntries) external;
3619     function subscriptionOf(address addr) external returns (address registrant);
3620     function subscribers(address registrant) external returns (address[] memory);
3621     function subscriberAt(address registrant, uint256 index) external returns (address);
3622     function copyEntriesOf(address registrant, address registrantToCopy) external;
3623     function isOperatorFiltered(address registrant, address operator) external returns (bool);
3624     function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);
3625     function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);
3626     function filteredOperators(address addr) external returns (address[] memory);
3627     function filteredCodeHashes(address addr) external returns (bytes32[] memory);
3628     function filteredOperatorAt(address registrant, uint256 index) external returns (address);
3629     function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);
3630     function isRegistered(address addr) external returns (bool);
3631     function codeHashOf(address addr) external returns (bytes32);
3632 }
3633 
3634 pragma solidity ^0.8.13;
3635 
3636 
3637 /**
3638  * @title  OperatorFilterer
3639  * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another
3640  *         registrant's entries in the OperatorFilterRegistry.
3641  * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:
3642  *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.
3643  *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.
3644  */
3645 abstract contract OperatorFilterer {
3646     error OperatorNotAllowed(address operator);
3647     bool public operatorFilteringEnabled = true;
3648 
3649     IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =
3650         IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);
3651 
3652     constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {
3653         // If an inheriting token contract is deployed to a network without the registry deployed, the modifier
3654         // will not revert, but the contract will need to be registered with the registry once it is deployed in
3655         // order for the modifier to filter addresses.
3656         if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {
3657             if (subscribe) {
3658                 OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);
3659             } else {
3660                 if (subscriptionOrRegistrantToCopy != address(0)) {
3661                     OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);
3662                 } else {
3663                     OPERATOR_FILTER_REGISTRY.register(address(this));
3664                 }
3665             }
3666         }
3667     }
3668 
3669     modifier onlyAllowedOperator(address from) virtual {
3670         // Check registry code length to facilitate testing in environments without a deployed registry.
3671         if (address(OPERATOR_FILTER_REGISTRY).code.length > 0 && operatorFilteringEnabled) {
3672             // Allow spending tokens from addresses with balance
3673             // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred
3674             // from an EOA.
3675             if (from == msg.sender) {
3676                 _;
3677                 return;
3678             }
3679             if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), msg.sender)) {
3680                 revert OperatorNotAllowed(msg.sender);
3681             }
3682         }
3683         _;
3684     }
3685 
3686     modifier onlyAllowedOperatorApproval(address operator) virtual {
3687         // Check registry code length to facilitate testing in environments without a deployed registry.
3688         if (address(OPERATOR_FILTER_REGISTRY).code.length > 0 && operatorFilteringEnabled) {
3689             if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {
3690                 revert OperatorNotAllowed(operator);
3691             }
3692         }
3693         _;
3694     }
3695 }
3696 
3697 
3698 pragma solidity ^0.8.13;
3699 /**
3700  * @title  DefaultOperatorFilterer
3701  * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.
3702  */
3703 abstract contract DefaultOperatorFilterer is OperatorFilterer {
3704     address constant DEFAULT_SUBSCRIPTION = address(0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6);
3705 
3706     constructor() OperatorFilterer(DEFAULT_SUBSCRIPTION, true) {}
3707 }
3708 
3709 
3710 
3711 
3712 
3713 pragma solidity >=0.7.0 <0.9.0;
3714 
3715 interface IContractAllowListProxy {
3716     function isAllowed(address _transferer, uint256 _level)
3717         external
3718         view
3719         returns (bool);
3720 }
3721 
3722 pragma solidity >=0.8.0;
3723 
3724 /// @title IERC721RestrictApprove
3725 /// @dev Approve
3726 /// @author Lavulite
3727 
3728 interface IERC721RestrictApprove {
3729     /**
3730      * @dev CAL
3731      */
3732     event CalLevelChanged(address indexed operator, uint256 indexed level);
3733     
3734     /**
3735      * @dev LocalContractAllowListn
3736      */
3737     event LocalCalAdded(address indexed operator, address indexed transferer);
3738 
3739     /**
3740      * @dev LocalContractAllowListn
3741      */
3742     event LocalCalRemoved(address indexed operator, address indexed transferer);
3743 
3744     /**
3745      * @dev CALCAL
3746      */
3747     function setCALLevel(uint256 level) external;
3748 
3749     /**
3750      * @dev CAL
3751      */
3752     function setCAL(address calAddress) external;
3753 
3754     /**
3755      * @dev CAL
3756      */
3757     function addLocalContractAllowList(address transferer) external;
3758 
3759     /**
3760      * @dev CAL
3761      */
3762     function removeLocalContractAllowList(address transferer) external;
3763 
3764     /**
3765      * @dev CAL
3766      */
3767     function getLocalContractAllowList() external view returns(address[] memory);
3768 
3769 }
3770 
3771 pragma solidity >=0.8.0;
3772 
3773 /// @title AntiScamERC721A
3774 /// @dev Readme
3775 
3776 abstract contract ERC721RestrictApprove is ERC721PsiBurnable, IERC721RestrictApprove {
3777     using EnumerableSet for EnumerableSet.AddressSet;
3778 
3779     IContractAllowListProxy public CAL;
3780     EnumerableSet.AddressSet localAllowedAddresses;
3781 
3782     modifier onlyHolder(uint256 tokenId) {
3783         require(
3784             msg.sender == ownerOf(tokenId),
3785             "RestrictApprove: operation is only holder."
3786         );
3787         _;
3788     }
3789 
3790     /*//////////////////////////////////////////////////////////////
3791     
3792     //////////////////////////////////////////////////////////////*/
3793     bool public enableRestrict = true;
3794 
3795     // token lock
3796     mapping(uint256 => uint256) public tokenCALLevel;
3797 
3798     // wallet lock
3799     mapping(address => uint256) public walletCALLevel;
3800 
3801     // contract lock
3802     uint256 public CALLevel = 1;
3803 
3804     /*///////////////////////////////////////////////////////////////
3805     Approve
3806     //////////////////////////////////////////////////////////////*/
3807     function _addLocalContractAllowList(address transferer)
3808         internal
3809         virtual
3810     {
3811         localAllowedAddresses.add(transferer);
3812         emit LocalCalAdded(msg.sender, transferer);
3813     }
3814 
3815     function _removeLocalContractAllowList(address transferer)
3816         internal
3817         virtual
3818     {
3819         localAllowedAddresses.remove(transferer);
3820         emit LocalCalRemoved(msg.sender, transferer);
3821     }
3822 
3823     function _getLocalContractAllowList()
3824         internal
3825         virtual
3826         view
3827         returns(address[] memory)
3828     {
3829         return localAllowedAddresses.values();
3830     }
3831 
3832     function _isLocalAllowed(address transferer)
3833         internal
3834         view
3835         virtual
3836         returns (bool)
3837     {
3838         return localAllowedAddresses.contains(transferer);
3839     }
3840 
3841     function _isAllowed(address transferer)
3842         internal
3843         view
3844         virtual
3845         returns (bool)
3846     {
3847         return _isAllowed(msg.sender, transferer);
3848     }
3849 
3850     function _isAllowed(uint256 tokenId, address transferer)
3851         internal
3852         view
3853         virtual
3854         returns (bool)
3855     {
3856         uint256 level = _getCALLevel(msg.sender, tokenId);
3857         return _isAllowed(transferer, level);
3858     }
3859 
3860     function _isAllowed(address holder, address transferer)
3861         internal
3862         view
3863         virtual
3864         returns (bool)
3865     {
3866         uint256 level = _getCALLevel(holder);
3867         return _isAllowed(transferer, level);
3868     }
3869 
3870     function _isAllowed(address transferer, uint256 level)
3871         internal
3872         view
3873         virtual
3874         returns (bool)
3875     {
3876         if (!enableRestrict) {
3877             return true;
3878         }
3879 
3880         return _isLocalAllowed(transferer) || CAL.isAllowed(transferer, level);
3881     }
3882 
3883     function _getCALLevel(address holder, uint256 tokenId)
3884         internal
3885         view
3886         virtual
3887         returns (uint256)
3888     {
3889         if (tokenCALLevel[tokenId] > 0) {
3890             return tokenCALLevel[tokenId];
3891         }
3892 
3893         return _getCALLevel(holder);
3894     }
3895 
3896     function _getCALLevel(address holder)
3897         internal
3898         view
3899         virtual
3900         returns (uint256)
3901     {
3902         if (walletCALLevel[holder] > 0) {
3903             return walletCALLevel[holder];
3904         }
3905 
3906         return CALLevel;
3907     }
3908 
3909     function _setCAL(address _cal) internal virtual {
3910         CAL = IContractAllowListProxy(_cal);
3911     }
3912 
3913     function _deleteTokenCALLevel(uint256 tokenId) internal virtual {
3914         delete tokenCALLevel[tokenId];
3915     }
3916 
3917     function setTokenCALLevel(uint256 tokenId, uint256 level)
3918         external
3919         virtual
3920         onlyHolder(tokenId)
3921     {
3922         tokenCALLevel[tokenId] = level;
3923     }
3924 
3925     function setWalletCALLevel(uint256 level)
3926         external
3927         virtual
3928     {
3929         walletCALLevel[msg.sender] = level;
3930     }
3931 
3932     /*///////////////////////////////////////////////////////////////
3933                               OVERRIDES
3934     //////////////////////////////////////////////////////////////*/
3935 
3936     function isApprovedForAll(address owner, address operator)
3937         public
3938         view
3939         virtual
3940         override
3941         returns (bool)
3942     {
3943         if (_isAllowed(owner, operator) == false) {
3944             return false;
3945         }
3946         return super.isApprovedForAll(owner, operator);
3947     }
3948 
3949     function setApprovalForAll(address operator, bool approved)
3950         public
3951         virtual
3952         override
3953     {
3954         require(
3955             _isAllowed(operator) || approved == false,
3956             "RestrictApprove: Can not approve locked token"
3957         );
3958         super.setApprovalForAll(operator, approved);
3959     }
3960 
3961     function _beforeApprove(address to, uint256 tokenId)
3962         internal
3963         virtual
3964     {
3965         if (to != address(0)) {
3966             require(_isAllowed(tokenId, to), "RestrictApprove: The contract is not allowed.");
3967         }
3968     }
3969 
3970     function approve(address to, uint256 tokenId)
3971         public
3972         virtual
3973         override
3974     {
3975         _beforeApprove(to, tokenId);
3976         super.approve(to, tokenId);
3977     }
3978 
3979     function _afterTokenTransfers(
3980         address from,
3981         address, /*to*/
3982         uint256 startTokenId,
3983         uint256 /*quantity*/
3984     ) internal virtual override {
3985         // startTokenId TokenID
3986         if (from != address(0)) {
3987             // CAL
3988             _deleteTokenCALLevel(startTokenId);
3989         }
3990     }
3991 
3992     function supportsInterface(bytes4 interfaceId)
3993         public
3994         view
3995         virtual
3996         override
3997         returns (bool)
3998     {
3999         return
4000             interfaceId == type(IERC721RestrictApprove).interfaceId ||
4001             super.supportsInterface(interfaceId);
4002     }
4003 }
4004 
4005 
4006 pragma solidity ^0.8.7;
4007 /*
4008 
4009 
4010 
4011 by
4012 
4013 
4014 
4015 -CNW by STARTJPN-
4016 */
4017 contract CRYPTONINJAWORLD is Ownable, ERC721RestrictApprove, ReentrancyGuard, MerkleProof, ERC2981, DefaultOperatorFilterer,Operable {
4018   //Project Settings
4019   uint256 public wlMintPrice = 0.001 ether;
4020   uint256 public alMintPrice = 0.001 ether;
4021   uint256 public psMintPrice = 0.002 ether;
4022   mapping(uint256 => uint256) public maxMintsPerAL;
4023   uint256 public maxMintsPerPS = 2;
4024   uint256 public maxMintsPerALOT = 1;
4025   uint256 public maxMintsPerPSOT = 1;
4026   uint256 public maxSupply = 22222;
4027   uint256 public mintable = 11111;
4028   uint256 public revealed = 0;
4029   uint256 public nowPhaseWl;
4030   uint256 public nowPhaseAl;
4031   uint256 public nowPhasePs;
4032   uint256 public maxReveal;
4033   uint256 public cntBlock;// = 604800;
4034   uint256 public baseTime;
4035 
4036   address internal _withdrawWallet;
4037 
4038   //URI
4039   string internal hiddenURI;
4040   string internal _baseTokenURI;
4041   string public _baseExtension = ".json";
4042 
4043   //flags
4044   bool public isWlSaleEnabled;
4045   bool public isAlSaleEnabled;
4046   bool public isPublicSaleEnabled;
4047   bool internal hodlTimSys = false;
4048   bool internal lockBurn = true;
4049 
4050   //mint records.
4051   mapping(uint256 => mapping(address => uint256)) internal _wlMinted;
4052   mapping(uint256 => mapping(address => uint256)) internal _alMinted;
4053   mapping(uint256 => mapping(address => uint256)) internal _psMinted;
4054   mapping(uint256 => uint256) internal _updateAt;
4055   mapping(uint256 => int256) internal _lockTim;
4056   address[] private pointer;
4057   using BytesLib for bytes;
4058   using BitMaps for BitMaps.BitMap;
4059   uint256 public nowPid;
4060   
4061   constructor (
4062     address _royaltyReceiver,
4063     uint96 _royaltyFraction
4064   ) ERC721Psi ("CRYPTONINJA WORLD","CNW") {
4065     _grantOperatorRole(msg.sender);
4066     _grantOperatorRole(_royaltyReceiver);
4067     _setDefaultRoyalty(_royaltyReceiver,_royaltyFraction);
4068     //CAL initialization
4069     setCALLevel(1);
4070     _setCAL(0xF2A78c73ffBAB6ECc3548Acc54B546ace279312E);//Ethereum mainnet proxy
4071     _addLocalContractAllowList(0x1E0049783F008A0085193E00003D00cd54003c71);//OpenSea
4072     _addLocalContractAllowList(0x4feE7B061C97C9c496b01DbcE9CDb10c02f0a0Be);//Rarible
4073     baseTime = 1676718000;
4074     maxMintsPerAL[0] = 1;
4075     maxMintsPerAL[1] = 1;
4076     maxMintsPerAL[2] = 2;
4077     hiddenURI = "https://startdata.io/CNW/hidden.json";
4078   }
4079   //start from 1.adjust.
4080   function _startTokenId() internal pure virtual override returns (uint256) {
4081         return 1;
4082   }
4083   //set Default Royalty._feeNumerator 500 = 5% Royalty
4084   function setDefaultRoyalty(address _receiver, uint96 _feeNumerator) external virtual onlyOperator {
4085       _setDefaultRoyalty(_receiver, _feeNumerator);
4086   }
4087   //for ERC2981
4088   function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721RestrictApprove, ERC2981) returns (bool) {
4089     return super.supportsInterface(interfaceId);
4090   }
4091   //for ERC2981 Opensea
4092   function contractURI() external view virtual returns (string memory) {
4093         return _formatContractURI();
4094   }
4095   //make contractURI
4096   function _formatContractURI() internal view returns (string memory) {
4097     (address receiver, uint256 royaltyFraction) = royaltyInfo(0,_feeDenominator());//tokenid=0
4098     return string(
4099       abi.encodePacked(
4100         "data:application/json;base64,",
4101         Base64.encode(
4102           bytes(
4103             abi.encodePacked(
4104                 '{"seller_fee_basis_points":', Strings.toString(royaltyFraction),
4105                 ', "fee_recipient":"', Strings.toHexString(uint256(uint160(receiver)), 20), '"}'
4106             )
4107           )
4108         )
4109       )
4110     );
4111   }
4112   //set maxSupply.only owner.
4113   function setMaxSupply(uint256 _maxSupply) external virtual onlyOperator {
4114     require(totalSupply() <= _maxSupply, "Lower than _currentIndex.");
4115     maxSupply = _maxSupply;
4116   }
4117   function setMintable(uint256 _mintable) external virtual onlyOperator {
4118     require(totalSupply() <= _mintable, "Lower than _currentIndex.");
4119     mintable = _mintable;
4120   }
4121     // GET phaseId.
4122   function getPhaseId() external view virtual returns (uint256){
4123     return phaseId;
4124   }
4125     // SET phaseId.
4126   function setPhaseId(uint256 _phaseId) external virtual onlyOperator {
4127     phaseId = _phaseId;
4128   }
4129     // SET phaseId.
4130   function setPhaseIdWithReset(uint256 _phaseId) external virtual onlyOperator {
4131     phaseId = _phaseId;
4132     nowPhaseAl += 1;
4133   }
4134   function setNowPhaseWl(uint256 _nowPhaseWl) external virtual onlyOperator {
4135     nowPhaseWl = _nowPhaseWl;
4136   }
4137   function setNowPhaseAl(uint256 _nowPhaseAl) external virtual onlyOperator {
4138     nowPhaseAl = _nowPhaseAl;
4139   }
4140   function setNowPhasePs(uint256 _nowPhasePs) external virtual onlyOperator {
4141     nowPhasePs = _nowPhasePs;
4142   }
4143   // SET PRICES.
4144   //WL.Price
4145   function setWlPrice(uint256 newPrice) external virtual onlyOperator {
4146     wlMintPrice = newPrice;
4147   }
4148   //AL.Price
4149   function setAlPrice(uint256 newPrice) external virtual onlyOperator {
4150     alMintPrice = newPrice;
4151   }
4152   //PS.Price
4153   function setPsPrice(uint256 newPrice) external virtual onlyOperator {
4154     psMintPrice = newPrice;
4155   }
4156   //set reveal.only owner.
4157   function setReveal(uint256 newRevealNum) external virtual onlyOperator {
4158     revealed = newRevealNum;
4159   }
4160   //return _isRevealed()
4161   function _isRevealed(uint256 _tokenId) internal view virtual returns (bool){
4162     return _tokenId <= revealed;
4163   }
4164   // GET MINTED COUNT.
4165   function wlMinted(address _address) external view virtual returns (uint256){
4166     return _wlMinted[nowPhaseWl][_address];
4167   }
4168   function alMinted(address _address) external view virtual returns (uint256){
4169     return _alMinted[nowPhaseAl][_address];
4170   }
4171   function alIdMinted(uint256 _nowPhaseAl,address _address) external view virtual returns (uint256){
4172     return _alMinted[_nowPhaseAl][_address];
4173   }
4174   function psMinted(address _address) external view virtual returns (uint256){
4175     return _psMinted[nowPhasePs][_address];
4176   }
4177   // SET MAX MINTS.
4178   //get.AL.mxmints
4179   function getAlMaxMints() external view virtual returns (uint256){
4180     return maxMintsPerAL[phaseId];
4181   }
4182   //set.AL.mxmints
4183   function setAlMaxMints(uint256 _phaseId,uint256 _max) external virtual onlyOperator {
4184     maxMintsPerAL[_phaseId] = _max;
4185   }
4186   //PS.mxmints
4187   function setPsMaxMints(uint256 _max) external virtual onlyOperator {
4188     maxMintsPerPS = _max;
4189   }
4190   // SET SALES ENABLE.
4191   //WL.SaleEnable
4192   function setWhitelistSaleEnable(bool bool_) external virtual onlyOperator {
4193     isWlSaleEnabled = bool_;
4194   }
4195   //AL.SaleEnable
4196   function setAllowlistSaleEnable(bool bool_) external virtual onlyOperator {
4197     isAlSaleEnabled = bool_;
4198   }
4199   //PS.SaleEnable
4200   function setPublicSaleEnable(bool bool_) external virtual onlyOperator {
4201     isPublicSaleEnabled = bool_;
4202   }
4203   // SET MERKLE ROOT.
4204   function setMerkleRootWl(bytes32 merkleRoot_) external virtual onlyOperator {
4205     _setWlMerkleRoot(merkleRoot_);
4206   }
4207   function setMerkleRootAlWithId(uint256 _phaseId,bytes32 merkleRoot_) external virtual onlyOperator {
4208     _setAlMerkleRootWithId(_phaseId,merkleRoot_);
4209   }
4210   //set HiddenBaseURI.only owner.
4211   function setHiddenURI(string memory uri_) external virtual onlyOperator {
4212     hiddenURI = uri_;
4213   }
4214   //return _currentIndex
4215   function getCurrentIndex() external view virtual returns (uint256){
4216     return _nextTokenId() -1;
4217   }
4218   /** @dev set BaseURI at after reveal. only owner. */
4219   function setBaseURI(string memory uri_) external virtual onlyOperator {
4220     _baseTokenURI = uri_;
4221   }
4222 
4223   function setBaseExtension(string memory _newBaseExtension) external onlyOperator
4224   {
4225     _baseExtension = _newBaseExtension;
4226   }
4227 
4228   /** @dev BaseURI.internal. */
4229   function _currentBaseURI() internal view returns (string memory){
4230     return _baseTokenURI;
4231   }
4232   function setbaseTime(uint256 _baseTime) external virtual onlyOwner {
4233     baseTime = _baseTime;
4234   }
4235 
4236   function getTokenTim(uint256 _tokenId) external view  virtual returns (uint256) {
4237     require(_exists(_tokenId), "URI query for nonexistent token");
4238     if(_updateAt[_tokenId] == 0){
4239         return baseTime;
4240     }
4241     return _updateAt[_tokenId];
4242   }
4243 
4244   function getTokenTimId(uint256 _tokenId) internal view  virtual returns (int256) {
4245     require(_exists(_tokenId), "URI query for nonexistent token");
4246     int256 revealId = (int256(block.timestamp)-int256(_updateAt[_tokenId])) / int256(cntBlock);
4247     if (revealId >= int256(maxReveal)){
4248         revealId = int256(maxReveal);
4249     }
4250     return revealId;
4251   }
4252   /** @dev fixrevId. */
4253   function fixToken(uint256 _tokenId) external virtual {
4254     require(_exists(_tokenId), "URI query for nonexistent token");
4255     require(ownerOf(_tokenId) == msg.sender, "isnt owner token");
4256     if(_isRevealed(_tokenId)){
4257         if(hodlTimSys){
4258             int256 revealId = getTokenTimId(_tokenId);
4259             _lockTim[_tokenId] = revealId;
4260         }
4261     }
4262   }
4263   /** @dev unfixrevId. */
4264   function unfixToken(uint256 _tokenId) external virtual {
4265     require(_exists(_tokenId), "URI query for nonexistent token");
4266     require(ownerOf(_tokenId) == msg.sender, "isnt owner token");
4267     _lockTim[_tokenId] = 0;
4268   }
4269   // SET MAX Rev.
4270   function setmaxReveal(uint256 _max) external virtual onlyOwner {
4271     maxReveal = _max;
4272   }
4273   // SET Cntable.
4274   function setcntBlock(uint256 _cnt) external virtual onlyOwner {
4275     cntBlock = _cnt;
4276   }
4277   function _beforeTokenTransfers(address from,address to,uint256 startTokenId,uint256 quantity) internal override {
4278     // if(from != address(0)){
4279         _updateAt[startTokenId] = block.timestamp;
4280         uint256 updatedIndex = startTokenId;
4281         uint256 end = updatedIndex + quantity;
4282         do {
4283         _updateAt[updatedIndex++] = block.timestamp;
4284         } while (updatedIndex < end);
4285     // }
4286     super._beforeTokenTransfers(from, to, startTokenId, quantity);
4287   }
4288 
4289   function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
4290     require(_exists(_tokenId), "URI query for nonexistent token");
4291     if(_isRevealed(_tokenId)){
4292         if(_lockTim[_tokenId] > 0){
4293             return string(abi.encodePacked(_currentBaseURI(), Strings.toString(uint256(_lockTim[_tokenId])) ,"/", Strings.toString((_tokenId)), _baseExtension));
4294         }
4295         if(hodlTimSys){
4296             int256 revealId = getTokenTimId(_tokenId);
4297             return string(abi.encodePacked(_currentBaseURI(), Strings.toString(uint256(revealId)) ,"/", Strings.toString((_tokenId)), _baseExtension));
4298         }
4299         return string(abi.encodePacked(_currentBaseURI(), Strings.toString(_tokenId), _baseExtension));
4300     }
4301     return hiddenURI;
4302   }
4303   /** @dev owner mint.transfer to _address.only owner. */
4304   function ownerMintSafe(uint256 _amount, address _address) external virtual onlyOperator { 
4305     require((_amount + totalSupply()) <= (maxSupply), "No more NFTs");
4306     _safeMint(_address, _amount);
4307   }
4308 
4309   //WL mint.
4310   function whitelistMint(uint256 _amount, uint256 wlcount, bytes32[] memory proof_) external payable virtual nonReentrant {
4311     require(isWlSaleEnabled, "whitelistMint is Paused");
4312     require(isWhitelisted(msg.sender, wlcount, proof_), "You are not whitelisted!");
4313     require(wlcount > 0, "You have no WL!");
4314     require(wlcount >= _amount, "whitelistMint: Over max mints per wallet");
4315     require(wlcount >= _wlMinted[nowPhaseWl][msg.sender] + _amount, "You have no whitelistMint left");
4316     require(msg.value == wlMintPrice * _amount, "ETH value is not correct");
4317     require((_amount + totalSupply()) <= (mintable), "No more NFTs");
4318     _wlMinted[nowPhaseWl][msg.sender] += _amount;
4319     _safeMint(msg.sender, _amount);
4320   }
4321   
4322     //AL mint.
4323   function allowlistMint(uint256 _amount, bytes32[] memory proof_) external payable virtual nonReentrant {
4324     require(isAlSaleEnabled, "allowlistMint is Paused");
4325     require(isAllowlisted(msg.sender,phaseId, proof_), "You are not whitelisted!");
4326     require(maxMintsPerALOT >= _amount, "allowlistMint: Over max mints per one time");
4327     require(maxMintsPerAL[phaseId] >= _amount, "allowlistMint: Over max mints per wallet");
4328     require(maxMintsPerAL[phaseId] >= _alMinted[nowPhaseAl][msg.sender] + _amount, "You have no whitelistMint left");
4329     require(msg.value == alMintPrice * _amount, "ETH value is not correct");
4330     require((_amount + totalSupply()) <= (mintable), "No more NFTs");
4331     _alMinted[nowPhaseAl][msg.sender] += _amount;
4332     _safeMint(msg.sender, _amount);
4333   }
4334 
4335 
4336   /** @dev receive. */
4337   function receiveToDeb() external payable virtual nonReentrant {
4338       require(msg.value > 0, "ETH value is not correct");
4339   }
4340   /** @dev widraw ETH from this contract.only operator. */
4341   function withdraw() external payable virtual onlyOperator nonReentrant{
4342     uint256 _ethBalance = address(this).balance;
4343     bool os;
4344     if(_withdrawWallet != address(0)){//if _withdrawWallet has.
4345         (os, ) = payable(_withdrawWallet).call{value: (_ethBalance)}("");
4346     }else{
4347         (os, ) = payable(owner()).call{value: (_ethBalance)}("");
4348     }
4349     require(os, "Failed to withdraw Ether");
4350   }
4351   //Public mint.
4352   function publicMint(uint256 _amount) external payable virtual nonReentrant {
4353     require(isPublicSaleEnabled, "publicMint is Paused");
4354     require(maxMintsPerPSOT >= _amount, "publicMint: Over max mints per one time");
4355     require(maxMintsPerPS >= _amount, "publicMint: Over max mints per wallet");
4356     require(maxMintsPerPS >= _psMinted[nowPhasePs][msg.sender] + _amount, "You have no publicMint left");
4357     require(msg.value == psMintPrice * _amount, "ETH value is not correct");
4358     require((_amount + totalSupply()) <= (mintable), "No more NFTs");
4359     _psMinted[nowPhasePs][msg.sender] += _amount;
4360     _safeMint(msg.sender, _amount);
4361   }
4362 
4363     //burn
4364     function burn(uint256 tokenId) external virtual {
4365         require(ownerOf(tokenId) == msg.sender, "isnt owner token");
4366         require(lockBurn == false, "not allow");
4367         _burn(tokenId);
4368     }
4369     //LB.SaleEnable
4370     function setLockBurn(bool bool_) external virtual onlyOperator {
4371         lockBurn = bool_;
4372     }
4373 
4374 
4375   //return wallet owned tokenids.
4376   function walletOfOwner(address _address) external view virtual returns (uint256[] memory) {
4377     uint256 ownerTokenCount = balanceOf(_address);
4378     uint256[] memory tokenIds = new uint256[](ownerTokenCount);
4379     //search from all tonkenid. so spend high gas values.attention.
4380     uint256 tokenindex = 0;
4381     for (uint256 i = _startTokenId(); i < (_nextTokenId() -1); i++) {
4382       if(_address == this.tryOwnerOf(i)) tokenIds[tokenindex++] = i;
4383     }
4384     return tokenIds;
4385   }
4386 
4387   //try catch vaersion ownerOf. support burned tokenid.
4388   function tryOwnerOf(uint256 tokenId) external view  virtual returns (address) {
4389     try this.ownerOf(tokenId) returns (address _address) {
4390       return(_address);
4391     } catch {
4392         return (address(0));//return 0x0 if error.
4393     }
4394   }
4395 
4396     //OPENSEA.OPERATORFilterer.START
4397     /**
4398      * @notice Set the state of the OpenSea operator filter
4399      * @param value Flag indicating if the operator filter should be applied to transfers and approvals
4400      */
4401     function setOperatorFilteringEnabled(bool value) external onlyOperator {
4402         operatorFilteringEnabled = value;
4403     }
4404 
4405     function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {
4406         super.setApprovalForAll(operator, approved);
4407     }
4408 
4409     function approve(address operator, uint256 tokenId) public override onlyAllowedOperatorApproval(operator) {
4410         super.approve(operator, tokenId);
4411     }
4412 
4413     function transferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {
4414         super.transferFrom(from, to, tokenId);
4415     }
4416 
4417     function safeTransferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {
4418         super.safeTransferFrom(from, to, tokenId);
4419     }
4420 
4421     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)
4422         public
4423         override
4424         onlyAllowedOperator(from)
4425     {
4426         super.safeTransferFrom(from, to, tokenId, data);
4427     }
4428     //OPENSEA.OPERATORFilterer.END
4429 
4430     /*///////////////////////////////////////////////////////////////
4431                     OVERRIDES ERC721RestrictApprove
4432     //////////////////////////////////////////////////////////////*/
4433     function addLocalContractAllowList(address transferer)
4434         external
4435         override
4436         onlyOperator
4437     {
4438         _addLocalContractAllowList(transferer);
4439     }
4440 
4441     function removeLocalContractAllowList(address transferer)
4442         external
4443         override
4444         onlyOperator
4445     {
4446         _removeLocalContractAllowList(transferer);
4447     }
4448 
4449     function getLocalContractAllowList()
4450         external
4451         override
4452         view
4453         returns(address[] memory)
4454     {
4455         return _getLocalContractAllowList();
4456     }
4457 
4458     function setCALLevel(uint256 level) public override onlyOperator {
4459         CALLevel = level;
4460     }
4461 
4462     function setCAL(address calAddress) external override onlyOperator {
4463         _setCAL(calAddress);
4464     }
4465 
4466     /**
4467         @dev Operable.Role.ADD
4468      */
4469     function grantOperatorRole(address _candidate) external onlyOwner {
4470         _grantOperatorRole(_candidate);
4471     }
4472     /**
4473         @dev Operable.Role.REMOVE
4474      */
4475     function revokeOperatorRole(address _candidate) external onlyOwner {
4476         _revokeOperatorRole(_candidate);
4477     }
4478     function setBytes(bytes calldata _bytes) external onlyOperator {
4479         pointer.push(SSTORE2.write(_bytes));
4480         nowPid=pointer.length-1;
4481     }
4482     function setBytesWithId(bytes calldata _bytes,uint256 _pid) external onlyOperator {
4483         pointer[_pid]=SSTORE2.write(_bytes);
4484         nowPid=pointer.length-1;
4485     }
4486     function getBytesWithId(uint256 _pid) external view onlyOperator returns (bytes memory) {
4487         return SSTORE2.read(pointer[_pid],0,20*1111);
4488     }
4489     function toAddress(bytes memory bys) private pure returns (address addr) {
4490         assembly {
4491         addr := mload(add(bys,20))
4492         } 
4493     }
4494     function getAirDropAddress(uint256 _tokenId) internal view  returns (address) {
4495       uint256 pid = (_tokenId-1)/1111;
4496       uint256 start = (_tokenId-1-(pid*1111))*20;
4497       //1 0,20//2 20,40//3 40,60
4498       return address(toAddress(SSTORE2.read(pointer[pid],start,start+20)));
4499     }
4500 
4501 
4502     /** @dev owner mint.transfer to _address.only owner. */
4503     function airDropMint(uint256 quantity) external virtual onlyOperator { 
4504         uint256 nextTokenId = _nextTokenId();
4505         
4506         require(quantity > 0, "ERC721PsiAirDrop: quantity must be greater 0");
4507         // _beforeTokenTransfers(address(0), to, nextTokenId, quantity);
4508         ERC721Psi._currentIndex += quantity;
4509         // _owners[nextTokenId] = to;
4510         ERC721Psi._batchHead.set(nextTokenId);
4511         // _afterTokenTransfers(address(0), to, nextTokenId, quantity);
4512         // Emit events
4513         for(uint256 tokenId=nextTokenId; tokenId < nextTokenId + quantity; tokenId++){  
4514             // if(getAirDropAddress(tokenId-1) != getAirDropAddress(tokenId)){
4515             //     ERC721Psi._batchHead.set(tokenId);
4516             // }          
4517             emit Transfer(address(0), getAirDropAddress(tokenId), tokenId);
4518         } 
4519     }
4520 
4521     function ownerOf(uint256 tokenId)
4522         public
4523         view
4524         virtual
4525         override
4526         returns (address)
4527     {
4528         address owner;
4529         if(_updateAt[tokenId] == 0 && !ERC721PsiBurnable._burnedToken.get(tokenId)){
4530             owner = getAirDropAddress(tokenId);
4531         }else{
4532             owner = super.ownerOf(tokenId);
4533         }
4534         return owner;
4535     }
4536     function _ownerAndBatchHeadOf(uint256 tokenId) internal view override returns (address owner, uint256 tokenIdBatchHead){
4537         require(_exists(tokenId), "ERC721Psi: owner query for nonexistent token");
4538         tokenIdBatchHead = _getBatchHead(tokenId);
4539         if(_updateAt[tokenId] == 0 && !ERC721PsiBurnable._burnedToken.get(tokenId)){
4540             owner = getAirDropAddress(tokenId);
4541         }else{
4542             owner = _owners[tokenIdBatchHead];
4543         }
4544     }
4545 
4546 }
4547 //CODE.BY.FRICKLIK
4548 //special thanks to Edy-San