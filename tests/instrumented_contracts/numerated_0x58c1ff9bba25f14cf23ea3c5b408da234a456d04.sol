1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/xRooStaking.sol": {
5       "content": "pragma solidity ^0.8.7;\r\nimport \"../nftx/interface/INFTXVault.sol\";\r\nimport \"../nftx/interface/INFTXLPStaking.sol\";\r\nimport \"../nftx/interface/IUniswapV2Router01.sol\";\r\nimport \"../nftx/interface/IVaultTokenUpgradeable.sol\";\r\nimport \"../nftx/interface/IRewardDistributionToken.sol\";\r\nimport {IWETH} from \"../nftx/interface/INFTXStakingZap.sol\";\r\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\ncontract xRooStaking is Ownable {\r\n    using PRBMathUD60x18 for uint256;\r\n    event Staked(\r\n        address indexed _user,\r\n        uint256 _stake,\r\n        uint256 _liquidity,\r\n        uint256 _weth\r\n    );\r\n    event Unstaked(address indexed _user, uint256 _stake, uint256 _liquidity);\r\n\r\n    // --------- NFTX CONTRACTS/VARIABLES -------------\r\n    INFTXVault public NFTXVault;\r\n    INFTXLPStaking public NFTXLPStaking;\r\n    IRewardDistributionToken public NFTXRewardDistributionToken;\r\n    uint256 constant base = 10**18; // 18 decimal places\r\n    uint256 NFTXRewardPerLiquidity;\r\n\r\n    IWETH public WETH;\r\n\r\n    // --------- SUSHI CONTRACTS ------------\r\n    IUniswapV2Router01 public sushiRouter;\r\n    IERC20 public SLPToken;\r\n\r\n    // --------- INTERNAL CONTRACTS/VARIABLES ---------\r\n    IERC20 public RTRewardToken;\r\n    IERC721 public RTStakedToken;\r\n\r\n    uint256 public rewardPeriod;\r\n    uint256 public periodicReward;\r\n    uint256 public lockTime;\r\n\r\n    // at the start, RT rewards will not be withdrawable\r\n    bool public lockRTRewards = true;\r\n\r\n    // --------- STRUCTS --------------------\r\n    struct UserData {\r\n        uint256 stake;\r\n        uint256 liquidity;\r\n        uint256 lastTimestamp;\r\n        int256 RTRewardModifier;\r\n        int256 NFTXRewardModifier;\r\n        uint256 NFTXRewardWithdrawn;\r\n    }\r\n\r\n    struct Dividend {\r\n        uint256 RTRewardToken;\r\n        uint256 NFTXRewardToken;\r\n    }\r\n\r\n    // --------- CONTRACT DATA --------------\r\n    mapping(address => UserData) public users;\r\n\r\n    // ---------- EXTERNAL CONTRACT METHODS ----------\r\n    constructor(\r\n        address _NFTXVault,\r\n        address _NFTXLPStaking,\r\n        address _NFTXRewardDistributionToken,\r\n        address _sushiRouter,\r\n        address _SLPToken,\r\n        address _RTRewardToken,\r\n        address _RTStakedToken,\r\n        uint256 _rewardPeriod,\r\n        uint256 _periodicReward,\r\n        uint256 _lockTime\r\n    ) {\r\n        RTRewardToken = IERC20(_RTRewardToken);\r\n        RTStakedToken = IERC721(_RTStakedToken);\r\n        rewardPeriod = _rewardPeriod;\r\n        periodicReward = _periodicReward;\r\n        lockTime = _lockTime;\r\n\r\n        updateExternalReferences(\r\n            _NFTXVault,\r\n            _NFTXLPStaking,\r\n            _NFTXRewardDistributionToken,\r\n            _sushiRouter,\r\n            _SLPToken\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Updates all external references (NFTX/Sushiswap/WETH).\r\n     * @dev only for the contract owner to use, particularly in the case of near-FUBAR.\r\n     * @param _NFTXVault the vault token address\r\n     * @param _NFTXLPStaking the NFTXLPStaking contract address\r\n     * @param _NFTXRewardDistributionToken the NFTX Reward distribution token\r\n     * @param _sushiRouter the address of the Sushiswap router\r\n     * @param _SLPToken the address of the liquidity pool WETH/vault token\r\n     */\r\n    function updateExternalReferences(\r\n        address _NFTXVault,\r\n        address _NFTXLPStaking,\r\n        address _NFTXRewardDistributionToken,\r\n        address _sushiRouter,\r\n        address _SLPToken\r\n    ) public onlyOwner {\r\n        // ASSIGNMENTS\r\n        NFTXVault = INFTXVault(_NFTXVault);\r\n        NFTXLPStaking = INFTXLPStaking(_NFTXLPStaking);\r\n        NFTXRewardDistributionToken = IRewardDistributionToken(\r\n            _NFTXRewardDistributionToken\r\n        );\r\n        WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());\r\n        sushiRouter = IUniswapV2Router01(_sushiRouter);\r\n        SLPToken = IERC20(_SLPToken);\r\n\r\n        // APPROVALS\r\n        IERC20Upgradeable(address(WETH)).approve(\r\n            _sushiRouter,\r\n            type(uint256).max\r\n        );\r\n        SLPToken.approve(_sushiRouter, type(uint256).max);\r\n        NFTXRewardDistributionToken.approve(\r\n            address(NFTXLPStaking),\r\n            type(uint256).max\r\n        );\r\n        NFTXVault.approve(address(sushiRouter), type(uint256).max);\r\n        SLPToken.approve(address(NFTXLPStaking), type(uint256).max);\r\n    }\r\n\r\n    /**\r\n     * Updates the address for the reward token.\r\n     * @param _token the token in which rewards will be disbursed.\r\n     */\r\n    function setRTRewardToken(address _token) external onlyOwner {\r\n        RTRewardToken = IERC20(_token);\r\n    }\r\n\r\n    /**\r\n     * Locks/unlocks RT reward withdraw\r\n     * @param _locked the value of the lock (boolean)\r\n     */\r\n    function setLock(bool _locked) external onlyOwner {\r\n        lockRTRewards = _locked;\r\n    }\r\n\r\n    /**\r\n     * Sets the lock time where assets cannot be removed after staking.\r\n     * @param _lockTime the amount of seconds the lock lasts after staking\r\n     */\r\n    function setLockTime(uint256 _lockTime) external onlyOwner {\r\n        require(_lockTime > 0);\r\n        lockTime = _lockTime;\r\n    }\r\n\r\n    /**\r\n     * Adds liquidity to the pool using the stakable ERC721 token\r\n     * and WETH.\r\n     * @param _minWethIn the min amount of WETH that will get sent to the LP\r\n     * @param _wethIn the amount of WETH that has been provided by the call\r\n     * @param _ids the ids of the tokens to stake\r\n     */\r\n    function addLiquidityERC721(\r\n        uint256 _minWethIn,\r\n        uint256 _wethIn,\r\n        uint256[] calldata _ids\r\n    ) external {\r\n        uint256 initialWETH = IERC20Upgradeable(address(WETH)).balanceOf(\r\n            address(this)\r\n        );\r\n\r\n        IERC20Upgradeable(address(WETH)).transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            _wethIn\r\n        );\r\n        _addLiquidityERC721(msg.sender, _minWethIn, _wethIn, _ids);\r\n\r\n        uint256 WETHRefund = IERC20Upgradeable(address(WETH)).balanceOf(\r\n            address(this)\r\n        ) - initialWETH;\r\n\r\n        if (WETHRefund < _wethIn && WETHRefund > 0)\r\n            WETH.transfer(msg.sender, WETHRefund);\r\n    }\r\n\r\n    /**\r\n     * Adds liquidity to the pool using the stakable ERC721 token\r\n     * and ETH.\r\n     * @param _minWethIn the min amount of WETH that will get sent to the LP\r\n     * @param _ids the ids of the tokens to stake\r\n     * @dev the value passed in is converted to WETH and sent to the LP.\r\n     */\r\n    function addLiquidityERC721ETH(uint256 _minWethIn, uint256[] calldata _ids)\r\n        external\r\n        payable\r\n    {\r\n        uint256 initialWETH = IERC20Upgradeable(address(WETH)).balanceOf(\r\n            address(this)\r\n        );\r\n\r\n        WETH.deposit{value: msg.value}();\r\n\r\n        _addLiquidityERC721(msg.sender, _minWethIn, msg.value, _ids);\r\n\r\n        uint256 wethRefund = IERC20Upgradeable(address(WETH)).balanceOf(\r\n            address(this)\r\n        ) - initialWETH;\r\n\r\n        // Return extras.\r\n        if (wethRefund < msg.value && wethRefund > 0) {\r\n            WETH.withdraw(wethRefund);\r\n            (bool success, ) = payable(msg.sender).call{value: wethRefund}(\"\");\r\n            require(success, \"Refund failed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds liquidity to the pool using the stakable ERC20 token\r\n     * and WETH.\r\n     * @param _minWethIn the min amount of WETH that will get sent to the LP\r\n     * @param _wethIn the amount of WETH that has been provided by the call\r\n     * @param _amount the amount of the ERC20 token to stake\r\n     */\r\n    function addLiquidityERC20(\r\n        uint256 _minWethIn,\r\n        uint256 _wethIn,\r\n        uint256 _amount\r\n    ) external {\r\n        IERC20Upgradeable(address(WETH)).transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            _wethIn\r\n        );\r\n\r\n        (, uint256 amountWETH, ) = _addLiquidityERC20(\r\n            msg.sender,\r\n            _minWethIn,\r\n            _wethIn,\r\n            _amount\r\n        );\r\n\r\n        // refund unused WETH\r\n        if (amountWETH < _wethIn && _wethIn - amountWETH > 0) {\r\n            WETH.transfer(msg.sender, _wethIn - amountWETH);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds liquidity to the pool using the stakable ERC20 token\r\n     * and ETH.\r\n     * @param _minWethIn the min amount of WETH that will get sent to the LP\r\n     * @param _amount the amount of the ERC20 token to stake\r\n     * @dev the value passed in is converted to WETH and sent to the LP.\r\n     */\r\n    function addLiquidityERC20ETH(uint256 _minWethIn, uint256 _amount)\r\n        external\r\n        payable\r\n    {\r\n        WETH.deposit{value: msg.value}();\r\n\r\n        (, uint256 amountWETH, ) = _addLiquidityERC20(\r\n            msg.sender,\r\n            _minWethIn,\r\n            msg.value,\r\n            _amount\r\n        );\r\n\r\n        // refund unused ETH\r\n        if (amountWETH < msg.value && msg.value - amountWETH > 0) {\r\n            WETH.withdraw(msg.value - amountWETH);\r\n            (bool sent, ) = payable(msg.sender).call{\r\n                value: msg.value - amountWETH\r\n            }(\"\");\r\n            require(sent, \"refund failed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all liquidity from the LP and claims rewards.\r\n     * @param _amountTokenMin the min amount of the ERC20 staking token to get back\r\n     * @param _amountWETHMin the min amount of WETH to get back\r\n     *\r\n     * NOTE you cannot withdraw until the timelock has expired.\r\n     */\r\n    function removeLiquidity(uint256 _amountTokenMin, uint256 _amountWETHMin)\r\n        external\r\n    {\r\n        require(\r\n            users[msg.sender].lastTimestamp + lockTime < block.timestamp,\r\n            \"Locked\"\r\n        );\r\n        _removeLiquidity(msg.sender, _amountTokenMin, _amountWETHMin);\r\n    }\r\n\r\n    /**\r\n     * Claims all of the dividends currently owed to the caller.\r\n     * Will not claim RT rewards if the lock is set.\r\n     */\r\n    function claimRewards() external {\r\n        _claimRewards(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Gets the rewards owed to the user.\r\n     */\r\n    function dividendOf(address _user) external view returns (Dividend memory) {\r\n        return _dividendOf(_user);\r\n    }\r\n\r\n    /**\r\n     * An emergency function that will allow users to pull out their liquidity in the NFTX\r\n     * reward distribution token. DOES NOT DISTRIBUTE REWARDS. This is to be used in the\r\n     * case where our connection with NFTX's contracts causes transaction failures.\r\n     *\r\n     * NOTE you cannot withdraw until the timelock has expired.\r\n     */\r\n    function emergencyExit() external {\r\n        require(\r\n            users[msg.sender].lastTimestamp + lockTime < block.timestamp,\r\n            \"Locked\"\r\n        );\r\n        _emergencyExit(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Shows the time until the user's funds are unlocked (unix seconds).\r\n     * @param _user the user whose lock time we are checking\r\n     */\r\n    function lockedUntil(address _user) external view returns (uint256) {\r\n        require(users[_user].lastTimestamp != 0, \"N/A\");\r\n        return users[_user].lastTimestamp + lockTime;\r\n    }\r\n\r\n    // ---------- INTERNAL CONTRACT METHODS ----------\r\n    function _totalLiquidityStaked() internal view returns (uint256) {\r\n        return NFTXRewardDistributionToken.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * An emergency escape in the unlikely case of a contract error\r\n     * causing unstaking methods to fail.\r\n     */\r\n    function _emergencyExit(address _user) internal {\r\n        uint256 liquidity = users[_user].liquidity;\r\n        delete users[_user];\r\n\r\n        NFTXRewardDistributionToken.transfer(_user, liquidity);\r\n    }\r\n\r\n    function _claimContractNFTXRewards() internal {\r\n        uint256 currentRewards = NFTXVault.balanceOf(address(this));\r\n        uint256 dividend = NFTXRewardDistributionToken.dividendOf(\r\n            address(this)\r\n        );\r\n        if (dividend == 0) return;\r\n\r\n        NFTXLPStaking.claimRewards(NFTXVault.vaultId());\r\n        require(\r\n            NFTXVault.balanceOf(address(this)) == currentRewards + dividend,\r\n            \"Unexpected balance\"\r\n        );\r\n\r\n        NFTXRewardPerLiquidity += dividend.div(_totalLiquidityStaked());\r\n    }\r\n\r\n    function _addLiquidityERC721(\r\n        address _user,\r\n        uint256 _minWethIn,\r\n        uint256 _wethIn,\r\n        uint256[] calldata _ids\r\n    )\r\n        internal\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountWETH,\r\n            uint256 liquidity\r\n        )\r\n    {\r\n        _claimContractNFTXRewards();\r\n        uint256 initialRewardToken = NFTXVault.balanceOf(address(this));\r\n\r\n        for (uint256 i = 0; i < _ids.length; i++) {\r\n            RTStakedToken.transferFrom(_user, address(this), _ids[i]);\r\n        }\r\n        RTStakedToken.setApprovalForAll(address(NFTXVault), true);\r\n        NFTXVault.mint(_ids, new uint256[](0));\r\n\r\n        uint256 newTokens = NFTXVault.balanceOf(address(this)) -\r\n            initialRewardToken;\r\n\r\n        return _stakeAndUpdate(_user, _minWethIn, _wethIn, newTokens);\r\n    }\r\n\r\n    /**\r\n     * Adds liquidity in ERC20 (the vault token)\r\n     */\r\n    function _addLiquidityERC20(\r\n        address _user,\r\n        uint256 _minWethIn,\r\n        uint256 _wethIn,\r\n        uint256 _amount\r\n    )\r\n        internal\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountWETH,\r\n            uint256 liquidity\r\n        )\r\n    {\r\n        _claimContractNFTXRewards();\r\n\r\n        NFTXVault.transferFrom(_user, address(this), _amount);\r\n        return _stakeAndUpdate(_user, _minWethIn, _wethIn, _amount);\r\n    }\r\n\r\n    /**\r\n     * Stakes on the SLP and then on NFTx's platform\r\n     * @dev All vault token and WETH should be owned by the\r\n     * contract before calling.\r\n     */\r\n    function _stakeAndUpdate(\r\n        address _user,\r\n        uint256 _minWethIn,\r\n        uint256 _wethIn,\r\n        uint256 _amount // amount of ERC20 vault token\r\n    )\r\n        internal\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountWETH,\r\n            uint256 liquidity\r\n        )\r\n    {\r\n        // stake on SUSHI\r\n        (\r\n            amountToken,\r\n            amountWETH, // amt used\r\n            liquidity\r\n        ) = sushiRouter.addLiquidity(\r\n            address(NFTXVault),\r\n            address(WETH),\r\n            _amount,\r\n            _wethIn,\r\n            _amount,\r\n            _minWethIn,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        NFTXLPStaking.deposit(NFTXVault.vaultId(), liquidity); // DEPOSIT IN NFTX\r\n\r\n        UserData memory userData = users[_user];\r\n\r\n        uint256 NFTXRewardModifier = liquidity.mul(NFTXRewardPerLiquidity);\r\n        uint256 currentNumPeriods = userData.lastTimestamp == 0\r\n            ? 0\r\n            : (block.timestamp - userData.lastTimestamp) / rewardPeriod;\r\n\r\n        userData.liquidity += liquidity;\r\n        userData.RTRewardModifier += int256(\r\n            currentNumPeriods * periodicReward.mul(userData.stake)\r\n        );\r\n        userData.lastTimestamp = block.timestamp;\r\n        userData.stake += _amount;\r\n        userData.NFTXRewardModifier -= int256(NFTXRewardModifier);\r\n\r\n        users[_user] = userData;\r\n\r\n        // return unstaked vault token\r\n        if (amountToken < _amount) {\r\n            NFTXVault.transfer(_user, _amount - amountToken);\r\n        }\r\n\r\n        emit Staked(_user, _amount, liquidity, amountWETH);\r\n    }\r\n\r\n    function _dividendOf(address _user)\r\n        internal\r\n        view\r\n        returns (Dividend memory)\r\n    {\r\n        uint256 updatedNFTXRewardPerLiquidity = NFTXRewardPerLiquidity +\r\n            NFTXRewardDistributionToken.dividendOf(address(this)).div(\r\n                _totalLiquidityStaked()\r\n            );\r\n\r\n        int256 nftxReward = int256(\r\n            (users[_user].liquidity.mul(updatedNFTXRewardPerLiquidity))\r\n        ) +\r\n            users[_user].NFTXRewardModifier -\r\n            int256(users[_user].NFTXRewardWithdrawn);\r\n\r\n        uint256 numPeriods = users[_user].lastTimestamp == 0\r\n            ? 0\r\n            : (block.timestamp - users[_user].lastTimestamp) / rewardPeriod;\r\n\r\n        int256 rtReward = int256(\r\n            numPeriods * periodicReward.mul(users[_user].stake)\r\n        ) + users[_user].RTRewardModifier;\r\n\r\n        require(nftxReward >= 0 && rtReward >= 0, \"Negative Reward\");\r\n\r\n        Dividend memory dividend;\r\n        dividend.NFTXRewardToken = uint256(nftxReward);\r\n        dividend.RTRewardToken = uint256(rtReward);\r\n\r\n        return dividend;\r\n    }\r\n\r\n    function _claimRewards(address _user) internal {\r\n        _claimContractNFTXRewards();\r\n\r\n        Dividend memory rewards = _dividendOf(_user);\r\n        if (rewards.NFTXRewardToken > 0) {\r\n            users[_user].NFTXRewardWithdrawn += rewards.NFTXRewardToken;\r\n            NFTXVault.transfer(_user, rewards.NFTXRewardToken);\r\n        }\r\n        if (rewards.RTRewardToken > 0 && !lockRTRewards) {\r\n            users[_user].RTRewardModifier -= int256(rewards.RTRewardToken);\r\n            RTRewardToken.transfer(_user, rewards.RTRewardToken);\r\n        }\r\n    }\r\n\r\n    function _removeLiquidity(\r\n        address _user,\r\n        uint256 _amountTokenMin,\r\n        uint256 _amountWETHMin\r\n    ) internal {\r\n        uint256 amount = users[_user].liquidity;\r\n        uint256 stake = users[_user].stake;\r\n        _claimRewards(_user);\r\n        delete users[_user];\r\n\r\n        // remove from NFTXLPStaking\r\n        NFTXLPStaking.withdraw(NFTXVault.vaultId(), amount); // gives us <amount> SLP\r\n        sushiRouter.removeLiquidity(\r\n            address(NFTXVault),\r\n            address(WETH),\r\n            amount,\r\n            _amountTokenMin,\r\n            _amountWETHMin,\r\n            _user, // send to user\r\n            block.timestamp\r\n        ); // return to user\r\n\r\n        emit Unstaked(_user, stake, amount);\r\n    }\r\n\r\n    receive() external payable {\r\n        // DO NOTHING\r\n    }\r\n}\r\n"
6     },
7     "nftx/interface/INFTXVault.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interface/INFTXEligibility.sol\";\nimport \"../token/IERC20Upgradeable.sol\";\nimport \"../interface/INFTXVaultFactory.sol\";\n\ninterface INFTXVault is IERC20Upgradeable {\n    function manager() external view returns (address);\n    function assetAddress() external view returns (address);\n    function vaultFactory() external view returns (INFTXVaultFactory);\n    function eligibilityStorage() external view returns (INFTXEligibility);\n\n    function is1155() external view returns (bool);\n    function allowAllItems() external view returns (bool);\n    function enableMint() external view returns (bool);\n    function enableRandomRedeem() external view returns (bool);\n    function enableTargetRedeem() external view returns (bool);\n    function enableRandomSwap() external view returns (bool);\n    function enableTargetSwap() external view returns (bool);\n\n    function vaultId() external view returns (uint256);\n    function nftIdAt(uint256 holdingsIndex) external view returns (uint256);\n    function allHoldings() external view returns (uint256[] memory);\n    function totalHoldings() external view returns (uint256);\n    function mintFee() external view returns (uint256);\n    function randomRedeemFee() external view returns (uint256);\n    function targetRedeemFee() external view returns (uint256);\n    function randomSwapFee() external view returns (uint256);\n    function targetSwapFee() external view returns (uint256);\n    function vaultFees() external view returns (uint256, uint256, uint256, uint256, uint256);\n\n    event VaultInit(\n        uint256 indexed vaultId,\n        address assetAddress,\n        bool is1155,\n        bool allowAllItems\n    );\n\n    event ManagerSet(address manager);\n    event EligibilityDeployed(uint256 moduleIndex, address eligibilityAddr);\n    // event CustomEligibilityDeployed(address eligibilityAddr);\n\n    event EnableMintUpdated(bool enabled);\n    event EnableRandomRedeemUpdated(bool enabled);\n    event EnableTargetRedeemUpdated(bool enabled);\n    event EnableRandomSwapUpdated(bool enabled);\n    event EnableTargetSwapUpdated(bool enabled);\n\n    event Minted(uint256[] nftIds, uint256[] amounts, address to);\n    event Redeemed(uint256[] nftIds, uint256[] specificIds, address to);\n    event Swapped(\n        uint256[] nftIds,\n        uint256[] amounts,\n        uint256[] specificIds,\n        uint256[] redeemedIds,\n        address to\n    );\n\n    function __NFTXVault_init(\n        string calldata _name,\n        string calldata _symbol,\n        address _assetAddress,\n        bool _is1155,\n        bool _allowAllItems\n    ) external;\n\n    function finalizeVault() external;\n\n    function setVaultMetadata(\n        string memory name_, \n        string memory symbol_\n    ) external;\n\n    function setVaultFeatures(\n        bool _enableMint,\n        bool _enableRandomRedeem,\n        bool _enableTargetRedeem,\n        bool _enableRandomSwap,\n        bool _enableTargetSwap\n    ) external;\n\n    function setFees(\n        uint256 _mintFee,\n        uint256 _randomRedeemFee,\n        uint256 _targetRedeemFee,\n        uint256 _randomSwapFee,\n        uint256 _targetSwapFee\n    ) external;\n    function disableVaultFees() external;\n\n    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.\n    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow\n    // a similar interface.\n    function deployEligibilityStorage(\n        uint256 moduleIndex,\n        bytes calldata initData\n    ) external returns (address);\n\n    // The manager has control over options like fees and features\n    function setManager(address _manager) external;\n\n    function mint(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts /* ignored for ERC721 vaults */\n    ) external returns (uint256);\n\n    function mintTo(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        address to\n    ) external returns (uint256);\n\n    function redeem(uint256 amount, uint256[] calldata specificIds)\n        external\n        returns (uint256[] calldata);\n\n    function redeemTo(\n        uint256 amount,\n        uint256[] calldata specificIds,\n        address to\n    ) external returns (uint256[] calldata);\n\n    function swap(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        uint256[] calldata specificIds\n    ) external returns (uint256[] calldata);\n\n    function swapTo(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        uint256[] calldata specificIds,\n        address to\n    ) external returns (uint256[] calldata);\n\n    function allValidNFTs(uint256[] calldata tokenIds)\n        external\n        view\n        returns (bool);\n}\n"
9     },
10     "nftx/interface/INFTXLPStaking.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface INFTXLPStaking {\n    function nftxVaultFactory() external view returns (address);\n    function rewardDistTokenImpl() external view returns (address);\n    function stakingTokenProvider() external view returns (address);\n    function vaultToken(address _stakingToken) external view returns (address);\n    function stakingToken(address _vaultToken) external view returns (address);\n    function rewardDistributionToken(uint256 vaultId) external view returns (address);\n    function newRewardDistributionToken(uint256 vaultId) external view returns (address);\n    function oldRewardDistributionToken(uint256 vaultId) external view returns (address);\n    function unusedRewardDistributionToken(uint256 vaultId) external view returns (address);\n    function rewardDistributionTokenAddr(address stakingToken, address rewardToken) external view returns (address);\n    \n    // Write functions.\n    function __NFTXLPStaking__init(address _stakingTokenProvider) external;\n    function setNFTXVaultFactory(address newFactory) external;\n    function setStakingTokenProvider(address newProvider) external;\n    function addPoolForVault(uint256 vaultId) external;\n    function updatePoolForVault(uint256 vaultId) external;\n    function updatePoolForVaults(uint256[] calldata vaultId) external;\n    function receiveRewards(uint256 vaultId, uint256 amount) external returns (bool);\n    function deposit(uint256 vaultId, uint256 amount) external;\n    function timelockDepositFor(uint256 vaultId, address account, uint256 amount, uint256 timelockLength) external;\n    function exit(uint256 vaultId, uint256 amount) external;\n    function rescue(uint256 vaultId) external;\n    function withdraw(uint256 vaultId, uint256 amount) external;\n    function claimRewards(uint256 vaultId) external;\n}"
12     },
13     "nftx/interface/IUniswapV2Router01.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB)\n        external\n        pure\n        returns (uint256 amountB);\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n"
15     },
16     "nftx/interface/IVaultTokenUpgradeable.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/IERC20Upgradeable.sol\";\n\ninterface IVaultTokenUpgradeable is IERC20Upgradeable {\n    function mint(address to, uint256 amount) external;\n\n    function burnFrom(address account, uint256 amount) external;\n}\n"
18     },
19     "nftx/interface/IRewardDistributionToken.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/IERC20Upgradeable.sol\";\n\ninterface IRewardDistributionToken is IERC20Upgradeable {\n  function distributeRewards(uint amount) external;\n  function __RewardDistributionToken_init(IERC20Upgradeable _target, string memory _name, string memory _symbol) external;\n  function mint(address account, address to, uint256 amount) external;\n  function burnFrom(address account, uint256 amount) external;\n  function withdrawReward(address user) external;\n  function dividendOf(address _owner) external view returns(uint256);\n  function withdrawnRewardOf(address _owner) external view returns(uint256);\n  function accumulativeRewardOf(address _owner) external view returns(uint256);\n}"
21     },
22     "nftx/interface/INFTXStakingZap.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./INFTXVault.sol\";\nimport \"./INFTXVaultFactory.sol\";\nimport \"./INFTXFeeDistributor.sol\";\nimport \"./INFTXLPStaking.sol\";\nimport \"./ITimelockRewardDistributionToken.sol\";\nimport \"./IUniswapV2Router01.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"../token/IERC1155Upgradeable.sol\";\nimport \"../token/IERC20Upgradeable.sol\";\nimport \"../token/ERC721HolderUpgradeable.sol\";\nimport \"../token/IERC1155ReceiverUpgradeable.sol\";\nimport \"../util/OwnableUpgradeable.sol\";\n\n// Authors: @0xKiwi_.\nabstract contract IWETH {\n  function deposit() virtual external payable;\n  function transfer(address to, uint value) virtual external returns (bool);\n  function withdraw(uint) virtual external;\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\nabstract contract INFTXStakingZap is IERC721ReceiverUpgradeable, IERC1155ReceiverUpgradeable {\n  IWETH public immutable WETH; \n  INFTXLPStaking public immutable lpStaking;\n  INFTXVaultFactory public immutable nftxFactory;\n  IUniswapV2Router01 public immutable sushiRouter;\n  uint256 public lockTime;\n\n  constructor(address _nftxFactory, address _sushiRouter) {\n    nftxFactory = INFTXVaultFactory(_nftxFactory);\n    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());\n    sushiRouter = IUniswapV2Router01(_sushiRouter);\n    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());\n    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);\n  }\n\n  function setLockTime(uint256 newLockTime) virtual external;\n\n  function addLiquidity721ETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn\n  ) virtual external payable returns (uint256);\n\n  function addLiquidity721ETHTo(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    address to\n  ) virtual external payable returns (uint256);\n\n  function addLiquidity1155ETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minEthIn\n  ) virtual external payable returns (uint256);\n\n  function addLiquidity1155ETHTo(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minEthIn,\n    address to\n  ) virtual external payable returns (uint256);\n\n  function addLiquidity721(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn\n  ) virtual external returns (uint256);\n\n  function addLiquidity721To(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) virtual external returns (uint256);\n\n  function addLiquidity1155(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn\n  ) virtual external returns (uint256);\n\n  function addLiquidity1155To(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) virtual external returns (uint256);\n\n  function lockedUntil(uint256 vaultId, address who) virtual external view returns (uint256);\n\n  function lockedLPBalance(uint256 vaultId, address who) virtual external view returns (uint256);\n\n  receive() virtual external payable;\n}\n"
24     },
25     "@openzeppelin/contracts/interfaces/IERC20.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
27     },
28     "@openzeppelin/contracts/interfaces/IERC721.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
30     },
31     "@openzeppelin/contracts/access/Ownable.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
33     },
34     "prb-math/contracts/PRBMathUD60x18.sol": {
35       "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"./PRBMath.sol\";\n\n/// @title PRBMathUD60x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\n/// maximum values permitted by the Solidity type uint256.\nlibrary PRBMathUD60x18 {\n    /// @dev Half the SCALE number.\n    uint256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\n    uint256 internal constant LOG2_E = 1_442695040888963407;\n\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\n\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_WHOLE_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // The operations can never overflow.\n        unchecked {\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function ceil(uint256 x) internal pure returns (uint256 result) {\n        if (x > MAX_WHOLE_UD60x18) {\n            revert PRBMathUD60x18__CeilOverflow(x);\n        }\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"SCALE - remainder\" but faster.\n            let delta := sub(SCALE, remainder)\n\n            // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\n            result := add(x, mul(delta, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\n    ///\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    ///\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDiv(x, SCALE, y);\n    }\n\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (uint256 result) {\n        result = 2_718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp(uint256 x) internal pure returns (uint256 result) {\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        if (x >= 133_084258667509499441) {\n            revert PRBMathUD60x18__ExpInputTooBig(x);\n        }\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            uint256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n        if (x >= 192e18) {\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x192x64 = (x << 64) / SCALE;\n\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\n            result = PRBMath.exp2(x192x64);\n        }\n    }\n\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function floor(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\n            result := sub(x, mul(remainder, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x.\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\n    function frac(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            result := mod(x, SCALE)\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__FromUintOverflow(x);\n            }\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\n    ///\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            uint256 xy = x * y;\n            if (xy / x != y) {\n                revert PRBMathUD60x18__GmOverflow(x, y);\n            }\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = PRBMath.sqrt(xy);\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding toward zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\n    function inv(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\n    function ln(uint256 x) internal pure returns (uint256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 196205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log10(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n\n        // Note that the \"mul\" in this block is the assembly multiplication operation, not the \"mul\" function defined\n        // in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\n            default {\n                result := MAX_UD60x18\n            }\n        }\n\n        if (result == MAX_UD60x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3_321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\n    ///\n    /// Caveats:\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log2(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n        unchecked {\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\n\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255 and SCALE is 1e18.\n            result = n * SCALE;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n        }\n    }\n\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\n    /// fixed-point number.\n    /// @dev See the documentation for the \"PRBMath.mulDivFixedPoint\" function.\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDivFixedPoint(x, y);\n    }\n\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\n    function pi() internal pure returns (uint256 result) {\n        result = 3_141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : uint256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// Caveats:\n    /// - All from \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // Calculate the first iteration of the loop in advance.\n        result = y & 1 > 0 ? x : SCALE;\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        for (y >>= 1; y > 0; y >>= 1) {\n            x = PRBMath.mulDivFixedPoint(x, x);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (y & 1 > 0) {\n                result = PRBMath.mulDivFixedPoint(result, x);\n            }\n        }\n    }\n\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\n    function scale() internal pure returns (uint256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x must be less than MAX_UD60x18 / SCALE.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__SqrtOverflow(x);\n            }\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = PRBMath.sqrt(x * SCALE);\n        }\n    }\n\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}\n"
36     },
37     "nftx/interface/INFTXEligibility.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface INFTXEligibility {\n    // Read functions.\n    function name() external pure returns (string memory);\n    function finalized() external view returns (bool);\n    function targetAsset() external pure returns (address);\n    function checkAllEligible(uint256[] calldata tokenIds)\n        external\n        view\n        returns (bool);\n    function checkEligible(uint256[] calldata tokenIds)\n        external\n        view\n        returns (bool[] memory);\n    function checkAllIneligible(uint256[] calldata tokenIds)\n        external\n        view\n        returns (bool);\n    function checkIsEligible(uint256 tokenId) external view returns (bool);\n\n    // Write functions.\n    function __NFTXEligibility_init_bytes(bytes calldata configData) external;\n    function beforeMintHook(uint256[] calldata tokenIds) external;\n    function afterMintHook(uint256[] calldata tokenIds) external;\n    function beforeRedeemHook(uint256[] calldata tokenIds) external;\n    function afterRedeemHook(uint256[] calldata tokenIds) external;\n}\n"
39     },
40     "nftx/token/IERC20Upgradeable.sol": {
41       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20Upgradeable {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"
42     },
43     "nftx/interface/INFTXVaultFactory.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../proxy/IBeacon.sol\";\n\ninterface INFTXVaultFactory is IBeacon {\n  // Read functions.\n  function numVaults() external view returns (uint256);\n  function zapContract() external view returns (address);\n  function feeDistributor() external view returns (address);\n  function eligibilityManager() external view returns (address);\n  function vault(uint256 vaultId) external view returns (address);\n  function allVaults() external view returns (address[] memory);\n  function vaultsForAsset(address asset) external view returns (address[] memory);\n  function isLocked(uint256 id) external view returns (bool);\n  function excludedFromFees(address addr) external view returns (bool);\n  function factoryMintFee() external view returns (uint64);\n  function factoryRandomRedeemFee() external view returns (uint64);\n  function factoryTargetRedeemFee() external view returns (uint64);\n  function factoryRandomSwapFee() external view returns (uint64);\n  function factoryTargetSwapFee() external view returns (uint64);\n  function vaultFees(uint256 vaultId) external view returns (uint256, uint256, uint256, uint256, uint256);\n\n  event NewFeeDistributor(address oldDistributor, address newDistributor);\n  event NewZapContract(address oldZap, address newZap);\n  event FeeExclusion(address feeExcluded, bool excluded);\n  event NewEligibilityManager(address oldEligManager, address newEligManager);\n  event NewVault(uint256 indexed vaultId, address vaultAddress, address assetAddress);\n  event UpdateVaultFees(uint256 vaultId, uint256 mintFee, uint256 randomRedeemFee, uint256 targetRedeemFee, uint256 randomSwapFee, uint256 targetSwapFee);\n  event DisableVaultFees(uint256 vaultId);\n  event UpdateFactoryFees(uint256 mintFee, uint256 randomRedeemFee, uint256 targetRedeemFee, uint256 randomSwapFee, uint256 targetSwapFee);\n\n  // Write functions.\n  function __NFTXVaultFactory_init(address _vaultImpl, address _feeDistributor) external;\n  function createVault(\n      string calldata name,\n      string calldata symbol,\n      address _assetAddress,\n      bool is1155,\n      bool allowAllItems\n  ) external returns (uint256);\n  function setFeeDistributor(address _feeDistributor) external;\n  function setEligibilityManager(address _eligibilityManager) external;\n  function setZapContract(address _zapContract) external;\n  function setFeeExclusion(address _excludedAddr, bool excluded) external;\n\n  function setFactoryFees(\n    uint256 mintFee, \n    uint256 randomRedeemFee, \n    uint256 targetRedeemFee,\n    uint256 randomSwapFee, \n    uint256 targetSwapFee\n  ) external; \n  function setVaultFees(\n      uint256 vaultId, \n      uint256 mintFee, \n      uint256 randomRedeemFee, \n      uint256 targetRedeemFee,\n      uint256 randomSwapFee, \n      uint256 targetSwapFee\n  ) external;\n  function disableVaultFees(uint256 vaultId) external;\n}\n"
45     },
46     "nftx/proxy/IBeacon.sol": {
47       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\r\n */\r\ninterface IBeacon {\r\n    /**\r\n     * @dev Must return an address that can be used as a delegate call target.\r\n     *\r\n     * {BeaconProxy} will check that this address is a contract.\r\n     */\r\n    function childImplementation() external view returns (address);\r\n    function upgradeChildTo(address newImplementation) external;\r\n}"
48     },
49     "nftx/interface/INFTXFeeDistributor.sol": {
50       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface INFTXFeeDistributor {\n  \n  struct FeeReceiver {\n    uint256 allocPoint;\n    address receiver;\n    bool isContract;\n  }\n\n  function nftxVaultFactory() external returns (address);\n  function lpStaking() external returns (address);\n  function treasury() external returns (address);\n  function defaultTreasuryAlloc() external returns (uint256);\n  function defaultLPAlloc() external returns (uint256);\n  function allocTotal(uint256 vaultId) external returns (uint256);\n  function specificTreasuryAlloc(uint256 vaultId) external returns (uint256);\n\n  // Write functions.\n  function __FeeDistributor__init__(address _lpStaking, address _treasury) external;\n  function rescueTokens(address token) external;\n  function distribute(uint256 vaultId) external;\n  function addReceiver(uint256 _vaultId, uint256 _allocPoint, address _receiver, bool _isContract) external;\n  function initializeVaultReceivers(uint256 _vaultId) external;\n  function changeMultipleReceiverAlloc(\n    uint256[] memory _vaultIds, \n    uint256[] memory _receiverIdxs, \n    uint256[] memory allocPoints\n  ) external;\n\n  function changeMultipleReceiverAddress(\n    uint256[] memory _vaultIds, \n    uint256[] memory _receiverIdxs, \n    address[] memory addresses, \n    bool[] memory isContracts\n  ) external;\n  function changeReceiverAlloc(uint256 _vaultId, uint256 _idx, uint256 _allocPoint) external;\n  function changeReceiverAddress(uint256 _vaultId, uint256 _idx, address _address, bool _isContract) external;\n  function removeReceiver(uint256 _vaultId, uint256 _receiverIdx) external;\n\n  // Configuration functions.\n  function setTreasuryAddress(address _treasury) external;\n  function setDefaultTreasuryAlloc(uint256 _allocPoint) external;\n  function setSpecificTreasuryAlloc(uint256 _vaultId, uint256 _allocPoint) external;\n  function setLPStakingAddress(address _lpStaking) external;\n  function setNFTXVaultFactory(address _factory) external;\n  function setDefaultLPAlloc(uint256 _allocPoint) external;\n} "
51     },
52     "nftx/interface/ITimelockRewardDistributionToken.sol": {
53       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/IERC20Upgradeable.sol\";\n\ninterface ITimelockRewardDistributionToken is IERC20Upgradeable {\n  function distributeRewards(uint amount) external;\n  function __TimelockRewardDistributionToken_init(IERC20Upgradeable _target, string memory _name, string memory _symbol) external;\n  function mint(address account, address to, uint256 amount) external;\n  function timelockMint(address account, uint256 amount, uint256 timelockLength) external;\n  function burnFrom(address account, uint256 amount) external;\n  function withdrawReward(address user) external;\n  function dividendOf(address _owner) external view returns(uint256);\n  function withdrawnRewardOf(address _owner) external view returns(uint256);\n  function accumulativeRewardOf(address _owner) external view returns(uint256);\n  function timelockUntil(address account) external view returns (uint256);\n}"
54     },
55     "nftx/token/IERC1155Upgradeable.sol": {
56       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interface/IERC165Upgradeable.sol\";\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155Upgradeable is IERC165Upgradeable {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\r\n}\r\n"
57     },
58     "nftx/token/ERC721HolderUpgradeable.sol": {
59       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC721ReceiverUpgradeable.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC721Receiver} interface.\r\n *\r\n * Accepts all token transfers.\r\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\r\n */\r\ncontract ERC721HolderUpgradeable is IERC721ReceiverUpgradeable {\r\n    /**\r\n     * @dev See {IERC721Receiver-onERC721Received}.\r\n     *\r\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n"
60     },
61     "nftx/token/IERC1155ReceiverUpgradeable.sol": {
62       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interface/IERC165Upgradeable.sol\";\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\r\n\r\n    /**\r\n        @dev Handles the receipt of a single ERC1155 token type. This function is\r\n        called at the end of a `safeTransferFrom` after the balance has been updated.\r\n        To accept the transfer, this must return\r\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n        (i.e. 0xf23a6e61, or its own function selector).\r\n        @param operator The address which initiated the transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param id The ID of the token being transferred\r\n        @param value The amount of tokens being transferred\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n\r\n    /**\r\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n        is called at the end of a `safeBatchTransferFrom` after the balances have\r\n        been updated. To accept the transfer(s), this must return\r\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n        (i.e. 0xbc197c81, or its own function selector).\r\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n}\r\n"
63     },
64     "nftx/util/OwnableUpgradeable.sol": {
65       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
66     },
67     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
68       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
69     },
70     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
71       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
72     },
73     "nftx/interface/IERC165Upgradeable.sol": {
74       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
75     },
76     "nftx/token/IERC721ReceiverUpgradeable.sol": {
77       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721ReceiverUpgradeable {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n"
78     },
79     "nftx/util/ContextUpgradeable.sol": {
80       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
81     },
82     "nftx/proxy/Initializable.sol": {
83       "content": "// SPDX-License-Identifier: MIT\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n"
84     },
85     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
86       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
87     },
88     "@openzeppelin/contracts/utils/Context.sol": {
89       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
90     },
91     "prb-math/contracts/PRBMath.sol": {
92       "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*ydenominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*ydenominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the closest power of two that is higher than x.\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
93     }
94   },
95   "settings": {
96     "optimizer": {
97       "enabled": true,
98       "runs": 100000
99     },
100     "outputSelection": {
101       "*": {
102         "*": [
103           "evm.bytecode",
104           "evm.deployedBytecode",
105           "devdoc",
106           "userdoc",
107           "metadata",
108           "abi"
109         ]
110       }
111     },
112     "libraries": {}
113   }
114 }}