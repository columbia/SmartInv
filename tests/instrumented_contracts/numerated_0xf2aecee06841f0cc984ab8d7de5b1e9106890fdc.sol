1 {{
2   "language": "Solidity",
3   "sources": {
4     "@thirdweb-dev/contracts/base/ERC1155Drop.sol": {
5       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport { ERC1155 } from \"../eip/ERC1155.sol\";\n\nimport \"../extension/ContractMetadata.sol\";\nimport \"../extension/Multicall.sol\";\nimport \"../extension/Ownable.sol\";\nimport \"../extension/Royalty.sol\";\nimport \"../extension/BatchMintMetadata.sol\";\nimport \"../extension/PrimarySale.sol\";\nimport \"../extension/DropSinglePhase1155.sol\";\nimport \"../extension/LazyMint.sol\";\nimport \"../extension/DelayedReveal.sol\";\n\nimport \"../lib/CurrencyTransferLib.sol\";\nimport \"../lib/TWStrings.sol\";\n\n/**\n *      BASE:      ERC1155Base\n *      EXTENSION: DropSinglePhase1155\n *\n *  The `ERC1155Base` smart contract implements the ERC1155 NFT standard.\n *  It includes the following additions to standard ERC1155 logic:\n *\n *      - Contract metadata for royalty support on platforms such as OpenSea that use\n *        off-chain information to distribute roaylties.\n *\n *      - Ownership of the contract, with the ability to restrict certain functions to\n *        only be called by the contract's owner.\n *\n *      - Multicall capability to perform multiple actions atomically\n *\n *      - EIP 2981 compliance for royalty support on NFT marketplaces.\n *\n *  The `drop` mechanism in the `DropSinglePhase1155` extension is a distribution mechanism for lazy minted tokens. It lets\n *  you set restrictions such as a price to charge, an allowlist etc. when an address atttempts to mint lazy minted tokens.\n *\n *  The `ERC721Drop` contract lets you lazy mint tokens, and distribute those lazy minted tokens via the drop mechanism.\n */\n\ncontract ERC1155Drop is\n    ERC1155,\n    ContractMetadata,\n    Ownable,\n    Royalty,\n    Multicall,\n    BatchMintMetadata,\n    PrimarySale,\n    LazyMint,\n    DelayedReveal,\n    DropSinglePhase1155\n{\n    using TWStrings for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                        Mappings\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     *  @notice Returns the total supply of NFTs of a given tokenId\n     *  @dev Mapping from tokenId => total circulating supply of NFTs of that tokenId.\n     */\n    mapping(uint256 => uint256) public totalSupply;\n\n    /*///////////////////////////////////////////////////////////////\n                            Constructor\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _royaltyRecipient,\n        uint128 _royaltyBps,\n        address _primarySaleRecipient\n    ) ERC1155(_name, _symbol) {\n        _setupOwner(msg.sender);\n        _setupDefaultRoyaltyInfo(_royaltyRecipient, _royaltyBps);\n        _setupPrimarySaleRecipient(_primarySaleRecipient);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    Overriden metadata logic\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     *  @notice         Returns the metadata URI for an NFT.\n     *  @dev            See `BatchMintMetadata` for handling of metadata in this contract.\n     *\n     *  @param _tokenId The tokenId of an NFT.\n     */\n    function uri(uint256 _tokenId) public view virtual override returns (string memory) {\n        (uint256 batchId, ) = getBatchId(_tokenId);\n        string memory batchUri = getBaseURI(_tokenId);\n\n        if (isEncryptedBatch(batchId)) {\n            return string(abi.encodePacked(batchUri, \"0\"));\n        } else {\n            return string(abi.encodePacked(batchUri, _tokenId.toString()));\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Delayed reveal logic\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     *  @notice       Lets an authorized address reveal a batch of delayed reveal NFTs.\n     *\n     *  @param _index The ID for the batch of delayed-reveal NFTs to reveal.\n     *  @param _key   The key with which the base URI for the relevant batch of NFTs was encrypted.\n     */\n    function reveal(uint256 _index, bytes calldata _key) public virtual override returns (string memory revealedURI) {\n        require(_canReveal(), \"Not authorized\");\n\n        uint256 batchId = getBatchIdAtIndex(_index);\n        revealedURI = getRevealURI(batchId, _key);\n\n        _setEncryptedData(batchId, \"\");\n        _setBaseURI(batchId, revealedURI);\n\n        emit TokenURIRevealed(_index, revealedURI);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    Overriden lazy minting logic\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     *  @notice                  Lets an authorized address lazy mint a given amount of NFTs.\n     *\n     *  @param _amount           The number of NFTs to lazy mint.\n     *  @param _baseURIForTokens The placeholder base URI for the 'n' number of NFTs being lazy minted, where the\n     *                           metadata for each of those NFTs is `${baseURIForTokens}/${tokenId}`.\n     *  @param _data             The encrypted base URI + provenance hash for the batch of NFTs being lazy minted.\n     *  @return batchId          A unique integer identifier for the batch of NFTs lazy minted together.\n     */\n    function lazyMint(\n        uint256 _amount,\n        string calldata _baseURIForTokens,\n        bytes calldata _data\n    ) public virtual override returns (uint256 batchId) {\n        if (_data.length > 0) {\n            (bytes memory encryptedURI, bytes32 provenanceHash) = abi.decode(_data, (bytes, bytes32));\n            if (encryptedURI.length != 0 && provenanceHash != \"\") {\n                _setEncryptedData(nextTokenIdToLazyMint + _amount, _data);\n            }\n        }\n\n        return LazyMint.lazyMint(_amount, _baseURIForTokens, _data);\n    }\n\n    /// @notice The tokenId assigned to the next new NFT to be lazy minted.\n    function nextTokenIdToMint() public view virtual returns (uint256) {\n        return nextTokenIdToLazyMint;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC165 Logic\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns whether this contract supports the given interface.\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155, IERC165) returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c || // ERC165 Interface ID for ERC1155MetadataURI\n            interfaceId == type(IERC2981).interfaceId; // ERC165 ID for ERC2981\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Internal functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Runs before every `claim` function call.\n    function _beforeClaim(\n        uint256 _tokenId,\n        address,\n        uint256,\n        address,\n        uint256,\n        AllowlistProof calldata,\n        bytes memory\n    ) internal view virtual override {\n        require(msg.sender == tx.origin, \"BOT\");\n        if (_tokenId >= nextTokenIdToLazyMint) {\n            revert(\"Not enough minted tokens\");\n        }\n    }\n\n    /// @dev Collects and distributes the primary sale value of NFTs being claimed.\n    function collectPriceOnClaim(\n        address _primarySaleRecipient,\n        uint256 _quantityToClaim,\n        address _currency,\n        uint256 _pricePerToken\n    ) internal virtual override {\n        if (_pricePerToken == 0) {\n            return;\n        }\n\n        uint256 totalPrice = _quantityToClaim * _pricePerToken;\n\n        if (_currency == CurrencyTransferLib.NATIVE_TOKEN) {\n            if (msg.value != totalPrice) {\n                revert(\"Must send total price.\");\n            }\n        }\n\n        address saleRecipient = _primarySaleRecipient == address(0) ? primarySaleRecipient() : _primarySaleRecipient;\n        CurrencyTransferLib.transferCurrency(_currency, msg.sender, saleRecipient, totalPrice);\n    }\n\n    /// @dev Transfers the NFTs being claimed.\n    function transferTokensOnClaim(\n        address _to,\n        uint256 _tokenId,\n        uint256 _quantityBeingClaimed\n    ) internal virtual override {\n        _mint(_to, _tokenId, _quantityBeingClaimed, \"\");\n    }\n\n    /// @dev Runs before every token transfer / mint / burn.\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                totalSupply[ids[i]] += amounts[i];\n            }\n        }\n\n        if (to == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                totalSupply[ids[i]] -= amounts[i];\n            }\n        }\n    }\n\n    /// @dev Checks whether primary sale recipient can be set in the given execution context.\n    function _canSetPrimarySaleRecipient() internal view virtual override returns (bool) {\n        return msg.sender == owner();\n    }\n\n    /// @dev Checks whether owner can be set in the given execution context.\n    function _canSetOwner() internal view virtual override returns (bool) {\n        return msg.sender == owner();\n    }\n\n    /// @dev Checks whether royalty info can be set in the given execution context.\n    function _canSetRoyaltyInfo() internal view virtual override returns (bool) {\n        return msg.sender == owner();\n    }\n\n    /// @dev Checks whether contract metadata can be set in the given execution context.\n    function _canSetContractURI() internal view virtual override returns (bool) {\n        return msg.sender == owner();\n    }\n\n    /// @dev Checks whether platform fee info can be set in the given execution context.\n    function _canSetClaimConditions() internal view virtual override returns (bool) {\n        return msg.sender == owner();\n    }\n\n    /// @dev Returns whether lazy minting can be done in the given execution context.\n    function _canLazyMint() internal view virtual override returns (bool) {\n        return msg.sender == owner();\n    }\n\n    /// @dev Checks whether NFTs can be revealed in the given execution context.\n    function _canReveal() internal view virtual returns (bool) {\n        return msg.sender == owner();\n    }\n}\n"
6     },
7     "@thirdweb-dev/contracts/eip/ERC1155.sol": {
8       "content": "// SPDX-License-Identifier: Apache 2.0\npragma solidity ^0.8.0;\n\nimport \"./interface/IERC1155.sol\";\nimport \"./interface/IERC1155Metadata.sol\";\nimport \"./interface/IERC1155Receiver.sol\";\n\ncontract ERC1155 is IERC1155, IERC1155Metadata {\n    /*//////////////////////////////////////////////////////////////\n                        State variables\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n    string public symbol;\n\n    /*//////////////////////////////////////////////////////////////\n                            Mappings\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    mapping(uint256 => string) internal _uri;\n\n    /*//////////////////////////////////////////////////////////////\n                            Constructor\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            View functions\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    function uri(uint256 tokenId) public view virtual override returns (string memory) {\n        return _uri[tokenId];\n    }\n\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"LENGTH_MISMATCH\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf[accounts[i]][ids[i]];\n        }\n\n        return batchBalances;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC1155 logic\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        address owner = msg.sender;\n        require(owner != operator, \"APPROVING_SELF\");\n        isApprovedForAll[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(from == msg.sender || isApprovedForAll[from][msg.sender], \"!OWNER_OR_APPROVED\");\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(from == msg.sender || isApprovedForAll[from][msg.sender], \"!OWNER_OR_APPROVED\");\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Internal logic\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"TO_ZERO_ADDR\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = balanceOf[from][id];\n        require(fromBalance >= amount, \"INSUFFICIENT_BAL\");\n        unchecked {\n            balanceOf[from][id] = fromBalance - amount;\n        }\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n        require(to != address(0), \"TO_ZERO_ADDR\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = balanceOf[from][id];\n            require(fromBalance >= amount, \"INSUFFICIENT_BAL\");\n            unchecked {\n                balanceOf[from][id] = fromBalance - amount;\n            }\n            balanceOf[to][id] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    function _setTokenURI(uint256 tokenId, string memory newuri) internal virtual {\n        _uri[tokenId] = newuri;\n    }\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"TO_ZERO_ADDR\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        balanceOf[to][id] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"TO_ZERO_ADDR\");\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            balanceOf[to][ids[i]] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"FROM_ZERO_ADDR\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 fromBalance = balanceOf[from][id];\n        require(fromBalance >= amount, \"INSUFFICIENT_BAL\");\n        unchecked {\n            balanceOf[from][id] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"FROM_ZERO_ADDR\");\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = balanceOf[from][id];\n            require(fromBalance >= amount, \"INSUFFICIENT_BAL\");\n            unchecked {\n                balanceOf[from][id] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"TOKENS_REJECTED\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"!ERC1155RECEIVER\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"TOKENS_REJECTED\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"!ERC1155RECEIVER\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
9     },
10     "@thirdweb-dev/contracts/eip/interface/IERC1155.sol": {
11       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/**\n    @title ERC-1155 Multi Token Standard\n    @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md\n    Note: The ERC-165 identifier for this interface is 0xd9b67a26.\n */\ninterface IERC1155 {\n    /**\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n        The `_operator` argument MUST be msg.sender.\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\n        The `_id` argument MUST be the token type being transferred.\n        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    */\n    event TransferSingle(\n        address indexed _operator,\n        address indexed _from,\n        address indexed _to,\n        uint256 _id,\n        uint256 _value\n    );\n\n    /**\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n        The `_operator` argument MUST be msg.sender.\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\n        The `_ids` argument MUST be the list of tokens being transferred.\n        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    */\n    event TransferBatch(\n        address indexed _operator,\n        address indexed _from,\n        address indexed _to,\n        uint256[] _ids,\n        uint256[] _values\n    );\n\n    /**\n        @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absense of an event assumes disabled).\n    */\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /**\n        @dev MUST emit when the URI is updated for a token ID.\n        URIs are defined in RFC 3986.\n        The URI MUST point a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\n    */\n    event URI(string _value, uint256 indexed _id);\n\n    /**\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\n        MUST revert on any other error.\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param _from    Source address\n        @param _to      Target address\n        @param _id      ID of the token type\n        @param _value   Transfer amount\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\n    */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external;\n\n    /**\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if length of `_ids` is not the same as length of `_values`.\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\n        MUST revert on any other error.\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param _from    Source address\n        @param _to      Target address\n        @param _ids     IDs of each token type (order and length must match _values array)\n        @param _values  Transfer amounts per token type (order and length must match _ids array)\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\n    */\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external;\n\n    /**\n        @notice Get the balance of an account's Tokens.\n        @param _owner  The address of the token holder\n        @param _id     ID of the Token\n        @return        The _owner's balance of the Token type requested\n     */\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n    /**\n        @notice Get the balance of multiple account/token pairs\n        @param _owners The addresses of the token holders\n        @param _ids    ID of the Tokens\n        @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\n     */\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n        @dev MUST emit the ApprovalForAll event on success.\n        @param _operator  Address to add to the set of authorized operators\n        @param _approved  True if the operator is approved, false to revoke approval\n    */\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /**\n        @notice Queries the approval status of an operator for a given owner.\n        @param _owner     The owner of the Tokens\n        @param _operator  Address of authorized operator\n        @return           True if the operator is approved, false if not\n    */\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"
12     },
13     "@thirdweb-dev/contracts/eip/interface/IERC1155Metadata.sol": {
14       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/**\n    Note: The ERC-165 identifier for this interface is 0x0e89341c.\n*/\ninterface IERC1155Metadata {\n    /**\n        @notice A distinct Uniform Resource Identifier (URI) for a given token.\n        @dev URIs are defined in RFC 3986.\n        The URI may point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\n        @return URI string\n    */\n    function uri(uint256 _id) external view returns (string memory);\n}\n"
15     },
16     "@thirdweb-dev/contracts/eip/interface/IERC1155Receiver.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
18     },
19     "@thirdweb-dev/contracts/eip/interface/IERC165.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
21     },
22     "@thirdweb-dev/contracts/eip/interface/IERC20.sol": {
23       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
24     },
25     "@thirdweb-dev/contracts/eip/interface/IERC2981.sol": {
26       "content": "// SPDX-License-Identifier: Apache 2.0\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be payed in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
27     },
28     "@thirdweb-dev/contracts/extension/BatchMintMetadata.sol": {
29       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/**\n *  @title   Batch-mint Metadata\n *  @notice  The `BatchMintMetadata` is a contract extension for any base NFT contract. It lets the smart contract\n *           using this extension set metadata for `n` number of NFTs all at once. This is enabled by storing a single\n *           base URI for a batch of `n` NFTs, where the metadata for each NFT in a relevant batch is `baseURI/tokenId`.\n */\n\ncontract BatchMintMetadata {\n    /// @dev Largest tokenId of each batch of tokens with the same baseURI.\n    uint256[] private batchIds;\n\n    /// @dev Mapping from id of a batch of tokens => to base URI for the respective batch of tokens.\n    mapping(uint256 => string) private baseURI;\n\n    /**\n     *  @notice         Returns the count of batches of NFTs.\n     *  @dev            Each batch of tokens has an in ID and an associated `baseURI`.\n     *                  See {batchIds}.\n     */\n    function getBaseURICount() public view returns (uint256) {\n        return batchIds.length;\n    }\n\n    /**\n     *  @notice         Returns the ID for the batch of tokens the given tokenId belongs to.\n     *  @dev            See {getBaseURICount}.\n     *  @param _index   ID of a token.\n     */\n    function getBatchIdAtIndex(uint256 _index) public view returns (uint256) {\n        if (_index >= getBaseURICount()) {\n            revert(\"Invalid index\");\n        }\n        return batchIds[_index];\n    }\n\n    /// @dev Returns the id for the batch of tokens the given tokenId belongs to.\n    function getBatchId(uint256 _tokenId) internal view returns (uint256 batchId, uint256 index) {\n        uint256 numOfTokenBatches = getBaseURICount();\n        uint256[] memory indices = batchIds;\n\n        for (uint256 i = 0; i < numOfTokenBatches; i += 1) {\n            if (_tokenId < indices[i]) {\n                index = i;\n                batchId = indices[i];\n\n                return (batchId, index);\n            }\n        }\n\n        revert(\"Invalid tokenId\");\n    }\n\n    /// @dev Returns the baseURI for a token. The intended metadata URI for the token is baseURI + tokenId.\n    function getBaseURI(uint256 _tokenId) internal view returns (string memory) {\n        uint256 numOfTokenBatches = getBaseURICount();\n        uint256[] memory indices = batchIds;\n\n        for (uint256 i = 0; i < numOfTokenBatches; i += 1) {\n            if (_tokenId < indices[i]) {\n                return baseURI[indices[i]];\n            }\n        }\n        revert(\"Invalid tokenId\");\n    }\n\n    /// @dev Sets the base URI for the batch of tokens with the given batchId.\n    function _setBaseURI(uint256 _batchId, string memory _baseURI) internal {\n        baseURI[_batchId] = _baseURI;\n    }\n\n    /// @dev Mints a batch of tokenIds and associates a common baseURI to all those Ids.\n    function _batchMintMetadata(\n        uint256 _startId,\n        uint256 _amountToMint,\n        string memory _baseURIForTokens\n    ) internal returns (uint256 nextTokenIdToMint, uint256 batchId) {\n        batchId = _startId + _amountToMint;\n        nextTokenIdToMint = batchId;\n\n        batchIds.push(batchId);\n\n        baseURI[batchId] = _baseURIForTokens;\n    }\n}\n"
30     },
31     "@thirdweb-dev/contracts/extension/ContractMetadata.sol": {
32       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./interface/IContractMetadata.sol\";\n\n/**\n *  @title   Contract Metadata\n *  @notice  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\n *           for you contract.\n *           Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\n */\n\nabstract contract ContractMetadata is IContractMetadata {\n    /// @notice Returns the contract metadata URI.\n    string public override contractURI;\n\n    /**\n     *  @notice         Lets a contract admin set the URI for contract-level metadata.\n     *  @dev            Caller should be authorized to setup contractURI, e.g. contract admin.\n     *                  See {_canSetContractURI}.\n     *                  Emits {ContractURIUpdated Event}.\n     *\n     *  @param _uri     keccak256 hash of the role. e.g. keccak256(\"TRANSFER_ROLE\")\n     */\n    function setContractURI(string memory _uri) external override {\n        if (!_canSetContractURI()) {\n            revert(\"Not authorized\");\n        }\n\n        _setupContractURI(_uri);\n    }\n\n    /// @dev Lets a contract admin set the URI for contract-level metadata.\n    function _setupContractURI(string memory _uri) internal {\n        string memory prevURI = contractURI;\n        contractURI = _uri;\n\n        emit ContractURIUpdated(prevURI, _uri);\n    }\n\n    /// @dev Returns whether contract metadata can be set in the given execution context.\n    function _canSetContractURI() internal view virtual returns (bool);\n}\n"
33     },
34     "@thirdweb-dev/contracts/extension/DelayedReveal.sol": {
35       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./interface/IDelayedReveal.sol\";\n\n/**\n *  @title   Delayed Reveal\n *  @notice  Thirdweb's `DelayedReveal` is a contract extension for base NFT contracts. It lets you create batches of\n *           'delayed-reveal' NFTs. You can learn more about the usage of delayed reveal NFTs here - https://blog.thirdweb.com/delayed-reveal-nfts\n */\n\nabstract contract DelayedReveal is IDelayedReveal {\n    /// @dev Mapping from tokenId of a batch of tokens => to delayed reveal data.\n    mapping(uint256 => bytes) public encryptedData;\n\n    /// @dev Sets the delayed reveal data for a batchId.\n    function _setEncryptedData(uint256 _batchId, bytes memory _encryptedData) internal {\n        encryptedData[_batchId] = _encryptedData;\n    }\n\n    /**\n     *  @notice             Returns revealed URI for a batch of NFTs.\n     *  @dev                Reveal encrypted base URI for `_batchId` with caller/admin's `_key` used for encryption.\n     *                      Reverts if there's no encrypted URI for `_batchId`.\n     *                      See {encryptDecrypt}.\n     *\n     *  @param _batchId     ID of the batch for which URI is being revealed.\n     *  @param _key         Secure key used by caller/admin for encryption of baseURI.\n     *\n     *  @return revealedURI Decrypted base URI.\n     */\n    function getRevealURI(uint256 _batchId, bytes calldata _key) public view returns (string memory revealedURI) {\n        bytes memory data = encryptedData[_batchId];\n        if (data.length == 0) {\n            revert(\"Nothing to reveal\");\n        }\n\n        (bytes memory encryptedURI, bytes32 provenanceHash) = abi.decode(data, (bytes, bytes32));\n\n        revealedURI = string(encryptDecrypt(encryptedURI, _key));\n\n        require(keccak256(abi.encodePacked(revealedURI, _key, block.chainid)) == provenanceHash, \"Incorrect key\");\n    }\n\n    /**\n     *  @notice         Encrypt/decrypt data on chain.\n     *  @dev            Encrypt/decrypt given `data` with `key`. Uses inline assembly.\n     *                  See: https://ethereum.stackexchange.com/questions/69825/decrypt-message-on-chain\n     *\n     *  @param data     Bytes of data to encrypt/decrypt.\n     *  @param key      Secure key used by caller for encryption/decryption.\n     *\n     *  @return result  Output after encryption/decryption of given data.\n     */\n    function encryptDecrypt(bytes memory data, bytes calldata key) public pure override returns (bytes memory result) {\n        // Store data length on stack for later use\n        uint256 length = data.length;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Set result to free memory pointer\n            result := mload(0x40)\n            // Increase free memory pointer by lenght + 32\n            mstore(0x40, add(add(result, length), 32))\n            // Set result length\n            mstore(result, length)\n        }\n\n        // Iterate over the data stepping by 32 bytes\n        for (uint256 i = 0; i < length; i += 32) {\n            // Generate hash of the key and offset\n            bytes32 hash = keccak256(abi.encodePacked(key, i));\n\n            bytes32 chunk;\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // Read 32-bytes data chunk\n                chunk := mload(add(data, add(i, 32)))\n            }\n            // XOR the chunk with hash\n            chunk ^= hash;\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // Write 32-byte encrypted chunk\n                mstore(add(result, add(i, 32)), chunk)\n            }\n        }\n    }\n\n    /**\n     *  @notice         Returns whether the relvant batch of NFTs is subject to a delayed reveal.\n     *  @dev            Returns `true` if `_batchId`'s base URI is encrypted.\n     *  @param _batchId ID of a batch of NFTs.\n     */\n    function isEncryptedBatch(uint256 _batchId) public view returns (bool) {\n        return encryptedData[_batchId].length > 0;\n    }\n}\n"
36     },
37     "@thirdweb-dev/contracts/extension/DropSinglePhase1155.sol": {
38       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./interface/IDropSinglePhase1155.sol\";\nimport \"../lib/MerkleProof.sol\";\nimport \"../lib/TWBitMaps.sol\";\n\nabstract contract DropSinglePhase1155 is IDropSinglePhase1155 {\n    using TWBitMaps for TWBitMaps.BitMap;\n\n    /*///////////////////////////////////////////////////////////////\n                                Mappings\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from tokenId => active claim condition for the tokenId.\n    mapping(uint256 => ClaimCondition) public claimCondition;\n\n    /// @dev Mapping from tokenId => active claim condition's UID.\n    mapping(uint256 => bytes32) private conditionId;\n\n    /**\n     *  @dev Map from an account and uid for a claim condition, to the last timestamp\n     *       at which the account claimed tokens under that claim condition.\n     */\n    mapping(bytes32 => mapping(address => uint256)) private lastClaimTimestamp;\n\n    /**\n     *  @dev Map from a claim condition uid to whether an address in an allowlist\n     *       has already claimed tokens i.e. used their place in the allowlist.\n     */\n    mapping(bytes32 => TWBitMaps.BitMap) private usedAllowlistSpot;\n\n    /*///////////////////////////////////////////////////////////////\n                            Drop logic\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Lets an account claim tokens.\n    function claim(\n        address _receiver,\n        uint256 _tokenId,\n        uint256 _quantity,\n        address _currency,\n        uint256 _pricePerToken,\n        AllowlistProof calldata _allowlistProof,\n        bytes memory _data\n    ) public payable virtual override {\n        _beforeClaim(_tokenId, _receiver, _quantity, _currency, _pricePerToken, _allowlistProof, _data);\n\n        ClaimCondition memory condition = claimCondition[_tokenId];\n        bytes32 activeConditionId = conditionId[_tokenId];\n\n        /**\n         *  We make allowlist checks (i.e. verifyClaimMerkleProof) before verifying the claim's general\n         *  validity (i.e. verifyClaim) because we give precedence to the check of allow list quantity\n         *  restriction over the check of the general claim condition's quantityLimitPerTransaction\n         *  restriction.\n         */\n\n        // Verify inclusion in allowlist.\n        (bool validMerkleProof, uint256 merkleProofIndex) = verifyClaimMerkleProof(\n            _tokenId,\n            _dropMsgSender(),\n            _quantity,\n            _allowlistProof\n        );\n\n        // Verify claim validity. If not valid, revert.\n        // when there's allowlist present --> verifyClaimMerkleProof will verify the maxQuantityInAllowlist value with hashed leaf in the allowlist\n        // when there's no allowlist, this check is true --> verifyClaim will check for _quantity being equal/less than the limit\n        bool toVerifyMaxQuantityPerTransaction = _allowlistProof.maxQuantityInAllowlist == 0 ||\n            condition.merkleRoot == bytes32(0);\n\n        verifyClaim(\n            _tokenId,\n            _dropMsgSender(),\n            _quantity,\n            _currency,\n            _pricePerToken,\n            toVerifyMaxQuantityPerTransaction\n        );\n\n        if (validMerkleProof && _allowlistProof.maxQuantityInAllowlist > 0) {\n            /**\n             *  Mark the claimer's use of their position in the allowlist. A spot in an allowlist\n             *  can be used only once.\n             */\n            usedAllowlistSpot[activeConditionId].set(merkleProofIndex);\n        }\n\n        // Update contract state.\n        condition.supplyClaimed += _quantity;\n        lastClaimTimestamp[activeConditionId][_dropMsgSender()] = block.timestamp;\n        claimCondition[_tokenId] = condition;\n\n        // If there's a price, collect price.\n        collectPriceOnClaim(address(0), _quantity, _currency, _pricePerToken);\n\n        // Mint the relevant NFTs to claimer.\n        transferTokensOnClaim(_receiver, _tokenId, _quantity);\n\n        emit TokensClaimed(_dropMsgSender(), _receiver, _tokenId, _quantity);\n\n        _afterClaim(_tokenId, _receiver, _quantity, _currency, _pricePerToken, _allowlistProof, _data);\n    }\n\n    /// @dev Lets a contract admin set claim conditions.\n    function setClaimConditions(\n        uint256 _tokenId,\n        ClaimCondition calldata _condition,\n        bool _resetClaimEligibility\n    ) external override {\n        if (!_canSetClaimConditions()) {\n            revert(\"Not authorized\");\n        }\n\n        ClaimCondition memory condition = claimCondition[_tokenId];\n        bytes32 targetConditionId = conditionId[_tokenId];\n\n        uint256 supplyClaimedAlready = condition.supplyClaimed;\n\n        if (_resetClaimEligibility) {\n            supplyClaimedAlready = 0;\n            targetConditionId = keccak256(abi.encodePacked(_dropMsgSender(), block.number));\n        }\n\n        if (supplyClaimedAlready > _condition.maxClaimableSupply) {\n            revert(\"max supply claimed\");\n        }\n\n        ClaimCondition memory updatedCondition = ClaimCondition({\n            startTimestamp: _condition.startTimestamp,\n            maxClaimableSupply: _condition.maxClaimableSupply,\n            supplyClaimed: supplyClaimedAlready,\n            quantityLimitPerTransaction: _condition.quantityLimitPerTransaction,\n            waitTimeInSecondsBetweenClaims: _condition.waitTimeInSecondsBetweenClaims,\n            merkleRoot: _condition.merkleRoot,\n            pricePerToken: _condition.pricePerToken,\n            currency: _condition.currency\n        });\n\n        claimCondition[_tokenId] = updatedCondition;\n        conditionId[_tokenId] = targetConditionId;\n\n        emit ClaimConditionUpdated(_tokenId, _condition, _resetClaimEligibility);\n    }\n\n    /// @dev Checks a request to claim NFTs against the active claim condition's criteria.\n    function verifyClaim(\n        uint256 _tokenId,\n        address _claimer,\n        uint256 _quantity,\n        address _currency,\n        uint256 _pricePerToken,\n        bool verifyMaxQuantityPerTransaction\n    ) public view {\n        ClaimCondition memory currentClaimPhase = claimCondition[_tokenId];\n\n        if (_currency != currentClaimPhase.currency || _pricePerToken != currentClaimPhase.pricePerToken) {\n            revert(\"Invalid price or currency\");\n        }\n\n        // If we're checking for an allowlist quantity restriction, ignore the general quantity restriction.\n        if (\n            _quantity == 0 ||\n            (verifyMaxQuantityPerTransaction && _quantity > currentClaimPhase.quantityLimitPerTransaction)\n        ) {\n            revert(\"Invalid quantity\");\n        }\n\n        if (currentClaimPhase.supplyClaimed + _quantity > currentClaimPhase.maxClaimableSupply) {\n            revert(\"exceeds max supply\");\n        }\n\n        (uint256 lastClaimedAt, uint256 nextValidClaimTimestamp) = getClaimTimestamp(_tokenId, _claimer);\n        if (\n            currentClaimPhase.startTimestamp > block.timestamp ||\n            (lastClaimedAt != 0 && block.timestamp < nextValidClaimTimestamp)\n        ) {\n            revert(\"cant claim yet\");\n        }\n    }\n\n    /// @dev Checks whether a claimer meets the claim condition's allowlist criteria.\n    function verifyClaimMerkleProof(\n        uint256 _tokenId,\n        address _claimer,\n        uint256 _quantity,\n        AllowlistProof calldata _allowlistProof\n    ) public view returns (bool validMerkleProof, uint256 merkleProofIndex) {\n        ClaimCondition memory currentClaimPhase = claimCondition[_tokenId];\n\n        if (currentClaimPhase.merkleRoot != bytes32(0)) {\n            (validMerkleProof, merkleProofIndex) = MerkleProof.verify(\n                _allowlistProof.proof,\n                currentClaimPhase.merkleRoot,\n                keccak256(abi.encodePacked(_claimer, _allowlistProof.maxQuantityInAllowlist))\n            );\n            if (!validMerkleProof) {\n                revert(\"not in allowlist\");\n            }\n\n            if (usedAllowlistSpot[conditionId[_tokenId]].get(merkleProofIndex)) {\n                revert(\"proof claimed\");\n            }\n\n            if (_allowlistProof.maxQuantityInAllowlist != 0 && _quantity > _allowlistProof.maxQuantityInAllowlist) {\n                revert(\"Invalid qty proof\");\n            }\n        }\n    }\n\n    /// @dev Returns the timestamp for when a claimer is eligible for claiming NFTs again.\n    function getClaimTimestamp(uint256 _tokenId, address _claimer)\n        public\n        view\n        returns (uint256 lastClaimedAt, uint256 nextValidClaimTimestamp)\n    {\n        lastClaimedAt = lastClaimTimestamp[conditionId[_tokenId]][_claimer];\n\n        unchecked {\n            nextValidClaimTimestamp = lastClaimedAt + claimCondition[_tokenId].waitTimeInSecondsBetweenClaims;\n\n            if (nextValidClaimTimestamp < lastClaimedAt) {\n                nextValidClaimTimestamp = type(uint256).max;\n            }\n        }\n    }\n\n    /*////////////////////////////////////////////////////////////////////\n        Optional hooks that can be implemented in the derived contract\n    ///////////////////////////////////////////////////////////////////*/\n\n    /// @dev Exposes the ability to override the msg sender.\n    function _dropMsgSender() internal virtual returns (address) {\n        return msg.sender;\n    }\n\n    /// @dev Runs before every `claim` function call.\n    function _beforeClaim(\n        uint256 _tokenId,\n        address _receiver,\n        uint256 _quantity,\n        address _currency,\n        uint256 _pricePerToken,\n        AllowlistProof calldata _allowlistProof,\n        bytes memory _data\n    ) internal virtual {}\n\n    /// @dev Runs after every `claim` function call.\n    function _afterClaim(\n        uint256 _tokenId,\n        address _receiver,\n        uint256 _quantity,\n        address _currency,\n        uint256 _pricePerToken,\n        AllowlistProof calldata _allowlistProof,\n        bytes memory _data\n    ) internal virtual {}\n\n    /// @dev Collects and distributes the primary sale value of NFTs being claimed.\n    function collectPriceOnClaim(\n        address _primarySaleRecipient,\n        uint256 _quantityToClaim,\n        address _currency,\n        uint256 _pricePerToken\n    ) internal virtual;\n\n    /// @dev Transfers the NFTs being claimed.\n    function transferTokensOnClaim(\n        address _to,\n        uint256 _tokenId,\n        uint256 _quantityBeingClaimed\n    ) internal virtual;\n\n    function _canSetClaimConditions() internal view virtual returns (bool);\n}\n"
39     },
40     "@thirdweb-dev/contracts/extension/LazyMint.sol": {
41       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./interface/ILazyMint.sol\";\nimport \"./BatchMintMetadata.sol\";\n\n/**\n *  The `LazyMint` is a contract extension for any base NFT contract. It lets you 'lazy mint' any number of NFTs\n *  at once. Here, 'lazy mint' means defining the metadata for particular tokenIds of your NFT contract, without actually\n *  minting a non-zero balance of NFTs of those tokenIds.\n */\n\nabstract contract LazyMint is ILazyMint, BatchMintMetadata {\n    /// @notice The tokenId assigned to the next new NFT to be lazy minted.\n    uint256 internal nextTokenIdToLazyMint;\n\n    /**\n     *  @notice                  Lets an authorized address lazy mint a given amount of NFTs.\n     *\n     *  @param _amount           The number of NFTs to lazy mint.\n     *  @param _baseURIForTokens The base URI for the 'n' number of NFTs being lazy minted, where the metadata for each\n     *                           of those NFTs is `${baseURIForTokens}/${tokenId}`.\n     *  @param _data             Additional bytes data to be used at the discretion of the consumer of the contract.\n     *  @return batchId          A unique integer identifier for the batch of NFTs lazy minted together.\n     */\n    function lazyMint(\n        uint256 _amount,\n        string calldata _baseURIForTokens,\n        bytes calldata _data\n    ) public virtual override returns (uint256 batchId) {\n        if (!_canLazyMint()) {\n            revert(\"Not authorized\");\n        }\n\n        if (_amount == 0) {\n            revert(\"Minting 0 tokens\");\n        }\n\n        uint256 startId = nextTokenIdToLazyMint;\n\n        (nextTokenIdToLazyMint, batchId) = _batchMintMetadata(startId, _amount, _baseURIForTokens);\n\n        emit TokensLazyMinted(startId, startId + _amount - 1, _baseURIForTokens, _data);\n\n        return batchId;\n    }\n\n    /// @dev Returns whether lazy minting can be performed in the given execution context.\n    function _canLazyMint() internal view virtual returns (bool);\n}\n"
42     },
43     "@thirdweb-dev/contracts/extension/Multicall.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../lib/TWAddress.sol\";\nimport \"./interface/IMulticall.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\ncontract Multicall is IMulticall {\n    /**\n     *  @notice Receives and executes a batch of function calls on this contract.\n     *  @dev Receives and executes a batch of function calls on this contract.\n     *\n     *  @param data The bytes data that makes up the batch of function calls to execute.\n     *  @return results The bytes data that makes up the result of the batch of function calls executed.\n     */\n    function multicall(bytes[] calldata data) external virtual override returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = TWAddress.functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n}\n"
45     },
46     "@thirdweb-dev/contracts/extension/Ownable.sol": {
47       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./interface/IOwnable.sol\";\n\n/**\n *  @title   Ownable\n *  @notice  Thirdweb's `Ownable` is a contract extension to be used with any base contract. It exposes functions for setting and reading\n *           who the 'owner' of the inheriting smart contract is, and lets the inheriting contract perform conditional logic that uses\n *           information about who the contract's owner is.\n */\n\nabstract contract Ownable is IOwnable {\n    /// @dev Owner of the contract (purpose: OpenSea compatibility)\n    address private _owner;\n\n    /// @dev Reverts if caller is not the owner.\n    modifier onlyOwner() {\n        if (msg.sender != _owner) {\n            revert(\"Not authorized\");\n        }\n        _;\n    }\n\n    /**\n     *  @notice Returns the owner of the contract.\n     */\n    function owner() public view override returns (address) {\n        return _owner;\n    }\n\n    /**\n     *  @notice Lets an authorized wallet set a new owner for the contract.\n     *  @param _newOwner The address to set as the new owner of the contract.\n     */\n    function setOwner(address _newOwner) external override {\n        if (!_canSetOwner()) {\n            revert(\"Not authorized\");\n        }\n        _setupOwner(_newOwner);\n    }\n\n    /// @dev Lets a contract admin set a new owner for the contract. The new owner must be a contract admin.\n    function _setupOwner(address _newOwner) internal {\n        address _prevOwner = _owner;\n        _owner = _newOwner;\n\n        emit OwnerUpdated(_prevOwner, _newOwner);\n    }\n\n    /// @dev Returns whether owner can be set in the given execution context.\n    function _canSetOwner() internal view virtual returns (bool);\n}\n"
48     },
49     "@thirdweb-dev/contracts/extension/PrimarySale.sol": {
50       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./interface/IPrimarySale.sol\";\n\n/**\n *  @title   Primary Sale\n *  @notice  Thirdweb's `PrimarySale` is a contract extension to be used with any base contract. It exposes functions for setting and reading\n *           the recipient of primary sales, and lets the inheriting contract perform conditional logic that uses information about\n *           primary sales, if desired.\n */\n\nabstract contract PrimarySale is IPrimarySale {\n    /// @dev The address that receives all primary sales value.\n    address private recipient;\n\n    /// @dev Returns primary sale recipient address.\n    function primarySaleRecipient() public view override returns (address) {\n        return recipient;\n    }\n\n    /**\n     *  @notice         Updates primary sale recipient.\n     *  @dev            Caller should be authorized to set primary sales info.\n     *                  See {_canSetPrimarySaleRecipient}.\n     *                  Emits {PrimarySaleRecipientUpdated Event}; See {_setupPrimarySaleRecipient}.\n     *\n     *  @param _saleRecipient   Address to be set as new recipient of primary sales.\n     */\n    function setPrimarySaleRecipient(address _saleRecipient) external override {\n        if (!_canSetPrimarySaleRecipient()) {\n            revert(\"Not authorized\");\n        }\n        _setupPrimarySaleRecipient(_saleRecipient);\n    }\n\n    /// @dev Lets a contract admin set the recipient for all primary sales.\n    function _setupPrimarySaleRecipient(address _saleRecipient) internal {\n        recipient = _saleRecipient;\n        emit PrimarySaleRecipientUpdated(_saleRecipient);\n    }\n\n    /// @dev Returns whether primary sale recipient can be set in the given execution context.\n    function _canSetPrimarySaleRecipient() internal view virtual returns (bool);\n}\n"
51     },
52     "@thirdweb-dev/contracts/extension/Royalty.sol": {
53       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./interface/IRoyalty.sol\";\n\n/**\n *  @title   Royalty\n *  @notice  Thirdweb's `Royalty` is a contract extension to be used with any base contract. It exposes functions for setting and reading\n *           the recipient of royalty fee and the royalty fee basis points, and lets the inheriting contract perform conditional logic\n *           that uses information about royalty fees, if desired.\n *\n *  @dev     The `Royalty` contract is ERC2981 compliant.\n */\n\nabstract contract Royalty is IRoyalty {\n    /// @dev The (default) address that receives all royalty value.\n    address private royaltyRecipient;\n\n    /// @dev The (default) % of a sale to take as royalty (in basis points).\n    uint16 private royaltyBps;\n\n    /// @dev Token ID => royalty recipient and bps for token\n    mapping(uint256 => RoyaltyInfo) private royaltyInfoForToken;\n\n    /**\n     *  @notice   View royalty info for a given token and sale price.\n     *  @dev      Returns royalty amount and recipient for `tokenId` and `salePrice`.\n     *  @param tokenId          The tokenID of the NFT for which to query royalty info.\n     *  @param salePrice        Sale price of the token.\n     *\n     *  @return receiver        Address of royalty recipient account.\n     *  @return royaltyAmount   Royalty amount calculated at current royaltyBps value.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        virtual\n        override\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        (address recipient, uint256 bps) = getRoyaltyInfoForToken(tokenId);\n        receiver = recipient;\n        royaltyAmount = (salePrice * bps) / 10_000;\n    }\n\n    /**\n     *  @notice          View royalty info for a given token.\n     *  @dev             Returns royalty recipient and bps for `_tokenId`.\n     *  @param _tokenId  The tokenID of the NFT for which to query royalty info.\n     */\n    function getRoyaltyInfoForToken(uint256 _tokenId) public view override returns (address, uint16) {\n        RoyaltyInfo memory royaltyForToken = royaltyInfoForToken[_tokenId];\n\n        return\n            royaltyForToken.recipient == address(0)\n                ? (royaltyRecipient, uint16(royaltyBps))\n                : (royaltyForToken.recipient, uint16(royaltyForToken.bps));\n    }\n\n    /**\n     *  @notice Returns the defualt royalty recipient and BPS for this contract's NFTs.\n     */\n    function getDefaultRoyaltyInfo() external view override returns (address, uint16) {\n        return (royaltyRecipient, uint16(royaltyBps));\n    }\n\n    /**\n     *  @notice         Updates default royalty recipient and bps.\n     *  @dev            Caller should be authorized to set royalty info.\n     *                  See {_canSetRoyaltyInfo}.\n     *                  Emits {DefaultRoyalty Event}; See {_setupDefaultRoyaltyInfo}.\n     *\n     *  @param _royaltyRecipient   Address to be set as default royalty recipient.\n     *  @param _royaltyBps         Updated royalty bps.\n     */\n    function setDefaultRoyaltyInfo(address _royaltyRecipient, uint256 _royaltyBps) external override {\n        if (!_canSetRoyaltyInfo()) {\n            revert(\"Not authorized\");\n        }\n\n        _setupDefaultRoyaltyInfo(_royaltyRecipient, _royaltyBps);\n    }\n\n    /// @dev Lets a contract admin update the default royalty recipient and bps.\n    function _setupDefaultRoyaltyInfo(address _royaltyRecipient, uint256 _royaltyBps) internal {\n        if (_royaltyBps > 10_000) {\n            revert(\"Exceeds max bps\");\n        }\n\n        royaltyRecipient = _royaltyRecipient;\n        royaltyBps = uint16(_royaltyBps);\n\n        emit DefaultRoyalty(_royaltyRecipient, _royaltyBps);\n    }\n\n    /**\n     *  @notice         Updates default royalty recipient and bps for a particular token.\n     *  @dev            Sets royalty info for `_tokenId`. Caller should be authorized to set royalty info.\n     *                  See {_canSetRoyaltyInfo}.\n     *                  Emits {RoyaltyForToken Event}; See {_setupRoyaltyInfoForToken}.\n     *\n     *  @param _recipient   Address to be set as royalty recipient for given token Id.\n     *  @param _bps         Updated royalty bps for the token Id.\n     */\n    function setRoyaltyInfoForToken(\n        uint256 _tokenId,\n        address _recipient,\n        uint256 _bps\n    ) external override {\n        if (!_canSetRoyaltyInfo()) {\n            revert(\"Not authorized\");\n        }\n\n        _setupRoyaltyInfoForToken(_tokenId, _recipient, _bps);\n    }\n\n    /// @dev Lets a contract admin set the royalty recipient and bps for a particular token Id.\n    function _setupRoyaltyInfoForToken(\n        uint256 _tokenId,\n        address _recipient,\n        uint256 _bps\n    ) internal {\n        if (_bps > 10_000) {\n            revert(\"Exceeds max bps\");\n        }\n\n        royaltyInfoForToken[_tokenId] = RoyaltyInfo({ recipient: _recipient, bps: _bps });\n\n        emit RoyaltyForToken(_tokenId, _recipient, _bps);\n    }\n\n    /// @dev Returns whether royalty info can be set in the given execution context.\n    function _canSetRoyaltyInfo() internal view virtual returns (bool);\n}\n"
54     },
55     "@thirdweb-dev/contracts/extension/interface/IClaimCondition.sol": {
56       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"../../lib/TWBitMaps.sol\";\n\n/**\n *  Thirdweb's 'Drop' contracts are distribution mechanisms for tokens.\n *\n *  A contract admin (i.e. a holder of `DEFAULT_ADMIN_ROLE`) can set a series of claim conditions,\n *  ordered by their respective `startTimestamp`. A claim condition defines criteria under which\n *  accounts can mint tokens. Claim conditions can be overwritten or added to by the contract admin.\n *  At any moment, there is only one active claim condition.\n */\n\ninterface IClaimCondition {\n    /**\n     *  @notice The criteria that make up a claim condition.\n     *\n     *  @param startTimestamp                 The unix timestamp after which the claim condition applies.\n     *                                        The same claim condition applies until the `startTimestamp`\n     *                                        of the next claim condition.\n     *\n     *  @param maxClaimableSupply             The maximum total number of tokens that can be claimed under\n     *                                        the claim condition.\n     *\n     *  @param supplyClaimed                  At any given point, the number of tokens that have been claimed\n     *                                        under the claim condition.\n     *\n     *  @param quantityLimitPerTransaction    The maximum number of tokens that can be claimed in a single\n     *                                        transaction.\n     *\n     *  @param waitTimeInSecondsBetweenClaims The least number of seconds an account must wait after claiming\n     *                                        tokens, to be able to claim tokens again.\n     *\n     *  @param merkleRoot                     The allowlist of addresses that can claim tokens under the claim\n     *                                        condition.\n     *\n     *  @param pricePerToken                  The price required to pay per token claimed.\n     *\n     *  @param currency                       The currency in which the `pricePerToken` must be paid.\n     */\n    struct ClaimCondition {\n        uint256 startTimestamp;\n        uint256 maxClaimableSupply;\n        uint256 supplyClaimed;\n        uint256 quantityLimitPerTransaction;\n        uint256 waitTimeInSecondsBetweenClaims;\n        bytes32 merkleRoot;\n        uint256 pricePerToken;\n        address currency;\n    }\n}\n"
57     },
58     "@thirdweb-dev/contracts/extension/interface/IContractMetadata.sol": {
59       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/**\n *  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\n *  for you contract.\n *\n *  Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\n */\n\ninterface IContractMetadata {\n    /// @dev Returns the metadata URI of the contract.\n    function contractURI() external view returns (string memory);\n\n    /**\n     *  @dev Sets contract URI for the storefront-level metadata of the contract.\n     *       Only module admin can call this function.\n     */\n    function setContractURI(string calldata _uri) external;\n\n    /// @dev Emitted when the contract URI is updated.\n    event ContractURIUpdated(string prevURI, string newURI);\n}\n"
60     },
61     "@thirdweb-dev/contracts/extension/interface/IDelayedReveal.sol": {
62       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/**\n *  Thirdweb's `DelayedReveal` is a contract extension for base NFT contracts. It lets you create batches of\n *  'delayed-reveal' NFTs. You can learn more about the usage of delayed reveal NFTs here - https://blog.thirdweb.com/delayed-reveal-nfts\n */\n\ninterface IDelayedReveal {\n    /// @dev Emitted when tokens are revealed.\n    event TokenURIRevealed(uint256 indexed index, string revealedURI);\n\n    /**\n     *  @notice Reveals a batch of delayed reveal NFTs.\n     *\n     *  @param identifier The ID for the batch of delayed-reveal NFTs to reveal.\n     *\n     *  @param key        The key with which the base URI for the relevant batch of NFTs was encrypted.\n     */\n    function reveal(uint256 identifier, bytes calldata key) external returns (string memory revealedURI);\n\n    /**\n     *  @notice Performs XOR encryption/decryption.\n     *\n     *  @param data The data to encrypt. In the case of delayed-reveal NFTs, this is the \"revealed\" state\n     *              base URI of the relevant batch of NFTs.\n     *\n     *  @param key  The key with which to encrypt data\n     */\n    function encryptDecrypt(bytes memory data, bytes calldata key) external pure returns (bytes memory result);\n}\n"
63     },
64     "@thirdweb-dev/contracts/extension/interface/IDropSinglePhase1155.sol": {
65       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./IClaimCondition.sol\";\n\ninterface IDropSinglePhase1155 is IClaimCondition {\n    struct AllowlistProof {\n        bytes32[] proof;\n        uint256 maxQuantityInAllowlist;\n    }\n\n    /// @dev Emitted when tokens are claimed via `claim`.\n    event TokensClaimed(\n        address indexed claimer,\n        address indexed receiver,\n        uint256 indexed tokenId,\n        uint256 quantityClaimed\n    );\n\n    /// @dev Emitted when the contract's claim conditions are updated.\n    event ClaimConditionUpdated(uint256 indexed tokenId, ClaimCondition condition, bool resetEligibility);\n\n    /**\n     *  @notice Lets an account claim a given quantity of NFTs.\n     *\n     *  @param tokenId                        The tokenId of the NFT to claim.\n     *  @param receiver                       The receiver of the NFT to claim.\n     *  @param quantity                       The quantity of the NFT to claim.\n     *  @param currency                       The currency in which to pay for the claim.\n     *  @param pricePerToken                  The price per token to pay for the claim.\n     *  @param allowlistProof                 The proof of the claimer's inclusion in the merkle root allowlist\n     *                                        of the claim conditions that apply.\n     *  @param data                           Arbitrary bytes data that can be leveraged in the implementation of this interface.\n     */\n    function claim(\n        address receiver,\n        uint256 tokenId,\n        uint256 quantity,\n        address currency,\n        uint256 pricePerToken,\n        AllowlistProof calldata allowlistProof,\n        bytes memory data\n    ) external payable;\n\n    /**\n     *  @notice Lets a contract admin (account with `DEFAULT_ADMIN_ROLE`) set claim conditions.\n     *\n     *  @param phase                    Claim condition to set.\n     *\n     *  @param resetClaimEligibility    Whether to reset `limitLastClaimTimestamp` and `limitMerkleProofClaim` values when setting new\n     *                                  claim conditions.\n     *\n     *  @param tokenId                  The tokenId for which to set the relevant claim condition.\n     */\n    function setClaimConditions(\n        uint256 tokenId,\n        ClaimCondition calldata phase,\n        bool resetClaimEligibility\n    ) external;\n}\n"
66     },
67     "@thirdweb-dev/contracts/extension/interface/ILazyMint.sol": {
68       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/**\n *  Thirdweb's `LazyMint` is a contract extension for any base NFT contract. It lets you 'lazy mint' any number of NFTs\n *  at once. Here, 'lazy mint' means defining the metadata for particular tokenIds of your NFT contract, without actually\n *  minting a non-zero balance of NFTs of those tokenIds.\n */\n\ninterface ILazyMint {\n    /// @dev Emitted when tokens are lazy minted.\n    event TokensLazyMinted(uint256 indexed startTokenId, uint256 endTokenId, string baseURI, bytes encryptedBaseURI);\n\n    /**\n     *  @notice Lazy mints a given amount of NFTs.\n     *\n     *  @param amount           The number of NFTs to lazy mint.\n     *\n     *  @param baseURIForTokens The base URI for the 'n' number of NFTs being lazy minted, where the metadata for each\n     *                          of those NFTs is `${baseURIForTokens}/${tokenId}`.\n     *\n     *  @param extraData        Additional bytes data to be used at the discretion of the consumer of the contract.\n     *\n     *  @return batchId         A unique integer identifier for the batch of NFTs lazy minted together.\n     */\n    function lazyMint(\n        uint256 amount,\n        string calldata baseURIForTokens,\n        bytes calldata extraData\n    ) external returns (uint256 batchId);\n}\n"
69     },
70     "@thirdweb-dev/contracts/extension/interface/IMulticall.sol": {
71       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\ninterface IMulticall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results);\n}\n"
72     },
73     "@thirdweb-dev/contracts/extension/interface/IOwnable.sol": {
74       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/**\n *  Thirdweb's `Ownable` is a contract extension to be used with any base contract. It exposes functions for setting and reading\n *  who the 'owner' of the inheriting smart contract is, and lets the inheriting contract perform conditional logic that uses\n *  information about who the contract's owner is.\n */\n\ninterface IOwnable {\n    /// @dev Returns the owner of the contract.\n    function owner() external view returns (address);\n\n    /// @dev Lets a module admin set a new owner for the contract. The new owner must be a module admin.\n    function setOwner(address _newOwner) external;\n\n    /// @dev Emitted when a new Owner is set.\n    event OwnerUpdated(address indexed prevOwner, address indexed newOwner);\n}\n"
75     },
76     "@thirdweb-dev/contracts/extension/interface/IPrimarySale.sol": {
77       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/**\n *  Thirdweb's `Primary` is a contract extension to be used with any base contract. It exposes functions for setting and reading\n *  the recipient of primary sales, and lets the inheriting contract perform conditional logic that uses information about\n *  primary sales, if desired.\n */\n\ninterface IPrimarySale {\n    /// @dev The adress that receives all primary sales value.\n    function primarySaleRecipient() external view returns (address);\n\n    /// @dev Lets a module admin set the default recipient of all primary sales.\n    function setPrimarySaleRecipient(address _saleRecipient) external;\n\n    /// @dev Emitted when a new sale recipient is set.\n    event PrimarySaleRecipientUpdated(address indexed recipient);\n}\n"
78     },
79     "@thirdweb-dev/contracts/extension/interface/IRoyalty.sol": {
80       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"../../eip/interface/IERC2981.sol\";\n\n/**\n *  Thirdweb's `Royalty` is a contract extension to be used with any base contract. It exposes functions for setting and reading\n *  the recipient of royalty fee and the royalty fee basis points, and lets the inheriting contract perform conditional logic\n *  that uses information about royalty fees, if desired.\n *\n *  The `Royalty` contract is ERC2981 compliant.\n */\n\ninterface IRoyalty is IERC2981 {\n    struct RoyaltyInfo {\n        address recipient;\n        uint256 bps;\n    }\n\n    /// @dev Returns the royalty recipient and fee bps.\n    function getDefaultRoyaltyInfo() external view returns (address, uint16);\n\n    /// @dev Lets a module admin update the royalty bps and recipient.\n    function setDefaultRoyaltyInfo(address _royaltyRecipient, uint256 _royaltyBps) external;\n\n    /// @dev Lets a module admin set the royalty recipient for a particular token Id.\n    function setRoyaltyInfoForToken(\n        uint256 tokenId,\n        address recipient,\n        uint256 bps\n    ) external;\n\n    /// @dev Returns the royalty recipient for a particular token Id.\n    function getRoyaltyInfoForToken(uint256 tokenId) external view returns (address, uint16);\n\n    /// @dev Emitted when royalty info is updated.\n    event DefaultRoyalty(address indexed newRoyaltyRecipient, uint256 newRoyaltyBps);\n\n    /// @dev Emitted when royalty recipient for tokenId is set\n    event RoyaltyForToken(uint256 indexed tokenId, address indexed royaltyRecipient, uint256 royaltyBps);\n}\n"
81     },
82     "@thirdweb-dev/contracts/interfaces/IWETH.sol": {
83       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256 amount) external;\n\n    function transfer(address to, uint256 value) external returns (bool);\n}\n"
84     },
85     "@thirdweb-dev/contracts/lib/CurrencyTransferLib.sol": {
86       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n// Helper interfaces\nimport { IWETH } from \"../interfaces/IWETH.sol\";\n\nimport \"../openzeppelin-presets/token/ERC20/utils/SafeERC20.sol\";\n\nlibrary CurrencyTransferLib {\n    using SafeERC20 for IERC20;\n\n    /// @dev The address interpreted as native token of the chain.\n    address public constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Transfers a given amount of currency.\n    function transferCurrency(\n        address _currency,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        if (_amount == 0) {\n            return;\n        }\n\n        if (_currency == NATIVE_TOKEN) {\n            safeTransferNativeToken(_to, _amount);\n        } else {\n            safeTransferERC20(_currency, _from, _to, _amount);\n        }\n    }\n\n    /// @dev Transfers a given amount of currency. (With native token wrapping)\n    function transferCurrencyWithWrapper(\n        address _currency,\n        address _from,\n        address _to,\n        uint256 _amount,\n        address _nativeTokenWrapper\n    ) internal {\n        if (_amount == 0) {\n            return;\n        }\n\n        if (_currency == NATIVE_TOKEN) {\n            if (_from == address(this)) {\n                // withdraw from weth then transfer withdrawn native token to recipient\n                IWETH(_nativeTokenWrapper).withdraw(_amount);\n                safeTransferNativeTokenWithWrapper(_to, _amount, _nativeTokenWrapper);\n            } else if (_to == address(this)) {\n                // store native currency in weth\n                require(_amount == msg.value, \"msg.value != amount\");\n                IWETH(_nativeTokenWrapper).deposit{ value: _amount }();\n            } else {\n                safeTransferNativeTokenWithWrapper(_to, _amount, _nativeTokenWrapper);\n            }\n        } else {\n            safeTransferERC20(_currency, _from, _to, _amount);\n        }\n    }\n\n    /// @dev Transfer `amount` of ERC20 token from `from` to `to`.\n    function safeTransferERC20(\n        address _currency,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        if (_from == _to) {\n            return;\n        }\n\n        if (_from == address(this)) {\n            IERC20(_currency).safeTransfer(_to, _amount);\n        } else {\n            IERC20(_currency).safeTransferFrom(_from, _to, _amount);\n        }\n    }\n\n    /// @dev Transfers `amount` of native token to `to`.\n    function safeTransferNativeToken(address to, uint256 value) internal {\n        // solhint-disable avoid-low-level-calls\n        // slither-disable-next-line low-level-calls\n        (bool success, ) = to.call{ value: value }(\"\");\n        require(success, \"native token transfer failed\");\n    }\n\n    /// @dev Transfers `amount` of native token to `to`. (With native token wrapping)\n    function safeTransferNativeTokenWithWrapper(\n        address to,\n        uint256 value,\n        address _nativeTokenWrapper\n    ) internal {\n        // solhint-disable avoid-low-level-calls\n        // slither-disable-next-line low-level-calls\n        (bool success, ) = to.call{ value: value }(\"\");\n        if (!success) {\n            IWETH(_nativeTokenWrapper).deposit{ value: value }();\n            IERC20(_nativeTokenWrapper).safeTransfer(to, value);\n        }\n    }\n}\n"
87     },
88     "@thirdweb-dev/contracts/lib/MerkleProof.sol": {
89       "content": "// SPDX-License-Identifier: MIT\n// Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.3.0/contracts/utils/cryptography/MerkleProof.sol\n// Copied from https://github.com/ensdomains/governance/blob/master/contracts/MerkleProof.sol\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * Source: https://github.com/ensdomains/governance/blob/master/contracts/MerkleProof.sol\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool, uint256) {\n        bytes32 computedHash = leaf;\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            index *= 2;\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n                index += 1;\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return (computedHash == root, index);\n    }\n}\n"
90     },
91     "@thirdweb-dev/contracts/lib/TWAddress.sol": {
92       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary TWAddress {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * [EIP1884](https://eips.ethereum.org/EIPS/eip-1884) increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
93     },
94     "@thirdweb-dev/contracts/lib/TWBitMaps.sol": {
95       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/BitMaps.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\n * Largely inspired by Uniswap's [merkle-distributor](https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol).\n */\nlibrary TWBitMaps {\n    struct BitMap {\n        mapping(uint256 => uint256) _data;\n    }\n\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        return bitmap._data[bucket] & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index` to the boolean `value`.\n     */\n    function setTo(\n        BitMap storage bitmap,\n        uint256 index,\n        bool value\n    ) internal {\n        if (value) {\n            set(bitmap, index);\n        } else {\n            unset(bitmap, index);\n        }\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] |= mask;\n    }\n\n    /**\n     * @dev Unsets the bit at `index`.\n     */\n    function unset(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] &= ~mask;\n    }\n}\n"
96     },
97     "@thirdweb-dev/contracts/lib/TWStrings.sol": {
98       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary TWStrings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
99     },
100     "@thirdweb-dev/contracts/openzeppelin-presets/token/ERC20/utils/SafeERC20.sol": {
101       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../../../eip/interface/IERC20.sol\";\nimport \"../../../../lib/TWAddress.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using TWAddress for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
102     },
103     "contracts/OBYCLabs.sol": {
104       "content": "// SPDX-License-Identifier: Apache-2.0\n\n/******************************************\n *  Amendeded by OBYC Labs Development    *\n *         Author: devAlex.eth            *\n ******************************************/\n\n//     _     _      _     _      _     _      _     _   \n//    (c).-.(c)    (c).-.(c)    (c).-.(c)    (c).-.(c)  \n//     / ._. \\      / ._. \\      / ._. \\      / ._. \\   \n//   __\\( Y )/__  __\\( Y )/__  __\\( Y )/__  __\\( Y )/__ \n//  (_.-/'-'\\-._)(_.-/'-'\\-._)(_.-/'-'\\-._)(_.-/'-'\\-._)\n//     || O ||      || B ||      || Y ||      || C ||   \n//   _.' `-' '._  _.' `-' '._  _.' `-' '._  _.' `-' '._ \n//  (.-./`-'\\.-.)(.-./`-'\\.-.)(.-./`-'\\.-.)(.-./`-'\\.-.)\n//   `-'     `-'  `-'     `-'  `-'     `-'  `-'     `-' \n\n\npragma solidity ^0.8.0;\n\nimport \"@thirdweb-dev/contracts/base/ERC1155Drop.sol\";\n\ncontract OBYCLabs is ERC1155Drop {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _royaltyRecipient,\n        uint128 _royaltyBps,\n        address _primarySaleRecipient\n    )\n        ERC1155Drop(\n            _name,\n            _symbol,\n            _royaltyRecipient,\n            _royaltyBps,\n            _primarySaleRecipient\n        )\n    {}\n}"
105     }
106   },
107   "settings": {
108     "optimizer": {
109       "enabled": true,
110       "runs": 200
111     },
112     "evmVersion": "london",
113     "remappings": [],
114     "outputSelection": {
115       "*": {
116         "*": [
117           "evm.bytecode",
118           "evm.deployedBytecode",
119           "devdoc",
120           "userdoc",
121           "metadata",
122           "abi"
123         ]
124       }
125     }
126   }
127 }}