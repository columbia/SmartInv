1 {"ERC721.sol":{"content":"pragma solidity \u003e=0.6.0 \u003c0.8.0;\npragma experimental ABIEncoderV2;\n\nabstract contract Context {\n\tfunction _msgSender() internal view virtual returns (address payable) {\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view virtual returns (bytes memory) {\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\t\treturn msg.data;\n\t}\n}\n\nlibrary Base64 {\n\tbytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n\t/// @notice Encodes some bytes to the base64 representation\n\tfunction encode(bytes memory data) internal pure returns (string memory) {\n\t\tuint256 len = data.length;\n\t\tif (len == 0) return \"\";\n\n\t\t// multiply by 4/3 rounded up\n\t\tuint256 encodedLen = 4 * ((len + 2) / 3);\n\n\t\t// Add some extra buffer at the end\n\t\tbytes memory result = new bytes(encodedLen + 32);\n\n\t\tbytes memory table = TABLE;\n\n\t\tassembly {\n\t\t\tlet tablePtr := add(table, 1)\n\t\t\tlet resultPtr := add(result, 32)\n\n\t\t\tfor {\n\t\t\t\tlet i := 0\n\t\t\t} lt(i, len) {\n\n\t\t\t} {\n\t\t\t\ti := add(i, 3)\n\t\t\t\tlet input := and(mload(add(data, i)), 0xffffff)\n\n\t\t\t\tlet out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n\t\t\t\tout := shl(8, out)\n\t\t\t\tout := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n\t\t\t\tout := shl(8, out)\n\t\t\t\tout := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n\t\t\t\tout := shl(8, out)\n\t\t\t\tout := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n\t\t\t\tout := shl(224, out)\n\n\t\t\t\tmstore(resultPtr, out)\n\n\t\t\t\tresultPtr := add(resultPtr, 4)\n\t\t\t}\n\n\t\t\tswitch mod(len, 3)\n\t\t\tcase 1 {\n\t\t\t\tmstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n\t\t\t}\n\t\t\tcase 2 {\n\t\t\t\tmstore(sub(resultPtr, 1), shl(248, 0x3d))\n\t\t\t}\n\n\t\t\tmstore(result, encodedLen)\n\t\t}\n\n\t\treturn string(result);\n\t}\n}\n\ninterface LootInterface {\n\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\n}\n\nabstract contract Ownable is Context {\n\taddress private _owner;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tconstructor () internal {\n\t\t//address msgSender = _msgSender();\n\t\t_owner = 0x8Ce045fEbF4772070F1e983241763306889D14d3;\n\t\t//emit OwnershipTransferred(address(0), msgSender);\n\t}\n\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view virtual returns (address) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Leaves the contract without owner. It will not be possible to call\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\n\t *\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\n\t * thereby removing any functionality that is only available to the owner.\n\t */\n\tfunction renounceOwnership() public virtual onlyOwner {\n\t\temit OwnershipTransferred(_owner, address(0));\n\t\t_owner = address(0);\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}\n\nabstract contract ReentrancyGuard {\n\t// Booleans are more expensive than uint256 or any type that takes up a full\n\t// word because each write operation emits an extra SLOAD to first read the\n\t// slot\u0027s contents, replace the bits taken up by the boolean, and then write\n\t// back. This is the compiler\u0027s defense against contract upgrades and\n\t// pointer aliasing, and it cannot be disabled.\n\n\t// The values being non-zero value makes deployment a bit more expensive,\n\t// but in exchange the refund on every call to nonReentrant will be lower in\n\t// amount. Since refunds are capped to a percentage of the total\n\t// transaction\u0027s gas, it is best to keep them low in cases like this one, to\n\t// increase the likelihood of the full refund coming into effect.\n\tuint256 private constant _NOT_ENTERED = 1;\n\tuint256 private constant _ENTERED = 2;\n\n\tuint256 private _status;\n\n\tconstructor() {\n\t\t_status = _NOT_ENTERED;\n\t}\n\n\t/**\n\t * @dev Prevents a contract from calling itself, directly or indirectly.\n\t * Calling a `nonReentrant` function from another `nonReentrant`\n\t * function is not supported. It is possible to prevent this from happening\n\t * by making the `nonReentrant` function external, and make it call a\n\t * `private` function that does the actual work.\n\t */\n\tmodifier nonReentrant() {\n\t\t// On the first call to nonReentrant, _notEntered will be true\n\t\trequire(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n\t\t// Any calls to nonReentrant after this point will fail\n\t\t_status = _ENTERED;\n\n\t\t_;\n\n\t\t// By storing the original value once again, a refund is triggered (see\n\t\t// https://eips.ethereum.org/EIPS/eip-2200)\n\t\t_status = _NOT_ENTERED;\n\t}\n}\n\ninterface IERC721Receiver {\n\t/**\n\t * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n\t * by `operator` from `from`, this function is called.\n\t *\n\t * It must return its Solidity selector to confirm the token transfer.\n\t * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n\t *\n\t * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n\t */\n\tfunction onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n\nlibrary Strings {\n\t/**\n\t * @dev Converts a `uint256` to its ASCII `string` representation.\n\t */\n\tfunction toString(uint256 value) internal pure returns (string memory) {\n\t\t// Inspired by OraclizeAPI\u0027s implementation - MIT licence\n\t\t// https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n\t\tif (value == 0) {\n\t\t\treturn \"0\";\n\t\t}\n\t\tuint256 temp = value;\n\t\tuint256 digits;\n\t\twhile (temp != 0) {\n\t\t\tdigits++;\n\t\t\ttemp /= 10;\n\t\t}\n\t\tbytes memory buffer = new bytes(digits);\n\t\tuint256 index = digits - 1;\n\t\ttemp = value;\n\t\twhile (temp != 0) {\n\t\t\tbuffer[index--] = bytes1(uint8(48 + temp % 10));\n\t\t\ttemp /= 10;\n\t\t}\n\t\treturn string(buffer);\n\t}\n}\n\nlibrary EnumerableMap {\n\t// To implement this library for multiple types with as little code\n\t// repetition as possible, we write it in terms of a generic Map type with\n\t// bytes32 keys and values.\n\t// The Map implementation uses private functions, and user-facing\n\t// implementations (such as Uint256ToAddressMap) are just wrappers around\n\t// the underlying Map.\n\t// This means that we can only create new EnumerableMaps for types that fit\n\t// in bytes32.\n\n\tstruct MapEntry {\n\t\tbytes32 _key;\n\t\tbytes32 _value;\n\t}\n\n\tstruct Map {\n\t\t// Storage of map keys and values\n\t\tMapEntry[] _entries;\n\n\t\t// Position of the entry defined by a key in the `entries` array, plus 1\n\t\t// because index 0 means a key is not in the map.\n\t\tmapping (bytes32 =\u003e uint256) _indexes;\n\t}\n\n\t/**\n\t * @dev Adds a key-value pair to a map, or updates the value for an existing\n\t * key. O(1).\n\t *\n\t * Returns true if the key was added to the map, that is if it was not\n\t * already present.\n\t */\n\tfunction _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n\t\t// We read and store the key\u0027s index to prevent multiple reads from the same storage slot\n\t\tuint256 keyIndex = map._indexes[key];\n\n\t\tif (keyIndex == 0) { // Equivalent to !contains(map, key)\n\t\t\tmap._entries.push(MapEntry({ _key: key, _value: value }));\n\t\t\t// The entry is stored at length-1, but we add 1 to all indexes\n\t\t\t// and use 0 as a sentinel value\n\t\t\tmap._indexes[key] = map._entries.length;\n\t\t\treturn true;\n\t\t} else {\n\t\t\tmap._entries[keyIndex - 1]._value = value;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Removes a key-value pair from a map. O(1).\n\t *\n\t * Returns true if the key was removed from the map, that is if it was present.\n\t */\n\tfunction _remove(Map storage map, bytes32 key) private returns (bool) {\n\t\t// We read and store the key\u0027s index to prevent multiple reads from the same storage slot\n\t\tuint256 keyIndex = map._indexes[key];\n\n\t\tif (keyIndex != 0) { // Equivalent to contains(map, key)\n\t\t\t// To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n\t\t\t// in the array, and then remove the last entry (sometimes called as \u0027swap and pop\u0027).\n\t\t\t// This modifies the order of the array, as noted in {at}.\n\n\t\t\tuint256 toDeleteIndex = keyIndex - 1;\n\t\t\tuint256 lastIndex = map._entries.length - 1;\n\n\t\t\t// When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n\t\t\t// so rarely, we still do the swap anyway to avoid the gas cost of adding an \u0027if\u0027 statement.\n\n\t\t\tMapEntry storage lastEntry = map._entries[lastIndex];\n\n\t\t\t// Move the last entry to the index where the entry to delete is\n\t\t\tmap._entries[toDeleteIndex] = lastEntry;\n\t\t\t// Update the index for the moved entry\n\t\t\tmap._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n\t\t\t// Delete the slot where the moved entry was stored\n\t\t\tmap._entries.pop();\n\n\t\t\t// Delete the index for the deleted slot\n\t\t\tdelete map._indexes[key];\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns true if the key is in the map. O(1).\n\t */\n\tfunction _contains(Map storage map, bytes32 key) private view returns (bool) {\n\t\treturn map._indexes[key] != 0;\n\t}\n\n\t/**\n\t * @dev Returns the number of key-value pairs in the map. O(1).\n\t */\n\tfunction _length(Map storage map) private view returns (uint256) {\n\t\treturn map._entries.length;\n\t}\n\n\t/**\n\t * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n\t *\n\t * Note that there are no guarantees on the ordering of entries inside the\n\t * array, and it may change when more entries are added or removed.\n\t *\n\t * Requirements:\n\t *\n\t * - `index` must be strictly less than {length}.\n\t */\n\tfunction _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n\t\trequire(map._entries.length \u003e index, \"EnumerableMap: index out of bounds\");\n\n\t\tMapEntry storage entry = map._entries[index];\n\t\treturn (entry._key, entry._value);\n\t}\n\n\t/**\n\t * @dev Tries to returns the value associated with `key`.  O(1).\n\t * Does not revert if `key` is not in the map.\n\t */\n\tfunction _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n\t\tuint256 keyIndex = map._indexes[key];\n\t\tif (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n\t\treturn (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n\t}\n\n\t/**\n\t * @dev Returns the value associated with `key`.  O(1).\n\t *\n\t * Requirements:\n\t *\n\t * - `key` must be in the map.\n\t */\n\tfunction _get(Map storage map, bytes32 key) private view returns (bytes32) {\n\t\tuint256 keyIndex = map._indexes[key];\n\t\trequire(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n\t\treturn map._entries[keyIndex - 1]._value; // All indexes are 1-based\n\t}\n\n\t/**\n\t * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n\t *\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\n\t * message unnecessarily. For custom revert reasons use {_tryGet}.\n\t */\n\tfunction _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n\t\tuint256 keyIndex = map._indexes[key];\n\t\trequire(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n\t\treturn map._entries[keyIndex - 1]._value; // All indexes are 1-based\n\t}\n\n\t// UintToAddressMap\n\n\tstruct UintToAddressMap {\n\t\tMap _inner;\n\t}\n\n\t/**\n\t * @dev Adds a key-value pair to a map, or updates the value for an existing\n\t * key. O(1).\n\t *\n\t * Returns true if the key was added to the map, that is if it was not\n\t * already present.\n\t */\n\tfunction set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n\t\treturn _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n\t}\n\n\t/**\n\t * @dev Removes a value from a set. O(1).\n\t *\n\t * Returns true if the key was removed from the map, that is if it was present.\n\t */\n\tfunction remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n\t\treturn _remove(map._inner, bytes32(key));\n\t}\n\n\t/**\n\t * @dev Returns true if the key is in the map. O(1).\n\t */\n\tfunction contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n\t\treturn _contains(map._inner, bytes32(key));\n\t}\n\n\t/**\n\t * @dev Returns the number of elements in the map. O(1).\n\t */\n\tfunction length(UintToAddressMap storage map) internal view returns (uint256) {\n\t\treturn _length(map._inner);\n\t}\n\n\t/**\n\t * @dev Returns the element stored at position `index` in the set. O(1).\n\t * Note that there are no guarantees on the ordering of values inside the\n\t * array, and it may change when more values are added or removed.\n\t *\n\t * Requirements:\n\t *\n\t * - `index` must be strictly less than {length}.\n\t */\n\tfunction at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n\t\t(bytes32 key, bytes32 value) = _at(map._inner, index);\n\t\treturn (uint256(key), address(uint160(uint256(value))));\n\t}\n\n\t/**\n\t * @dev Tries to returns the value associated with `key`.  O(1).\n\t * Does not revert if `key` is not in the map.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n\t\t(bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n\t\treturn (success, address(uint160(uint256(value))));\n\t}\n\n\t/**\n\t * @dev Returns the value associated with `key`.  O(1).\n\t *\n\t * Requirements:\n\t *\n\t * - `key` must be in the map.\n\t */\n\tfunction get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n\t\treturn address(uint160(uint256(_get(map._inner, bytes32(key)))));\n\t}\n\n\t/**\n\t * @dev Same as {get}, with a custom error message when `key` is not in the map.\n\t *\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\n\t * message unnecessarily. For custom revert reasons use {tryGet}.\n\t */\n\tfunction get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n\t\treturn address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n\t}\n}\n\nlibrary EnumerableSet {\n\t// To implement this library for multiple types with as little code\n\t// repetition as possible, we write it in terms of a generic Set type with\n\t// bytes32 values.\n\t// The Set implementation uses private functions, and user-facing\n\t// implementations (such as AddressSet) are just wrappers around the\n\t// underlying Set.\n\t// This means that we can only create new EnumerableSets for types that fit\n\t// in bytes32.\n\n\tstruct Set {\n\t\t// Storage of set values\n\t\tbytes32[] _values;\n\n\t\t// Position of the value in the `values` array, plus 1 because index 0\n\t\t// means a value is not in the set.\n\t\tmapping (bytes32 =\u003e uint256) _indexes;\n\t}\n\n\t/**\n\t * @dev Add a value to a set. O(1).\n\t *\n\t * Returns true if the value was added to the set, that is if it was not\n\t * already present.\n\t */\n\tfunction _add(Set storage set, bytes32 value) private returns (bool) {\n\t\tif (!_contains(set, value)) {\n\t\t\tset._values.push(value);\n\t\t\t// The value is stored at length-1, but we add 1 to all indexes\n\t\t\t// and use 0 as a sentinel value\n\t\t\tset._indexes[value] = set._values.length;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Removes a value from a set. O(1).\n\t *\n\t * Returns true if the value was removed from the set, that is if it was\n\t * present.\n\t */\n\tfunction _remove(Set storage set, bytes32 value) private returns (bool) {\n\t\t// We read and store the value\u0027s index to prevent multiple reads from the same storage slot\n\t\tuint256 valueIndex = set._indexes[value];\n\n\t\tif (valueIndex != 0) { // Equivalent to contains(set, value)\n\t\t\t// To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n\t\t\t// the array, and then remove the last element (sometimes called as \u0027swap and pop\u0027).\n\t\t\t// This modifies the order of the array, as noted in {at}.\n\n\t\t\tuint256 toDeleteIndex = valueIndex - 1;\n\t\t\tuint256 lastIndex = set._values.length - 1;\n\n\t\t\t// When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n\t\t\t// so rarely, we still do the swap anyway to avoid the gas cost of adding an \u0027if\u0027 statement.\n\n\t\t\tbytes32 lastvalue = set._values[lastIndex];\n\n\t\t\t// Move the last value to the index where the value to delete is\n\t\t\tset._values[toDeleteIndex] = lastvalue;\n\t\t\t// Update the index for the moved value\n\t\t\tset._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n\t\t\t// Delete the slot where the moved value was stored\n\t\t\tset._values.pop();\n\n\t\t\t// Delete the index for the deleted slot\n\t\t\tdelete set._indexes[value];\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns true if the value is in the set. O(1).\n\t */\n\tfunction _contains(Set storage set, bytes32 value) private view returns (bool) {\n\t\treturn set._indexes[value] != 0;\n\t}\n\n\t/**\n\t * @dev Returns the number of values on the set. O(1).\n\t */\n\tfunction _length(Set storage set) private view returns (uint256) {\n\t\treturn set._values.length;\n\t}\n\n\t/**\n\t * @dev Returns the value stored at position `index` in the set. O(1).\n\t *\n\t * Note that there are no guarantees on the ordering of values inside the\n\t * array, and it may change when more values are added or removed.\n\t *\n\t * Requirements:\n\t *\n\t * - `index` must be strictly less than {length}.\n\t */\n\tfunction _at(Set storage set, uint256 index) private view returns (bytes32) {\n\t\trequire(set._values.length \u003e index, \"EnumerableSet: index out of bounds\");\n\t\treturn set._values[index];\n\t}\n\n\t// Bytes32Set\n\n\tstruct Bytes32Set {\n\t\tSet _inner;\n\t}\n\n\t/**\n\t * @dev Add a value to a set. O(1).\n\t *\n\t * Returns true if the value was added to the set, that is if it was not\n\t * already present.\n\t */\n\tfunction add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n\t\treturn _add(set._inner, value);\n\t}\n\n\t/**\n\t * @dev Removes a value from a set. O(1).\n\t *\n\t * Returns true if the value was removed from the set, that is if it was\n\t * present.\n\t */\n\tfunction remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n\t\treturn _remove(set._inner, value);\n\t}\n\n\t/**\n\t * @dev Returns true if the value is in the set. O(1).\n\t */\n\tfunction contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n\t\treturn _contains(set._inner, value);\n\t}\n\n\t/**\n\t * @dev Returns the number of values in the set. O(1).\n\t */\n\tfunction length(Bytes32Set storage set) internal view returns (uint256) {\n\t\treturn _length(set._inner);\n\t}\n\n\t/**\n\t * @dev Returns the value stored at position `index` in the set. O(1).\n\t *\n\t * Note that there are no guarantees on the ordering of values inside the\n\t * array, and it may change when more values are added or removed.\n\t *\n\t * Requirements:\n\t *\n\t * - `index` must be strictly less than {length}.\n\t */\n\tfunction at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n\t\treturn _at(set._inner, index);\n\t}\n\n\t// AddressSet\n\n\tstruct AddressSet {\n\t\tSet _inner;\n\t}\n\n\t/**\n\t * @dev Add a value to a set. O(1).\n\t *\n\t * Returns true if the value was added to the set, that is if it was not\n\t * already present.\n\t */\n\tfunction add(AddressSet storage set, address value) internal returns (bool) {\n\t\treturn _add(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\t/**\n\t * @dev Removes a value from a set. O(1).\n\t *\n\t * Returns true if the value was removed from the set, that is if it was\n\t * present.\n\t */\n\tfunction remove(AddressSet storage set, address value) internal returns (bool) {\n\t\treturn _remove(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\t/**\n\t * @dev Returns true if the value is in the set. O(1).\n\t */\n\tfunction contains(AddressSet storage set, address value) internal view returns (bool) {\n\t\treturn _contains(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\t/**\n\t * @dev Returns the number of values in the set. O(1).\n\t */\n\tfunction length(AddressSet storage set) internal view returns (uint256) {\n\t\treturn _length(set._inner);\n\t}\n\n\t/**\n\t * @dev Returns the value stored at position `index` in the set. O(1).\n\t *\n\t * Note that there are no guarantees on the ordering of values inside the\n\t * array, and it may change when more values are added or removed.\n\t *\n\t * Requirements:\n\t *\n\t * - `index` must be strictly less than {length}.\n\t */\n\tfunction at(AddressSet storage set, uint256 index) internal view returns (address) {\n\t\treturn address(uint160(uint256(_at(set._inner, index))));\n\t}\n\n\n\t// UintSet\n\n\tstruct UintSet {\n\t\tSet _inner;\n\t}\n\n\t/**\n\t * @dev Add a value to a set. O(1).\n\t *\n\t * Returns true if the value was added to the set, that is if it was not\n\t * already present.\n\t */\n\tfunction add(UintSet storage set, uint256 value) internal returns (bool) {\n\t\treturn _add(set._inner, bytes32(value));\n\t}\n\n\t/**\n\t * @dev Removes a value from a set. O(1).\n\t *\n\t * Returns true if the value was removed from the set, that is if it was\n\t * present.\n\t */\n\tfunction remove(UintSet storage set, uint256 value) internal returns (bool) {\n\t\treturn _remove(set._inner, bytes32(value));\n\t}\n\n\t/**\n\t * @dev Returns true if the value is in the set. O(1).\n\t */\n\tfunction contains(UintSet storage set, uint256 value) internal view returns (bool) {\n\t\treturn _contains(set._inner, bytes32(value));\n\t}\n\n\t/**\n\t * @dev Returns the number of values on the set. O(1).\n\t */\n\tfunction length(UintSet storage set) internal view returns (uint256) {\n\t\treturn _length(set._inner);\n\t}\n\n\t/**\n\t * @dev Returns the value stored at position `index` in the set. O(1).\n\t *\n\t * Note that there are no guarantees on the ordering of values inside the\n\t * array, and it may change when more values are added or removed.\n\t *\n\t * Requirements:\n\t *\n\t * - `index` must be strictly less than {length}.\n\t */\n\tfunction at(UintSet storage set, uint256 index) internal view returns (uint256) {\n\t\treturn uint256(_at(set._inner, index));\n\t}\n}\n\nlibrary Address {\n\t/**\n\t * @dev Returns true if `account` is a contract.\n\t *\n\t * [IMPORTANT]\n\t * ====\n\t * It is unsafe to assume that an address for which this function returns\n\t * false is an externally-owned account (EOA) and not a contract.\n\t *\n\t * Among others, `isContract` will return false for the following\n\t * types of addresses:\n\t *\n\t *  - an externally-owned account\n\t *  - a contract in construction\n\t *  - an address where a contract will be created\n\t *  - an address where a contract lived, but was destroyed\n\t * ====\n\t */\n\tfunction isContract(address account) internal view returns (bool) {\n\t\t// This method relies on extcodesize, which returns 0 for contracts in\n\t\t// construction, since the code is only stored at the end of the\n\t\t// constructor execution.\n\n\t\tuint256 size;\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly { size := extcodesize(account) }\n\t\treturn size \u003e 0;\n\t}\n\n\t/**\n\t * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n\t * `recipient`, forwarding all available gas and reverting on errors.\n\t *\n\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\n\t * imposed by `transfer`, making them unable to receive funds via\n\t * `transfer`. {sendValue} removes this limitation.\n\t *\n\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n\t *\n\t * IMPORTANT: because control is transferred to `recipient`, care must be\n\t * taken to not create reentrancy vulnerabilities. Consider using\n\t * {ReentrancyGuard} or the\n\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n\t */\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\n\t\trequire(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n\t\t// solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n\t\t(bool success, ) = recipient.call{ value: amount }(\"\");\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\n\t}\n\n\t/**\n\t * @dev Performs a Solidity function call using a low level `call`. A\n\t * plain`call` is an unsafe replacement for a function call: use this\n\t * function instead.\n\t *\n\t * If `target` reverts with a revert reason, it is bubbled up by this\n\t * function (like regular Solidity function calls).\n\t *\n\t * Returns the raw returned data. To convert to the expected return value,\n\t * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n\t *\n\t * Requirements:\n\t *\n\t * - `target` must be a contract.\n\t * - calling `target` with `data` must not revert.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n\t * `errorMessage` as a fallback revert reason when `target` reverts.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\t * but also transferring `value` wei to `target`.\n\t *\n\t * Requirements:\n\t *\n\t * - the calling contract must have an ETH balance of at least `value`.\n\t * - the called Solidity function must be `payable`.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n\t * with `errorMessage` as a fallback revert reason when `target` reverts.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n\t\trequire(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n\t\trequire(isContract(target), \"Address: call to non-contract\");\n\n\t\t// solhint-disable-next-line avoid-low-level-calls\n\t\t(bool success, bytes memory returndata) = target.call{ value: value }(data);\n\t\treturn _verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\t * but performing a static call.\n\t *\n\t * _Available since v3.3._\n\t */\n\tfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n\t\treturn functionStaticCall(target, data, \"Address: low-level static call failed\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n\t * but performing a static call.\n\t *\n\t * _Available since v3.3._\n\t */\n\tfunction functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n\t\trequire(isContract(target), \"Address: static call to non-contract\");\n\n\t\t// solhint-disable-next-line avoid-low-level-calls\n\t\t(bool success, bytes memory returndata) = target.staticcall(data);\n\t\treturn _verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\t * but performing a delegate call.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n\t * but performing a delegate call.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n\t\trequire(isContract(target), \"Address: delegate call to non-contract\");\n\n\t\t// solhint-disable-next-line avoid-low-level-calls\n\t\t(bool success, bytes memory returndata) = target.delegatecall(data);\n\t\treturn _verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\tfunction _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n\t\tif (success) {\n\t\t\treturn returndata;\n\t\t} else {\n\t\t\t// Look for revert reason and bubble it up if present\n\t\t\tif (returndata.length \u003e 0) {\n\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\n\n\t\t\t\t// solhint-disable-next-line no-inline-assembly\n\t\t\t\tassembly {\n\t\t\t\t\tlet returndata_size := mload(returndata)\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trevert(errorMessage);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, with an overflow flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tuint256 c = a + b;\n\t\tif (c \u003c a) return (false, 0);\n\t\treturn (true, c);\n\t}\n\n\t/**\n\t * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tif (b \u003e a) return (false, 0);\n\t\treturn (true, a - b);\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\t// Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n\t\t// benefit is lost if \u0027b\u0027 is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\tif (a == 0) return (true, 0);\n\t\tuint256 c = a * b;\n\t\tif (c / a != b) return (false, 0);\n\t\treturn (true, c);\n\t}\n\n\t/**\n\t * @dev Returns the division of two unsigned integers, with a division by zero flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tif (b == 0) return (false, 0);\n\t\treturn (true, a / b);\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tif (b == 0) return (false, 0);\n\t\treturn (true, a % b);\n\t}\n\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity\u0027s `+` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c \u003e= a, \"SafeMath: addition overflow\");\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity\u0027s `-` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b \u003c= a, \"SafeMath: subtraction overflow\");\n\t\treturn a - b;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity\u0027s `*` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tif (a == 0) return 0;\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers, reverting on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b \u003e 0, \"SafeMath: division by zero\");\n\t\treturn a / b;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * reverting when dividing by zero.\n\t *\n\t * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b \u003e 0, \"SafeMath: modulo by zero\");\n\t\treturn a % b;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\n\t * message unnecessarily. For custom revert reasons use {trySub}.\n\t *\n\t * Counterpart to Solidity\u0027s `-` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b \u003c= a, errorMessage);\n\t\treturn a - b;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\n\t * message unnecessarily. For custom revert reasons use {tryDiv}.\n\t *\n\t * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b \u003e 0, errorMessage);\n\t\treturn a / b;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * reverting with custom message when dividing by zero.\n\t *\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\n\t * message unnecessarily. For custom revert reasons use {tryMod}.\n\t *\n\t * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b \u003e 0, errorMessage);\n\t\treturn a % b;\n\t}\n}\n\ninterface IERC165 {\n\t/**\n\t * @dev Returns true if this contract implements the interface defined by\n\t * `interfaceId`. See the corresponding\n\t * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n\t * to learn more about how these ids are created.\n\t *\n\t * This function call must use less than 30 000 gas.\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\nabstract contract ERC165 is IERC165 {\n\t/*\n\t * bytes4(keccak256(\u0027supportsInterface(bytes4)\u0027)) == 0x01ffc9a7\n\t */\n\tbytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n\t/**\n\t * @dev Mapping of interface ids to whether or not it\u0027s supported.\n\t */\n\tmapping(bytes4 =\u003e bool) private _supportedInterfaces;\n\n\tconstructor () internal {\n\t\t// Derived contracts need only register support for their own interfaces,\n\t\t// we register support for ERC165 itself here\n\t\t_registerInterface(_INTERFACE_ID_ERC165);\n\t}\n\n\t/**\n\t * @dev See {IERC165-supportsInterface}.\n\t *\n\t * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n\t\treturn _supportedInterfaces[interfaceId];\n\t}\n\n\t/**\n\t * @dev Registers the contract as an implementer of the interface defined by\n\t * `interfaceId`. Support of the actual ERC165 interface is automatic and\n\t * registering its interface id is not required.\n\t *\n\t * See {IERC165-supportsInterface}.\n\t *\n\t * Requirements:\n\t *\n\t * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n\t */\n\tfunction _registerInterface(bytes4 interfaceId) internal virtual {\n\t\trequire(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n\t\t_supportedInterfaces[interfaceId] = true;\n\t}\n}\n\ninterface IERC721 is IERC165 {\n\t/**\n\t * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n\t/**\n\t * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n\t */\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n\t/**\n\t * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n\t */\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n\t/**\n\t * @dev Returns the number of tokens in ``owner``\u0027s account.\n\t */\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\n\n\t/**\n\t * @dev Returns the owner of the `tokenId` token.\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must exist.\n\t */\n\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\n\n\t/**\n\t * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n\t * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n\t *\n\t * Requirements:\n\t *\n\t * - `from` cannot be the zero address.\n\t * - `to` cannot be the zero address.\n\t * - `tokenId` token must exist and be owned by `from`.\n\t * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n\t/**\n\t * @dev Transfers `tokenId` token from `from` to `to`.\n\t *\n\t * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n\t *\n\t * Requirements:\n\t *\n\t * - `from` cannot be the zero address.\n\t * - `to` cannot be the zero address.\n\t * - `tokenId` token must be owned by `from`.\n\t * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transferFrom(address from, address to, uint256 tokenId) external;\n\n\t/**\n\t * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n\t * The approval is cleared when the token is transferred.\n\t *\n\t * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n\t *\n\t * Requirements:\n\t *\n\t * - The caller must own the token or be an approved operator.\n\t * - `tokenId` must exist.\n\t *\n\t * Emits an {Approval} event.\n\t */\n\tfunction approve(address to, uint256 tokenId) external;\n\n\t/**\n\t * @dev Returns the account approved for `tokenId` token.\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must exist.\n\t */\n\tfunction getApproved(uint256 tokenId) external view returns (address operator);\n\n\t/**\n\t * @dev Approve or remove `operator` as an operator for the caller.\n\t * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n\t *\n\t * Requirements:\n\t *\n\t * - The `operator` cannot be the caller.\n\t *\n\t * Emits an {ApprovalForAll} event.\n\t */\n\tfunction setApprovalForAll(address operator, bool _approved) external;\n\n\t/**\n\t * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n\t *\n\t * See {setApprovalForAll}\n\t */\n\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\n\n\t/**\n\t  * @dev Safely transfers `tokenId` token from `from` to `to`.\n\t  *\n\t  * Requirements:\n\t  *\n\t  * - `from` cannot be the zero address.\n\t  * - `to` cannot be the zero address.\n\t  * - `tokenId` token must exist and be owned by `from`.\n\t  * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n\t  * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n\t  *\n\t  * Emits a {Transfer} event.\n\t  */\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\ninterface IERC721Enumerable is IERC721 {\n\n\t/**\n\t * @dev Returns the total amount of tokens stored by the contract.\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n\t * Use along with {balanceOf} to enumerate all of ``owner``\u0027s tokens.\n\t */\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n\t/**\n\t * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n\t * Use along with {totalSupply} to enumerate all tokens.\n\t */\n\tfunction tokenByIndex(uint256 index) external view returns (uint256);\n}\n\ninterface IERC721Metadata is IERC721 {\n\n\t/**\n\t * @dev Returns the token collection name.\n\t */\n\tfunction name() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the token collection symbol.\n\t */\n\tfunction symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n\t */\n\tfunction tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n\tusing SafeMath for uint256;\n\tusing Address for address;\n\tusing EnumerableSet for EnumerableSet.UintSet;\n\tusing EnumerableMap for EnumerableMap.UintToAddressMap;\n\tusing Strings for uint256;\n\n\t// Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n\t// which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n\tbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n\t// Mapping from holder address to their (enumerable) set of owned tokens\n\tmapping (address =\u003e EnumerableSet.UintSet) private _holderTokens;\n\n\t// Enumerable mapping from token ids to their owners\n\tEnumerableMap.UintToAddressMap private _tokenOwners;\n\n\t// Mapping from token ID to approved address\n\tmapping (uint256 =\u003e address) private _tokenApprovals;\n\n\t// Mapping from owner to operator approvals\n\tmapping (address =\u003e mapping (address =\u003e bool)) private _operatorApprovals;\n\n\t// Token name\n\tstring private _name;\n\n\t// Token symbol\n\tstring private _symbol;\n\n\t// Optional mapping for token URIs\n\tmapping (uint256 =\u003e string) private _tokenURIs;\n\n\t// Base URI\n\tstring private _baseURI;\n\n\t/*\n\t *     bytes4(keccak256(\u0027balanceOf(address)\u0027)) == 0x70a08231\n\t *     bytes4(keccak256(\u0027ownerOf(uint256)\u0027)) == 0x6352211e\n\t *     bytes4(keccak256(\u0027approve(address,uint256)\u0027)) == 0x095ea7b3\n\t *     bytes4(keccak256(\u0027getApproved(uint256)\u0027)) == 0x081812fc\n\t *     bytes4(keccak256(\u0027setApprovalForAll(address,bool)\u0027)) == 0xa22cb465\n\t *     bytes4(keccak256(\u0027isApprovedForAll(address,address)\u0027)) == 0xe985e9c5\n\t *     bytes4(keccak256(\u0027transferFrom(address,address,uint256)\u0027)) == 0x23b872dd\n\t *     bytes4(keccak256(\u0027safeTransferFrom(address,address,uint256)\u0027)) == 0x42842e0e\n\t *     bytes4(keccak256(\u0027safeTransferFrom(address,address,uint256,bytes)\u0027)) == 0xb88d4fde\n\t *\n\t *     =\u003e 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n\t *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n\t */\n\tbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n\t/*\n\t *     bytes4(keccak256(\u0027name()\u0027)) == 0x06fdde03\n\t *     bytes4(keccak256(\u0027symbol()\u0027)) == 0x95d89b41\n\t *     bytes4(keccak256(\u0027tokenURI(uint256)\u0027)) == 0xc87b56dd\n\t *\n\t *     =\u003e 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n\t */\n\tbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n\t/*\n\t *     bytes4(keccak256(\u0027totalSupply()\u0027)) == 0x18160ddd\n\t *     bytes4(keccak256(\u0027tokenOfOwnerByIndex(address,uint256)\u0027)) == 0x2f745c59\n\t *     bytes4(keccak256(\u0027tokenByIndex(uint256)\u0027)) == 0x4f6ccce7\n\t *\n\t *     =\u003e 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n\t */\n\tbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n\t/**\n\t * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n\t */\n\tconstructor (string memory name_, string memory symbol_) public {\n\t\t_name = name_;\n\t\t_symbol = symbol_;\n\n\t\t// register the supported interfaces to conform to ERC721 via ERC165\n\t\t_registerInterface(_INTERFACE_ID_ERC721);\n\t\t_registerInterface(_INTERFACE_ID_ERC721_METADATA);\n\t\t_registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n\t}\n\n\t/**\n\t * @dev See {IERC721-balanceOf}.\n\t */\n\tfunction balanceOf(address owner) public view virtual override returns (uint256) {\n\t\trequire(owner != address(0), \"ERC721: balance query for the zero address\");\n\t\treturn _holderTokens[owner].length();\n\t}\n\n\t/**\n\t * @dev See {IERC721-ownerOf}.\n\t */\n\tfunction ownerOf(uint256 tokenId) public view virtual override returns (address) {\n\t\treturn _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n\t}\n\n\t/**\n\t * @dev See {IERC721Metadata-name}.\n\t */\n\tfunction name() public view virtual override returns (string memory) {\n\t\treturn _name;\n\t}\n\n\t/**\n\t * @dev See {IERC721Metadata-symbol}.\n\t */\n\tfunction symbol() public view virtual override returns (string memory) {\n\t\treturn _symbol;\n\t}\n\n\t/**\n\t * @dev See {IERC721Metadata-tokenURI}.\n\t */\n\tfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n\t\trequire(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n\t\tstring memory _tokenURI = _tokenURIs[tokenId];\n\t\tstring memory base = baseURI();\n\n\t\t// If there is no base URI, return the token URI.\n\t\tif (bytes(base).length == 0) {\n\t\t\treturn _tokenURI;\n\t\t}\n\t\t// If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n\t\tif (bytes(_tokenURI).length \u003e 0) {\n\t\t\treturn string(abi.encodePacked(base, _tokenURI));\n\t\t}\n\t\t// If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n\t\treturn string(abi.encodePacked(base, tokenId.toString()));\n\t}\n\n\t/**\n\t* @dev Returns the base URI set via {_setBaseURI}. This will be\n\t* automatically added as a prefix in {tokenURI} to each token\u0027s URI, or\n\t* to the token ID if no specific URI is set for that token ID.\n\t*/\n\tfunction baseURI() public view virtual returns (string memory) {\n\t\treturn _baseURI;\n\t}\n\n\t/**\n\t * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n\t */\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n\t\treturn _holderTokens[owner].at(index);\n\t}\n\n\t/**\n\t * @dev See {IERC721Enumerable-totalSupply}.\n\t */\n\tfunction totalSupply() public view virtual override returns (uint256) {\n\t\t// _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n\t\treturn _tokenOwners.length();\n\t}\n\n\t/**\n\t * @dev See {IERC721Enumerable-tokenByIndex}.\n\t */\n\tfunction tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n\t\t(uint256 tokenId, ) = _tokenOwners.at(index);\n\t\treturn tokenId;\n\t}\n\n\t/**\n\t * @dev See {IERC721-approve}.\n\t */\n\tfunction approve(address to, uint256 tokenId) public virtual override {\n\t\taddress owner = ERC721.ownerOf(tokenId);\n\t\trequire(to != owner, \"ERC721: approval to current owner\");\n\n\t\trequire(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\n\t\t\t\"ERC721: approve caller is not owner nor approved for all\"\n\t\t);\n\n\t\t_approve(to, tokenId);\n\t}\n\n\t/**\n\t * @dev See {IERC721-getApproved}.\n\t */\n\tfunction getApproved(uint256 tokenId) public view virtual override returns (address) {\n\t\trequire(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n\t\treturn _tokenApprovals[tokenId];\n\t}\n\n\t/**\n\t * @dev See {IERC721-setApprovalForAll}.\n\t */\n\tfunction setApprovalForAll(address operator, bool approved) public virtual override {\n\t\trequire(operator != _msgSender(), \"ERC721: approve to caller\");\n\n\t\t_operatorApprovals[_msgSender()][operator] = approved;\n\t\temit ApprovalForAll(_msgSender(), operator, approved);\n\t}\n\n\t/**\n\t * @dev See {IERC721-isApprovedForAll}.\n\t */\n\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n\t\treturn _operatorApprovals[owner][operator];\n\t}\n\n\t/**\n\t * @dev See {IERC721-transferFrom}.\n\t */\n\tfunction transferFrom(address from, address to, uint256 tokenId) public virtual override {\n\t\t//solhint-disable-next-line max-line-length\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n\t\t_transfer(from, to, tokenId);\n\t}\n\n\t/**\n\t * @dev See {IERC721-safeTransferFrom}.\n\t */\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n\t\tsafeTransferFrom(from, to, tokenId, \"\");\n\t}\n\n\t/**\n\t * @dev See {IERC721-safeTransferFrom}.\n\t */\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\t\t_safeTransfer(from, to, tokenId, _data);\n\t}\n\n\t/**\n\t * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n\t * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n\t *\n\t * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n\t *\n\t * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n\t * implement alternative mechanisms to perform token transfer, such as signature-based.\n\t *\n\t * Requirements:\n\t *\n\t * - `from` cannot be the zero address.\n\t * - `to` cannot be the zero address.\n\t * - `tokenId` token must exist and be owned by `from`.\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n\t\t_transfer(from, to, tokenId);\n\t\trequire(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n\t}\n\n\t/**\n\t * @dev Returns whether `tokenId` exists.\n\t *\n\t * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n\t *\n\t * Tokens start existing when they are minted (`_mint`),\n\t * and stop existing when they are burned (`_burn`).\n\t */\n\tfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\n\t\treturn _tokenOwners.contains(tokenId);\n\t}\n\n\t/**\n\t * @dev Returns whether `spender` is allowed to manage `tokenId`.\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must exist.\n\t */\n\tfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n\t\trequire(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n\t\taddress owner = ERC721.ownerOf(tokenId);\n\t\treturn (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\n\t}\n\n\t/**\n\t * @dev Safely mints `tokenId` and transfers it to `to`.\n\t *\n\t * Requirements:\n\t d*\n\t * - `tokenId` must not exist.\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction _safeMint(address to, uint256 tokenId) internal virtual {\n\t\t_safeMint(to, tokenId, \"\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n\t * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n\t */\n\tfunction _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n\t\t_mint(to, tokenId);\n\t\trequire(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n\t}\n\n\t/**\n\t * @dev Mints `tokenId` and transfers it to `to`.\n\t *\n\t * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must not exist.\n\t * - `to` cannot be the zero address.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction _mint(address to, uint256 tokenId) internal virtual {\n\t\trequire(to != address(0), \"ERC721: mint to the zero address\");\n\t\trequire(!_exists(tokenId), \"ERC721: token already minted\");\n\n\t\t_beforeTokenTransfer(address(0), to, tokenId);\n\n\t\t_holderTokens[to].add(tokenId);\n\n\t\t_tokenOwners.set(tokenId, to);\n\n\t\temit Transfer(address(0), to, tokenId);\n\t}\n\n\t/**\n\t * @dev Destroys `tokenId`.\n\t * The approval is cleared when the token is burned.\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must exist.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction _burn(uint256 tokenId) internal virtual {\n\t\taddress owner = ERC721.ownerOf(tokenId); // internal owner\n\n\t\t_beforeTokenTransfer(owner, address(0), tokenId);\n\n\t\t// Clear approvals\n\t\t_approve(address(0), tokenId);\n\n\t\t// Clear metadata (if any)\n\t\tif (bytes(_tokenURIs[tokenId]).length != 0) {\n\t\t\tdelete _tokenURIs[tokenId];\n\t\t}\n\n\t\t_holderTokens[owner].remove(tokenId);\n\n\t\t_tokenOwners.remove(tokenId);\n\n\t\temit Transfer(owner, address(0), tokenId);\n\t}\n\n\t/**\n\t * @dev Transfers `tokenId` from `from` to `to`.\n\t *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n\t *\n\t * Requirements:\n\t *\n\t * - `to` cannot be the zero address.\n\t * - `tokenId` token must be owned by `from`.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction _transfer(address from, address to, uint256 tokenId) internal virtual {\n\t\trequire(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\"); // internal owner\n\t\trequire(to != address(0), \"ERC721: transfer to the zero address\");\n\n\t\t_beforeTokenTransfer(from, to, tokenId);\n\n\t\t// Clear approvals from the previous owner\n\t\t_approve(address(0), tokenId);\n\n\t\t_holderTokens[from].remove(tokenId);\n\t\t_holderTokens[to].add(tokenId);\n\n\t\t_tokenOwners.set(tokenId, to);\n\n\t\temit Transfer(from, to, tokenId);\n\t}\n\n\t/**\n\t * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must exist.\n\t */\n\tfunction _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n\t\trequire(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n\t\t_tokenURIs[tokenId] = _tokenURI;\n\t}\n\n\t/**\n\t * @dev Internal function to set the base URI for all token IDs. It is\n\t * automatically added as a prefix to the value returned in {tokenURI},\n\t * or to the token ID if {tokenURI} is empty.\n\t */\n\tfunction _setBaseURI(string memory baseURI_) internal virtual {\n\t\t_baseURI = baseURI_;\n\t}\n\n\t/**\n\t * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n\t * The call is not executed if the target address is not a contract.\n\t *\n\t * @param from address representing the previous owner of the given token ID\n\t * @param to target address that will receive the tokens\n\t * @param tokenId uint256 ID of the token to be transferred\n\t * @param _data bytes optional data to send along with the call\n\t * @return bool whether the call correctly returned the expected magic value\n\t */\n\tfunction _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n\tprivate returns (bool)\n\t{\n\t\tif (!to.isContract()) {\n\t\t\treturn true;\n\t\t}\n\t\tbytes memory returndata = to.functionCall(abi.encodeWithSelector(\n\t\t\t\tIERC721Receiver(to).onERC721Received.selector,\n\t\t\t\t_msgSender(),\n\t\t\t\tfrom,\n\t\t\t\ttokenId,\n\t\t\t\t_data\n\t\t\t), \"ERC721: transfer to non ERC721Receiver implementer\");\n\t\tbytes4 retval = abi.decode(returndata, (bytes4));\n\t\treturn (retval == _ERC721_RECEIVED);\n\t}\n\n\t/**\n\t * @dev Approve `to` to operate on `tokenId`\n\t *\n\t * Emits an {Approval} event.\n\t */\n\tfunction _approve(address to, uint256 tokenId) internal virtual {\n\t\t_tokenApprovals[tokenId] = to;\n\t\temit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\n\t}\n\n\t/**\n\t * @dev Hook that is called before any token transfer. This includes minting\n\t * and burning.\n\t *\n\t * Calling conditions:\n\t *\n\t * - When `from` and `to` are both non-zero, ``from``\u0027s `tokenId` will be\n\t * transferred to `to`.\n\t * - When `from` is zero, `tokenId` will be minted for `to`.\n\t * - When `to` is zero, ``from``\u0027s `tokenId` will be burned.\n\t * - `from` cannot be the zero address.\n\t * - `to` cannot be the zero address.\n\t *\n\t * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n\t */\n\tfunction _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}"},"NFT.sol":{"content":"pragma solidity \u003e=0.6.0 \u003c0.8.0;\npragma experimental ABIEncoderV2;\n\n//SPDX-License-Identifier: UNLICENSED\n\nimport \"./ERC721.sol\";\n\ncontract Mounts is ERC721, ReentrancyGuard, Ownable {\n\tusing SafeMath for uint256;\n\n\tconstructor() ERC721(\"Mounts (for Adventurers)\", \"MOUNT\") {}\n\taddress public lootAddress = 0xFF9C1b15B16263C61d017ee9F65C50e4AE0113D7;\n\tLootInterface lootContract = LootInterface(lootAddress);\n\n\tstring public PROVENANCE = \"\";\n\n\tuint256 public maxSupply = 8000;\n\tuint256 public currentSupply = 0;\n\n\tuint256 public lootersPrice = 10000000000000000; // 0.01 ETH\n\tuint256 public publicPrice = 20000000000000000; // 0.02 ETH\n\n\tstring[] private creature = [\n\t\t\"Horse\", \"Horse\", \"Horse\",\n\t\t\"Dragon\",\n\t\t\"Gryffin\", \"Gryffin\",\n\t\t\"Camel\", \"Camel\", \"Camel\",\n\t\t\"Poney\", \"Poney\", \"Poney\",\n\t\t\"Elephant\", \"Elephant\",\n\t\t\"Hound\", \"Hound\", \"Hound\",\n\t\t\"Shark\", \"Shark\",\n\t\t\"Hippogryff\", \"Hippogryff\",\n\t\t\"Bull\", \"Bull\", \"Bull\",\n\t\t\"Bear\", \"Bear\", \"Bear\",\n\t\t\"Ostrich\", \"Ostrich\",\n\t\t\"Donkey\", \"Donkey\"\n\t];\n\tstring[] private creaturePrefix = [\"Black\", \"White\", \"Blue\", \"Red\", \"Green\", \"Silver\", \"Golden\", \"Courageous\", \"Divine\", \"Holy\", \"Demonic\", \"Young\", \"Ancient\", \"Docile\", \"Proud\", \"Bold\", \"Quirky\", \"Brave\", \"Rash\", \"Impish\", \"Quiet\", \"Lonely\", \"Ice\", \"Fire\"];\n\n\tstring[] private saddle = [\"saddle\"];\n\tstring[] private saddlePrefix = [\"General purpose\", \"Dressage\", \"Jumping\", \"Hunting\", \"Racing\", \"Double\", \"Endurance\", \"Roping\", \"Leather\"];\n\n\tstring[] private equipment = [\"Helmet\", \"Armor\", \"Collar\", \"Harness\"];\n\tstring[] private equipmentPrefix = [\"Ancient\", \"Golden\", \"Heavy\", \"Light\", \"Dragonskin\", \"Chain\", \"Ornate\", \"Spiky\", \"Holy\", \"Silver\", \"Great\", \"Bronze\", \"Iron\", \"Platinum\", \"Unholy\"];\n\n\tstring[] private inventory = [\"pouch\", \"bag\", \"satchel\", \"purse\", \"saddlebag\", \"basket\", \"seat bag\", \"wedge pack\"];\n\tstring[] private inventoryPrefix = [\"Large\", \"Small\", \"Medium\", \"Bountiful\", \"Empty\"];\n\n\tfunction getCreature(uint256 tokenId) public view returns (string memory) {\n\t\treturn pluck(tokenId, \"Creature\", creature, creaturePrefix);\n\t}\n\n\tfunction getSaddle(uint256 tokenId) public view returns (string memory) {\n\t\treturn pluck(tokenId, \"Saddle\", saddle, saddlePrefix);\n\t}\n\n\tfunction getEquipment(uint256 tokenId) public view returns (string memory) {\n\t\treturn pluck(tokenId, \"Equipment\", equipment, equipmentPrefix);\n\t}\n\n\tfunction getInventory(uint256 tokenId) public view returns (string memory) {\n\t\treturn pluck(tokenId, \"Inventory\", inventory, inventoryPrefix);\n\t}\n\n\tfunction getFullDescription(uint256 tokenId) public view returns (string memory) {\n\t\treturn string(abi.encodePacked(\n\t\t\tgetCreature(tokenId), \" + \",\n\t\t\tgetSaddle(tokenId), \" + \",\n\t\t\tgetEquipment(tokenId), \" + \",\n\t\t\tgetInventory(tokenId)\n\t\t));\n\t}\n\n\tfunction random(string memory input) public pure returns (uint256) {\n\t\treturn uint256(keccak256(abi.encodePacked(input))) % 31;\n\t}\n\n\tfunction pluckRoll(uint256 tokenId, string memory keyPrefix) internal pure returns (string memory) {\n\t\tuint256 roll1 = random(string(abi.encodePacked(keyPrefix, toString(tokenId), \"1\")));\n\t\tuint256 min = roll1;\n\t\tuint256 roll2 = random(string(abi.encodePacked(keyPrefix, toString(tokenId), \"2\")));\n\t\tmin = min \u003e roll2 ? roll2 : min;\n\t\tuint256 roll3 = random(string(abi.encodePacked(keyPrefix, toString(tokenId), \"3\")));\n\t\tmin = min \u003e roll3 ? roll3 : min;\n\t\tuint256 roll4 = random(string(abi.encodePacked(keyPrefix, toString(tokenId), \"4\")));\n\t\tmin = min \u003e roll4 ? roll4 : min;\n\n\t\t// get 3 highest dice rolls\n\t\tuint256 stat = roll1 * roll2 * roll3 + roll4 + roll3 - min;\n\n\t\tstring memory output = string(abi.encodePacked(toString(stat)));\n\n\t\treturn output;\n\t}\n\n\tfunction pluck(\n\t\tuint256 tokenId,\n\t\tstring memory keyPrefix,\n\t\tstring[] memory sourceArray,\n\t\tstring[] memory prefixes\n\t) internal view returns (string memory) {\n\t\tuint256 randA = random(\n\t\t\tstring(abi.encodePacked(keyPrefix, toString(tokenId*7)))\n\t\t);\n\t\tuint256 randB = random(\n\t\t\tstring(abi.encodePacked(keyPrefix, toString(tokenId*4)))\n\t\t);\n\n\t\tstring memory output = sourceArray[randA % sourceArray.length];\n\t\toutput = string(\n\t\t\tabi.encodePacked(prefixes[randB % prefixes.length], \" \", output)\n\t\t);\n\n\t\tstring memory actual = string(abi.encodePacked(output));\n\t\treturn actual;\n\t}\n\n\tfunction withdraw() public onlyOwner {\n\t\tuint balance = address(this).balance;\n\t\tmsg.sender.transfer(balance);\n\t}\n\n\tfunction deposit() public payable onlyOwner {}\n\n\n\tfunction setLootersPrice(uint256 newPrice) public onlyOwner {\n\t\tlootersPrice = newPrice;\n\t}\n\n\tfunction setPublicPrice(uint256 newPrice) public onlyOwner {\n\t\tpublicPrice = newPrice;\n\t}\n\n\tfunction setBaseURI(string memory baseURI) public onlyOwner {\n\t\t_setBaseURI(baseURI);\n\t}\n\n\tfunction setProvenance(string memory prov) public onlyOwner {\n\t\tPROVENANCE = prov;\n\t}\n\n\t// Loot owners minting\n\tfunction mintWithLoot(uint lootId) public payable nonReentrant {\n\t\trequire(lootContract.ownerOf(lootId) == msg.sender, \"This Loot is not owned by the minter\");\n\t\trequire(lootersPrice \u003c= msg.value, \"Not enough Ether sent\");\n\t\trequire(currentSupply \u003c maxSupply, \"All mounts are minted\");\n\t\t_safeMint(msg.sender, currentSupply);\n\t\tcurrentSupply += 1;\n\t}\n\n\t// Public minting\n\tfunction mint() public payable nonReentrant {\n\t\trequire(publicPrice \u003c= msg.value, \"Not enough Ether sent\");\n\t\trequire(currentSupply \u003c maxSupply, \"All mounts are minted\");\n\n\t\t_safeMint(msg.sender, currentSupply);\n\t\tcurrentSupply += 1;\n\t}\n\n\tfunction toString(uint256 value) internal pure returns (string memory) {\n\t\tif (value == 0) {\n\t\t\treturn \"0\";\n\t\t}\n\t\tuint256 temp = value;\n\t\tuint256 digits;\n\t\twhile (temp != 0) {\n\t\t\tdigits++;\n\t\t\ttemp /= 10;\n\t\t}\n\t\tbytes memory buffer = new bytes(digits);\n\t\twhile (value != 0) {\n\t\t\tdigits -= 1;\n\t\t\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n\t\t\tvalue /= 10;\n\t\t}\n\t\treturn string(buffer);\n\t}\n\n\tfunction tokenURI(uint256 tokenId) override public view returns (string memory) {\n\t\tstring[9] memory parts;\n\t\tparts[0] = \u0027\u003csvg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 350 350\"\u003e\u003cstyle\u003e.base { fill: white; font-family: serif; font-size: 14px; }\u003c/style\u003e\u003crect width=\"100%\" height=\"100%\" fill=\"black\" /\u003e\u003ctext x=\"10\" y=\"20\" class=\"base\"\u003e\u0027;\n\n\t\tparts[1] = getCreature(tokenId);\n\n\t\tparts[2] = \u0027\u003c/text\u003e\u003ctext x=\"10\" y=\"40\" class=\"base\"\u003e\u0027;\n\n\t\tparts[3] = getSaddle(tokenId);\n\n\t\tparts[4] = \u0027\u003c/text\u003e\u003ctext x=\"10\" y=\"60\" class=\"base\"\u003e\u0027;\n\n\t\tparts[5] = getEquipment(tokenId);\n\n\t\tparts[6] = \u0027\u003c/text\u003e\u003ctext x=\"10\" y=\"80\" class=\"base\"\u003e\u0027;\n\n\t\tparts[7] = getInventory(tokenId);\n\n\t\tparts[8] = \u0027\u003c/text\u003e\u003c/svg\u003e\u0027;\n\n\t\tstring memory output = string(abi.encodePacked(parts[0], parts[1], parts[2], parts[3], parts[4], parts[5], parts[6], parts[7], parts[8]));\n\t\t//output = string(abi.encodePacked(output, parts[9], parts[10], parts[11], parts[12], parts[13], parts[14], parts[15], parts[16]));\n\n\t\tstring memory json = Base64.encode(bytes(string(abi.encodePacked(\u0027{\"name\": \"Mount #\u0027, toString(tokenId), \u0027\", \"description\": \"Welcome, weary traveler ! Which mounts will you pick to help you wander from realms to realms ?\", \"image\": \"data:image/svg+xml;base64,\u0027, Base64.encode(bytes(output)), \u0027\"}\u0027))));\n\t\toutput = string(abi.encodePacked(\u0027data:application/json;base64,\u0027, json));\n\n\t\treturn output;\n\t}\n}"}}