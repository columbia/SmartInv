1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "istanbul",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "enabled": true,
12       "runs": 2000
13     },
14     "remappings": [],
15     "outputSelection": {
16       "*": {
17         "*": [
18           "evm.bytecode",
19           "evm.deployedBytecode",
20           "abi"
21         ]
22       }
23     }
24   },
25   "sources": {
26     "src/solc_0.6/BaseWithStorage/ERC20Group.sol": {
27       "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"./ERC20SubToken.sol\";\nimport \"../common/Libraries/SafeMath.sol\";\nimport \"../common/Libraries/AddressUtils.sol\";\nimport \"../common/Libraries/ObjectLib32.sol\";\nimport \"../common/Libraries/BytesUtil.sol\";\n\nimport \"../common/BaseWithStorage/SuperOperators.sol\";\nimport \"../common/BaseWithStorage/MetaTransactionReceiver.sol\";\n\n\ncontract ERC20Group is SuperOperators, MetaTransactionReceiver {\n    uint256 internal constant MAX_UINT256 = ~uint256(0);\n\n    /// @notice emitted when a new Token is added to the group.\n    /// @param subToken the token added, its id will be its index in the array.\n    event SubToken(ERC20SubToken subToken);\n\n    /// @notice emitted when `owner` is allowing or disallowing `operator` to transfer tokens on its behalf.\n    /// @param owner the address approving.\n    /// @param operator the address being granted (or revoked) permission to transfer.\n    /// @param approved whether the operator is granted transfer right or not.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event Minter(address minter, bool enabled);\n\n    /// @notice Enable or disable the ability of `minter` to mint tokens\n    /// @param minter address that will be given/removed minter right.\n    /// @param enabled set whether the minter is enabled or disabled.\n    function setMinter(address minter, bool enabled) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        _setMinter(minter, enabled);\n    }\n\n    /// @notice check whether address `who` is given minter rights.\n    /// @param who The address to query.\n    /// @return whether the address has minter rights.\n    function isMinter(address who) public view returns (bool) {\n        return _minters[who];\n    }\n\n    /// @dev mint more tokens of a specific subToken .\n    /// @param to address receiving the tokens.\n    /// @param id subToken id (also the index at which it was added).\n    /// @param amount of token minted.\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount\n    ) external {\n        require(_minters[msg.sender], \"NOT_AUTHORIZED_MINTER\");\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\n        toPack[bin] = toPack[bin].updateTokenBalance(index, amount, ObjectLib32.Operations.ADD);\n        _packedSupplies[bin] = _packedSupplies[bin].updateTokenBalance(index, amount, ObjectLib32.Operations.ADD);\n        _erc20s[id].emitTransferEvent(address(0), to, amount);\n    }\n\n    /// @dev mint more tokens of a several subToken .\n    /// @param to address receiving the tokens.\n    /// @param ids subToken ids (also the index at which it was added).\n    /// @param amounts for each token minted.\n    function batchMint(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        require(_minters[msg.sender], \"NOT_AUTHORIZED_MINTER\");\n        require(ids.length == amounts.length, \"INVALID_INCONSISTENT_LENGTH\");\n        _batchMint(to, ids, amounts);\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        uint256 lastBin = MAX_UINT256;\n        uint256 bal = 0;\n        uint256 supply = 0;\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\n        for (uint256 i = 0; i < ids.length; i++) {\n            if (amounts[i] != 0) {\n                (uint256 bin, uint256 index) = ids[i].getTokenBinIndex();\n                if (lastBin == MAX_UINT256) {\n                    lastBin = bin;\n                    bal = toPack[bin].updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\n                    supply = _packedSupplies[bin].updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\n                } else {\n                    if (bin != lastBin) {\n                        toPack[lastBin] = bal;\n                        bal = toPack[bin];\n                        _packedSupplies[lastBin] = supply;\n                        supply = _packedSupplies[bin];\n                        lastBin = bin;\n                    }\n                    bal = bal.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\n                    supply = supply.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\n                }\n                _erc20s[ids[i]].emitTransferEvent(address(0), to, amounts[i]);\n            }\n        }\n        if (lastBin != MAX_UINT256) {\n            toPack[lastBin] = bal;\n            _packedSupplies[lastBin] = supply;\n        }\n    }\n\n    /// @notice return the current total supply of a specific subToken.\n    /// @param id subToken id.\n    /// @return supply current total number of tokens.\n    function supplyOf(uint256 id) external view returns (uint256 supply) {\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        return _packedSupplies[bin].getValueInBin(index);\n    }\n\n    /// @notice return the balance of a particular owner for a particular subToken.\n    /// @param owner whose balance it is of.\n    /// @param id subToken id.\n    /// @return balance of the owner\n    function balanceOf(address owner, uint256 id) public view returns (uint256 balance) {\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        return _packedTokenBalance[owner][bin].getValueInBin(index);\n    }\n\n    /// @notice return the balances of a list of owners / subTokens.\n    /// @param owners list of addresses to which we want to know the balance.\n    /// @param ids list of subTokens's addresses.\n    /// @return balances list of balances for each request.\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external view returns (uint256[] memory balances) {\n        require(owners.length == ids.length, \"INVALID_INCONSISTENT_LENGTH\");\n        balances = new uint256[](ids.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            balances[i] = balanceOf(owners[i], ids[i]);\n        }\n    }\n\n    /// @notice transfer a number of subToken from one address to another.\n    /// @param from owner to transfer from.\n    /// @param to destination address that will receive the tokens.\n    /// @param id subToken id.\n    /// @param value amount of tokens to transfer.\n    function singleTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value\n    ) external {\n        require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        ERC20SubToken erc20 = _erc20s[id];\n        require(\n            from == msg.sender ||\n                msg.sender == address(erc20) ||\n                _metaTransactionContracts[msg.sender] ||\n                _superOperators[msg.sender] ||\n                _operatorsForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\n        fromPack[bin] = fromPack[bin].updateTokenBalance(index, value, ObjectLib32.Operations.SUB);\n        toPack[bin] = toPack[bin].updateTokenBalance(index, value, ObjectLib32.Operations.ADD);\n        erc20.emitTransferEvent(from, to, value);\n    }\n\n    /// @notice transfer a number of different subTokens from one address to another.\n    /// @param from owner to transfer from.\n    /// @param to destination address that will receive the tokens.\n    /// @param ids list of subToken ids to transfer.\n    /// @param values list of amount for eacg subTokens to transfer.\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) external {\n        require(ids.length == values.length, \"INVALID_INCONSISTENT_LENGTH\");\n        require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        require(\n            from == msg.sender || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender] || _metaTransactionContracts[msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n        _batchTransferFrom(from, to, ids, values);\n    }\n\n    function _batchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) internal {\n        uint256 lastBin = MAX_UINT256;\n        uint256 balFrom;\n        uint256 balTo;\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\n        for (uint256 i = 0; i < ids.length; i++) {\n            if (values[i] != 0) {\n                (uint256 bin, uint256 index) = ids[i].getTokenBinIndex();\n                if (lastBin == MAX_UINT256) {\n                    lastBin = bin;\n                    balFrom = ObjectLib32.updateTokenBalance(fromPack[bin], index, values[i], ObjectLib32.Operations.SUB);\n                    balTo = ObjectLib32.updateTokenBalance(toPack[bin], index, values[i], ObjectLib32.Operations.ADD);\n                } else {\n                    if (bin != lastBin) {\n                        fromPack[lastBin] = balFrom;\n                        toPack[lastBin] = balTo;\n                        balFrom = fromPack[bin];\n                        balTo = toPack[bin];\n                        lastBin = bin;\n                    }\n                    balFrom = balFrom.updateTokenBalance(index, values[i], ObjectLib32.Operations.SUB);\n                    balTo = balTo.updateTokenBalance(index, values[i], ObjectLib32.Operations.ADD);\n                }\n                ERC20SubToken erc20 = _erc20s[ids[i]];\n                erc20.emitTransferEvent(from, to, values[i]);\n            }\n        }\n        if (lastBin != MAX_UINT256) {\n            fromPack[lastBin] = balFrom;\n            toPack[lastBin] = balTo;\n        }\n    }\n\n    /// @notice grant or revoke the ability for an address to transfer token on behalf of another address.\n    /// @param sender address granting/revoking the approval.\n    /// @param operator address being granted/revoked ability to transfer.\n    /// @param approved whether the operator is revoked or approved.\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external {\n        require(msg.sender == sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender], \"NOT_AUTHORIZED\");\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /// @notice grant or revoke the ability for an address to transfer token on your behalf.\n    /// @param operator address being granted/revoked ability to transfer.\n    /// @param approved whether the operator is revoked or approved.\n    function setApprovalForAll(address operator, bool approved) external {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @notice return whether an oeprator has the ability to transfer on behalf of another address.\n    /// @param owner address who would have granted the rights.\n    /// @param operator address being given the ability to transfer.\n    /// @return isOperator whether the operator has approval rigths or not.\n    function isApprovedForAll(address owner, address operator) external view returns (bool isOperator) {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }\n\n    function isAuthorizedToTransfer(address owner, address sender) external view returns (bool) {\n        return _metaTransactionContracts[sender] || _superOperators[sender] || _operatorsForAll[owner][sender];\n    }\n\n    function isAuthorizedToApprove(address sender) external view returns (bool) {\n        return _metaTransactionContracts[sender] || _superOperators[sender];\n    }\n\n    function batchBurnFrom(\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        require(from != address(0), \"INVALID_FROM_ZERO_ADDRESS\");\n        require(\n            from == msg.sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        _batchBurnFrom(from, ids, amounts);\n    }\n\n    /// @notice burn token for a specific owner and subToken.\n    /// @param from fron which address the token are burned from.\n    /// @param id subToken id.\n    /// @param value amount of tokens to burn.\n    function burnFrom(\n        address from,\n        uint256 id,\n        uint256 value\n    ) external {\n        require(\n            from == msg.sender || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender] || _metaTransactionContracts[msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n        _burn(from, id, value);\n    }\n\n    /// @notice burn token for a specific subToken.\n    /// @param id subToken id.\n    /// @param value amount of tokens to burn.\n    function burn(uint256 id, uint256 value) external {\n        _burn(msg.sender, id, value);\n    }\n\n    // ///////////////// INTERNAL //////////////////////////\n\n    function _batchBurnFrom(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        uint256 balFrom = 0;\n        uint256 supply = 0;\n        uint256 lastBin = MAX_UINT256;\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\n        for (uint256 i = 0; i < ids.length; i++) {\n            if (amounts[i] != 0) {\n                (uint256 bin, uint256 index) = ids[i].getTokenBinIndex();\n                if (lastBin == MAX_UINT256) {\n                    lastBin = bin;\n                    balFrom = fromPack[bin].updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\n                    supply = _packedSupplies[bin].updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\n                } else {\n                    if (bin != lastBin) {\n                        fromPack[lastBin] = balFrom;\n                        balFrom = fromPack[bin];\n                        _packedSupplies[lastBin] = supply;\n                        supply = _packedSupplies[bin];\n                        lastBin = bin;\n                    }\n\n                    balFrom = balFrom.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\n                    supply = supply.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\n                }\n                _erc20s[ids[i]].emitTransferEvent(from, address(0), amounts[i]);\n            }\n        }\n        if (lastBin != MAX_UINT256) {\n            fromPack[lastBin] = balFrom;\n            _packedSupplies[lastBin] = supply;\n        }\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 value\n    ) internal {\n        ERC20SubToken erc20 = _erc20s[id];\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\n        fromPack[bin] = ObjectLib32.updateTokenBalance(fromPack[bin], index, value, ObjectLib32.Operations.SUB);\n        _packedSupplies[bin] = ObjectLib32.updateTokenBalance(_packedSupplies[bin], index, value, ObjectLib32.Operations.SUB);\n        erc20.emitTransferEvent(from, address(0), value);\n    }\n\n    function _addSubToken(ERC20SubToken subToken) internal returns (uint256 id) {\n        id = _erc20s.length;\n        require(subToken.groupAddress() == address(this), \"INVALID_GROUP\");\n        require(subToken.groupTokenId() == id, \"INVALID_ID\");\n        _erc20s.push(subToken);\n        emit SubToken(subToken);\n    }\n\n    function _setApprovalForAll(\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        require(!_superOperators[operator], \"INVALID_SUPER_OPERATOR\");\n        _operatorsForAll[sender][operator] = approved;\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    function _setMinter(address minter, bool enabled) internal {\n        _minters[minter] = enabled;\n        emit Minter(minter, enabled);\n    }\n\n    // ///////////////// UTILITIES /////////////////////////\n    using AddressUtils for address;\n    using ObjectLib32 for ObjectLib32.Operations;\n    using ObjectLib32 for uint256;\n    using SafeMath for uint256;\n\n    // ////////////////// DATA ///////////////////////////////\n    mapping(uint256 => uint256) internal _packedSupplies;\n    mapping(address => mapping(uint256 => uint256)) internal _packedTokenBalance;\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\n    ERC20SubToken[] internal _erc20s;\n    mapping(address => bool) internal _minters;\n\n    // ////////////// CONSTRUCTOR ////////////////////////////\n\n    struct SubTokenData {\n        string name;\n        string symbol;\n    }\n\n    constructor(\n        address metaTransactionContract,\n        address admin,\n        address initialMinter\n    ) internal {\n        _admin = admin;\n        _setMetaTransactionProcessor(metaTransactionContract, true);\n        _setMinter(initialMinter, true);\n    }\n}\n"
28     },
29     "src/solc_0.6/BaseWithStorage/ERC20SubToken.sol": {
30       "content": "pragma solidity 0.6.5;\n\nimport \"../common/Libraries/SafeMathWithRequire.sol\";\nimport \"../common/BaseWithStorage/SuperOperators.sol\";\nimport \"../common/BaseWithStorage/MetaTransactionReceiver.sol\";\n\nimport \"./ERC20Group.sol\";\n\n\ncontract ERC20SubToken {\n    // TODO add natspec, currently blocked by solidity compiler issue\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // TODO add natspec, currently blocked by solidity compiler issue\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice A descriptive name for the tokens\n    /// @return name of the tokens\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /// @notice An abbreviated name for the tokens\n    /// @return symbol of the tokens\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /// @notice the tokenId in ERC20Group\n    /// @return the tokenId in ERC20Group\n    function groupTokenId() external view returns (uint256) {\n        return _index;\n    }\n\n    /// @notice the ERC20Group address\n    /// @return the address of the group\n    function groupAddress() external view returns (address) {\n        return address(_group);\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return _group.supplyOf(_index);\n    }\n\n    function balanceOf(address who) external view returns (uint256) {\n        return _group.balanceOf(who, _index);\n    }\n\n    function decimals() external pure returns (uint8) {\n        return uint8(0);\n    }\n\n    function transfer(address to, uint256 amount) external returns (bool success) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool success) {\n        if (msg.sender != from && !_group.isAuthorizedToTransfer(from, msg.sender)) {\n            uint256 allowance = _mAllowed[from][msg.sender];\n            if (allowance != ~uint256(0)) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(allowance >= amount, \"NOT_AUTHOIZED_ALLOWANCE\");\n                _mAllowed[from][msg.sender] = allowance - amount;\n            }\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool success) {\n        _approveFor(msg.sender, spender, amount);\n        return true;\n    }\n\n    function approveFor(\n        address from,\n        address spender,\n        uint256 amount\n    ) external returns (bool success) {\n        require(msg.sender == from || _group.isAuthorizedToApprove(msg.sender), \"NOT_AUTHORIZED\");\n        _approveFor(from, spender, amount);\n        return true;\n    }\n\n    function emitTransferEvent(\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n        require(msg.sender == address(_group), \"NOT_AUTHORIZED_GROUP_ONLY\");\n        emit Transfer(from, to, amount);\n    }\n\n    // /////////////////// INTERNAL ////////////////////////\n\n    function _approveFor(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0) && spender != address(0), \"INVALID_FROM_OR_SPENDER\");\n        _mAllowed[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining) {\n        return _mAllowed[owner][spender];\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        _group.singleTransferFrom(from, to, _index, amount);\n    }\n\n    // ///////////////////// UTILITIES ///////////////////////\n    using SafeMathWithRequire for uint256;\n\n    // //////////////////// CONSTRUCTOR /////////////////////\n    constructor(\n        ERC20Group group,\n        uint256 index,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) public {\n        _group = group;\n        _index = index;\n        _name = tokenName;\n        _symbol = tokenSymbol;\n    }\n\n    // ////////////////////// DATA ///////////////////////////\n    ERC20Group internal immutable _group;\n    uint256 internal immutable _index;\n    mapping(address => mapping(address => uint256)) internal _mAllowed;\n    string internal _name;\n    string internal _symbol;\n}\n"
31     },
32     "src/solc_0.6/Catalyst/CatalystToken.sol": {
33       "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\n\ninterface CatalystToken {\n    function getMintData(uint256 catalystId)\n        external\n        view\n        returns (\n            uint16 maxGems,\n            uint16 minQuantity,\n            uint16 maxQuantity,\n            uint256 sandMintingFee,\n            uint256 sandUpdateFee\n        );\n\n    function batchBurnFrom(\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external;\n\n    function burnFrom(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) external;\n}\n"
34     },
35     "src/solc_0.6/Catalyst/CatalystValue.sol": {
36       "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\n\ninterface CatalystValue {\n    struct GemEvent {\n        uint256[] gemIds;\n        bytes32 blockHash;\n    }\n\n    function getValues(\n        uint256 catalystId,\n        uint256 seed,\n        GemEvent[] calldata events,\n        uint32 totalNumberOfGemTypes\n    ) external view returns (uint32[] memory values);\n}\n"
37     },
38     "src/solc_0.6/Catalyst/GemToken.sol": {
39       "content": "pragma solidity 0.6.5;\n\n\ninterface GemToken {\n    function batchBurnFrom(\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external;\n}\n"
40     },
41     "src/solc_0.6/CatalystMinter.sol": {
42       "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"./Interfaces/AssetToken.sol\";\nimport \"./common/Interfaces/ERC20.sol\";\nimport \"./Interfaces/ERC20Extended.sol\";\nimport \"./common/BaseWithStorage/MetaTransactionReceiver.sol\";\nimport \"./common/Libraries/SafeMathWithRequire.sol\";\nimport \"./Catalyst/GemToken.sol\";\nimport \"./Catalyst/CatalystToken.sol\";\nimport \"./CatalystRegistry.sol\";\nimport \"./BaseWithStorage/ERC20Group.sol\";\n\n\n/// @notice Gateway to mint Asset with Catalyst, Gems and Sand\ncontract CatalystMinter is MetaTransactionReceiver {\n    /// @dev emitted when fee collector (that receive the sand fee) get changed\n    /// @param newCollector address of the new collector, address(0) means the fee will be burned\n    event FeeCollector(address newCollector);\n\n    function setFeeCollector(address newCollector) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        _setFeeCollector(newCollector);\n    }\n\n    event GemAdditionFee(uint256 newFee);\n\n    function setGemAdditionFee(uint256 newFee) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        _setGemAdditionFee(newFee);\n    }\n\n    /// @notice mint one Asset token.\n    /// @param from address creating the Asset, need to be the tx sender or meta tx signer.\n    /// @param packId unused packId that will let you predict the resulting tokenId.\n    /// @param metadataHash cidv1 ipfs hash of the folder where 0.json file contains the metadata.\n    /// @param catalystId address of the Catalyst ERC20 token to burn.\n    /// @param gemIds list of gem ids to burn in the catalyst.\n    /// @param quantity asset supply to mint\n    /// @param to destination address receiving the minted tokens.\n    /// @param data extra data.\n    function mint(\n        address from,\n        uint40 packId,\n        bytes32 metadataHash,\n        uint256 catalystId,\n        uint256[] calldata gemIds,\n        uint256 quantity,\n        address to,\n        bytes calldata data\n    ) external returns (uint256) {\n        _checkAuthorization(from, to);\n        _burnCatalyst(from, catalystId);\n        uint16 maxGems = _checkQuantityAndBurnSandAndGems(from, catalystId, gemIds, quantity);\n        uint256 id = _asset.mint(from, packId, metadataHash, quantity, 0, to, data);\n        _catalystRegistry.setCatalyst(id, catalystId, maxGems, gemIds);\n        return id;\n    }\n\n    /// @notice associate a catalyst to a fungible Asset token by extracting it as ERC721 first.\n    /// @param from address from which the Asset token belongs to.\n    /// @param assetId tokenId of the Asset being extracted.\n    /// @param catalystId address of the catalyst token to use and burn.\n    /// @param gemIds list of gems to socket into the catalyst (burned).\n    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.\n    function extractAndChangeCatalyst(\n        address from,\n        uint256 assetId,\n        uint256 catalystId,\n        uint256[] calldata gemIds,\n        address to\n    ) external returns (uint256 tokenId) {\n        _checkAuthorization(from, to);\n        tokenId = _asset.extractERC721From(from, assetId, from);\n        _changeCatalyst(from, tokenId, catalystId, gemIds, to);\n    }\n\n    /// @notice associate a new catalyst to a non-fungible Asset token.\n    /// @param from address from which the Asset token belongs to.\n    /// @param assetId tokenId of the Asset being updated.\n    /// @param catalystId address of the catalyst token to use and burn.\n    /// @param gemIds list of gems to socket into the catalyst (burned).\n    /// @param to destination address receiving the Asset token.\n    function changeCatalyst(\n        address from,\n        uint256 assetId,\n        uint256 catalystId,\n        uint256[] calldata gemIds,\n        address to\n    ) external returns (uint256 tokenId) {\n        _checkAuthorization(from, to);\n        _changeCatalyst(from, assetId, catalystId, gemIds, to);\n        return assetId;\n    }\n\n    /// @notice add gems to a fungible Asset token by extracting it as ERC721 first.\n    /// @param from address from which the Asset token belongs to.\n    /// @param assetId tokenId of the Asset being extracted.\n    /// @param gemIds list of gems to socket into the existing catalyst (burned).\n    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.\n    function extractAndAddGems(\n        address from,\n        uint256 assetId,\n        uint256[] calldata gemIds,\n        address to\n    ) external returns (uint256 tokenId) {\n        _checkAuthorization(from, to);\n        tokenId = _asset.extractERC721From(from, assetId, from);\n        _addGems(from, tokenId, gemIds, to);\n    }\n\n    /// @notice add gems to a non-fungible Asset token.\n    /// @param from address from which the Asset token belongs to.\n    /// @param assetId tokenId of the Asset to which the gems will be added to.\n    /// @param gemIds list of gems to socket into the existing catalyst (burned).\n    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.\n    function addGems(\n        address from,\n        uint256 assetId,\n        uint256[] calldata gemIds,\n        address to\n    ) external {\n        _checkAuthorization(from, to);\n        _addGems(from, assetId, gemIds, to);\n    }\n\n    struct AssetData {\n        uint256[] gemIds;\n        uint256 quantity;\n        uint256 catalystId;\n    }\n\n    /// @notice mint multiple Asset tokens.\n    /// @param from address creating the Asset, need to be the tx sender or meta tx signer.\n    /// @param packId unused packId that will let you predict the resulting tokenId.\n    /// @param metadataHash cidv1 ipfs hash of the folder where 0.json file contains the metadata.\n    /// @param gemsQuantities quantities of gems to be used for each id in order\n    /// @param catalystsQuantities quantities of catalyst to be used for each id in order\n    /// @param assets contains the data to associate catalyst and gems to the assets.\n    /// @param to destination address receiving the minted tokens.\n    /// @param data extra data.\n    function mintMultiple(\n        address from,\n        uint40 packId,\n        bytes32 metadataHash,\n        uint256[] memory gemsQuantities,\n        uint256[] memory catalystsQuantities,\n        AssetData[] memory assets,\n        address to,\n        bytes memory data\n    ) public returns (uint256[] memory ids) {\n        require(assets.length != 0, \"INVALID_0_ASSETS\");\n        _checkAuthorization(from, to);\n        return _mintMultiple(from, packId, metadataHash, gemsQuantities, catalystsQuantities, assets, to, data);\n    }\n\n    // //////////////////// INTERNALS ////////////////////\n\n    function _checkQuantityAndBurnSandAndGems(\n        address from,\n        uint256 catalystId,\n        uint256[] memory gemIds,\n        uint256 quantity\n    ) internal returns (uint16) {\n        (uint16 maxGems, uint16 minQuantity, uint16 maxQuantity, uint256 sandMintingFee, ) = _getMintData(catalystId);\n        require(minQuantity <= quantity && quantity <= maxQuantity, \"INVALID_QUANTITY\");\n        require(gemIds.length <= maxGems, \"INVALID_GEMS_TOO_MANY\");\n        _burnSingleGems(from, gemIds);\n        _chargeSand(from, quantity.mul(sandMintingFee));\n        return maxGems;\n    }\n\n    function _mintMultiple(\n        address from,\n        uint40 packId,\n        bytes32 metadataHash,\n        uint256[] memory gemsQuantities,\n        uint256[] memory catalystsQuantities,\n        AssetData[] memory assets,\n        address to,\n        bytes memory data\n    ) internal returns (uint256[] memory) {\n        (uint256 totalSandFee, uint256[] memory supplies, uint16[] memory maxGemsList) = _handleMultipleCatalysts(\n            from,\n            gemsQuantities,\n            catalystsQuantities,\n            assets\n        );\n\n        _chargeSand(from, totalSandFee);\n\n        return _mintAssets(from, packId, metadataHash, assets, supplies, maxGemsList, to, data);\n    }\n\n    function _chargeSand(address from, uint256 sandFee) internal {\n        address feeCollector = _feeCollector;\n        if (feeCollector != address(0) && sandFee != 0) {\n            if (feeCollector == address(BURN_ADDRESS)) {\n                // special address for burn\n                _sand.burnFor(from, sandFee);\n            } else {\n                _sand.transferFrom(from, _feeCollector, sandFee);\n            }\n        }\n    }\n\n    function _extractMintData(uint256 data)\n        internal\n        pure\n        returns (\n            uint16 maxGems,\n            uint16 minQuantity,\n            uint16 maxQuantity,\n            uint256 sandMintingFee,\n            uint256 sandUpdateFee\n        )\n    {\n        maxGems = uint16(data >> 240);\n        minQuantity = uint16((data >> 224) % 2**16);\n        maxQuantity = uint16((data >> 208) % 2**16);\n        sandMintingFee = uint256((data >> 120) % 2**88);\n        sandUpdateFee = uint256(data % 2**88);\n    }\n\n    function _getMintData(uint256 catalystId)\n        internal\n        view\n        returns (\n            uint16,\n            uint16,\n            uint16,\n            uint256,\n            uint256\n        )\n    {\n        if (catalystId == 0) {\n            return _extractMintData(_common_mint_data);\n        } else if (catalystId == 1) {\n            return _extractMintData(_rare_mint_data);\n        } else if (catalystId == 2) {\n            return _extractMintData(_epic_mint_data);\n        } else if (catalystId == 3) {\n            return _extractMintData(_legendary_mint_data);\n        }\n        return _catalysts.getMintData(catalystId);\n    }\n\n    function _handleMultipleCatalysts(\n        address from,\n        uint256[] memory gemsQuantities,\n        uint256[] memory catalystsQuantities,\n        AssetData[] memory assets\n    )\n        internal\n        returns (\n            uint256 totalSandFee,\n            uint256[] memory supplies,\n            uint16[] memory maxGemsList\n        )\n    {\n        _burnCatalysts(from, catalystsQuantities);\n        _burnGems(from, gemsQuantities);\n\n        supplies = new uint256[](assets.length);\n        maxGemsList = new uint16[](assets.length);\n\n        for (uint256 i = 0; i < assets.length; i++) {\n            require(catalystsQuantities[assets[i].catalystId] != 0, \"INVALID_CATALYST_NOT_ENOUGH\");\n            catalystsQuantities[assets[i].catalystId]--;\n            gemsQuantities = _checkGemsQuantities(gemsQuantities, assets[i].gemIds);\n            (uint16 maxGems, uint16 minQuantity, uint16 maxQuantity, uint256 sandMintingFee, ) = _getMintData(assets[i].catalystId);\n            require(minQuantity <= assets[i].quantity && assets[i].quantity <= maxQuantity, \"INVALID_QUANTITY\");\n            require(assets[i].gemIds.length <= maxGems, \"INVALID_GEMS_TOO_MANY\");\n            maxGemsList[i] = maxGems;\n            supplies[i] = assets[i].quantity;\n            totalSandFee = totalSandFee.add(sandMintingFee.mul(assets[i].quantity));\n        }\n    }\n\n    function _checkGemsQuantities(uint256[] memory gemsQuantities, uint256[] memory gemIds) internal pure returns (uint256[] memory) {\n        for (uint256 i = 0; i < gemIds.length; i++) {\n            require(gemsQuantities[gemIds[i]] != 0, \"INVALID_GEMS_NOT_ENOUGH\");\n            gemsQuantities[gemIds[i]]--;\n        }\n        return gemsQuantities;\n    }\n\n    function _burnCatalysts(address from, uint256[] memory catalystsQuantities) internal {\n        uint256[] memory ids = new uint256[](catalystsQuantities.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            ids[i] = i;\n        }\n        _catalysts.batchBurnFrom(from, ids, catalystsQuantities);\n    }\n\n    function _burnGems(address from, uint256[] memory gemsQuantities) internal {\n        uint256[] memory ids = new uint256[](gemsQuantities.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            ids[i] = i;\n        }\n        _gems.batchBurnFrom(from, ids, gemsQuantities);\n    }\n\n    function _mintAssets(\n        address from,\n        uint40 packId,\n        bytes32 metadataHash,\n        AssetData[] memory assets,\n        uint256[] memory supplies,\n        uint16[] memory maxGemsList,\n        address to,\n        bytes memory data\n    ) internal returns (uint256[] memory tokenIds) {\n        tokenIds = _asset.mintMultiple(from, packId, metadataHash, supplies, \"\", to, data);\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _catalystRegistry.setCatalyst(tokenIds[i], assets[i].catalystId, maxGemsList[i], assets[i].gemIds);\n        }\n    }\n\n    function _changeCatalyst(\n        address from,\n        uint256 assetId,\n        uint256 catalystId,\n        uint256[] memory gemIds,\n        address to\n    ) internal {\n        require(assetId & IS_NFT != 0, \"INVALID_NOT_NFT\"); // Asset (ERC1155ERC721.sol) ensure NFT will return true here and non-NFT will return false\n        _burnCatalyst(from, catalystId);\n        (uint16 maxGems, , , , uint256 sandUpdateFee) = _getMintData(catalystId);\n        require(gemIds.length <= maxGems, \"INVALID_GEMS_TOO_MANY\");\n        _burnGems(from, gemIds);\n        _chargeSand(from, sandUpdateFee);\n\n        _catalystRegistry.setCatalyst(assetId, catalystId, maxGems, gemIds);\n\n        _transfer(from, to, assetId);\n    }\n\n    function _addGems(\n        address from,\n        uint256 assetId,\n        uint256[] memory gemIds,\n        address to\n    ) internal {\n        require(assetId & IS_NFT != 0, \"INVALID_NOT_NFT\"); // Asset (ERC1155ERC721.sol) ensure NFT will return true here and non-NFT will return false\n        _catalystRegistry.addGems(assetId, gemIds);\n        _chargeSand(from, gemIds.length.mul(_gemAdditionFee));\n        _transfer(from, to, assetId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 assetId\n    ) internal {\n        if (from != to) {\n            _asset.safeTransferFrom(from, to, assetId);\n        }\n    }\n\n    function _checkAuthorization(address from, address to) internal view {\n        require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        require(from == msg.sender || _metaTransactionContracts[msg.sender], \"NOT_SENDER\");\n    }\n\n    function _burnSingleGems(address from, uint256[] memory gemIds) internal {\n        uint256[] memory amounts = new uint256[](gemIds.length);\n        for (uint256 i = 0; i < gemIds.length; i++) {\n            amounts[i] = 1;\n        }\n        _gems.batchBurnFrom(from, gemIds, amounts);\n    }\n\n    function _burnCatalyst(address from, uint256 catalystId) internal {\n        _catalysts.burnFrom(from, catalystId, 1);\n    }\n\n    function _setFeeCollector(address newCollector) internal {\n        _feeCollector = newCollector;\n        emit FeeCollector(newCollector);\n    }\n\n    function _setGemAdditionFee(uint256 newFee) internal {\n        _gemAdditionFee = newFee;\n        emit GemAdditionFee(newFee);\n    }\n\n    // /////////////////// UTILITIES /////////////////////\n    using SafeMathWithRequire for uint256;\n\n    // //////////////////////// DATA /////////////////////\n    uint256 private constant IS_NFT = 0x0000000000000000000000000000000000000000800000000000000000000000;\n    address private constant BURN_ADDRESS = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\n\n    ERC20Extended internal immutable _sand;\n    AssetToken internal immutable _asset;\n    GemToken internal immutable _gems;\n    CatalystToken internal immutable _catalysts;\n    CatalystRegistry internal immutable _catalystRegistry;\n    address internal _feeCollector;\n\n    uint256 internal immutable _common_mint_data;\n    uint256 internal immutable _rare_mint_data;\n    uint256 internal immutable _epic_mint_data;\n    uint256 internal immutable _legendary_mint_data;\n\n    uint256 internal _gemAdditionFee;\n\n    // /////////////////// CONSTRUCTOR ////////////////////\n    constructor(\n        CatalystRegistry catalystRegistry,\n        ERC20Extended sand,\n        AssetToken asset,\n        GemToken gems,\n        address metaTx,\n        address admin,\n        address feeCollector,\n        uint256 gemAdditionFee,\n        CatalystToken catalysts,\n        uint256[4] memory bakedInMintdata\n    ) public {\n        _catalystRegistry = catalystRegistry;\n        _sand = sand;\n        _asset = asset;\n        _gems = gems;\n        _catalysts = catalysts;\n        _admin = admin;\n        _setGemAdditionFee(gemAdditionFee);\n        _setFeeCollector(feeCollector);\n        _setMetaTransactionProcessor(metaTx, true);\n        _common_mint_data = bakedInMintdata[0];\n        _rare_mint_data = bakedInMintdata[1];\n        _epic_mint_data = bakedInMintdata[2];\n        _legendary_mint_data = bakedInMintdata[3];\n    }\n}\n"
43     },
44     "src/solc_0.6/CatalystRegistry.sol": {
45       "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"./Interfaces/AssetToken.sol\";\nimport \"./common/BaseWithStorage/Admin.sol\";\nimport \"./Catalyst/CatalystValue.sol\";\n\n\ncontract CatalystRegistry is Admin, CatalystValue {\n    event Minter(address indexed newMinter);\n    event CatalystApplied(uint256 indexed assetId, uint256 indexed catalystId, uint256 seed, uint256[] gemIds, uint64 blockNumber);\n    event GemsAdded(uint256 indexed assetId, uint256 seed, uint256[] gemIds, uint64 blockNumber);\n\n    function getCatalyst(uint256 assetId) external view returns (bool exists, uint256 catalystId) {\n        CatalystStored memory catalyst = _catalysts[assetId];\n        if (catalyst.set != 0) {\n            return (true, catalyst.catalystId);\n        }\n        if (assetId & IS_NFT != 0) {\n            catalyst = _catalysts[_getCollectionId(assetId)];\n            return (catalyst.set != 0, catalyst.catalystId);\n        }\n        return (false, 0);\n    }\n\n    function setCatalyst(\n        uint256 assetId,\n        uint256 catalystId,\n        uint256 maxGems,\n        uint256[] calldata gemIds\n    ) external {\n        require(msg.sender == _minter, \"NOT_AUTHORIZED_MINTER\");\n        require(gemIds.length <= maxGems, \"INVALID_GEMS_TOO_MANY\");\n        uint256 emptySockets = maxGems - gemIds.length;\n        _catalysts[assetId] = CatalystStored(uint64(emptySockets), uint64(catalystId), 1);\n        uint64 blockNumber = _getBlockNumber();\n        emit CatalystApplied(assetId, catalystId, assetId, gemIds, blockNumber);\n    }\n\n    function addGems(uint256 assetId, uint256[] calldata gemIds) external {\n        require(msg.sender == _minter, \"NOT_AUTHORIZED_MINTER\");\n        require(assetId & IS_NFT != 0, \"INVALID_NOT_NFT\");\n        require(gemIds.length != 0, \"INVALID_GEMS_0\");\n        (uint256 emptySockets, uint256 seed) = _getSocketData(assetId);\n        require(emptySockets >= gemIds.length, \"INVALID_GEMS_TOO_MANY\");\n        emptySockets -= gemIds.length;\n        _catalysts[assetId].emptySockets = uint64(emptySockets);\n        uint64 blockNumber = _getBlockNumber();\n        emit GemsAdded(assetId, seed, gemIds, blockNumber);\n    }\n\n    /// @dev Set the Minter that will be the only address able to create Estate\n    /// @param minter address of the minter\n    function setMinter(address minter) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        require(minter != _minter, \"INVALID_MINTER_SAME_ALREADY_SET\");\n        _minter = minter;\n        emit Minter(minter);\n    }\n\n    /// @dev return the current minter\n    function getMinter() external view returns (address) {\n        return _minter;\n    }\n\n    function getValues(\n        uint256 catalystId,\n        uint256 seed,\n        GemEvent[] calldata events,\n        uint32 totalNumberOfGemTypes\n    ) external override view returns (uint32[] memory values) {\n        return _catalystValue.getValues(catalystId, seed, events, totalNumberOfGemTypes);\n    }\n\n    // ///////// INTERNAL ////////////\n\n    uint256 private constant IS_NFT = 0x0000000000000000000000000000000000000000800000000000000000000000;\n    uint256 private constant NOT_IS_NFT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFFFFFFFFFF;\n    uint256 private constant NOT_NFT_INDEX = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF800000007FFFFFFFFFFFFFFF;\n\n    function _getSocketData(uint256 assetId) internal view returns (uint256 emptySockets, uint256 seed) {\n        seed = assetId;\n        CatalystStored memory catalyst = _catalysts[assetId];\n        if (catalyst.set != 0) {\n            // the gems are added to an asset who already get a specific catalyst.\n            // the seed is its id\n            return (catalyst.emptySockets, seed);\n        }\n        // else the asset is only adding gems while keeping the same seed (that of the original assetId)\n        seed = _getCollectionId(assetId);\n        catalyst = _catalysts[seed];\n        return (catalyst.emptySockets, seed);\n    }\n\n    function _getBlockNumber() internal view returns (uint64 blockNumber) {\n        blockNumber = uint64(block.number + 1);\n    }\n\n    function _getCollectionId(uint256 assetId) internal pure returns (uint256) {\n        return assetId & NOT_NFT_INDEX & NOT_IS_NFT; // compute the same as Asset to get collectionId\n    }\n\n    // CONSTRUCTOR ////\n    constructor(CatalystValue catalystValue, address admin) public {\n        _admin = admin;\n        _catalystValue = catalystValue;\n    }\n\n    /// DATA ////////\n\n    struct CatalystStored {\n        uint64 emptySockets;\n        uint64 catalystId;\n        uint64 set;\n    }\n    address internal _minter;\n    CatalystValue internal immutable _catalystValue;\n    mapping(uint256 => CatalystStored) internal _catalysts;\n}\n"
46     },
47     "src/solc_0.6/Interfaces/AssetToken.sol": {
48       "content": "pragma solidity 0.6.5;\n\n\ninterface AssetToken {\n    function mint(\n        address creator,\n        uint40 packId,\n        bytes32 hash,\n        uint256 supply,\n        uint8 rarity,\n        address owner,\n        bytes calldata data\n    ) external returns (uint256 id);\n\n    function mintMultiple(\n        address creator,\n        uint40 packId,\n        bytes32 hash,\n        uint256[] calldata supplies,\n        bytes calldata rarityPack,\n        address owner,\n        bytes calldata data\n    ) external returns (uint256[] memory ids);\n\n    // fails on non-NFT or nft who do not have collection (was a mistake)\n    function collectionOf(uint256 id) external view returns (uint256);\n\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    // return true for Non-NFT ERC1155 tokens which exists\n    function isCollection(uint256 id) external view returns (bool);\n\n    function collectionIndexOf(uint256 id) external view returns (uint256);\n\n    function extractERC721From(\n        address sender,\n        uint256 id,\n        address to\n    ) external returns (uint256 newId);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
49     },
50     "src/solc_0.6/Interfaces/ERC20Extended.sol": {
51       "content": "pragma solidity 0.6.5;\n\nimport \"../common/Interfaces/ERC20.sol\";\n\n\ninterface ERC20Extended is ERC20 {\n    function burnFor(address from, uint256 amount) external;\n\n    function burn(uint256 amount) external;\n\n    function approveFor(\n        address owner,\n        address spender,\n        uint256 amount\n    ) external returns (bool success);\n}\n"
52     },
53     "src/solc_0.6/common/BaseWithStorage/Admin.sol": {
54       "content": "pragma solidity 0.6.5;\n\n\ncontract Admin {\n    address internal _admin;\n\n    /// @dev emitted when the contract administrator is changed.\n    /// @param oldAdmin address of the previous administrator.\n    /// @param newAdmin address of the new administrator.\n    event AdminChanged(address oldAdmin, address newAdmin);\n\n    /// @dev gives the current administrator of this contract.\n    /// @return the current administrator of this contract.\n    function getAdmin() external view returns (address) {\n        return _admin;\n    }\n\n    /// @dev change the administrator to be `newAdmin`.\n    /// @param newAdmin address of the new administrator.\n    function changeAdmin(address newAdmin) external {\n        require(msg.sender == _admin, \"only admin can change admin\");\n        emit AdminChanged(_admin, newAdmin);\n        _admin = newAdmin;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == _admin, \"only admin allowed\");\n        _;\n    }\n}\n"
55     },
56     "src/solc_0.6/common/BaseWithStorage/MetaTransactionReceiver.sol": {
57       "content": "pragma solidity 0.6.5;\n\nimport \"./Admin.sol\";\n\n\ncontract MetaTransactionReceiver is Admin {\n    mapping(address => bool) internal _metaTransactionContracts;\n\n    /// @dev emiited when a meta transaction processor is enabled/disabled\n    /// @param metaTransactionProcessor address that will be given/removed metaTransactionProcessor rights.\n    /// @param enabled set whether the metaTransactionProcessor is enabled or disabled.\n    event MetaTransactionProcessor(address metaTransactionProcessor, bool enabled);\n\n    /// @dev Enable or disable the ability of `metaTransactionProcessor` to perform meta-tx (metaTransactionProcessor rights).\n    /// @param metaTransactionProcessor address that will be given/removed metaTransactionProcessor rights.\n    /// @param enabled set whether the metaTransactionProcessor is enabled or disabled.\n    function setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) public {\n        require(msg.sender == _admin, \"only admin can setup metaTransactionProcessors\");\n        _setMetaTransactionProcessor(metaTransactionProcessor, enabled);\n    }\n\n    function _setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) internal {\n        _metaTransactionContracts[metaTransactionProcessor] = enabled;\n        emit MetaTransactionProcessor(metaTransactionProcessor, enabled);\n    }\n\n    /// @dev check whether address `who` is given meta-transaction execution rights.\n    /// @param who The address to query.\n    /// @return whether the address has meta-transaction execution rights.\n    function isMetaTransactionProcessor(address who) external view returns (bool) {\n        return _metaTransactionContracts[who];\n    }\n}\n"
58     },
59     "src/solc_0.6/common/BaseWithStorage/SuperOperators.sol": {
60       "content": "pragma solidity 0.6.5;\n\nimport \"./Admin.sol\";\n\n\ncontract SuperOperators is Admin {\n    mapping(address => bool) internal _superOperators;\n\n    event SuperOperator(address superOperator, bool enabled);\n\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\n    /// @param superOperator address that will be given/removed superOperator right.\n    /// @param enabled set whether the superOperator is enabled or disabled.\n    function setSuperOperator(address superOperator, bool enabled) external {\n        require(msg.sender == _admin, \"only admin is allowed to add super operators\");\n        _superOperators[superOperator] = enabled;\n        emit SuperOperator(superOperator, enabled);\n    }\n\n    /// @notice check whether address `who` is given superOperator rights.\n    /// @param who The address to query.\n    /// @return whether the address has superOperator rights.\n    function isSuperOperator(address who) public view returns (bool) {\n        return _superOperators[who];\n    }\n}\n"
61     },
62     "src/solc_0.6/common/Interfaces/ERC20.sol": {
63       "content": "pragma solidity 0.6.5;\n\n\n/// @dev see https://eips.ethereum.org/EIPS/eip-20\ninterface ERC20 {\n    /// @notice emitted when tokens are transfered from one address to another.\n    /// @param from address from which the token are transfered from (zero means tokens are minted).\n    /// @param to destination address which the token are transfered to (zero means tokens are burnt).\n    /// @param value amount of tokens transferred.\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice emitted when owner grant transfer rights to another address\n    /// @param owner address allowing its token to be transferred.\n    /// @param spender address allowed to spend on behalf of `owner`\n    /// @param value amount of tokens allowed.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice return the current total amount of tokens owned by all holders.\n    /// @return supply total number of tokens held.\n    function totalSupply() external view returns (uint256 supply);\n\n    /// @notice return the number of tokens held by a particular address.\n    /// @param who address being queried.\n    /// @return balance number of token held by that address.\n    function balanceOf(address who) external view returns (uint256 balance);\n\n    /// @notice transfer tokens to a specific address.\n    /// @param to destination address receiving the tokens.\n    /// @param value number of tokens to transfer.\n    /// @return success whether the transfer succeeded.\n    function transfer(address to, uint256 value) external returns (bool success);\n\n    /// @notice transfer tokens from one address to another.\n    /// @param from address tokens will be sent from.\n    /// @param to destination address receiving the tokens.\n    /// @param value number of tokens to transfer.\n    /// @return success whether the transfer succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool success);\n\n    /// @notice approve an address to spend on your behalf.\n    /// @param spender address entitled to transfer on your behalf.\n    /// @param value amount allowed to be transfered.\n    /// @param success whether the approval succeeded.\n    function approve(address spender, uint256 value) external returns (bool success);\n\n    /// @notice return the current allowance for a particular owner/spender pair.\n    /// @param owner address allowing spender.\n    /// @param spender address allowed to spend.\n    /// @return amount number of tokens `spender` can spend on behalf of `owner`.\n    function allowance(address owner, address spender) external view returns (uint256 amount);\n}\n"
64     },
65     "src/solc_0.6/common/Libraries/AddressUtils.sol": {
66       "content": "pragma solidity 0.6.5;\n\n\nlibrary AddressUtils {\n    function toPayable(address _address) internal pure returns (address payable _payable) {\n        return address(uint160(_address));\n    }\n\n    function isContract(address addr) internal view returns (bool) {\n        // for accounts without code, i.e. `keccak256('')`:\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        bytes32 codehash;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codehash := extcodehash(addr)\n        }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n}\n"
67     },
68     "src/solc_0.6/common/Libraries/BytesUtil.sol": {
69       "content": "pragma solidity 0.6.5;\n\n\nlibrary BytesUtil {\n    function memcpy(\n        uint256 dest,\n        uint256 src,\n        uint256 len\n    ) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    function pointerToBytes(uint256 src, uint256 len) internal pure returns (bytes memory) {\n        bytes memory ret = new bytes(len);\n        uint256 retptr;\n        assembly {\n            retptr := add(ret, 32)\n        }\n\n        memcpy(retptr, src, len);\n        return ret;\n    }\n\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\n            mstore(0x40, add(m, 52))\n            b := m\n        }\n    }\n\n    function uint256ToBytes(uint256 a) internal pure returns (bytes memory b) {\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 32), a)\n            mstore(0x40, add(m, 64))\n            b := m\n        }\n    }\n\n    function doFirstParamEqualsAddress(bytes memory data, address _address) internal pure returns (bool) {\n        if (data.length < (36 + 32)) {\n            return false;\n        }\n        uint256 value;\n        assembly {\n            value := mload(add(data, 36))\n        }\n        return value == uint256(_address);\n    }\n\n    function doParamEqualsUInt256(\n        bytes memory data,\n        uint256 i,\n        uint256 value\n    ) internal pure returns (bool) {\n        if (data.length < (36 + (i + 1) * 32)) {\n            return false;\n        }\n        uint256 offset = 36 + i * 32;\n        uint256 valuePresent;\n        assembly {\n            valuePresent := mload(add(data, offset))\n        }\n        return valuePresent == value;\n    }\n\n    function overrideFirst32BytesWithAddress(bytes memory data, address _address) internal pure returns (bytes memory) {\n        uint256 dest;\n        assembly {\n            dest := add(data, 48)\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\n\n        bytes memory addressBytes = addressToBytes(_address);\n        uint256 src;\n        assembly {\n            src := add(addressBytes, 32)\n        }\n\n        memcpy(dest, src, 20);\n        return data;\n    }\n\n    function overrideFirstTwo32BytesWithAddressAndInt(\n        bytes memory data,\n        address _address,\n        uint256 _value\n    ) internal pure returns (bytes memory) {\n        uint256 dest;\n        uint256 src;\n\n        assembly {\n            dest := add(data, 48)\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\n        bytes memory bbytes = addressToBytes(_address);\n        assembly {\n            src := add(bbytes, 32)\n        }\n        memcpy(dest, src, 20);\n\n        assembly {\n            dest := add(data, 68)\n        } // 48 = 32 (offset) + 4 (func sig) + 32 (next slot)\n        bbytes = uint256ToBytes(_value);\n        assembly {\n            src := add(bbytes, 32)\n        }\n        memcpy(dest, src, 32);\n\n        return data;\n    }\n}\n"
70     },
71     "src/solc_0.6/common/Libraries/ObjectLib32.sol": {
72       "content": "pragma solidity 0.6.5;\n\nimport \"./SafeMathWithRequire.sol\";\n\n\nlibrary ObjectLib32 {\n    using SafeMathWithRequire for uint256;\n    enum Operations {ADD, SUB, REPLACE}\n    // Constants regarding bin or chunk sizes for balance packing\n    uint256 constant TYPES_BITS_SIZE = 32; // Max size of each object\n    uint256 constant TYPES_PER_UINT256 = 256 / TYPES_BITS_SIZE; // Number of types per uint256\n\n    //\n    // Objects and Tokens Functions\n    //\n\n    /**\n     * @dev Return the bin number and index within that bin where ID is\n     * @param tokenId Object type\n     * @return bin Bin number\n     * @return index ID's index within that bin\n     */\n    function getTokenBinIndex(uint256 tokenId) internal pure returns (uint256 bin, uint256 index) {\n        bin = (tokenId * TYPES_BITS_SIZE) / 256;\n        index = tokenId % TYPES_PER_UINT256;\n        return (bin, index);\n    }\n\n    /**\n     * @dev update the balance of a type provided in binBalances\n     * @param binBalances Uint256 containing the balances of objects\n     * @param index Index of the object in the provided bin\n     * @param amount Value to update the type balance\n     * @param operation Which operation to conduct :\n     *     Operations.REPLACE : Replace type balance with amount\n     *     Operations.ADD     : ADD amount to type balance\n     *     Operations.SUB     : Substract amount from type balance\n     */\n    function updateTokenBalance(\n        uint256 binBalances,\n        uint256 index,\n        uint256 amount,\n        Operations operation\n    ) internal pure returns (uint256 newBinBalance) {\n        uint256 objectBalance = 0;\n        if (operation == Operations.ADD) {\n            objectBalance = getValueInBin(binBalances, index);\n            newBinBalance = writeValueInBin(binBalances, index, objectBalance.add(amount));\n        } else if (operation == Operations.SUB) {\n            objectBalance = getValueInBin(binBalances, index);\n            require(objectBalance >= amount, \"can't substract more than there is\");\n            newBinBalance = writeValueInBin(binBalances, index, objectBalance.sub(amount));\n        } else if (operation == Operations.REPLACE) {\n            newBinBalance = writeValueInBin(binBalances, index, amount);\n        } else {\n            revert(\"Invalid operation\"); // Bad operation\n        }\n\n        return newBinBalance;\n    }\n\n    /*\n     * @dev return value in binValue at position index\n     * @param binValue uint256 containing the balances of TYPES_PER_UINT256 types\n     * @param index index at which to retrieve value\n     * @return Value at given index in bin\n     */\n    function getValueInBin(uint256 binValue, uint256 index) internal pure returns (uint256) {\n        // Mask to retrieve data for a given binData\n        uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n        // Shift amount\n        uint256 rightShift = 256 - TYPES_BITS_SIZE * (index + 1);\n        return (binValue >> rightShift) & mask;\n    }\n\n    /**\n     * @dev return the updated binValue after writing amount at index\n     * @param binValue uint256 containing the balances of TYPES_PER_UINT256 types\n     * @param index Index at which to retrieve value\n     * @param amount Value to store at index in bin\n     * @return Value at given index in bin\n     */\n    function writeValueInBin(\n        uint256 binValue,\n        uint256 index,\n        uint256 amount\n    ) internal pure returns (uint256) {\n        require(amount < 2**TYPES_BITS_SIZE, \"Amount to write in bin is too large\");\n\n        // Mask to retrieve data for a given binData\n        uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n        // Shift amount\n        uint256 leftShift = 256 - TYPES_BITS_SIZE * (index + 1);\n        return (binValue & ~(mask << leftShift)) | (amount << leftShift);\n    }\n}\n"
73     },
74     "src/solc_0.6/common/Libraries/SafeMath.sol": {
75       "content": "pragma solidity 0.6.5;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, throws on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n     * @dev Adds two numbers, throws on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n"
76     },
77     "src/solc_0.6/common/Libraries/SafeMathWithRequire.sol": {
78       "content": "pragma solidity 0.6.5;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert\n */\nlibrary SafeMathWithRequire {\n    using SafeMathWithRequire for uint256;\n\n    uint256 constant DECIMALS_18 = 1000000000000000000;\n    uint256 constant DECIMALS_12 = 1000000000000;\n    uint256 constant DECIMALS_9 = 1000000000;\n    uint256 constant DECIMALS_6 = 1000000;\n\n    /**\n     * @dev Multiplies two numbers, throws on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        require(c / a == b, \"overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"divbyzero\");\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"undeflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Adds two numbers, throws on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        require(c >= a, \"overflow\");\n        return c;\n    }\n\n    function sqrt6(uint256 a) internal pure returns (uint256 c) {\n        a = a.mul(DECIMALS_12);\n        uint256 tmp = a.add(1) / 2;\n        c = a;\n        // tmp cannot be zero unless a = 0 which skip the loop\n        while (tmp < c) {\n            c = tmp;\n            tmp = ((a / tmp) + tmp) / 2;\n        }\n    }\n\n    function sqrt3(uint256 a) internal pure returns (uint256 c) {\n        a = a.mul(DECIMALS_6);\n        uint256 tmp = a.add(1) / 2;\n        c = a;\n        // tmp cannot be zero unless a = 0 which skip the loop\n        while (tmp < c) {\n            c = tmp;\n            tmp = ((a / tmp) + tmp) / 2;\n        }\n    }\n\n    function cbrt6(uint256 a) internal pure returns (uint256 c) {\n        a = a.mul(DECIMALS_18);\n        uint256 tmp = a.add(2) / 3;\n        c = a;\n        // tmp cannot be zero unless a = 0 which skip the loop\n        while (tmp < c) {\n            c = tmp;\n            uint256 tmpSquare = tmp**2;\n            require(tmpSquare > tmp, \"overflow\");\n            tmp = ((a / tmpSquare) + (tmp * 2)) / 3;\n        }\n        return c;\n    }\n\n    function cbrt3(uint256 a) internal pure returns (uint256 c) {\n        a = a.mul(DECIMALS_9);\n        uint256 tmp = a.add(2) / 3;\n        c = a;\n        // tmp cannot be zero unless a = 0 which skip the loop\n        while (tmp < c) {\n            c = tmp;\n            uint256 tmpSquare = tmp**2;\n            require(tmpSquare > tmp, \"overflow\");\n            tmp = ((a / tmpSquare) + (tmp * 2)) / 3;\n        }\n        return c;\n    }\n\n    // TODO test\n    function rt6_3(uint256 a) internal pure returns (uint256 c) {\n        a = a.mul(DECIMALS_18);\n        uint256 tmp = a.add(5) / 6;\n        c = a;\n        // tmp cannot be zero unless a = 0 which skip the loop\n        while (tmp < c) {\n            c = tmp;\n            uint256 tmpFive = tmp**5;\n            require(tmpFive > tmp, \"overflow\");\n            tmp = ((a / tmpFive) + (tmp * 5)) / 6;\n        }\n    }\n}\n"
79     }
80   }
81 }}