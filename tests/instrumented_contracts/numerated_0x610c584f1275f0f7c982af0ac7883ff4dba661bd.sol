1 {{
2   "language": "Solidity",
3   "sources": {
4     "@openzeppelin/contracts/access/Ownable.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
6     },
7     "@openzeppelin/contracts/access/Ownable2Step.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() external {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
9     },
10     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
12     },
13     "@openzeppelin/contracts/utils/Context.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
15     },
16     "contracts/FX1SportsToken.sol": {
17       "content": "//SPDX-License-Identifier: None\r\n\r\npragma solidity ^0.8.19;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\r\nimport \"./interfaces/IUniswapV2Factory.sol\";\r\nimport \"./interfaces/IUniswapV2Router02.sol\";\r\nimport \"./interfaces/IFX1SportsToken.sol\";\r\n\r\n/// @title FX1 Sports Token\r\n/// @title https://fx1.io/\r\n/// @title https://t.me/fx1_sports_portal\r\n/// @author https://PROOFplatform.io\r\n/// @author https://5thWeb.io\r\n\r\ncontract FX1SportsToken is Ownable2Step, IFX1SportsToken {\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    mapping(address => bool) public bots;\r\n    mapping(address => bool) public excludedFromFees;\r\n    mapping(address => bool) public excludedFromMaxTransfer;\r\n    mapping(address => bool) public excludedFromMaxWallet;\r\n    mapping(address => bool) public whitelists;\r\n\r\n    uint256 private _totalSupply = 250_000_000 * 10 ** _decimals;\r\n    uint256 public launchTime;\r\n    uint256 public whitelistPeriod;\r\n    uint256 public swapThreshold;\r\n    uint256 public maxTransferAmount;\r\n    uint256 public maxWalletAmount;\r\n    uint256 private accLiquidityAmount;\r\n    uint256 private accMarketingAmount;\r\n    uint256 private accPROOFAmount;\r\n\r\n    address public marketingTaxRecv;\r\n    address public proofRevenue;\r\n    address public proofRewards;\r\n    address public proofAdmin;\r\n    address public pair;\r\n    address constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    bool private inSwapLiquidity;\r\n\r\n    string private _name = \"FX1 Sports\";\r\n    string private _symbol = \"FX1\";\r\n\r\n    uint16 public immutable FIXED_POINT = 1000;\r\n    uint8 private constant _decimals = 18;\r\n\r\n    IUniswapV2Router02 public dexRouter;\r\n    BuyFeeRate public buyfeeRate;\r\n    SellFeeRate public sellfeeRate;\r\n\r\n    modifier onlyPROOFAdmin() {\r\n        require(\r\n            proofAdmin == _msgSender(),\r\n            \"Ownable: caller is not the proofAdmin\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(Param memory _param) {\r\n        require(\r\n            _param.proofRevenue != address(0),\r\n            \"invalid PROOF Revenue address\"\r\n        );\r\n        require(\r\n            _param.proofRewards != address(0),\r\n            \"invalid PROOF Rewards address\"\r\n        );\r\n        require(\r\n            _param.proofAdmin != address(0),\r\n            \"invalid PROOF Rewards address\"\r\n        );\r\n        require(\r\n            _param.marketingTaxRecv != address(0),\r\n            \"invalid MarketingTaxRecv address\"\r\n        );\r\n        require(\r\n            _param.teamAllocator_1 != address(0),\r\n            \"invalid teamAllocator_1 address\"\r\n        );\r\n        require(\r\n            _param.teamAllocator_2 != address(0),\r\n            \"invalid teamAllocator_2 address\"\r\n        );\r\n        require(_param.dexRouter != address(0), \"invalid dexRouter adddress\");\r\n        require(_param.whitelistPeriod > 0, \"invalid whitelistPeriod\");\r\n        require(_param.proofFeeDuration > 0, \"invalid proofFeeDuration\");\r\n        require(\r\n            _param.highPROOFFeeRate > 0 &&\r\n                _param.highPROOFFeeRate > _param.normalPROOFFeeRate,\r\n            \"invalid highPROOFFeeRate\"\r\n        );\r\n        require(_param.normalPROOFFeeRate > 0, \"invalid normalPROOFFeeRate\");\r\n        require(\r\n            _param.totalTeamAllocationRate > 0,\r\n            \"invalid totalTeamAllocationRate\"\r\n        );\r\n        require(\r\n            _param.totalTeamAllocationRate ==\r\n                _param.teamAllocationRate_1 + _param.teamAllocationRate_2,\r\n            \"invalid teamAllocationRates\"\r\n        );\r\n\r\n        address sender = msg.sender;\r\n        proofRevenue = _param.proofRevenue;\r\n        proofRewards = _param.proofRewards;\r\n        proofAdmin = _param.proofAdmin;\r\n        marketingTaxRecv = _param.marketingTaxRecv;\r\n        dexRouter = IUniswapV2Router02(_param.dexRouter);\r\n        whitelistPeriod = _param.whitelistPeriod;\r\n        buyfeeRate.highPROOFFeeRate = _param.highPROOFFeeRate;\r\n        buyfeeRate.normalPROOFFeeRate = _param.normalPROOFFeeRate;\r\n        buyfeeRate.liquidityFeeRate = _param.liquidityFeeRate;\r\n        buyfeeRate.marketingFeeRate = _param.marketingFeeRate;\r\n        buyfeeRate.proofFeeDuration = _param.proofFeeDuration;\r\n        buyfeeRate.highTotalFeeRate =\r\n            _param.marketingFeeRate +\r\n            _param.liquidityFeeRate +\r\n            _param.highPROOFFeeRate;\r\n        buyfeeRate.normalTotalFeeRate =\r\n            _param.marketingFeeRate +\r\n            _param.liquidityFeeRate +\r\n            _param.normalPROOFFeeRate;\r\n\r\n        sellfeeRate.highPROOFFeeRate = _param.highPROOFFeeRate;\r\n        sellfeeRate.normalPROOFFeeRate = _param.normalPROOFFeeRate;\r\n        sellfeeRate.liquidityFeeRate = _param.liquidityFeeRate;\r\n        sellfeeRate.marketingFeeRate = _param.marketingFeeRate;\r\n        sellfeeRate.proofFeeDuration = _param.proofFeeDuration;\r\n        sellfeeRate.highTotalFeeRate =\r\n            _param.marketingFeeRate +\r\n            _param.liquidityFeeRate +\r\n            _param.highPROOFFeeRate;\r\n        sellfeeRate.normalTotalFeeRate =\r\n            _param.marketingFeeRate +\r\n            _param.liquidityFeeRate +\r\n            _param.normalPROOFFeeRate;\r\n\r\n        pair = IUniswapV2Factory(dexRouter.factory()).createPair(\r\n            dexRouter.WETH(),\r\n            address(this)\r\n        );\r\n\r\n        excludedFromFees[sender] = true;\r\n        excludedFromMaxTransfer[sender] = true;\r\n        excludedFromMaxTransfer[pair] = true;\r\n        excludedFromMaxTransfer[address(this)] = true;\r\n        excludedFromMaxWallet[sender] = true;\r\n        excludedFromMaxWallet[pair] = true;\r\n        excludedFromMaxWallet[address(this)] = true;\r\n        excludedFromMaxWallet[proofRevenue] = true;\r\n        excludedFromMaxWallet[proofRewards] = true;\r\n        excludedFromMaxWallet[proofAdmin] = true;\r\n        excludedFromMaxWallet[marketingTaxRecv] = true;\r\n        whitelists[sender] = true;\r\n        whitelists[pair] = true;\r\n        whitelists[address(this)] = true;\r\n\r\n        uint256 totalTeamAllocationAmount = (_totalSupply *\r\n            _param.totalTeamAllocationRate) / FIXED_POINT;\r\n        uint256 teamAllocationAmount_1 = (_totalSupply *\r\n            _param.teamAllocationRate_1) / FIXED_POINT;\r\n        uint256 teamAllocationAmount_2 = totalTeamAllocationAmount -\r\n            teamAllocationAmount_1;\r\n        uint256 amountForDeployer = _totalSupply - totalTeamAllocationAmount;\r\n        _balances[_param.teamAllocator_1] += teamAllocationAmount_1;\r\n        _balances[_param.teamAllocator_2] += teamAllocationAmount_2;\r\n        _balances[msg.sender] += amountForDeployer;\r\n        emit Transfer(address(0), msg.sender, amountForDeployer);\r\n        emit Transfer(\r\n            address(0),\r\n            _param.teamAllocator_1,\r\n            teamAllocationAmount_1\r\n        );\r\n        emit Transfer(\r\n            address(0),\r\n            _param.teamAllocator_2,\r\n            teamAllocationAmount_2\r\n        );\r\n        swapThreshold = _totalSupply / 10000; // 0.01%\r\n        maxTransferAmount = (_totalSupply * 5) / 1000; // 0.5%\r\n        maxWalletAmount = (_totalSupply * 1) / 100; // 1%\r\n    }\r\n\r\n    // !---------------- functions for ERC20 token ----------------!\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() external pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) external override returns (bool) {\r\n        _transfer(msg.sender, _recipient, _amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    ) external view override returns (uint256) {\r\n        return _allowances[_owner][_spender];\r\n    }\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _amount\r\n    ) external override returns (bool) {\r\n        _approve(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) external override returns (bool) {\r\n        uint256 currentAllowance = _allowances[_sender][msg.sender];\r\n        require(currentAllowance >= _amount, \"Transfer > allowance\");\r\n        _approve(_sender, msg.sender, currentAllowance - _amount);\r\n        _transfer(_sender, _recipient, _amount);\r\n        return true;\r\n    }\r\n\r\n    // !---------------- functions for ERC20 token ----------------!\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function updatePROOFAdmin(\r\n        address _newAdmin\r\n    ) external override onlyPROOFAdmin {\r\n        require(_newAdmin != address(0), \"invalid proofAdmin address\");\r\n        proofAdmin = _newAdmin;\r\n    }\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function setBots(address[] memory _bots) external override onlyPROOFAdmin {\r\n        uint256 length = _bots.length;\r\n        require(length > 0, \"invalid array length\");\r\n        for (uint256 i = 0; i < _bots.length; i++) {\r\n            bots[_bots[i]] = true;\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function cancelToken() external override onlyPROOFAdmin {\r\n        excludedFromFees[address(dexRouter)] = true;\r\n        excludedFromMaxTransfer[address(dexRouter)] = true;\r\n        excludedFromMaxWallet[address(dexRouter)] = true;\r\n        excludedFromMaxTransfer[owner()] = true;\r\n        excludedFromMaxWallet[owner()] = true;\r\n        _transferOwnership(proofAdmin);\r\n    }\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function formatPROOFFee() external override onlyPROOFAdmin {\r\n        require(buyfeeRate.normalPROOFFeeRate != 0, \"already reduced\");\r\n        require(buyfeeRate.highPROOFFeeRate != 0, \"already reduced\");\r\n        require(sellfeeRate.normalPROOFFeeRate != 0, \"already reduced\");\r\n        require(sellfeeRate.highPROOFFeeRate != 0, \"already reduced\");\r\n        buyfeeRate.highTotalFeeRate =\r\n            buyfeeRate.highTotalFeeRate +\r\n            0 -\r\n            buyfeeRate.highPROOFFeeRate;\r\n        buyfeeRate.highPROOFFeeRate = 0;\r\n        buyfeeRate.normalTotalFeeRate =\r\n            buyfeeRate.normalTotalFeeRate +\r\n            0 -\r\n            buyfeeRate.normalPROOFFeeRate;\r\n        buyfeeRate.normalPROOFFeeRate = 0;\r\n\r\n        sellfeeRate.highTotalFeeRate =\r\n            sellfeeRate.highTotalFeeRate +\r\n            0 -\r\n            sellfeeRate.highPROOFFeeRate;\r\n        sellfeeRate.highPROOFFeeRate = 0;\r\n        sellfeeRate.normalTotalFeeRate =\r\n            sellfeeRate.normalTotalFeeRate +\r\n            0 -\r\n            sellfeeRate.normalPROOFFeeRate;\r\n        sellfeeRate.normalPROOFFeeRate = 0;\r\n    }\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function delBot(address _notbot) external override {\r\n        address sender = _msgSender();\r\n        require(\r\n            sender == proofAdmin || sender == owner(),\r\n            \"Ownable: caller doesn't have permission\"\r\n        );\r\n        bots[_notbot] = false;\r\n    }\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function setLaunchBegin() external override onlyOwner {\r\n        require(launchTime == 0, \"already launched\");\r\n        launchTime = block.timestamp;\r\n    }\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function addWhitelists(\r\n        address[] memory _accounts,\r\n        bool _add\r\n    ) external override onlyOwner {\r\n        uint256 length = _accounts.length;\r\n        require(length > 0, \"invalid accounts length\");\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            whitelists[_accounts[i]] = _add;\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function excludeWalletsFromMaxTransfer(\r\n        address[] memory _accounts,\r\n        bool _add\r\n    ) external override onlyOwner {\r\n        uint256 length = _accounts.length;\r\n        require(length > 0, \"invalid length array\");\r\n        for (uint256 i = 0; i < length; i++) {\r\n            excludedFromMaxTransfer[_accounts[i]] = _add;\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function excludeWalletsFromMaxWallets(\r\n        address[] memory _accounts,\r\n        bool _add\r\n    ) external override onlyOwner {\r\n        uint256 length = _accounts.length;\r\n        require(length > 0, \"invalid length array\");\r\n        for (uint256 i = 0; i < length; i++) {\r\n            excludedFromMaxWallet[_accounts[i]] = _add;\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function excludeWalletsFromFees(\r\n        address[] memory _accounts,\r\n        bool _add\r\n    ) external override onlyOwner {\r\n        uint256 length = _accounts.length;\r\n        require(length > 0, \"invalid length array\");\r\n        for (uint256 i = 0; i < length; i++) {\r\n            excludedFromFees[_accounts[i]] = _add;\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function setMaxTransferAmount(\r\n        uint256 newLimit\r\n    ) external override onlyOwner {\r\n        require(newLimit >= (_totalSupply * 5) / 1000, \"Min 0.5% limit\");\r\n        maxTransferAmount = newLimit;\r\n    }\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function setMaxWalletAmount(uint256 newLimit) external override onlyOwner {\r\n        require(newLimit >= (_totalSupply * 10) / 1000, \"Min 1% limit\");\r\n        maxWalletAmount = newLimit;\r\n    }\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function setMarketingTaxWallet(\r\n        address _marketingTaxWallet\r\n    ) external override onlyOwner {\r\n        require(\r\n            _marketingTaxWallet != address(0),\r\n            \"invalid marketingTaxWallet address\"\r\n        );\r\n        marketingTaxRecv = _marketingTaxWallet;\r\n    }\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function reducePROOFFeeRate() external override onlyOwner {\r\n        require(\r\n            block.timestamp > launchTime + buyfeeRate.proofFeeDuration,\r\n            \"You must wait 72 hrs\"\r\n        );\r\n        buyfeeRate.highTotalFeeRate =\r\n            buyfeeRate.highTotalFeeRate +\r\n            10 -\r\n            buyfeeRate.highPROOFFeeRate;\r\n        buyfeeRate.highPROOFFeeRate = 10;\r\n        buyfeeRate.normalTotalFeeRate =\r\n            buyfeeRate.normalTotalFeeRate +\r\n            10 -\r\n            buyfeeRate.normalPROOFFeeRate;\r\n        buyfeeRate.normalPROOFFeeRate = 10;\r\n        sellfeeRate.highTotalFeeRate =\r\n            sellfeeRate.highTotalFeeRate +\r\n            10 -\r\n            sellfeeRate.highPROOFFeeRate;\r\n        sellfeeRate.highPROOFFeeRate = 10;\r\n        sellfeeRate.normalTotalFeeRate =\r\n            sellfeeRate.normalTotalFeeRate +\r\n            10 -\r\n            sellfeeRate.normalPROOFFeeRate;\r\n        sellfeeRate.normalPROOFFeeRate = 10;\r\n    }\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function setMarketingFeeRate(\r\n        uint16 _marketingBuyFeeRate,\r\n        uint16 _marketingSellFeeRate\r\n    ) external override onlyOwner {\r\n        uint16 maxRateSet = 100;\r\n        require(\r\n            _marketingBuyFeeRate <= maxRateSet &&\r\n                _marketingSellFeeRate <= maxRateSet,\r\n            \"Max Rate exceeded, please lower value\"\r\n        );\r\n            buyfeeRate.highTotalFeeRate =\r\n                buyfeeRate.highTotalFeeRate +\r\n                _marketingBuyFeeRate -\r\n                buyfeeRate.marketingFeeRate;\r\n            buyfeeRate.normalTotalFeeRate =\r\n                buyfeeRate.normalTotalFeeRate +\r\n                _marketingBuyFeeRate -\r\n                buyfeeRate.marketingFeeRate;\r\n        buyfeeRate.marketingFeeRate = _marketingBuyFeeRate;\r\n            sellfeeRate.highTotalFeeRate =\r\n                sellfeeRate.highTotalFeeRate +\r\n                _marketingSellFeeRate -\r\n                sellfeeRate.marketingFeeRate;\r\n            sellfeeRate.normalTotalFeeRate =\r\n                sellfeeRate.normalTotalFeeRate +\r\n                _marketingSellFeeRate -\r\n                sellfeeRate.marketingFeeRate;\r\n        sellfeeRate.marketingFeeRate = _marketingSellFeeRate;\r\n    }\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function setLiquidityFeeRate(\r\n        uint16 _liquidityBuyFeeRate,\r\n        uint16 _liquiditySellFeeRate\r\n    ) external override onlyOwner {\r\n        uint16 maxRateSet = 100;\r\n        require(\r\n            _liquidityBuyFeeRate <= maxRateSet &&\r\n                _liquiditySellFeeRate <= maxRateSet,\r\n            \"Max Rate exceeded, please lower value\"\r\n        );\r\n            buyfeeRate.highTotalFeeRate =\r\n                buyfeeRate.highTotalFeeRate +\r\n                _liquidityBuyFeeRate -\r\n                buyfeeRate.liquidityFeeRate;\r\n            buyfeeRate.normalTotalFeeRate =\r\n                buyfeeRate.normalTotalFeeRate +\r\n                _liquidityBuyFeeRate -\r\n                buyfeeRate.liquidityFeeRate;\r\n        buyfeeRate.liquidityFeeRate = _liquidityBuyFeeRate;\r\n            sellfeeRate.highTotalFeeRate =\r\n                sellfeeRate.highTotalFeeRate +\r\n                _liquiditySellFeeRate -\r\n                sellfeeRate.liquidityFeeRate;\r\n            sellfeeRate.normalTotalFeeRate =\r\n                sellfeeRate.normalTotalFeeRate +\r\n                _liquiditySellFeeRate -\r\n                sellfeeRate.liquidityFeeRate;\r\n        sellfeeRate.liquidityFeeRate = _liquiditySellFeeRate;\r\n    }\r\n\r\n    /// @inheritdoc IFX1SportsToken\r\n    function setSwapThreshold(\r\n        uint256 _swapThreshold\r\n    ) external override onlyOwner {\r\n        require(_swapThreshold > 0, \"invalid swapThreshold\");\r\n        swapThreshold = _swapThreshold;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function _transfer(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) internal {\r\n        require(_sender != address(0), \"transfer from zero address\");\r\n        require(!bots[_sender] || !bots[_recipient], \"no bots allowed\");\r\n        require(_recipient != address(0), \"transfer to zero address\");\r\n        require(_amount > 0, \"zero amount\");\r\n        require(_balances[_sender] >= _amount, \"not enough amount to transfer\");\r\n        require(_sender == owner() || launchTime != 0, \"not launched yet\");\r\n        if (block.timestamp < launchTime + whitelistPeriod) {\r\n            require(whitelists[_recipient], \"only whitelist\");\r\n        }\r\n        require(\r\n            excludedFromMaxTransfer[_sender] ||\r\n                _amount <= maxTransferAmount + (10 * 10 ** _decimals),\r\n            \"exceeds to maxTransferAmount\"\r\n        );\r\n        require(\r\n            excludedFromMaxWallet[_recipient] ||\r\n                _balances[_recipient] + _amount <=\r\n                maxWalletAmount + (10 * 10 ** _decimals),\r\n            \"exceeds to maxWalletAmount\"\r\n        );\r\n\r\n        if (\r\n            inSwapLiquidity ||\r\n            excludedFromFees[_recipient] ||\r\n            excludedFromFees[_sender]\r\n        ) {\r\n            _basicTransfer(_sender, _recipient, _amount);\r\n            emit Transfer(_sender, _recipient, _amount);\r\n            return;\r\n        }\r\n\r\n        if (_sender == pair) {\r\n            // buy\r\n            _taxonBuyTransfer(_sender, _recipient, _amount);\r\n        } else {\r\n            _swapBack();\r\n            if (_recipient == pair) {\r\n                // sell\r\n                _taxonSellTransfer(_sender, _recipient, _amount);\r\n            } else {\r\n                _basicTransfer(_sender, _recipient, _amount);\r\n            }\r\n        }\r\n\r\n        emit Transfer(_sender, _recipient, _amount);\r\n    }\r\n\r\n    function _approve(\r\n        address _owner,\r\n        address _spender,\r\n        uint256 _amount\r\n    ) private {\r\n        require(_owner != address(0), \"Approve from zero\");\r\n        require(_spender != address(0), \"Approve to zero\");\r\n        _allowances[_owner][_spender] = _amount;\r\n        emit Approval(_owner, _spender, _amount);\r\n    }\r\n\r\n    function _swapBack() internal {\r\n        uint256 accTotalAmount = accPROOFAmount +\r\n            accLiquidityAmount +\r\n            accMarketingAmount;\r\n        if (accTotalAmount <= swapThreshold) {\r\n            return;\r\n        }\r\n        inSwapLiquidity = true;\r\n        uint256 swapAmountForLiquidity = accLiquidityAmount / 2;\r\n        uint256 swapAmount = accTotalAmount - swapAmountForLiquidity;\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = dexRouter.WETH();\r\n        _approve(address(this), address(dexRouter), swapAmount);\r\n        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            swapAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        uint256 swappedETHAmount = address(this).balance;\r\n        require(swappedETHAmount > 0, \"too small token for swapBack\");\r\n        uint256 ethForLiquidity = (swappedETHAmount * swapAmountForLiquidity) /\r\n            swapAmount;\r\n\r\n        if (ethForLiquidity > 0) {\r\n            uint256 amountForLiquidity = accLiquidityAmount -\r\n                swapAmountForLiquidity;\r\n            _approve(address(this), address(dexRouter), amountForLiquidity);\r\n            dexRouter.addLiquidityETH{value: ethForLiquidity}(\r\n                address(this),\r\n                amountForLiquidity,\r\n                0,\r\n                0,\r\n                0x000000000000000000000000000000000000dEaD,\r\n                block.timestamp\r\n            );\r\n            swappedETHAmount -= ethForLiquidity;\r\n        }\r\n\r\n        uint256 ethForPROOF = (swappedETHAmount * accPROOFAmount) / swapAmount;\r\n        uint256 ethForPROOFRevenue = ethForPROOF / 2;\r\n        uint256 ethForPROOFRewards = ethForPROOF - ethForPROOFRevenue;\r\n        uint256 ethForMarketing = swappedETHAmount - ethForPROOF;\r\n        _transferETH(proofRevenue, ethForPROOFRevenue);\r\n        _transferETH(proofRewards, ethForPROOFRewards);\r\n        _transferETH(marketingTaxRecv, ethForMarketing);\r\n\r\n        accLiquidityAmount = 0;\r\n        accMarketingAmount = 0;\r\n        accPROOFAmount = 0;\r\n        inSwapLiquidity = false;\r\n    }\r\n\r\n    function _taxonSellTransfer(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) internal {\r\n        (\r\n            uint16 totalFeeRate,\r\n            uint16 proofFeeRate,\r\n            ,\r\n            uint16 liquidityFeeRate\r\n        ) = _getSellFeeRate();\r\n\r\n        uint256 feeAmount = (_amount * totalFeeRate) / FIXED_POINT;\r\n        uint256 proofFeeAmount = (_amount * proofFeeRate) / FIXED_POINT;\r\n        uint256 liquidityFeeAmount = (_amount * liquidityFeeRate) / FIXED_POINT;\r\n        uint256 marketingFeeAmount = feeAmount -\r\n            proofFeeAmount -\r\n            liquidityFeeAmount;\r\n        uint256 recvAmount = _amount - feeAmount;\r\n\r\n        _balances[_sender] -= _amount;\r\n        _balances[_recipient] += recvAmount;\r\n        _balances[address(this)] += feeAmount;\r\n        accPROOFAmount += proofFeeAmount;\r\n        accLiquidityAmount += liquidityFeeAmount;\r\n        accMarketingAmount += marketingFeeAmount;\r\n    }\r\n\r\n    function _taxonBuyTransfer(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) internal {\r\n        (\r\n            uint16 totalFeeRate,\r\n            uint16 proofFeeRate,\r\n            ,\r\n            uint16 liquidityFeeRate\r\n        ) = _getBuyFeeRate();\r\n\r\n        uint256 feeAmount = (_amount * totalFeeRate) / FIXED_POINT;\r\n        uint256 proofFeeAmount = (_amount * proofFeeRate) / FIXED_POINT;\r\n        uint256 liquidityFeeAmount = (_amount * liquidityFeeRate) / FIXED_POINT;\r\n        uint256 marketingFeeAmount = feeAmount -\r\n            proofFeeAmount -\r\n            liquidityFeeAmount;\r\n        uint256 recvAmount = _amount - feeAmount;\r\n\r\n        _balances[_sender] -= _amount;\r\n        _balances[_recipient] += recvAmount;\r\n        _balances[address(this)] += feeAmount;\r\n        accPROOFAmount += proofFeeAmount;\r\n        accLiquidityAmount += liquidityFeeAmount;\r\n        accMarketingAmount += marketingFeeAmount;\r\n    }\r\n\r\n    function _basicTransfer(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) internal {\r\n        _balances[_sender] -= _amount;\r\n        _balances[_recipient] += _amount;\r\n    }\r\n\r\n    function _getSellFeeRate()\r\n        internal\r\n        view\r\n        returns (\r\n            uint16 _totalFeeRate,\r\n            uint16 _proofFeeRate,\r\n            uint16 _marketingFeeRate,\r\n            uint16 _liquidityFeeRate\r\n        )\r\n    {\r\n        if (block.timestamp < launchTime + sellfeeRate.proofFeeDuration) {\r\n            return (\r\n                sellfeeRate.highTotalFeeRate,\r\n                sellfeeRate.highPROOFFeeRate,\r\n                sellfeeRate.marketingFeeRate,\r\n                sellfeeRate.liquidityFeeRate\r\n            );\r\n        } else {\r\n            return (\r\n                sellfeeRate.normalTotalFeeRate,\r\n                sellfeeRate.normalPROOFFeeRate,\r\n                sellfeeRate.marketingFeeRate,\r\n                sellfeeRate.liquidityFeeRate\r\n            );\r\n        }\r\n    }\r\n\r\n    function _getBuyFeeRate()\r\n        internal\r\n        view\r\n        returns (\r\n            uint16 _totalFeeRate,\r\n            uint16 _proofFeeRate,\r\n            uint16 _marketingFeeRate,\r\n            uint16 _liquidityFeeRate\r\n        )\r\n    {\r\n        if (block.timestamp < launchTime + buyfeeRate.proofFeeDuration) {\r\n            return (\r\n                buyfeeRate.highTotalFeeRate,\r\n                buyfeeRate.highPROOFFeeRate,\r\n                buyfeeRate.marketingFeeRate,\r\n                buyfeeRate.liquidityFeeRate\r\n            );\r\n        } else {\r\n            return (\r\n                buyfeeRate.normalTotalFeeRate,\r\n                buyfeeRate.normalPROOFFeeRate,\r\n                buyfeeRate.marketingFeeRate,\r\n                buyfeeRate.liquidityFeeRate\r\n            );\r\n        }\r\n    }\r\n\r\n    function _transferETH(address _recipient, uint256 _amount) internal {\r\n        if (_amount == 0) return;\r\n        (bool sent, ) = _recipient.call{value: _amount}(\"\");\r\n        require(sent, \"sending ETH failed\");\r\n    }\r\n}\r\n"
18     },
19     "contracts/interfaces/IFX1SportsToken.sol": {
20       "content": "//SPDX-License-Identifier: None\r\n\r\npragma solidity ^0.8.19;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/// @title FX1 Sports Token\r\n/// @title https://fx1.io/\r\n/// @title https://t.me/fx1_sports_portal\r\n/// @author https://PROOFplatform.io\r\n/// @author https://5thWeb.io\r\n\r\ninterface IFX1SportsToken is IERC20 {\r\n    struct Param {\r\n        address proofRevenue;\r\n        address proofRewards;\r\n        address proofAdmin;\r\n        address marketingTaxRecv;\r\n        address dexRouter;\r\n        address teamAllocator_1;\r\n        address teamAllocator_2;\r\n        uint256 whitelistPeriod;\r\n        uint256 proofFeeDuration;\r\n        uint16 highPROOFFeeRate;\r\n        uint16 normalPROOFFeeRate;\r\n        uint16 marketingFeeRate;\r\n        uint16 liquidityFeeRate;\r\n        uint16 totalTeamAllocationRate;\r\n        uint16 teamAllocationRate_1;\r\n        uint16 teamAllocationRate_2;\r\n    }\r\n\r\n    struct BuyFeeRate {\r\n        uint256 proofFeeDuration;\r\n        uint16 highTotalFeeRate;\r\n        uint16 normalTotalFeeRate;\r\n        uint16 highPROOFFeeRate;\r\n        uint16 normalPROOFFeeRate;\r\n        uint16 marketingFeeRate;\r\n        uint16 liquidityFeeRate;\r\n    }\r\n\r\n    struct SellFeeRate {\r\n        uint256 proofFeeDuration;\r\n        uint16 highTotalFeeRate;\r\n        uint16 normalTotalFeeRate;\r\n        uint16 highPROOFFeeRate;\r\n        uint16 normalPROOFFeeRate;\r\n        uint16 marketingFeeRate;\r\n        uint16 liquidityFeeRate;\r\n    }\r\n\r\n    /// @notice Cancels Token from Fees and transfers ownership to PROOF.\r\n    /// @dev Only PROOF Admin can call this function.\r\n    function cancelToken() external;\r\n\r\n    /// @notice Remove PROOFFeeRate.\r\n    /// @dev Only PROOF Admin can call this function.\r\n    function formatPROOFFee() external;\r\n\r\n    /// @notice Locks trading until called. Cannont be called twice.\r\n    /// @dev Only owner can call this function.\r\n    function setLaunchBegin()external;\r\n\r\n    /// @notice Set proofAdmin wallet address.\r\n    /// @dev Only PROOF Admin can call this function.\r\n    /// @param newAdmin The address of proofAdmin wallet.\r\n    function updatePROOFAdmin(address newAdmin) external;\r\n\r\n    /// @notice Add bots.\r\n    /// @dev Only PROOF Admin can call this function.\r\n    /// @param bots_ The address of bot.\r\n    function setBots(address[] memory bots_) external;\r\n\r\n    /// @notice Remove bots.\r\n    /// @dev Only PROOF Admin and Owner can call this function.\r\n    /// @param notbot The address to be removed from bots.\r\n    function delBot(address notbot) external;\r\n\r\n    /// @notice Add/Remove whitelists.\r\n    /// @dev Only owner can call this function.\r\n    /// @param _accounts The address of whitelists.\r\n    /// @param _add True/False = Add/Remove\r\n    function addWhitelists(address[] memory _accounts, bool _add) external;\r\n\r\n    /// @notice Add/Remove wallets to excludedMaxTransfer.\r\n    /// @dev Only owner can call this function.\r\n    /// @param _accounts The address of accounts.\r\n    /// @param _add True/False = Add/Remove\r\n    function excludeWalletsFromMaxTransfer(\r\n        address[] memory _accounts,\r\n        bool _add\r\n    ) external;\r\n\r\n    /// @notice Add/Remove wallets to excludedMaxWallet.\r\n    /// @dev Only owner can call this function.\r\n    /// @param _accounts The address of accounts.\r\n    /// @param _add True/False = Add/Remove\r\n    function excludeWalletsFromMaxWallets(\r\n        address[] memory _accounts,\r\n        bool _add\r\n    ) external;\r\n\r\n    /// @notice Add/Remove wallets to excludedFromFees.\r\n    /// @dev Only owner can call this function.\r\n    /// @param _accounts The address of accounts.\r\n    /// @param _add True/False = Add/Remove\r\n    function excludeWalletsFromFees(\r\n        address[] memory _accounts,\r\n        bool _add\r\n    ) external;\r\n\r\n    /// @notice Set maxTransferAmount.\r\n    /// @dev Only owner can call this function.\r\n    /// @param _maxTransferAmount New maxTransferAmount.\r\n    function setMaxTransferAmount(uint256 _maxTransferAmount) external;\r\n\r\n    /// @notice Set maxWalletAmount.\r\n    /// @dev Only owner can call this function.\r\n    /// @param _maxWalletAmount New maxWalletAmount.\r\n    function setMaxWalletAmount(uint256 _maxWalletAmount) external;\r\n\r\n    /// @notice Set marketingTaxRecipient wallet address.\r\n    /// @dev Only owner can call this function.\r\n    /// @param _marketingTaxWallet The address of marketingTaxRecipient wallet.\r\n    function setMarketingTaxWallet(address _marketingTaxWallet) external;\r\n\r\n    /// @notice Reduce PROOFFeeRate.\r\n    /// @dev Only owner can call this function.\r\n    function reducePROOFFeeRate() external;\r\n\r\n    /// @notice Set MarketingFeeRate.\r\n    /// @dev Only owner can call this function.\r\n    /// @dev Max Rate of 100(10%) 10 = 1%\r\n    /// @param _marketingBuyFeeRate New MarketingBuyFeeRate.\r\n    /// @param _marketingSellFeeRate New MarketingSellFeeRate.\r\n    function setMarketingFeeRate(\r\n        uint16 _marketingBuyFeeRate, \r\n        uint16 _marketingSellFeeRate\r\n    ) external;\r\n\r\n    /// @notice Set LiquidityFeeRate.\r\n    /// @dev Only owner can call this function.\r\n    /// @dev Max Rate of 100(10%) 10 = 1%\r\n    /// @param _liquidityBuyFeeRate New liquiditySellFeeRate.\r\n    /// @param _liquiditySellFeeRate New liquidityBuyFeeRate.\r\n    function setLiquidityFeeRate(\r\n        uint16 _liquidityBuyFeeRate,\r\n        uint16 _liquiditySellFeeRate\r\n    ) external;\r\n\r\n    /// @notice Set swapThreshold.\r\n    /// @dev Only owner can call this function.\r\n    /// @param _swapThreshold New swapThreshold amount.\r\n    function setSwapThreshold(uint256 _swapThreshold) external;\r\n}\r\n"
21     },
22     "contracts/interfaces/IUniswapV2Factory.sol": {
23       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        address pair,\r\n        uint\r\n    );\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external view returns (address pair);\r\n\r\n    function allPairs(uint) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n}\r\n"
24     },
25     "contracts/interfaces/IUniswapV2Router02.sol": {
26       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.19;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    function quote(\r\n        uint amountA,\r\n        uint reserveA,\r\n        uint reserveB\r\n    ) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(\r\n        uint amountIn,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(\r\n        uint amountOut,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(\r\n        uint amountOut,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n"
27     }
28   },
29   "settings": {
30     "optimizer": {
31       "enabled": true,
32       "runs": 2000
33     },
34     "outputSelection": {
35       "*": {
36         "*": [
37           "evm.bytecode",
38           "evm.deployedBytecode",
39           "devdoc",
40           "userdoc",
41           "metadata",
42           "abi"
43         ]
44       }
45     },
46     "libraries": {}
47   }
48 }}