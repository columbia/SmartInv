1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/governance/KyberGovernance.sol": {
5       "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {PermissionAdmin} from '@kyber.network/utils-sc/contracts/PermissionAdmin.sol';\nimport {IKyberGovernance} from '../interfaces/governance/IKyberGovernance.sol';\nimport {IExecutorWithTimelock} from '../interfaces/governance/IExecutorWithTimelock.sol';\nimport {IVotingPowerStrategy} from '../interfaces/governance/IVotingPowerStrategy.sol';\nimport {IProposalValidator} from '../interfaces/governance/IProposalValidator.sol';\nimport {getChainId} from '../misc/Helpers.sol';\n\n/**\n * @title Kyber Governance contract for Kyber 3.0\n * - Create a Proposal\n * - Cancel a Proposal\n * - Queue a Proposal\n * - Execute a Proposal\n * - Submit Vote to a Proposal\n * Proposal States : Pending => Active => Succeeded(/Failed/Finalized)\n *                   => Queued => Executed(/Expired)\n *                   The transition to \"Canceled\" can appear in multiple states\n **/\ncontract KyberGovernance is IKyberGovernance, PermissionAdmin {\n  using SafeMath for uint256;\n\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\n    'EIP712Domain(string name,uint256 chainId,address verifyingContract)'\n  );\n  bytes32 public constant VOTE_EMITTED_TYPEHASH = keccak256(\n    'VoteEmitted(uint256 id,uint256 optionBitMask)'\n  );\n  string public constant NAME = 'Kyber Governance';\n\n  address private _daoOperator;\n  uint256 private _proposalsCount;\n  mapping(uint256 => Proposal) private _proposals;\n  mapping(address => bool) private _authorizedExecutors;\n  mapping(address => bool) private _authorizedVotingPowerStrategies;\n\n  constructor(\n    address admin,\n    address daoOperator,\n    address[] memory executors,\n    address[] memory votingPowerStrategies\n  ) PermissionAdmin(admin) {\n    require(daoOperator != address(0), 'invalid dao operator');\n    _daoOperator = daoOperator;\n\n    _authorizeExecutors(executors);\n    _authorizeVotingPowerStrategies(votingPowerStrategies);\n  }\n\n  /**\n   * @dev Creates a Binary Proposal (needs to be validated by the Proposal Validator)\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\n   * @param strategy voting power strategy of the proposal\n   * @param executionParams data for execution, includes\n   *   targets list of contracts called by proposal's associated transactions\n   *   weiValues list of value in wei for each proposal's associated transaction\n   *   signatures list of function signatures (can be empty) to be used when created the callData\n   *   calldatas list of calldatas: if associated signature empty,\n   *        calldata ready, else calldata is arguments\n   *   withDelegatecalls boolean, true = transaction delegatecalls the taget,\n   *         else calls the target\n   * @param startTime start timestamp to allow vote\n   * @param endTime end timestamp of the proposal\n   * @param link link to the proposal description\n   **/\n  function createBinaryProposal(\n    IExecutorWithTimelock executor,\n    IVotingPowerStrategy strategy,\n    BinaryProposalParams memory executionParams,\n    uint256 startTime,\n    uint256 endTime,\n    string memory link\n  ) external override returns (uint256 proposalId) {\n    require(executionParams.targets.length != 0, 'create binary invalid empty targets');\n    require(\n      executionParams.targets.length == executionParams.weiValues.length &&\n        executionParams.targets.length == executionParams.signatures.length &&\n        executionParams.targets.length == executionParams.calldatas.length &&\n        executionParams.targets.length == executionParams.withDelegatecalls.length,\n      'create binary inconsistent params length'\n    );\n\n    require(isExecutorAuthorized(address(executor)), 'create binary executor not authorized');\n    require(\n      isVotingPowerStrategyAuthorized(address(strategy)),\n      'create binary strategy not authorized'\n    );\n\n    proposalId = _proposalsCount;\n    require(\n      IProposalValidator(address(executor)).validateBinaryProposalCreation(\n        strategy,\n        msg.sender,\n        startTime,\n        endTime,\n        _daoOperator\n      ),\n      'validate proposal creation invalid'\n    );\n\n    ProposalWithoutVote storage newProposalData = _proposals[proposalId].proposalData;\n    newProposalData.id = proposalId;\n    newProposalData.proposalType = ProposalType.Binary;\n    newProposalData.creator = msg.sender;\n    newProposalData.executor = executor;\n    newProposalData.targets = executionParams.targets;\n    newProposalData.weiValues = executionParams.weiValues;\n    newProposalData.signatures = executionParams.signatures;\n    newProposalData.calldatas = executionParams.calldatas;\n    newProposalData.withDelegatecalls = executionParams.withDelegatecalls;\n    newProposalData.startTime = startTime;\n    newProposalData.endTime = endTime;\n    newProposalData.strategy = strategy;\n    newProposalData.link = link;\n\n    // only 2 options, YES and NO\n    newProposalData.options.push('YES');\n    newProposalData.options.push('NO');\n    newProposalData.voteCounts.push(0);\n    newProposalData.voteCounts.push(0);\n    // use max voting power to finalise the proposal\n    newProposalData.maxVotingPower = strategy.getMaxVotingPower();\n\n    _proposalsCount++;\n    // call strategy to record data if needed\n    strategy.handleProposalCreation(proposalId, startTime, endTime);\n\n    emit BinaryProposalCreated(\n      proposalId,\n      msg.sender,\n      executor,\n      strategy,\n      executionParams.targets,\n      executionParams.weiValues,\n      executionParams.signatures,\n      executionParams.calldatas,\n      executionParams.withDelegatecalls,\n      startTime,\n      endTime,\n      link,\n      newProposalData.maxVotingPower\n    );\n  }\n\n  /**\n   * @dev Creates a Generic Proposal (needs to be validated by the Proposal Validator)\n   *    It only gets the winning option without any executions\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\n   * @param strategy voting power strategy of the proposal\n   * @param options list of options to vote for\n   * @param startTime start timestamp to allow vote\n   * @param endTime end timestamp of the proposal\n   * @param link link to the proposal description\n   **/\n  function createGenericProposal(\n    IExecutorWithTimelock executor,\n    IVotingPowerStrategy strategy,\n    string[] memory options,\n    uint256 startTime,\n    uint256 endTime,\n    string memory link\n  )\n    external override returns (uint256 proposalId)\n  {\n    require(\n      isExecutorAuthorized(address(executor)),\n      'create generic executor not authorized'\n    );\n    require(\n      isVotingPowerStrategyAuthorized(address(strategy)),\n      'create generic strategy not authorized'\n    );\n    proposalId = _proposalsCount;\n    require(\n      IProposalValidator(address(executor)).validateGenericProposalCreation(\n        strategy,\n        msg.sender,\n        startTime,\n        endTime,\n        options,\n        _daoOperator\n      ),\n      'validate proposal creation invalid'\n    );\n    Proposal storage newProposal = _proposals[proposalId];\n    ProposalWithoutVote storage newProposalData = newProposal.proposalData;\n    newProposalData.id = proposalId;\n    newProposalData.proposalType = ProposalType.Generic;\n    newProposalData.creator = msg.sender;\n    newProposalData.executor = executor;\n    newProposalData.startTime = startTime;\n    newProposalData.endTime = endTime;\n    newProposalData.strategy = strategy;\n    newProposalData.link = link;\n    newProposalData.options = options;\n    newProposalData.voteCounts = new uint256[](options.length);\n    // use max voting power to finalise the proposal\n    newProposalData.maxVotingPower = strategy.getMaxVotingPower();\n\n    _proposalsCount++;\n    // call strategy to record data if needed\n    strategy.handleProposalCreation(proposalId, startTime, endTime);\n\n    emit GenericProposalCreated(\n      proposalId,\n      msg.sender,\n      executor,\n      strategy,\n      options,\n      startTime,\n      endTime,\n      link,\n      newProposalData.maxVotingPower\n    );\n  }\n\n  /**\n   * @dev Cancels a Proposal.\n   * - Callable by the _daoOperator with relaxed conditions,\n   *   or by anybody if the conditions of cancellation on the executor are fulfilled\n   * @param proposalId id of the proposal\n   **/\n  function cancel(uint256 proposalId) external override {\n    require(proposalId < _proposalsCount, 'invalid proposal id');\n    ProposalState state = getProposalState(proposalId);\n    require(\n      state != ProposalState.Executed &&\n        state != ProposalState.Canceled &&\n        state != ProposalState.Expired &&\n        state != ProposalState.Finalized,\n      'invalid state to cancel'\n    );\n\n    ProposalWithoutVote storage proposal = _proposals[proposalId].proposalData;\n    require(\n      msg.sender == _daoOperator ||\n        IProposalValidator(address(proposal.executor)).validateProposalCancellation(\n          IKyberGovernance(this),\n          proposalId,\n          proposal.creator\n        ),\n      'validate proposal cancellation failed'\n    );\n    proposal.canceled = true;\n    if (proposal.proposalType == ProposalType.Binary) {\n      for (uint256 i = 0; i < proposal.targets.length; i++) {\n        proposal.executor.cancelTransaction(\n          proposal.targets[i],\n          proposal.weiValues[i],\n          proposal.signatures[i],\n          proposal.calldatas[i],\n          proposal.executionTime,\n          proposal.withDelegatecalls[i]\n        );\n      }\n    }\n    // notify voting power strategy about the cancellation\n    proposal.strategy.handleProposalCancellation(proposalId);\n\n    emit ProposalCanceled(proposalId);\n  }\n\n  /**\n   * @dev Queue the proposal (If Proposal Succeeded), only for Binary proposals\n   * @param proposalId id of the proposal to queue\n   **/\n  function queue(uint256 proposalId) external override {\n    require(proposalId < _proposalsCount, 'invalid proposal id');\n    require(\n      getProposalState(proposalId) == ProposalState.Succeeded,\n      'invalid state to queue'\n    );\n    ProposalWithoutVote storage proposal = _proposals[proposalId].proposalData;\n    // generic proposal does not have Succeeded state\n    assert(proposal.proposalType == ProposalType.Binary);\n    uint256 executionTime = block.timestamp.add(proposal.executor.getDelay());\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      _queueOrRevert(\n        proposal.executor,\n        proposal.targets[i],\n        proposal.weiValues[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        executionTime,\n        proposal.withDelegatecalls[i]\n      );\n    }\n    proposal.executionTime = executionTime;\n\n    emit ProposalQueued(proposalId, executionTime, msg.sender);\n  }\n\n  /**\n   * @dev Execute the proposal (If Proposal Queued), only for Binary proposals\n   * @param proposalId id of the proposal to execute\n   **/\n  function execute(uint256 proposalId) external override payable {\n    require(proposalId < _proposalsCount, 'invalid proposal id');\n    require(getProposalState(proposalId) == ProposalState.Queued, 'only queued proposals');\n    ProposalWithoutVote storage proposal = _proposals[proposalId].proposalData;\n    // generic proposal does not have Queued state\n    assert(proposal.proposalType == ProposalType.Binary);\n    proposal.executed = true;\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      proposal.executor.executeTransaction{value: proposal.weiValues[i]}(\n        proposal.targets[i],\n        proposal.weiValues[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.executionTime,\n        proposal.withDelegatecalls[i]\n      );\n    }\n    emit ProposalExecuted(proposalId, msg.sender);\n  }\n\n  /**\n   * @dev Function allowing msg.sender to vote for/against a proposal\n   * @param proposalId id of the proposal\n   * @param optionBitMask bitmask optionBitMask of voter\n   *  for Binary Proposal, optionBitMask should be either 1 or 2 (Accept/Reject)\n   *  for Generic Proposal, optionBitMask is the bitmask of voted options\n   **/\n  function submitVote(uint256 proposalId, uint256 optionBitMask) external override {\n    return _submitVote(msg.sender, proposalId, optionBitMask);\n  }\n\n  /**\n   * @dev Function to register the vote of user that has voted offchain via signature\n   * @param proposalId id of the proposal\n   * @param optionBitMask the bit mask of voted options\n   * @param v v part of the voter signature\n   * @param r r part of the voter signature\n   * @param s s part of the voter signature\n   **/\n  function submitVoteBySignature(\n    uint256 proposalId,\n    uint256 optionBitMask,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override {\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        '\\x19\\x01',\n        keccak256(\n          abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainId(), address(this))\n        ),\n        keccak256(abi.encode(VOTE_EMITTED_TYPEHASH, proposalId, optionBitMask))\n      )\n    );\n    address signer = ecrecover(digest, v, r, s);\n    require(signer != address(0), 'invalid signature');\n    return _submitVote(signer, proposalId, optionBitMask);\n  }\n\n  /**\n   * @dev Function to handle voting power changed for a voter\n   *  caller must be the voting power strategy of the proposal\n   * @param voter address that has changed the voting power\n   * @param newVotingPower new voting power of that address,\n   *   old voting power can be taken from records\n   * @param proposalIds list proposal ids that belongs to this voting power strategy\n   *   should update the voteCound of the active proposals in the list\n   **/\n  function handleVotingPowerChanged(\n    address voter,\n    uint256 newVotingPower,\n    uint256[] calldata proposalIds\n  ) external override {\n    uint224 safeNewVotingPower = _safeUint224(newVotingPower);\n    for (uint256 i = 0; i < proposalIds.length; i++) {\n      // only update for active proposals\n      if (getProposalState(proposalIds[i]) != ProposalState.Active) continue;\n      ProposalWithoutVote storage proposal = _proposals[proposalIds[i]].proposalData;\n      require(address(proposal.strategy) == msg.sender, 'invalid voting power strategy');\n      Vote memory vote = _proposals[proposalIds[i]].votes[voter];\n      if (vote.optionBitMask == 0) continue; // not voted yet\n      uint256 oldVotingPower = uint256(vote.votingPower);\n      // update totalVotes of the proposal\n      proposal.totalVotes = proposal.totalVotes.add(newVotingPower).sub(oldVotingPower);\n      for (uint256 j = 0; j < proposal.options.length; j++) {\n        if (vote.optionBitMask & (2**j) == 2**j) {\n          // update voteCounts for each voted option\n          proposal.voteCounts[j] = proposal.voteCounts[j].add(newVotingPower).sub(oldVotingPower);\n        }\n      }\n      // update voting power of the voter\n      _proposals[proposalIds[i]].votes[voter].votingPower = safeNewVotingPower;\n      emit VotingPowerChanged(\n        proposalIds[i],\n        voter,\n        vote.optionBitMask,\n        vote.votingPower,\n        safeNewVotingPower\n      );\n    }\n  }\n\n  /**\n  * @dev Transfer dao operator\n  * @param newDaoOperator new dao operator\n  **/\n  function transferDaoOperator(address newDaoOperator) external {\n    require(msg.sender == _daoOperator, 'only dao operator');\n    require(newDaoOperator != address(0), 'invalid dao operator');\n    _daoOperator = newDaoOperator;\n    emit DaoOperatorTransferred(newDaoOperator);\n  }\n\n  /**\n   * @dev Add new addresses to the list of authorized executors\n   * @param executors list of new addresses to be authorized executors\n   **/\n  function authorizeExecutors(address[] memory executors)\n    public override onlyAdmin\n  {\n    _authorizeExecutors(executors);\n  }\n\n  /**\n   * @dev Remove addresses to the list of authorized executors\n   * @param executors list of addresses to be removed as authorized executors\n   **/\n  function unauthorizeExecutors(address[] memory executors)\n    public override onlyAdmin\n  {\n    _unauthorizeExecutors(executors);\n  }\n\n  /**\n   * @dev Add new addresses to the list of authorized strategies\n   * @param strategies list of new addresses to be authorized strategies\n   **/\n  function authorizeVotingPowerStrategies(address[] memory strategies)\n    public override onlyAdmin\n  {\n    _authorizeVotingPowerStrategies(strategies);\n  }\n\n  /**\n   * @dev Remove addresses to the list of authorized strategies\n   * @param strategies list of addresses to be removed as authorized strategies\n   **/\n  function unauthorizeVotingPowerStrategies(address[] memory strategies)\n    public\n    override\n    onlyAdmin\n  {\n    _unauthorizedVotingPowerStrategies(strategies);\n  }\n\n  /**\n   * @dev Returns whether an address is an authorized executor\n   * @param executor address to evaluate as authorized executor\n   * @return true if authorized\n   **/\n  function isExecutorAuthorized(address executor) public override view returns (bool) {\n    return _authorizedExecutors[executor];\n  }\n\n  /**\n   * @dev Returns whether an address is an authorized strategy\n   * @param strategy address to evaluate as authorized strategy\n   * @return true if authorized\n   **/\n  function isVotingPowerStrategyAuthorized(address strategy) public override view returns (bool) {\n    return _authorizedVotingPowerStrategies[strategy];\n  }\n\n  /**\n   * @dev Getter the address of the daoOperator, that can mainly cancel proposals\n   * @return The address of the daoOperator\n   **/\n  function getDaoOperator() external override view returns (address) {\n    return _daoOperator;\n  }\n\n  /**\n   * @dev Getter of the proposal count (the current number of proposals ever created)\n   * @return the proposal count\n   **/\n  function getProposalsCount() external override view returns (uint256) {\n    return _proposalsCount;\n  }\n\n  /**\n   * @dev Getter of a proposal by id\n   * @param proposalId id of the proposal to get\n   * @return the proposal as ProposalWithoutVote memory object\n   **/\n  function getProposalById(uint256 proposalId)\n    external\n    override\n    view\n    returns (ProposalWithoutVote memory)\n  {\n    return _proposals[proposalId].proposalData;\n  }\n\n  /**\n   * @dev Getter of the vote data of a proposal by id\n   * including totalVotes, voteCounts and options\n   * @param proposalId id of the proposal\n   * @return (totalVotes, voteCounts, options)\n   **/\n  function getProposalVoteDataById(uint256 proposalId)\n    external\n    override\n    view\n    returns (\n      uint256,\n      uint256[] memory,\n      string[] memory\n    )\n  {\n    ProposalWithoutVote storage proposal = _proposals[proposalId].proposalData;\n    return (proposal.totalVotes, proposal.voteCounts, proposal.options);\n  }\n\n  /**\n   * @dev Getter of the Vote of a voter about a proposal\n   * Note: Vote is a struct: ({uint32 bitOptionMask, uint224 votingPower})\n   * @param proposalId id of the proposal\n   * @param voter address of the voter\n   * @return The associated Vote memory object\n   **/\n  function getVoteOnProposal(uint256 proposalId, address voter)\n    external\n    override\n    view\n    returns (Vote memory)\n  {\n    return _proposals[proposalId].votes[voter];\n  }\n\n  /**\n   * @dev Get the current state of a proposal\n   * @param proposalId id of the proposal\n   * @return The current state if the proposal\n   **/\n  function getProposalState(uint256 proposalId) public override view returns (ProposalState) {\n    require(proposalId < _proposalsCount, 'invalid proposal id');\n    ProposalWithoutVote storage proposal = _proposals[proposalId].proposalData;\n    if (proposal.canceled) {\n      return ProposalState.Canceled;\n    } else if (block.timestamp < proposal.startTime) {\n      return ProposalState.Pending;\n    } else if (block.timestamp <= proposal.endTime) {\n      return ProposalState.Active;\n    } else if (proposal.proposalType == ProposalType.Generic) {\n      return ProposalState.Finalized;\n    } else if (\n      !IProposalValidator(address(proposal.executor)).isBinaryProposalPassed(\n        IKyberGovernance(this),\n        proposalId\n      )\n    ) {\n      return ProposalState.Failed;\n    } else if (proposal.executionTime == 0) {\n      return ProposalState.Succeeded;\n    } else if (proposal.executed) {\n      return ProposalState.Executed;\n    } else if (proposal.executor.isProposalOverGracePeriod(this, proposalId)) {\n      return ProposalState.Expired;\n    } else {\n      return ProposalState.Queued;\n    }\n  }\n\n  function _queueOrRevert(\n    IExecutorWithTimelock executor,\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory callData,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) internal {\n    require(\n      !executor.isActionQueued(\n        keccak256(abi.encode(target, value, signature, callData, executionTime, withDelegatecall))\n      ),\n      'duplicated action'\n    );\n    executor.queueTransaction(target, value, signature, callData, executionTime, withDelegatecall);\n  }\n\n  function _submitVote(\n    address voter,\n    uint256 proposalId,\n    uint256 optionBitMask\n  ) internal {\n    require(proposalId < _proposalsCount, 'invalid proposal id');\n    require(getProposalState(proposalId) == ProposalState.Active, 'voting closed');\n    ProposalWithoutVote storage proposal = _proposals[proposalId].proposalData;\n    uint256 numOptions = proposal.options.length;\n    if (proposal.proposalType == ProposalType.Binary) {\n      // either Yes (1) or No (2)\n      require(optionBitMask == 1 || optionBitMask == 2, 'wrong vote for binary proposal');\n    } else {\n      require(\n        optionBitMask > 0 && optionBitMask < 2**numOptions,\n        'invalid options for generic proposal'\n      );\n    }\n\n    Vote memory vote = _proposals[proposalId].votes[voter];\n    uint256 votingPower = proposal.strategy.handleVote(voter, proposalId, optionBitMask);\n    if (vote.optionBitMask == 0) {\n      // first time vote, increase the totalVotes of the proposal\n      proposal.totalVotes = proposal.totalVotes.add(votingPower);\n    }\n    for (uint256 i = 0; i < proposal.options.length; i++) {\n      bool hasVoted = (vote.optionBitMask & (2**i)) == 2**i;\n      bool isVoting = (optionBitMask & (2**i)) == 2**i;\n      if (hasVoted && !isVoting) {\n        proposal.voteCounts[i] = proposal.voteCounts[i].sub(votingPower);\n      } else if (!hasVoted && isVoting) {\n        proposal.voteCounts[i] = proposal.voteCounts[i].add(votingPower);\n      }\n    }\n\n    _proposals[proposalId].votes[voter] = Vote({\n      optionBitMask: _safeUint32(optionBitMask),\n      votingPower: _safeUint224(votingPower)\n    });\n    emit VoteEmitted(proposalId, voter, _safeUint32(optionBitMask), _safeUint224(votingPower));\n  }\n\n  function _authorizeExecutors(address[] memory executors) internal {\n    for(uint256 i = 0; i < executors.length; i++) {\n      _authorizedExecutors[executors[i]] = true;\n      emit ExecutorAuthorized(executors[i]);\n    }\n  }\n\n  function _unauthorizeExecutors(address[] memory executors) internal {\n    for(uint256 i = 0; i < executors.length; i++) {\n      _authorizedExecutors[executors[i]] = false;\n      emit ExecutorUnauthorized(executors[i]);\n    }\n  }\n\n  function _authorizeVotingPowerStrategies(address[] memory strategies) internal {\n    for(uint256 i = 0; i < strategies.length; i++) {\n      _authorizedVotingPowerStrategies[strategies[i]] = true;\n      emit VotingPowerStrategyAuthorized(strategies[i]);\n    }\n  }\n\n  function _unauthorizedVotingPowerStrategies(address[] memory strategies) internal {\n    for(uint256 i = 0; i < strategies.length; i++) {\n      _authorizedVotingPowerStrategies[strategies[i]] = false;\n      emit VotingPowerStrategyUnauthorized(strategies[i]);\n    }\n  }\n\n  function _safeUint224(uint256 value) internal pure returns (uint224) {\n    require(value < 2**224 - 1, 'value is too big (uint224)');\n    return uint224(value);\n  }\n\n  function _safeUint32(uint256 value) internal pure returns (uint32) {\n    require(value < 2**32 - 1, 'value is too big (uint32)');\n    return uint32(value);\n  }\n}\n"
6     },
7     "@openzeppelin/contracts/math/SafeMath.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
9     },
10     "@kyber.network/utils-sc/contracts/PermissionAdmin.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\n\nabstract contract PermissionAdmin {\n    address public admin;\n    address public pendingAdmin;\n\n    event AdminClaimed(address newAdmin, address previousAdmin);\n\n    event TransferAdminPending(address pendingAdmin);\n\n    constructor(address _admin) {\n        require(_admin != address(0), \"admin 0\");\n        admin = _admin;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"only admin\");\n        _;\n    }\n\n    /**\n     * @dev Allows the current admin to set the pendingAdmin address.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdmin(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0), \"new admin 0\");\n        emit TransferAdminPending(newAdmin);\n        pendingAdmin = newAdmin;\n    }\n\n    /**\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0), \"admin 0\");\n        emit TransferAdminPending(newAdmin);\n        emit AdminClaimed(newAdmin, admin);\n        admin = newAdmin;\n    }\n\n    /**\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\n     */\n    function claimAdmin() public {\n        require(pendingAdmin == msg.sender, \"not pending\");\n        emit AdminClaimed(pendingAdmin, admin);\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n}\n"
12     },
13     "contracts/interfaces/governance/IKyberGovernance.sol": {
14       "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IExecutorWithTimelock} from './IExecutorWithTimelock.sol';\nimport {IVotingPowerStrategy} from './IVotingPowerStrategy.sol';\n\ninterface IKyberGovernance {\n  enum ProposalState {\n    Pending,\n    Canceled,\n    Active,\n    Failed,\n    Succeeded,\n    Queued,\n    Expired,\n    Executed,\n    Finalized\n  }\n  enum ProposalType {Generic, Binary}\n\n  /// For Binary proposal, optionBitMask is 0/1/2\n  /// For Generic proposal, optionBitMask is bitmask of voted options\n  struct Vote {\n    uint32 optionBitMask;\n    uint224 votingPower;\n  }\n\n  struct ProposalWithoutVote {\n    uint256 id;\n    ProposalType proposalType;\n    address creator;\n    IExecutorWithTimelock executor;\n    IVotingPowerStrategy strategy;\n    address[] targets;\n    uint256[] weiValues;\n    string[] signatures;\n    bytes[] calldatas;\n    bool[] withDelegatecalls;\n    string[] options;\n    uint256[] voteCounts;\n    uint256 totalVotes;\n    uint256 maxVotingPower;\n    uint256 startTime;\n    uint256 endTime;\n    uint256 executionTime;\n    string link;\n    bool executed;\n    bool canceled;\n  }\n\n  struct Proposal {\n    ProposalWithoutVote proposalData;\n    mapping(address => Vote) votes;\n  }\n\n  struct BinaryProposalParams {\n    address[] targets;\n    uint256[] weiValues;\n    string[] signatures;\n    bytes[] calldatas;\n    bool[] withDelegatecalls;\n  }\n\n  /**\n   * @dev emitted when a new binary proposal is created\n   * @param proposalId id of the binary proposal\n   * @param creator address of the creator\n   * @param executor ExecutorWithTimelock contract that will execute the proposal\n   * @param strategy votingPowerStrategy contract to calculate voting power\n   * @param targets list of contracts called by proposal's associated transactions\n   * @param weiValues list of value in wei for each propoposal's associated transaction\n   * @param signatures list of function signatures (can be empty) to be used\n   *     when created the callData\n   * @param calldatas list of calldatas: if associated signature empty,\n   *     calldata ready, else calldata is arguments\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget,\n   *    else calls the target\n   * @param startTime timestamp when vote starts\n   * @param endTime timestamp when vote ends\n   * @param link URL link of the proposal\n   * @param maxVotingPower max voting power for this proposal\n   **/\n  event BinaryProposalCreated(\n    uint256 proposalId,\n    address indexed creator,\n    IExecutorWithTimelock indexed executor,\n    IVotingPowerStrategy indexed strategy,\n    address[] targets,\n    uint256[] weiValues,\n    string[] signatures,\n    bytes[] calldatas,\n    bool[] withDelegatecalls,\n    uint256 startTime,\n    uint256 endTime,\n    string link,\n    uint256 maxVotingPower\n  );\n\n  /**\n   * @dev emitted when a new generic proposal is created\n   * @param proposalId id of the generic proposal\n   * @param creator address of the creator\n   * @param executor ExecutorWithTimelock contract that will execute the proposal\n   * @param strategy votingPowerStrategy contract to calculate voting power\n   * @param options list of proposal vote options\n   * @param startTime timestamp when vote starts\n   * @param endTime timestamp when vote ends\n   * @param link URL link of the proposal\n   * @param maxVotingPower max voting power for this proposal\n   **/\n  event GenericProposalCreated(\n    uint256 proposalId,\n    address indexed creator,\n    IExecutorWithTimelock indexed executor,\n    IVotingPowerStrategy indexed strategy,\n    string[] options,\n    uint256 startTime,\n    uint256 endTime,\n    string link,\n    uint256 maxVotingPower\n  );\n\n  /**\n   * @dev emitted when a proposal is canceled\n   * @param proposalId id of the proposal\n   **/\n  event ProposalCanceled(uint256 proposalId);\n\n  /**\n   * @dev emitted when a proposal is queued\n   * @param proposalId id of the proposal\n   * @param executionTime time when proposal underlying transactions can be executed\n   * @param initiatorQueueing address of the initiator of the queuing transaction\n   **/\n  event ProposalQueued(\n    uint256 indexed proposalId,\n    uint256 executionTime,\n    address indexed initiatorQueueing\n  );\n  /**\n   * @dev emitted when a proposal is executed\n   * @param proposalId id of the proposal\n   * @param initiatorExecution address of the initiator of the execution transaction\n   **/\n  event ProposalExecuted(uint256 proposalId, address indexed initiatorExecution);\n  /**\n   * @dev emitted when a vote is registered\n   * @param proposalId id of the proposal\n   * @param voter address of the voter\n   * @param voteOptions vote options selected by voter\n   * @param votingPower Power of the voter/vote\n   **/\n  event VoteEmitted(\n    uint256 indexed proposalId,\n    address indexed voter,\n    uint32 indexed voteOptions,\n    uint224 votingPower\n  );\n\n  /**\n   * @dev emitted when a vote is registered\n   * @param proposalId id of the proposal\n   * @param voter address of the voter\n   * @param voteOptions vote options selected by voter\n   * @param oldVotingPower Old power of the voter/vote\n   * @param newVotingPower New power of the voter/vote\n   **/\n  event VotingPowerChanged(\n    uint256 indexed proposalId,\n    address indexed voter,\n    uint32 indexed voteOptions,\n    uint224 oldVotingPower,\n    uint224 newVotingPower\n  );\n\n  event DaoOperatorTransferred(address indexed newDaoOperator);\n\n  event ExecutorAuthorized(address indexed executor);\n\n  event ExecutorUnauthorized(address indexed executor);\n\n  event VotingPowerStrategyAuthorized(address indexed strategy);\n\n  event VotingPowerStrategyUnauthorized(address indexed strategy);\n\n  /**\n   * @dev Function is triggered when users withdraw from staking and change voting power\n   */\n  function handleVotingPowerChanged(\n    address staker,\n    uint256 newVotingPower,\n    uint256[] calldata proposalIds\n  ) external;\n\n  /**\n   * @dev Creates a Binary Proposal (needs to be validated by the Proposal Validator)\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\n   * @param strategy voting power strategy of the proposal\n   * @param executionParams data for execution, includes\n   *   targets list of contracts called by proposal's associated transactions\n   *   weiValues list of value in wei for each proposal's associated transaction\n   *   signatures list of function signatures (can be empty)\n   *        to be used when created the callData\n   *   calldatas list of calldatas: if associated signature empty,\n   *        calldata ready, else calldata is arguments\n   *   withDelegatecalls boolean, true = transaction delegatecalls the taget,\n   *        else calls the target\n   * @param startTime start timestamp to allow vote\n   * @param endTime end timestamp of the proposal\n   * @param link link to the proposal description\n   **/\n  function createBinaryProposal(\n    IExecutorWithTimelock executor,\n    IVotingPowerStrategy strategy,\n    BinaryProposalParams memory executionParams,\n    uint256 startTime,\n    uint256 endTime,\n    string memory link\n  ) external returns (uint256 proposalId);\n\n  /**\n   * @dev Creates a Generic Proposal\n   * @param executor ExecutorWithTimelock contract that will execute the proposal\n   * @param strategy votingPowerStrategy contract to calculate voting power\n   * @param options list of proposal vote options\n   * @param startTime timestamp when vote starts\n   * @param endTime timestamp when vote ends\n   * @param link URL link of the proposal\n   **/\n  function createGenericProposal(\n    IExecutorWithTimelock executor,\n    IVotingPowerStrategy strategy,\n    string[] memory options,\n    uint256 startTime,\n    uint256 endTime,\n    string memory link\n  ) external returns (uint256 proposalId);\n\n  /**\n   * @dev Cancels a Proposal,\n   * either at anytime by guardian\n   * or when proposal is Pending/Active and threshold no longer reached\n   * @param proposalId id of the proposal\n   **/\n  function cancel(uint256 proposalId) external;\n\n  /**\n   * @dev Queue the proposal (If Proposal Succeeded)\n   * @param proposalId id of the proposal to queue\n   **/\n  function queue(uint256 proposalId) external;\n\n  /**\n   * @dev Execute the proposal (If Proposal Queued)\n   * @param proposalId id of the proposal to execute\n   **/\n  function execute(uint256 proposalId) external payable;\n\n  /**\n   * @dev Function allowing msg.sender to vote for/against a proposal\n   * @param proposalId id of the proposal\n   * @param optionBitMask vote option(s) selected\n   **/\n  function submitVote(uint256 proposalId, uint256 optionBitMask) external;\n\n  /**\n   * @dev Function to register the vote of user that has voted offchain via signature\n   * @param proposalId id of the proposal\n   * @param choice the bit mask of voted options\n   * @param v v part of the voter signature\n   * @param r r part of the voter signature\n   * @param s s part of the voter signature\n   **/\n  function submitVoteBySignature(\n    uint256 proposalId,\n    uint256 choice,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Add new addresses to the list of authorized executors\n   * @param executors list of new addresses to be authorized executors\n   **/\n  function authorizeExecutors(address[] calldata executors) external;\n\n  /**\n   * @dev Remove addresses to the list of authorized executors\n   * @param executors list of addresses to be removed as authorized executors\n   **/\n  function unauthorizeExecutors(address[] calldata executors) external;\n\n  /**\n   * @dev Add new addresses to the list of authorized strategies\n   * @param strategies list of new addresses to be authorized strategies\n   **/\n  function authorizeVotingPowerStrategies(address[] calldata strategies) external;\n\n  /**\n   * @dev Remove addresses to the list of authorized strategies\n   * @param strategies list of addresses to be removed as authorized strategies\n   **/\n  function unauthorizeVotingPowerStrategies(address[] calldata strategies) external;\n\n  /**\n   * @dev Returns whether an address is an authorized executor\n   * @param executor address to evaluate as authorized executor\n   * @return true if authorized\n   **/\n  function isExecutorAuthorized(address executor) external view returns (bool);\n\n  /**\n   * @dev Returns whether an address is an authorized strategy\n   * @param strategy address to evaluate as authorized strategy\n   * @return true if authorized\n   **/\n  function isVotingPowerStrategyAuthorized(address strategy) external view returns (bool);\n\n  /**\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\n   * @return The address of the guardian\n   **/\n  function getDaoOperator() external view returns (address);\n\n  /**\n   * @dev Getter of the proposal count (the current number of proposals ever created)\n   * @return the proposal count\n   **/\n  function getProposalsCount() external view returns (uint256);\n\n  /**\n   * @dev Getter of a proposal by id\n   * @param proposalId id of the proposal to get\n   * @return the proposal as ProposalWithoutVote memory object\n   **/\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVote memory);\n\n  /**\n   * @dev Getter of the vote data of a proposal by id\n   * including totalVotes, voteCounts and options\n   * @param proposalId id of the proposal\n   * @return (totalVotes, voteCounts, options)\n   **/\n  function getProposalVoteDataById(uint256 proposalId)\n    external\n    view\n    returns (\n      uint256,\n      uint256[] memory,\n      string[] memory\n    );\n\n  /**\n   * @dev Getter of the Vote of a voter about a proposal\n   * Note: Vote is a struct: ({uint32 bitOptionMask, uint224 votingPower})\n   * @param proposalId id of the proposal\n   * @param voter address of the voter\n   * @return The associated Vote memory object\n   **/\n  function getVoteOnProposal(uint256 proposalId, address voter)\n    external\n    view\n    returns (Vote memory);\n\n  /**\n   * @dev Get the current state of a proposal\n   * @param proposalId id of the proposal\n   * @return The current state if the proposal\n   **/\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\n}\n"
15     },
16     "contracts/interfaces/governance/IExecutorWithTimelock.sol": {
17       "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IKyberGovernance} from './IKyberGovernance.sol';\n\ninterface IExecutorWithTimelock {\n  /**\n   * @dev emitted when a new pending admin is set\n   * @param newPendingAdmin address of the new pending admin\n   **/\n  event NewPendingAdmin(address newPendingAdmin);\n\n  /**\n   * @dev emitted when a new admin is set\n   * @param newAdmin address of the new admin\n   **/\n  event NewAdmin(address newAdmin);\n\n  /**\n   * @dev emitted when a new delay (between queueing and execution) is set\n   * @param delay new delay\n   **/\n  event NewDelay(uint256 delay);\n\n  /**\n   * @dev emitted when a new (trans)action is Queued.\n   * @param actionHash hash of the action\n   * @param target address of the targeted contract\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param executionTime time at which to execute the transaction\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   **/\n  event QueuedAction(\n    bytes32 actionHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 executionTime,\n    bool withDelegatecall\n  );\n\n  /**\n   * @dev emitted when an action is Cancelled\n   * @param actionHash hash of the action\n   * @param target address of the targeted contract\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param executionTime time at which to execute the transaction\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   **/\n  event CancelledAction(\n    bytes32 actionHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 executionTime,\n    bool withDelegatecall\n  );\n\n  /**\n   * @dev emitted when an action is Cancelled\n   * @param actionHash hash of the action\n   * @param target address of the targeted contract\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param executionTime time at which to execute the transaction\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   * @param resultData the actual callData used on the target\n   **/\n  event ExecutedAction(\n    bytes32 actionHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 executionTime,\n    bool withDelegatecall,\n    bytes resultData\n  );\n\n  /**\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\n   * @param target smart contract target\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param executionTime time at which to execute the transaction\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   **/\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) external returns (bytes32);\n\n  /**\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\n   * @param target smart contract target\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param executionTime time at which to execute the transaction\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   **/\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) external payable returns (bytes memory);\n\n  /**\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\n   * @param target smart contract target\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param executionTime time at which to execute the transaction\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   **/\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) external returns (bytes32);\n\n  /**\n   * @dev Getter of the current admin address (should be governance)\n   * @return The address of the current admin\n   **/\n  function getAdmin() external view returns (address);\n\n  /**\n   * @dev Getter of the current pending admin address\n   * @return The address of the pending admin\n   **/\n  function getPendingAdmin() external view returns (address);\n\n  /**\n   * @dev Getter of the delay between queuing and execution\n   * @return The delay in seconds\n   **/\n  function getDelay() external view returns (uint256);\n\n  /**\n   * @dev Returns whether an action (via actionHash) is queued\n   * @param actionHash hash of the action to be checked\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\n   * @return true if underlying action of actionHash is queued\n   **/\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\n\n  /**\n   * @dev Checks whether a proposal is over its grace period\n   * @param governance Governance contract\n   * @param proposalId Id of the proposal against which to test\n   * @return true of proposal is over grace period\n   **/\n  function isProposalOverGracePeriod(IKyberGovernance governance, uint256 proposalId)\n    external\n    view\n    returns (bool);\n\n  /**\n   * @dev Getter of grace period constant\n   * @return grace period in seconds\n   **/\n  function GRACE_PERIOD() external view returns (uint256);\n\n  /**\n   * @dev Getter of minimum delay constant\n   * @return minimum delay in seconds\n   **/\n  function MINIMUM_DELAY() external view returns (uint256);\n\n  /**\n   * @dev Getter of maximum delay constant\n   * @return maximum delay in seconds\n   **/\n  function MAXIMUM_DELAY() external view returns (uint256);\n}\n"
18     },
19     "contracts/interfaces/governance/IVotingPowerStrategy.sol": {
20       "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IWithdrawHandler} from '../staking/IWithdrawHandler.sol';\n\ninterface IVotingPowerStrategy is IWithdrawHandler {\n  /**\n   * @dev call by governance when create a proposal\n   */\n  function handleProposalCreation(\n    uint256 proposalId,\n    uint256 startTime,\n    uint256 endTime\n  ) external;\n\n  /**\n   * @dev call by governance when cancel a proposal\n   */\n  function handleProposalCancellation(uint256 proposalId) external;\n\n  /**\n   * @dev call by governance when submitting a vote\n   * @param choice: unused param for future usage\n   * @return votingPower of voter\n   */\n  function handleVote(\n    address voter,\n    uint256 proposalId,\n    uint256 choice\n  ) external returns (uint256 votingPower);\n\n  /**\n   * @dev get voter's voting power given timestamp\n   * @dev for reading purposes and validating voting power for creating/canceling proposal in the furture\n   * @dev when submitVote, should call 'handleVote' instead\n   */\n  function getVotingPower(address voter, uint256 timestamp)\n    external\n    view\n    returns (uint256 votingPower);\n\n  /**\n   * @dev validate that startTime and endTime are suitable for calculating voting power\n   * @dev with current version, startTime and endTime must be in the sameEpcoh\n   */\n  function validateProposalCreation(uint256 startTime, uint256 endTime)\n    external\n    view\n    returns (bool);\n\n  /**\n   * @dev getMaxVotingPower at current time\n   * @dev call by governance when creating a proposal\n   */\n  function getMaxVotingPower() external view returns (uint256);\n}\n"
21     },
22     "contracts/interfaces/governance/IProposalValidator.sol": {
23       "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IKyberGovernance} from './IKyberGovernance.sol';\nimport {IVotingPowerStrategy} from './IVotingPowerStrategy.sol';\n\ninterface IProposalValidator {\n  /**\n   * @dev Called to validate a binary proposal\n   * @param strategy votingPowerStrategy contract to calculate voting power\n   * @param creator address of the creator\n   * @param startTime timestamp when vote starts\n   * @param endTime timestamp when vote ends\n   * @param daoOperator address of daoOperator\n   * @return boolean, true if can be created\n   **/\n  function validateBinaryProposalCreation(\n    IVotingPowerStrategy strategy,\n    address creator,\n    uint256 startTime,\n    uint256 endTime,\n    address daoOperator\n  ) external view returns (bool);\n\n  /**\n   * @dev Called to validate a generic proposal\n   * @param strategy votingPowerStrategy contract to calculate voting power\n   * @param creator address of the creator\n   * @param startTime timestamp when vote starts\n   * @param endTime timestamp when vote ends\n   * @param options list of proposal vote options\n   * @param daoOperator address of daoOperator\n   * @return boolean, true if can be created\n   **/\n  function validateGenericProposalCreation(\n    IVotingPowerStrategy strategy,\n    address creator,\n    uint256 startTime,\n    uint256 endTime,\n    string[] calldata options,\n    address daoOperator\n  ) external view returns (bool);\n\n  /**\n   * @dev Called to validate the cancellation of a proposal\n   * @param governance governance contract to fetch proposals from\n   * @param proposalId Id of the generic proposal\n   * @param user entity initiating the cancellation\n   * @return boolean, true if can be cancelled\n   **/\n  function validateProposalCancellation(\n    IKyberGovernance governance,\n    uint256 proposalId,\n    address user\n  ) external view returns (bool);\n\n  /**\n   * @dev Returns whether a binary proposal passed or not\n   * @param governance governance contract to fetch proposals from\n   * @param proposalId Id of the proposal to set\n   * @return true if proposal passed\n   **/\n  function isBinaryProposalPassed(IKyberGovernance governance, uint256 proposalId)\n    external\n    view\n    returns (bool);\n\n  /**\n   * @dev Check whether a proposal has reached quorum\n   * @param governance governance contract to fetch proposals from\n   * @param proposalId Id of the proposal to verify\n   * @return voting power needed for a proposal to pass\n   **/\n  function isQuorumValid(IKyberGovernance governance, uint256 proposalId)\n    external\n    view\n    returns (bool);\n\n  /**\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\n   * @param governance governance contract to fetch proposals from\n   * @param proposalId Id of the proposal to verify\n   * @return true if enough For-Votes\n   **/\n  function isVoteDifferentialValid(IKyberGovernance governance, uint256 proposalId)\n    external\n    view\n    returns (bool);\n\n  /**\n   * @dev Get maximum vote options for a generic proposal\n   * @return the maximum no. of vote options possible for a generic proposal\n   **/\n  function MAX_VOTING_OPTIONS() external view returns (uint256);\n\n  /**\n   * @dev Get minimum voting duration constant value\n   * @return the minimum voting duration value in seconds\n   **/\n  function MIN_VOTING_DURATION() external view returns (uint256);\n\n  /**\n   * @dev Get the vote differential threshold constant value\n   * to compare with % of for votes/total supply - % of against votes/total supply\n   * @return the vote differential threshold value (100 <=> 1%)\n   **/\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\n\n  /**\n   * @dev Get quorum threshold constant value\n   * to compare with % of for votes/total supply\n   * @return the quorum threshold value (100 <=> 1%)\n   **/\n  function MINIMUM_QUORUM() external view returns (uint256);\n}\n"
24     },
25     "contracts/misc/Helpers.sol": {
26       "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma abicoder v2;\n\nfunction getChainId() pure returns (uint256) {\n  uint256 chainId;\n  assembly {\n    chainId := chainid()\n  }\n  return chainId;\n}\n\nfunction isContract(address account) view returns (bool) {\n  // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n  // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n  // for accounts without code, i.e. `keccak256('')`\n  bytes32 codehash;\n  bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n  // solhint-disable-next-line no-inline-assembly\n  assembly {\n    codehash := extcodehash(account)\n  }\n  return (codehash != accountHash && codehash != 0x0);\n}\n"
27     },
28     "contracts/interfaces/staking/IWithdrawHandler.sol": {
29       "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma abicoder v2;\n\n/**\n * @title Interface for callbacks hooks when user withdraws from staking contract\n */\ninterface IWithdrawHandler {\n  function handleWithdrawal(address staker, uint256 reduceAmount) external;\n}\n"
30     }
31   },
32   "settings": {
33     "optimizer": {
34       "enabled": true,
35       "runs": 1000
36     },
37     "outputSelection": {
38       "*": {
39         "*": [
40           "evm.bytecode",
41           "evm.deployedBytecode",
42           "abi"
43         ]
44       }
45     },
46     "libraries": {}
47   }
48 }}