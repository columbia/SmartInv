1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/farm/ERC721Farm.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/math/Math.sol';\nimport '@solidstate/contracts/token/ERC721/IERC721.sol';\nimport '@solidstate/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@solidstate/contracts/utils/EnumerableSet.sol';\n\nimport '../token/IMagic.sol';\n\ncontract ERC721Farm is IERC721Receiver {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    address private immutable MAGIC;\n    address private immutable ERC721_CONTRACT;\n    uint256 public immutable EXPIRATION;\n    uint256 private immutable RATE;\n\n    mapping(address => EnumerableSet.UintSet) private _deposits;\n    mapping(address => mapping(uint256 => uint256)) public depositBlocks;\n\n    constructor(\n        address magic,\n        address erc721,\n        uint256 rate,\n        uint256 expiration\n    ) {\n        MAGIC = magic;\n        ERC721_CONTRACT = erc721;\n        RATE = rate;\n        EXPIRATION = block.number + expiration;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    function depositsOf(address account)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        EnumerableSet.UintSet storage depositSet = _deposits[account];\n        uint256[] memory tokenIds = new uint256[](depositSet.length());\n\n        for (uint256 i; i < depositSet.length(); i++) {\n            tokenIds[i] = depositSet.at(i);\n        }\n\n        return tokenIds;\n    }\n\n    function calculateRewards(address account, uint256[] memory tokenIds)\n        public\n        view\n        returns (uint256[] memory rewards)\n    {\n        rewards = new uint256[](tokenIds.length);\n\n        for (uint256 i; i < tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n\n            rewards[i] =\n                RATE *\n                (_deposits[account].contains(tokenId) ? 1 : 0) *\n                (Math.min(block.number, EXPIRATION) -\n                    depositBlocks[account][tokenId]);\n        }\n    }\n\n    function claimRewards(uint256[] calldata tokenIds) public {\n        uint256 reward;\n        uint256 block = Math.min(block.number, EXPIRATION);\n\n        uint256[] memory rewards = calculateRewards(msg.sender, tokenIds);\n\n        for (uint256 i; i < tokenIds.length; i++) {\n            reward += rewards[i];\n            depositBlocks[msg.sender][tokenIds[i]] = block;\n        }\n\n        if (reward > 0) {\n            IMagic(MAGIC).mint(msg.sender, reward);\n        }\n    }\n\n    function deposit(uint256[] calldata tokenIds) external {\n        claimRewards(tokenIds);\n\n        for (uint256 i; i < tokenIds.length; i++) {\n            IERC721(ERC721_CONTRACT).safeTransferFrom(\n                msg.sender,\n                address(this),\n                tokenIds[i],\n                ''\n            );\n\n            _deposits[msg.sender].add(tokenIds[i]);\n        }\n    }\n\n    function withdraw(uint256[] calldata tokenIds) external {\n        claimRewards(tokenIds);\n\n        for (uint256 i; i < tokenIds.length; i++) {\n            require(\n                _deposits[msg.sender].contains(tokenIds[i]),\n                'ERC721Farm: token not deposited'\n            );\n\n            _deposits[msg.sender].remove(tokenIds[i]);\n\n            IERC721(ERC721_CONTRACT).safeTransferFrom(\n                address(this),\n                msg.sender,\n                tokenIds[i],\n                ''\n            );\n        }\n    }\n}\n"
6     },
7     "@openzeppelin/contracts/utils/math/Math.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
9     },
10     "@solidstate/contracts/token/ERC721/IERC721.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IERC165} from '../../introspection/IERC165.sol';\nimport {IERC721Internal} from './IERC721Internal.sol';\n\n/**\n * @notice ERC721 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721 is IERC721Internal, IERC165 {\n  /**\n   * @notice query the balance of given address\n   * @return balance quantity of tokens held\n   */\n  function balanceOf (\n    address account\n  ) external view returns (uint256 balance);\n\n  /**\n   * @notice query the owner of given token\n   * @param tokenId token to query\n   * @return owner token owner\n   */\n  function ownerOf (\n    uint256 tokenId\n  ) external view returns (address owner);\n\n  /**\n   * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n   * @param from sender of token\n   * @param to receiver of token\n   * @param tokenId token id\n   */\n  function safeTransferFrom (\n    address from,\n    address to,\n    uint256 tokenId\n  ) external payable;\n\n  /**\n   * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n   * @param from sender of token\n   * @param to receiver of token\n   * @param tokenId token id\n   * @param data data payload\n   */\n  function safeTransferFrom (\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes calldata data\n  ) external payable;\n\n  /**\n   * @notice transfer token between given addresses, without checking for ERC721Receiver implementation if applicable\n   * @param from sender of token\n   * @param to receiver of token\n   * @param tokenId token id\n   */\n  function transferFrom (\n    address from,\n    address to,\n    uint256 tokenId\n  ) external payable;\n\n  /**\n   * @notice grant approval to given account to spend token\n   * @param operator address to be approved\n   * @param tokenId token to approve\n   */\n  function approve (\n    address operator,\n    uint256 tokenId\n  ) external payable;\n\n  /**\n   * @notice get approval status for given token\n   * @param tokenId token to query\n   * @return operator address approved to spend token\n   */\n  function getApproved (\n    uint256 tokenId\n  ) external view returns (address operator);\n\n  /**\n   * @notice grant approval to or revoke approval from given account to spend all tokens held by sender\n   * @param operator address to be approved\n   * @param status approval status\n   */\n  function setApprovalForAll (\n    address operator,\n    bool status\n  ) external;\n\n  /**\n   * @notice query approval status of given operator with respect to given address\n   * @param account address to query for approval granted\n   * @param operator address to query for approval received\n   * @return status whether operator is approved to spend tokens held by account\n   */\n  function isApprovedForAll (\n    address account,\n    address operator\n  ) external view returns (bool status);\n}\n"
12     },
13     "@solidstate/contracts/token/ERC721/IERC721Receiver.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC721Receiver {\n  function onERC721Received (\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes calldata data\n  ) external returns (bytes4);\n}\n"
15     },
16     "@solidstate/contracts/utils/EnumerableSet.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n  struct Set {\n    bytes32[] _values;\n    // 1-indexed to allow 0 to signify nonexistence\n    mapping (bytes32 => uint) _indexes;\n  }\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  function at (\n    Bytes32Set storage set,\n    uint index\n  ) internal view returns (bytes32) {\n    return _at(set._inner, index);\n  }\n\n  function at (\n    AddressSet storage set,\n    uint index\n  ) internal view returns (address) {\n    return address(uint160(uint(_at(set._inner, index))));\n  }\n\n  function at (\n    UintSet storage set,\n    uint index\n  ) internal view returns (uint) {\n    return uint(_at(set._inner, index));\n  }\n\n  function contains (\n    Bytes32Set storage set,\n    bytes32 value\n  ) internal view returns (bool) {\n    return _contains(set._inner, value);\n  }\n\n  function contains (\n    AddressSet storage set,\n    address value\n  ) internal view returns (bool) {\n    return _contains(set._inner, bytes32(uint(uint160(value))));\n  }\n\n  function contains (\n    UintSet storage set,\n    uint value\n  ) internal view returns (bool) {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  function indexOf (\n    Bytes32Set storage set,\n    bytes32 value\n  ) internal view returns (uint) {\n    return _indexOf(set._inner, value);\n  }\n\n  function indexOf (\n    AddressSet storage set,\n    address value\n  ) internal view returns (uint) {\n    return _indexOf(set._inner, bytes32(uint(uint160(value))));\n  }\n\n  function indexOf (\n    UintSet storage set,\n    uint value\n  ) internal view returns (uint) {\n    return _indexOf(set._inner, bytes32(value));\n  }\n\n  function length (\n    Bytes32Set storage set\n  ) internal view returns (uint) {\n    return _length(set._inner);\n  }\n\n  function length (\n    AddressSet storage set\n  ) internal view returns (uint) {\n    return _length(set._inner);\n  }\n\n  function length (\n    UintSet storage set\n  ) internal view returns (uint) {\n    return _length(set._inner);\n  }\n\n  function add (\n    Bytes32Set storage set,\n    bytes32 value\n  ) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  function add (\n    AddressSet storage set,\n    address value\n  ) internal returns (bool) {\n    return _add(set._inner, bytes32(uint(uint160(value))));\n  }\n\n  function add (\n    UintSet storage set,\n    uint value\n  ) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  function remove (\n    Bytes32Set storage set,\n    bytes32 value\n  ) internal returns (bool) {\n    return _remove(set._inner, value);\n  }\n\n  function remove (\n    AddressSet storage set,\n    address value\n  ) internal returns (bool) {\n    return _remove(set._inner, bytes32(uint(uint160(value))));\n  }\n\n  function remove (\n    UintSet storage set,\n    uint value\n  ) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  function _at (\n    Set storage set,\n    uint index\n  ) private view returns (bytes32) {\n    require(set._values.length > index, 'EnumerableSet: index out of bounds');\n    return set._values[index];\n  }\n\n  function _contains (\n    Set storage set,\n    bytes32 value\n  ) private view returns (bool) {\n    return set._indexes[value] != 0;\n  }\n\n  function _indexOf (\n    Set storage set,\n    bytes32 value\n  ) private view returns (uint) {\n    unchecked {\n      return set._indexes[value] - 1;\n    }\n  }\n\n  function _length (\n    Set storage set\n  ) private view returns (uint) {\n    return set._values.length;\n  }\n\n  function _add (\n    Set storage set,\n    bytes32 value\n  ) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function _remove (\n    Set storage set,\n    bytes32 value\n  ) private returns (bool) {\n    uint valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      uint index = valueIndex - 1;\n      bytes32 last = set._values[set._values.length - 1];\n\n      // move last value to now-vacant index\n\n      set._values[index] = last;\n      set._indexes[last] = index + 1;\n\n      // clear last index\n\n      set._values.pop();\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n"
18     },
19     "contracts/token/IMagic.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@solidstate/contracts/token/ERC20/IERC20.sol';\n\ninterface IMagic is IERC20 {\n    function mint(address account, uint256 amount) external;\n}\n"
21     },
22     "@solidstate/contracts/introspection/IERC165.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 {\n  /**\n   * @notice query whether contract has registered support for given interface\n   * @param interfaceId interface id\n   * @return bool whether interface is supported\n   */\n  function supportsInterface (\n    bytes4 interfaceId\n  ) external view returns (bool);\n}\n"
24     },
25     "@solidstate/contracts/token/ERC721/IERC721Internal.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @notice Partial ERC721 interface needed by internal functions\n */\ninterface IERC721Internal {\n  event Transfer (\n    address indexed from,\n    address indexed to,\n    uint256 indexed tokenId\n  );\n\n  event Approval (\n    address indexed owner,\n    address indexed operator,\n    uint256 indexed tokenId\n  );\n\n  event ApprovalForAll (\n    address indexed owner,\n    address indexed operator,\n    bool approved\n  );\n}\n"
27     },
28     "@solidstate/contracts/token/ERC20/IERC20.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IERC20Internal} from './IERC20Internal.sol';\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 is IERC20Internal {\n  /**\n   * @notice query the total minted token supply\n   * @return token supply\n   */\n  function totalSupply () external view returns (uint256);\n\n  /**\n   * @notice query the token balance of given account\n   * @param account address to query\n   * @return token balance\n   */\n  function balanceOf (\n    address account\n  ) external view returns (uint256);\n\n  /**\n   * @notice query the allowance granted from given holder to given spender\n   * @param holder approver of allowance\n   * @param spender recipient of allowance\n   * @return token allowance\n   */\n  function allowance (\n    address holder,\n    address spender\n  ) external view returns (uint256);\n\n  /**\n   * @notice grant approval to spender to spend tokens\n   * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n   * @param spender recipient of allowance\n   * @param amount quantity of tokens approved for spending\n   * @return success status (always true; otherwise function should revert)\n   */\n  function approve (\n    address spender,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @notice transfer tokens to given recipient\n   * @param recipient beneficiary of token transfer\n   * @param amount quantity of tokens to transfer\n   * @return success status (always true; otherwise function should revert)\n   */\n  function transfer (\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @notice transfer tokens to given recipient on behalf of given holder\n   * @param holder holder of tokens prior to transfer\n   * @param recipient beneficiary of token transfer\n   * @param amount quantity of tokens to transfer\n   * @return success status (always true; otherwise function should revert)\n   */\n  function transferFrom (\n    address holder,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n}\n"
30     },
31     "@solidstate/contracts/token/ERC20/IERC20Internal.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial ERC20 interface needed by internal functions\n */\ninterface IERC20Internal {\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n"
33     }
34   },
35   "settings": {
36     "optimizer": {
37       "enabled": true,
38       "runs": 200
39     },
40     "outputSelection": {
41       "*": {
42         "*": [
43           "evm.bytecode",
44           "evm.deployedBytecode",
45           "abi"
46         ]
47       }
48     },
49     "libraries": {}
50   }
51 }}