1 {{
2   "language": "Solidity",
3   "sources": {
4     "solidity/contracts/HarvestPublicKeep3rJob.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n\n/*\n\nCoded for Yearn Finance with ♥ by\n\n██████╗░███████╗███████╗██╗░░░██╗░░░░░░░██╗░█████╗░███╗░░██╗██████╗░███████╗██████╗░██╗░░░░░░█████╗░███╗░░██╗██████╗░\n██╔══██╗██╔════╝██╔════╝██║░░░██║░░██╗░░██║██╔══██╗████╗░██║██╔══██╗██╔════╝██╔══██╗██║░░░░░██╔══██╗████╗░██║██╔══██╗\n██║░░██║█████╗░░█████╗░░██║░░░╚██╗████╗██╔╝██║░░██║██╔██╗██║██║░░██║█████╗░░██████╔╝██║░░░░░███████║██╔██╗██║██║░░██║\n██║░░██║██╔══╝░░██╔══╝░░██║░░░░████╔═████║░██║░░██║██║╚████║██║░░██║██╔══╝░░██╔══██╗██║░░░░░██╔══██║██║╚████║██║░░██║\n██████╔╝███████╗██║░░░░░██║░░░░╚██╔╝░╚██╔╝░╚█████╔╝██║░╚███║██████╔╝███████╗██║░░██║███████╗██║░░██║██║░╚███║██████╔╝\n╚═════╝░╚══════╝╚═╝░░░░░╚═╝░░░░░╚═╝░░░╚═╝░░░╚════╝░╚═╝░░╚══╝╚═════╝░╚══════╝╚═╝░░╚═╝╚══════╝╚═╝░░╚═╝╚═╝░░╚══╝╚═════╝░\n\nhttps://defi.sucks\n\n*/\n\npragma solidity >=0.8.9 <0.9.0;\n\nimport './PublicKeeperJob.sol';\nimport './utils/Pausable.sol';\nimport './utils/Keep3rMeteredPublicJob.sol';\n\ncontract HarvestPublicKeep3rJob is IKeep3rJob, PublicKeeperJob, Pausable, Keep3rJob {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  constructor(\n    address _governor,\n    address _mechanicsRegistry,\n    address _publicKeeper,\n    address _vaultRegistry,\n    uint256 _workCooldown,\n    address _keep3r\n  ) PublicKeeperJob(_governor, _publicKeeper, _mechanicsRegistry, _vaultRegistry, _workCooldown) {\n    _setKeep3r(_keep3r);\n  }\n\n  // views\n\n  /// @inheritdoc IPublicKeeperJob\n  function workable(address _strategy) external view returns (bool _isWorkable) {\n    return _workable(_strategy);\n  }\n\n  function _isValidStrategy(address _strategy) internal view virtual override returns (bool _isValid) {\n    address _vault = IBaseStrategy(_strategy).vault();\n    return\n      IVaultRegistry(vaultRegistry).isVaultEndorsed(_vault) &&\n      ITokenVault(_vault).strategies(_strategy).activation > 0 &&\n      !_ignoredStrategies.contains(_strategy);\n  }\n\n  // methods\n\n  /// @inheritdoc IPublicKeeperJob\n  function work(address _strategy) external upkeep notPaused {\n    _workInternal(_strategy);\n  }\n\n  /// @inheritdoc IPublicKeeperJob\n  function forceWork(address _strategy) external onlyGovernorOrMechanic {\n    _forceWork(_strategy);\n  }\n\n  // internals\n\n  function _workable(address _strategy) internal view override returns (bool _isWorkable) {\n    if (!super._workable(_strategy)) return false;\n    return IBaseStrategy(_strategy).harvestTrigger(0);\n  }\n\n  function _work(address _strategy) internal override {\n    publicKeeper.harvest(_strategy);\n  }\n}\n"
6     },
7     "solidity/contracts/PublicKeeperJob.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.9 <0.9.0;\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\nimport './utils/GasBaseFee.sol';\nimport './utils/MachineryReady.sol';\nimport '../interfaces/IPublicKeeperJob.sol';\nimport '../interfaces/external/IKeeperWrapper.sol';\nimport '../interfaces/external/IBaseStrategy.sol';\nimport '../interfaces/external/IVaultRegistry.sol';\nimport '../interfaces/external/ITokenVault.sol';\n\nabstract contract PublicKeeperJob is IPublicKeeperJob, MachineryReady, GasBaseFee {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @inheritdoc IPublicKeeperJob\n  IKeeperWrapper public publicKeeper;\n\n  /// @inheritdoc IPublicKeeperJob\n  IVaultRegistry public vaultRegistry;\n\n  EnumerableSet.AddressSet internal _ignoredStrategies;\n  /// @inheritdoc IPublicKeeperJob\n  mapping(address => uint256) public lastWorkAt;\n  /// @inheritdoc IPublicKeeperJob\n  uint256 public workCooldown;\n\n  constructor(\n    address _governor,\n    address _publicKeeper,\n    address _mechanicsRegistry,\n    address _vaultRegistry,\n    uint256 _workCooldown\n  ) Governable(_governor) MachineryReady(_mechanicsRegistry) {\n    vaultRegistry = IVaultRegistry(_vaultRegistry);\n    publicKeeper = IKeeperWrapper(_publicKeeper);\n    if (_workCooldown > 0) _setWorkCooldown(_workCooldown);\n  }\n\n  // views\n\n  /// @inheritdoc IPublicKeeperJob\n  function isValidStrategy(address _strategy) external view returns (bool _isValid) {\n    return _isValidStrategy(_strategy);\n  }\n\n  // setters\n\n  /// @inheritdoc IPublicKeeperJob\n  function setPublicKeeper(address _publicKeeper) external onlyGovernor {\n    _setPublicKeeper(_publicKeeper);\n  }\n\n  /// @inheritdoc IPublicKeeperJob\n  function setWorkCooldown(uint256 _workCooldown) external onlyGovernorOrMechanic {\n    _setWorkCooldown(_workCooldown);\n  }\n\n  function ignoreStrategy(address _strategy) external onlyGovernorOrMechanic {\n    _ignoreStrategy(_strategy);\n  }\n\n  function acknowledgeStrategy(address _strategy) external onlyGovernorOrMechanic {\n    _acknowledgeStrategy(_strategy);\n  }\n\n  // internals\n\n  function _isValidStrategy(address _strategy) internal view virtual returns (bool _isValid);\n\n  function _setPublicKeeper(address _publicKeeper) internal {\n    publicKeeper = IKeeperWrapper(_publicKeeper);\n  }\n\n  function _setWorkCooldown(uint256 _workCooldown) internal {\n    if (_workCooldown == 0) revert ZeroCooldown();\n    workCooldown = _workCooldown;\n  }\n\n  function _ignoreStrategy(address _strategy) internal {\n    if (_ignoredStrategies.contains(_strategy)) revert StrategyAlreadyIgnored();\n    emit StrategyIgnored(_strategy);\n    _ignoredStrategies.add(_strategy);\n  }\n\n  function _acknowledgeStrategy(address _strategy) internal {\n    if (!_ignoredStrategies.contains(_strategy)) revert StrategyNotIgnored();\n    _ignoredStrategies.remove(_strategy);\n    emit StrategyAcknowledged(_strategy);\n  }\n\n  function _workable(address _strategy) internal view virtual returns (bool) {\n    if (!_isValidStrategy(_strategy)) revert InvalidStrategy();\n    if (workCooldown == 0 || block.timestamp > lastWorkAt[_strategy] + workCooldown) return true;\n    return false;\n  }\n\n  function _workInternal(address _strategy) internal {\n    if (!_workable(_strategy)) revert StrategyNotWorkable();\n    lastWorkAt[_strategy] = block.timestamp;\n    _work(_strategy);\n    emit KeeperWorked(_strategy);\n  }\n\n  function _forceWork(address _strategy) internal {\n    _work(_strategy);\n    emit ForceWorked(_strategy);\n  }\n\n  /// @dev This function should be implemented on the base contract\n  function _work(address _strategy) internal virtual {}\n}\n"
9     },
10     "solidity/contracts/utils/Pausable.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport './Governable.sol';\nimport '../../interfaces/utils/IPausable.sol';\n\nabstract contract Pausable is IPausable, Governable {\n  /// @inheritdoc IPausable\n  bool public paused;\n\n  // setters\n\n  /// @inheritdoc IPausable\n  function setPause(bool _paused) external onlyGovernor {\n    _setPause(_paused);\n  }\n\n  // modifiers\n\n  modifier notPaused() {\n    if (paused) revert Paused();\n    _;\n  }\n\n  // internals\n\n  function _setPause(bool _paused) internal {\n    if (paused == _paused) revert NoChangeInPause();\n    paused = _paused;\n    emit PauseSet(_paused);\n  }\n}\n"
12     },
13     "solidity/contracts/utils/Keep3rMeteredPublicJob.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport './Keep3rMeteredJob.sol';\nimport './Keep3rBondedJob.sol';\nimport './OnlyEOA.sol';\n\nabstract contract Keep3rMeteredPublicJob is Keep3rMeteredJob, Keep3rBondedJob, OnlyEOA {\n  // internals\n  function _isValidKeeper(address _keeper) internal override(Keep3rBondedJob, Keep3rJob) {\n    if (onlyEOA) _validateEOA(_keeper);\n    super._isValidKeeper(_keeper);\n  }\n}\n"
15     },
16     "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
18     },
19     "solidity/contracts/utils/GasBaseFee.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.9 <0.9.0;\n\nabstract contract GasBaseFee {\n  // internals\n  function _gasPrice() internal view virtual returns (uint256) {\n    return block.basefee;\n  }\n}\n"
21     },
22     "solidity/contracts/utils/MachineryReady.sol": {
23       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport '@yearn-mechanics/contract-utils/solidity/contracts/utils/Machinery.sol';\nimport './Governable.sol';\n\nabstract contract MachineryReady is Machinery, Governable {\n  // errors\n\n  /// @notice Throws when a OnlyGovernorOrMechanic function is called from an unknown address\n  error OnlyGovernorOrMechanic();\n\n  constructor(address _mechanicsRegistry) Machinery(_mechanicsRegistry) {}\n\n  // methods\n\n  /// @notice Allows governor to set a new MechanicsRegistry contract\n  /// @param _mechanicsRegistry Address of the new MechanicsRegistry contract\n  function setMechanicsRegistry(address _mechanicsRegistry) external override onlyGovernor {\n    _setMechanicsRegistry(_mechanicsRegistry);\n  }\n\n  // modifiers\n\n  modifier onlyGovernorOrMechanic() {\n    _validateGovernorOrMechanic(msg.sender);\n    _;\n  }\n\n  // internals\n\n  function _validateGovernorOrMechanic(address _user) internal view {\n    if (_user != governor && !isMechanic(_user)) revert OnlyGovernorOrMechanic();\n  }\n}\n"
24     },
25     "solidity/interfaces/IPublicKeeperJob.sol": {
26       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\nimport './external/IKeeperWrapper.sol';\nimport './external/IVaultRegistry.sol';\n\ninterface IPublicKeeperJob {\n  // errors\n\n  /// @notice Throws if the strategy being worked is not valid\n  error InvalidStrategy();\n  /// @notice Throws if the strategy being added has already been added\n  error StrategyAlreadyIgnored();\n  /// @notice Throws if the strategy being summoned is not added\n  error StrategyNotIgnored();\n  /// @notice Throws if a keeper tries to work a non-workable strategy\n  error StrategyNotWorkable();\n  /// @notice Throws if the cooldown is being set to 0\n  error ZeroCooldown();\n\n  // events\n\n  /// @notice Emitted when a strategy is worked\n  /// @param _strategy Address of the strategy being worked\n  event KeeperWorked(address _strategy);\n\n  /// @notice Emitted when a strategy is force-worked by governor or mechanic\n  /// @param _strategy Address of the strategy being force-worked\n  event ForceWorked(address _strategy);\n\n  /// @notice Emitted when a new strategy is added to the ignore list\n  /// @param _strategy Address of the strategy being added to the ignore list\n  event StrategyIgnored(address _strategy);\n\n  /// @notice Emitted when a strategy is removed from the ignore list\n  /// @param _strategy Address of the strategy being removed from the ignore list\n  event StrategyAcknowledged(address _strategy);\n\n  // views\n\n  function isValidStrategy(address _strategy) external view returns (bool _isValid);\n\n  /// @return _publicKeeper Address of the public Keeper wrapper\n  function publicKeeper() external view returns (IKeeperWrapper _publicKeeper);\n\n  /// @return _vaultRegistry Address of the vault registry\n  function vaultRegistry() external view returns (IVaultRegistry _vaultRegistry);\n\n  /// @return _workCooldown Amount of seconds to wait until a strategy can be worked again\n  function workCooldown() external view returns (uint256 _workCooldown);\n\n  /// @param _strategy Address of the strategy to query\n  /// @return _isWorkable Whether the queried strategy is workable or not\n  function workable(address _strategy) external view returns (bool _isWorkable);\n\n  /// @param _strategy Address of the strategy to query\n  /// @return _lastWorkAt Timestamp of the last time the strategy was worked\n  function lastWorkAt(address _strategy) external view returns (uint256 _lastWorkAt);\n\n  // methods\n\n  /// @param _publicKeeper Address of the new v2Keeper to set\n  function setPublicKeeper(address _publicKeeper) external;\n\n  /// @param _workCooldown Amount of seconds to wait until a strategy can be worked again\n  function setWorkCooldown(uint256 _workCooldown) external;\n\n  /// @param _strategy Address of the strategy to add\n  function ignoreStrategy(address _strategy) external;\n\n  /// @param _strategy Address of the strategy to remove\n  function acknowledgeStrategy(address _strategy) external;\n\n  /// @notice Function to be called by the keeper that triggers the execution of the given strategy\n  /// @param _strategy Address of the strategy to be worked\n  function work(address _strategy) external;\n\n  /// @notice Function to be called by governor or mechanics that triggers the execution of the given strategy\n  /// @notice This function bypasses the workable checks\n  /// @param _strategy Address of the strategy to be worked\n  function forceWork(address _strategy) external;\n}\n"
27     },
28     "solidity/interfaces/external/IKeeperWrapper.sol": {
29       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.8;\n\ninterface IKeeperWrapper {\n  function harvest(address _strategy) external;\n}\n"
30     },
31     "solidity/interfaces/external/IBaseStrategy.sol": {
32       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IBaseStrategy {\n  // events\n  event Harvested(uint256 _profit, uint256 _loss, uint256 _debtPayment, uint256 _debtOutstanding);\n\n  // views\n\n  function vault() external view returns (address _vault);\n\n  function strategist() external view returns (address _strategist);\n\n  function rewards() external view returns (address _rewards);\n\n  function keeper() external view returns (address _keeper);\n\n  function want() external view returns (address _want);\n\n  function name() external view returns (string memory _name);\n\n  function profitFactor() external view returns (uint256 _profitFactor);\n\n  function maxReportDelay() external view returns (uint256 _maxReportDelay);\n\n  function crv() external view returns (address _crv);\n\n  // setters\n  function setStrategist(address _strategist) external;\n\n  function setKeeper(address _keeper) external;\n\n  function setRewards(address _rewards) external;\n\n  function tendTrigger(uint256 _callCost) external view returns (bool);\n\n  function tend() external;\n\n  function harvestTrigger(uint256 _callCost) external view returns (bool);\n\n  function harvest() external;\n\n  function setBorrowCollateralizationRatio(uint256 _c) external;\n}\n"
33     },
34     "solidity/interfaces/external/IVaultRegistry.sol": {
35       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IVaultRegistry {\n  // solhint-disable-next-line func-name-mixedcase\n  function DEFAULT_VAULT_TYPE() external view returns (uint256);\n\n  // solhint-disable-next-line func-name-mixedcase\n  function LEGACY_REGISTRY() external view returns (address);\n\n  function approvedVaultsOwner(address) external view returns (bool);\n\n  function endorseVault(address _vault) external;\n\n  function endorseVault(\n    address _vault,\n    uint256 _releaseDelta,\n    uint256 _type\n  ) external;\n\n  function endorseVault(address _vault, uint256 _releaseDelta) external;\n\n  function isRegistered(address) external view returns (bool);\n\n  function isVaultEndorsed(address) external view returns (bool);\n\n  function latestVault(address _token) external view returns (address);\n\n  function latestVaultOfType(address _token, uint256 _type) external view returns (address);\n\n  function newVault(\n    address _token,\n    address _governance,\n    address _guardian,\n    address _rewards,\n    string memory _name,\n    string memory _symbol,\n    uint256 _releaseDelta,\n    uint256 _type\n  ) external returns (address);\n\n  function newVault(\n    address _token,\n    address _guardian,\n    address _rewards,\n    string memory _name,\n    string memory _symbol,\n    uint256 _releaseDelta\n  ) external returns (address);\n\n  function numTokens() external view returns (uint256);\n\n  function numVaults(address _token) external view returns (uint256);\n\n  function owner() external view returns (address);\n\n  function releaseRegistry() external view returns (address);\n\n  function renounceOwnership() external;\n\n  function setApprovedVaultsOwner(address _addr, bool _approved) external;\n\n  function setVaultEndorsers(address _addr, bool _approved) external;\n\n  function tokens(uint256) external view returns (address);\n\n  function transferOwnership(address _newOwner) external;\n\n  function updateReleaseRegistry(address _newRegistry) external;\n\n  function vaultEndorsers(address) external view returns (bool);\n\n  function vaultType(address) external view returns (uint256);\n\n  function vaults(address, uint256) external view returns (address);\n}\n"
36     },
37     "solidity/interfaces/external/ITokenVault.sol": {
38       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface ITokenVault {\n  function initialize(\n    address _token,\n    address _governance,\n    address _rewards,\n    string memory _nameOverride,\n    string memory _symbolOverride\n  ) external;\n\n  function initialize(\n    address _token,\n    address _governance,\n    address _rewards,\n    string memory _nameOverride,\n    string memory _symbolOverride,\n    address _guardian\n  ) external;\n\n  function initialize(\n    address _token,\n    address _governance,\n    address _rewards,\n    string memory _nameOverride,\n    string memory _symbolOverride,\n    address _guardian,\n    address _management\n  ) external;\n\n  function apiVersion() external pure returns (string memory);\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function setName(string memory _name) external;\n\n  function setSymbol(string memory _symbol) external;\n\n  function setGovernance(address _governance) external;\n\n  function acceptGovernance() external;\n\n  function setManagement(address _management) external;\n\n  function setRewards(address _rewards) external;\n\n  function setLockedProfitDegradation(uint256 _degradation) external;\n\n  function setDepositLimit(uint256 _limit) external;\n\n  function setPerformanceFee(uint256 _fee) external;\n\n  function setManagementFee(uint256 _fee) external;\n\n  function setGuardian(address _guardian) external;\n\n  function setEmergencyShutdown(bool _active) external;\n\n  function setWithdrawalQueue(address[20] memory _queue) external;\n\n  function transfer(address _receiver, uint256 _amount) external returns (bool);\n\n  function transferFrom(\n    address _sender,\n    address _receiver,\n    uint256 _amount\n  ) external returns (bool);\n\n  function approve(address _spender, uint256 _amount) external returns (bool);\n\n  function increaseAllowance(address _spender, uint256 _amount) external returns (bool);\n\n  function decreaseAllowance(address _spender, uint256 _amount) external returns (bool);\n\n  function permit(\n    address _owner,\n    address _spender,\n    uint256 _amount,\n    uint256 _expiry,\n    bytes memory _signature\n  ) external returns (bool);\n\n  function totalAssets() external view returns (uint256);\n\n  function deposit() external returns (uint256);\n\n  function deposit(uint256 _amount) external returns (uint256);\n\n  function deposit(uint256 _amount, address _recipient) external returns (uint256);\n\n  function maxAvailableShares() external view returns (uint256);\n\n  function withdraw() external returns (uint256);\n\n  function withdraw(uint256 _maxShares) external returns (uint256);\n\n  function withdraw(uint256 _maxShares, address _recipient) external returns (uint256);\n\n  function withdraw(\n    uint256 _maxShares,\n    address _recipient,\n    uint256 _maxLoss\n  ) external returns (uint256);\n\n  function pricePerShare() external view returns (uint256);\n\n  function addStrategy(\n    address _strategy,\n    uint256 _debtRatio,\n    uint256 _minDebtPerHarvest,\n    uint256 _maxDebtPerHarvest,\n    uint256 _performanceFee\n  ) external;\n\n  function updateStrategyDebtRatio(address _strategy, uint256 _debtRatio) external;\n\n  function updateStrategyMinDebtPerHarvest(address _strategy, uint256 _minDebtPerHarvest) external;\n\n  function updateStrategyMaxDebtPerHarvest(address _strategy, uint256 _maxDebtPerHarvest) external;\n\n  function updateStrategyPerformanceFee(address _strategy, uint256 _performanceFee) external;\n\n  function migrateStrategy(address _oldVersion, address _newVersion) external;\n\n  function revokeStrategy() external;\n\n  function revokeStrategy(address _strategy) external;\n\n  function addStrategyToQueue(address _strategy) external;\n\n  function removeStrategyFromQueue(address _strategy) external;\n\n  function debtOutstanding() external view returns (uint256);\n\n  function debtOutstanding(address _strategy) external view returns (uint256);\n\n  function creditAvailable() external view returns (uint256);\n\n  function creditAvailable(address _strategy) external view returns (uint256);\n\n  function availableDepositLimit() external view returns (uint256);\n\n  function expectedReturn() external view returns (uint256);\n\n  function expectedReturn(address _strategy) external view returns (uint256);\n\n  function report(\n    uint256 _gain,\n    uint256 _loss,\n    uint256 _debtPayment\n  ) external returns (uint256);\n\n  function sweep(address _token) external;\n\n  function sweep(address _token, uint256 _amount) external;\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint256);\n\n  function balanceOf(address _arg0) external view returns (uint256);\n\n  function allowance(address _arg0, address _arg1) external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function token() external view returns (address);\n\n  function governance() external view returns (address);\n\n  function management() external view returns (address);\n\n  function guardian() external view returns (address);\n\n  function strategies(address _arg0) external view returns (StrategyParams memory);\n\n  function withdrawalQueue(uint256 _arg0) external view returns (address);\n\n  function emergencyShutdown() external view returns (bool);\n\n  function depositLimit() external view returns (uint256);\n\n  function debtRatio() external view returns (uint256);\n\n  function totalIdle() external view returns (uint256);\n\n  function totalDebt() external view returns (uint256);\n\n  function lastReport() external view returns (uint256);\n\n  function activation() external view returns (uint256);\n\n  function lockedProfit() external view returns (uint256);\n\n  function lockedProfitDegradation() external view returns (uint256);\n\n  function rewards() external view returns (address);\n\n  function managementFee() external view returns (uint256);\n\n  function performanceFee() external view returns (uint256);\n\n  function nonces(address _arg0) external view returns (uint256);\n}\n\nstruct StrategyParams {\n  uint256 performanceFee;\n  uint256 activation;\n  uint256 debtRatio;\n  uint256 minDebtPerHarvest;\n  uint256 maxDebtPerHarvest;\n  uint256 lastReport;\n  uint256 totalDebt;\n  uint256 totalGain;\n  uint256 totalLoss;\n}\n"
39     },
40     "@yearn-mechanics/contract-utils/solidity/contracts/utils/Machinery.sol": {
41       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport '../../interfaces/utils/IMachinery.sol';\nimport '../../interfaces/mechanics/IMechanicsRegistry.sol';\n\ncontract Machinery is IMachinery {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  IMechanicsRegistry internal _mechanicsRegistry;\n\n  constructor(address __mechanicsRegistry) {\n    _setMechanicsRegistry(__mechanicsRegistry);\n  }\n\n  modifier onlyMechanic() {\n    require(_mechanicsRegistry.isMechanic(msg.sender), 'Machinery: not mechanic');\n    _;\n  }\n\n  function setMechanicsRegistry(address __mechanicsRegistry) external virtual override {\n    _setMechanicsRegistry(__mechanicsRegistry);\n  }\n\n  function _setMechanicsRegistry(address __mechanicsRegistry) internal {\n    _mechanicsRegistry = IMechanicsRegistry(__mechanicsRegistry);\n  }\n\n  // View helpers\n  function mechanicsRegistry() external view override returns (address _mechanicRegistry) {\n    return address(_mechanicsRegistry);\n  }\n\n  function isMechanic(address _mechanic) public view override returns (bool _isMechanic) {\n    return _mechanicsRegistry.isMechanic(_mechanic);\n  }\n}\n"
42     },
43     "solidity/contracts/utils/Governable.sol": {
44       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport '../../interfaces/utils/IGovernable.sol';\n\nabstract contract Governable is IGovernable {\n  /// @inheritdoc IGovernable\n  address public governor;\n  /// @inheritdoc IGovernable\n  address public pendingGovernor;\n\n  constructor(address _governor) {\n    if (_governor == address(0)) revert ZeroAddress();\n    governor = _governor;\n  }\n\n  // methods\n\n  /// @inheritdoc IGovernable\n  function setPendingGovernor(address _pendingGovernor) external onlyGovernor {\n    _setPendingGovernor(_pendingGovernor);\n  }\n\n  /// @inheritdoc IGovernable\n  function acceptPendingGovernor() external onlyPendingGovernor {\n    _acceptPendingGovernor();\n  }\n\n  // modifiers\n\n  modifier onlyGovernor() {\n    if (msg.sender != governor) revert OnlyGovernor();\n    _;\n  }\n\n  modifier onlyPendingGovernor() {\n    if (msg.sender != pendingGovernor) revert OnlyPendingGovernor();\n    _;\n  }\n\n  // internals\n\n  function _setPendingGovernor(address _pendingGovernor) internal {\n    if (_pendingGovernor == address(0)) revert ZeroAddress();\n    pendingGovernor = _pendingGovernor;\n    emit PendingGovernorSet(governor, pendingGovernor);\n  }\n\n  function _acceptPendingGovernor() internal {\n    governor = pendingGovernor;\n    pendingGovernor = address(0);\n    emit PendingGovernorAccepted(governor);\n  }\n}\n"
45     },
46     "@yearn-mechanics/contract-utils/solidity/interfaces/utils/IMachinery.sol": {
47       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\ninterface IMachinery {\n  // View helpers\n  function mechanicsRegistry() external view returns (address _mechanicsRegistry);\n\n  function isMechanic(address mechanic) external view returns (bool _isMechanic);\n\n  // Setters\n  function setMechanicsRegistry(address _mechanicsRegistry) external;\n}\n"
48     },
49     "@yearn-mechanics/contract-utils/solidity/interfaces/mechanics/IMechanicsRegistry.sol": {
50       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\ninterface IMechanicsRegistry {\n  event MechanicAdded(address _mechanic);\n  event MechanicRemoved(address _mechanic);\n\n  function addMechanic(address _mechanic) external;\n\n  function removeMechanic(address _mechanic) external;\n\n  function mechanics() external view returns (address[] memory _mechanicsList);\n\n  function isMechanic(address mechanic) external view returns (bool _isMechanic);\n}\n"
51     },
52     "solidity/interfaces/utils/IGovernable.sol": {
53       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IBaseErrors.sol';\n\ninterface IGovernable is IBaseErrors {\n  // events\n\n  /// @notice Emitted when a new pending governor is set\n  /// @param _governor Address of the current governor\n  /// @param _pendingGovernor Address of the proposed next governor\n  event PendingGovernorSet(address _governor, address _pendingGovernor);\n\n  /// @notice Emitted when a new governor is set\n  /// @param _newGovernor Address of the new governor\n  event PendingGovernorAccepted(address _newGovernor);\n\n  // errors\n\n  /// @notice Throws if a non-governor user tries to call a OnlyGovernor function\n  error OnlyGovernor();\n  /// @notice Throws if a non-pending-governor user tries to call a OnlyPendingGovernor function\n  error OnlyPendingGovernor();\n\n  // views\n\n  /// @return _governor Address of the current governor\n  function governor() external view returns (address _governor);\n\n  /// @return _pendingGovernor Address of the current pending governor\n  function pendingGovernor() external view returns (address _pendingGovernor);\n\n  // methods\n\n  /// @notice Allows a governor to propose a new governor\n  /// @param _pendingGovernor Address of the proposed new governor\n  function setPendingGovernor(address _pendingGovernor) external;\n\n  /// @notice Allows a proposed governor to accept the governance\n  function acceptPendingGovernor() external;\n}\n"
54     },
55     "solidity/interfaces/utils/IBaseErrors.sol": {
56       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.4 <0.9.0;\n\ninterface IBaseErrors {\n  /// @notice Throws if a variable is assigned to the zero address\n  error ZeroAddress();\n\n  /// @notice Throws if a set of correlated input param arrays differ in lengths\n  error WrongLengths();\n}\n"
57     },
58     "solidity/interfaces/utils/IPausable.sol": {
59       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IGovernable.sol';\n\ninterface IPausable is IGovernable {\n  // events\n\n  /// @notice Emitted when the contract pause is switched\n  /// @param _paused Whether the contract is paused or not\n  event PauseSet(bool _paused);\n\n  // errors\n\n  /// @notice Throws when a keeper tries to work a paused contract\n  error Paused();\n\n  /// @notice Throws when governor tries to switch pause to the same state as before\n  error NoChangeInPause();\n\n  // views\n\n  /// @return _paused Whether the contract is paused or not\n  function paused() external view returns (bool _paused);\n\n  // methods\n\n  /// @notice Allows governor to pause or unpause the contract\n  /// @param _paused Whether the contract should be paused or not\n  function setPause(bool _paused) external;\n}\n"
60     },
61     "solidity/contracts/utils/Keep3rMeteredJob.sol": {
62       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport './Keep3rJob.sol';\nimport '../../interfaces/external/IKeep3rHelper.sol';\nimport '../../interfaces/utils/IKeep3rMeteredJob.sol';\n\nabstract contract Keep3rMeteredJob is IKeep3rMeteredJob, Keep3rJob {\n  /// @inheritdoc IKeep3rMeteredJob\n  address public keep3rHelper = 0xeDDe080E28Eb53532bD1804de51BD9Cd5cADF0d4;\n  /// @inheritdoc IKeep3rMeteredJob\n  uint256 public gasBonus = 102_000;\n  /// @inheritdoc IKeep3rMeteredJob\n  uint256 public gasMultiplier = 10_000;\n  /// @inheritdoc IKeep3rMeteredJob\n  uint32 public constant BASE = 10_000;\n  /// @inheritdoc IKeep3rMeteredJob\n  uint256 public maxMultiplier = 15_000;\n\n  // setters\n\n  /// @inheritdoc IKeep3rMeteredJob\n  function setKeep3rHelper(address _keep3rHelper) public onlyGovernor {\n    _setKeep3rHelper(_keep3rHelper);\n  }\n\n  /// @inheritdoc IKeep3rMeteredJob\n  function setGasBonus(uint256 _gasBonus) external onlyGovernor {\n    _setGasBonus(_gasBonus);\n  }\n\n  /// @inheritdoc IKeep3rMeteredJob\n  function setMaxMultiplier(uint256 _maxMultiplier) external onlyGovernor {\n    _setMaxMultiplier(_maxMultiplier);\n  }\n\n  /// @inheritdoc IKeep3rMeteredJob\n  function setGasMultiplier(uint256 _gasMultiplier) external onlyGovernor {\n    _setGasMultiplier(_gasMultiplier);\n  }\n\n  // modifiers\n\n  modifier upkeepMetered() {\n    uint256 _initialGas = gasleft();\n    _isValidKeeper(msg.sender);\n    _;\n    uint256 _gasAfterWork = gasleft();\n    uint256 _reward = IKeep3rHelper(keep3rHelper).getRewardAmountFor(msg.sender, _initialGas - _gasAfterWork + gasBonus);\n    _reward = (_reward * gasMultiplier) / BASE;\n    IKeep3rV2(keep3r).bondedPayment(msg.sender, _reward);\n    emit GasMetered(_initialGas, _gasAfterWork, gasBonus);\n  }\n\n  // internals\n\n  function _setKeep3rHelper(address _keep3rHelper) internal {\n    keep3rHelper = _keep3rHelper;\n    emit Keep3rHelperSet(_keep3rHelper);\n  }\n\n  function _setGasBonus(uint256 _gasBonus) internal {\n    gasBonus = _gasBonus;\n    emit GasBonusSet(gasBonus);\n  }\n\n  function _setMaxMultiplier(uint256 _maxMultiplier) internal {\n    maxMultiplier = _maxMultiplier;\n    emit MaxMultiplierSet(maxMultiplier);\n  }\n\n  function _setGasMultiplier(uint256 _gasMultiplier) internal {\n    if (_gasMultiplier > maxMultiplier) revert MaxMultiplier();\n    gasMultiplier = _gasMultiplier;\n    emit GasMultiplierSet(gasMultiplier);\n  }\n\n  function _calculateCredits(uint256 _gasUsed) internal view returns (uint256 _credits) {\n    return IKeep3rHelper(keep3rHelper).getRewardAmount(_gasUsed);\n  }\n}\n"
63     },
64     "solidity/contracts/utils/Keep3rBondedJob.sol": {
65       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport './Keep3rJob.sol';\nimport '../../interfaces/utils/IKeep3rBondedJob.sol';\n\nabstract contract Keep3rBondedJob is IKeep3rBondedJob, Keep3rJob {\n  /// @inheritdoc IKeep3rBondedJob\n  address public requiredBond = 0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44;\n  /// @inheritdoc IKeep3rBondedJob\n  uint256 public requiredMinBond = 50 ether;\n  /// @inheritdoc IKeep3rBondedJob\n  uint256 public requiredEarnings;\n  /// @inheritdoc IKeep3rBondedJob\n  uint256 public requiredAge;\n\n  // methods\n\n  /// @inheritdoc IKeep3rBondedJob\n  function setKeep3rRequirements(\n    address _bond,\n    uint256 _minBond,\n    uint256 _earned,\n    uint256 _age\n  ) public onlyGovernor {\n    _setKeep3rRequirements(_bond, _minBond, _earned, _age);\n  }\n\n  // internals\n\n  function _setKeep3rRequirements(\n    address _bond,\n    uint256 _minBond,\n    uint256 _earned,\n    uint256 _age\n  ) internal {\n    requiredBond = _bond;\n    requiredMinBond = _minBond;\n    requiredEarnings = _earned;\n    requiredAge = _age;\n    emit Keep3rRequirementsSet(_bond, _minBond, _earned, _age);\n  }\n\n  function _isValidKeeper(address _keeper) internal virtual override {\n    if (!IKeep3rV2(keep3r).isBondedKeeper(_keeper, requiredBond, requiredMinBond, requiredEarnings, requiredAge)) revert KeeperNotValid();\n  }\n}\n"
66     },
67     "solidity/contracts/utils/OnlyEOA.sol": {
68       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport '../../interfaces/utils/IOnlyEOA.sol';\nimport './Governable.sol';\n\nabstract contract OnlyEOA is IOnlyEOA, Governable {\n  /// @inheritdoc IOnlyEOA\n  bool public onlyEOA;\n\n  // methods\n\n  /// @inheritdoc IOnlyEOA\n  function setOnlyEOA(bool _onlyEOA) external onlyGovernor {\n    _setOnlyEOA(_onlyEOA);\n  }\n\n  // internals\n\n  function _setOnlyEOA(bool _onlyEOA) internal {\n    onlyEOA = _onlyEOA;\n    emit OnlyEOASet(_onlyEOA);\n  }\n\n  function _validateEOA(address _caller) internal view {\n    // solhint-disable-next-line avoid-tx-origin\n    if (_caller != tx.origin) revert OnlyEOA();\n  }\n}\n"
69     },
70     "solidity/contracts/utils/Keep3rJob.sol": {
71       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport './Governable.sol';\nimport '../../interfaces/utils/IKeep3rJob.sol';\nimport '../../interfaces/external/IKeep3rV2.sol';\n\nabstract contract Keep3rJob is IKeep3rJob, Governable {\n  /// @inheritdoc IKeep3rJob\n  address public keep3r = 0xeb02addCfD8B773A5FFA6B9d1FE99c566f8c44CC;\n\n  // methods\n\n  /// @inheritdoc IKeep3rJob\n  function setKeep3r(address _keep3r) public onlyGovernor {\n    _setKeep3r(_keep3r);\n  }\n\n  // modifiers\n\n  modifier upkeep() {\n    _isValidKeeper(msg.sender);\n    _;\n    IKeep3rV2(keep3r).worked(msg.sender);\n  }\n\n  // internals\n\n  function _setKeep3r(address _keep3r) internal {\n    keep3r = _keep3r;\n    emit Keep3rSet(_keep3r);\n  }\n\n  function _isValidKeeper(address _keeper) internal virtual {\n    if (!IKeep3rV2(keep3r).isKeeper(_keeper)) revert KeeperNotValid();\n  }\n}\n"
72     },
73     "solidity/interfaces/external/IKeep3rHelper.sol": {
74       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n/// @title Keep3rHelper contract\n/// @notice Contains all the helper functions used throughout the different files.\ninterface IKeep3rHelper {\n  // Errors\n\n  /// @notice Throws when none of the tokens in the liquidity pair is KP3R\n  error LiquidityPairInvalid();\n\n  // Variables\n\n  /// @notice Address of KP3R token\n  /// @return _kp3r Address of KP3R token\n  // solhint-disable func-name-mixedcase\n  function KP3R() external view returns (address _kp3r);\n\n  /// @notice Address of KP3R-WETH pool to use as oracle\n  /// @return _kp3rWeth Address of KP3R-WETH pool to use as oracle\n  function KP3R_WETH_POOL() external view returns (address _kp3rWeth);\n\n  /// @notice The minimum multiplier used to calculate the amount of gas paid to the Keeper for the gas used to perform a job\n  ///         For example: if the quoted gas used is 1000, then the minimum amount to be paid will be 1000 * MIN / BOOST_BASE\n  /// @return _multiplier The MIN multiplier\n  function MIN() external view returns (uint256 _multiplier);\n\n  /// @notice The maximum multiplier used to calculate the amount of gas paid to the Keeper for the gas used to perform a job\n  ///         For example: if the quoted gas used is 1000, then the maximum amount to be paid will be 1000 * MAX / BOOST_BASE\n  /// @return _multiplier The MAX multiplier\n  function MAX() external view returns (uint256 _multiplier);\n\n  /// @notice The boost base used to calculate the boost rewards for the keeper\n  /// @return _base The boost base number\n  function BOOST_BASE() external view returns (uint256 _base);\n\n  /// @notice The targeted amount of bonded KP3Rs to max-up reward multiplier\n  ///         For example: if the amount of KP3R the keeper has bonded is TARGETBOND or more, then the keeper will get\n  ///                      the maximum boost possible in his rewards, if it's less, the reward boost will be proportional\n  /// @return _target The amount of KP3R that comforms the TARGETBOND\n  function TARGETBOND() external view returns (uint256 _target);\n\n  // Methods\n  // solhint-enable func-name-mixedcase\n\n  /// @notice Calculates the amount of KP3R that corresponds to the ETH passed into the function\n  /// @dev This function allows us to calculate how much KP3R we should pay to a keeper for things expressed in ETH, like gas\n  /// @param _eth The amount of ETH\n  /// @return _amountOut The amount of KP3R\n  function quote(uint256 _eth) external view returns (uint256 _amountOut);\n\n  /// @notice Returns the amount of KP3R the keeper has bonded\n  /// @param _keeper The address of the keeper to check\n  /// @return _amountBonded The amount of KP3R the keeper has bonded\n  function bonds(address _keeper) external view returns (uint256 _amountBonded);\n\n  /// @notice Calculates the reward (in KP3R) that corresponds to a keeper for using gas\n  /// @param _keeper The address of the keeper to check\n  /// @param _gasUsed The amount of gas used that will be rewarded\n  /// @return _kp3r The amount of KP3R that should be awarded to the keeper\n  function getRewardAmountFor(address _keeper, uint256 _gasUsed) external view returns (uint256 _kp3r);\n\n  /// @notice Calculates the boost in the reward given to a keeper based on the amount of KP3R that keeper has bonded\n  /// @param _bonds The amount of KP3R tokens bonded by the keeper\n  /// @return _rewardBoost The reward boost that corresponds to the keeper\n  function getRewardBoostFor(uint256 _bonds) external view returns (uint256 _rewardBoost);\n\n  /// @notice Calculates the reward (in KP3R) that corresponds to tx.origin for using gas\n  /// @param _gasUsed The amount of gas used that will be rewarded\n  /// @return _amount The amount of KP3R that should be awarded to tx.origin\n  function getRewardAmount(uint256 _gasUsed) external view returns (uint256 _amount);\n\n  /// @notice Given a pool address, returns the underlying tokens of the pair\n  /// @param _pool Address of the correspondant pool\n  /// @return _token0 Address of the first token of the pair\n  /// @return _token1 Address of the second token of the pair\n  function getPoolTokens(address _pool) external view returns (address _token0, address _token1);\n\n  /// @notice Defines the order of the tokens in the pair for twap calculations\n  /// @param _pool Address of the correspondant pool\n  /// @return _isKP3RToken0 Boolean indicating the order of the tokens in the pair\n  function isKP3RToken0(address _pool) external view returns (bool _isKP3RToken0);\n\n  /// @notice Given an array of secondsAgo, returns UniswapV3 pool cumulatives at that moment\n  /// @param _pool Address of the pool to observe\n  /// @param _secondsAgo Array with time references to observe\n  /// @return _tickCumulative1 Cummulative sum of ticks until first time reference\n  /// @return _tickCumulative2 Cummulative sum of ticks until second time reference\n  /// @return _success Boolean indicating if the observe call was succesfull\n  function observe(address _pool, uint32[] memory _secondsAgo)\n    external\n    view\n    returns (\n      int56 _tickCumulative1,\n      int56 _tickCumulative2,\n      bool _success\n    );\n\n  /// @notice Given a tick and a liquidity amount, calculates the underlying KP3R tokens\n  /// @param _liquidityAmount Amount of liquidity to be converted\n  /// @param _tickDifference Tick value used to calculate the quote\n  /// @param _timeInterval Time value used to calculate the quote\n  /// @return _kp3rAmount Amount of KP3R tokens underlying on the given liquidity\n  function getKP3RsAtTick(\n    uint256 _liquidityAmount,\n    int56 _tickDifference,\n    uint256 _timeInterval\n  ) external pure returns (uint256 _kp3rAmount);\n\n  /// @notice Given a tick and a token amount, calculates the output in correspondant token\n  /// @param _baseAmount Amount of token to be converted\n  /// @param _tickDifference Tick value used to calculate the quote\n  /// @param _timeInterval Time value used to calculate the quote\n  /// @return _quoteAmount Amount of credits deserved for the baseAmount at the tick value\n  function getQuoteAtTick(\n    uint128 _baseAmount,\n    int56 _tickDifference,\n    uint256 _timeInterval\n  ) external pure returns (uint256 _quoteAmount);\n}\n"
75     },
76     "solidity/interfaces/utils/IKeep3rMeteredJob.sol": {
77       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IKeep3rJob.sol';\n\ninterface IKeep3rMeteredJob is IKeep3rJob {\n  // events\n\n  /// @notice Emitted when a new Keep3rHelper contract is set\n  /// @param _keep3rHelper Address of the new Keep3rHelper contract\n  event Keep3rHelperSet(address _keep3rHelper);\n\n  /// @notice Emitted when a new gas bonus amount is set\n  /// @param _gasBonus Amount of gas to add to cover unaccounted gas\n  event GasBonusSet(uint256 _gasBonus);\n\n  /// @notice Emitted when a new gas bonus multiplier is set\n  /// @param _gasMultiplier Multiplier that boosts gas record to calculate the keeper reward\n  event GasMultiplierSet(uint256 _gasMultiplier);\n\n  /// @notice Emitted when a new gas bonus multiplier maximum is set\n  /// @param _maxMultiplier Maximum acceptable gasMultiplier to be set\n  event MaxMultiplierSet(uint256 _maxMultiplier);\n\n  /// @notice Emitted when a metered job is worked\n  /// @param _initialGas First gas record registered\n  /// @param _gasAfterWork Gas record registered after work\n  /// @param _bonus Fixed amount of gas added to the accountance\n  event GasMetered(uint256 _initialGas, uint256 _gasAfterWork, uint256 _bonus);\n\n  // errors\n  error MaxMultiplier();\n\n  // views\n\n  /// @return _keep3rHelper Address of the Keep3rHelper contract\n  function keep3rHelper() external view returns (address _keep3rHelper);\n\n  /// @return _gasBonus Amount of gas to add to cover unaccounted gas\n  function gasBonus() external view returns (uint256 _gasBonus);\n\n  /// @return _gasMultiplier Multiplier that boosts gas record to calculate the keeper reward\n  function gasMultiplier() external view returns (uint256 _gasMultiplier);\n\n  /// @return _maxMultiplier Maximum acceptable gasMultiplier to be set\n  function maxMultiplier() external view returns (uint256 _maxMultiplier);\n\n  // solhint-disable-next-line func-name-mixedcase, var-name-mixedcase\n  function BASE() external view returns (uint32 _BASE);\n\n  // methods\n\n  /// @notice Allows governor to set a new Keep3rHelper contract\n  /// @param _keep3rHelper Address of the new Keep3rHelper contract\n  function setKeep3rHelper(address _keep3rHelper) external;\n\n  /// @notice Allows governor to set a new gas bonus amount\n  /// @param _gasBonus New amount of gas to add to cover unaccounted gas\n  function setGasBonus(uint256 _gasBonus) external;\n\n  /// @notice Allows governor to set a new gas multiplier\n  /// @param _gasMultiplier New multiplier that boosts gas record to calculate the keeper reward\n  function setGasMultiplier(uint256 _gasMultiplier) external;\n\n  /// @notice Allows governor to set a new gas multiplier maximum\n  /// @param _maxMultiplier New maximum acceptable gasMultiplier to be set\n  function setMaxMultiplier(uint256 _maxMultiplier) external;\n}\n"
78     },
79     "solidity/interfaces/utils/IKeep3rJob.sol": {
80       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IGovernable.sol';\n\ninterface IKeep3rJob is IGovernable {\n  // events\n\n  /// @notice Emitted when a new Keep3r contract is set\n  /// @param _keep3r Address of the new Keep3r contract\n  event Keep3rSet(address _keep3r);\n\n  // errors\n\n  /// @notice Throws when a keeper fails the validation\n  error KeeperNotValid();\n\n  // views\n\n  /// @return _keep3r Address of the Keep3r contract\n  function keep3r() external view returns (address _keep3r);\n\n  // methods\n\n  /// @notice Allows governor to set a new Keep3r contract\n  /// @param _keep3r Address of the new Keep3r contract\n  function setKeep3r(address _keep3r) external;\n}\n"
81     },
82     "solidity/interfaces/external/IKeep3rV2.sol": {
83       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\ninterface IKeep3rV2 {\n  /// @notice Stores the tick information of the different liquidity pairs\n  struct TickCache {\n    int56 current; // Tracks the current tick\n    int56 difference; // Stores the difference between the current tick and the last tick\n    uint256 period; // Stores the period at which the last observation was made\n  }\n\n  // Events\n\n  /// @notice Emitted when the Keep3rHelper address is changed\n  /// @param _keep3rHelper The address of Keep3rHelper's contract\n  event Keep3rHelperChange(address _keep3rHelper);\n\n  /// @notice Emitted when the Keep3rV1 address is changed\n  /// @param _keep3rV1 The address of Keep3rV1's contract\n  event Keep3rV1Change(address _keep3rV1);\n\n  /// @notice Emitted when the Keep3rV1Proxy address is changed\n  /// @param _keep3rV1Proxy The address of Keep3rV1Proxy's contract\n  event Keep3rV1ProxyChange(address _keep3rV1Proxy);\n\n  /// @notice Emitted when the KP3R-WETH pool address is changed\n  /// @param _kp3rWethPool The address of the KP3R-WETH pool\n  event Kp3rWethPoolChange(address _kp3rWethPool);\n\n  /// @notice Emitted when bondTime is changed\n  /// @param _bondTime The new bondTime\n  event BondTimeChange(uint256 _bondTime);\n\n  /// @notice Emitted when _liquidityMinimum is changed\n  /// @param _liquidityMinimum The new _liquidityMinimum\n  event LiquidityMinimumChange(uint256 _liquidityMinimum);\n\n  /// @notice Emitted when _unbondTime is changed\n  /// @param _unbondTime The new _unbondTime\n  event UnbondTimeChange(uint256 _unbondTime);\n\n  /// @notice Emitted when _rewardPeriodTime is changed\n  /// @param _rewardPeriodTime The new _rewardPeriodTime\n  event RewardPeriodTimeChange(uint256 _rewardPeriodTime);\n\n  /// @notice Emitted when the inflationPeriod is changed\n  /// @param _inflationPeriod The new inflationPeriod\n  event InflationPeriodChange(uint256 _inflationPeriod);\n\n  /// @notice Emitted when the fee is changed\n  /// @param _fee The new token credits fee\n  event FeeChange(uint256 _fee);\n\n  /// @notice Emitted when a slasher is added\n  /// @param _slasher Address of the added slasher\n  event SlasherAdded(address _slasher);\n\n  /// @notice Emitted when a slasher is removed\n  /// @param _slasher Address of the removed slasher\n  event SlasherRemoved(address _slasher);\n\n  /// @notice Emitted when a disputer is added\n  /// @param _disputer Address of the added disputer\n  event DisputerAdded(address _disputer);\n\n  /// @notice Emitted when a disputer is removed\n  /// @param _disputer Address of the removed disputer\n  event DisputerRemoved(address _disputer);\n\n  /// @notice Emitted when the bonding process of a new keeper begins\n  /// @param _keeper The caller of Keep3rKeeperFundable#bond function\n  /// @param _bonding The asset the keeper has bonded\n  /// @param _amount The amount the keeper has bonded\n  event Bonding(address indexed _keeper, address indexed _bonding, uint256 _amount);\n\n  /// @notice Emitted when a keeper or job begins the unbonding process to withdraw the funds\n  /// @param _keeperOrJob The keeper or job that began the unbonding process\n  /// @param _unbonding The liquidity pair or asset being unbonded\n  /// @param _amount The amount being unbonded\n  event Unbonding(address indexed _keeperOrJob, address indexed _unbonding, uint256 _amount);\n\n  /// @notice Emitted when Keep3rKeeperFundable#activate is called\n  /// @param _keeper The keeper that has been activated\n  /// @param _bond The asset the keeper has bonded\n  /// @param _amount The amount of the asset the keeper has bonded\n  event Activation(address indexed _keeper, address indexed _bond, uint256 _amount);\n\n  /// @notice Emitted when Keep3rKeeperFundable#withdraw is called\n  /// @param _keeper The caller of Keep3rKeeperFundable#withdraw function\n  /// @param _bond The asset to withdraw from the bonding pool\n  /// @param _amount The amount of funds withdrawn\n  event Withdrawal(address indexed _keeper, address indexed _bond, uint256 _amount);\n\n  /// @notice Emitted when Keep3rKeeperDisputable#slash is called\n  /// @param _keeper The slashed keeper\n  /// @param _slasher The user that called Keep3rKeeperDisputable#slash\n  /// @param _amount The amount of credits slashed from the keeper\n  event KeeperSlash(address indexed _keeper, address indexed _slasher, uint256 _amount);\n\n  /// @notice Emitted when Keep3rKeeperDisputable#revoke is called\n  /// @param _keeper The revoked keeper\n  /// @param _slasher The user that called Keep3rKeeperDisputable#revoke\n  event KeeperRevoke(address indexed _keeper, address indexed _slasher);\n\n  /// @notice Emitted when Keep3rJobFundableCredits#addTokenCreditsToJob is called\n  /// @param _job The address of the job being credited\n  /// @param _token The address of the token being provided\n  /// @param _provider The user that calls the function\n  /// @param _amount The amount of credit being added to the job\n  event TokenCreditAddition(address indexed _job, address indexed _token, address indexed _provider, uint256 _amount);\n\n  /// @notice Emitted when Keep3rJobFundableCredits#withdrawTokenCreditsFromJob is called\n  /// @param _job The address of the job from which the credits are withdrawn\n  /// @param _token The credit being withdrawn from the job\n  /// @param _receiver The user that receives the tokens\n  /// @param _amount The amount of credit withdrawn\n  event TokenCreditWithdrawal(address indexed _job, address indexed _token, address indexed _receiver, uint256 _amount);\n\n  /// @notice Emitted when Keep3rJobFundableLiquidity#approveLiquidity function is called\n  /// @param _liquidity The address of the liquidity pair being approved\n  event LiquidityApproval(address _liquidity);\n\n  /// @notice Emitted when Keep3rJobFundableLiquidity#revokeLiquidity function is called\n  /// @param _liquidity The address of the liquidity pair being revoked\n  event LiquidityRevocation(address _liquidity);\n\n  /// @notice Emitted when IKeep3rJobFundableLiquidity#addLiquidityToJob function is called\n  /// @param _job The address of the job to which liquidity will be added\n  /// @param _liquidity The address of the liquidity being added\n  /// @param _provider The user that calls the function\n  /// @param _amount The amount of liquidity being added\n  event LiquidityAddition(address indexed _job, address indexed _liquidity, address indexed _provider, uint256 _amount);\n\n  /// @notice Emitted when IKeep3rJobFundableLiquidity#withdrawLiquidityFromJob function is called\n  /// @param _job The address of the job of which liquidity will be withdrawn from\n  /// @param _liquidity The address of the liquidity being withdrawn\n  /// @param _receiver The receiver of the liquidity tokens\n  /// @param _amount The amount of liquidity being withdrawn from the job\n  event LiquidityWithdrawal(address indexed _job, address indexed _liquidity, address indexed _receiver, uint256 _amount);\n\n  /// @notice Emitted when Keep3rJobFundableLiquidity#addLiquidityToJob function is called\n  /// @param _job The address of the job whose credits will be updated\n  /// @param _rewardedAt The time at which the job was last rewarded\n  /// @param _currentCredits The current credits of the job\n  /// @param _periodCredits The credits of the job for the current period\n  event LiquidityCreditsReward(address indexed _job, uint256 _rewardedAt, uint256 _currentCredits, uint256 _periodCredits);\n\n  /// @notice Emitted when Keep3rJobFundableLiquidity#forceLiquidityCreditsToJob function is called\n  /// @param _job The address of the job whose credits will be updated\n  /// @param _rewardedAt The time at which the job was last rewarded\n  /// @param _currentCredits The current credits of the job\n  event LiquidityCreditsForced(address indexed _job, uint256 _rewardedAt, uint256 _currentCredits);\n\n  /// @notice Emitted when Keep3rJobManager#addJob is called\n  /// @param _job The address of the job to add\n  /// @param _jobOwner The job's owner\n  event JobAddition(address indexed _job, address indexed _jobOwner);\n\n  /// @notice Emitted when a keeper is validated before a job\n  /// @param _gasLeft The amount of gas that the transaction has left at the moment of keeper validation\n  event KeeperValidation(uint256 _gasLeft);\n\n  /// @notice Emitted when a keeper works a job\n  /// @param _credit The address of the asset in which the keeper is paid\n  /// @param _job The address of the job the keeper has worked\n  /// @param _keeper The address of the keeper that has worked the job\n  /// @param _amount The amount that has been paid out to the keeper in exchange for working the job\n  /// @param _gasLeft The amount of gas that the transaction has left at the moment of payment\n  event KeeperWork(address indexed _credit, address indexed _job, address indexed _keeper, uint256 _amount, uint256 _gasLeft);\n\n  /// @notice Emitted when Keep3rJobOwnership#changeJobOwnership is called\n  /// @param _job The address of the job proposed to have a change of owner\n  /// @param _owner The current owner of the job\n  /// @param _pendingOwner The new address proposed to be the owner of the job\n  event JobOwnershipChange(address indexed _job, address indexed _owner, address indexed _pendingOwner);\n\n  /// @notice Emitted when Keep3rJobOwnership#JobOwnershipAssent is called\n  /// @param _job The address of the job which the proposed owner will now own\n  /// @param _previousOwner The previous owner of the job\n  /// @param _newOwner The newowner of the job\n  event JobOwnershipAssent(address indexed _job, address indexed _previousOwner, address indexed _newOwner);\n\n  /// @notice Emitted when Keep3rJobMigration#migrateJob function is called\n  /// @param _fromJob The address of the job that requests to migrate\n  /// @param _toJob The address at which the job requests to migrate\n  event JobMigrationRequested(address indexed _fromJob, address _toJob);\n\n  /// @notice Emitted when Keep3rJobMigration#acceptJobMigration function is called\n  /// @param _fromJob The address of the job that requested to migrate\n  /// @param _toJob The address at which the job had requested to migrate\n  event JobMigrationSuccessful(address _fromJob, address indexed _toJob);\n\n  /// @notice Emitted when Keep3rJobDisputable#slashTokenFromJob is called\n  /// @param _job The address of the job from which the token will be slashed\n  /// @param _token The address of the token being slashed\n  /// @param _slasher The user that slashes the token\n  /// @param _amount The amount of the token being slashed\n  event JobSlashToken(address indexed _job, address _token, address indexed _slasher, uint256 _amount);\n\n  /// @notice Emitted when Keep3rJobDisputable#slashLiquidityFromJob is called\n  /// @param _job The address of the job from which the liquidity will be slashed\n  /// @param _liquidity The address of the liquidity being slashed\n  /// @param _slasher The user that slashes the liquidity\n  /// @param _amount The amount of the liquidity being slashed\n  event JobSlashLiquidity(address indexed _job, address _liquidity, address indexed _slasher, uint256 _amount);\n\n  /// @notice Emitted when a keeper or a job is disputed\n  /// @param _jobOrKeeper The address of the disputed keeper/job\n  /// @param _disputer The user that called the function and disputed the keeper\n  event Dispute(address indexed _jobOrKeeper, address indexed _disputer);\n\n  /// @notice Emitted when a dispute is resolved\n  /// @param _jobOrKeeper The address of the disputed keeper/job\n  /// @param _resolver The user that called the function and resolved the dispute\n  event Resolve(address indexed _jobOrKeeper, address indexed _resolver);\n\n  // Errors\n\n  /// @notice Throws if the reward period is less than the minimum reward period time\n  error MinRewardPeriod();\n\n  /// @notice Throws if either a job or a keeper is disputed\n  error Disputed();\n\n  /// @notice Throws if there are no bonded assets\n  error BondsUnexistent();\n\n  /// @notice Throws if the time required to bond an asset has not passed yet\n  error BondsLocked();\n\n  /// @notice Throws if there are no bonds to withdraw\n  error UnbondsUnexistent();\n\n  /// @notice Throws if the time required to withdraw the bonds has not passed yet\n  error UnbondsLocked();\n\n  /// @notice Throws if the address is already a registered slasher\n  error SlasherExistent();\n\n  /// @notice Throws if caller is not a registered slasher\n  error SlasherUnexistent();\n\n  /// @notice Throws if the address is already a registered disputer\n  error DisputerExistent();\n\n  /// @notice Throws if caller is not a registered disputer\n  error DisputerUnexistent();\n\n  /// @notice Throws if the msg.sender is not a slasher or is not a part of governance\n  error OnlySlasher();\n\n  /// @notice Throws if the msg.sender is not a disputer or is not a part of governance\n  error OnlyDisputer();\n\n  /// @notice Throws when an address is passed as a job, but that address is not a job\n  error JobUnavailable();\n\n  /// @notice Throws when an action that requires an undisputed job is applied on a disputed job\n  error JobDisputed();\n\n  /// @notice Throws when the address that is trying to register as a job is already a job\n  error AlreadyAJob();\n\n  /// @notice Throws when the token is KP3R, as it should not be used for direct token payments\n  error TokenUnallowed();\n\n  /// @notice Throws when the token withdraw cooldown has not yet passed\n  error JobTokenCreditsLocked();\n\n  /// @notice Throws when the user tries to withdraw more tokens than it has\n  error InsufficientJobTokenCredits();\n\n  /// @notice Throws when trying to add a job that has already been added\n  error JobAlreadyAdded();\n\n  /// @notice Throws when the address that is trying to register as a keeper is already a keeper\n  error AlreadyAKeeper();\n\n  /// @notice Throws when the liquidity being approved has already been approved\n  error LiquidityPairApproved();\n\n  /// @notice Throws when the liquidity being removed has not been approved\n  error LiquidityPairUnexistent();\n\n  /// @notice Throws when trying to add liquidity to an unapproved pool\n  error LiquidityPairUnapproved();\n\n  /// @notice Throws when the job doesn't have the requested liquidity\n  error JobLiquidityUnexistent();\n\n  /// @notice Throws when trying to remove more liquidity than the job has\n  error JobLiquidityInsufficient();\n\n  /// @notice Throws when trying to add less liquidity than the minimum liquidity required\n  error JobLiquidityLessThanMin();\n\n  /// @notice Throws if a variable is assigned to the zero address\n  error ZeroAddress();\n\n  /// @notice Throws if the address claiming to be a job is not in the list of approved jobs\n  error JobUnapproved();\n\n  /// @notice Throws if the amount of funds in the job is less than the payment that must be paid to the keeper that works that job\n  error InsufficientFunds();\n\n  /// @notice Throws when the caller of the function is not the job owner\n  error OnlyJobOwner();\n\n  /// @notice Throws when the caller of the function is not the pending job owner\n  error OnlyPendingJobOwner();\n\n  /// @notice Throws when the address of the job that requests to migrate wants to migrate to its same address\n  error JobMigrationImpossible();\n\n  /// @notice Throws when the _toJob address differs from the address being tracked in the pendingJobMigrations mapping\n  error JobMigrationUnavailable();\n\n  /// @notice Throws when cooldown between migrations has not yet passed\n  error JobMigrationLocked();\n\n  /// @notice Throws when the token trying to be slashed doesn't exist\n  error JobTokenUnexistent();\n\n  /// @notice Throws when someone tries to slash more tokens than the job has\n  error JobTokenInsufficient();\n\n  /// @notice Throws when a job or keeper is already disputed\n  error AlreadyDisputed();\n\n  /// @notice Throws when a job or keeper is not disputed and someone tries to resolve the dispute\n  error NotDisputed();\n\n  // Variables\n\n  /// @notice Address of Keep3rHelper's contract\n  /// @return _keep3rHelper The address of Keep3rHelper's contract\n  function keep3rHelper() external view returns (address _keep3rHelper);\n\n  /// @notice Address of Keep3rV1's contract\n  /// @return _keep3rV1 The address of Keep3rV1's contract\n  function keep3rV1() external view returns (address _keep3rV1);\n\n  /// @notice Address of Keep3rV1Proxy's contract\n  /// @return _keep3rV1Proxy The address of Keep3rV1Proxy's contract\n  function keep3rV1Proxy() external view returns (address _keep3rV1Proxy);\n\n  /// @notice Address of the KP3R-WETH pool\n  /// @return _kp3rWethPool The address of KP3R-WETH pool\n  function kp3rWethPool() external view returns (address _kp3rWethPool);\n\n  /// @notice The amount of time required to pass after a keeper has bonded assets for it to be able to activate\n  /// @return _days The required bondTime in days\n  function bondTime() external view returns (uint256 _days);\n\n  /// @notice The amount of time required to pass before a keeper can unbond what he has bonded\n  /// @return _days The required unbondTime in days\n  function unbondTime() external view returns (uint256 _days);\n\n  /// @notice The minimum amount of liquidity required to fund a job per liquidity\n  /// @return _amount The minimum amount of liquidity in KP3R\n  function liquidityMinimum() external view returns (uint256 _amount);\n\n  /// @notice The amount of time between each scheduled credits reward given to a job\n  /// @return _days The reward period in days\n  function rewardPeriodTime() external view returns (uint256 _days);\n\n  /// @notice The inflation period is the denominator used to regulate the emission of KP3R\n  /// @return _period The denominator used to regulate the emission of KP3R\n  function inflationPeriod() external view returns (uint256 _period);\n\n  /// @notice The fee to be sent to governance when a user adds liquidity to a job\n  /// @return _amount The fee amount to be sent to governance when a user adds liquidity to a job\n  function fee() external view returns (uint256 _amount);\n\n  // solhint-disable func-name-mixedcase\n  /// @notice The base that will be used to calculate the fee\n  /// @return _base The base that will be used to calculate the fee\n  function BASE() external view returns (uint256 _base);\n\n  /// @notice The minimum rewardPeriodTime value to be set\n  /// @return _minPeriod The minimum reward period in seconds\n  function MIN_REWARD_PERIOD_TIME() external view returns (uint256 _minPeriod);\n\n  /// @notice Maps an address to a boolean to determine whether the address is a slasher or not.\n  /// @return _isSlasher Whether the address is a slasher or not\n  function slashers(address _slasher) external view returns (bool _isSlasher);\n\n  /// @notice Maps an address to a boolean to determine whether the address is a disputer or not.\n  /// @return _isDisputer Whether the address is a disputer or not\n  function disputers(address _disputer) external view returns (bool _isDisputer);\n\n  /// @notice Tracks the total KP3R earnings of a keeper since it started working\n  /// @return _workCompleted Total KP3R earnings of a keeper since it started working\n  function workCompleted(address _keeper) external view returns (uint256 _workCompleted);\n\n  /// @notice Tracks when a keeper was first registered\n  /// @return _timestamp The time at which the keeper was first registered\n  function firstSeen(address _keeper) external view returns (uint256 _timestamp);\n\n  /// @notice Tracks if a keeper or job has a pending dispute\n  /// @return _disputed Whether a keeper or job has a pending dispute\n  function disputes(address _keeperOrJob) external view returns (bool _disputed);\n\n  /// @notice Allows governance to create a dispute for a given keeper/job\n  /// @param _jobOrKeeper The address in dispute\n  function dispute(address _jobOrKeeper) external;\n\n  /// @notice Allows governance to resolve a dispute on a keeper/job\n  /// @param _jobOrKeeper The address cleared\n  function resolve(address _jobOrKeeper) external;\n\n  /// @notice Tracks how much a keeper has bonded of a certain token\n  /// @return _bonds Amount of a certain token that a keeper has bonded\n  function bonds(address _keeper, address _bond) external view returns (uint256 _bonds);\n\n  /// @notice The current token credits available for a job\n  /// @return _amount The amount of token credits available for a job\n  function jobTokenCredits(address _job, address _token) external view returns (uint256 _amount);\n\n  /// @notice Tracks the amount of assets deposited in pending bonds\n  /// @return _pendingBonds Amount of a certain asset a keeper has unbonding\n  function pendingBonds(address _keeper, address _bonding) external view returns (uint256 _pendingBonds);\n\n  /// @notice Tracks when a bonding for a keeper can be activated\n  /// @return _timestamp Time at which the bonding for a keeper can be activated\n  function canActivateAfter(address _keeper, address _bonding) external view returns (uint256 _timestamp);\n\n  /// @notice Tracks when keeper bonds are ready to be withdrawn\n  /// @return _timestamp Time at which the keeper bonds are ready to be withdrawn\n  function canWithdrawAfter(address _keeper, address _bonding) external view returns (uint256 _timestamp);\n\n  /// @notice Tracks how much keeper bonds are to be withdrawn\n  /// @return _pendingUnbonds The amount of keeper bonds that are to be withdrawn\n  function pendingUnbonds(address _keeper, address _bonding) external view returns (uint256 _pendingUnbonds);\n\n  /// @notice Checks whether the address has ever bonded an asset\n  /// @return _hasBonded Whether the address has ever bonded an asset\n  function hasBonded(address _keeper) external view returns (bool _hasBonded);\n\n  /// @notice Last block where tokens were added to the job [job => token => timestamp]\n  /// @return _timestamp The last block where tokens were added to the job\n  function jobTokenCreditsAddedAt(address _job, address _token) external view returns (uint256 _timestamp);\n\n  // Methods\n\n  /// @notice Add credit to a job to be paid out for work\n  /// @param _job The address of the job being credited\n  /// @param _token The address of the token being credited\n  /// @param _amount The amount of credit being added\n  function addTokenCreditsToJob(\n    address _job,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  /// @notice Withdraw credit from a job\n  /// @param _job The address of the job from which the credits are withdrawn\n  /// @param _token The address of the token being withdrawn\n  /// @param _amount The amount of token to be withdrawn\n  /// @param _receiver The user that will receive tokens\n  function withdrawTokenCreditsFromJob(\n    address _job,\n    address _token,\n    uint256 _amount,\n    address _receiver\n  ) external;\n\n  /// @notice Lists liquidity pairs\n  /// @return _list An array of addresses with all the approved liquidity pairs\n  function approvedLiquidities() external view returns (address[] memory _list);\n\n  /// @notice Amount of liquidity in a specified job\n  /// @param _job The address of the job being checked\n  /// @param _liquidity The address of the liquidity we are checking\n  /// @return _amount Amount of liquidity in the specified job\n  function liquidityAmount(address _job, address _liquidity) external view returns (uint256 _amount);\n\n  /// @notice Last time the job was rewarded liquidity credits\n  /// @param _job The address of the job being checked\n  /// @return _timestamp Timestamp of the last time the job was rewarded liquidity credits\n  function rewardedAt(address _job) external view returns (uint256 _timestamp);\n\n  /// @notice Last time the job was worked\n  /// @param _job The address of the job being checked\n  /// @return _timestamp Timestamp of the last time the job was worked\n  function workedAt(address _job) external view returns (uint256 _timestamp);\n\n  /// @notice Maps the job to the owner of the job (job => user)\n  /// @return _owner The addres of the owner of the job\n  function jobOwner(address _job) external view returns (address _owner);\n\n  /// @notice Maps the owner of the job to its pending owner (job => user)\n  /// @return _pendingOwner The address of the pending owner of the job\n  function jobPendingOwner(address _job) external view returns (address _pendingOwner);\n\n  /// @notice Maps the jobs that have requested a migration to the address they have requested to migrate to\n  /// @return _toJob The address to which the job has requested to migrate to\n  function pendingJobMigrations(address _fromJob) external view returns (address _toJob);\n\n  // Methods\n\n  /// @notice Sets the Keep3rHelper address\n  /// @param _keep3rHelper The Keep3rHelper address\n  function setKeep3rHelper(address _keep3rHelper) external;\n\n  /// @notice Sets the Keep3rV1 address\n  /// @param _keep3rV1 The Keep3rV1 address\n  function setKeep3rV1(address _keep3rV1) external;\n\n  /// @notice Sets the Keep3rV1Proxy address\n  /// @param _keep3rV1Proxy The Keep3rV1Proxy address\n  function setKeep3rV1Proxy(address _keep3rV1Proxy) external;\n\n  /// @notice Sets the KP3R-WETH pool address\n  /// @param _kp3rWethPool The KP3R-WETH pool address\n  function setKp3rWethPool(address _kp3rWethPool) external;\n\n  /// @notice Sets the bond time required to activate as a keeper\n  /// @param _bond The new bond time\n  function setBondTime(uint256 _bond) external;\n\n  /// @notice Sets the unbond time required unbond what has been bonded\n  /// @param _unbond The new unbond time\n  function setUnbondTime(uint256 _unbond) external;\n\n  /// @notice Sets the minimum amount of liquidity required to fund a job\n  /// @param _liquidityMinimum The new minimum amount of liquidity\n  function setLiquidityMinimum(uint256 _liquidityMinimum) external;\n\n  /// @notice Sets the time required to pass between rewards for jobs\n  /// @param _rewardPeriodTime The new amount of time required to pass between rewards\n  function setRewardPeriodTime(uint256 _rewardPeriodTime) external;\n\n  /// @notice Sets the new inflation period\n  /// @param _inflationPeriod The new inflation period\n  function setInflationPeriod(uint256 _inflationPeriod) external;\n\n  /// @notice Sets the new fee\n  /// @param _fee The new fee\n  function setFee(uint256 _fee) external;\n\n  /// @notice Registers a slasher by updating the slashers mapping\n  function addSlasher(address _slasher) external;\n\n  /// @notice Removes a slasher by updating the slashers mapping\n  function removeSlasher(address _slasher) external;\n\n  /// @notice Registers a disputer by updating the disputers mapping\n  function addDisputer(address _disputer) external;\n\n  /// @notice Removes a disputer by updating the disputers mapping\n  function removeDisputer(address _disputer) external;\n\n  /// @notice Lists all jobs\n  /// @return _jobList Array with all the jobs in _jobs\n  function jobs() external view returns (address[] memory _jobList);\n\n  /// @notice Lists all keepers\n  /// @return _keeperList Array with all the jobs in keepers\n  function keepers() external view returns (address[] memory _keeperList);\n\n  /// @notice Beginning of the bonding process\n  /// @param _bonding The asset being bound\n  /// @param _amount The amount of bonding asset being bound\n  function bond(address _bonding, uint256 _amount) external;\n\n  /// @notice Beginning of the unbonding process\n  /// @param _bonding The asset being unbound\n  /// @param _amount Allows for partial unbonding\n  function unbond(address _bonding, uint256 _amount) external;\n\n  /// @notice End of the bonding process after bonding time has passed\n  /// @param _bonding The asset being activated as bond collateral\n  function activate(address _bonding) external;\n\n  /// @notice Withdraw funds after unbonding has finished\n  /// @param _bonding The asset to withdraw from the bonding pool\n  function withdraw(address _bonding) external;\n\n  /// @notice Allows governance to slash a keeper based on a dispute\n  /// @param _keeper The address being slashed\n  /// @param _bonded The asset being slashed\n  /// @param _amount The amount being slashed\n  function slash(\n    address _keeper,\n    address _bonded,\n    uint256 _amount\n  ) external;\n\n  /// @notice Blacklists a keeper from participating in the network\n  /// @param _keeper The address being slashed\n  function revoke(address _keeper) external;\n\n  /// @notice Allows any caller to add a new job\n  /// @param _job Address of the contract for which work should be performed\n  function addJob(address _job) external;\n\n  /// @notice Returns the liquidity credits of a given job\n  /// @param _job The address of the job of which we want to know the liquidity credits\n  /// @return _amount The liquidity credits of a given job\n  function jobLiquidityCredits(address _job) external view returns (uint256 _amount);\n\n  /// @notice Returns the credits of a given job for the current period\n  /// @param _job The address of the job of which we want to know the period credits\n  /// @return _amount The credits the given job has at the current period\n  function jobPeriodCredits(address _job) external view returns (uint256 _amount);\n\n  /// @notice Calculates the total credits of a given job\n  /// @param _job The address of the job of which we want to know the total credits\n  /// @return _amount The total credits of the given job\n  function totalJobCredits(address _job) external view returns (uint256 _amount);\n\n  /// @notice Calculates how many credits should be rewarded periodically for a given liquidity amount\n  /// @dev _periodCredits = underlying KP3Rs for given liquidity amount * rewardPeriod / inflationPeriod\n  /// @param _liquidity The liquidity to provide\n  /// @param _amount The amount of liquidity to provide\n  /// @return _periodCredits The amount of KP3R periodically minted for the given liquidity\n  function quoteLiquidity(address _liquidity, uint256 _amount) external view returns (uint256 _periodCredits);\n\n  /// @notice Observes the current state of the liquidity pair being observed and updates TickCache with the information\n  /// @param _liquidity The liquidity pair being observed\n  /// @return _tickCache The updated TickCache\n  function observeLiquidity(address _liquidity) external view returns (TickCache memory _tickCache);\n\n  /// @notice Gifts liquidity credits to the specified job\n  /// @param _job The address of the job being credited\n  /// @param _amount The amount of liquidity credits to gift\n  function forceLiquidityCreditsToJob(address _job, uint256 _amount) external;\n\n  /// @notice Approve a liquidity pair for being accepted in future\n  /// @param _liquidity The address of the liquidity accepted\n  function approveLiquidity(address _liquidity) external;\n\n  /// @notice Revoke a liquidity pair from being accepted in future\n  /// @param _liquidity The liquidity no longer accepted\n  function revokeLiquidity(address _liquidity) external;\n\n  /// @notice Allows anyone to fund a job with liquidity\n  /// @param _job The address of the job to assign liquidity to\n  /// @param _liquidity The liquidity being added\n  /// @param _amount The amount of liquidity tokens to add\n  function addLiquidityToJob(\n    address _job,\n    address _liquidity,\n    uint256 _amount\n  ) external;\n\n  /// @notice Unbond liquidity for a job\n  /// @dev Can only be called by the job's owner\n  /// @param _job The address of the job being unbound from\n  /// @param _liquidity The liquidity being unbound\n  /// @param _amount The amount of liquidity being removed\n  function unbondLiquidityFromJob(\n    address _job,\n    address _liquidity,\n    uint256 _amount\n  ) external;\n\n  /// @notice Withdraw liquidity from a job\n  /// @param _job The address of the job being withdrawn from\n  /// @param _liquidity The liquidity being withdrawn\n  /// @param _receiver The address that will receive the withdrawn liquidity\n  function withdrawLiquidityFromJob(\n    address _job,\n    address _liquidity,\n    address _receiver\n  ) external;\n\n  /// @notice Confirms if the current keeper is registered, can be used for general (non critical) functions\n  /// @param _keeper The keeper being investigated\n  /// @return _isKeeper Whether the address passed as a parameter is a keeper or not\n  function isKeeper(address _keeper) external returns (bool _isKeeper);\n\n  /// @notice Confirms if the current keeper is registered and has a minimum bond of any asset. Should be used for protected functions\n  /// @param _keeper The keeper to check\n  /// @param _bond The bond token being evaluated\n  /// @param _minBond The minimum amount of bonded tokens\n  /// @param _earned The minimum funds earned in the keepers lifetime\n  /// @param _age The minimum keeper age required\n  /// @return _isBondedKeeper Whether the `_keeper` meets the given requirements\n  function isBondedKeeper(\n    address _keeper,\n    address _bond,\n    uint256 _minBond,\n    uint256 _earned,\n    uint256 _age\n  ) external returns (bool _isBondedKeeper);\n\n  /// @notice Implemented by jobs to show that a keeper performed work\n  /// @dev Automatically calculates the payment for the keeper\n  /// @param _keeper Address of the keeper that performed the work\n  function worked(address _keeper) external;\n\n  /// @notice Implemented by jobs to show that a keeper performed work\n  /// @dev Pays the keeper that performs the work with KP3R\n  /// @param _keeper Address of the keeper that performed the work\n  /// @param _payment The reward that should be allocated for the job\n  function bondedPayment(address _keeper, uint256 _payment) external;\n\n  /// @notice Implemented by jobs to show that a keeper performed work\n  /// @dev Pays the keeper that performs the work with a specific token\n  /// @param _token The asset being awarded to the keeper\n  /// @param _keeper Address of the keeper that performed the work\n  /// @param _amount The reward that should be allocated\n  function directTokenPayment(\n    address _token,\n    address _keeper,\n    uint256 _amount\n  ) external;\n\n  /// @notice Proposes a new address to be the owner of the job\n  function changeJobOwnership(address _job, address _newOwner) external;\n\n  /// @notice The proposed address accepts to be the owner of the job\n  function acceptJobOwnership(address _job) external;\n\n  /// @notice Initializes the migration process for a job by adding the request to the pendingJobMigrations mapping\n  /// @param _fromJob The address of the job that is requesting to migrate\n  /// @param _toJob The address at which the job is requesting to migrate\n  function migrateJob(address _fromJob, address _toJob) external;\n\n  /// @notice Completes the migration process for a job\n  /// @dev Unbond/withdraw process doesn't get migrated\n  /// @param _fromJob The address of the job that requested to migrate\n  /// @param _toJob The address to which the job wants to migrate to\n  function acceptJobMigration(address _fromJob, address _toJob) external;\n\n  /// @notice Allows governance or slasher to slash a job specific token\n  /// @param _job The address of the job from which the token will be slashed\n  /// @param _token The address of the token that will be slashed\n  /// @param _amount The amount of the token that will be slashed\n  function slashTokenFromJob(\n    address _job,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  /// @notice Allows governance or a slasher to slash liquidity from a job\n  /// @param _job The address being slashed\n  /// @param _liquidity The address of the liquidity that will be slashed\n  /// @param _amount The amount of liquidity that will be slashed\n  function slashLiquidityFromJob(\n    address _job,\n    address _liquidity,\n    uint256 _amount\n  ) external;\n}\n"
84     },
85     "solidity/interfaces/utils/IKeep3rBondedJob.sol": {
86       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IKeep3rJob.sol';\n\ninterface IKeep3rBondedJob is IKeep3rJob {\n  // events\n\n  /// @notice Emitted when a new set of requirements is set\n  /// @param _bond Address of the token required to bond to work the job\n  /// @param _minBond Amount of tokens required to bond to work the job\n  /// @param _earned Amount of KP3R earnings required to work the job\n  /// @param _age Amount of seconds since keeper registration required to work the job\n  event Keep3rRequirementsSet(address _bond, uint256 _minBond, uint256 _earned, uint256 _age);\n\n  // views\n\n  /// @return _requiredBond Address of the token required to bond to work the job\n  function requiredBond() external view returns (address _requiredBond);\n\n  /// @return _requiredMinBond Amount of tokens required to bond to work the job\n  function requiredMinBond() external view returns (uint256 _requiredMinBond);\n\n  /// @return _requiredEarnings Amount of KP3R earnings required to work the job\n  function requiredEarnings() external view returns (uint256 _requiredEarnings);\n\n  /// @return _requiredAge Amount of seconds since keeper registration required to work the job\n  function requiredAge() external view returns (uint256 _requiredAge);\n\n  // methods\n\n  /// @notice Allows the governor to set new requirements to work the job\n  /// @param _bond Address of the token required to bond to work the job\n  /// @param _minBond Amount of tokens required to bond to work the job\n  /// @param _earned Amount of KP3R earnings required to work the job\n  /// @param _age Amount of seconds since keeper registration required to work the job\n  function setKeep3rRequirements(\n    address _bond,\n    uint256 _minBond,\n    uint256 _earned,\n    uint256 _age\n  ) external;\n}\n"
87     },
88     "solidity/interfaces/utils/IOnlyEOA.sol": {
89       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\ninterface IOnlyEOA {\n  // events\n\n  /// @notice Emitted when onlyEOA is set\n  event OnlyEOASet(bool _onlyEOA);\n\n  // errors\n\n  /// @notice Throws when keeper is not tx.origin\n  error OnlyEOA();\n\n  // views\n\n  /// @return _onlyEOA Whether the keeper is required to be an EOA or not\n  function onlyEOA() external returns (bool _onlyEOA);\n\n  // methods\n\n  /// @notice Allows governor to set the onlyEOA condition\n  /// @param _onlyEOA Whether the keeper is required to be an EOA or not\n  function setOnlyEOA(bool _onlyEOA) external;\n}\n"
90     }
91   },
92   "settings": {
93     "optimizer": {
94       "enabled": true,
95       "runs": 200
96     },
97     "outputSelection": {
98       "*": {
99         "*": [
100           "evm.bytecode",
101           "evm.deployedBytecode",
102           "devdoc",
103           "userdoc",
104           "metadata",
105           "abi"
106         ]
107       }
108     },
109     "metadata": {
110       "useLiteralContent": true
111     },
112     "libraries": {}
113   }
114 }}