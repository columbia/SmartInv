1 {{
2   "language": "Solidity",
3   "sources": {
4     "src/contracts/Exchange.sol": {
5       "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.4;\n\nimport \"../libraries/MathLib.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/IExchangeFactory.sol\";\n\n/**\n * @title Exchange contract for Elastic Swap representing a single ERC20 pair of tokens to be swapped.\n * @author Elastic DAO\n * @notice This contract provides all of the needed functionality for a liquidity provider to supply/withdraw ERC20\n * tokens and traders to swap tokens for one another.\n */\ncontract Exchange is ERC20, ReentrancyGuard {\n    using MathLib for uint256;\n    using SafeERC20 for IERC20;\n\n    address public immutable baseToken; // address of ERC20 base token (elastic or fixed supply)\n    address public immutable quoteToken; // address of ERC20 quote token (WETH or a stable coin w/ fixed supply)\n    address public immutable exchangeFactoryAddress;\n\n    uint256 public constant TOTAL_LIQUIDITY_FEE = 50; // fee provided to liquidity providers + DAO in basis points\n    uint256 public constant MINIMUM_LIQUIDITY = 1e3;\n\n    MathLib.InternalBalances public internalBalances;\n\n    event AddLiquidity(\n        address indexed liquidityProvider,\n        uint256 baseTokenQtyAdded,\n        uint256 quoteTokenQtyAdded\n    );\n    event RemoveLiquidity(\n        address indexed liquidityProvider,\n        uint256 baseTokenQtyRemoved,\n        uint256 quoteTokenQtyRemoved\n    );\n    event Swap(\n        address indexed sender,\n        uint256 baseTokenQtyIn,\n        uint256 quoteTokenQtyIn,\n        uint256 baseTokenQtyOut,\n        uint256 quoteTokenQtyOut\n    );\n\n    /**\n     * @dev Called to check timestamps from users for expiration of their calls.\n     */\n    modifier isNotExpired(uint256 _expirationTimeStamp) {\n        require(_expirationTimeStamp >= block.timestamp, \"Exchange: EXPIRED\");\n        _;\n    }\n\n    /**\n     * @notice called by the exchange factory to create a new erc20 token swap pair (do not call this directly!)\n     * @param _name The human readable name of this pair (also used for the liquidity token name)\n     * @param _symbol Shortened symbol for trading pair (also used for the liquidity token symbol)\n     * @param _baseToken address of the ERC20 base token in the pair. This token can have a fixed or elastic supply\n     * @param _quoteToken address of the ERC20 quote token in the pair. This token is assumed to have a fixed supply.\n     * @param _exchangeFactoryAddress address of the exchange factory\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _baseToken,\n        address _quoteToken,\n        address _exchangeFactoryAddress\n    ) ERC20(_name, _symbol) {\n        baseToken = _baseToken;\n        quoteToken = _quoteToken;\n        exchangeFactoryAddress = _exchangeFactoryAddress;\n    }\n\n    /**\n     * @notice primary entry point for a liquidity provider to add new liquidity (base and quote tokens) to the exchange\n     * and receive liquidity tokens in return.\n     * Requires approvals to be granted to this exchange for both base and quote tokens.\n     * @param _baseTokenQtyDesired qty of baseTokens that you would like to add to the exchange\n     * @param _quoteTokenQtyDesired qty of quoteTokens that you would like to add to the exchange\n     * @param _baseTokenQtyMin minimum acceptable qty of baseTokens that will be added (or transaction will revert)\n     * @param _quoteTokenQtyMin minimum acceptable qty of quoteTokens that will be added (or transaction will revert)\n     * @param _liquidityTokenRecipient address for the exchange to issue the resulting liquidity tokens from\n     * this transaction to\n     * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)\n     */\n    function addLiquidity(\n        uint256 _baseTokenQtyDesired,\n        uint256 _quoteTokenQtyDesired,\n        uint256 _baseTokenQtyMin,\n        uint256 _quoteTokenQtyMin,\n        address _liquidityTokenRecipient,\n        uint256 _expirationTimestamp\n    ) external nonReentrant() isNotExpired(_expirationTimestamp) {\n        uint256 totalSupply = this.totalSupply();\n        MathLib.TokenQtys memory tokenQtys =\n            MathLib.calculateAddLiquidityQuantities(\n                _baseTokenQtyDesired,\n                _quoteTokenQtyDesired,\n                _baseTokenQtyMin,\n                _quoteTokenQtyMin,\n                IERC20(baseToken).balanceOf(address(this)),\n                totalSupply,\n                internalBalances\n            );\n\n        internalBalances.kLast =\n            internalBalances.baseTokenReserveQty *\n            internalBalances.quoteTokenReserveQty;\n\n        if (tokenQtys.liquidityTokenFeeQty != 0) {\n            // mint liquidity tokens to fee address for k growth.\n            _mint(\n                IExchangeFactory(exchangeFactoryAddress).feeAddress(),\n                tokenQtys.liquidityTokenFeeQty\n            );\n        }\n\n        bool isExchangeEmpty = totalSupply == 0;\n        if (isExchangeEmpty) {\n            // check if this the first LP provider, if so, we need to lock some minimum dust liquidity.\n            require(\n                tokenQtys.liquidityTokenQty > MINIMUM_LIQUIDITY,\n                \"Exchange: INITIAL_DEPOSIT_MIN\"\n            );\n            unchecked {\n                tokenQtys.liquidityTokenQty -= MINIMUM_LIQUIDITY;\n            }\n            _mint(address(this), MINIMUM_LIQUIDITY); // mint to this address, total supply will never be 0 again\n        }\n\n        _mint(_liquidityTokenRecipient, tokenQtys.liquidityTokenQty); // mint liquidity tokens to recipient\n\n        if (tokenQtys.baseTokenQty != 0) {\n            // transfer base tokens to Exchange\n            IERC20(baseToken).safeTransferFrom(\n                msg.sender,\n                address(this),\n                tokenQtys.baseTokenQty\n            );\n\n            if (isExchangeEmpty) {\n                require(\n                    IERC20(baseToken).balanceOf(address(this)) ==\n                        tokenQtys.baseTokenQty,\n                    \"Exchange: FEE_ON_TRANSFER_NOT_SUPPORTED\"\n                );\n            }\n        }\n\n        if (tokenQtys.quoteTokenQty != 0) {\n            // transfer quote tokens to Exchange\n            IERC20(quoteToken).safeTransferFrom(\n                msg.sender,\n                address(this),\n                tokenQtys.quoteTokenQty\n            );\n        }\n\n        emit AddLiquidity(\n            msg.sender,\n            tokenQtys.baseTokenQty,\n            tokenQtys.quoteTokenQty\n        );\n    }\n\n    /**\n     * @notice called by a liquidity provider to redeem liquidity tokens from the exchange and receive back\n     * base and quote tokens. Required approvals to be granted to this exchange for the liquidity token\n     * @param _liquidityTokenQty qty of liquidity tokens that you would like to redeem\n     * @param _baseTokenQtyMin minimum acceptable qty of base tokens to receive back (or transaction will revert)\n     * @param _quoteTokenQtyMin minimum acceptable qty of quote tokens to receive back (or transaction will revert)\n     * @param _tokenRecipient address for the exchange to issue the resulting base and\n     * quote tokens from this transaction to\n     * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)\n     */\n    function removeLiquidity(\n        uint256 _liquidityTokenQty,\n        uint256 _baseTokenQtyMin,\n        uint256 _quoteTokenQtyMin,\n        address _tokenRecipient,\n        uint256 _expirationTimestamp\n    ) external nonReentrant() isNotExpired(_expirationTimestamp) {\n        require(this.totalSupply() != 0, \"Exchange: INSUFFICIENT_LIQUIDITY\");\n        require(\n            _baseTokenQtyMin != 0 && _quoteTokenQtyMin != 0,\n            \"Exchange: MINS_MUST_BE_GREATER_THAN_ZERO\"\n        );\n\n        uint256 baseTokenReserveQty =\n            IERC20(baseToken).balanceOf(address(this));\n        uint256 quoteTokenReserveQty =\n            IERC20(quoteToken).balanceOf(address(this));\n\n        uint256 totalSupplyOfLiquidityTokens = this.totalSupply();\n        // calculate any DAO fees here.\n        uint256 liquidityTokenFeeQty =\n            MathLib.calculateLiquidityTokenFees(\n                totalSupplyOfLiquidityTokens,\n                internalBalances\n            );\n\n        // we need to factor this quantity in to any total supply before redemption\n        totalSupplyOfLiquidityTokens += liquidityTokenFeeQty;\n\n        uint256 baseTokenQtyToReturn =\n            (_liquidityTokenQty * baseTokenReserveQty) /\n                totalSupplyOfLiquidityTokens;\n        uint256 quoteTokenQtyToReturn =\n            (_liquidityTokenQty * quoteTokenReserveQty) /\n                totalSupplyOfLiquidityTokens;\n\n        require(\n            baseTokenQtyToReturn >= _baseTokenQtyMin,\n            \"Exchange: INSUFFICIENT_BASE_QTY\"\n        );\n\n        require(\n            quoteTokenQtyToReturn >= _quoteTokenQtyMin,\n            \"Exchange: INSUFFICIENT_QUOTE_QTY\"\n        );\n\n        // this ensures that we are removing the equivalent amount of decay\n        // when this person exits.\n        {\n            //scoping to avoid stack too deep errors\n            uint256 internalBaseTokenReserveQty =\n                internalBalances.baseTokenReserveQty;\n            uint256 baseTokenQtyToRemoveFromInternalAccounting =\n                (_liquidityTokenQty * internalBaseTokenReserveQty) /\n                    totalSupplyOfLiquidityTokens;\n\n            internalBalances.baseTokenReserveQty = internalBaseTokenReserveQty =\n                internalBaseTokenReserveQty -\n                baseTokenQtyToRemoveFromInternalAccounting;\n\n            // We should ensure no possible overflow here.\n            uint256 internalQuoteTokenReserveQty =\n                internalBalances.quoteTokenReserveQty;\n            if (quoteTokenQtyToReturn > internalQuoteTokenReserveQty) {\n                internalBalances\n                    .quoteTokenReserveQty = internalQuoteTokenReserveQty = 0;\n            } else {\n                internalBalances\n                    .quoteTokenReserveQty = internalQuoteTokenReserveQty =\n                    internalQuoteTokenReserveQty -\n                    quoteTokenQtyToReturn;\n            }\n\n            internalBalances.kLast =\n                internalBaseTokenReserveQty *\n                internalQuoteTokenReserveQty;\n        }\n\n        if (liquidityTokenFeeQty != 0) {\n            _mint(\n                IExchangeFactory(exchangeFactoryAddress).feeAddress(),\n                liquidityTokenFeeQty\n            );\n        }\n\n        _burn(msg.sender, _liquidityTokenQty);\n        IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn);\n        IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn);\n        emit RemoveLiquidity(\n            msg.sender,\n            baseTokenQtyToReturn,\n            quoteTokenQtyToReturn\n        );\n    }\n\n    /**\n     * @notice swaps base tokens for a minimum amount of quote tokens.  Fees are included in all transactions.\n     * The exchange must be granted approvals for the base token by the caller.\n     * @param _baseTokenQty qty of base tokens to swap\n     * @param _minQuoteTokenQty minimum qty of quote tokens to receive in exchange for\n     * your base tokens (or the transaction will revert)\n     * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)\n     */\n    function swapBaseTokenForQuoteToken(\n        uint256 _baseTokenQty,\n        uint256 _minQuoteTokenQty,\n        uint256 _expirationTimestamp\n    ) external nonReentrant() isNotExpired(_expirationTimestamp) {\n        require(\n            _baseTokenQty != 0 && _minQuoteTokenQty != 0,\n            \"Exchange: INSUFFICIENT_TOKEN_QTY\"\n        );\n\n        uint256 quoteTokenQty =\n            MathLib.calculateQuoteTokenQty(\n                _baseTokenQty,\n                _minQuoteTokenQty,\n                TOTAL_LIQUIDITY_FEE,\n                internalBalances\n            );\n\n        IERC20(baseToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _baseTokenQty\n        );\n\n        IERC20(quoteToken).safeTransfer(msg.sender, quoteTokenQty);\n        emit Swap(msg.sender, _baseTokenQty, 0, 0, quoteTokenQty);\n    }\n\n    /**\n     * @notice swaps quote tokens for a minimum amount of base tokens.  Fees are included in all transactions.\n     * The exchange must be granted approvals for the quote token by the caller.\n     * @param _quoteTokenQty qty of quote tokens to swap\n     * @param _minBaseTokenQty minimum qty of base tokens to receive in exchange for\n     * your quote tokens (or the transaction will revert)\n     * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)\n     */\n    function swapQuoteTokenForBaseToken(\n        uint256 _quoteTokenQty,\n        uint256 _minBaseTokenQty,\n        uint256 _expirationTimestamp\n    ) external nonReentrant() isNotExpired(_expirationTimestamp) {\n        require(\n            _quoteTokenQty != 0 && _minBaseTokenQty != 0,\n            \"Exchange: INSUFFICIENT_TOKEN_QTY\"\n        );\n\n        uint256 baseTokenQty =\n            MathLib.calculateBaseTokenQty(\n                _quoteTokenQty,\n                _minBaseTokenQty,\n                IERC20(baseToken).balanceOf(address(this)),\n                TOTAL_LIQUIDITY_FEE,\n                internalBalances\n            );\n\n        IERC20(quoteToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _quoteTokenQty\n        );\n\n        IERC20(baseToken).safeTransfer(msg.sender, baseTokenQty);\n        emit Swap(msg.sender, 0, _quoteTokenQty, baseTokenQty, 0);\n    }\n}\n"
6     },
7     "src/libraries/MathLib.sol": {
8       "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.4;\n\n/**\n * @title MathLib\n * @author ElasticDAO\n */\nlibrary MathLib {\n    struct InternalBalances {\n        // x*y=k - we track these internally to compare to actual balances of the ERC20's\n        // in order to calculate the \"decay\" or the amount of balances that are not\n        // participating in the pricing curve and adding additional liquidity to swap.\n        uint256 baseTokenReserveQty; // x\n        uint256 quoteTokenReserveQty; // y\n        uint256 kLast; // as of the last add / rem liquidity event\n    }\n\n    // aids in avoiding stack too deep errors.\n    struct TokenQtys {\n        uint256 baseTokenQty;\n        uint256 quoteTokenQty;\n        uint256 liquidityTokenQty;\n        uint256 liquidityTokenFeeQty;\n    }\n\n    uint256 public constant BASIS_POINTS = 10000;\n    uint256 public constant WAD = 1e18; // represent a decimal with 18 digits of precision\n\n    /**\n     * @dev divides two float values, required since solidity does not handle\n     * floating point values.\n     *\n     * inspiration: https://github.com/dapphub/ds-math/blob/master/src/math.sol\n     *\n     * NOTE: this rounds to the nearest integer (up or down). For example .666666 would end up\n     * rounding to .66667.\n     *\n     * @return uint256 wad value (decimal with 18 digits of precision)\n     */\n    function wDiv(uint256 a, uint256 b) public pure returns (uint256) {\n        return ((a * WAD) + (b / 2)) / b;\n    }\n\n    /**\n     * @dev rounds a integer (a) to the nearest n places.\n     * IE roundToNearest(123, 10) would round to the nearest 10th place (120).\n     */\n    function roundToNearest(uint256 a, uint256 n)\n        public\n        pure\n        returns (uint256)\n    {\n        return ((a + (n / 2)) / n) * n;\n    }\n\n    /**\n     * @dev multiplies two float values, required since solidity does not handle\n     * floating point values\n     *\n     * inspiration: https://github.com/dapphub/ds-math/blob/master/src/math.sol\n     *\n     * @return uint256 wad value (decimal with 18 digits of precision)\n     */\n    function wMul(uint256 a, uint256 b) public pure returns (uint256) {\n        return ((a * b) + (WAD / 2)) / WAD;\n    }\n\n    /**\n     * @dev calculates an absolute diff between two integers. Basically the solidity\n     * equivalent of Math.abs(a-b);\n     */\n    function diff(uint256 a, uint256 b) public pure returns (uint256) {\n        if (a >= b) {\n            return a - b;\n        }\n        return b - a;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 x) public pure returns (uint256 y) {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n\n    /**\n     * @dev defines the amount of decay needed in order for us to require a user to handle the\n     * decay prior to a double asset entry as the equivalent of 1 unit of quote token\n     */\n    function isSufficientDecayPresent(\n        uint256 _baseTokenReserveQty,\n        InternalBalances memory _internalBalances\n    ) public pure returns (bool) {\n        return (wDiv(\n            diff(_baseTokenReserveQty, _internalBalances.baseTokenReserveQty) *\n                WAD,\n            wDiv(\n                _internalBalances.baseTokenReserveQty,\n                _internalBalances.quoteTokenReserveQty\n            )\n        ) >= WAD); // the amount of base token (a) decay is greater than 1 unit of quote token (token b)\n    }\n\n    /**\n     * @dev used to calculate the qty of token a liquidity provider\n     * must add in order to maintain the current reserve ratios\n     * @param _tokenAQty base or quote token qty to be supplied by the liquidity provider\n     * @param _tokenAReserveQty current reserve qty of the base or quote token (same token as tokenA)\n     * @param _tokenBReserveQty current reserve qty of the other base or quote token (not tokenA)\n     */\n    function calculateQty(\n        uint256 _tokenAQty,\n        uint256 _tokenAReserveQty,\n        uint256 _tokenBReserveQty\n    ) public pure returns (uint256 tokenBQty) {\n        require(_tokenAQty != 0, \"MathLib: INSUFFICIENT_QTY\");\n        require(\n            _tokenAReserveQty != 0 && _tokenBReserveQty != 0,\n            \"MathLib: INSUFFICIENT_LIQUIDITY\"\n        );\n        tokenBQty = (_tokenAQty * _tokenBReserveQty) / _tokenAReserveQty;\n    }\n\n    /**\n     * @dev used to calculate the qty of token a trader will receive (less fees)\n     * given the qty of token A they are providing\n     * @param _tokenASwapQty base or quote token qty to be swapped by the trader\n     * @param _tokenAReserveQty current reserve qty of the base or quote token (same token as tokenA)\n     * @param _tokenBReserveQty current reserve qty of the other base or quote token (not tokenA)\n     * @param _liquidityFeeInBasisPoints fee to liquidity providers represented in basis points\n     */\n    function calculateQtyToReturnAfterFees(\n        uint256 _tokenASwapQty,\n        uint256 _tokenAReserveQty,\n        uint256 _tokenBReserveQty,\n        uint256 _liquidityFeeInBasisPoints\n    ) public pure returns (uint256 qtyToReturn) {\n        uint256 tokenASwapQtyLessFee =\n            _tokenASwapQty * (BASIS_POINTS - _liquidityFeeInBasisPoints);\n        qtyToReturn =\n            (tokenASwapQtyLessFee * _tokenBReserveQty) /\n            ((_tokenAReserveQty * BASIS_POINTS) + tokenASwapQtyLessFee);\n    }\n\n    /**\n     * @dev used to calculate the qty of liquidity tokens (deltaRo) we will be issued to a supplier\n     * of a single asset entry when base token decay is present.\n     * @param _baseTokenReserveBalance the total balance (external) of base tokens in our pool (Alpha)\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _tokenQtyAToAdd the amount of tokens being added by the caller to remove the current decay\n     * @param _internalTokenAReserveQty the internal balance (X or Y) of token A as a result of this transaction\n     * @param _omega - ratio of internal balances of baseToken and quoteToken: baseToken/quoteToken\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateLiquidityTokenQtyForSingleAssetEntryWithBaseTokenDecay(\n        uint256 _baseTokenReserveBalance,\n        uint256 _totalSupplyOfLiquidityTokens,\n        uint256 _tokenQtyAToAdd,\n        uint256 _internalTokenAReserveQty,\n        uint256 _omega\n    ) public pure returns (uint256 liquidityTokenQty) {\n        /**\n        \n        (is the formula in the terms of quoteToken)\n                    ΔY \n            = ---------------------                                                    \n                Alpha/Omega + Y'\n\n\n         */\n        uint256 wRatio = wDiv(_baseTokenReserveBalance, _omega);\n        uint256 denominator = wRatio + _internalTokenAReserveQty;\n        uint256 wGamma = wDiv(_tokenQtyAToAdd, denominator);\n\n        liquidityTokenQty =\n            wDiv(\n                wMul(_totalSupplyOfLiquidityTokens * WAD, wGamma),\n                WAD - wGamma\n            ) /\n            WAD;\n    }\n\n    /**\n     * @dev used to calculate the qty of liquidity tokens (deltaRo) we will be issued to a supplier\n     * of a single asset entry when quote decay is present.\n     * @param _baseTokenReserveBalance the total balance (external) of base tokens in our pool (Alpha)\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _tokenQtyAToAdd the amount of tokens being added by the caller to remove the current decay\n     * @param _internalTokenAReserveQty the internal balance (X or Y) of token A as a result of this transaction\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateLiquidityTokenQtyForSingleAssetEntryWithQuoteTokenDecay(\n        uint256 _baseTokenReserveBalance,\n        uint256 _totalSupplyOfLiquidityTokens,\n        uint256 _tokenQtyAToAdd,\n        uint256 _internalTokenAReserveQty\n    ) public pure returns (uint256 liquidityTokenQty) {\n        /**\n        \n               ΔX\n        = -------------------  / (denominator may be Alpha' instead of X)\n           X + (Alpha + ΔX)\n\n        */\n\n        uint256 denominator =\n            _internalTokenAReserveQty +\n                _baseTokenReserveBalance +\n                _tokenQtyAToAdd;\n        uint256 wGamma = wDiv(_tokenQtyAToAdd, denominator);\n\n        liquidityTokenQty =\n            wDiv(\n                wMul(_totalSupplyOfLiquidityTokens * WAD, wGamma),\n                WAD - wGamma\n            ) /\n            WAD;\n    }\n\n    /**\n     * @dev used to calculate the qty of liquidity tokens (deltaRo) we will be issued to a supplier\n     * of a single asset entry when decay is present.\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _quoteTokenQty the amount of quote token the user it adding to the pool (deltaB or deltaY)\n     * @param _quoteTokenReserveBalance the total balance (external) of quote tokens in our pool (Beta)\n     *\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateLiquidityTokenQtyForDoubleAssetEntry(\n        uint256 _totalSupplyOfLiquidityTokens,\n        uint256 _quoteTokenQty,\n        uint256 _quoteTokenReserveBalance\n    ) public pure returns (uint256 liquidityTokenQty) {\n        liquidityTokenQty =\n            (_quoteTokenQty * _totalSupplyOfLiquidityTokens) /\n            _quoteTokenReserveBalance;\n    }\n\n    /**\n     * @dev used to calculate the qty of quote token required and liquidity tokens (deltaRo) to be issued\n     * in order to add liquidity and remove base token decay.\n     * @param _quoteTokenQtyDesired the amount of quote token the user wants to contribute\n     * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     *\n     * @return quoteTokenQty qty of quote token the user must supply\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateAddQuoteTokenLiquidityQuantities(\n        uint256 _quoteTokenQtyDesired,\n        uint256 _baseTokenReserveQty,\n        uint256 _totalSupplyOfLiquidityTokens,\n        InternalBalances storage _internalBalances\n    ) public returns (uint256 quoteTokenQty, uint256 liquidityTokenQty) {\n        uint256 baseTokenDecay =\n            _baseTokenReserveQty - _internalBalances.baseTokenReserveQty;\n\n        // determine max amount of quote token that can be added to offset the current decay\n        uint256 wInternalBaseTokenToQuoteTokenRatio =\n            wDiv(\n                _internalBalances.baseTokenReserveQty,\n                _internalBalances.quoteTokenReserveQty\n            );\n\n        // alphaDecay / omega (A/B)\n        uint256 maxQuoteTokenQty =\n            wDiv(baseTokenDecay, wInternalBaseTokenToQuoteTokenRatio);\n\n        if (_quoteTokenQtyDesired > maxQuoteTokenQty) {\n            quoteTokenQty = maxQuoteTokenQty;\n        } else {\n            quoteTokenQty = _quoteTokenQtyDesired;\n        }\n\n        uint256 baseTokenQtyDecayChange =\n            roundToNearest(\n                (quoteTokenQty * wInternalBaseTokenToQuoteTokenRatio),\n                WAD\n            ) / WAD;\n\n        require(\n            baseTokenQtyDecayChange != 0,\n            \"MathLib: INSUFFICIENT_CHANGE_IN_DECAY\"\n        );\n        //x += alphaDecayChange\n        //y += deltaBeta\n        _internalBalances.baseTokenReserveQty += baseTokenQtyDecayChange;\n        _internalBalances.quoteTokenReserveQty += quoteTokenQty;\n\n        // calculate the number of liquidity tokens to return to user using\n        liquidityTokenQty = calculateLiquidityTokenQtyForSingleAssetEntryWithBaseTokenDecay(\n            _baseTokenReserveQty,\n            _totalSupplyOfLiquidityTokens,\n            quoteTokenQty,\n            _internalBalances.quoteTokenReserveQty,\n            wInternalBaseTokenToQuoteTokenRatio\n        );\n        return (quoteTokenQty, liquidityTokenQty);\n    }\n\n    /**\n     * @dev used to calculate the qty of base tokens required and liquidity tokens (deltaRo) to be issued\n     * in order to add liquidity and remove base token decay.\n     * @param _baseTokenQtyDesired the amount of base token the user wants to contribute\n     * @param _baseTokenQtyMin the minimum amount of base token the user wants to contribute (allows for slippage)\n     * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return baseTokenQty qty of base token the user must supply\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateAddBaseTokenLiquidityQuantities(\n        uint256 _baseTokenQtyDesired,\n        uint256 _baseTokenQtyMin,\n        uint256 _baseTokenReserveQty,\n        uint256 _totalSupplyOfLiquidityTokens,\n        InternalBalances memory _internalBalances\n    ) public pure returns (uint256 baseTokenQty, uint256 liquidityTokenQty) {\n        uint256 maxBaseTokenQty =\n            _internalBalances.baseTokenReserveQty - _baseTokenReserveQty;\n        require(\n            _baseTokenQtyMin <= maxBaseTokenQty,\n            \"MathLib: INSUFFICIENT_DECAY\"\n        );\n\n        if (_baseTokenQtyDesired > maxBaseTokenQty) {\n            baseTokenQty = maxBaseTokenQty;\n        } else {\n            baseTokenQty = _baseTokenQtyDesired;\n        }\n\n        // determine the quote token qty decay change quoted on our current ratios\n        uint256 wInternalQuoteToBaseTokenRatio =\n            wDiv(\n                _internalBalances.quoteTokenReserveQty,\n                _internalBalances.baseTokenReserveQty\n            );\n\n        // NOTE we need this function to use the same\n        // rounding scheme as wDiv in order to avoid a case\n        // in which a user is trying to resolve decay in which\n        // quoteTokenQtyDecayChange ends up being 0 and we are stuck in\n        // a bad state.\n        uint256 quoteTokenQtyDecayChange =\n            roundToNearest(\n                (baseTokenQty * wInternalQuoteToBaseTokenRatio),\n                MathLib.WAD\n            ) / WAD;\n\n        require(\n            quoteTokenQtyDecayChange != 0,\n            \"MathLib: INSUFFICIENT_CHANGE_IN_DECAY\"\n        );\n\n        // we can now calculate the total amount of quote token decay\n        uint256 quoteTokenDecay =\n            (maxBaseTokenQty * wInternalQuoteToBaseTokenRatio) / WAD;\n\n        // this may be redundant quoted on the above math, but will check to ensure the decay wasn't so small\n        // that it was <1 and rounded down to 0 saving the caller some gas\n        // also could fix a potential revert due to div by zero.\n        require(quoteTokenDecay != 0, \"MathLib: NO_QUOTE_DECAY\");\n\n        // we are not changing anything about our internal accounting here. We are simply adding tokens\n        // to make our internal account \"right\"...or rather getting the external balances to match our internal\n        // quoteTokenReserveQty += quoteTokenQtyDecayChange;\n        // baseTokenReserveQty += baseTokenQty;\n\n        // calculate the number of liquidity tokens to return to user using:\n        liquidityTokenQty = calculateLiquidityTokenQtyForSingleAssetEntryWithQuoteTokenDecay(\n            _baseTokenReserveQty,\n            _totalSupplyOfLiquidityTokens,\n            baseTokenQty,\n            _internalBalances.baseTokenReserveQty\n        );\n    }\n\n    /**\n     * @dev used to calculate the qty of tokens a user will need to contribute and be issued in order to add liquidity\n     * @param _baseTokenQtyDesired the amount of base token the user wants to contribute\n     * @param _quoteTokenQtyDesired the amount of quote token the user wants to contribute\n     * @param _baseTokenQtyMin the minimum amount of base token the user wants to contribute (allows for slippage)\n     * @param _quoteTokenQtyMin the minimum amount of quote token the user wants to contribute (allows for slippage)\n     * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return tokenQtys qty of tokens needed to complete transaction\n     */\n    function calculateAddLiquidityQuantities(\n        uint256 _baseTokenQtyDesired,\n        uint256 _quoteTokenQtyDesired,\n        uint256 _baseTokenQtyMin,\n        uint256 _quoteTokenQtyMin,\n        uint256 _baseTokenReserveQty,\n        uint256 _totalSupplyOfLiquidityTokens,\n        InternalBalances storage _internalBalances\n    ) public returns (TokenQtys memory tokenQtys) {\n        if (_totalSupplyOfLiquidityTokens != 0) {\n            // we have outstanding liquidity tokens present and an existing price curve\n\n            tokenQtys.liquidityTokenFeeQty = calculateLiquidityTokenFees(\n                _totalSupplyOfLiquidityTokens,\n                _internalBalances\n            );\n\n            // we need to take this amount (that will be minted) into account for below calculations\n            _totalSupplyOfLiquidityTokens += tokenQtys.liquidityTokenFeeQty;\n\n            // confirm that we have no beta or alpha decay present\n            // if we do, we need to resolve that first\n            if (\n                isSufficientDecayPresent(\n                    _baseTokenReserveQty,\n                    _internalBalances\n                )\n            ) {\n                // decay is present and needs to be dealt with by the caller.\n\n                uint256 baseTokenQtyFromDecay;\n                uint256 quoteTokenQtyFromDecay;\n                uint256 liquidityTokenQtyFromDecay;\n\n                if (\n                    _baseTokenReserveQty > _internalBalances.baseTokenReserveQty\n                ) {\n                    // we have more base token than expected (base token decay) due to rebase up\n                    // we first need to handle this situation by requiring this user\n                    // to add quote tokens\n                    (\n                        quoteTokenQtyFromDecay,\n                        liquidityTokenQtyFromDecay\n                    ) = calculateAddQuoteTokenLiquidityQuantities(\n                        _quoteTokenQtyDesired,\n                        _baseTokenReserveQty,\n                        _totalSupplyOfLiquidityTokens,\n                        _internalBalances\n                    );\n                } else {\n                    // we have less base token than expected (quote token decay) due to a rebase down\n                    // we first need to handle this by adding base tokens to offset this.\n                    (\n                        baseTokenQtyFromDecay,\n                        liquidityTokenQtyFromDecay\n                    ) = calculateAddBaseTokenLiquidityQuantities(\n                        _baseTokenQtyDesired,\n                        0, // there is no minimum for this particular call since we may use base tokens later.\n                        _baseTokenReserveQty,\n                        _totalSupplyOfLiquidityTokens,\n                        _internalBalances\n                    );\n                }\n\n                if (\n                    quoteTokenQtyFromDecay < _quoteTokenQtyDesired &&\n                    baseTokenQtyFromDecay < _baseTokenQtyDesired\n                ) {\n                    // the user still has qty that they desire to contribute to the exchange for liquidity\n                    (\n                        tokenQtys.baseTokenQty,\n                        tokenQtys.quoteTokenQty,\n                        tokenQtys.liquidityTokenQty\n                    ) = calculateAddTokenPairLiquidityQuantities(\n                        _baseTokenQtyDesired - baseTokenQtyFromDecay, // safe from underflow quoted on above IF\n                        _quoteTokenQtyDesired - quoteTokenQtyFromDecay, // safe from underflow quoted on above IF\n                        0, // we will check minimums below\n                        0, // we will check minimums below\n                        _totalSupplyOfLiquidityTokens +\n                            liquidityTokenQtyFromDecay,\n                        _internalBalances // NOTE: these balances have already been updated when we did the decay math.\n                    );\n                }\n                tokenQtys.baseTokenQty += baseTokenQtyFromDecay;\n                tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay;\n                tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay;\n\n                require(\n                    tokenQtys.baseTokenQty >= _baseTokenQtyMin,\n                    \"MathLib: INSUFFICIENT_BASE_QTY\"\n                );\n\n                require(\n                    tokenQtys.quoteTokenQty >= _quoteTokenQtyMin,\n                    \"MathLib: INSUFFICIENT_QUOTE_QTY\"\n                );\n            } else {\n                // the user is just doing a simple double asset entry / providing both base and quote.\n                (\n                    tokenQtys.baseTokenQty,\n                    tokenQtys.quoteTokenQty,\n                    tokenQtys.liquidityTokenQty\n                ) = calculateAddTokenPairLiquidityQuantities(\n                    _baseTokenQtyDesired,\n                    _quoteTokenQtyDesired,\n                    _baseTokenQtyMin,\n                    _quoteTokenQtyMin,\n                    _totalSupplyOfLiquidityTokens,\n                    _internalBalances\n                );\n            }\n        } else {\n            // this user will set the initial pricing curve\n            require(\n                _baseTokenQtyDesired != 0,\n                \"MathLib: INSUFFICIENT_BASE_QTY_DESIRED\"\n            );\n            require(\n                _quoteTokenQtyDesired != 0,\n                \"MathLib: INSUFFICIENT_QUOTE_QTY_DESIRED\"\n            );\n\n            tokenQtys.baseTokenQty = _baseTokenQtyDesired;\n            tokenQtys.quoteTokenQty = _quoteTokenQtyDesired;\n            tokenQtys.liquidityTokenQty = sqrt(\n                _baseTokenQtyDesired * _quoteTokenQtyDesired\n            );\n\n            _internalBalances.baseTokenReserveQty += tokenQtys.baseTokenQty;\n            _internalBalances.quoteTokenReserveQty += tokenQtys.quoteTokenQty;\n        }\n    }\n\n    /**\n     * @dev calculates the qty of base and quote tokens required and liquidity tokens (deltaRo) to be issued\n     * in order to add liquidity when no decay is present.\n     * @param _baseTokenQtyDesired the amount of base token the user wants to contribute\n     * @param _quoteTokenQtyDesired the amount of quote token the user wants to contribute\n     * @param _baseTokenQtyMin the minimum amount of base token the user wants to contribute (allows for slippage)\n     * @param _quoteTokenQtyMin the minimum amount of quote token the user wants to contribute (allows for slippage)\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return baseTokenQty qty of base token the user must supply\n     * @return quoteTokenQty qty of quote token the user must supply\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateAddTokenPairLiquidityQuantities(\n        uint256 _baseTokenQtyDesired,\n        uint256 _quoteTokenQtyDesired,\n        uint256 _baseTokenQtyMin,\n        uint256 _quoteTokenQtyMin,\n        uint256 _totalSupplyOfLiquidityTokens,\n        InternalBalances storage _internalBalances\n    )\n        public\n        returns (\n            uint256 baseTokenQty,\n            uint256 quoteTokenQty,\n            uint256 liquidityTokenQty\n        )\n    {\n        uint256 requiredQuoteTokenQty =\n            calculateQty(\n                _baseTokenQtyDesired,\n                _internalBalances.baseTokenReserveQty,\n                _internalBalances.quoteTokenReserveQty\n            );\n\n        if (requiredQuoteTokenQty <= _quoteTokenQtyDesired) {\n            // user has to provide less than their desired amount\n            require(\n                requiredQuoteTokenQty >= _quoteTokenQtyMin,\n                \"MathLib: INSUFFICIENT_QUOTE_QTY\"\n            );\n            baseTokenQty = _baseTokenQtyDesired;\n            quoteTokenQty = requiredQuoteTokenQty;\n        } else {\n            // we need to check the opposite way.\n            uint256 requiredBaseTokenQty =\n                calculateQty(\n                    _quoteTokenQtyDesired,\n                    _internalBalances.quoteTokenReserveQty,\n                    _internalBalances.baseTokenReserveQty\n                );\n\n            require(\n                requiredBaseTokenQty >= _baseTokenQtyMin,\n                \"MathLib: INSUFFICIENT_BASE_QTY\"\n            );\n            baseTokenQty = requiredBaseTokenQty;\n            quoteTokenQty = _quoteTokenQtyDesired;\n        }\n\n        liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(\n            _totalSupplyOfLiquidityTokens,\n            quoteTokenQty,\n            _internalBalances.quoteTokenReserveQty\n        );\n\n        _internalBalances.baseTokenReserveQty += baseTokenQty;\n        _internalBalances.quoteTokenReserveQty += quoteTokenQty;\n    }\n\n    /**\n     * @dev calculates the qty of base tokens a user will receive for swapping their quote tokens (less fees)\n     * @param _quoteTokenQty the amount of quote tokens the user wants to swap\n     * @param _baseTokenQtyMin the minimum about of base tokens they are willing to receive in return (slippage)\n     * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction\n     * @param _liquidityFeeInBasisPoints the current total liquidity fee represented as an integer of basis points\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return baseTokenQty qty of base token the user will receive back\n     */\n    function calculateBaseTokenQty(\n        uint256 _quoteTokenQty,\n        uint256 _baseTokenQtyMin,\n        uint256 _baseTokenReserveQty,\n        uint256 _liquidityFeeInBasisPoints,\n        InternalBalances storage _internalBalances\n    ) public returns (uint256 baseTokenQty) {\n        require(\n            _baseTokenReserveQty != 0 &&\n                _internalBalances.baseTokenReserveQty != 0,\n            \"MathLib: INSUFFICIENT_BASE_TOKEN_QTY\"\n        );\n\n        // check to see if we have experience quote token decay / a rebase down event\n        if (_baseTokenReserveQty < _internalBalances.baseTokenReserveQty) {\n            // we have less reserves than our current price curve will expect, we need to adjust the curve\n            uint256 wPricingRatio =\n                wDiv(\n                    _internalBalances.baseTokenReserveQty,\n                    _internalBalances.quoteTokenReserveQty\n                ); // omega\n\n            uint256 impliedQuoteTokenQty =\n                wDiv(_baseTokenReserveQty, wPricingRatio); // no need to divide by WAD, wPricingRatio is already a WAD.\n\n            baseTokenQty = calculateQtyToReturnAfterFees(\n                _quoteTokenQty,\n                impliedQuoteTokenQty,\n                _baseTokenReserveQty, // use the actual balance here since we adjusted the quote token to match ratio!\n                _liquidityFeeInBasisPoints\n            );\n        } else {\n            // we have the same or more reserves, no need to alter the curve.\n            baseTokenQty = calculateQtyToReturnAfterFees(\n                _quoteTokenQty,\n                _internalBalances.quoteTokenReserveQty,\n                _internalBalances.baseTokenReserveQty,\n                _liquidityFeeInBasisPoints\n            );\n        }\n\n        require(\n            baseTokenQty >= _baseTokenQtyMin,\n            \"MathLib: INSUFFICIENT_BASE_TOKEN_QTY\"\n        );\n\n        _internalBalances.baseTokenReserveQty -= baseTokenQty;\n        _internalBalances.quoteTokenReserveQty += _quoteTokenQty;\n    }\n\n    /**\n     * @dev calculates the qty of quote tokens a user will receive for swapping their base tokens (less fees)\n     * @param _baseTokenQty the amount of bases tokens the user wants to swap\n     * @param _quoteTokenQtyMin the minimum about of quote tokens they are willing to receive in return (slippage)\n     * @param _liquidityFeeInBasisPoints the current total liquidity fee represented as an integer of basis points\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return quoteTokenQty qty of quote token the user will receive back\n     */\n    function calculateQuoteTokenQty(\n        uint256 _baseTokenQty,\n        uint256 _quoteTokenQtyMin,\n        uint256 _liquidityFeeInBasisPoints,\n        InternalBalances storage _internalBalances\n    ) public returns (uint256 quoteTokenQty) {\n        require(\n            _baseTokenQty != 0 && _quoteTokenQtyMin != 0,\n            \"MathLib: INSUFFICIENT_TOKEN_QTY\"\n        );\n\n        quoteTokenQty = calculateQtyToReturnAfterFees(\n            _baseTokenQty,\n            _internalBalances.baseTokenReserveQty,\n            _internalBalances.quoteTokenReserveQty,\n            _liquidityFeeInBasisPoints\n        );\n\n        require(\n            quoteTokenQty >= _quoteTokenQtyMin,\n            \"MathLib: INSUFFICIENT_QUOTE_TOKEN_QTY\"\n        );\n\n        _internalBalances.baseTokenReserveQty += _baseTokenQty;\n        _internalBalances.quoteTokenReserveQty -= quoteTokenQty;\n    }\n\n    /**\n     * @dev calculates the qty of liquidity tokens that should be sent to the DAO due to the growth in K from trading.\n     * 50BPS is the total fee, 25 goes to the LPs, 5 BP to the DAO, and 20 BP to staking rewards and liquidity incentives\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return liquidityTokenFeeQty qty of tokens to be minted to the fee address for the growth in K\n     */\n    function calculateLiquidityTokenFees(\n        uint256 _totalSupplyOfLiquidityTokens,\n        InternalBalances memory _internalBalances\n    ) public pure returns (uint256 liquidityTokenFeeQty) {\n        uint256 rootK =\n            sqrt(\n                _internalBalances.baseTokenReserveQty *\n                    _internalBalances.quoteTokenReserveQty\n            );\n        uint256 rootKLast = sqrt(_internalBalances.kLast);\n        if (rootK > rootKLast) {\n            uint256 numerator =\n                _totalSupplyOfLiquidityTokens * (rootK - rootKLast);\n            uint256 denominator = rootK * 2;\n            liquidityTokenFeeQty = numerator / denominator;\n        }\n    }\n}\n"
9     },
10     "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
12     },
13     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
15     },
16     "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
18     },
19     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
21     },
22     "src/interfaces/IExchangeFactory.sol": {
23       "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.4;\n\ninterface IExchangeFactory {\n    function feeAddress() external view returns (address);\n}\n"
24     },
25     "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
27     },
28     "@openzeppelin/contracts/utils/Context.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
30     },
31     "@openzeppelin/contracts/utils/Address.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
33     }
34   },
35   "settings": {
36     "optimizer": {
37       "enabled": true,
38       "runs": 100000
39     },
40     "outputSelection": {
41       "*": {
42         "*": [
43           "evm.bytecode",
44           "evm.deployedBytecode",
45           "devdoc",
46           "userdoc",
47           "metadata",
48           "abi"
49         ]
50       }
51     },
52     "metadata": {
53       "useLiteralContent": true
54     },
55     "libraries": {
56       "src/libraries/MathLib.sol": {
57         "MathLib": "0xe3c08c95aa81474f44bee23f8c45d470ddad37be"
58       }
59     }
60   }
61 }}