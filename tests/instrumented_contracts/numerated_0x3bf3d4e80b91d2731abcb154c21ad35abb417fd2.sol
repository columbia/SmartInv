1 {"ERC721Token.sol":{"content":"pragma solidity ^0.4.22;\n\nimport \"./SafeMath.sol\";\nimport \"./oly.sol\";\n/**\n * @title Etherpoly\n * Etherpoly DApp based on the ERC721 standard\n */\ncontract ERC721Token {\n  using SafeMath for uint256;\n\n  string public constant name = \"Etherpoly\"; \n  string public constant symbol = \"POLY\"; \n  uint8 public constant decimals = 0;\n  uint256 private constant olyDecimals = 10 ** 3;\n\n  // Total amount of tokens\n  uint256 public totalTokens;\n\n  // Index for CityDB Mapping \n  uint256 public tokensIndex;\n\n  // Owner of contract\n  address private creator;\n\n   // Owner of contract \n  address private olyAddress;\n\n  // Total Balance of users (without counting Contract) \n  uint256 public totalUsersBalance;\n\n   // Mapping from user address to user balance\n  mapping (address =\u003e uint256) private usersBalance; \n\n  // Mapping from token ID to owner\n  mapping (uint256 =\u003e address) private tokenOwner;\n\n  // Mapping from token ID to approved address\n  mapping (uint256 =\u003e address) private tokenApprovals;\n\n  // Mapping from owner to list of owned token IDs\n  mapping (address =\u003e uint256[]) private ownedTokens;\n\n  // Mapping from token ID to index of the owner tokens list\n  mapping(uint256 =\u003e uint256) private ownedTokensIndex;\n\n  // Core structure for Cities\n  struct CityStruct {\n    bytes32 name;\n    bytes16 country;\n    uint32 pop;\n    int32 lat;\n    int32 long;\n    uint8 upgType;\n    uint32 finneyValue;\n    uint64 olyValue;\n  }\n\n  // Core structure for Countries\n  struct CountryStruct {\n    uint32 pop;\n    uint64 gdp;\n  }\n\n  // Mapping from Token ID to City Struct ID \n  mapping(uint256 =\u003e CityStruct) public CityDB;\n\n  // Mapping from City\u0027s Country name to Country \n  mapping (bytes16 =\u003e CountryStruct) public Countries;\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n  event Upgrade(uint256 indexed _tokenId, uint8 _upgradeType);\n\n  modifier onlyCreator() {\n    require(creator == msg.sender);\n    _;\n  }\n\n  modifier onlyOwnerOf(uint256 _tokenId) {\n    require(ownerOf(_tokenId) == msg.sender);\n    _;\n  }\n\n  modifier cityExists(uint256 _tokenId) {\n  require(CityDB[_tokenId].pop \u003e 0);\n  _;\n}\n\n  function() public payable {}\n\n  function totalSupply() public view returns (uint256) {\n    return totalTokens;\n  }\n\n\n  function balanceOf(address _owner) public view returns (uint256) {\n    return ownedTokens[_owner].length;\n  }\n\n  function tokensOf(address _owner) public view returns (uint256[]) {\n    return ownedTokens[_owner];\n  }\n\n  function ownerOf(uint256 _tokenId) public view returns (address) {\n    address owner = tokenOwner[_tokenId];\n    require(owner != address(0));\n    return owner;\n  }\n\n  function approvedFor(uint256 _tokenId) public view returns (address) {\n    return tokenApprovals[_tokenId];\n  }\n\n  function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {\n    require(_to != address(this));\n    clearApprovalAndTransfer(msg.sender, _to, _tokenId);\n  }\n\n  function buyTokenWei(uint256 _tokenId) public payable cityExists (_tokenId) {\n \n    address _tokenOwner = ownerOf(_tokenId);\n    require (CityDB[_tokenId].finneyValue != 0);\n    uint256 _weiValue = CityDB[_tokenId].finneyValue;\n    _weiValue = _weiValue.mul(1000000000000000);\n    //_weiValue *= 1000000000000000;\n    require (msg.value \u003e= _weiValue);\n    require (msg.sender != _tokenOwner);\n\n    // Withdraw final OLY revenues for token owner\n    uint256 _hourlyRevenues = getCityRevenuesValue(_tokenId);\n    Oly olyInstance = Oly(olyAddress);  \n    olyInstance.polyUpdateRevenues(_tokenOwner, _tokenId, _hourlyRevenues);\n\n    // applying 5% commission fees, to remove from the msg value before application\n    uint256 updateValueCom = msg.value;\n    updateValueCom = updateValueCom.mul(95);\n    updateValueCom = updateValueCom.div(100);\n\n    // checking possible overflow or division malfunctions (not necessary with safemath)\n    //require (updateValueCom \u003c msg.value);\n\n    // updates the wei balance of the token seller\n    usersBalance[_tokenOwner] = usersBalance[_tokenOwner].add(updateValueCom); \n    totalUsersBalance = totalUsersBalance.add(updateValueCom);\n\n    // transfer when balances have been updated\n    clearApprovalAndTransfer(_tokenOwner, msg.sender, _tokenId);\n\n    // set eth and oly sale values to 0  \n    CityDB[_tokenId].finneyValue = 0;\n    CityDB[_tokenId].olyValue = 0;  \n  }\n\n  function setTokenFinneyValue(uint32 _amount, uint256 _tokenId) public onlyOwnerOf(_tokenId) cityExists (_tokenId) {\n    CityDB[_tokenId].finneyValue = _amount;\n    // updating the price, 0 = not for sale, only from Owner of token\n  }\n\n  function setTokenOlyValue(uint64 _amount, uint256 _tokenId) public onlyOwnerOf(_tokenId) cityExists (_tokenId) {\n    CityDB[_tokenId].olyValue = _amount;\n    // updating the price, 0 = not for sale, only from Owner of token\n  }\n/*\n  function setCityUpg(uint8 _upgType, uint256 _tokenId) public onlyOwnerOf(_tokenId) {\n    // must add payable with OLY, \n    // must add checks for OLY balance, \n    // must register date of upgrade for revenues calculation\n\n    // only allow one of 4 initial types of upgrades including 0 (no upgrades)\n    require(_upgType \u003c= 4);\n    CityDB[_tokenId].upgType = _upgType;\n\n  } \n*/\n\n  // return Users Balance for user address\n  function getUsersBalance(address _addr) public view returns (uint256 userBalance) {\n    userBalance = usersBalance[_addr];\n    return userBalance;\n  } \n\n  // Withdrawing Users Balance\n  function withdrawUsers() external payable returns(uint256 paidUserBalance) {\n    uint256 _userBalance = usersBalance[msg.sender];\n    address _contractAddr = this;\n    require(_userBalance != 0);\n    require(_contractAddr.balance \u003e= _userBalance);\n\n    usersBalance[msg.sender] = 0;\n    totalUsersBalance = totalUsersBalance.sub(_userBalance);\n\n    //msg.sender.transfer(_userBalance);\n    assert(msg.sender.send(_userBalance));\n    return _userBalance;\n  }\n\n  // Withdrawing Contract Balance\n  function withdrawContract() external payable onlyCreator() {\n    address _contractAddr = this;\n    uint256 _contractBalance = _contractAddr.balance;\n    _contractBalance = _contractBalance.sub(totalUsersBalance);\n    require(_contractBalance \u003e 0);\n    creator.transfer(_contractBalance);\n  }\n\n  function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) cityExists (_tokenId) {\n    address owner = ownerOf(_tokenId);\n    require(_to != owner);\n    if (approvedFor(_tokenId) != 0 || _to != 0) {\n      tokenApprovals[_tokenId] = _to;\n      emit Approval(owner, _to, _tokenId);\n    }\n  }\n\n  function takeOwnership(uint256 _tokenId) public {\n    require(isApprovedFor(msg.sender, _tokenId));\n    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);\n  }\n\n  function _mintCity(address _to, bytes32 _name, bytes16 _country, uint32 _pop, int32 _lat, int32 _long, uint32 _finney, uint64 _oly) public {\n    require(_to != address(0));\n    require(_pop \u003e 0);\n    require(Countries[_country].gdp != 0);\n    //uint256 _tokenId = totalTokens;\n    uint256 _tokenId = tokensIndex;\n    require (CityDB[_tokenId].name == \"\");\n\n    CityDB[_tokenId] = CityStruct (_name, _country, _pop, _lat, _long, 0, _finney, _oly);\n    addToken(_to, _tokenId);\n    tokensIndex = tokensIndex.add(1);\n    emit Transfer(0x0, _to, _tokenId);\n\n  }\n\n  function _burn(uint256 _tokenId) onlyOwnerOf(_tokenId) cityExists (_tokenId) public {\n    if (approvedFor(_tokenId) != 0) {\n      clearApproval(msg.sender, _tokenId);\n    }\n    removeToken(msg.sender, _tokenId);\n\n    CityDB[_tokenId].name = \u0027\u0027;\n    CityDB[_tokenId].country = \u0027\u0027;\n    CityDB[_tokenId].pop = 0;\n    CityDB[_tokenId].lat = 0;\n    CityDB[_tokenId].long = 0;\n    CityDB[_tokenId].upgType = 0;\n    CityDB[_tokenId].finneyValue= 0;\n    CityDB[_tokenId].olyValue = 0;\n    emit Transfer(msg.sender, 0x0, _tokenId);\n  }\n\n\n  function isApprovedFor(address _owner, uint256 _tokenId) internal view returns (bool) {\n    return approvedFor(_tokenId) == _owner;\n  }\n\n  function clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {\n    require(_to != address(0));\n    require(_to != ownerOf(_tokenId));\n    require(ownerOf(_tokenId) == _from);\n\n    clearApproval(_from, _tokenId);\n    removeToken(_from, _tokenId);\n    addToken(_to, _tokenId);\n    emit Transfer(_from, _to, _tokenId);\n  }\n\n  function clearApproval(address _owner, uint256 _tokenId) private {\n    require(ownerOf(_tokenId) == _owner);\n    tokenApprovals[_tokenId] = 0;\n    emit Approval(_owner, 0, _tokenId);\n  }\n\n  function addToken(address _to, uint256 _tokenId) private {\n    require(tokenOwner[_tokenId] == address(0));\n    tokenOwner[_tokenId] = _to;\n    uint256 length = balanceOf(_to);\n    ownedTokens[_to].push(_tokenId);\n    ownedTokensIndex[_tokenId] = length;\n    totalTokens = totalTokens.add(1);\n  }\n\n  function removeToken(address _from, uint256 _tokenId) private {\n    require(ownerOf(_tokenId) == _from);\n\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\n    uint256 lastTokenIndex = balanceOf(_from).sub(1);\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n\n    tokenOwner[_tokenId] = 0;\n    ownedTokens[_from][tokenIndex] = lastToken;\n    ownedTokens[_from][lastTokenIndex] = 0;\n\n    ownedTokens[_from].length--;\n    ownedTokensIndex[_tokenId] = 0;\n    ownedTokensIndex[lastToken] = tokenIndex;\n    totalTokens = totalTokens.sub(1);\n  }\n\n  constructor () public payable {\n\n  creator = msg.sender;\n\n  // Initial countries creation \n  Countries[\"United States\"] = CountryStruct (323100000,18570);\n  Countries[\"China\"] = CountryStruct (1379000000,11200);\n  Countries[\"France\"] = CountryStruct (66900000,2465);\n  Countries[\"South Korea\"] = CountryStruct (51107797,1411);\n  Countries[\"Japan\"] = CountryStruct (126194685,4884);\n  Countries[\"Germany\"] = CountryStruct (81365343,3652);\n  Countries[\"United Kingdom\"] = CountryStruct (65861628,2565);\n  Countries[\"India\"] = CountryStruct (1355621800,2439);\n  Countries[\"Brazil\"] = CountryStruct (213202329,2081);\n  Countries[\"Italy\"] = CountryStruct (59932451,1921);\n  Countries[\"Canada\"] = CountryStruct (36991986,1640);\n  Countries[\"Russia\"] = CountryStruct (146466710,1469);\n  Countries[\"Australia\"] = CountryStruct (25039715,1390);\n  Countries[\"Spain\"] = CountryStruct (45878041,1307);\n  Countries[\"Mexico\"] = CountryStruct (131951936,1142);\n  Countries[\"Indonesia\"] = CountryStruct (266895567,1011);\n  Countries[\"Turkey\"] = CountryStruct (82491371,841);\n  Countries[\"Netherlands\"] = CountryStruct (17090565,824);\n  Countries[\"Switzerland\"] = CountryStruct (8573481,681);\n  Countries[\"Saudi Arabia\"] = CountryStruct (33645897,679);\n  Countries[\"Argentina\"] = CountryStruct (44684737,620);\n  Countries[\"Taiwan\"] = CountryStruct (23591604,571);\n  Countries[\"Sweden\"] = CountryStruct (10008633,542);\n  Countries[\"Poland\"] = CountryStruct (38639940,510);\n  Countries[\"Belgium\"] = CountryStruct (11510188,492);\n  Countries[\"Thailand\"] = CountryStruct (68684785,438);\n  Countries[\"Iran\"] = CountryStruct (81938060,428);\n  Countries[\"Austria\"] = CountryStruct (25039734,409);\n  Countries[\"Egypt\"] = CountryStruct (97187207,408);\n  Countries[\"Nigeria\"] = CountryStruct (22176294,395);\n  Countries[\"Norway\"] = CountryStruct (5397619,392);\n  Countries[\"UAE\"] = CountryStruct (9542843,379);\n  Countries[\"Israel\"] = CountryStruct (8446249,348);\n  Countries[\"South Africa\"] = CountryStruct (56175824,344);\n  Countries[\"Hong Kong\"] = CountryStruct (7455354,334);\n  Countries[\"Ireland\"] = CountryStruct (4728945,326);\n  Countries[\"Denmark\"] = CountryStruct (5736458,324);\n  Countries[\"Malaysia\"] = CountryStruct (31637840,310);\n  Countries[\"Colombia\"] = CountryStruct (49571747,307);\n  Countries[\"Singapore\"] = CountryStruct (5921295,306);\n  Countries[\"Pakistan\"] = CountryStruct (200195156,304);\n  Countries[\"Chile\"] = CountryStruct (18487758,263);\n  Countries[\"Finland\"] = CountryStruct (5581914,251);\n  Countries[\"Vietnam\"] = CountryStruct (96392488,216);\n  Countries[\"Venezuela\"] = CountryStruct (32347707,215);\n  Countries[\"Portugal\"] = CountryStruct (10224152,212);\n  Countries[\"Peru\"] = CountryStruct (32543775,210);\n  Countries[\"Romania\"] = CountryStruct (19078379,205);\n  Countries[\"Greece\"] = CountryStruct (10833357,204);\n  Countries[\"New Zealand\"] = CountryStruct (4618946,201);\n  Countries[\"Iraq\"] = CountryStruct (39880904,193);\n  Countries[\"Qatar\"] = CountryStruct (2562082,166);\n  Countries[\"Hungary\"] = CountryStruct (9768789,132);\n  Countries[\"Kuwait\"] = CountryStruct (4457395,118);\n  Countries[\"Morocco\"] = CountryStruct (35280000,111);\n  Countries[\"Ukraine\"] = CountryStruct (42264829,104);\n  Countries[\"Puerto Rico\"] = CountryStruct (3667634,103);\n  Countries[\"Lebanon\"] = CountryStruct (6927630,53);\n  Countries[\"Cote d\u0027Ivoire\"] = CountryStruct (24244054,40);\n  Countries[\"Uganda\"] = CountryStruct (42672478,26);\n  Countries[\"Iceland\"] = CountryStruct (336002,25);\n\n  // Initial cities token creation \n  _mintCity(msg.sender, \"New York City\", \"United States\", 8537673, 4073000, -7394000, 31710, 34245881000);\n  _mintCity(msg.sender, \"Los Angeles\", \"United States\", 3971883, 3405000, -11824000, 14750, 15931949000);\n}\n\n    // Functions interacting with Oly ---------------------------\n\n    function setOlyAddress(address _contractAddress) public onlyCreator() returns (bool _successful) {\n      olyAddress = _contractAddress;\n      return true;\n    }\n\n    function getOlyTotalSupply() public view returns (uint256 _totalSupply) {\n      Oly olyInstance = Oly(olyAddress);\n      return olyInstance.totalSupply();\n    }\n\n    // Functions for getting City Revenues and Upgrade Costs\n\n    function getCityRevenuesValue(uint256 _tokenId) public view cityExists(_tokenId) returns (uint256 _hourlyBoostedRevenues) {\n      uint32 _cityPop = CityDB[_tokenId].pop;\n      \n      require (_cityPop != 0);\n\n      bytes16 _cityCountry = CityDB[_tokenId].country;\n      uint64 _countryGDP = Countries[_cityCountry].gdp;\n      uint256 _cityUpgType = CityDB[_tokenId].upgType;\n      // base values without upgrade\n      uint8 _upgPercent = 100;\n      uint256 _upgBaseBonus = 0; \n\n      if (_cityUpgType == 1) {\n          // house\n          _upgPercent = 125;\n          _upgBaseBonus = 0;\n      } else if (_cityUpgType == 2) {\n          // hotels\n          _upgPercent = 150;\n          _upgBaseBonus = 0; \n      } else if (_cityUpgType == 3) {\n          // offices\n          _upgPercent = 115;\n          // base bonus is multiplied by base divider\n          _upgBaseBonus = 6944444 * olyDecimals;\n      } else if (_cityUpgType == 4) {\n          // factory\n          _upgPercent = 100;\n          _upgBaseBonus = 13888889 * olyDecimals;\n      } \n      uint256 _baseDivider = 100000000;\n      uint256 _hourlyRevenues = _cityPop * _countryGDP * olyDecimals; \n      _hourlyBoostedRevenues = _hourlyRevenues * _upgPercent / 100 + _upgBaseBonus;\n      _hourlyBoostedRevenues = _hourlyBoostedRevenues.div(_baseDivider);\n\n    }\n\n    function getUpgradeCost(uint256 _tokenId, uint8 _upgradeType) public view cityExists(_tokenId) returns (uint256 _upgradeCost) {\n      require (_upgradeType \u003c= 4);\n      bytes16 _cityCountry = CityDB[_tokenId].country;\n      uint256 _countryGDP = Countries[_cityCountry].gdp;\n\n        if (_upgradeType == 0) {\n          _upgradeCost = 0;\n        } else {\n            uint8 _upgPercent = 100;\n            uint256 _upgBaseBonus = 0; \n            uint256 _upgBaseCost = 0;\n\n            if (_upgradeType == 1) {\n                // house\n                _upgPercent = 125;\n                _upgBaseBonus = 0;\n                _upgBaseCost = _countryGDP / 10 * olyDecimals; \n            } else if (_upgradeType == 2) {\n                // hotels\n                _upgPercent = 150;\n                _upgBaseBonus = 0; \n                _upgBaseCost = _countryGDP / 5 * olyDecimals;\n            } else if (_upgradeType == 3) {\n                // offices\n                _upgPercent = 115;\n                // upgrade base applies to monthly revenues\n                _upgBaseBonus = 50 * olyDecimals;\n                _upgBaseCost = _countryGDP / 8 * olyDecimals; \n            } else if (_upgradeType == 4) {\n                // factory\n                _upgPercent = 100;\n                _upgBaseBonus = 100 * olyDecimals;\n                _upgBaseCost = _countryGDP / 15 * olyDecimals; \n            } \n\n            uint256 _revenues = getCityRevenuesValue(_tokenId) * 24 * 30;\n            uint256 _boostedRevenues = _revenues * _upgPercent;\n            _boostedRevenues = _boostedRevenues.div(100);\n            _boostedRevenues += _upgBaseBonus;\n            _upgradeCost = _boostedRevenues - _revenues + _upgBaseCost;\n            //_upgradeCost *= olyDecimals;\n\n        }\n    }\n\n\n  function olyUpdateRevenues(uint256 _tokenId) public onlyOwnerOf(_tokenId) cityExists(_tokenId) {\n    // get revenues + check\n    require (CityDB[_tokenId].name != \"\");\n\n    address _tokenOwner = ownerOf(_tokenId);\n    uint256 _hourlyRevenues = getCityRevenuesValue(_tokenId);\n\n    Oly olyInstance = Oly(olyAddress);  \n    olyInstance.polyUpdateRevenues(_tokenOwner, _tokenId, _hourlyRevenues);\n  }\n  \n  function olyBuyToken(uint256 _tokenId) public cityExists(_tokenId) {\n    require (CityDB[_tokenId].name != \"\");\n    require (CityDB[_tokenId].olyValue != 0);\n\n    address _tokenOwner = ownerOf(_tokenId);\n    address _tokenBuyer = msg.sender;\n    require (_tokenOwner != _tokenBuyer);\n    \n    uint256 _cityValue = CityDB[_tokenId].olyValue;\n\n    // Withdraw final OLY revenues for token owner\n    uint256 _hourlyRevenues = getCityRevenuesValue(_tokenId);\n    Oly olyInstance = Oly(olyAddress);  \n    olyInstance.polyUpdateRevenues(_tokenOwner, _tokenId, _hourlyRevenues);\n\n    // transfering OLY \n    olyInstance.polyTransfer(_tokenBuyer, _tokenOwner, _cityValue);\n    \n    // transfering POLY\n    clearApprovalAndTransfer(_tokenOwner, _tokenBuyer, _tokenId);\n\n    // set eth and oly sale values to 0  \n    CityDB[_tokenId].finneyValue = 0;\n    CityDB[_tokenId].olyValue = 0;  \n    \n  }\n\n   function olyUpgradeCity(uint256 _tokenId, uint8 _upgradeType) public onlyOwnerOf(_tokenId) cityExists(_tokenId) {\n    require (CityDB[_tokenId].name != \u0027\u0027);\n    require (_upgradeType \u003c= 4);\n    require (CityDB[_tokenId].upgType != _upgradeType);\n\n    address _tokenOwner = ownerOf(_tokenId);\n    uint256 _upgCost = getUpgradeCost(_tokenId, _upgradeType);\n    require (_upgCost \u003e= 1);\n\n    Oly olyInstance = Oly(olyAddress);  \n    olyUpdateRevenues(_tokenId);\n\n    olyInstance.polyTransfer(_tokenOwner, 0x0, _upgCost);\n\n    CityDB[_tokenId].upgType = _upgradeType;\n    emit Upgrade(_tokenId, _upgradeType);\n    \n  }\n\n  function olyGetBalance(address _tokenOwner) public view returns (uint256) {\n    Oly olyInstance = Oly(olyAddress);  \n    return olyInstance.balanceOf(_tokenOwner);\n  }\n\n}"},"oly.sol":{"content":"pragma solidity ^0.4.22;\n// might need to remove upwards compatibility\nimport \"./SafeMath.sol\";\n\ncontract Oly {\n  using SafeMath for uint256;\n\n  string public constant name = \"Etherpoly Dollars\"; \n  string public constant symbol = \"OLY\"; \n  uint8 public constant decimals = 3;\n\n  uint256 public constant INITIAL_SUPPLY = 10000 * (10 ** uint256(decimals));\n  mapping(address =\u003e uint256) balances;\n  mapping(uint256 =\u003e uint256) lastUpdate;\n  mapping (address =\u003e mapping (address =\u003e uint256)) internal allowed;\n  uint256 public totalSupply_;\n  uint256 private dateCreated;\n  address private polyAddress;\n\n   constructor (address _polyAddress) public {\n    polyAddress = _polyAddress;\n    dateCreated = now - 2 hours;\n    totalSupply_ = INITIAL_SUPPLY;\n    balances[msg.sender] = INITIAL_SUPPLY;\n    emit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n  }\n\n\n    modifier onlyPayloadSize(uint size) {\n    assert(msg.data.length \u003e= size * 32 + 4);\n    _;\n  }\n\n    modifier onlyPoly() {\n    require (msg.sender == polyAddress);\n    _;\n  }\n\n \n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n \n  function transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool) {\n    require(_to != address(0));\n    require(_value \u003c= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n\n\n\n  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3) public returns (bool) {\n    require(_to != address(0));\n    require(_value \u003c= balances[_from]);\n    require(_value \u003c= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  function approve(address _spender, uint256 _value) public onlyPayloadSize(2) returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  function increaseApproval(address _spender, uint _addedValue) public onlyPayloadSize(2) returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  function decreaseApproval(address _spender, uint _subtractedValue) public onlyPayloadSize(2) returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue \u003e oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  // functions that are interacting with POLY721\n\n  function polyUpdateRevenues(address _tokenOwner, uint256 _tokenId, uint256 _revenues) external onlyPoly() returns (uint256) {\n    require(_tokenOwner != address(0));\n    require (_revenues \u003e 0);\n\n    // time passed in hours since the last update, or since contract creation if first update\n    if (lastUpdate[_tokenId] \u003e 0) {\n      uint256 _timePassed = now - lastUpdate[_tokenId];\n      _timePassed /= 3600;\n    }\n    else { \n      _timePassed = now - dateCreated;\n      _timePassed /= 3600;\n    }\n\n    // if timepassed is higher than one hour, we can calculate hourly revenues, making sure there\u0027s no bug\n    if (_timePassed \u003e= 1 \u0026\u0026 _timePassed \u003c 100000) {\n      // minting the revenues for the owner of the Token ID, based on the hourly _revenues calculated by POLY721 since _timePassed \n      uint256 _cumulatedRevenues = _revenues * _timePassed; \n      lastUpdate[_tokenId] = now;\n      uint256 _newTotalSupply = totalSupply_.add(_cumulatedRevenues);\n      uint256 _newBalance = balances[_tokenOwner].add(_cumulatedRevenues);\n\n      totalSupply_ = _newTotalSupply;\n      balances[_tokenOwner] = _newBalance;\n\n      emit Transfer(0x0, _tokenOwner, _cumulatedRevenues);\n      return _cumulatedRevenues;\n      \n    } else return 0;\n\n  }\n\n\n  function polyTransfer(address _from, address _to, uint256 _value) external onlyPoly() {\n    //require(_to != address(0));\n    require(_from != address(0));\n    require(_value \u003c= balances[_from]);\n    require (_value \u003e 0);\n    // During tests, creator could send coins to itself resulting in throw\n    require(_to != _from);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(_from, _to, _value);\n  }\n\n\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.4.22;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b \u003c= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c \u003e= a);\n    return c;\n  }\n}\n"}}