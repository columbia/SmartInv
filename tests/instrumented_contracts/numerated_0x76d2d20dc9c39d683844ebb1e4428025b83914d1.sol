1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/ChainRunnersXRBaseRenderer.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"./core/ChainRunnersTypes.sol\";\nimport \"./interfaces/IChainRunnersRenderer.sol\";\nimport \"./interfaces/IChainRunners.sol\";\nimport \"./ChainRunnersBaseRenderer.sol\";\n\n/*\n               ::::                                                                                                                                                  :::#%=\n               @*==+-                                                                                                                                               ++==*=.\n               #+=#=++..                                                                                                                                        ..=*=*+-#:\n                :=+++++++=====================================:    .===============================================. .=========================================++++++++=\n                 .%-+%##+=--==================================+=..=+-=============================================-+*+======================================---+##+=#-.\n                   -+++@@%++++@@@%+++++++++++++++++++++++++++%#++++++%#+++#@@@#+++++++++@@%++++++++++++++++++++@#+.=+*@*+*@@@@*+++++++++++++++++++++++%@@@#+++#@@+++=\n                    -*-#%@@%%%=*%@%*++=++=+==+=++=++=+=++=++==#@%#%#+++=+=*@%*+=+==+=+++%*++==+=++=+==+=++=+=++@%%#%#++++*@%#++=++=++=++=+=++=++=+=+*%%*==*%@@@*:%=\n                     :@:+@@@@@@*+++%@@*+===========+*=========#@@========+#%==========*@========##*#*+=======*@##*======#@#+=======*#*============+#%++#@@%#@@#++=.\n                      .*+=%@%*%@%##++@@%#=-==-=--==*%=========*%==--=--=-====--=--=-=##=--=-=--%%%%%+=-=--=-=*%=--=--=-=#%=--=----=#%=--=-=--=-+%#+==#%@@*#%@=++.\n                        +%.#@@###%@@@@@%*---------#@%########@%*---------------------##---------------------##---------%%*--------@@#---------+#@=#@@#+==@@%*++-\n                        .:*+*%@#+=*%@@@*=-------=#%#=-------=%*---------=*#*--------#+=--------===--------=#%*-------=#%*-------==@%#--------=%@@%#*+=-+#%*+*:.\n       ====================%*.@@%#==+##%@*=----------------+@#+---------@@*-------=*@+---------@@*--------=@+--------+@=--------*@@+-------+#@@%#==---+#@.*%====================\n     :*=--==================-:=#@@%*===+*@%+=============%%%@=========*%@*========+@+=--=====+%@+==========@+========+@========*%@@+======%%%**+=---=%@#=:-====================-#-\n       +++**%@@@#*****************@#*=---=##%@@@@@@@@@@@@@#**@@@@****************%@@*+++@#***********#@************************************+=------=*@#*********************@#+=+:\n        .-##=*@@%*----------------+%@%=---===+%@@@@@@@*+++---%#++----------------=*@@*+++=-----------=+#=------------------------------------------+%+--------------------+#@-=@\n         :%:#%#####+=-=-*@@+--=-==-=*@=--=-==-=*@@#*=-==-=-+@===-==-=-=++==-=-==--=@%===-==----+-==-==--+*+-==-==---=*@@@@@@%#===-=-=+%@%-==-=-==-#@%=-==-==--+#@@@@@@@@@@@@*+++\n        =*=#@#=----==-=-=++=--=-==-=*@=--=-==-=*@@+-=-==-==+@===-=--=-*@@*=-=-==--+@=--=-==--+#@-==-==---+%-==-==---=+++#@@@#--==-=-=++++-=--=-===#%+=-==-==---=++++++++@@@%.#*\n        +#:@%*===================++%#=========%@%=========#%=========+#@%+=======#%==========*@#=========*%=========+*+%@@@+========+*==========+@@%+**+================*%#*=+=\n       *++#@*+=++++++*#%*+++++=+++*%%++++=++++%%*=+++++++##*=++++=++=%@@++++=++=+#%++++=++++#%@=+++++++=*#*+++++++=#%@@@@@*++=++++=#%@*+++=++=+++@#*****=+++++++=+++++*%@@+:=+=\n    :=*=#%#@@@@#%@@@%#@@#++++++++++%%*+++++++++++++++++**@*+++++++++*%#++++++++=*##++++++++*%@%+++++++++##+++++++++#%%%%%%++++**#@@@@@**+++++++++++++++++=*%@@@%#@@@@#%@@@%#@++*:.\n    #*:@#=-+%#+:=*@*=-+@%#++++++++#%@@#*++++++++++++++#%@#*++++++++*@@#+++++++++@#++++++++*@@#+++++++++##*+++++++++++++++++###@@@@++*@@#+++++++++++++++++++*@@#=:+#%+--+@*=-+%*.@=\n    ++=#%#+%@@%=#%@%#+%%#++++++*#@@@%###**************@@@++++++++**#@##*********#*********#@@#++++++***@#******%@%#*++**#@@@%##+==+++=*#**********%%*++++++++#%#=%@@%+*%@%*+%#*=*-\n     .-*+===========*@@+++++*%%%@@@++***************+.%%*++++#%%%@@%=:=******************--@@#+++*%%@#==+***--*@%*++*%@@*===+**=--   -************++@%%#++++++#@@@*==========*+-\n        =*******##.#%#++++*%@@@%+==+=             *#-%@%**%%###*====**-               -@:*@@##@###*==+**-.-#=+@@#*@##*==+***=                     =+=##%@*+++++*%@@#.#%******:\n               ++++%#+++*#@@@@+++==.              **-@@@%+++++++===-                 -+++#@@+++++++==:  :+++%@@+++++++==:                          .=++++@%##++++@@%++++\n             :%:*%%****%@@%+==*-                .%==*====**+...                      #*.#+==***....    #+=#%+==****:.                                ..-*=*%@%#++*#%@=+%.\n            -+++#%+#%@@@#++===                  .@*++===-                            #%++===           %#+++===                                          =+++%@%##**@@*.@:\n          .%-=%@##@@%*==++                                                                                                                                 .*==+#@@%*%@%=*=.\n         .+++#@@@@@*++==.                                                                                                                                    -==++#@@@@@@=+%\n       .=*=%@@%%%#=*=.                                                                                                                                          .*+=%@@@@%+-#.\n       @=-@@@%:++++.                                                                                                                                              -+++**@@#+*=:\n    .-+=*#%%++*::.                                                                                                                                                  :+**=#%@#==#\n    #*:@*+++=:                                                                                                                                                          =+++@*++=:\n  :*-=*=++..                                                                                                                                                             .=*=#*.%=\n +#.=+++:                                                                                                                                                                   ++++:+#\n*+=#-::                                                                                                                                                                      .::*+=*\n\n*/\n\ncontract ChainRunnersXRBaseRenderer is Ownable, ReentrancyGuard {\n    /**\n     * @dev Emitted when the body type for `tokenId` token is changed to `to`.\n     */\n    event SetBodyType(address indexed owner, uint8 indexed to, uint256 indexed tokenId);\n\n    uint256 public constant NUM_LAYERS = 13;\n    uint256 public constant NUM_COLORS = 8;\n\n    address public genesisRendererContractAddress;\n    address public xrContractAddress;\n    string public baseImageURI;\n    string public baseAnimationURI;\n    string public baseModelURI;\n    string public modelStandardName;\n    string public modelExtensionName;\n    string public modelFileType;\n\n    uint16[][NUM_LAYERS][3] WEIGHTS;\n\n    struct BodyTypeOverride {\n        bool isSet;\n        uint8 id;\n    }\n\n    mapping(uint256 => BodyTypeOverride) bodyTypeOverrides;\n\n    constructor(\n        address genesisRendererContractAddress_\n    ) {\n        genesisRendererContractAddress = genesisRendererContractAddress_;\n\n        /*\n        This indexes into a race, then a layer index, then an array capturing the frequency each layer should be selected.\n        Shout out to Anonymice for the rarity impl inspiration.\n        */\n\n        // Default\n        WEIGHTS[0][0] = [36, 225, 225, 225, 360, 135, 27, 360, 315, 315, 315, 315, 225, 180, 225, 180, 360, 180, 45, 360, 360, 360, 27, 36, 360, 45, 180, 360, 225, 360, 225, 225, 360, 180, 45, 360, 18, 225, 225, 225, 225, 180, 225, 361];\n        WEIGHTS[0][1] = [875, 1269, 779, 779, 779, 779, 779, 779, 779, 779, 779, 779, 17, 8, 41];\n        WEIGHTS[0][2] = [172, 172, 172, 172, 86, 17, 0, 0, 86, 86, 86, 86, 17, 172, 86, 17, 172, 172, 172, 172, 172, 172, 17, 86, 172, 172, 172, 172, 172, 172, 172, 172, 6062];\n        WEIGHTS[0][3] = [645, 0, 1290, 322, 645, 645, 645, 967, 322, 967, 645, 967, 967, 973];\n        WEIGHTS[0][4] = [0, 0, 0, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250];\n        WEIGHTS[0][5] = [121, 121, 121, 121, 121, 121, 243, 0, 0, 0, 0, 121, 121, 243, 121, 121, 243, 121, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 243, 0, 0, 0, 121, 121, 243, 121, 121, 306];\n        WEIGHTS[0][6] = [833, 555, 138, 416, 694, 416, 138, 1111, 1111, 1111, 3477];\n        WEIGHTS[0][7] = [88, 88, 88, 88, 88, 265, 442, 8853];\n        WEIGHTS[0][8] = [189, 189, 47, 18, 9, 28, 37, 9483];\n        WEIGHTS[0][9] = [340, 340, 340, 340, 340, 340, 34, 340, 340, 340, 340, 170, 170, 170, 102, 238, 238, 238, 272, 340, 340, 340, 272, 238, 238, 238, 238, 170, 34, 340, 340, 136, 340, 340, 340, 340, 344];\n        WEIGHTS[0][10] = [159, 212, 106, 53, 26, 159, 53, 265, 53, 212, 159, 265, 53, 265, 265, 212, 53, 159, 239, 53, 106, 5, 106, 53, 212, 212, 106, 159, 212, 265, 212, 265, 5066];\n        WEIGHTS[0][11] = [139, 278, 278, 250, 250, 194, 222, 278, 278, 194, 222, 83, 222, 278, 139, 139, 27, 278, 278, 278, 278, 27, 278, 139, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 27, 139, 139, 139, 139, 0, 278, 194, 83, 83, 278, 83, 27, 306];\n        WEIGHTS[0][12] = [548, 1097, 182, 11, 274, 91, 365, 114, 7318];\n\n        // Skull\n        WEIGHTS[1][0] = [36, 225, 225, 225, 360, 135, 27, 360, 315, 315, 315, 315, 225, 180, 225, 180, 360, 180, 45, 360, 360, 360, 27, 36, 360, 45, 180, 360, 225, 360, 225, 225, 360, 180, 45, 360, 18, 225, 225, 225, 225, 180, 225, 361];\n        WEIGHTS[1][1] = [875, 1269, 779, 779, 779, 779, 779, 779, 779, 779, 779, 779, 17, 8, 41];\n        WEIGHTS[1][2] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10000];\n        WEIGHTS[1][3] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        WEIGHTS[1][4] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        WEIGHTS[1][5] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 384, 7692, 1923, 0, 0, 0, 0, 0, 1];\n        WEIGHTS[1][6] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10000];\n        WEIGHTS[1][7] = [0, 0, 0, 0, 0, 909, 0, 9091];\n        WEIGHTS[1][8] = [0, 0, 0, 0, 0, 0, 0, 10000];\n        WEIGHTS[1][9] = [526, 526, 526, 0, 0, 0, 0, 0, 526, 0, 0, 0, 526, 0, 526, 0, 0, 0, 526, 526, 526, 526, 526, 526, 526, 526, 526, 526, 526, 0, 0, 526, 0, 0, 0, 0, 532];\n        WEIGHTS[1][10] = [80, 0, 400, 240, 80, 0, 240, 0, 0, 80, 80, 80, 0, 0, 0, 0, 80, 80, 0, 0, 80, 80, 0, 80, 80, 80, 80, 80, 0, 0, 0, 0, 8000];\n        WEIGHTS[1][11] = [289, 0, 0, 0, 0, 404, 462, 578, 578, 0, 462, 173, 462, 578, 0, 0, 57, 0, 57, 0, 57, 57, 578, 289, 578, 57, 0, 57, 57, 57, 578, 578, 0, 0, 0, 0, 0, 0, 57, 289, 578, 0, 0, 0, 231, 57, 0, 0, 1745];\n        WEIGHTS[1][12] = [666, 666, 666, 0, 666, 0, 0, 0, 7336];\n\n        // Bot\n        WEIGHTS[2][0] = [36, 225, 225, 225, 360, 135, 27, 360, 315, 315, 315, 315, 225, 180, 225, 180, 360, 180, 45, 360, 360, 360, 27, 36, 360, 45, 180, 360, 225, 360, 225, 225, 360, 180, 45, 360, 18, 225, 225, 225, 225, 180, 225, 361];\n        WEIGHTS[2][1] = [875, 1269, 779, 779, 779, 779, 779, 779, 779, 779, 779, 779, 17, 8, 41];\n        WEIGHTS[2][2] = [172, 172, 172, 172, 86, 17, 0, 0, 86, 86, 86, 86, 17, 172, 86, 17, 172, 172, 172, 172, 172, 172, 17, 86, 172, 172, 172, 172, 172, 172, 172, 172, 6062];\n        WEIGHTS[2][3] = [645, 0, 1290, 322, 645, 645, 645, 967, 322, 967, 645, 967, 967, 973];\n        WEIGHTS[2][4] = [2500, 2500, 2500, 0, 0, 0, 0, 0, 0, 2500, 0];\n        WEIGHTS[2][5] = [0, 0, 0, 0, 0, 0, 588, 588, 588, 588, 588, 0, 0, 588, 0, 0, 588, 0, 0, 0, 0, 0, 588, 0, 0, 0, 0, 588, 0, 0, 0, 588, 588, 0, 0, 0, 588, 0, 0, 0, 0, 588, 0, 0, 0, 0, 0, 0, 0, 0, 0, 588, 0, 0, 0, 0, 588, 0, 0, 0, 0, 588, 0, 0, 0, 0, 0, 0, 0, 0, 588, 0, 0, 4];\n        WEIGHTS[2][6] = [833, 555, 138, 416, 694, 416, 138, 1111, 1111, 1111, 3477];\n        WEIGHTS[2][7] = [88, 88, 88, 88, 88, 265, 442, 8853];\n        WEIGHTS[2][8] = [183, 274, 274, 18, 18, 27, 36, 9170];\n        WEIGHTS[2][9] = [340, 340, 340, 340, 340, 340, 34, 340, 340, 340, 340, 170, 170, 170, 102, 238, 238, 238, 272, 340, 340, 340, 272, 238, 238, 238, 238, 170, 34, 340, 340, 136, 340, 340, 340, 340, 344];\n        WEIGHTS[2][10] = [217, 362, 217, 144, 72, 289, 144, 362, 72, 289, 217, 362, 72, 362, 362, 289, 0, 217, 0, 72, 144, 7, 217, 72, 217, 217, 289, 217, 289, 362, 217, 362, 3269];\n        WEIGHTS[2][11] = [139, 278, 278, 250, 250, 194, 222, 278, 278, 194, 222, 83, 222, 278, 139, 139, 27, 278, 278, 278, 278, 27, 278, 139, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 27, 139, 139, 139, 139, 0, 278, 194, 83, 83, 278, 83, 27, 306];\n        WEIGHTS[2][12] = [548, 1097, 182, 11, 274, 91, 365, 114, 7318];\n    }\n\n    /*\n    Get race index.  Race index represents the \"type\" of base character:\n\n    0 - Default, representing human and alien characters\n    1 - Skull\n    2 - Bot\n\n    This allows skull/bot characters to have distinct trait distributions.\n    */\n    function getRaceIndex(uint16 _dna) public view returns (uint8) {\n        uint16 lowerBound;\n        uint16 percentage;\n        for (uint8 i; i < WEIGHTS[0][1].length; i++) {\n            percentage = WEIGHTS[0][1][i];\n            if (_dna >= lowerBound && _dna < lowerBound + percentage) {\n                if (i == 1) {\n                    // Bot\n                    return 2;\n                } else if (i > 11) {\n                    // Skull\n                    return 1;\n                } else {\n                    // Default\n                    return 0;\n                }\n            }\n            lowerBound += percentage;\n        }\n        revert();\n    }\n\n    function getLayerIndex(uint16 _dna, uint8 _index, uint16 _raceIndex) public view returns (uint) {\n        uint16 lowerBound;\n        uint16 percentage;\n        for (uint8 i; i < WEIGHTS[_raceIndex][_index].length; i++) {\n            percentage = WEIGHTS[_raceIndex][_index][i];\n            if (_dna >= lowerBound && _dna < lowerBound + percentage) {\n                return i;\n            }\n            lowerBound += percentage;\n        }\n        // If not found, return index higher than available layers.  Will get filtered out.\n        return WEIGHTS[_raceIndex][_index].length;\n    }\n\n    function _baseImageURI() internal view virtual returns (string memory) {\n        return baseImageURI;\n    }\n\n    function setBaseImageURI(string calldata _baseImageURI) external onlyOwner {\n        baseImageURI = _baseImageURI;\n    }\n\n    function _baseAnimationURI() internal view virtual returns (string memory) {\n        return baseAnimationURI;\n    }\n\n    function setBaseAnimationURI(string calldata _baseAnimationURI) external onlyOwner {\n        baseAnimationURI = _baseAnimationURI;\n    }\n\n    function _baseModelURI() internal view virtual returns (string memory) {\n        return baseModelURI;\n    }\n\n    function setBaseModelURI(string calldata _baseModelURI) external onlyOwner {\n        baseModelURI = _baseModelURI;\n    }\n\n    function _modelStandardName() internal view virtual returns (string memory) {\n        return bytes(modelStandardName).length > 0 ? modelStandardName : 'EIP-XXXX';\n    }\n\n    function setModelStandardName(string calldata _modelStandardName) external onlyOwner {\n        modelStandardName = _modelStandardName;\n    }\n\n    function _modelExtensionName() internal view virtual returns (string memory) {\n        return bytes(modelExtensionName).length > 0 ? modelExtensionName : 'NIMDE-1';\n    }\n\n    function setModelExtensionName(string calldata _modelExtensionName) external onlyOwner {\n        modelExtensionName = _modelExtensionName;\n    }\n\n    function _modelFileType() internal view virtual returns (string memory) {\n        return bytes(modelFileType).length > 0 ? modelFileType : 'model/fbx';\n    }\n\n    function setModelFileType(string calldata _modelFileType) external onlyOwner {\n        modelFileType = _modelFileType;\n    }\n\n    function _xrContractAddress() public view returns (address) {\n        return xrContractAddress;\n    }\n\n    function setXRContractAddress(address _xrContractAddress) external onlyOwner {\n        xrContractAddress = _xrContractAddress;\n    }\n\n    function setBodyTypeOverride(uint256 _tokenId, uint8 _bodyTypeId) external {\n        IERC721 xrContract = IERC721(_xrContractAddress());\n        require(xrContract.ownerOf(_tokenId) == msg.sender, \"not the owner of token\");\n\n        bodyTypeOverrides[_tokenId] = BodyTypeOverride(true, _bodyTypeId % 2);\n\n        emit SetBodyType(msg.sender, bodyTypeOverrides[_tokenId].id, _tokenId);\n    }\n\n    /*\n    Generate base64 encoded tokenURI.\n\n    All string constants are pre-base64 encoded to save gas.\n    Input strings are padded with spacing/etc to ensure their length is a multiple of 3.\n    This way the resulting base64 encoded string is a multiple of 4 and will not include any '=' padding characters,\n    which allows these base64 string snippets to be concatenated with other snippets.\n    */\n    function tokenURI(uint256 _tokenId, ChainRunnersTypes.ChainRunner memory _runnerData) public view returns (string memory) {\n        if (_tokenId <= 10000) {\n            return genesisXRTokenURI(_tokenId, _runnerData.dna);\n        }\n        (ChainRunnersBaseRenderer.Layer [NUM_LAYERS] memory tokenLayers, ChainRunnersBaseRenderer.Color [NUM_COLORS][NUM_LAYERS] memory tokenPalettes, uint8 numTokenLayers, string[NUM_LAYERS] memory traitTypes) = getXRTokenData(_runnerData.dna);\n        return base64TokenMetadata(_tokenId, tokenLayers, numTokenLayers, traitTypes, _runnerData.dna);\n    }\n\n    function genesisXRTokenURI(uint256 _tokenId, uint256 _dna) public view returns (string memory) {\n        ChainRunnersBaseRenderer genesisRendererContract = ChainRunnersBaseRenderer(genesisRendererContractAddress);\n        (ChainRunnersBaseRenderer.Layer [NUM_LAYERS] memory tokenLayers, ChainRunnersBaseRenderer.Color [NUM_COLORS][NUM_LAYERS] memory tokenPalettes, uint8 numTokenLayers, string[NUM_LAYERS] memory traitTypes) = genesisRendererContract.getTokenData(_dna);\n        return base64TokenMetadata(_tokenId, tokenLayers, numTokenLayers, traitTypes, _dna);\n    }\n\n    function base64TokenMetadata(uint256 _tokenId,\n        ChainRunnersBaseRenderer.Layer [NUM_LAYERS] memory _tokenLayers,\n        uint8 _numTokenLayers,\n        string[NUM_LAYERS] memory _traitTypes,\n        uint256 _dna) public view returns (string memory) {\n\n        string memory attributes;\n        for (uint8 i = 0; i < _numTokenLayers; i++) {\n            attributes = string(abi.encodePacked(attributes,\n                bytes(attributes).length == 0 ? 'eyAg' : 'LCB7',\n                'InRyYWl0X3R5cGUiOiAi', _traitTypes[i], 'IiwidmFsdWUiOiAi', _tokenLayers[i].name, 'IiB9'\n                ));\n        }\n        string memory baseFileName = getBaseFileName(_tokenId, _dna);\n        return string(abi.encodePacked(\n                'data:application/json;base64,eyAiaW1hZ2UiOiAi',\n                getBase64ImageURI(baseFileName),\n                getBase64AnimationURI(baseFileName),\n                'IiwgImF0dHJpYnV0ZXMiOiBb',\n                attributes,\n                'XSwgICAibmFtZSI6IlJ1bm5lciAj',\n                getBase64TokenString(_tokenId),\n                getBase64ModelMetadata(baseFileName),\n                'LCAiZGVzY3JpcHRpb24iOiAiQ2hhaW4gUnVubmVycyBYUiBhcmUgM0QgTWVnYSBDaXR5IHJlbmVnYWRlcy4gIn0g'\n            ));\n    }\n\n    function getBaseFileName(uint256 _tokenId, uint256 _dna) public view returns (string memory) {\n        uint8 bodyTypeId = getBodyType(_tokenId, _dna);\n        return string(abi.encodePacked(Strings.toString(_dna), '_', Strings.toString(bodyTypeId)));\n    }\n\n    function getBodyType(uint256 _tokenId, uint256 _dna) public view returns (uint8) {\n        BodyTypeOverride memory bodyTypeOverride = bodyTypeOverrides[_tokenId];\n        if (bodyTypeOverride.isSet) {\n            return bodyTypeOverride.id;\n        }\n        return uint8((_dna & (uint256(1111111) << (14 * NUM_LAYERS))) >> (14 * NUM_LAYERS)) % 2;\n    }\n\n    function getBase64TokenString(uint256 _tokenId) public view returns (string memory) {\n        return Base64.encode(uintToByteString(_tokenId, 6));\n    }\n\n    function getBase64ImageURI(string memory _baseFileName) public view returns (string memory) {\n        return Base64.encode(padStringBytes(abi.encodePacked(_baseImageURI(), _baseFileName), 3));\n    }\n\n    function getBase64AnimationURI(string memory _baseFileName) public view returns (string memory) {\n        return bytes(_baseAnimationURI()).length > 0\n            ? string(abi.encodePacked('IiwgImFuaW1hdGlvbl91cmwiOiAi', Base64.encode(bytes(padString(string(abi.encodePacked(_baseImageURI(), _baseFileName)), 3)))))\n            : '';\n    }\n\n    function getBase64ModelMetadata(string memory _baseFileName) public view returns (string memory) {\n        return Base64.encode(padStringBytes(abi.encodePacked(\n            '\",\"metadataStandard\": \"',\n            _modelStandardName(),\n            '\",\"extensions\": [ \"',\n            _modelExtensionName(),\n            '\" ],\"assets\": [{ \"mediaType\": \"model\", \"assetType\": \"avatar\", \"files\": [{\"url\": \"',\n            _baseModelURI(),\n                _baseFileName,\n            '\",\"fileType\": \"',\n            _modelFileType(),\n            '\"}]}]'\n        ), 3));\n    }\n\n    function getTokenData(uint256 _tokenId, uint256 _dna) public view returns (ChainRunnersBaseRenderer.Layer [NUM_LAYERS] memory tokenLayers, ChainRunnersBaseRenderer.Color [NUM_COLORS][NUM_LAYERS] memory tokenPalettes, uint8 numTokenLayers, string [NUM_LAYERS] memory traitTypes) {\n        if (_tokenId <= 10000) {\n            ChainRunnersBaseRenderer genesisRendererContract = ChainRunnersBaseRenderer(genesisRendererContractAddress);\n            return genesisRendererContract.getTokenData(_dna);\n        }\n        return getXRTokenData(_dna);\n    }\n\n    function getXRTokenData(uint256 _dna) public view returns (ChainRunnersBaseRenderer.Layer [NUM_LAYERS] memory tokenLayers, ChainRunnersBaseRenderer.Color [NUM_COLORS][NUM_LAYERS] memory tokenPalettes, uint8 numTokenLayers, string [NUM_LAYERS] memory traitTypes) {\n        uint16[NUM_LAYERS] memory dna = splitNumber(_dna);\n        uint16 raceIndex = getRaceIndex(dna[1]);\n\n        bool hasFaceAcc = dna[7] < (10000 - WEIGHTS[raceIndex][7][7]);\n        bool hasMask = dna[8] < (10000 - WEIGHTS[raceIndex][8][7]);\n        bool hasHeadBelow = dna[9] < (10000 - WEIGHTS[raceIndex][9][36]);\n        bool hasHeadAbove = dna[11] < (10000 - WEIGHTS[raceIndex][11][48]);\n        bool useHeadAbove = (dna[0] % 2) > 0;\n        for (uint8 i = 0; i < NUM_LAYERS; i ++) {\n            ChainRunnersBaseRenderer genesisRenderer = ChainRunnersBaseRenderer(genesisRendererContractAddress);\n            ChainRunnersBaseRenderer.Layer memory layer = genesisRenderer.getLayer(i, uint8(getLayerIndex(dna[i], i, raceIndex)));\n            if (layer.hexString.length > 0) {\n                /*\n                These conditions help make sure layer selection meshes well visually.\n                1. If mask, no face/eye acc/mouth acc\n                2. If face acc, no mask/mouth acc/face\n                3. If both head above & head below, randomly choose one\n                */\n                if (((i == 2 || i == 12) && !hasMask && !hasFaceAcc) || (i == 7 && !hasMask) || (i == 10 && !hasMask) || (i < 2 || (i > 2 && i < 7) || i == 8 || i == 9 || i == 11)) {\n                    if (hasHeadBelow && hasHeadAbove && (i == 9 && useHeadAbove) || (i == 11 && !useHeadAbove)) continue;\n                    tokenLayers[numTokenLayers] = layer;\n                    traitTypes[numTokenLayers] = [\"QmFja2dyb3VuZCAg\",\"UmFjZSAg\",\"RmFjZSAg\",\"TW91dGgg\",\"Tm9zZSAg\",\"RXllcyAg\",\"RWFyIEFjY2Vzc29yeSAg\",\"RmFjZSBBY2Nlc3Nvcnkg\",\"TWFzayAg\",\"SGVhZCBCZWxvdyAg\",\"RXllIEFjY2Vzc29yeSAg\",\"SGVhZCBBYm92ZSAg\",\"TW91dGggQWNjZXNzb3J5\"][i];\n                    numTokenLayers++;\n                }\n            }\n        }\n        return (tokenLayers, tokenPalettes, numTokenLayers, traitTypes);\n    }\n\n    function splitNumber(uint256 _number) internal view returns (uint16[NUM_LAYERS] memory numbers) {\n        for (uint256 i = 0; i < numbers.length; i++) {\n            numbers[i] = uint16(_number % 10000);\n            _number >>= 14;\n        }\n        return numbers;\n    }\n\n    /*\n    Convert uint to byte string, padding number string with spaces at end.\n    Useful to ensure result's length is a multiple of 3, and therefore base64 encoding won't\n    result in '=' padding chars.\n    */\n    function uintToByteString(uint _a, uint _fixedLen) internal pure returns (bytes memory _uintAsString) {\n        uint j = _a;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(_fixedLen);\n        j = _fixedLen;\n        if (_a == 0) {\n            bstr[0] = \"0\";\n            len = 1;\n        }\n        while (j > len) {\n            j = j - 1;\n            bstr[j] = bytes1(' ');\n        }\n        uint k = len;\n        while (_a != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_a - _a / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _a /= 10;\n        }\n        return bstr;\n    }\n\n    function padString(string memory _s, uint256 _multiple) internal view returns (string memory) {\n        uint256 numPaddingSpaces = (_multiple - (bytes(_s).length % _multiple)) % _multiple;\n        while (numPaddingSpaces > 0) {\n            _s = string(abi.encodePacked(_s, ' '));\n            numPaddingSpaces--;\n        }\n        return _s;\n    }\n\n    function padStringBytes(bytes memory _s, uint256 _multiple) internal view returns (bytes memory) {\n        uint256 numPaddingSpaces = (_multiple - (_s.length % _multiple)) % _multiple;\n        while (numPaddingSpaces > 0) {\n            _s = abi.encodePacked(_s, ' ');\n            numPaddingSpaces--;\n        }\n        return _s;\n    }\n}"
6     },
7     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
9     },
10     "@openzeppelin/contracts/access/Ownable.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
12     },
13     "@openzeppelin/contracts/utils/Strings.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
15     },
16     "contracts/core/ChainRunnersTypes.sol": {
17       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface ChainRunnersTypes {\n    struct ChainRunner {\n        uint256 dna;\n    }\n}\n"
18     },
19     "contracts/interfaces/IChainRunnersRenderer.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"../core/ChainRunnersTypes.sol\";\n\ninterface IChainRunnersRenderer {\n    function tokenURI(uint256 tokenId, ChainRunnersTypes.ChainRunner memory runnerData) external view returns (string memory);\n}\n"
21     },
22     "contracts/interfaces/IChainRunners.sol": {
23       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport \"../core/ChainRunnersTypes.sol\";\n\ninterface IChainRunners is IERC721Enumerable {\n    function getDna(uint256 _tokenId) external view returns (uint256);\n}\n"
24     },
25     "contracts/ChainRunnersBaseRenderer.sol": {
26       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./core/ChainRunnersTypes.sol\";\n\n/*\n               ::::                                                                                                                                                  :::#%=\n               @*==+-                                                                                                                                               ++==*=.\n               #+=#=++..                                                                                                                                        ..=*=*+-#:\n                :=+++++++=====================================:    .===============================================. .=========================================++++++++=\n                 .%-+%##+=--==================================+=..=+-=============================================-+*+======================================---+##+=#-.\n                   -+++@@%++++@@@%+++++++++++++++++++++++++++%#++++++%#+++#@@@#+++++++++@@%++++++++++++++++++++@#+.=+*@*+*@@@@*+++++++++++++++++++++++%@@@#+++#@@+++=\n                    -*-#%@@%%%=*%@%*++=++=+==+=++=++=+=++=++==#@%#%#+++=+=*@%*+=+==+=+++%*++==+=++=+==+=++=+=++@%%#%#++++*@%#++=++=++=++=+=++=++=+=+*%%*==*%@@@*:%=\n                     :@:+@@@@@@*+++%@@*+===========+*=========#@@========+#%==========*@========##*#*+=======*@##*======#@#+=======*#*============+#%++#@@%#@@#++=.\n                      .*+=%@%*%@%##++@@%#=-==-=--==*%=========*%==--=--=-====--=--=-=##=--=-=--%%%%%+=-=--=-=*%=--=--=-=#%=--=----=#%=--=-=--=-+%#+==#%@@*#%@=++.\n                        +%.#@@###%@@@@@%*---------#@%########@%*---------------------##---------------------##---------%%*--------@@#---------+#@=#@@#+==@@%*++-\n                        .:*+*%@#+=*%@@@*=-------=#%#=-------=%*---------=*#*--------#+=--------===--------=#%*-------=#%*-------==@%#--------=%@@%#*+=-+#%*+*:.\n       ====================%*.@@%#==+##%@*=----------------+@#+---------@@*-------=*@+---------@@*--------=@+--------+@=--------*@@+-------+#@@%#==---+#@.*%====================\n     :*=--==================-:=#@@%*===+*@%+=============%%%@=========*%@*========+@+=--=====+%@+==========@+========+@========*%@@+======%%%**+=---=%@#=:-====================-#-\n       +++**%@@@#*****************@#*=---=##%@@@@@@@@@@@@@#**@@@@****************%@@*+++@#***********#@************************************+=------=*@#*********************@#+=+:\n        .-##=*@@%*----------------+%@%=---===+%@@@@@@@*+++---%#++----------------=*@@*+++=-----------=+#=------------------------------------------+%+--------------------+#@-=@\n         :%:#%#####+=-=-*@@+--=-==-=*@=--=-==-=*@@#*=-==-=-+@===-==-=-=++==-=-==--=@%===-==----+-==-==--+*+-==-==---=*@@@@@@%#===-=-=+%@%-==-=-==-#@%=-==-==--+#@@@@@@@@@@@@*+++\n        =*=#@#=----==-=-=++=--=-==-=*@=--=-==-=*@@+-=-==-==+@===-=--=-*@@*=-=-==--+@=--=-==--+#@-==-==---+%-==-==---=+++#@@@#--==-=-=++++-=--=-===#%+=-==-==---=++++++++@@@%.#*\n        +#:@%*===================++%#=========%@%=========#%=========+#@%+=======#%==========*@#=========*%=========+*+%@@@+========+*==========+@@%+**+================*%#*=+=\n       *++#@*+=++++++*#%*+++++=+++*%%++++=++++%%*=+++++++##*=++++=++=%@@++++=++=+#%++++=++++#%@=+++++++=*#*+++++++=#%@@@@@*++=++++=#%@*+++=++=+++@#*****=+++++++=+++++*%@@+:=+=\n    :=*=#%#@@@@#%@@@%#@@#++++++++++%%*+++++++++++++++++**@*+++++++++*%#++++++++=*##++++++++*%@%+++++++++##+++++++++#%%%%%%++++**#@@@@@**+++++++++++++++++=*%@@@%#@@@@#%@@@%#@++*:.\n    #*:@#=-+%#+:=*@*=-+@%#++++++++#%@@#*++++++++++++++#%@#*++++++++*@@#+++++++++@#++++++++*@@#+++++++++##*+++++++++++++++++###@@@@++*@@#+++++++++++++++++++*@@#=:+#%+--+@*=-+%*.@=\n    ++=#%#+%@@%=#%@%#+%%#++++++*#@@@%###**************@@@++++++++**#@##*********#*********#@@#++++++***@#******%@%#*++**#@@@%##+==+++=*#**********%%*++++++++#%#=%@@%+*%@%*+%#*=*-\n     .-*+===========*@@+++++*%%%@@@++***************+.%%*++++#%%%@@%=:=******************--@@#+++*%%@#==+***--*@%*++*%@@*===+**=--   -************++@%%#++++++#@@@*==========*+-\n        =*******##.#%#++++*%@@@%+==+=             *#-%@%**%%###*====**-               -@:*@@##@###*==+**-.-#=+@@#*@##*==+***=                     =+=##%@*+++++*%@@#.#%******:\n               ++++%#+++*#@@@@+++==.              **-@@@%+++++++===-                 -+++#@@+++++++==:  :+++%@@+++++++==:                          .=++++@%##++++@@%++++\n             :%:*%%****%@@%+==*-                .%==*====**+...                      #*.#+==***....    #+=#%+==****:.                                ..-*=*%@%#++*#%@=+%.\n            -+++#%+#%@@@#++===                  .@*++===-                            #%++===           %#+++===                                          =+++%@%##**@@*.@:\n          .%-=%@##@@%*==++                                                                                                                                 .*==+#@@%*%@%=*=.\n         .+++#@@@@@*++==.                                                                                                                                    -==++#@@@@@@=+%\n       .=*=%@@%%%#=*=.                                                                                                                                          .*+=%@@@@%+-#.\n       @=-@@@%:++++.                                                                                                                                              -+++**@@#+*=:\n    .-+=*#%%++*::.                                                                                                                                                  :+**=#%@#==#\n    #*:@*+++=:                                                                                                                                                          =+++@*++=:\n  :*-=*=++..                                                                                                                                                             .=*=#*.%=\n +#.=+++:                                                                                                                                                                   ++++:+#\n*+=#-::                                                                                                                                                                      .::*+=*\n\n*/\n\ncontract ChainRunnersBaseRenderer is Ownable, ReentrancyGuard {\n    struct SVGCursor {\n        uint8 x;\n        uint8 y;\n        string color1;\n        string color2;\n        string color3;\n        string color4;\n    }\n\n    struct Buffer {\n        string one;\n        string two;\n        string three;\n        string four;\n        string five;\n        string six;\n        string seven;\n        string eight;\n    }\n\n    struct Color {\n        string hexString;\n        uint alpha;\n        uint red;\n        uint green;\n        uint blue;\n    }\n\n    struct Layer {\n        string name;\n        bytes hexString;\n    }\n\n    struct LayerInput {\n        string name;\n        bytes hexString;\n        uint8 layerIndex;\n        uint8 itemIndex;\n    }\n\n    uint256 public constant NUM_LAYERS = 13;\n    uint256 public constant NUM_COLORS = 8;\n\n    mapping(uint256 => Layer) [NUM_LAYERS] layers;\n\n    /*\n    This indexes into a race, then a layer index, then an array capturing the frequency each layer should be selected.\n    Shout out to Anonymice for the rarity impl inspiration.\n    */\n    uint16[][NUM_LAYERS][3] WEIGHTS;\n\n    constructor() {\n        // Default\n        WEIGHTS[0][0] = [36, 225, 225, 225, 360, 135, 27, 360, 315, 315, 315, 315, 225, 180, 225, 180, 360, 180, 45, 360, 360, 360, 27, 36, 360, 45, 180, 360, 225, 360, 225, 225, 360, 180, 45, 360, 18, 225, 225, 225, 225, 180, 225, 361];\n        WEIGHTS[0][1] = [875, 1269, 779, 779, 779, 779, 779, 779, 779, 779, 779, 779, 17, 8, 41];\n        WEIGHTS[0][2] = [303, 303, 303, 303, 151, 30, 0, 0, 151, 151, 151, 151, 30, 303, 151, 30, 303, 303, 303, 303, 303, 303, 30, 151, 303, 303, 303, 303, 303, 303, 303, 303, 3066];\n        WEIGHTS[0][3] = [645, 0, 1290, 322, 645, 645, 645, 967, 322, 967, 645, 967, 967, 973];\n        WEIGHTS[0][4] = [0, 0, 0, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250];\n        WEIGHTS[0][5] = [121, 121, 121, 121, 121, 121, 243, 0, 0, 0, 0, 121, 121, 243, 121, 121, 243, 121, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 243, 0, 0, 0, 121, 121, 243, 121, 121, 306];\n        WEIGHTS[0][6] = [925, 555, 185, 555, 925, 925, 185, 1296, 1296, 1296, 1857];\n        WEIGHTS[0][7] = [88, 88, 88, 88, 88, 265, 442, 8853];\n        WEIGHTS[0][8] = [189, 189, 47, 18, 9, 28, 37, 9483];\n        WEIGHTS[0][9] = [340, 340, 340, 340, 340, 340, 34, 340, 340, 340, 340, 170, 170, 170, 102, 238, 238, 238, 272, 340, 340, 340, 272, 238, 238, 238, 238, 170, 34, 340, 340, 136, 340, 340, 340, 340, 344];\n        WEIGHTS[0][10] = [159, 212, 106, 53, 26, 159, 53, 265, 53, 212, 159, 265, 53, 265, 265, 212, 53, 159, 239, 53, 106, 5, 106, 53, 212, 212, 106, 159, 212, 265, 212, 265, 5066];\n        WEIGHTS[0][11] = [139, 278, 278, 250, 250, 194, 222, 278, 278, 194, 222, 83, 222, 278, 139, 139, 27, 278, 278, 278, 278, 27, 278, 139, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 27, 139, 139, 139, 139, 0, 278, 194, 83, 83, 278, 83, 27, 306];\n        WEIGHTS[0][12] = [981, 2945, 654, 16, 981, 327, 654, 163, 3279];\n\n        // Skull\n        WEIGHTS[1][0] = [36, 225, 225, 225, 360, 135, 27, 360, 315, 315, 315, 315, 225, 180, 225, 180, 360, 180, 45, 360, 360, 360, 27, 36, 360, 45, 180, 360, 225, 360, 225, 225, 360, 180, 45, 360, 18, 225, 225, 225, 225, 180, 225, 361];\n        WEIGHTS[1][1] = [875, 1269, 779, 779, 779, 779, 779, 779, 779, 779, 779, 779, 17, 8, 41];\n        WEIGHTS[1][2] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10000];\n        WEIGHTS[1][3] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        WEIGHTS[1][4] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        WEIGHTS[1][5] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 384, 7692, 1923, 0, 0, 0, 0, 0, 1];\n        WEIGHTS[1][6] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10000];\n        WEIGHTS[1][7] = [0, 0, 0, 0, 0, 909, 0, 9091];\n        WEIGHTS[1][8] = [0, 0, 0, 0, 0, 0, 0, 10000];\n        WEIGHTS[1][9] = [526, 526, 526, 0, 0, 0, 0, 0, 526, 0, 0, 0, 526, 0, 526, 0, 0, 0, 526, 526, 526, 526, 526, 526, 526, 526, 526, 526, 526, 0, 0, 526, 0, 0, 0, 0, 532];\n        WEIGHTS[1][10] = [80, 0, 400, 240, 80, 0, 240, 0, 0, 80, 80, 80, 0, 0, 0, 0, 80, 80, 0, 0, 80, 80, 0, 80, 80, 80, 80, 80, 0, 0, 0, 0, 8000];\n        WEIGHTS[1][11] = [289, 0, 0, 0, 0, 404, 462, 578, 578, 0, 462, 173, 462, 578, 0, 0, 57, 0, 57, 0, 57, 57, 578, 289, 578, 57, 0, 57, 57, 57, 578, 578, 0, 0, 0, 0, 0, 0, 57, 289, 578, 0, 0, 0, 231, 57, 0, 0, 1745];\n        WEIGHTS[1][12] = [714, 714, 714, 0, 714, 0, 0, 0, 7144];\n\n        // Bot\n        WEIGHTS[2][0] = [36, 225, 225, 225, 360, 135, 27, 360, 315, 315, 315, 315, 225, 180, 225, 180, 360, 180, 45, 360, 360, 360, 27, 36, 360, 45, 180, 360, 225, 360, 225, 225, 360, 180, 45, 360, 18, 225, 225, 225, 225, 180, 225, 361];\n        WEIGHTS[2][1] = [875, 1269, 779, 779, 779, 779, 779, 779, 779, 779, 779, 779, 17, 8, 41];\n        WEIGHTS[2][2] = [303, 303, 303, 303, 151, 30, 0, 0, 151, 151, 151, 151, 30, 303, 151, 30, 303, 303, 303, 303, 303, 303, 30, 151, 303, 303, 303, 303, 303, 303, 303, 303, 3066];\n        WEIGHTS[2][3] = [645, 0, 1290, 322, 645, 645, 645, 967, 322, 967, 645, 967, 967, 973];\n        WEIGHTS[2][4] = [2500, 2500, 2500, 0, 0, 0, 0, 0, 0, 2500, 0];\n        WEIGHTS[2][5] = [0, 0, 0, 0, 0, 0, 588, 588, 588, 588, 588, 0, 0, 588, 0, 0, 588, 0, 0, 0, 0, 0, 588, 0, 0, 0, 0, 588, 0, 0, 0, 588, 588, 0, 0, 0, 588, 0, 0, 0, 0, 588, 0, 0, 0, 0, 0, 0, 0, 0, 0, 588, 0, 0, 0, 0, 588, 0, 0, 0, 0, 588, 0, 0, 0, 0, 0, 0, 0, 0, 588, 0, 0, 4];\n        WEIGHTS[2][6] = [925, 555, 185, 555, 925, 925, 185, 1296, 1296, 1296, 1857];\n        WEIGHTS[2][7] = [88, 88, 88, 88, 88, 265, 442, 8853];\n        WEIGHTS[2][8] = [183, 274, 274, 18, 18, 27, 36, 9170];\n        WEIGHTS[2][9] = [340, 340, 340, 340, 340, 340, 34, 340, 340, 340, 340, 170, 170, 170, 102, 238, 238, 238, 272, 340, 340, 340, 272, 238, 238, 238, 238, 170, 34, 340, 340, 136, 340, 340, 340, 340, 344];\n        WEIGHTS[2][10] = [217, 362, 217, 144, 72, 289, 144, 362, 72, 289, 217, 362, 72, 362, 362, 289, 0, 217, 0, 72, 144, 7, 217, 72, 217, 217, 289, 217, 289, 362, 217, 362, 3269];\n        WEIGHTS[2][11] = [139, 278, 278, 250, 250, 194, 222, 278, 278, 194, 222, 83, 222, 278, 139, 139, 27, 278, 278, 278, 278, 27, 278, 139, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 27, 139, 139, 139, 139, 0, 278, 194, 83, 83, 278, 83, 27, 306];\n        WEIGHTS[2][12] = [981, 2945, 654, 16, 981, 327, 654, 163, 3279];\n    }\n\n    function setLayers(LayerInput[] calldata toSet) external onlyOwner {\n        for (uint16 i = 0; i < toSet.length; i++) {\n            layers[toSet[i].layerIndex][toSet[i].itemIndex] = Layer(toSet[i].name, toSet[i].hexString);\n        }\n    }\n\n    function getLayer(uint8 layerIndex, uint8 itemIndex) public view returns (Layer memory) {\n        return layers[layerIndex][itemIndex];\n    }\n\n    /*\n    Get race index.  Race index represents the \"type\" of base character:\n\n    0 - Default, representing human and alien characters\n    1 - Skull\n    2 - Bot\n\n    This allows skull/bot characters to have distinct trait distributions.\n    */\n    function getRaceIndex(uint16 _dna) public view returns (uint8) {\n        uint16 lowerBound;\n        uint16 percentage;\n        for (uint8 i; i < WEIGHTS[0][1].length; i++) {\n            percentage = WEIGHTS[0][1][i];\n            if (_dna >= lowerBound && _dna < lowerBound + percentage) {\n                if (i == 1) {\n                    // Bot\n                    return 2;\n                } else if (i > 11) {\n                    // Skull\n                    return 1;\n                } else {\n                    // Default\n                    return 0;\n                }\n            }\n            lowerBound += percentage;\n        }\n        revert();\n    }\n\n    function getLayerIndex(uint16 _dna, uint8 _index, uint16 _raceIndex) public view returns (uint) {\n        uint16 lowerBound;\n        uint16 percentage;\n        for (uint8 i; i < WEIGHTS[_raceIndex][_index].length; i++) {\n            percentage = WEIGHTS[_raceIndex][_index][i];\n            if (_dna >= lowerBound && _dna < lowerBound + percentage) {\n                return i;\n            }\n            lowerBound += percentage;\n        }\n        // If not found, return index higher than available layers.  Will get filtered out.\n        return WEIGHTS[_raceIndex][_index].length;\n    }\n\n    /*\n    Generate base64 encoded tokenURI.\n\n    All string constants are pre-base64 encoded to save gas.\n    Input strings are padded with spacing/etc to ensure their length is a multiple of 3.\n    This way the resulting base64 encoded string is a multiple of 4 and will not include any '=' padding characters,\n    which allows these base64 string snippets to be concatenated with other snippets.\n    */\n    function tokenURI(uint256 tokenId, ChainRunnersTypes.ChainRunner memory runnerData) public view returns (string memory) {\n        (Layer [NUM_LAYERS] memory tokenLayers, Color [NUM_COLORS][NUM_LAYERS] memory tokenPalettes, uint8 numTokenLayers, string[NUM_LAYERS] memory traitTypes) = getTokenData(runnerData.dna);\n        string memory attributes;\n        for (uint8 i = 0; i < numTokenLayers; i++) {\n            attributes = string(abi.encodePacked(attributes,\n                bytes(attributes).length == 0 ? 'eyAg' : 'LCB7',\n                'InRyYWl0X3R5cGUiOiAi', traitTypes[i], 'IiwidmFsdWUiOiAi', tokenLayers[i].name, 'IiB9'\n                ));\n        }\n        string[4] memory svgBuffers = tokenSVGBuffer(tokenLayers, tokenPalettes, numTokenLayers);\n        return string(abi.encodePacked(\n                'data:application/json;base64,eyAgImltYWdlX2RhdGEiOiAiPHN2ZyB2ZXJzaW9uPScxLjEnIHZpZXdCb3g9JzAgMCAzMjAgMzIwJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHNoYXBlLXJlbmRlcmluZz0nY3Jpc3BFZGdlcyc+',\n                svgBuffers[0], svgBuffers[1], svgBuffers[2], svgBuffers[3],\n                'PHN0eWxlPnJlY3R7d2lkdGg6MTBweDtoZWlnaHQ6MTBweDt9PC9zdHlsZT48L3N2Zz4gIiwgImF0dHJpYnV0ZXMiOiBb',\n                attributes,\n                'XSwgICAibmFtZSI6IlJ1bm5lciAj',\n                Base64.encode(uintToByteString(tokenId, 6)),\n                'IiwgImRlc2NyaXB0aW9uIjogIkNoYWluIFJ1bm5lcnMgYXJlIE1lZ2EgQ2l0eSByZW5lZ2FkZXMgMTAwJSBnZW5lcmF0ZWQgb24gY2hhaW4uIn0g'\n            ));\n    }\n\n    function tokenSVG(uint256 _dna) public view returns (string memory) {\n        (Layer [NUM_LAYERS] memory tokenLayers, Color [NUM_COLORS][NUM_LAYERS] memory tokenPalettes, uint8 numTokenLayers, string[NUM_LAYERS] memory traitTypes) = getTokenData(_dna);\n        string[4] memory buffer256 = tokenSVGBuffer(tokenLayers, tokenPalettes, numTokenLayers);\n        return string(abi.encodePacked(\n                \"PHN2ZyB2ZXJzaW9uPScxLjEnIHZpZXdCb3g9JzAgMCAzMiAzMicgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyBzaGFwZS1yZW5kZXJpbmc9J2NyaXNwRWRnZXMnIGhlaWdodD0nMTAwJScgd2lkdGg9JzEwMCUnICA+\",\n                buffer256[0], buffer256[1], buffer256[2], buffer256[3],\n                \"PHN0eWxlPnJlY3R7d2lkdGg6MXB4O2hlaWdodDoxcHg7fTwvc3R5bGU+PC9zdmc+\"\n            )\n        );\n    }\n\n    function getTokenData(uint256 _dna) public view returns (Layer [NUM_LAYERS] memory tokenLayers, Color [NUM_COLORS][NUM_LAYERS] memory tokenPalettes, uint8 numTokenLayers, string [NUM_LAYERS] memory traitTypes) {\n        uint16[NUM_LAYERS] memory dna = splitNumber(_dna);\n        uint16 raceIndex = getRaceIndex(dna[1]);\n\n        bool hasFaceAcc = dna[7] < (10000 - WEIGHTS[raceIndex][7][7]);\n        bool hasMask = dna[8] < (10000 - WEIGHTS[raceIndex][8][7]);\n        bool hasHeadBelow = dna[9] < (10000 - WEIGHTS[raceIndex][9][36]);\n        bool hasHeadAbove = dna[11] < (10000 - WEIGHTS[raceIndex][11][48]);\n        bool useHeadAbove = (dna[0] % 2) > 0;\n        for (uint8 i = 0; i < NUM_LAYERS; i ++) {\n            Layer memory layer = layers[i][getLayerIndex(dna[i], i, raceIndex)];\n            if (layer.hexString.length > 0) {\n                /*\n                These conditions help make sure layer selection meshes well visually.\n                1. If mask, no face/eye acc/mouth acc\n                2. If face acc, no mask/mouth acc/face\n                3. If both head above & head below, randomly choose one\n                */\n                if (((i == 2 || i == 12) && !hasMask && !hasFaceAcc) || (i == 7 && !hasMask) || (i == 10 && !hasMask) || (i < 2 || (i > 2 && i < 7) || i == 8 || i == 9 || i == 11)) {\n                    if (hasHeadBelow && hasHeadAbove && (i == 9 && useHeadAbove) || (i == 11 && !useHeadAbove)) continue;\n                    tokenLayers[numTokenLayers] = layer;\n                    tokenPalettes[numTokenLayers] = palette(tokenLayers[numTokenLayers].hexString);\n                    traitTypes[numTokenLayers] = [\"QmFja2dyb3VuZCAg\",\"UmFjZSAg\",\"RmFjZSAg\",\"TW91dGgg\",\"Tm9zZSAg\",\"RXllcyAg\",\"RWFyIEFjY2Vzc29yeSAg\",\"RmFjZSBBY2Nlc3Nvcnkg\",\"TWFzayAg\",\"SGVhZCBCZWxvdyAg\",\"RXllIEFjY2Vzc29yeSAg\",\"SGVhZCBBYm92ZSAg\",\"TW91dGggQWNjZXNzb3J5\"][i];\n                    numTokenLayers++;\n                }\n            }\n        }\n        return (tokenLayers, tokenPalettes, numTokenLayers, traitTypes);\n    }\n\n    /*\n    Generate svg rects, leaving un-concatenated to save a redundant concatenation in calling functions to reduce gas.\n    Shout out to Blitmap for a lot of the inspiration for efficient rendering here.\n    */\n    function tokenSVGBuffer(Layer [NUM_LAYERS] memory tokenLayers, Color [NUM_COLORS][NUM_LAYERS] memory tokenPalettes, uint8 numTokenLayers) public pure returns (string[4] memory) {\n        // Base64 encoded lookups into x/y position strings from 010 to 310.\n        string[32] memory lookup = [\"MDAw\", \"MDEw\", \"MDIw\", \"MDMw\", \"MDQw\", \"MDUw\", \"MDYw\", \"MDcw\", \"MDgw\", \"MDkw\", \"MTAw\", \"MTEw\", \"MTIw\", \"MTMw\", \"MTQw\", \"MTUw\", \"MTYw\", \"MTcw\", \"MTgw\", \"MTkw\", \"MjAw\", \"MjEw\", \"MjIw\", \"MjMw\", \"MjQw\", \"MjUw\", \"MjYw\", \"Mjcw\", \"Mjgw\", \"Mjkw\", \"MzAw\", \"MzEw\"];\n        SVGCursor memory cursor;\n\n        /*\n        Rather than concatenating the result string with itself over and over (e.g. result = abi.encodePacked(result, newString)),\n        we fill up multiple levels of buffers.  This reduces redundant intermediate concatenations, performing O(log(n)) concats\n        instead of O(n) concats.  Buffers beyond a length of about 12 start hitting stack too deep issues, so using a length of 8\n        because the pixel math is convenient.\n        */\n        Buffer memory buffer4;\n        // 4 pixels per slot, 32 total.  Struct is ever so slightly better for gas, so using when convenient.\n        string[8] memory buffer32;\n        // 32 pixels per slot, 256 total\n        string[4] memory buffer256;\n        // 256 pixels per slot, 1024 total\n        uint8 buffer32count;\n        uint8 buffer256count;\n        for (uint k = 32; k < 416;) {\n            cursor.color1 = colorForIndex(tokenLayers, k, 0, tokenPalettes, numTokenLayers);\n            cursor.color2 = colorForIndex(tokenLayers, k, 1, tokenPalettes, numTokenLayers);\n            cursor.color3 = colorForIndex(tokenLayers, k, 2, tokenPalettes, numTokenLayers);\n            cursor.color4 = colorForIndex(tokenLayers, k, 3, tokenPalettes, numTokenLayers);\n            buffer4.one = pixel4(lookup, cursor);\n            cursor.x += 4;\n\n            cursor.color1 = colorForIndex(tokenLayers, k, 4, tokenPalettes, numTokenLayers);\n            cursor.color2 = colorForIndex(tokenLayers, k, 5, tokenPalettes, numTokenLayers);\n            cursor.color3 = colorForIndex(tokenLayers, k, 6, tokenPalettes, numTokenLayers);\n            cursor.color4 = colorForIndex(tokenLayers, k, 7, tokenPalettes, numTokenLayers);\n            buffer4.two = pixel4(lookup, cursor);\n            cursor.x += 4;\n\n            k += 3;\n\n            cursor.color1 = colorForIndex(tokenLayers, k, 0, tokenPalettes, numTokenLayers);\n            cursor.color2 = colorForIndex(tokenLayers, k, 1, tokenPalettes, numTokenLayers);\n            cursor.color3 = colorForIndex(tokenLayers, k, 2, tokenPalettes, numTokenLayers);\n            cursor.color4 = colorForIndex(tokenLayers, k, 3, tokenPalettes, numTokenLayers);\n            buffer4.three = pixel4(lookup, cursor);\n            cursor.x += 4;\n\n            cursor.color1 = colorForIndex(tokenLayers, k, 4, tokenPalettes, numTokenLayers);\n            cursor.color2 = colorForIndex(tokenLayers, k, 5, tokenPalettes, numTokenLayers);\n            cursor.color3 = colorForIndex(tokenLayers, k, 6, tokenPalettes, numTokenLayers);\n            cursor.color4 = colorForIndex(tokenLayers, k, 7, tokenPalettes, numTokenLayers);\n            buffer4.four = pixel4(lookup, cursor);\n            cursor.x += 4;\n\n            k += 3;\n\n            cursor.color1 = colorForIndex(tokenLayers, k, 0, tokenPalettes, numTokenLayers);\n            cursor.color2 = colorForIndex(tokenLayers, k, 1, tokenPalettes, numTokenLayers);\n            cursor.color3 = colorForIndex(tokenLayers, k, 2, tokenPalettes, numTokenLayers);\n            cursor.color4 = colorForIndex(tokenLayers, k, 3, tokenPalettes, numTokenLayers);\n            buffer4.five = pixel4(lookup, cursor);\n            cursor.x += 4;\n\n            cursor.color1 = colorForIndex(tokenLayers, k, 4, tokenPalettes, numTokenLayers);\n            cursor.color2 = colorForIndex(tokenLayers, k, 5, tokenPalettes, numTokenLayers);\n            cursor.color3 = colorForIndex(tokenLayers, k, 6, tokenPalettes, numTokenLayers);\n            cursor.color4 = colorForIndex(tokenLayers, k, 7, tokenPalettes, numTokenLayers);\n            buffer4.six = pixel4(lookup, cursor);\n            cursor.x += 4;\n\n            k += 3;\n\n            cursor.color1 = colorForIndex(tokenLayers, k, 0, tokenPalettes, numTokenLayers);\n            cursor.color2 = colorForIndex(tokenLayers, k, 1, tokenPalettes, numTokenLayers);\n            cursor.color3 = colorForIndex(tokenLayers, k, 2, tokenPalettes, numTokenLayers);\n            cursor.color4 = colorForIndex(tokenLayers, k, 3, tokenPalettes, numTokenLayers);\n            buffer4.seven = pixel4(lookup, cursor);\n            cursor.x += 4;\n\n            cursor.color1 = colorForIndex(tokenLayers, k, 4, tokenPalettes, numTokenLayers);\n            cursor.color2 = colorForIndex(tokenLayers, k, 5, tokenPalettes, numTokenLayers);\n            cursor.color3 = colorForIndex(tokenLayers, k, 6, tokenPalettes, numTokenLayers);\n            cursor.color4 = colorForIndex(tokenLayers, k, 7, tokenPalettes, numTokenLayers);\n            buffer4.eight = pixel4(lookup, cursor);\n            cursor.x += 4;\n\n            k += 3;\n\n            buffer32[buffer32count++] = string(abi.encodePacked(buffer4.one, buffer4.two, buffer4.three, buffer4.four, buffer4.five, buffer4.six, buffer4.seven, buffer4.eight));\n            cursor.x = 0;\n            cursor.y += 1;\n            if (buffer32count >= 8) {\n                buffer256[buffer256count++] = string(abi.encodePacked(buffer32[0], buffer32[1], buffer32[2], buffer32[3], buffer32[4], buffer32[5], buffer32[6], buffer32[7]));\n                buffer32count = 0;\n            }\n        }\n        // At this point, buffer256 contains 4 strings or 256*4=1024=32x32 pixels\n        return buffer256;\n    }\n\n    function palette(bytes memory data) internal pure returns (Color [NUM_COLORS] memory) {\n        Color [NUM_COLORS] memory colors;\n        for (uint16 i = 0; i < NUM_COLORS; i++) {\n            // Even though this can be computed later from the RGBA values below, it saves gas to pre-compute it once upfront.\n            colors[i].hexString = Base64.encode(bytes(abi.encodePacked(\n                    byteToHexString(data[i * 4]),\n                    byteToHexString(data[i * 4 + 1]),\n                    byteToHexString(data[i * 4 + 2])\n                )));\n            colors[i].red = byteToUint(data[i * 4]);\n            colors[i].green = byteToUint(data[i * 4 + 1]);\n            colors[i].blue = byteToUint(data[i * 4 + 2]);\n            colors[i].alpha = byteToUint(data[i * 4 + 3]);\n        }\n        return colors;\n    }\n\n    function colorForIndex(Layer[NUM_LAYERS] memory tokenLayers, uint k, uint index, Color [NUM_COLORS][NUM_LAYERS] memory palettes, uint numTokenLayers) internal pure returns (string memory) {\n        for (uint256 i = numTokenLayers - 1; i >= 0; i--) {\n            Color memory fg = palettes[i][colorIndex(tokenLayers[i].hexString, k, index)];\n            // Since most layer pixels are transparent, performing this check first saves gas\n            if (fg.alpha == 0) {\n                continue;\n            } else if (fg.alpha == 255) {\n                return fg.hexString;\n            } else {\n                for (uint256 j = i - 1; j >= 0; j--) {\n                    Color memory bg = palettes[j][colorIndex(tokenLayers[j].hexString, k, index)];\n                    /* As a simplification, blend with first non-transparent layer then stop.\n                    We won't generally have overlapping semi-transparent pixels.\n                    */\n                    if (bg.alpha > 0) {\n                        return Base64.encode(bytes(blendColors(fg, bg)));\n                    }\n                }\n            }\n        }\n        return \"000000\";\n    }\n\n    /*\n    Each color index is 3 bits (there are 8 colors, so 3 bits are needed to index into them).\n    Since 3 bits doesn't divide cleanly into 8 bits (1 byte), we look up colors 24 bits (3 bytes) at a time.\n    \"k\" is the starting byte index, and \"index\" is the color index within the 3 bytes starting at k.\n    */\n    function colorIndex(bytes memory data, uint k, uint index) internal pure returns (uint8) {\n        if (index == 0) {\n            return uint8(data[k]) >> 5;\n        } else if (index == 1) {\n            return (uint8(data[k]) >> 2) % 8;\n        } else if (index == 2) {\n            return ((uint8(data[k]) % 4) * 2) + (uint8(data[k + 1]) >> 7);\n        } else if (index == 3) {\n            return (uint8(data[k + 1]) >> 4) % 8;\n        } else if (index == 4) {\n            return (uint8(data[k + 1]) >> 1) % 8;\n        } else if (index == 5) {\n            return ((uint8(data[k + 1]) % 2) * 4) + (uint8(data[k + 2]) >> 6);\n        } else if (index == 6) {\n            return (uint8(data[k + 2]) >> 3) % 8;\n        } else {\n            return uint8(data[k + 2]) % 8;\n        }\n    }\n\n    /*\n    Create 4 svg rects, pre-base64 encoding the svg constants to save gas.\n    */\n    function pixel4(string[32] memory lookup, SVGCursor memory cursor) internal pure returns (string memory result) {\n        return string(abi.encodePacked(\n                \"PHJlY3QgICBmaWxsPScj\", cursor.color1, \"JyAgeD0n\", lookup[cursor.x], \"JyAgeT0n\", lookup[cursor.y],\n                \"JyAvPjxyZWN0ICBmaWxsPScj\", cursor.color2, \"JyAgeD0n\", lookup[cursor.x + 1], \"JyAgeT0n\", lookup[cursor.y],\n                \"JyAvPjxyZWN0ICBmaWxsPScj\", cursor.color3, \"JyAgeD0n\", lookup[cursor.x + 2], \"JyAgeT0n\", lookup[cursor.y],\n                \"JyAvPjxyZWN0ICBmaWxsPScj\", cursor.color4, \"JyAgeD0n\", lookup[cursor.x + 3], \"JyAgeT0n\", lookup[cursor.y], \"JyAgIC8+\"\n            ));\n    }\n\n    /*\n    Blend colors, inspired by https://stackoverflow.com/a/12016968\n    */\n    function blendColors(Color memory fg, Color memory bg) internal pure returns (string memory) {\n        uint alpha = uint16(fg.alpha + 1);\n        uint inv_alpha = uint16(256 - fg.alpha);\n        return uintToHexString6(uint24((alpha * fg.blue + inv_alpha * bg.blue) >> 8) + (uint24((alpha * fg.green + inv_alpha * bg.green) >> 8) << 8) + (uint24((alpha * fg.red + inv_alpha * bg.red) >> 8) << 16));\n    }\n\n    function splitNumber(uint256 _number) internal pure returns (uint16[NUM_LAYERS] memory numbers) {\n        for (uint256 i = 0; i < numbers.length; i++) {\n            numbers[i] = uint16(_number % 10000);\n            _number >>= 14;\n        }\n        return numbers;\n    }\n\n    function uintToHexDigit(uint8 d) public pure returns (bytes1) {\n        if (0 <= d && d <= 9) {\n            return bytes1(uint8(bytes1('0')) + d);\n        } else if (10 <= uint8(d) && uint8(d) <= 15) {\n            return bytes1(uint8(bytes1('a')) + d - 10);\n        }\n        revert();\n    }\n\n    /*\n    Convert uint to hex string, padding to 6 hex nibbles\n    */\n    function uintToHexString6(uint a) public pure returns (string memory) {\n        string memory str = uintToHexString2(a);\n        if (bytes(str).length == 2) {\n            return string(abi.encodePacked(\"0000\", str));\n        } else if (bytes(str).length == 3) {\n            return string(abi.encodePacked(\"000\", str));\n        } else if (bytes(str).length == 4) {\n            return string(abi.encodePacked(\"00\", str));\n        } else if (bytes(str).length == 5) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n        return str;\n    }\n\n    /*\n    Convert uint to hex string, padding to 2 hex nibbles\n    */\n    function uintToHexString2(uint a) public pure returns (string memory) {\n        uint count = 0;\n        uint b = a;\n        while (b != 0) {\n            count++;\n            b /= 16;\n        }\n        bytes memory res = new bytes(count);\n        for (uint i = 0; i < count; ++i) {\n            b = a % 16;\n            res[count - i - 1] = uintToHexDigit(uint8(b));\n            a /= 16;\n        }\n\n        string memory str = string(res);\n        if (bytes(str).length == 0) {\n            return \"00\";\n        } else if (bytes(str).length == 1) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n        return str;\n    }\n\n    /*\n    Convert uint to byte string, padding number string with spaces at end.\n    Useful to ensure result's length is a multiple of 3, and therefore base64 encoding won't\n    result in '=' padding chars.\n    */\n    function uintToByteString(uint a, uint fixedLen) internal pure returns (bytes memory _uintAsString) {\n        uint j = a;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(fixedLen);\n        j = fixedLen;\n        if (a == 0) {\n            bstr[0] = \"0\";\n            len = 1;\n        }\n        while (j > len) {\n            j = j - 1;\n            bstr[j] = bytes1(' ');\n        }\n        uint k = len;\n        while (a != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(a - a / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            a /= 10;\n        }\n        return bstr;\n    }\n\n    function byteToUint(bytes1 b) public pure returns (uint) {\n        return uint(uint8(b));\n    }\n\n    function byteToHexString(bytes1 b) public pure returns (string memory) {\n        return uintToHexString2(byteToUint(b));\n    }\n}\n\n/// [MIT License]\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\nlibrary Base64 {\n    bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /// @notice Encodes some bytes to the base64 representation\n    function encode(bytes memory data) internal pure returns (string memory) {\n        uint256 len = data.length;\n        if (len == 0) return \"\";\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((len + 2) / 3);\n\n        // Add some extra buffer at the end\n        bytes memory result = new bytes(encodedLen + 32);\n\n        bytes memory table = TABLE;\n\n        assembly {\n            let tablePtr := add(table, 1)\n            let resultPtr := add(result, 32)\n\n            for {\n                let i := 0\n            } lt(i, len) {\n\n            } {\n                i := add(i, 3)\n                let input := and(mload(add(data, i)), 0xffffff)\n\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n                out := shl(224, out)\n\n                mstore(resultPtr, out)\n\n                resultPtr := add(resultPtr, 4)\n            }\n\n            switch mod(len, 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n\n            mstore(result, encodedLen)\n        }\n\n        return string(result);\n    }\n}\n"
27     },
28     "@openzeppelin/contracts/utils/Context.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
30     },
31     "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
33     },
34     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
36     },
37     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
39     }
40   },
41   "settings": {
42     "optimizer": {
43       "enabled": true,
44       "runs": 2000,
45       "details": {
46         "yul": true,
47         "yulDetails": {
48           "stackAllocation": true,
49           "optimizerSteps": "dhfoDgvulfnTUtnIf"
50         }
51       }
52     },
53     "outputSelection": {
54       "*": {
55         "*": [
56           "evm.bytecode",
57           "evm.deployedBytecode",
58           "devdoc",
59           "userdoc",
60           "metadata",
61           "abi"
62         ]
63       }
64     },
65     "libraries": {}
66   }
67 }}