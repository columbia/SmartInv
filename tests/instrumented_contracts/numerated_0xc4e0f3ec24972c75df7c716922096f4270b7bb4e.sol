1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/producers/crowdfunds/crowdfund-with-podium-editions/CrowdfundWithPodiumEditions.sol": {
5       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.6;\n\nimport {ERC721} from \"../../../external/ERC721.sol\";\nimport {ICrowdfundWithPodiumEditions} from \"./interface/ICrowdfundWithPodiumEditions.sol\";\n\n/**\n * @title CrowdfundWithPodiumEditions\n * @author MirrorXYZ\n */\ncontract CrowdfundWithPodiumEditions is ERC721, ICrowdfundWithPodiumEditions {\n    // ============ Constants ============\n\n    string public constant name = \"Crowdfunded Mirror Editions\";\n    string public constant symbol = \"CROWDFUND_EDITIONS\";\n\n    bytes32 public constant PRODUCER_TYPE = \"0x123123\";\n\n    uint256 internal constant REENTRANCY_NOT_ENTERED = 1;\n    uint256 internal constant REENTRANCY_ENTERED = 2;\n\n    // ============ Setup Storage ============\n\n    // The CrowdfundFactory that is able to create editions.\n    address public editionCreator;\n\n    // ============ Mutable Storage ============\n\n    // Mapping of edition id to descriptive data.\n    mapping(uint256 => Edition) public editions;\n    // Mapping of token id to edition id.\n    mapping(uint256 => uint256) public tokenToEdition;\n    // The contract that is able to mint.\n    mapping(uint256 => address) public editionToMinter;\n    // `nextTokenId` increments with each token purchased, globally across all editions.\n    uint256 private nextTokenId;\n    // Editions start at 1, in order that unsold tokens don't map to the first edition.\n    uint256 private nextEditionId = 1;\n    // Reentrancy\n    uint256 internal reentrancyStatus;\n    // Administration\n    address public owner;\n    address public nextOwner;\n    // Base URI can be modified by multisig owner, for intended future\n    // migration of API domain to a decentralized one.\n    string public baseURI;\n\n    // ============ Events ============\n\n    event EditionCreated(\n        uint256 quantity,\n        uint256 price,\n        address fundingRecipient,\n        uint256 indexed editionId\n    );\n\n    event EditionPurchased(\n        uint256 indexed editionId,\n        uint256 indexed tokenId,\n        // `numSold` at time of purchase represents the \"serial number\" of the NFT.\n        uint256 numSold,\n        uint256 amountPaid,\n        // The account that paid for and received the NFT.\n        address buyer,\n        address receiver\n    );\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    event EditionCreatorChanged(\n        address indexed previousCreator,\n        address indexed newCreator\n    );\n\n    // ============ Modifiers ============\n\n    modifier onlyOwner() {\n        require(isOwner(), \"caller is not the owner.\");\n        _;\n    }\n\n    modifier onlyNextOwner() {\n        require(isNextOwner(), \"current owner must set caller as next owner.\");\n        _;\n    }\n\n    modifier onlyMinter(uint256 editionId) {\n        // Only the minter can call this function.\n        // This allows us to mint through another contract, and\n        // there not have to transfer funds into this contract to purchase.\n        require(\n            msg.sender == editionToMinter[editionId],\n            \"sender not allowed minter\"\n        );\n        _;\n    }\n\n    // ============ Constructor ============\n\n    constructor(string memory baseURI_, address owner_) {\n        baseURI = baseURI_;\n        owner = owner_;\n    }\n\n    // ============ Setup ============\n\n    function setEditionCreator(address editionCreator_) external {\n        require(editionCreator == address(0), \"already set\");\n        editionCreator = editionCreator_;\n        emit EditionCreatorChanged(address(0), editionCreator_);\n    }\n\n    // ============ Edition Methods ============\n\n    function createEditions(\n        EditionTier[] memory tiers,\n        // The account that should receive the revenue.\n        address payable fundingRecipient,\n        // The address (e.g. crowdfund proxy) that is allowed to mint\n        // tokens in this edition.\n        address minter\n    ) external override {\n        // Only the crowdfund factory can create editions.\n        require(msg.sender == editionCreator);\n        // Copy the next edition id, which we reference in the loop.\n        uint256 firstEditionId = nextEditionId;\n        // Update the next edition id to what we expect after the loop.\n        nextEditionId += tiers.length;\n        // Execute a loop that created editions.\n        for (uint8 x = 0; x < tiers.length; x++) {\n            uint256 id = firstEditionId + x;\n            uint256 quantity = tiers[x].quantity;\n            uint256 price = tiers[x].price;\n            bytes32 contentHash = tiers[x].contentHash;\n\n            editions[id] = Edition({\n                quantity: quantity,\n                price: price,\n                fundingRecipient: fundingRecipient,\n                numSold: 0,\n                contentHash: contentHash\n            });\n\n            editionToMinter[id] = minter;\n\n            emit EditionCreated(quantity, price, fundingRecipient, id);\n        }\n    }\n\n    function buyEdition(uint256 editionId, address recipient)\n        external\n        payable\n        override\n        onlyMinter(editionId)\n        returns (uint256 tokenId)\n    {\n        return _buyEdition(editionId, recipient);\n    }\n\n    function _buyEdition(uint256 editionId, address recipient)\n        internal\n        returns (uint256 tokenId)\n    {\n        // Track and update token id.\n        tokenId = nextTokenId;\n        nextTokenId++;\n        // Check that the edition exists. Note: this is redundant\n        // with the next check, but it is useful for clearer error messaging.\n        require(editions[editionId].quantity > 0, \"Edition does not exist\");\n        // Check that there are still tokens available to purchase.\n        require(\n            editions[editionId].numSold < editions[editionId].quantity,\n            \"This edition is already sold out.\"\n        );\n        // Increment the number of tokens sold for this edition.\n        editions[editionId].numSold++;\n        // Mint a new token for the sender, using the `tokenId`.\n        _mint(recipient, tokenId);\n        // Store the mapping of token id to the edition being purchased.\n        tokenToEdition[tokenId] = editionId;\n\n        emit EditionPurchased(\n            editionId,\n            tokenId,\n            editions[editionId].numSold,\n            msg.value,\n            msg.sender,\n            recipient\n        );\n\n        return tokenId;\n    }\n\n    // ============ NFT Methods ============\n\n    // Returns e.g. https://mirror-api.com/editions/[editionId]/[tokenId]\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        // If the token does not map to an edition, it'll be 0.\n        require(tokenToEdition[tokenId] > 0, \"Token has not been sold yet\");\n        // Concatenate the components, baseURI, editionId and tokenId, to create URI.\n        return\n            string(\n                abi.encodePacked(\n                    baseURI,\n                    _toString(tokenToEdition[tokenId]),\n                    \"/\",\n                    _toString(tokenId)\n                )\n            );\n    }\n\n    // Returns e.g. https://mirror-api.com/editions/metadata\n    function contractURI() public view override returns (string memory) {\n        // Concatenate the components, baseURI, editionId and tokenId, to create URI.\n        return string(abi.encodePacked(baseURI, \"metadata\"));\n    }\n\n    // Given an edition's ID, returns its price.\n    function editionPrice(uint256 editionId)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return editions[editionId].price;\n    }\n\n    // The hash of the given content for the NFT. Can be used\n    // for IPFS storage, verifying authenticity, etc.\n    function getContentHash(uint256 tokenId) public view returns (bytes32) {\n        // If the token does not map to an edition, it'll be 0.\n        require(tokenToEdition[tokenId] > 0, \"Token has not been sold yet\");\n        // Concatenate the components, baseURI, editionId and tokenId, to create URI.\n        return editions[tokenToEdition[tokenId]].contentHash;\n    }\n\n    function getRoyaltyRecipient(uint256 tokenId)\n        public\n        view\n        returns (address)\n    {\n        require(tokenToEdition[tokenId] > 0, \"Token has not been minted yet\");\n        return editions[tokenToEdition[tokenId]].fundingRecipient;\n    }\n\n    function setRoyaltyRecipient(\n        uint256 editionId,\n        address payable newFundingRecipient\n    ) public {\n        require(\n            editions[editionId].fundingRecipient == msg.sender,\n            \"Only current fundingRecipient can modify its value\"\n        );\n\n        editions[editionId].fundingRecipient = newFundingRecipient;\n    }\n\n    // ============ Admin Methods ============\n\n    function changeBaseURI(string memory baseURI_) public onlyOwner {\n        baseURI = baseURI_;\n    }\n\n    // Allows the creator contract to be swapped out for an upgraded one.\n    // NOTE: This does not affect existing editions already minted.\n    function changeEditionCreator(address editionCreator_) public onlyOwner {\n        emit EditionCreatorChanged(editionCreator, editionCreator_);\n        editionCreator = editionCreator_;\n    }\n\n    function isOwner() public view returns (bool) {\n        return msg.sender == owner;\n    }\n\n    function isNextOwner() public view returns (bool) {\n        return msg.sender == nextOwner;\n    }\n\n    function transferOwnership(address nextOwner_) external onlyOwner {\n        require(nextOwner_ != address(0), \"Next owner is the zero address.\");\n\n        nextOwner = nextOwner_;\n    }\n\n    function cancelOwnershipTransfer() external onlyOwner {\n        delete nextOwner;\n    }\n\n    function acceptOwnership() external onlyNextOwner {\n        delete nextOwner;\n\n        emit OwnershipTransferred(owner, msg.sender);\n\n        owner = msg.sender;\n    }\n\n    function renounceOwnership() external onlyOwner {\n        emit OwnershipTransferred(owner, address(0));\n        owner = address(0);\n    }\n\n    // ============ Private Methods ============\n\n    // From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\n    function _toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
6     },
7     "contracts/external/ERC721.sol": {
8       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.6;\n\nimport {IERC721, IERC721Metadata, IERC721Receiver, IERC165} from \"./interface/IERC721.sol\";\n\nabstract contract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * Based on: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol\n */\ncontract ERC721 is ERC165, IERC721 {\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function balanceOf(address owner)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        require(\n            owner != address(0),\n            \"ERC721: balance query for the zero address\"\n        );\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        address owner = _owners[tokenId];\n        require(\n            owner != address(0),\n            \"ERC721: owner query for nonexistent token\"\n        );\n        return owner;\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        returns (string memory)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n\n        string memory baseURI = _baseURI();\n        return\n            bytes(baseURI).length > 0\n                ? string(abi.encodePacked(baseURI, tokenId))\n                : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\n     * in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721: approved query for nonexistent token\"\n        );\n\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        require(operator != msg.sender, \"ERC721: approve to caller\");\n\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(\n            _checkOnERC721Received(from, to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721: operator query for nonexistent token\"\n        );\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(\n            ERC721.ownerOf(tokenId) == from,\n            \"ERC721: transfer of token that is not own\"\n        );\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (isContract(to)) {\n            try\n                IERC721Receiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    tokenId,\n                    _data\n                )\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\n                        \"ERC721: transfer to non ERC721Receiver implementer\"\n                    );\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7f6a1666fac8ecff5dd467d0938069bc221ea9e0/contracts/utils/Address.sol\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n}\n"
9     },
10     "contracts/producers/crowdfunds/crowdfund-with-podium-editions/interface/ICrowdfundWithPodiumEditions.sol": {
11       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.6;\n\ninterface ICrowdfundWithPodiumEditions {\n    struct Edition {\n        // The maximum number of tokens that can be sold.\n        uint256 quantity;\n        // The price at which each token will be sold, in ETH.\n        uint256 price;\n        // The account that will receive sales revenue.\n        address payable fundingRecipient;\n        // The number of tokens sold so far.\n        uint256 numSold;\n        bytes32 contentHash;\n    }\n\n    struct EditionTier {\n        // The maximum number of tokens that can be sold.\n        uint256 quantity;\n        // The price at which each token will be sold, in ETH.\n        uint256 price;\n        bytes32 contentHash;\n    }\n\n    function buyEdition(uint256 editionId, address recipient)\n        external\n        payable\n        returns (uint256 tokenId);\n\n    function editionPrice(uint256 editionId) external view returns (uint256);\n\n    function createEditions(\n        EditionTier[] memory tier,\n        // The account that should receive the revenue.\n        address payable fundingRecipient,\n        address minter\n    ) external;\n\n    function contractURI() external view returns (string memory);\n}\n"
12     },
13     "contracts/external/interface/IERC721.sol": {
14       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.6;\n\ninterface IERC721 {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\ninterface IERC721Metadata {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\nabstract contract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
15     }
16   },
17   "settings": {
18     "optimizer": {
19       "enabled": true,
20       "runs": 2000
21     },
22     "outputSelection": {
23       "*": {
24         "*": [
25           "evm.bytecode",
26           "evm.deployedBytecode",
27           "abi"
28         ]
29       }
30     },
31     "libraries": {}
32   }
33 }}