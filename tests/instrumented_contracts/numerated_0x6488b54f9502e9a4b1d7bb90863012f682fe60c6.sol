1 {{
2   "language": "Solidity",
3   "sources": {
4     "lib/VRGDAs/src/LogisticVRGDA.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {wadLn, unsafeDiv, unsafeWadDiv} from \"solmate/utils/SignedWadMath.sol\";\n\nimport {VRGDA} from \"./VRGDA.sol\";\n\n/// @title Logistic Variable Rate Gradual Dutch Auction\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @notice VRGDA with a logistic issuance curve.\nabstract contract LogisticVRGDA is VRGDA {\n    /*//////////////////////////////////////////////////////////////\n                           PRICING PARAMETERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev The maximum number of tokens of tokens to sell + 1. We add\n    /// 1 because the logistic function will never fully reach its limit.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable logisticLimit;\n\n    /// @dev The maximum number of tokens of tokens to sell + 1 multiplied\n    /// by 2. We could compute it on the fly each time but this saves gas.\n    /// @dev Represented as a 36 decimal fixed point number.\n    int256 internal immutable logisticLimitDoubled;\n\n    /// @dev Time scale controls the steepness of the logistic curve,\n    /// which affects how quickly we will reach the curve's asymptote.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable timeScale;\n\n    /// @notice Sets pricing parameters for the VRGDA.\n    /// @param _targetPrice The target price for a token if sold on pace, scaled by 1e18.\n    /// @param _priceDecayPercent The percent price decays per unit of time with no sales, scaled by 1e18.\n    /// @param _maxSellable The maximum number of tokens to sell, scaled by 1e18.\n    /// @param _timeScale The steepness of the logistic curve, scaled by 1e18.\n    constructor(\n        int256 _targetPrice,\n        int256 _priceDecayPercent,\n        int256 _maxSellable,\n        int256 _timeScale\n    ) VRGDA(_targetPrice, _priceDecayPercent) {\n        // Add 1 wad to make the limit inclusive of _maxSellable.\n        logisticLimit = _maxSellable + 1e18;\n\n        // Scale by 2e18 to both double it and give it 36 decimals.\n        logisticLimitDoubled = logisticLimit * 2e18;\n\n        timeScale = _timeScale;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              PRICING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Given a number of tokens sold, return the target time that number of tokens should be sold by.\n    /// @param sold A number of tokens sold, scaled by 1e18, to get the corresponding target sale time for.\n    /// @return The target time the tokens should be sold by, scaled by 1e18, where the time is\n    /// relative, such that 0 means the tokens should be sold immediately when the VRGDA begins.\n    function getTargetSaleTime(int256 sold) public view virtual override returns (int256) {\n        unchecked {\n            return -unsafeWadDiv(wadLn(unsafeDiv(logisticLimitDoubled, sold + logisticLimit) - 1e18), timeScale);\n        }\n    }\n}\n"
6     },
7     "lib/VRGDAs/src/VRGDA.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {wadExp, wadLn, wadMul, unsafeWadMul, toWadUnsafe} from \"solmate/utils/SignedWadMath.sol\";\n\n/// @title Variable Rate Gradual Dutch Auction\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @notice Sell tokens roughly according to an issuance schedule.\nabstract contract VRGDA {\n    /*//////////////////////////////////////////////////////////////\n                            VRGDA PARAMETERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Target price for a token, to be scaled according to sales pace.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 public immutable targetPrice;\n\n    /// @dev Precomputed constant that allows us to rewrite a pow() as an exp().\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable decayConstant;\n\n    /// @notice Sets target price and per time unit price decay for the VRGDA.\n    /// @param _targetPrice The target price for a token if sold on pace, scaled by 1e18.\n    /// @param _priceDecayPercent The percent price decays per unit of time with no sales, scaled by 1e18.\n    constructor(int256 _targetPrice, int256 _priceDecayPercent) {\n        targetPrice = _targetPrice;\n\n        decayConstant = wadLn(1e18 - _priceDecayPercent);\n\n        // The decay constant must be negative for VRGDAs to work.\n        require(decayConstant < 0, \"NON_NEGATIVE_DECAY_CONSTANT\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              PRICING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Calculate the price of a token according to the VRGDA formula.\n    /// @param timeSinceStart Time passed since the VRGDA began, scaled by 1e18.\n    /// @param sold The total number of tokens that have been sold so far.\n    /// @return The price of a token according to VRGDA, scaled by 1e18.\n    function getVRGDAPrice(int256 timeSinceStart, uint256 sold) public view virtual returns (uint256) {\n        unchecked {\n            // prettier-ignore\n            return uint256(wadMul(targetPrice, wadExp(unsafeWadMul(decayConstant,\n                // Theoretically calling toWadUnsafe with sold can silently overflow but under\n                // any reasonable circumstance it will never be large enough. We use sold + 1 as\n                // the VRGDA formula's n param represents the nth token and sold is the n-1th token.\n                timeSinceStart - getTargetSaleTime(toWadUnsafe(sold + 1))\n            ))));\n        }\n    }\n\n    /// @dev Given a number of tokens sold, return the target time that number of tokens should be sold by.\n    /// @param sold A number of tokens sold, scaled by 1e18, to get the corresponding target sale time for.\n    /// @return The target time the tokens should be sold by, scaled by 1e18, where the time is\n    /// relative, such that 0 means the tokens should be sold immediately when the VRGDA begins.\n    function getTargetSaleTime(int256 sold) public view virtual returns (int256);\n}\n"
9     },
10     "lib/goo-issuance/src/LibGOO.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\n/// @title GOO (Gradual Ownership Optimization) Issuance\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @notice Implementation of the GOO Issuance mechanism.\nlibrary LibGOO {\n    using FixedPointMathLib for uint256;\n\n    /// @notice Compute goo balance based on emission multiple, last balance, and time elapsed.\n    /// @param emissionMultiple The multiple on emissions to consider when computing the balance.\n    /// @param lastBalanceWad The last checkpointed balance to apply the emission multiple over time to, scaled by 1e18.\n    /// @param timeElapsedWad The time elapsed since the last checkpoint, scaled by 1e18.\n    function computeGOOBalance(\n        uint256 emissionMultiple,\n        uint256 lastBalanceWad,\n        uint256 timeElapsedWad\n    ) internal pure returns (uint256) {\n        unchecked {\n            // We use wad math here because timeElapsedWad is, as the name indicates, a wad.\n            uint256 timeElapsedSquaredWad = timeElapsedWad.mulWadDown(timeElapsedWad);\n\n            // prettier-ignore\n            return lastBalanceWad + // The last recorded balance.\n\n            // Don't need to do wad multiplication since we're\n            // multiplying by a plain integer with no decimals.\n            // Shift right by 2 is equivalent to division by 4.\n            ((emissionMultiple * timeElapsedSquaredWad) >> 2) +\n\n            timeElapsedWad.mulWadDown( // Terms are wads, so must mulWad.\n                // No wad multiplication for emissionMultiple * lastBalance\n                // because emissionMultiple is a plain integer with no decimals.\n                // We multiply the sqrt's radicand by 1e18 because it expects ints.\n                (emissionMultiple * lastBalanceWad * 1e18).sqrt()\n            );\n        }\n    }\n}\n"
12     },
13     "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
15     },
16     "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
18     },
19     "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
21     },
22     "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
24     },
25     "lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
27     },
28     "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
30     },
31     "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
33     },
34     "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and 'to' cannot be the zero address at the same time.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
36     },
37     "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
39     },
40     "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
41       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
42     },
43     "lib/openzeppelin-contracts/contracts/token/ERC721/utils/ERC721Holder.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
45     },
46     "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
47       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
48     },
49     "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
50       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
51     },
52     "lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
53       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = 1;\n\n            // compute log10(value), and add it to length\n            uint256 valueCopy = value;\n            if (valueCopy >= 10**64) {\n                valueCopy /= 10**64;\n                length += 64;\n            }\n            if (valueCopy >= 10**32) {\n                valueCopy /= 10**32;\n                length += 32;\n            }\n            if (valueCopy >= 10**16) {\n                valueCopy /= 10**16;\n                length += 16;\n            }\n            if (valueCopy >= 10**8) {\n                valueCopy /= 10**8;\n                length += 8;\n            }\n            if (valueCopy >= 10**4) {\n                valueCopy /= 10**4;\n                length += 4;\n            }\n            if (valueCopy >= 10**2) {\n                valueCopy /= 10**2;\n                length += 2;\n            }\n            if (valueCopy >= 10**1) {\n                length += 1;\n            }\n            // now, length is log10(value) + 1\n\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = 1;\n\n            // compute log256(value), and add it to length\n            uint256 valueCopy = value;\n            if (valueCopy >= 1 << 128) {\n                valueCopy >>= 128;\n                length += 16;\n            }\n            if (valueCopy >= 1 << 64) {\n                valueCopy >>= 64;\n                length += 8;\n            }\n            if (valueCopy >= 1 << 32) {\n                valueCopy >>= 32;\n                length += 4;\n            }\n            if (valueCopy >= 1 << 16) {\n                valueCopy >>= 16;\n                length += 2;\n            }\n            if (valueCopy >= 1 << 8) {\n                valueCopy >>= 8;\n                length += 1;\n            }\n            // now, length is log256(value) + 1\n\n            return toHexString(value, length);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
54     },
55     "lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {
56       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
57     },
58     "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
59       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
60     },
61     "lib/solmate/src/utils/FixedPointMathLib.sol": {
62       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
63     },
64     "lib/solmate/src/utils/SignedWadMath.sol": {
65       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Signed 18 decimal fixed point (wad) arithmetic library.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SignedWadMath.sol)\n/// @author Modified from Remco Bloemen (https://xn--2-umb.com/22/exp-ln/index.html)\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction toWadUnsafe(uint256 x) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18.\n        r := mul(x, 1000000000000000000)\n    }\n}\n\n/// @dev Takes an integer amount of seconds and converts it to a wad amount of days.\n/// @dev Will not revert on overflow, only use where overflow is not possible.\n/// @dev Not meant for negative second amounts, it assumes x is positive.\nfunction toDaysWadUnsafe(uint256 x) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18 and then divide it by 86400.\n        r := div(mul(x, 1000000000000000000), 86400)\n    }\n}\n\n/// @dev Takes a wad amount of days and converts it to an integer amount of seconds.\n/// @dev Will not revert on overflow, only use where overflow is not possible.\n/// @dev Not meant for negative day amounts, it assumes x is positive.\nfunction fromDaysWadUnsafe(int256 x) pure returns (uint256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 86400 and then divide it by 1e18.\n        r := div(mul(x, 86400), 1000000000000000000)\n    }\n}\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadMul(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by y and divide by 1e18.\n        r := sdiv(mul(x, y), 1000000000000000000)\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero and will\n/// not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18 and divide it by y.\n        r := sdiv(mul(x, 1000000000000000000), y)\n    }\n}\n\nfunction wadMul(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Store x * y in r for now.\n        r := mul(x, y)\n\n        // Equivalent to require(x == 0 || (x * y) / x == y)\n        if iszero(or(iszero(x), eq(sdiv(r, x), y))) {\n            revert(0, 0)\n        }\n\n        // Scale the result down by 1e18.\n        r := sdiv(r, 1000000000000000000)\n    }\n}\n\nfunction wadDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Store x * 1e18 in r for now.\n        r := mul(x, 1000000000000000000)\n\n        // Equivalent to require(y != 0 && ((x * 1e18) / 1e18 == x))\n        if iszero(and(iszero(iszero(y)), eq(sdiv(r, 1000000000000000000), x))) {\n            revert(0, 0)\n        }\n\n        // Divide r by y.\n        r := sdiv(r, y)\n    }\n}\n\nfunction wadExp(int256 x) pure returns (int256 r) {\n    unchecked {\n        // When the result is < 0.5 we return zero. This happens when\n        // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n        if (x <= -42139678854452767551) return 0;\n\n        // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n        // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n        if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n        // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n        // for more intermediate precision and a binary basis. This base conversion\n        // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n        x = (x << 78) / 5**18;\n\n        // Reduce range of x to (- ln 2,  ln 2) * 2**96 by factoring out powers\n        // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n        // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n        int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n        x = x - k * 54916777467707473351141471128;\n\n        // k is in the range [-61, 195].\n\n        // Evaluate using a (6, 7)-term rational approximation.\n        // p is made monic, we'll multiply by a scale factor later.\n        int256 y = x + 1346386616545796478920950773328;\n        y = ((y * x) >> 96) + 57155421227552351082224309758442;\n        int256 p = y + x - 94201549194550492254356042504812;\n        p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n        p = p * x + (4385272521454847904659076985693276 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        int256 q = x - 2855989394907223263936484059900;\n        q = ((q * x) >> 96) + 50020603652535783019961831881945;\n        q = ((q * x) >> 96) - 533845033583426703283633433725380;\n        q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n        q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n        q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial won't have zeros in the domain as all its roots are complex.\n            // No scaling is necessary because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r should be in the range (0.09, 0.25) * 2**96.\n\n        // We now need to multiply r by:\n        // * the scale factor s = ~6.031367120.\n        // * the 2**k factor from the range reduction.\n        // * the 1e18 / 2**96 factor for base conversion.\n        // We do this all at once, with an intermediate result in 2**213\n        // basis, so the final right shift is always by a positive amount.\n        r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n    }\n}\n\nfunction wadLn(int256 x) pure returns (int256 r) {\n    unchecked {\n        require(x > 0, \"UNDEFINED\");\n\n        // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n        // We do this by multiplying by 2**96 / 10**18. But since\n        // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n        // and add ln(2**96 / 10**18) at the end.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n\n        // Reduce range of x to (1, 2) * 2**96\n        // ln(2^k * x) = k * ln(2) + ln(x)\n        int256 k = r - 96;\n        x <<= uint256(159 - k);\n        x = int256(uint256(x) >> 159);\n\n        // Evaluate using a (8, 8)-term rational approximation.\n        // p is made monic, we will multiply by a scale factor later.\n        int256 p = x + 3273285459638523848632254066296;\n        p = ((p * x) >> 96) + 24828157081833163892658089445524;\n        p = ((p * x) >> 96) + 43456485725739037958740375743393;\n        p = ((p * x) >> 96) - 11111509109440967052023855526967;\n        p = ((p * x) >> 96) - 45023709667254063763336534515857;\n        p = ((p * x) >> 96) - 14706773417378608786704636184526;\n        p = p * x - (795164235651350426258249787498 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        // q is monic by convention.\n        int256 q = x + 5573035233440673466300451813936;\n        q = ((q * x) >> 96) + 71694874799317883764090561454958;\n        q = ((q * x) >> 96) + 283447036172924575727196451306956;\n        q = ((q * x) >> 96) + 401686690394027663651624208769553;\n        q = ((q * x) >> 96) + 204048457590392012362485061816622;\n        q = ((q * x) >> 96) + 31853899698501571402653359427138;\n        q = ((q * x) >> 96) + 909429971244387300277376558375;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r is in the range (0, 0.125) * 2**96\n\n        // Finalization, we need to:\n        // * multiply by the scale factor s = 5.549\n        // * add ln(2**96 / 10**18)\n        // * add k * ln(2)\n        // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n        // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n        r *= 1677202110996718588342820967067443963516166;\n        // add ln(2) * k * 5e18 * 2**192\n        r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n        // add ln(2**96 / 10**18) * 5e18 * 2**192\n        r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n        // base conversion: mul 2**18 / 2**192\n        r >>= 174;\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero.\nfunction unsafeDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Divide x by y.\n        r := sdiv(x, y)\n    }\n}\n"
66     },
67     "src/KnifeGame.sol": {
68       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {Ownable} from \"@openzeppelin/access/Ownable.sol\";\nimport {ERC20} from \"@openzeppelin/token/ERC20/ERC20.sol\";\nimport {ERC721Holder} from \"@openzeppelin/token/ERC721/utils/ERC721Holder.sol\";\n\nimport {toWadUnsafe, toDaysWadUnsafe} from \"solmate/utils/SignedWadMath.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {LibGOO} from \"goo-issuance/LibGOO.sol\";\n\nimport {LVRGDA} from \"./LVRGDA.sol\";\nimport {KnifeNFT, SpyNFT, GooBalanceUpdateType} from \"./NFT.sol\";\n\n/// @title Knife Game Logic\n/// @author Libevm <libevm32@gmail.com>\n/// @notice A funny game\ncontract KnifeGame is ERC721Holder, Ownable {\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the SPY NFT contract\n    SpyNFT public immutable spyNFT;\n\n    /// @notice The address of the Knives NFT contract\n    KnifeNFT public immutable knifeNFT;\n\n    /// @notice Prices curves for the NFTs\n    LVRGDA public spyLVRGDA;\n    LVRGDA public knifeLVRGDA;\n\n    /*//////////////////////////////////////////////////////////////\n                            CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Safe multisig knifegamexyz.eth\n    address public constant MULTISIG =\n        0x503C42470951B7c163730fD8b67EA66FECd8c774;\n\n    /// @notice knife-game-treasury\n    address public constant SHOUTS_FUNDS_RECIPIENT =\n        0xDb42214E11bF1d49df83D311c3d88AaCDE666243;\n\n    /// @notice Burn address\n    address public constant BURN_ADDRESS =\n        0x000000000000000000000000000000000000dEaD;\n\n    /// @notice How much $$ per user\n    uint256 public constant INITIAL_PURCHASE_SPY_ETH_PRICE = 0.1 ether;\n\n    /*//////////////////////////////////////////////////////////////\n                            GAME VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Timestamp for the start of minting.\n    uint256 public immutable gameStart;\n\n    /// @notice Number of spies minted from moo.\n    uint128 public spiesMintedFromMoo;\n\n    /// @notice Number of knives minted from moo.\n    uint128 public knivesMintedFromMoo;\n\n    /// @notice Number of purchases per day (after game)\n    mapping(address => mapping(uint256 => uint256)) public userPurchasesOnDay;\n\n    /// @notice Have the users purchased pre-game\n    mapping(address => bool) public hasUserPrepurchased;\n\n    /// @notice Have the users claimed free MOO tokens pre-game\n    mapping(address => bool) public hasUserClaimedFreeMooTokens;\n\n    /// @notice Have reimbursements happened?\n    bool public isReimbursed;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error TooEarly();\n    error TooLate();\n    error TooPoor();\n    error DumbMove();\n\n    error NotOwner();\n    error NoWhales();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Shouted(address indexed sender, string message);\n\n    event SpyPurchasedETH(address indexed recipient, uint256 indexed id);\n    event SpyPurchasedMoo(\n        address indexed recipient,\n        uint256 indexed id,\n        uint256 price\n    );\n    event SpyKilled(\n        address indexed hitman,\n        address indexed victim,\n        uint256 knifeId,\n        uint256 spyId\n    );\n\n    event KnifePurchased(\n        address indexed recipient,\n        uint256 indexed id,\n        uint256 price\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        uint256 _gameStart,\n        address _spyNft,\n        address _knifeNFT\n    ) {\n        // Time\n        gameStart = _gameStart;\n\n        // NFTs\n        spyNFT = SpyNFT(_spyNft);\n        knifeNFT = KnifeNFT(_knifeNFT);\n\n        // Price curves\n        spyLVRGDA = new LVRGDA(\n            6.9e18, // Target price\n            0.5e18, // Price decay percent\n            toWadUnsafe(190 * 19),\n            0.3e18 // Time scale.\n        );\n        knifeLVRGDA = new LVRGDA(\n            8.0085e18, // Target price\n            0.6e18, // Price decay percent\n            toWadUnsafe(190 * 40),\n            0.22e18 // Time scale.\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          Permissioned\n    //////////////////////////////////////////////////////////////*/\n\n    function updateSpyVRGDA(\n        int256 _targetPrice,\n        int256 _priceDecayPercent,\n        uint256 _maxAmount,\n        int256 _timeScale\n    ) public {\n        // Only multisig can change\n        if (msg.sender != MULTISIG) revert NotOwner();\n\n        // Can't change after game starts\n        if (block.timestamp >= gameStart) revert TooLate();\n\n        spyLVRGDA = new LVRGDA(\n            _targetPrice,\n            _priceDecayPercent,\n            toWadUnsafe(_maxAmount),\n            _timeScale\n        );\n    }\n\n    function updateKnifeVRGDA(\n        int256 _targetPrice,\n        int256 _priceDecayPercent,\n        uint256 _maxAmount,\n        int256 _timeScale\n    ) public {\n        // Only multisig can change\n        if (msg.sender != MULTISIG) revert NotOwner();\n\n        // Can't change after game starts\n        if (block.timestamp > gameStart) revert TooLate();\n\n        knifeLVRGDA = new LVRGDA(\n            _targetPrice,\n            _priceDecayPercent,\n            toWadUnsafe(_maxAmount),\n            _timeScale\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          Minting Logic\n    //////////////////////////////////////////////////////////////*/\n\n    function claimFreeMoo() external {\n        // Only claimable after game starts\n        if (block.timestamp < gameStart) revert TooEarly();\n\n        // Only users who have pre purchased can claim\n        if (!hasUserPrepurchased[msg.sender]) revert DumbMove();\n\n        // Cannot claim twice\n        if (hasUserClaimedFreeMooTokens[msg.sender]) revert DumbMove();\n\n        hasUserClaimedFreeMooTokens[msg.sender] = true;\n\n        // 10 free moo!\n        spyNFT.updateUserGooBalance(\n            msg.sender,\n            10e18,\n            GooBalanceUpdateType.INCREASE\n        );\n    }\n\n    /// @notice Reimburses spies\n    function reimburseSpy(address[] memory _reimburse) public onlyOwner {\n        for (uint256 i = 0; i < _reimburse.length; i++) {\n            _purchaseSpy(_reimburse[i]);\n        }\n    }\n\n    /// @notice Buys a spy with ETH, pricing exponentially increases once game starts\n    function purchaseSpy(address user)\n        external\n        payable\n        returns (uint256 spyId)\n    {\n        // Don't be cheap\n        if (msg.value < spyPriceETH(user)) revert TooPoor();\n\n        MULTISIG.call{value: msg.value}(\"\");\n\n        spyId = _purchaseSpy(user);\n    }\n\n    /// @notice Mints a Spy using Moolah\n    function mintSpyFromMoolah(uint256 _maxPrice)\n        external\n        returns (uint256 spyId)\n    {\n        // If game has not begun, revert\n        if (block.timestamp < gameStart) revert TooEarly();\n\n        // No need to check if we're at MAX_MINTABLE\n        // spyPrice() will revert once we reach it due to its\n        // logistic nature. It will also revert prior to the mint start\n        uint256 currentPrice = spyPrice();\n\n        // If the current price is above the user's specified max, revert\n        if (currentPrice > _maxPrice) revert TooPoor();\n\n        // Decrement the user's goo by the ERC20 balance\n        spyNFT.updateUserGooBalance(\n            msg.sender,\n            currentPrice,\n            GooBalanceUpdateType.DECREASE\n        );\n\n        spyId = spyNFT.mint(\n            msg.sender,\n            block.timestamp > gameStart ? block.timestamp : gameStart\n        );\n\n        unchecked {\n            ++spiesMintedFromMoo; // Overflow should be impossible due to the supply cap\n            emit SpyPurchasedMoo(msg.sender, spyId, currentPrice);\n        }\n    }\n\n    /// @notice Mints a Knife using Moolah\n    function mintKnifeFromMoolah(uint256 _maxPrice)\n        external\n        returns (uint256 knifeId)\n    {\n        // If game has not begun, revert\n        if (block.timestamp < gameStart) revert TooEarly();\n\n        // No need to check if we're at MAX_MINTABLE\n        // spyPrice() will revert once we reach it due to its\n        // logistic nature. It will also revert prior to the mint start\n        uint256 currentPrice = knifePrice();\n\n        // If the current price is above the user's specified max, revert\n        if (currentPrice > _maxPrice) revert TooPoor();\n\n        // Decrement the user's goo by the virtual balance or ERC20 balance\n        spyNFT.updateUserGooBalance(\n            msg.sender,\n            currentPrice,\n            GooBalanceUpdateType.DECREASE\n        );\n\n        knifeId = knifeNFT.mint(msg.sender);\n\n        unchecked {\n            ++knivesMintedFromMoo; // Overflow should be impossible due to the supply cap\n            emit KnifePurchased(msg.sender, knifeId, currentPrice);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          Pricing Logic\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Spy pricing in terms of ETH\n    /// @dev Allows people to buy Spies after the game has started\n    ///      but disincentivies them to do so as it gets exponentially more expensive once the game starts\n    /// @return Current price of a spy in terms of ETH for a particular user\n    function spyPriceETH(address _user) public view returns (uint256) {\n        // If the game hasn't started, its a flat rate\n        if (block.timestamp < gameStart) return INITIAL_PURCHASE_SPY_ETH_PRICE;\n\n        // How many days since game started, and how many spies have user *purchased* on this day\n        uint256 daysSinceGameStarted = uint256(\n            toDaysWadUnsafe(block.timestamp - gameStart) / 1e18\n        );\n        uint256 userPurchased = userPurchasesOnDay[_user][daysSinceGameStarted];\n\n        // Magic algorithm\n        uint256 priceIncrease = 0;\n        for (uint256 i = 0; i < userPurchased; i++) {\n            if (priceIncrease == 0) {\n                priceIncrease = INITIAL_PURCHASE_SPY_ETH_PRICE;\n            }\n\n            priceIncrease = priceIncrease * 2;\n        }\n\n        return INITIAL_PURCHASE_SPY_ETH_PRICE + priceIncrease;\n    }\n\n    /// @notice Spy pricing in terms of moolah.\n    /// @dev Will revert if called before minting starts\n    /// or after all gobblers have been minted via VRGDA.\n    /// @return Current price of a gobbler in terms of goo.\n    function spyPrice() public view returns (uint256) {\n        // We need checked math here to cause underflow\n        // before minting has begun, preventing mints.\n        uint256 timeSinceStart = block.timestamp - gameStart;\n        return\n            spyLVRGDA.getVRGDAPrice(\n                toDaysWadUnsafe(timeSinceStart),\n                spiesMintedFromMoo\n            );\n    }\n\n    /// @notice Knife pricing in terms of moolah.\n    /// @dev Will revert if called before minting starts\n    /// or after all gobblers have been minted via VRGDA.\n    /// @return Current price of a gobbler in terms of goo.\n    function knifePrice() public view returns (uint256) {\n        // We need checked math here to cause underflow\n        // before minting has begun, preventing mints.\n        uint256 timeSinceStart = block.timestamp - (gameStart + 12 hours);\n        return\n            knifeLVRGDA.getVRGDAPrice(\n                toDaysWadUnsafe(timeSinceStart),\n                knivesMintedFromMoo\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          Add/Remove GOO Logic\n    //////////////////////////////////////////////////////////////*/\n\n    // /// @notice Add goo to your emission balance,\n    // /// burning the corresponding ERC20 balance.\n    // /// @param _mooAmount The amount of moo to add.\n    // function addMoo(uint256 _mooAmount) external {\n    //     // Burn goo being added to gobbler.\n    //     moo.burn(msg.sender, _mooAmount);\n\n    //     // Increase msg.sender's virtual goo balance.\n    //     spyNFT.updateUserGooBalance(msg.sender, _mooAmount, GooBalanceUpdateType.INCREASE);\n    // }\n\n    // /// @notice Remove goo from your emission balance, and\n    // /// add the corresponding amount to your ERC20 balance.\n    // /// @param _mooAmount The amount of moo to remove.\n    // function removeMoo(uint256 _mooAmount) external {\n    //     // Decrease msg.sender's virtual goo balance.\n    //     spyNFT.updateUserGooBalance(msg.sender, _mooAmount, GooBalanceUpdateType.DECREASE);\n\n    //     // Mint the corresponding amount of ERC20 goo.\n    //     moo.mint(msg.sender, _mooAmount);\n    // }\n\n    /*//////////////////////////////////////////////////////////////\n                          Game Logic\n    //////////////////////////////////////////////////////////////*/\n\n    function killSpy(uint256 _knifeId, uint256 _spyId) public {\n        // Make sure user owns the knife\n        if (knifeNFT.ownerOf(_knifeId) != msg.sender) revert NotOwner();\n\n        // Cannot kill burn address\n        if (spyNFT.ownerOf(_spyId) == BURN_ADDRESS) revert DumbMove();\n\n        // Literally retarded\n        if (knifeNFT.ownerOf(_knifeId) == spyNFT.ownerOf(_spyId)) {\n            revert DumbMove();\n        }\n\n        knifeNFT.sudoTransferFrom(msg.sender, BURN_ADDRESS, _knifeId);\n\n        address victim = spyNFT.ownerOf(_spyId);\n        spyNFT.sudoTransferFrom(victim, BURN_ADDRESS, _spyId);\n\n        emit SpyKilled(msg.sender, victim, _knifeId, _spyId);\n    }\n\n    // For world chat functionality\n    function shout(string calldata message) external payable {\n        if (msg.value < 0.05e18) revert TooPoor();\n\n        SHOUTS_FUNDS_RECIPIENT.call{value: msg.value}(\"\");\n\n        if (bytes(message).length > 256) {\n            emit Shouted(msg.sender, string(message[:256]));\n        } else {\n            emit Shouted(msg.sender, message);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          Internal\n    //////////////////////////////////////////////////////////////*/\n\n    function _purchaseSpy(address user) internal returns (uint256 spyId) {\n        // Only can purchase 1 spy pre game start\n        if (block.timestamp < gameStart) {\n            // Revert if user has purchased\n            if (hasUserPrepurchased[user]) revert NoWhales();\n\n            // Set purchased\n            hasUserPrepurchased[user] = true;\n        } else if (block.timestamp >= gameStart) {\n            // Add purchase count\n            userPurchasesOnDay[user][\n                uint256(toDaysWadUnsafe(block.timestamp - gameStart) / 1e18)\n            ]++;\n        }\n\n\n        spyId = spyNFT.mint(\n            user,\n            block.timestamp > gameStart ? block.timestamp : gameStart\n        );\n\n        unchecked {\n            emit SpyPurchasedETH(user, spyId);\n        }\n    }\n}\n"
69     },
70     "src/LVRGDA.sol": {
71       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {LogisticVRGDA} from \"VRGDAs/LogisticVRGDA.sol\";\n\n// LogisticVRGDA is an abstract contract, need to wrap it like so\ncontract LVRGDA is LogisticVRGDA {\n    /// @notice Sets pricing parameters for the VRGDA.\n    /// @param _targetPrice The target price for a token if sold on pace, scaled by 1e18.\n    /// @param _priceDecayPercent The percent price decays per unit of time with no sales, scaled by 1e18.\n    /// @param _maxSellable The maximum number of tokens to sell, scaled by 1e18.\n    /// @param _timeScale The steepness of the logistic curve, scaled by 1e18.\n    constructor(int256 _targetPrice, int256 _priceDecayPercent, int256 _maxSellable, int256 _timeScale)\n        LogisticVRGDA(_targetPrice, _priceDecayPercent, _maxSellable, _timeScale)\n    {}\n}\n"
72     },
73     "src/NFT.sol": {
74       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {IERC721, ERC721, ERC721Enumerable} from \"@openzeppelin/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {Ownable} from \"@openzeppelin/access/Ownable.sol\";\nimport {toWadUnsafe, toDaysWadUnsafe} from \"solmate/utils/SignedWadMath.sol\";\nimport {LibGOO} from \"goo-issuance/LibGOO.sol\";\n\n/// @dev An enum for representing whether to\n/// increase or decrease a user's goo balance.\nenum GooBalanceUpdateType {\n    INCREASE,\n    DECREASE\n}\n\n/// @notice Struct holding data relevant to each user's account.\nstruct UserData {\n    // User's goo balance at time of last checkpointing.\n    uint128 lastBalance;\n    // Timestamp of the last goo balance checkpoint.\n    uint64 lastTimestamp;\n}\n\ncontract OwnedEnumerableNFT is ERC721Enumerable, Ownable {\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) Ownable() {}\n\n    function mint(address recipient) public virtual onlyOwner returns (uint256 id) {\n        id = totalSupply();\n        _safeMint(recipient, id);\n    }\n\n    function burn(uint256 id) public onlyOwner {\n        _burn(id);\n    }\n}\n\n// SPY NFT will produce Goo\ncontract SpyNFT is OwnedEnumerableNFT {\n    /*//////////////////////////////////////////////////////////////\n                            Variables\n    //////////////////////////////////////////////////////////////*/\n\n    /// Random emission multiple to massage the curve into place\n    uint256 public constant EMISSION_MULTIPLE = 69;\n\n    /// Keeps track of virtual GOO Balance\n    mapping(address => UserData) public getUserData;\n\n    /*//////////////////////////////////////////////////////////////\n                            Events\n    //////////////////////////////////////////////////////////////*/\n\n    event GooBalanceUpdated(address indexed user, uint256 newGooBalance);\n\n    /*//////////////////////////////////////////////////////////////\n                            Errors\n    //////////////////////////////////////////////////////////////*/\n\n    error TooEarly();\n\n    /*//////////////////////////////////////////////////////////////\n                            Constructor\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() OwnedEnumerableNFT(\"Spy\", \"SPIES\") {}\n\n    /*//////////////////////////////////////////////////////////////\n                      Goo Functionality (Read only)\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Calculate a user's virtual goo balance.\n    /// @param user The user to query balance for.\n    function gooBalance(address user) public view returns (uint256) {\n        // Compute the user's virtual goo balance using LibGOO.\n        // prettier-ignore\n        return LibGOO.computeGOOBalance(\n            EMISSION_MULTIPLE * balanceOf(user),\n            getUserData[user].lastBalance,\n            uint256(toDaysWadUnsafe(block.timestamp - getUserData[user].lastTimestamp))\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      Goo Functionality (Permissioned)\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Update a user's virtual goo balance.\n    /// @param user The user whose virtual goo balance we should update.\n    /// @param gooAmount The amount of goo to update the user's virtual balance by.\n    /// @param updateType Whether to increase or decrease the user's balance by gooAmount.\n    function updateUserGooBalance(address user, uint256 gooAmount, GooBalanceUpdateType updateType) public onlyOwner {\n        // Will revert due to underflow if we're decreasing by more than the user's current balance.\n        // Don't need to do checked addition in the increase case, but we do it anyway for convenience.\n        uint256 updatedBalance =\n            updateType == GooBalanceUpdateType.INCREASE ? gooBalance(user) + gooAmount : gooBalance(user) - gooAmount;\n\n        // Snapshot the user's new goo balance with the current timestamp.\n        getUserData[user].lastBalance = uint128(updatedBalance);\n        getUserData[user].lastTimestamp = uint64(block.timestamp);\n\n        emit GooBalanceUpdated(user, updatedBalance);\n    }\n\n    /// @notice Superuser transferFrom\n    function sudoTransferFrom(address from, address to, uint256 tokenId) public onlyOwner {\n        // if (getUserData[from].lastTimestamp == 0) {\n        //     getUserData[from].lastTimestamp = uint64(block.timestamp);\n        // }\n        // if (getUserData[to].lastTimestamp == 0) {\n        //     getUserData[to].lastTimestamp = uint64(block.timestamp);\n        // }\n\n        unchecked {\n            // We update their last balance before updating their emission multiple to avoid\n            // penalizing them by retroactively applying their new (lower) balanceOf\n            getUserData[from].lastBalance = uint128(gooBalance(from));\n            getUserData[from].lastTimestamp = uint64(block.timestamp);\n\n            // We update their last balance before updating their emission multiple to avoid\n            // overpaying them by retroactively applying their new (higher) balanceOf\n            getUserData[to].lastBalance = uint128(gooBalance(to));\n            getUserData[to].lastTimestamp = uint64(block.timestamp);\n        }\n\n        // State changes happen *after* gooBalance is update\n        _transfer(from, to, tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC721 Functionality\n    //////////////////////////////////////////////////////////////*/\n\n    function mint(address recipient, uint256 timestamp) public onlyOwner returns (uint256 id) {\n        // Prevent bugs\n        if (timestamp < block.timestamp) {\n            revert TooEarly();\n        }\n\n        // If we can't get the gooBalance, then minting hasn't start yet\n        // If we can get the gooBal then we good\n        try this.gooBalance(recipient) returns (uint256 existingGooBal) {\n            getUserData[recipient].lastBalance = uint128(existingGooBal);\n        } catch {}\n        getUserData[recipient].lastTimestamp = uint64(timestamp);\n\n        id = totalSupply();\n        _safeMint(recipient, id);\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) public override (ERC721, IERC721) {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        if (getUserData[from].lastTimestamp == 0) {\n            getUserData[from].lastTimestamp = uint64(block.timestamp);\n        }\n        if (getUserData[to].lastTimestamp == 0) {\n            getUserData[to].lastTimestamp = uint64(block.timestamp);\n        }\n\n        unchecked {\n            // We update their last balance before updating their emission multiple to avoid\n            // penalizing them by retroactively applying their new (lower) balanceOf\n            getUserData[from].lastBalance = uint128(gooBalance(from));\n            getUserData[from].lastTimestamp = uint64(block.timestamp);\n\n            // We update their last balance before updating their emission multiple to avoid\n            // overpaying them by retroactively applying their new (higher) balanceOf\n            getUserData[to].lastBalance = uint128(gooBalance(to));\n            getUserData[to].lastTimestamp = uint64(block.timestamp);\n        }\n\n        // State changes happen *after* gooBalance is update\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        override (ERC721, IERC721)\n    {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        unchecked {\n            // We update their last balance before updating their emission multiple to avoid\n            // penalizing them by retroactively applying their new (lower) balanceOf\n            getUserData[from].lastBalance = uint128(gooBalance(from));\n            getUserData[from].lastTimestamp = uint64(block.timestamp);\n\n            // We update their last balance before updating their emission multiple to avoid\n            // overpaying them by retroactively applying their new (higher) balanceOf\n            getUserData[to].lastBalance = uint128(gooBalance(to));\n            getUserData[to].lastTimestamp = uint64(block.timestamp);\n        }\n\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    function tokenURI(uint256 tokenId) public pure override returns (string memory) {\n        string[4] memory parts;\n\n        parts[0] =\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 350 350\"><style>.base { fill: white; font-family: serif; font-size: 14px; }</style><rect width=\"100%\" height=\"100%\" fill=\"black\" /><text x=\"10\" y=\"20\" class=\"base\">';\n\n        parts[1] = \"SPY #\";\n\n        parts[2] = SVGUtils.toString(tokenId);\n\n        parts[3] = \"</text></svg>\";\n\n        string memory output = string(abi.encodePacked(parts[0], parts[1], parts[2], parts[3]));\n\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"name\": \"Spy #',\n                        SVGUtils.toString(tokenId),\n                        '\", \"description\": \"A Spy in the Knife Game Universe.\", \"image\": \"data:image/svg+xml;base64,',\n                        Base64.encode(bytes(output)),\n                        '\"}'\n                    )\n                )\n            )\n        );\n        output = string(abi.encodePacked(\"data:application/json;base64,\", json));\n\n        return output;\n    }\n}\n\ncontract KnifeNFT is OwnedEnumerableNFT {\n    constructor() OwnedEnumerableNFT(\"Knife\", \"KNIVES\") {}\n\n    function sudoTransferFrom(address from, address to, uint256 tokenId) public onlyOwner {\n        _transfer(from, to, tokenId);\n    }\n\n    function tokenURI(uint256 tokenId) public pure override returns (string memory) {\n        string[4] memory parts;\n\n        parts[0] =\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 350 350\"><style>.base { fill: white; font-family: serif; font-size: 14px; }</style><rect width=\"100%\" height=\"100%\" fill=\"black\" /><text x=\"10\" y=\"20\" class=\"base\">';\n\n        parts[1] = \"Knife #\";\n\n        parts[2] = SVGUtils.toString(tokenId);\n\n        parts[3] = \"</text></svg>\";\n\n        string memory output = string(abi.encodePacked(parts[0], parts[1], parts[2], parts[3]));\n\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"name\": \"Knife #',\n                        SVGUtils.toString(tokenId),\n                        '\", \"description\": \"A Knife the Knife Game Universe.\", \"image\": \"data:image/svg+xml;base64,',\n                        Base64.encode(bytes(output)),\n                        '\"}'\n                    )\n                )\n            )\n        );\n        output = string(abi.encodePacked(\"data:application/json;base64,\", json));\n\n        return output;\n    }\n}\n\n/// [MIT License]\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\nlibrary Base64 {\n    bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /// @notice Encodes some bytes to the base64 representation\n    function encode(bytes memory data) internal pure returns (string memory) {\n        uint256 len = data.length;\n        if (len == 0) return \"\";\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((len + 2) / 3);\n\n        // Add some extra buffer at the end\n        bytes memory result = new bytes(encodedLen + 32);\n\n        bytes memory table = TABLE;\n\n        assembly {\n            let tablePtr := add(table, 1)\n            let resultPtr := add(result, 32)\n\n            for { let i := 0 } lt(i, len) {} {\n                i := add(i, 3)\n                let input := and(mload(add(data, i)), 0xffffff)\n\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n                out := shl(224, out)\n\n                mstore(resultPtr, out)\n\n                resultPtr := add(resultPtr, 4)\n            }\n\n            switch mod(len, 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n\n            mstore(result, encodedLen)\n        }\n\n        return string(result);\n    }\n}\n\nlibrary SVGUtils {\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT license\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
75     }
76   },
77   "settings": {
78     "remappings": [
79       "@openzeppelin/=lib/openzeppelin-contracts/contracts/",
80       "VRGDAs/=lib/VRGDAs/src/",
81       "chainlink/=lib/chainlink/contracts/src/",
82       "ds-test/=lib/VRGDAs/lib/ds-test/src/",
83       "forge-std/=lib/forge-std/src/",
84       "goo-issuance/=lib/goo-issuance/src/",
85       "openzeppelin-contracts/=lib/openzeppelin-contracts/",
86       "solmate/=lib/solmate/src/"
87     ],
88     "optimizer": {
89       "enabled": true,
90       "runs": 200
91     },
92     "metadata": {
93       "bytecodeHash": "ipfs"
94     },
95     "outputSelection": {
96       "*": {
97         "*": [
98           "evm.bytecode",
99           "evm.deployedBytecode",
100           "devdoc",
101           "userdoc",
102           "metadata",
103           "abi"
104         ]
105       }
106     },
107     "evmVersion": "london",
108     "libraries": {}
109   }
110 }}