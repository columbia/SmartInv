1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/modules/ExchangeGovernance.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../libraries/ExchangeConstants.sol\";\nimport \"../libraries/LiquidVoting.sol\";\nimport \"../libraries/SafeCast.sol\";\nimport \"../utils/BalanceAccounting.sol\";\nimport \"./BaseGovernanceModule.sol\";\n\n\ncontract ExchangeGovernance is BaseGovernanceModule, BalanceAccounting {\n    using Vote for Vote.Data;\n    using LiquidVoting for LiquidVoting.Data;\n    using VirtualVote for VirtualVote.Data;\n    using SafeCast for uint256;\n\n    event LeftoverGovernanceShareUpdate(address indexed user, uint256 vote, bool isDefault, uint256 amount);\n    event LeftoverReferralShareUpdate(address indexed user, uint256 vote, bool isDefault, uint256 amount);\n\n    LiquidVoting.Data private _leftoverGovernanceShare;\n\n    constructor(address _mothership) public BaseGovernanceModule(_mothership) {\n        _leftoverGovernanceShare.data.result = ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE.toUint104();\n    }\n\n    function parameters() external view returns(uint256 govShare, uint256 refShare) {\n        govShare = _leftoverGovernanceShare.data.current();\n        refShare = ExchangeConstants._LEFTOVER_TOTAL_SHARE.sub(govShare);\n    }\n\n    function leftoverGovernanceShare() external view returns(uint256) {\n        return _leftoverGovernanceShare.data.current();\n    }\n\n    function leftoverGovernanceShareVotes(address user) external view returns(uint256) {\n        return _leftoverGovernanceShare.votes[user].get(ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE);\n    }\n\n    function virtualLeftoverGovernanceShare() external view returns(uint104, uint104, uint48) {\n        return (_leftoverGovernanceShare.data.oldResult, _leftoverGovernanceShare.data.result, _leftoverGovernanceShare.data.time);\n    }\n\n    //\n\n    function leftoverReferralShare() external view returns(uint256) {\n        return ExchangeConstants._LEFTOVER_TOTAL_SHARE.sub(_leftoverGovernanceShare.data.current());\n    }\n\n    function leftoverReferralShareVotes(address user) external view returns(uint256) {\n        return ExchangeConstants._LEFTOVER_TOTAL_SHARE.sub(_leftoverGovernanceShare.votes[user].get(ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE));\n    }\n\n    function virtualLeftoverReferralShare() external view returns(uint104, uint104, uint48) {\n        return (\n            ExchangeConstants._LEFTOVER_TOTAL_SHARE.sub(_leftoverGovernanceShare.data.oldResult).toUint104(),\n            ExchangeConstants._LEFTOVER_TOTAL_SHARE.sub(_leftoverGovernanceShare.data.result).toUint104(),\n            _leftoverGovernanceShare.data.time\n        );\n    }\n\n    ///\n\n    function leftoverShareVote(uint256 govShare) external {\n        uint256 refShare = ExchangeConstants._LEFTOVER_TOTAL_SHARE.sub(govShare, \"Governance share is too high\");\n\n        uint256 balance = balanceOf(msg.sender);\n        uint256 supply = totalSupply();\n\n        _leftoverGovernanceShare.updateVote(\n            msg.sender,\n            _leftoverGovernanceShare.votes[msg.sender],\n            Vote.init(govShare),\n            balance,\n            supply,\n            ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE,\n            _emitLeftoverGovernanceShareVoteUpdate\n        );\n\n        _emitLeftoverReferralShareVoteUpdate(msg.sender, refShare, false, balance);\n    }\n\n    function discardLeftoverShareVote() external {\n        uint256 balance = balanceOf(msg.sender);\n        uint256 supply = totalSupply();\n\n        _leftoverGovernanceShare.updateVote(\n           msg.sender,\n           _leftoverGovernanceShare.votes[msg.sender],\n           Vote.init(),\n           balance,\n           supply,\n           ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE,\n           _emitLeftoverGovernanceShareVoteUpdate\n        );\n\n        _emitLeftoverReferralShareVoteUpdate(msg.sender, ExchangeConstants._DEFAULT_LEFTOVER_REF_SHARE, true, balance);\n    }\n\n    function _notifyStakeChanged(address account, uint256 newBalance) internal override {\n        uint256 balance = _set(account, newBalance);\n        if (newBalance == balance) {\n            return;\n        }\n\n        Vote.Data memory govShareVote = _leftoverGovernanceShare.votes[account];\n        uint256 refShare = ExchangeConstants._LEFTOVER_TOTAL_SHARE.sub(govShareVote.get(ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE));\n        uint256 supply = totalSupply();\n\n        _leftoverGovernanceShare.updateBalance(\n            account,\n            govShareVote,\n            balance,\n            newBalance,\n            supply,\n            ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE,\n            _emitLeftoverGovernanceShareVoteUpdate\n        );\n\n        _emitLeftoverReferralShareVoteUpdate(\n            account,\n            refShare,\n            govShareVote.isDefault(),\n            newBalance\n        );\n    }\n\n    function _emitLeftoverGovernanceShareVoteUpdate(address user, uint256 newDefaultShare, bool isDefault, uint256 balance) private {\n        emit LeftoverGovernanceShareUpdate(user, newDefaultShare, isDefault, balance);\n    }\n\n    function _emitLeftoverReferralShareVoteUpdate(address user, uint256 newDefaultShare, bool isDefault, uint256 balance) private {\n        emit LeftoverReferralShareUpdate(user, newDefaultShare, isDefault, balance);\n    }\n}\n"
6     },
7     "contracts/libraries/ExchangeConstants.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n\nlibrary ExchangeConstants {\n    uint256 internal constant _LEFTOVER_TOTAL_SHARE = 1e18;          // 100%\n    uint256 internal constant _DEFAULT_LEFTOVER_GOV_SHARE = 0.8e18;  //  80%\n    uint256 internal constant _DEFAULT_LEFTOVER_REF_SHARE = 0.2e18;  //  20%\n}\n"
9     },
10     "contracts/libraries/LiquidVoting.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./SafeCast.sol\";\nimport \"./VirtualVote.sol\";\nimport \"./Vote.sol\";\n\n\nlibrary LiquidVoting {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using Vote for Vote.Data;\n    using VirtualVote for VirtualVote.Data;\n\n    struct Data {\n        VirtualVote.Data data;\n        uint256 _weightedSum;\n        uint256 _defaultVotes;\n        mapping(address => Vote.Data) votes;\n    }\n\n    function updateVote(\n        LiquidVoting.Data storage self,\n        address user,\n        Vote.Data memory oldVote,\n        Vote.Data memory newVote,\n        uint256 balance,\n        uint256 totalSupply,\n        uint256 defaultVote,\n        function(address, uint256, bool, uint256) emitEvent\n    ) internal {\n        return _update(self, user, oldVote, newVote, balance, balance, totalSupply, defaultVote, emitEvent);\n    }\n\n    function updateBalance(\n        LiquidVoting.Data storage self,\n        address user,\n        Vote.Data memory oldVote,\n        uint256 oldBalance,\n        uint256 newBalance,\n        uint256 newTotalSupply,\n        uint256 defaultVote,\n        function(address, uint256, bool, uint256) emitEvent\n    ) internal {\n        return _update(self, user, oldVote, newBalance == 0 ? Vote.init() : oldVote, oldBalance, newBalance, newTotalSupply, defaultVote, emitEvent);\n    }\n\n    function _update(\n        LiquidVoting.Data storage self,\n        address user,\n        Vote.Data memory oldVote,\n        Vote.Data memory newVote,\n        uint256 oldBalance,\n        uint256 newBalance,\n        uint256 newTotalSupply,\n        uint256 defaultVote,\n        function(address, uint256, bool, uint256) emitEvent\n    ) private {\n        uint256 oldWeightedSum = self._weightedSum;\n        uint256 newWeightedSum = oldWeightedSum;\n        uint256 oldDefaultVotes = self._defaultVotes;\n        uint256 newDefaultVotes = oldDefaultVotes;\n\n        if (oldVote.isDefault()) {\n            newDefaultVotes = newDefaultVotes.sub(oldBalance);\n        } else {\n            newWeightedSum = newWeightedSum.sub(oldBalance.mul(oldVote.get(defaultVote)));\n        }\n\n        if (newVote.isDefault()) {\n            newDefaultVotes = newDefaultVotes.add(newBalance);\n        } else {\n            newWeightedSum = newWeightedSum.add(newBalance.mul(newVote.get(defaultVote)));\n        }\n\n        if (newWeightedSum != oldWeightedSum) {\n            self._weightedSum = newWeightedSum;\n        }\n\n        if (newDefaultVotes != oldDefaultVotes) {\n            self._defaultVotes = newDefaultVotes;\n        }\n\n        {\n            uint256 newResult = newTotalSupply == 0 ? defaultVote : newWeightedSum.add(newDefaultVotes.mul(defaultVote)).div(newTotalSupply);\n            VirtualVote.Data memory data = self.data;\n\n            if (newResult != data.result) {\n                VirtualVote.Data storage sdata = self.data;\n                (sdata.oldResult, sdata.result, sdata.time) = (\n                    data.current().toUint104(),\n                    newResult.toUint104(),\n                    block.timestamp.toUint48()\n                );\n            }\n        }\n\n        if (!newVote.eq(oldVote)) {\n            self.votes[user] = newVote;\n        }\n\n        emitEvent(user, newVote.get(defaultVote), newVote.isDefault(), newBalance);\n    }\n}\n"
12     },
13     "contracts/libraries/SafeCast.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nlibrary SafeCast {\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value < 2**216, \"value does not fit in 216 bits\");\n        return uint216(value);\n    }\n\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value < 2**104, \"value does not fit in 104 bits\");\n        return uint104(value);\n    }\n\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value < 2**48, \"value does not fit in 48 bits\");\n        return uint48(value);\n    }\n\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value < 2**40, \"value does not fit in 40 bits\");\n        return uint40(value);\n    }\n}\n"
15     },
16     "contracts/utils/BalanceAccounting.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\ncontract BalanceAccounting {\n    using SafeMath for uint256;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        _balances[account] = _balances[account].sub(amount, \"Burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n    }\n\n    function _set(address account, uint256 amount) internal virtual returns(uint256 oldAmount) {\n        oldAmount = _balances[account];\n        if (oldAmount != amount) {\n            _balances[account] = amount;\n            _totalSupply = _totalSupply.add(amount).sub(oldAmount);\n        }\n    }\n}\n"
18     },
19     "contracts/modules/BaseGovernanceModule.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../interfaces/IGovernanceModule.sol\";\n\n\nabstract contract BaseGovernanceModule is IGovernanceModule {\n    address public immutable mothership;\n\n    modifier onlyMothership {\n        require(msg.sender == mothership, \"Access restricted to mothership\");\n\n        _;\n    }\n\n    constructor(address _mothership) public {\n        mothership = _mothership;\n    }\n\n    function notifyStakesChanged(address[] calldata accounts, uint256[] calldata newBalances) external override onlyMothership {\n        require(accounts.length == newBalances.length, \"Arrays length should be equal\");\n\n        for(uint256 i = 0; i < accounts.length; ++i) {\n            _notifyStakeChanged(accounts[i], newBalances[i]);\n        }\n    }\n\n    function notifyStakeChanged(address account, uint256 newBalance) external override onlyMothership {\n        _notifyStakeChanged(account, newBalance);\n    }\n\n    function _notifyStakeChanged(address account, uint256 newBalance) internal virtual;\n}\n"
21     },
22     "@openzeppelin/contracts/math/SafeMath.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
24     },
25     "contracts/libraries/VirtualVote.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\nlibrary VirtualVote {\n    using SafeMath for uint256;\n\n    uint256 private constant _VOTE_DECAY_PERIOD = 1 days;\n\n    struct Data {\n        uint104 oldResult;\n        uint104 result;\n        uint48 time;\n    }\n\n    function current(VirtualVote.Data memory self) internal view returns(uint256) {\n        uint256 timePassed = Math.min(_VOTE_DECAY_PERIOD, block.timestamp.sub(self.time));\n        uint256 timeRemain = _VOTE_DECAY_PERIOD.sub(timePassed);\n        return uint256(self.oldResult).mul(timeRemain).add(\n            uint256(self.result).mul(timePassed)\n        ).div(_VOTE_DECAY_PERIOD);\n    }\n}\n"
27     },
28     "contracts/libraries/Vote.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\n\nlibrary Vote {\n    struct Data {\n        uint256 value;\n    }\n\n    function eq(Vote.Data memory self, Vote.Data memory vote) internal pure returns(bool) {\n        return self.value == vote.value;\n    }\n\n    function init() internal pure returns(Vote.Data memory data) {\n        return Vote.Data({\n            value: 0\n        });\n    }\n\n    function init(uint256 vote) internal pure returns(Vote.Data memory data) {\n        return Vote.Data({\n            value: vote + 1\n        });\n    }\n\n    function isDefault(Data memory self) internal pure returns(bool) {\n        return self.value == 0;\n    }\n\n    function get(Data memory self, uint256 defaultVote) internal pure returns(uint256) {\n        if (self.value > 0) {\n            return self.value - 1;\n        }\n        return defaultVote;\n    }\n\n    function get(Data memory self, function() external view returns(uint256) defaultVoteFn) internal view returns(uint256) {\n        if (self.value > 0) {\n            return self.value - 1;\n        }\n        return defaultVoteFn();\n    }\n}\n"
30     },
31     "@openzeppelin/contracts/math/Math.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
33     },
34     "contracts/interfaces/IGovernanceModule.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n\ninterface IGovernanceModule {\n    function notifyStakeChanged(address account, uint256 newBalance) external;\n    function notifyStakesChanged(address[] calldata accounts, uint256[] calldata newBalances) external;\n}\n"
36     }
37   },
38   "settings": {
39     "optimizer": {
40       "enabled": true,
41       "runs": 1000000
42     },
43     "outputSelection": {
44       "*": {
45         "*": [
46           "evm.bytecode",
47           "evm.deployedBytecode",
48           "abi"
49         ]
50       }
51     },
52     "libraries": {}
53   }
54 }}