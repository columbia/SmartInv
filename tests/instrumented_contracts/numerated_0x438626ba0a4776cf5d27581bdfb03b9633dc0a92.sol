1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/NFTAuction.sol": {
5       "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.4;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title An Auction Contract for bidding and selling single and batched NFTs\n/// @author Avo Labs GmbH\n/// @notice This contract can be used for auctioning any NFTs, and accepts any ERC20 token as payment\ncontract NFTAuction {\n    mapping(address => mapping(uint256 => Auction)) public nftContractAuctions;\n    mapping(address => uint256) failedTransferCredits;\n    //Each Auction is unique to each NFT (contract + id pairing).\n    struct Auction {\n        //map token ID to\n        uint32 bidIncreasePercentage;\n        uint32 auctionBidPeriod; //Increments the length of time the auction is open in which a new bid can be made after each bid.\n        uint64 auctionEnd;\n        uint128 minPrice;\n        uint128 buyNowPrice;\n        uint128 nftHighestBid;\n        address nftHighestBidder;\n        address nftSeller;\n        address whitelistedBuyer; //The seller can specify a whitelisted address for a sale (this is effectively a direct sale).\n        address nftRecipient; //The bidder can specify a recipient for the NFT if their bid is successful.\n        address ERC20Token; // The seller can specify an ERC20 token that can be used to bid or purchase the NFT.\n        address[] feeRecipients;\n        uint32[] feePercentages;\n    }\n    /*\n     * Default values that are used if not specified by the NFT seller.\n     */\n    uint32 public defaultBidIncreasePercentage;\n    uint32 public minimumSettableIncreasePercentage;\n    uint32 public maximumMinPricePercentage;\n    uint32 public defaultAuctionBidPeriod;\n\n    /*╔═════════════════════════════╗\n      ║           EVENTS            ║\n      ╚═════════════════════════════╝*/\n\n    event NftAuctionCreated(\n        address nftContractAddress,\n        uint256 tokenId,\n        address nftSeller,\n        address erc20Token,\n        uint128 minPrice,\n        uint128 buyNowPrice,\n        uint32 auctionBidPeriod,\n        uint32 bidIncreasePercentage,\n        address[] feeRecipients,\n        uint32[] feePercentages\n    );\n\n    event SaleCreated(\n        address nftContractAddress,\n        uint256 tokenId,\n        address nftSeller,\n        address erc20Token,\n        uint128 buyNowPrice,\n        address whitelistedBuyer,\n        address[] feeRecipients,\n        uint32[] feePercentages\n    );\n\n    event BidMade(\n        address nftContractAddress,\n        uint256 tokenId,\n        address bidder,\n        uint256 ethAmount,\n        address erc20Token,\n        uint256 tokenAmount\n    );\n\n    event AuctionPeriodUpdated(\n        address nftContractAddress,\n        uint256 tokenId,\n        uint64 auctionEndPeriod\n    );\n\n    event NFTTransferredAndSellerPaid(\n        address nftContractAddress,\n        uint256 tokenId,\n        address nftSeller,\n        uint128 nftHighestBid,\n        address nftHighestBidder,\n        address nftRecipient\n    );\n\n    event AuctionSettled(\n        address nftContractAddress,\n        uint256 tokenId,\n        address auctionSettler\n    );\n\n    event AuctionWithdrawn(\n        address nftContractAddress,\n        uint256 tokenId,\n        address nftOwner\n    );\n\n    event BidWithdrawn(\n        address nftContractAddress,\n        uint256 tokenId,\n        address highestBidder\n    );\n\n    event WhitelistedBuyerUpdated(\n        address nftContractAddress,\n        uint256 tokenId,\n        address newWhitelistedBuyer\n    );\n\n    event MinimumPriceUpdated(\n        address nftContractAddress,\n        uint256 tokenId,\n        uint256 newMinPrice\n    );\n\n    event BuyNowPriceUpdated(\n        address nftContractAddress,\n        uint256 tokenId,\n        uint128 newBuyNowPrice\n    );\n    event HighestBidTaken(address nftContractAddress, uint256 tokenId);\n    /**********************************/\n    /*╔═════════════════════════════╗\n      ║             END             ║\n      ║            EVENTS           ║\n      ╚═════════════════════════════╝*/\n    /**********************************/\n    /*╔═════════════════════════════╗\n      ║          MODIFIERS          ║\n      ╚═════════════════════════════╝*/\n\n    modifier isAuctionNotStartedByOwner(\n        address _nftContractAddress,\n        uint256 _tokenId\n    ) {\n        require(\n            nftContractAuctions[_nftContractAddress][_tokenId].nftSeller !=\n                msg.sender,\n            \"Auction already started by owner\"\n        );\n\n        if (\n            nftContractAuctions[_nftContractAddress][_tokenId].nftSeller !=\n            address(0)\n        ) {\n            require(\n                msg.sender == IERC721(_nftContractAddress).ownerOf(_tokenId),\n                \"Sender doesn't own NFT\"\n            );\n\n            _resetAuction(_nftContractAddress, _tokenId);\n        }\n        _;\n    }\n\n    modifier auctionOngoing(address _nftContractAddress, uint256 _tokenId) {\n        require(\n            _isAuctionOngoing(_nftContractAddress, _tokenId),\n            \"Auction has ended\"\n        );\n        _;\n    }\n\n    modifier priceGreaterThanZero(uint256 _price) {\n        require(_price > 0, \"Price cannot be 0\");\n        _;\n    }\n    /*\n     * The minimum price must be 80% of the buyNowPrice(if set).\n     */\n    modifier minPriceDoesNotExceedLimit(\n        uint128 _buyNowPrice,\n        uint128 _minPrice\n    ) {\n        require(\n            _buyNowPrice == 0 ||\n                _getPortionOfBid(_buyNowPrice, maximumMinPricePercentage) >=\n                _minPrice,\n            \"MinPrice > 80% of buyNowPrice\"\n        );\n        _;\n    }\n\n    modifier notNftSeller(address _nftContractAddress, uint256 _tokenId) {\n        require(\n            msg.sender !=\n                nftContractAuctions[_nftContractAddress][_tokenId].nftSeller,\n            \"Owner cannot bid on own NFT\"\n        );\n        _;\n    }\n    modifier onlyNftSeller(address _nftContractAddress, uint256 _tokenId) {\n        require(\n            msg.sender ==\n                nftContractAuctions[_nftContractAddress][_tokenId].nftSeller,\n            \"Only nft seller\"\n        );\n        _;\n    }\n    /*\n     * The bid amount was either equal the buyNowPrice or it must be higher than the previous\n     * bid by the specified bid increase percentage.\n     */\n    modifier bidAmountMeetsBidRequirements(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        uint128 _tokenAmount\n    ) {\n        require(\n            _doesBidMeetBidRequirements(\n                _nftContractAddress,\n                _tokenId,\n                _tokenAmount\n            ),\n            \"Not enough funds to bid on NFT\"\n        );\n        _;\n    }\n    // check if the highest bidder can purchase this NFT.\n    modifier onlyApplicableBuyer(\n        address _nftContractAddress,\n        uint256 _tokenId\n    ) {\n        require(\n            !_isWhitelistedSale(_nftContractAddress, _tokenId) ||\n                nftContractAuctions[_nftContractAddress][_tokenId]\n                    .whitelistedBuyer ==\n                msg.sender,\n            \"Only the whitelisted buyer\"\n        );\n        _;\n    }\n\n    modifier minimumBidNotMade(address _nftContractAddress, uint256 _tokenId) {\n        require(\n            !_isMinimumBidMade(_nftContractAddress, _tokenId),\n            \"The auction has a valid bid made\"\n        );\n        _;\n    }\n\n    /*\n     * Payment is accepted if the payment is made in the ERC20 token or ETH specified by the seller.\n     * Early bids on NFTs not yet up for auction must be made in ETH.\n     */\n    modifier paymentAccepted(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        address _erc20Token,\n        uint128 _tokenAmount\n    ) {\n        require(\n            _isPaymentAccepted(\n                _nftContractAddress,\n                _tokenId,\n                _erc20Token,\n                _tokenAmount\n            ),\n            \"Bid to be in specified ERC20/Eth\"\n        );\n        _;\n    }\n\n    modifier isAuctionOver(address _nftContractAddress, uint256 _tokenId) {\n        require(\n            !_isAuctionOngoing(_nftContractAddress, _tokenId),\n            \"Auction is not yet over\"\n        );\n        _;\n    }\n\n    modifier notZeroAddress(address _address) {\n        require(_address != address(0), \"Cannot specify 0 address\");\n        _;\n    }\n\n    modifier increasePercentageAboveMinimum(uint32 _bidIncreasePercentage) {\n        require(\n            _bidIncreasePercentage >= minimumSettableIncreasePercentage,\n            \"Bid increase percentage too low\"\n        );\n        _;\n    }\n\n    modifier isFeePercentagesLessThanMaximum(uint32[] memory _feePercentages) {\n        uint32 totalPercent;\n        for (uint256 i = 0; i < _feePercentages.length; i++) {\n            totalPercent = totalPercent + _feePercentages[i];\n        }\n        require(totalPercent <= 10000, \"Fee percentages exceed maximum\");\n        _;\n    }\n\n    modifier correctFeeRecipientsAndPercentages(\n        uint256 _recipientsLength,\n        uint256 _percentagesLength\n    ) {\n        require(\n            _recipientsLength == _percentagesLength,\n            \"Recipients != percentages\"\n        );\n        _;\n    }\n\n    modifier isNotASale(address _nftContractAddress, uint256 _tokenId) {\n        require(\n            !_isASale(_nftContractAddress, _tokenId),\n            \"Not applicable for a sale\"\n        );\n        _;\n    }\n\n    /**********************************/\n    /*╔═════════════════════════════╗\n      ║             END             ║\n      ║          MODIFIERS          ║\n      ╚═════════════════════════════╝*/\n    /**********************************/\n    // constructor\n    constructor() {\n        defaultBidIncreasePercentage = 100;\n        defaultAuctionBidPeriod = 86400; //1 day\n        minimumSettableIncreasePercentage = 100;\n        maximumMinPricePercentage = 8000;\n    }\n\n    /*╔══════════════════════════════╗\n      ║    AUCTION CHECK FUNCTIONS   ║\n      ╚══════════════════════════════╝*/\n    function _isAuctionOngoing(address _nftContractAddress, uint256 _tokenId)\n        internal\n        view\n        returns (bool)\n    {\n        uint64 auctionEndTimestamp = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].auctionEnd;\n        //if the auctionEnd is set to 0, the auction is technically on-going, however\n        //the minimum bid price (minPrice) has not yet been met.\n        return (auctionEndTimestamp == 0 ||\n            block.timestamp < auctionEndTimestamp);\n    }\n\n    /*\n     * Check if a bid has been made. This is applicable in the early bid scenario\n     * to ensure that if an auction is created after an early bid, the auction\n     * begins appropriately or is settled if the buy now price is met.\n     */\n    function _isABidMade(address _nftContractAddress, uint256 _tokenId)\n        internal\n        view\n        returns (bool)\n    {\n        return (nftContractAuctions[_nftContractAddress][_tokenId]\n            .nftHighestBid > 0);\n    }\n\n    /*\n     *if the minPrice is set by the seller, check that the highest bid meets or exceeds that price.\n     */\n    function _isMinimumBidMade(address _nftContractAddress, uint256 _tokenId)\n        internal\n        view\n        returns (bool)\n    {\n        uint128 minPrice = nftContractAuctions[_nftContractAddress][_tokenId]\n            .minPrice;\n        return\n            minPrice > 0 &&\n            (nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBid >=\n                minPrice);\n    }\n\n    /*\n     * If the buy now price is set by the seller, check that the highest bid meets that price.\n     */\n    function _isBuyNowPriceMet(address _nftContractAddress, uint256 _tokenId)\n        internal\n        view\n        returns (bool)\n    {\n        uint128 buyNowPrice = nftContractAuctions[_nftContractAddress][_tokenId]\n            .buyNowPrice;\n        return\n            buyNowPrice > 0 &&\n            nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBid >=\n            buyNowPrice;\n    }\n\n    /*\n     * Check that a bid is applicable for the purchase of the NFT.\n     * In the case of a sale: the bid needs to meet the buyNowPrice.\n     * In the case of an auction: the bid needs to be a % higher than the previous bid.\n     */\n    function _doesBidMeetBidRequirements(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        uint128 _tokenAmount\n    ) internal view returns (bool) {\n        uint128 buyNowPrice = nftContractAuctions[_nftContractAddress][_tokenId]\n            .buyNowPrice;\n        //if buyNowPrice is met, ignore increase percentage\n        if (\n            buyNowPrice > 0 &&\n            (msg.value >= buyNowPrice || _tokenAmount >= buyNowPrice)\n        ) {\n            return true;\n        }\n        //if the NFT is up for auction, the bid needs to be a % higher than the previous bid\n        uint256 bidIncreaseAmount = (nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].nftHighestBid *\n            (10000 +\n                _getBidIncreasePercentage(_nftContractAddress, _tokenId))) /\n            10000;\n        return (msg.value >= bidIncreaseAmount ||\n            _tokenAmount >= bidIncreaseAmount);\n    }\n\n    /*\n     * An NFT is up for sale if the buyNowPrice is set, but the minPrice is not set.\n     * Therefore the only way to conclude the NFT sale is to meet the buyNowPrice.\n     */\n    function _isASale(address _nftContractAddress, uint256 _tokenId)\n        internal\n        view\n        returns (bool)\n    {\n        return (nftContractAuctions[_nftContractAddress][_tokenId].buyNowPrice >\n            0 &&\n            nftContractAuctions[_nftContractAddress][_tokenId].minPrice == 0);\n    }\n\n    function _isWhitelistedSale(address _nftContractAddress, uint256 _tokenId)\n        internal\n        view\n        returns (bool)\n    {\n        return (nftContractAuctions[_nftContractAddress][_tokenId]\n            .whitelistedBuyer != address(0));\n    }\n\n    /*\n     * The highest bidder is allowed to purchase the NFT if\n     * no whitelisted buyer is set by the NFT seller.\n     * Otherwise, the highest bidder must equal the whitelisted buyer.\n     */\n    function _isHighestBidderAllowedToPurchaseNFT(\n        address _nftContractAddress,\n        uint256 _tokenId\n    ) internal view returns (bool) {\n        return\n            (!_isWhitelistedSale(_nftContractAddress, _tokenId)) ||\n            _isHighestBidderWhitelisted(_nftContractAddress, _tokenId);\n    }\n\n    function _isHighestBidderWhitelisted(\n        address _nftContractAddress,\n        uint256 _tokenId\n    ) internal view returns (bool) {\n        return (nftContractAuctions[_nftContractAddress][_tokenId]\n            .nftHighestBidder ==\n            nftContractAuctions[_nftContractAddress][_tokenId]\n                .whitelistedBuyer);\n    }\n\n    /**\n     * Payment is accepted in the following scenarios:\n     * (1) Auction already created - can accept ETH or Specified Token\n     *  --------> Cannot bid with ETH & an ERC20 Token together in any circumstance<------\n     * (2) Auction not created - only ETH accepted (cannot early bid with an ERC20 Token\n     * (3) Cannot make a zero bid (no ETH or Token amount)\n     */\n    function _isPaymentAccepted(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        address _bidERC20Token,\n        uint128 _tokenAmount\n    ) internal view returns (bool) {\n        address auctionERC20Token = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].ERC20Token;\n        if (_isERC20Auction(auctionERC20Token)) {\n            return\n                msg.value == 0 &&\n                auctionERC20Token == _bidERC20Token &&\n                _tokenAmount > 0;\n        } else {\n            return\n                msg.value != 0 &&\n                _bidERC20Token == address(0) &&\n                _tokenAmount == 0;\n        }\n    }\n\n    function _isERC20Auction(address _auctionERC20Token)\n        internal\n        pure\n        returns (bool)\n    {\n        return _auctionERC20Token != address(0);\n    }\n\n    /*\n     * Returns the percentage of the total bid (used to calculate fee payments)\n     */\n    function _getPortionOfBid(uint256 _totalBid, uint256 _percentage)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_totalBid * (_percentage)) / 10000;\n    }\n\n    /**********************************/\n    /*╔══════════════════════════════╗\n      ║             END              ║\n      ║    AUCTION CHECK FUNCTIONS   ║\n      ╚══════════════════════════════╝*/\n    /**********************************/\n    /*╔══════════════════════════════╗\n      ║    DEFAULT GETTER FUNCTIONS  ║\n      ╚══════════════════════════════╝*/\n    /*****************************************************************\n     * These functions check if the applicable auction parameter has *\n     * been set by the NFT seller. If not, return the default value. *\n     *****************************************************************/\n\n    function _getBidIncreasePercentage(\n        address _nftContractAddress,\n        uint256 _tokenId\n    ) internal view returns (uint32) {\n        uint32 bidIncreasePercentage = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].bidIncreasePercentage;\n\n        if (bidIncreasePercentage == 0) {\n            return defaultBidIncreasePercentage;\n        } else {\n            return bidIncreasePercentage;\n        }\n    }\n\n    function _getAuctionBidPeriod(address _nftContractAddress, uint256 _tokenId)\n        internal\n        view\n        returns (uint32)\n    {\n        uint32 auctionBidPeriod = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].auctionBidPeriod;\n\n        if (auctionBidPeriod == 0) {\n            return defaultAuctionBidPeriod;\n        } else {\n            return auctionBidPeriod;\n        }\n    }\n\n    /*\n     * The default value for the NFT recipient is the highest bidder\n     */\n    function _getNftRecipient(address _nftContractAddress, uint256 _tokenId)\n        internal\n        view\n        returns (address)\n    {\n        address nftRecipient = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].nftRecipient;\n\n        if (nftRecipient == address(0)) {\n            return\n                nftContractAuctions[_nftContractAddress][_tokenId]\n                    .nftHighestBidder;\n        } else {\n            return nftRecipient;\n        }\n    }\n\n    /**********************************/\n    /*╔══════════════════════════════╗\n      ║             END              ║\n      ║    DEFAULT GETTER FUNCTIONS  ║\n      ╚══════════════════════════════╝*/\n    /**********************************/\n\n    /*╔══════════════════════════════╗\n      ║  TRANSFER NFTS TO CONTRACT   ║\n      ╚══════════════════════════════╝*/\n    function _transferNftToAuctionContract(\n        address _nftContractAddress,\n        uint256 _tokenId\n    ) internal {\n        address _nftSeller = nftContractAuctions[_nftContractAddress][_tokenId]\n            .nftSeller;\n        if (IERC721(_nftContractAddress).ownerOf(_tokenId) == _nftSeller) {\n            IERC721(_nftContractAddress).transferFrom(\n                _nftSeller,\n                address(this),\n                _tokenId\n            );\n            require(\n                IERC721(_nftContractAddress).ownerOf(_tokenId) == address(this),\n                \"nft transfer failed\"\n            );\n        } else {\n            require(\n                IERC721(_nftContractAddress).ownerOf(_tokenId) == address(this),\n                \"Seller doesn't own NFT\"\n            );\n        }\n    }\n\n    /**********************************/\n    /*╔══════════════════════════════╗\n      ║             END              ║\n      ║  TRANSFER NFTS TO CONTRACT   ║\n      ╚══════════════════════════════╝*/\n    /**********************************/\n\n    /*╔══════════════════════════════╗\n      ║       AUCTION CREATION       ║\n      ╚══════════════════════════════╝*/\n\n    /**\n     * Setup parameters applicable to all auctions and whitelised sales:\n     * -> ERC20 Token for payment (if specified by the seller) : _erc20Token\n     * -> minimum price : _minPrice\n     * -> buy now price : _buyNowPrice\n     * -> the nft seller: msg.sender\n     * -> The fee recipients & their respective percentages for a sucessful auction/sale\n     */\n    function _setupAuction(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        address _erc20Token,\n        uint128 _minPrice,\n        uint128 _buyNowPrice,\n        address[] memory _feeRecipients,\n        uint32[] memory _feePercentages\n    )\n        internal\n        minPriceDoesNotExceedLimit(_buyNowPrice, _minPrice)\n        correctFeeRecipientsAndPercentages(\n            _feeRecipients.length,\n            _feePercentages.length\n        )\n        isFeePercentagesLessThanMaximum(_feePercentages)\n    {\n        if (_erc20Token != address(0)) {\n            nftContractAuctions[_nftContractAddress][_tokenId]\n                .ERC20Token = _erc20Token;\n        }\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .feeRecipients = _feeRecipients;\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .feePercentages = _feePercentages;\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .buyNowPrice = _buyNowPrice;\n        nftContractAuctions[_nftContractAddress][_tokenId].minPrice = _minPrice;\n        nftContractAuctions[_nftContractAddress][_tokenId].nftSeller = msg\n            .sender;\n    }\n\n    function _createNewNftAuction(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        address _erc20Token,\n        uint128 _minPrice,\n        uint128 _buyNowPrice,\n        address[] memory _feeRecipients,\n        uint32[] memory _feePercentages\n    ) internal {\n        // Sending the NFT to this contract\n        _setupAuction(\n            _nftContractAddress,\n            _tokenId,\n            _erc20Token,\n            _minPrice,\n            _buyNowPrice,\n            _feeRecipients,\n            _feePercentages\n        );\n        emit NftAuctionCreated(\n            _nftContractAddress,\n            _tokenId,\n            msg.sender,\n            _erc20Token,\n            _minPrice,\n            _buyNowPrice,\n            _getAuctionBidPeriod(_nftContractAddress, _tokenId),\n            _getBidIncreasePercentage(_nftContractAddress, _tokenId),\n            _feeRecipients,\n            _feePercentages\n        );\n        _updateOngoingAuction(_nftContractAddress, _tokenId);\n    }\n\n    /**\n     * Create an auction that uses the default bid increase percentage\n     * & the default auction bid period.\n     */\n    function createDefaultNftAuction(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        address _erc20Token,\n        uint128 _minPrice,\n        uint128 _buyNowPrice,\n        address[] memory _feeRecipients,\n        uint32[] memory _feePercentages\n    )\n        external\n        isAuctionNotStartedByOwner(_nftContractAddress, _tokenId)\n        priceGreaterThanZero(_minPrice)\n    {\n        _createNewNftAuction(\n            _nftContractAddress,\n            _tokenId,\n            _erc20Token,\n            _minPrice,\n            _buyNowPrice,\n            _feeRecipients,\n            _feePercentages\n        );\n    }\n\n    function createNewNftAuction(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        address _erc20Token,\n        uint128 _minPrice,\n        uint128 _buyNowPrice,\n        uint32 _auctionBidPeriod, //this is the time that the auction lasts until another bid occurs\n        uint32 _bidIncreasePercentage,\n        address[] memory _feeRecipients,\n        uint32[] memory _feePercentages\n    )\n        external\n        isAuctionNotStartedByOwner(_nftContractAddress, _tokenId)\n        priceGreaterThanZero(_minPrice)\n        increasePercentageAboveMinimum(_bidIncreasePercentage)\n    {\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .auctionBidPeriod = _auctionBidPeriod;\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .bidIncreasePercentage = _bidIncreasePercentage;\n        _createNewNftAuction(\n            _nftContractAddress,\n            _tokenId,\n            _erc20Token,\n            _minPrice,\n            _buyNowPrice,\n            _feeRecipients,\n            _feePercentages\n        );\n    }\n\n    /**********************************/\n    /*╔══════════════════════════════╗\n      ║             END              ║\n      ║       AUCTION CREATION       ║\n      ╚══════════════════════════════╝*/\n    /**********************************/\n\n    /*╔══════════════════════════════╗\n      ║            SALES             ║\n      ╚══════════════════════════════╝*/\n\n    /********************************************************************\n     * Allows for a standard sale mechanism where the NFT seller can    *\n     * can select an address to be whitelisted. This address is then    *\n     * allowed to make a bid on the NFT. No other address can bid on    *\n     * the NFT.                                                         *\n     ********************************************************************/\n    function _setupSale(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        address _erc20Token,\n        uint128 _buyNowPrice,\n        address _whitelistedBuyer,\n        address[] memory _feeRecipients,\n        uint32[] memory _feePercentages\n    )\n        internal\n        correctFeeRecipientsAndPercentages(\n            _feeRecipients.length,\n            _feePercentages.length\n        )\n        isFeePercentagesLessThanMaximum(_feePercentages)\n    {\n        if (_erc20Token != address(0)) {\n            nftContractAuctions[_nftContractAddress][_tokenId]\n                .ERC20Token = _erc20Token;\n        }\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .feeRecipients = _feeRecipients;\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .feePercentages = _feePercentages;\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .buyNowPrice = _buyNowPrice;\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .whitelistedBuyer = _whitelistedBuyer;\n        nftContractAuctions[_nftContractAddress][_tokenId].nftSeller = msg\n            .sender;\n    }\n\n    function createSale(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        address _erc20Token,\n        uint128 _buyNowPrice,\n        address _whitelistedBuyer,\n        address[] memory _feeRecipients,\n        uint32[] memory _feePercentages\n    )\n        external\n        isAuctionNotStartedByOwner(_nftContractAddress, _tokenId)\n        priceGreaterThanZero(_buyNowPrice)\n    {\n        //min price = 0\n        _setupSale(\n            _nftContractAddress,\n            _tokenId,\n            _erc20Token,\n            _buyNowPrice,\n            _whitelistedBuyer,\n            _feeRecipients,\n            _feePercentages\n        );\n\n        emit SaleCreated(\n            _nftContractAddress,\n            _tokenId,\n            msg.sender,\n            _erc20Token,\n            _buyNowPrice,\n            _whitelistedBuyer,\n            _feeRecipients,\n            _feePercentages\n        );\n        //check if buyNowPrice is meet and conclude sale, otherwise reverse the early bid\n        if (_isABidMade(_nftContractAddress, _tokenId)) {\n            if (\n                //we only revert the underbid if the seller specifies a different\n                //whitelisted buyer to the highest bidder\n                _isHighestBidderAllowedToPurchaseNFT(\n                    _nftContractAddress,\n                    _tokenId\n                )\n            ) {\n                if (_isBuyNowPriceMet(_nftContractAddress, _tokenId)) {\n                    _transferNftToAuctionContract(\n                        _nftContractAddress,\n                        _tokenId\n                    );\n                    _transferNftAndPaySeller(_nftContractAddress, _tokenId);\n                }\n            } else {\n                _reverseAndResetPreviousBid(_nftContractAddress, _tokenId);\n            }\n        }\n    }\n\n    /**********************************/\n    /*╔══════════════════════════════╗\n      ║             END              ║\n      ║            SALES             ║\n      ╚══════════════════════════════╝*/\n    /**********************************/\n\n    /*╔═════════════════════════════╗\n      ║        BID FUNCTIONS        ║\n      ╚═════════════════════════════╝*/\n\n    /********************************************************************\n     * Make bids with ETH or an ERC20 Token specified by the NFT seller.*\n     * Additionally, a buyer can pay the asking price to conclude a sale*\n     * of an NFT.                                                      *\n     ********************************************************************/\n\n    function _makeBid(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        address _erc20Token,\n        uint128 _tokenAmount\n    )\n        internal\n        notNftSeller(_nftContractAddress, _tokenId)\n        paymentAccepted(\n            _nftContractAddress,\n            _tokenId,\n            _erc20Token,\n            _tokenAmount\n        )\n        bidAmountMeetsBidRequirements(\n            _nftContractAddress,\n            _tokenId,\n            _tokenAmount\n        )\n    {\n        _reversePreviousBidAndUpdateHighestBid(\n            _nftContractAddress,\n            _tokenId,\n            _tokenAmount\n        );\n        emit BidMade(\n            _nftContractAddress,\n            _tokenId,\n            msg.sender,\n            msg.value,\n            _erc20Token,\n            _tokenAmount\n        );\n        _updateOngoingAuction(_nftContractAddress, _tokenId);\n    }\n\n    function makeBid(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        address _erc20Token,\n        uint128 _tokenAmount\n    )\n        external\n        payable\n        auctionOngoing(_nftContractAddress, _tokenId)\n        onlyApplicableBuyer(_nftContractAddress, _tokenId)\n    {\n        _makeBid(_nftContractAddress, _tokenId, _erc20Token, _tokenAmount);\n    }\n\n    function makeCustomBid(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        address _erc20Token,\n        uint128 _tokenAmount,\n        address _nftRecipient\n    )\n        external\n        payable\n        auctionOngoing(_nftContractAddress, _tokenId)\n        notZeroAddress(_nftRecipient)\n        onlyApplicableBuyer(_nftContractAddress, _tokenId)\n    {\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .nftRecipient = _nftRecipient;\n        _makeBid(_nftContractAddress, _tokenId, _erc20Token, _tokenAmount);\n    }\n\n    /**********************************/\n    /*╔══════════════════════════════╗\n      ║             END              ║\n      ║        BID FUNCTIONS         ║\n      ╚══════════════════════════════╝*/\n    /**********************************/\n\n    /*╔══════════════════════════════╗\n      ║       UPDATE AUCTION         ║\n      ╚══════════════════════════════╝*/\n\n    /***************************************************************\n     * Settle an auction or sale if the buyNowPrice is met or set  *\n     *  auction period to begin if the minimum price has been met. *\n     ***************************************************************/\n    function _updateOngoingAuction(\n        address _nftContractAddress,\n        uint256 _tokenId\n    ) internal {\n        if (_isBuyNowPriceMet(_nftContractAddress, _tokenId)) {\n            _transferNftToAuctionContract(_nftContractAddress, _tokenId);\n            _transferNftAndPaySeller(_nftContractAddress, _tokenId);\n            return;\n        }\n        //min price not set, nft not up for auction yet\n        if (_isMinimumBidMade(_nftContractAddress, _tokenId)) {\n            _transferNftToAuctionContract(_nftContractAddress, _tokenId);\n            _updateAuctionEnd(_nftContractAddress, _tokenId);\n        }\n    }\n\n    function _updateAuctionEnd(address _nftContractAddress, uint256 _tokenId)\n        internal\n    {\n        //the auction end is always set to now + the bid period\n        nftContractAuctions[_nftContractAddress][_tokenId].auctionEnd =\n            _getAuctionBidPeriod(_nftContractAddress, _tokenId) +\n            uint64(block.timestamp);\n        emit AuctionPeriodUpdated(\n            _nftContractAddress,\n            _tokenId,\n            nftContractAuctions[_nftContractAddress][_tokenId].auctionEnd\n        );\n    }\n\n    /**********************************/\n    /*╔══════════════════════════════╗\n      ║             END              ║\n      ║       UPDATE AUCTION         ║\n      ╚══════════════════════════════╝*/\n    /**********************************/\n\n    /*╔══════════════════════════════╗\n      ║       RESET FUNCTIONS        ║\n      ╚══════════════════════════════╝*/\n\n    /*\n     * Reset all auction related parameters for an NFT.\n     * This effectively removes an EFT as an item up for auction\n     */\n    function _resetAuction(address _nftContractAddress, uint256 _tokenId)\n        internal\n    {\n        nftContractAuctions[_nftContractAddress][_tokenId].minPrice = 0;\n        nftContractAuctions[_nftContractAddress][_tokenId].buyNowPrice = 0;\n        nftContractAuctions[_nftContractAddress][_tokenId].auctionEnd = 0;\n        nftContractAuctions[_nftContractAddress][_tokenId].auctionBidPeriod = 0;\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .bidIncreasePercentage = 0;\n        nftContractAuctions[_nftContractAddress][_tokenId].nftSeller = address(\n            0\n        );\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .whitelistedBuyer = address(0);\n        nftContractAuctions[_nftContractAddress][_tokenId].ERC20Token = address(\n            0\n        );\n    }\n\n    /*\n     * Reset all bid related parameters for an NFT.\n     * This effectively sets an NFT as having no active bids\n     */\n    function _resetBids(address _nftContractAddress, uint256 _tokenId)\n        internal\n    {\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .nftHighestBidder = address(0);\n        nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBid = 0;\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .nftRecipient = address(0);\n    }\n\n    /**********************************/\n    /*╔══════════════════════════════╗\n      ║             END              ║\n      ║       RESET FUNCTIONS        ║\n      ╚══════════════════════════════╝*/\n    /**********************************/\n\n    /*╔══════════════════════════════╗\n      ║         UPDATE BIDS          ║\n      ╚══════════════════════════════╝*/\n    /******************************************************************\n     * Internal functions that update bid parameters and reverse bids *\n     * to ensure contract only holds the highest bid.                 *\n     ******************************************************************/\n    function _updateHighestBid(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        uint128 _tokenAmount\n    ) internal {\n        address auctionERC20Token = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].ERC20Token;\n        if (_isERC20Auction(auctionERC20Token)) {\n            IERC20(auctionERC20Token).transferFrom(\n                msg.sender,\n                address(this),\n                _tokenAmount\n            );\n            nftContractAuctions[_nftContractAddress][_tokenId]\n                .nftHighestBid = _tokenAmount;\n        } else {\n            nftContractAuctions[_nftContractAddress][_tokenId]\n                .nftHighestBid = uint128(msg.value);\n        }\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .nftHighestBidder = msg.sender;\n    }\n\n    function _reverseAndResetPreviousBid(\n        address _nftContractAddress,\n        uint256 _tokenId\n    ) internal {\n        address nftHighestBidder = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].nftHighestBidder;\n\n        uint128 nftHighestBid = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].nftHighestBid;\n        _resetBids(_nftContractAddress, _tokenId);\n\n        _payout(_nftContractAddress, _tokenId, nftHighestBidder, nftHighestBid);\n    }\n\n    function _reversePreviousBidAndUpdateHighestBid(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        uint128 _tokenAmount\n    ) internal {\n        address prevNftHighestBidder = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].nftHighestBidder;\n\n        uint256 prevNftHighestBid = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].nftHighestBid;\n        _updateHighestBid(_nftContractAddress, _tokenId, _tokenAmount);\n\n        if (prevNftHighestBidder != address(0)) {\n            _payout(\n                _nftContractAddress,\n                _tokenId,\n                prevNftHighestBidder,\n                prevNftHighestBid\n            );\n        }\n    }\n\n    /**********************************/\n    /*╔══════════════════════════════╗\n      ║             END              ║\n      ║         UPDATE BIDS          ║\n      ╚══════════════════════════════╝*/\n    /**********************************/\n\n    /*╔══════════════════════════════╗\n      ║  TRANSFER NFT & PAY SELLER   ║\n      ╚══════════════════════════════╝*/\n    function _transferNftAndPaySeller(\n        address _nftContractAddress,\n        uint256 _tokenId\n    ) internal {\n        address _nftSeller = nftContractAuctions[_nftContractAddress][_tokenId]\n            .nftSeller;\n        address _nftHighestBidder = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].nftHighestBidder;\n        address _nftRecipient = _getNftRecipient(_nftContractAddress, _tokenId);\n        uint128 _nftHighestBid = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].nftHighestBid;\n        _resetBids(_nftContractAddress, _tokenId);\n\n        _payFeesAndSeller(\n            _nftContractAddress,\n            _tokenId,\n            _nftSeller,\n            _nftHighestBid\n        );\n        IERC721(_nftContractAddress).transferFrom(\n            address(this),\n            _nftRecipient,\n            _tokenId\n        );\n\n        _resetAuction(_nftContractAddress, _tokenId);\n        emit NFTTransferredAndSellerPaid(\n            _nftContractAddress,\n            _tokenId,\n            _nftSeller,\n            _nftHighestBid,\n            _nftHighestBidder,\n            _nftRecipient\n        );\n    }\n\n    function _payFeesAndSeller(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        address _nftSeller,\n        uint256 _highestBid\n    ) internal {\n        uint256 feesPaid;\n        for (\n            uint256 i = 0;\n            i <\n            nftContractAuctions[_nftContractAddress][_tokenId]\n                .feeRecipients\n                .length;\n            i++\n        ) {\n            uint256 fee = _getPortionOfBid(\n                _highestBid,\n                nftContractAuctions[_nftContractAddress][_tokenId]\n                    .feePercentages[i]\n            );\n            feesPaid = feesPaid + fee;\n            _payout(\n                _nftContractAddress,\n                _tokenId,\n                nftContractAuctions[_nftContractAddress][_tokenId]\n                    .feeRecipients[i],\n                fee\n            );\n        }\n        _payout(\n            _nftContractAddress,\n            _tokenId,\n            _nftSeller,\n            (_highestBid - feesPaid)\n        );\n    }\n\n    function _payout(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        address _recipient,\n        uint256 _amount\n    ) internal {\n        address auctionERC20Token = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].ERC20Token;\n        if (_isERC20Auction(auctionERC20Token)) {\n            IERC20(auctionERC20Token).transfer(_recipient, _amount);\n        } else {\n            // attempt to send the funds to the recipient\n            (bool success, ) = payable(_recipient).call{\n                value: _amount,\n                gas: 20000\n            }(\"\");\n            // if it failed, update their credit balance so they can pull it later\n            if (!success) {\n                failedTransferCredits[_recipient] =\n                    failedTransferCredits[_recipient] +\n                    _amount;\n            }\n        }\n    }\n\n    /**********************************/\n    /*╔══════════════════════════════╗\n      ║             END              ║\n      ║  TRANSFER NFT & PAY SELLER   ║\n      ╚══════════════════════════════╝*/\n    /**********************************/\n\n    /*╔══════════════════════════════╗\n      ║      SETTLE & WITHDRAW       ║\n      ╚══════════════════════════════╝*/\n    function settleAuction(address _nftContractAddress, uint256 _tokenId)\n        external\n        isAuctionOver(_nftContractAddress, _tokenId)\n    {\n        _transferNftAndPaySeller(_nftContractAddress, _tokenId);\n        emit AuctionSettled(_nftContractAddress, _tokenId, msg.sender);\n    }\n\n    function withdrawAuction(address _nftContractAddress, uint256 _tokenId)\n        external\n    {\n        //only the NFT owner can prematurely close and auction\n        require(\n            IERC721(_nftContractAddress).ownerOf(_tokenId) == msg.sender,\n            \"Not NFT owner\"\n        );\n        _resetAuction(_nftContractAddress, _tokenId);\n        emit AuctionWithdrawn(_nftContractAddress, _tokenId, msg.sender);\n    }\n\n    function withdrawBid(address _nftContractAddress, uint256 _tokenId)\n        external\n        minimumBidNotMade(_nftContractAddress, _tokenId)\n    {\n        address nftHighestBidder = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].nftHighestBidder;\n        require(msg.sender == nftHighestBidder, \"Cannot withdraw funds\");\n\n        uint128 nftHighestBid = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].nftHighestBid;\n        _resetBids(_nftContractAddress, _tokenId);\n\n        _payout(_nftContractAddress, _tokenId, nftHighestBidder, nftHighestBid);\n\n        emit BidWithdrawn(_nftContractAddress, _tokenId, msg.sender);\n    }\n\n    /**********************************/\n    /*╔══════════════════════════════╗\n      ║             END              ║\n      ║      SETTLE & WITHDRAW       ║\n      ╚══════════════════════════════╝*/\n    /**********************************/\n\n    /*╔══════════════════════════════╗\n      ║       UPDATE AUCTION         ║\n      ╚══════════════════════════════╝*/\n    function updateWhitelistedBuyer(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        address _newWhitelistedBuyer\n    ) external onlyNftSeller(_nftContractAddress, _tokenId) {\n        require(_isASale(_nftContractAddress, _tokenId), \"Not a sale\");\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .whitelistedBuyer = _newWhitelistedBuyer;\n        //if an underbid is by a non whitelisted buyer,reverse that bid\n        address nftHighestBidder = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].nftHighestBidder;\n        uint128 nftHighestBid = nftContractAuctions[_nftContractAddress][\n            _tokenId\n        ].nftHighestBid;\n        if (nftHighestBid > 0 && !(nftHighestBidder == _newWhitelistedBuyer)) {\n            //we only revert the underbid if the seller specifies a different\n            //whitelisted buyer to the highest bider\n\n            _resetBids(_nftContractAddress, _tokenId);\n\n            _payout(\n                _nftContractAddress,\n                _tokenId,\n                nftHighestBidder,\n                nftHighestBid\n            );\n        }\n\n        emit WhitelistedBuyerUpdated(\n            _nftContractAddress,\n            _tokenId,\n            _newWhitelistedBuyer\n        );\n    }\n\n    function updateMinimumPrice(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        uint128 _newMinPrice\n    )\n        external\n        onlyNftSeller(_nftContractAddress, _tokenId)\n        minimumBidNotMade(_nftContractAddress, _tokenId)\n        isNotASale(_nftContractAddress, _tokenId)\n        priceGreaterThanZero(_newMinPrice)\n        minPriceDoesNotExceedLimit(\n            nftContractAuctions[_nftContractAddress][_tokenId].buyNowPrice,\n            _newMinPrice\n        )\n    {\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .minPrice = _newMinPrice;\n\n        emit MinimumPriceUpdated(_nftContractAddress, _tokenId, _newMinPrice);\n\n        if (_isMinimumBidMade(_nftContractAddress, _tokenId)) {\n            _transferNftToAuctionContract(_nftContractAddress, _tokenId);\n            _updateAuctionEnd(_nftContractAddress, _tokenId);\n        }\n    }\n\n    function updateBuyNowPrice(\n        address _nftContractAddress,\n        uint256 _tokenId,\n        uint128 _newBuyNowPrice\n    )\n        external\n        onlyNftSeller(_nftContractAddress, _tokenId)\n        priceGreaterThanZero(_newBuyNowPrice)\n        minPriceDoesNotExceedLimit(\n            _newBuyNowPrice,\n            nftContractAuctions[_nftContractAddress][_tokenId].minPrice\n        )\n    {\n        nftContractAuctions[_nftContractAddress][_tokenId]\n            .buyNowPrice = _newBuyNowPrice;\n        emit BuyNowPriceUpdated(_nftContractAddress, _tokenId, _newBuyNowPrice);\n        if (_isBuyNowPriceMet(_nftContractAddress, _tokenId)) {\n            _transferNftToAuctionContract(_nftContractAddress, _tokenId);\n            _transferNftAndPaySeller(_nftContractAddress, _tokenId);\n        }\n    }\n\n    /*\n     * The NFT seller can opt to end an auction by taking the current highest bid.\n     */\n    function takeHighestBid(address _nftContractAddress, uint256 _tokenId)\n        external\n        onlyNftSeller(_nftContractAddress, _tokenId)\n    {\n        require(\n            _isABidMade(_nftContractAddress, _tokenId),\n            \"cannot payout 0 bid\"\n        );\n        _transferNftToAuctionContract(_nftContractAddress, _tokenId);\n        _transferNftAndPaySeller(_nftContractAddress, _tokenId);\n        emit HighestBidTaken(_nftContractAddress, _tokenId);\n    }\n\n    /*\n     * Query the owner of an NFT deposited for auction\n     */\n    function ownerOfNFT(address _nftContractAddress, uint256 _tokenId)\n        external\n        view\n        returns (address)\n    {\n        address nftSeller = nftContractAuctions[_nftContractAddress][_tokenId]\n            .nftSeller;\n        require(nftSeller != address(0), \"NFT not deposited\");\n\n        return nftSeller;\n    }\n\n    /*\n     * If the transfer of a bid has failed, allow the recipient to reclaim their amount later.\n     */\n    function withdrawAllFailedCredits() external {\n        uint256 amount = failedTransferCredits[msg.sender];\n\n        require(amount != 0, \"no credits to withdraw\");\n\n        failedTransferCredits[msg.sender] = 0;\n\n        (bool successfulWithdraw, ) = msg.sender.call{\n            value: amount,\n            gas: 20000\n        }(\"\");\n        require(successfulWithdraw, \"withdraw failed\");\n    }\n\n    /**********************************/\n    /*╔══════════════════════════════╗\n      ║             END              ║\n      ║       UPDATE AUCTION         ║\n      ╚══════════════════════════════╝*/\n    /**********************************/\n}\n"
6     },
7     "hardhat/console.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
9     },
10     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
12     },
13     "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
15     },
16     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
18     },
19     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
21     }
22   },
23   "settings": {
24     "optimizer": {
25       "enabled": true,
26       "runs": 500
27     },
28     "outputSelection": {
29       "*": {
30         "*": [
31           "evm.bytecode",
32           "evm.deployedBytecode",
33           "devdoc",
34           "userdoc",
35           "metadata",
36           "abi"
37         ]
38       }
39     },
40     "metadata": {
41       "useLiteralContent": true
42     },
43     "libraries": {}
44   }
45 }}