1 {{
2   "language": "Solidity",
3   "sources": {
4     "sol/LWMempools.sol": {
5       "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\nimport './LTNT.sol';\nimport './lib/Rando.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\n\n\n/**\n\n          ___  ___      ___        __   __        __  \n|     /\\   |  |__  |\\ |  |   |  | /  \\ |__) |__/ /__` \n|___ /~~\\  |  |___ | \\|  |  .|/\\| \\__/ |  \\ |  \\ .__/ \n                                                      \n\"mempools\", latent.works, 2022\n\n\n*/\n\n\n/// @title Mempools\n/// @author troels_a\n/// @notice latent.works/mempools\n\ncontract LWMempools is ERC721, LTNTIssuer, Ownable, ReentrancyGuard {\n\n    /// @dev main bank struct\n    struct Bank {\n        string _name; // name of bank\n        string[4] _parts; // parts of the bank\n        string _filter;\n        uint[15] _pools;\n    }\n\n    uint public constant PRICE = 0.15 ether; // The price of one mempool\n\n    uint private _pool_ids; // Tracks the current pool id\n    Bank[15] private _banks; // Holds banks\n    mapping(uint => uint) private _pool_timestamps; // Holds the timestamp of when a pool was created\n    mapping(uint => uint) private _pool_banks; // Holds the bank id of a pool - id => bank_index\n    mapping(uint => uint) private _pool_fixed_epochs; // Holds the fixed epoch of a pool - id => epoch\n\n    LTNT public immutable _ltnt; // The LTNT token contract\n    LWMempools_Gen public immutable _generator; // The generator contract\n    LWMempools_Meta private _meta; // The meta contract\n\n\n    //////////////////////////\n    /// CONTRACT\n    //////////////////////////\n\n    constructor(address ltnt_) ERC721(\"Mempools\", \"MMPLS\"){\n        _ltnt = LTNT(ltnt_); // Set the LTNT token contract\n        _generator = new LWMempools_Gen(); // Deploy the generator contract\n        _meta = new LWMempools_Meta(); // Deploy the meta contract\n    }\n\n    /// @dev declare issuer info for LTNT\n    /// @return LTNT.IssuerInfo struct with issuer info\n    /// @param param_ the LTNT token params struct\n    function issuerInfo(uint, LTNT.Param memory param_) public view override returns(LTNT.IssuerInfo memory){\n        return LTNT.IssuerInfo('mempools', getPoolImage(param_._uint, true));\n    }\n\n\n    /// @dev get the address of the _meta contract\n    /// @return address of the _meta contract\n    function getMeta() public view returns (address){\n        return address(_meta);\n    }\n\n\n    /// @dev set the address of the _meta contract\n    /// @param meta_ the address of the new _meta contract\n    function setMeta(address meta_) public onlyOwner {\n        _meta = LWMempools_Meta(meta_);\n    }\n\n\n\n\n    /////////////////////////////\n    /// MINTING\n    /////////////////////////////\n\n\n    /// @dev mint a new mempool\n    /// @param bank_index_ the bank id of the mempool\n    /// @param pool_index_ the pool id of the mempool\n    function mint(uint bank_index_, uint pool_index_) public payable nonReentrant {\n        uint bank_count_ = getBankCount();\n        require(msg.value == PRICE, 'INVALID_PRICE'); // Check price\n        require(bank_count_ > 0 && bank_index_ < bank_count_, 'INVALID_BANK'); // Check bank index\n        require(_banks[bank_index_]._pools[pool_index_] == 0, 'POOL_INDEX_USED'); // Check pool index\n        _mintFor(msg.sender, bank_index_, pool_index_); // Mint the mempool\n    }\n\n\n    /// @dev mint a new mempool holding a LTNT token\n    /// @param ltnt_id_ the id of the LTNT token to hold\n    /// @param bank_index_ the bank id of the mempool\n    /// @param pool_index_ the pool id of the mempool\n    function mintWithLTNT(uint ltnt_id_, uint bank_index_, uint pool_index_) public payable nonReentrant {\n        uint bank_count_ = getBankCount();\n        require(msg.value == (PRICE/3)*2, 'INVALID_PRICE'); // Check price\n        require(_ltnt.ownerOf(ltnt_id_) == msg.sender, 'NOT_LTNT_HOLDER'); // Check LTNT ownership\n        require(!_ltnt.hasStamp(ltnt_id_, address(this)), 'ALREADY_STAMPED'); // Check if LTNT is already stamped\n        require(bank_count_ > 0 && bank_index_ < bank_count_, 'INVALID_BANK'); // Check bank index\n        require(_banks[bank_index_]._pools[pool_index_] == 0, 'POOL_INDEX_USED'); // Check pool index\n        uint id_ = _mintFor(msg.sender, bank_index_, pool_index_); // Mint the mempool\n        _ltnt.stamp(ltnt_id_, LTNT.Param(id_, address(0), '', false)); // Stamp the LTNT token\n    }\n\n\n    /// @dev internal mint function\n    function _mintFor(address for_, uint bank_, uint index_) private returns(uint) {\n        _pool_ids++; // Increment the pool id\n        _mint(for_, _pool_ids); // Mint the token\n        _pool_timestamps[_pool_ids] = block.timestamp; // Set the timestamp of the pool\n        _pool_banks[_pool_ids] = bank_; // Set the bank of the pool\n        _banks[bank_]._pools[index_] = _pool_ids; // Set the pool id of the bank\n        return _pool_ids;\n    }\n\n\n    /// @dev get the total supply of mempools\n    /// @return uint total supply of mempools\n    function totalSupply() public view returns (uint) {\n        return _pool_ids;\n    }\n\n\n    /////////////////////////////\n    /// BANKS\n    /////////////////////////////\n\n\n    /// @dev add a bank to the contract\n    /// @param name_ the name of the bank\n    /// @param parts_ the parts of the bank\n    /// @param filter_ the filter of the bank\n    function addBank(string memory name_, string[4] memory parts_, string memory filter_) public onlyOwner {\n\n        uint next_index_ = getBankCount(); // Current count should be equal to next index since we start at 0\n        require(next_index_ < _banks.length, \"MAX_BANKS\"); // Make sure we don't exceed the max banks\n        \n        _banks[next_index_]._name = name_; // Set the name\n        _banks[next_index_]._parts = parts_; // Set the parts\n        _banks[next_index_]._filter = filter_; // Set the filter\n\n    }\n\n\n    /// @dev get a specific bank\n    /// @return Bank struct\n    /// @param index_ the index of the bank in _banks\n    function getBank(uint index_) public view returns(Bank memory){\n        return _banks[index_];\n    }\n\n\n    /// @dev get array of added banks\n    /// @return array of Bank structs\n    function getBanks() public view returns(Bank[] memory){\n        \n        uint count = getBankCount(); // Get the bank count\n\n        Bank[] memory banks_ = new Bank[](count); // Create a new array of banks with the correct length\n\n        for(uint i = 0; i < count; i++) // Copy the banks to the new array\n            banks_[i] = _banks[i];\n\n        return banks_;\n\n    }\n\n\n    /// @dev get the cuurent count of banks\n    /// @return uint the count\n    function getBankCount() public view returns(uint) {\n\n        uint count_; // Init the count\n        for(uint i = 0; i < _banks.length; i++) // Loop through the banks\n            if(bytes(_banks[i]._name).length > 0) // If the name is not empty\n                count_++; // Increment the count\n\n        return count_;\n    }\n\n\n\n\n\n\n    /////////////////////////////\n    /// POOLS\n    /////////////////////////////\n\n\n    /// @dev check if a pool exists\n    /// @return bool if the pool exists\n    /// @param pool_id_ the id of the pool\n    function poolExists(uint pool_id_) public view returns(bool) {\n        return _exists(pool_id_);\n    }\n\n\n    /// @dev get the filter for a given pool\n    /// @return string the name of the filter\n    function getPoolFilter(uint pool_id_) public view returns(string memory){\n        return _banks[_pool_banks[pool_id_]]._filter;\n    }\n\n\n    /// @dev get the bank index for a given pool\n    /// @return uint the index of the bank\n    /// @param pool_id_ the id of the pool\n    function getPoolBankIndex(uint pool_id_) public view returns(uint){\n        return _pool_banks[pool_id_];\n    }\n\n\n    /// @dev get the Bank struct for a given pool\n    /// @return Bank the bank struct\n    /// @param pool_id_ the id of the pool\n    function getPoolBank(uint pool_id_) public view returns(LWMempools.Bank memory){\n        return getBank(getPoolBankIndex(pool_id_));\n    }\n\n\n    /// @dev get the part index for a given pool\n    /// @return uint the index of the part\n    /// @param pool_id_ the id of the pool\n    function getPoolPartIndex(uint pool_id_) public view returns(uint){\n        Bank memory bank_ = getPoolBank(pool_id_);\n        string memory seed_part_ = getPoolSeed(pool_id_, 'part');\n        return Rando.number(seed_part_, 0, bank_._parts.length-1);\n    }\n\n\n    /// @dev get the part for a given pool\n    /// @return string the part\n    /// @param pool_id_ the id of the pool\n    function getPoolPart(uint pool_id_) public view returns(string memory){\n        LWMempools.Bank memory bank_ = getPoolBank(pool_id_);\n        return bank_._parts[getPoolPartIndex(pool_id_)];\n    }\n\n\n    /// @dev get the seed for a given pool\n    /// @return string the seed\n    /// @param pool_id_ the id of the pool\n    /// @param append_ a string to append to the seed\n    function getPoolSeed(uint pool_id_, string memory append_) public view returns(string memory){\n        return string(abi.encodePacked(Strings.toString(_pool_timestamps[pool_id_]), Strings.toString(pool_id_), append_));\n    }\n\n\n\n\n\n    /////////////////////////////\n    /// EPOCHS\n    /////////////////////////////\n\n    /// @dev get epoch length for a given pool in seconds\n    /// @return uint the epoch length\n    /// @param pool_id_ the id of the pool\n    function getEpochLength(uint pool_id_) public view returns(uint){\n        return Rando.number(getPoolSeed(pool_id_, 'epoch'), 1, 6)*7776000;\n    }\n\n\n    /// @dev get the current epoch for a given pool\n    /// @return uint the epoch number\n    /// @param pool_id_ the id of the pool\n    function getCurrentEpoch(uint pool_id_) public view returns(uint){\n        uint epoch = (((block.timestamp - _pool_timestamps[pool_id_]) / getEpochLength(pool_id_))+1);\n        return epoch;\n    }\n\n\n    /// @dev get the fixed epoch for a given pool\n    /// @return uint the epoch number - 0 means the pool epoch is not fixed\n    /// @param pool_id_ the id of the pool\n    function getFixedEpoch(uint pool_id_) public view returns(uint){\n        return _pool_fixed_epochs[pool_id_];\n    }\n\n\n    /// @dev allow pool owner to fix the epoch for a given pool\n    /// @param pool_id_ the id of the pool\n    /// @param epoch_ the epoch to fix the pool to\n    function fixEpoch(uint pool_id_, uint epoch_) public {\n        require(ownerOf(pool_id_) == msg.sender, 'NOT_OWNER');\n        require(getCurrentEpoch(pool_id_) <= epoch_, 'EPOCH_NOT_REACHED');\n        _pool_fixed_epochs[pool_id_] = epoch_;\n    }\n\n\n\n\n\n    /// @dev get the generated image for a pool\n    /// @return string the image\n    /// @param pool_id_ the id of the pool\n    function getPoolImage(uint pool_id_, bool encode_) public view returns(string memory){\n\n        if(!poolExists(pool_id_)) // If the pool doesn't exist...\n            return ''; // ...return empty string\n\n        uint epoch_ = _pool_fixed_epochs[pool_id_]; // Get the fixed epoch\n        if(epoch_ < 1) // Fixed epoch is 0, go to current epoch\n            epoch_ = getCurrentEpoch(pool_id_); // Get the current epoch\n\n        return _generator.generateImage(pool_id_, epoch_, encode_); // Get the image based on id and epoch\n\n    }\n\n\n    /// @dev get the metadat data uri for a given pool\n    /// @return string the uri\n    /// @param pool_id_ the id of the pool\n    function tokenURI(uint pool_id_) override public view returns(string memory) {\n        return _meta.getJSON(pool_id_, true);\n    }\n\n\n    //////////////////////////\n    /// BALANCE\n    //////////////////////////\n\n    function withdrawAllTo(address to_) public payable onlyOwner {\n      require(payable(to_).send(address(this).balance));\n    }\n\n}\n\n\n/// @title Mempools meta\n/// @author troels_a\n/// @notice This contract handles the metadata for the mempools contract\ncontract LWMempools_Meta {\n\n    using Strings for string;\n\n    LWMempools public _pools; // The mempools contract\n\n    constructor() {\n        _pools = LWMempools(msg.sender); // Set the mempools contract\n    }\n    \n    /// @dev get the metadata for a given pool\n    /// @return string the metadata\n    /// @param pool_id_ the id of the pool\n    function getJSON(uint pool_id_, bool encode_) public view returns(string memory) {\n        \n        if(!_pools.poolExists(pool_id_)) // If the pool doesn't exist...\n            return ''; // ...return empty string\n\n        LWMempools.Bank memory bank_ = _pools.getPoolBank(pool_id_); // Get the bank for the pool\n\n        // Create the JSON string\n        bytes memory json_ = abi.encodePacked(\n            '{',\n                '\"name\":\"mempool #',Strings.toString(pool_id_),'\",',\n                '\"image\": \"', _pools.getPoolImage(pool_id_, true),'\",',\n                '\"description\": \"latent.works\",',\n                '\"attributes\": [',\n                    '{\"trait_type\": \"bank\", \"value\": \"',bank_._name,'\"},',\n                    '{\"trait_type\": \"bank_index\", \"value\": \"',bank_._name,'-',Strings.toString(_pools.getPoolPartIndex(pool_id_)),'\"},',\n                    '{\"trait_type\": \"epoch\", \"value\": ', Strings.toString(_pools.getCurrentEpoch(pool_id_)), '},',\n                    '{\"trait_type\": \"fixed_epoch\", \"value\": ', Strings.toString(_pools.getFixedEpoch(pool_id_)), '},',\n                    '{\"trait_type\": \"epoch_length\", \"value\": ', Strings.toString(_pools.getEpochLength(pool_id_)), '}',\n                ']',\n            '}'\n        );\n\n        if(encode_) // If encode_ is true\n            return string(abi.encodePacked('data:application/json;base64,', Base64.encode(json_))); // ...encode the json string\n        return string(json_); // return the raw JSON\n\n    }\n\n\n}\n\n\n/// @title Mempools generator\n/// @author troels_a\n/// @notice Generates images for mempools\ncontract LWMempools_Gen {\n    \n    struct Pool {\n        uint id;\n        bytes items;\n        string base;\n        string seed;\n        string seed1;\n        string seed2;\n        string filter;\n        uint epoch;\n        string shape1_width;\n        string shape1_height;\n        string shape2_width;\n        string shape2_height;\n        string shape3_width;\n        string shape3_height;\n    }\n\n    LWMempools public immutable _pools; // The mempools contract\n\n    constructor(){\n        _pools = LWMempools(msg.sender); // Set the mempools contract\n    }\n\n    /// @dev generate an image for a given pool\n    /// @return string the image\n    /// @param pool_id_ the id of the pool\n    /// @param epoch_ the epoch to generate the image for\n    /// @param encode_ bool indicating if the image should be encoded as base64 or not\n    function generateImage(uint pool_id_, uint epoch_, bool encode_) public view returns(string memory){\n\n        if(!_pools.poolExists(pool_id_)) // If the pool doesn't exist...\n            return ''; // ...return empty string\n\n        Pool memory pool_; // Create a pool struct\n        pool_.epoch = _pools.getCurrentEpoch(pool_id_); // Get the current epoch for pool\n\n        if(epoch_ > pool_.epoch) // If the epoch input is higher than the current epoch...\n            return ''; // ...return empty string\n        \n        pool_.id = pool_id_; // Set the pool id\n        pool_.seed = _pools.getPoolSeed(pool_id_, ''); // Get the main seed for this pool\n        pool_.base = _pools.getPoolPart(pool_id_); // Get the base part for this pool\n        pool_.filter = _pools.getPoolFilter(pool_id_); // Get the filter for this pool\n\n\n        /**\n         * Create the shapes for each pool epoch\n         */\n\n        uint i;\n        while(i < pool_.epoch){\n            pool_.seed1 =_pools.getPoolSeed(pool_id_, string(abi.encodePacked('1x', Strings.toString(i))));\n            pool_.seed2 = _pools.getPoolSeed(pool_id_, string(abi.encodePacked('1y', Strings.toString(i))));\n            pool_.items = abi.encodePacked(\n                pool_.items,\n                '<use href=\"#shape',Strings.toString(Rando.number(pool_.seed1, 1, 3)),'\" x=\"',Strings.toString(Rando.number(pool_.seed1, 1, 990)),'\" y=\"',Strings.toString(Rando.number(pool_.seed2, 1, 900)),'\" fill=\"url(#base',Strings.toString(Rando.number(pool_.seed2, 1, 5)),')\"/>'\n            );\n\n            ++i;\n        }\n\n        i = 0;\n        while(i < pool_.epoch){\n            pool_.seed1 = _pools.getPoolSeed(pool_id_, string(abi.encodePacked('2x', Strings.toString(i))));\n            pool_.seed2 = _pools.getPoolSeed(pool_id_, string(abi.encodePacked('2y', Strings.toString(i))));\n            pool_.items = abi.encodePacked(\n                pool_.items,\n                '<use href=\"#shape',Strings.toString(Rando.number(pool_.seed1, 1, 3)),'\" x=\"',Strings.toString(Rando.number(pool_.seed1, 1, 990)),'\" y=\"',Strings.toString(Rando.number(pool_.seed2, 1, 900)),'\" fill=\"url(#base',Strings.toString(Rando.number(pool_.seed2, 1, 5)),')\"/>'\n            );\n\n            ++i;\n        }\n\n        i = 0;\n        while(i < pool_.epoch){\n            pool_.seed1 = _pools.getPoolSeed(pool_id_, string(abi.encodePacked('3x', Strings.toString(i))));\n            pool_.seed2 = _pools.getPoolSeed(pool_id_, string(abi.encodePacked('3y', Strings.toString(i))));\n            pool_.items = abi.encodePacked(\n                pool_.items,\n                '<use href=\"#shape',Strings.toString(Rando.number(pool_.seed1, 1, 3)),'\" x=\"',Strings.toString(Rando.number(pool_.seed1, 1, 990)),'\" y=\"',Strings.toString(Rando.number(pool_.seed2, 1, 900)),'\" fill=\"url(#base',Strings.toString(Rando.number(pool_.seed2, 1, 5)),')\"/>'\n            );\n\n            ++i;\n        }\n\n        /**\n         * Create the shape dimensions\n         */\n        pool_.shape1_width = Strings.toString(Rando.number(_pools.getPoolSeed(pool_.id, 'shape1width'), 1, 50));\n        pool_.shape1_height = Strings.toString(Rando.number(_pools.getPoolSeed(pool_.id, 'shape1height'), 20, 300));\n        pool_.shape2_width = Strings.toString(Rando.number(_pools.getPoolSeed(pool_.id, 'shape2width'), 20, 30));\n        pool_.shape2_height = Strings.toString(Rando.number(_pools.getPoolSeed(pool_.id, 'shape2height'), 20, 200));\n        pool_.shape3_width = Strings.toString(Rando.number(_pools.getPoolSeed(pool_.id, 'shape2height'), 10, 30));\n        pool_.shape3_height = Strings.toString(Rando.number(_pools.getPoolSeed(pool_.id, 'shape3width'), 20, 100));\n\n        /**\n         * Create the svg\n         */\n        bytes memory svg_ = abi.encodePacked(\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1000 1000\" preserveAspectRatio=\"xMinYMin meet\">',\n                '<defs>',\n                    '<circle cx=\"500\" cy=\"500\" r=\"500\" id=\"bg\"/>',\n                    '<filter id=\"none\"><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"0\"/></filter>',\n                    '<filter id=\"bw\"><feColorMatrix type=\"matrix\" values=\"0.491 1.650 0.166 0.000 -0.464 0.491 1.650 0.166 0.000 -0.464 0.491 1.650 0.166 0.000 -0.464 0.000 0.000 0.000 1.000 0.000\"></feColorMatrix></filter>',\n                    '<filter id=\"s1\"><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"2\"/></filter>',\n                    '<filter id=\"s2\"><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"4\"/></filter>',\n                    '<filter id=\"s3\"><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"6\"/></filter>',\n                    '<filter id=\"s4\"><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"8\"/></filter>',\n                    '<filter id=\"s5\"><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"10\"/></filter>',\n                    '<filter id=\"s6\"><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"12\"/></filter>',\n                    '<filter id=\"s7\"><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"14\"/></filter>',\n                    '<filter id=\"s8\"><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"16\"/></filter>',\n                    '<filter id=\"s9\"><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"18\"/></filter>',\n                    '<filter id=\"s10\"><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"20\"/></filter>',\n                    '<filter id=\"r1\"><feColorMatrix in=\"SourceGraphic\" type=\"hueRotate\" values=\"20\"></feColorMatrix><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"3\"/></filter>',\n                    '<filter id=\"r2\"><feColorMatrix in=\"SourceGraphic\" type=\"hueRotate\" values=\"40\"></feColorMatrix><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"3\"/></filter>',\n                    '<filter id=\"r3\"><feColorMatrix in=\"SourceGraphic\" type=\"hueRotate\" values=\"60\"></feColorMatrix><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"3\"/></filter>',\n                    '<filter id=\"r4\"><feColorMatrix in=\"SourceGraphic\" type=\"hueRotate\" values=\"80\"></feColorMatrix><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"3\"/></filter>',\n                    '<filter id=\"r5\"><feColorMatrix in=\"SourceGraphic\" type=\"hueRotate\" values=\"100\"></feColorMatrix><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"3\"/></filter>',\n                    '<filter id=\"r6\"><feColorMatrix in=\"SourceGraphic\" type=\"hueRotate\" values=\"120\"></feColorMatrix><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"3\"/></filter>',\n                    '<filter id=\"r7\"><feColorMatrix in=\"SourceGraphic\" type=\"hueRotate\" values=\"140\"></feColorMatrix><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"3\"/></filter>',\n                    '<filter id=\"r8\"><feColorMatrix in=\"SourceGraphic\" type=\"hueRotate\" values=\"160\"></feColorMatrix><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"3\"/></filter>',\n                    '<filter id=\"r9\"><feColorMatrix in=\"SourceGraphic\" type=\"hueRotate\" values=\"180\"></feColorMatrix><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"3\"/></filter>',\n                    '<filter id=\"r10\"><feColorMatrix in=\"SourceGraphic\" type=\"hueRotate\" values=\"200\"></feColorMatrix><feColorMatrix in=\"SourceGraphic\" type=\"saturate\" values=\"3\"/></filter>',\n                    '<filter id=\"internal-noise\"><feTurbulence type=\"fractalNoise\" baseFrequency=\"0.55\" numOctaves=\"10\" stitchTiles=\"stitch\" /></filter>',\n                    '<filter id=\"internal-blur\" x=\"0\" y=\"0\"><feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"4\" /></filter>',\n                    '<clipPath id=\"clip\"><use href=\"#bg\"/></clipPath>',\n                    '<rect id=\"shape1\" width=\"',pool_.shape1_width,'\" height=\"',pool_.shape1_height,'\"/>',\n                    '<rect id=\"shape2\" width=\"30\" height=\"',pool_.shape2_height,'\"/>',\n                    '<rect id=\"shape3\" width=\"20\" height=\"',pool_.shape3_height,'\"/>',\n                    '<image id=\"base\" width=\"1000\" height=\"1000\" href=\"',pool_.base,'\"/>',\n                    '<pattern id=\"base1\" x=\"0\" y=\"0\" width=\"1\" height=\"1\" viewBox=\"0 0 200 200\"><use href=\"#base\"/></pattern>',\n                    '<pattern id=\"base2\" x=\"0\" y=\"0\" width=\"1\" height=\"1\" viewBox=\"200 200 200 200\" preserveAspectRatio=\"xMidYMid slice\"><use href=\"#base\"/></pattern>',\n                    '<pattern id=\"base3\" x=\"0\" y=\"0\" width=\"1\" height=\"1\" viewBox=\"400 400 200 200\" preserveAspectRatio=\"xMidYMid slice\"><use href=\"#base\"/></pattern>',\n                    '<pattern id=\"base4\" x=\"0\" y=\"0\" width=\"1\" height=\"1\" viewBox=\"600 600 200 200\" preserveAspectRatio=\"xMidYMid slice\"><use href=\"#base\"/></pattern>',\n                    '<pattern id=\"base5\" x=\"0\" y=\"0\" width=\"1\" height=\"1\" viewBox=\"800 800 200 200\" preserveAspectRatio=\"xMidYMid slice\"><use href=\"#base\"/></pattern>',\n                '</defs>',\n                '<g filter=\"url(#',pool_.filter,')\">',\n                    '<rect width=\"1000\" height=\"1000\" fill=\"black\"/>',\n                    '<rect width=\"1000\" height=\"1000\" fill-opacity=\"0.5\" fill=\"url(#base',Strings.toString(Rando.number(_pools.getPoolSeed(pool_.id, 'bg0'), 2, 5)),')\" filter=\"url(#bw)\"/>',\n                    '<g clip-path=\"url(#clip)\">',\n                        '<use href=\"#bg\" fill-opacity=\"1\" fill=\"url(#base',Strings.toString(Rando.number(_pools.getPoolSeed(pool_.id, 'bg1'), 2, 5)),')\"/>',\n                    '<g filter=\"url(#internal-blur)\" transform=\"translate(0, -100)\" id=\"pool\">',\n                    pool_.items,\n                    '</g>',\n                    '<use href=\"#pool\" transform=\"scale(.5, 0.5)\"/>',\n                    '<use href=\"#pool\" transform=\"scale(.5, 0.5) translate(',Strings.toString(Rando.number(pool_.seed, 0, 100)),', 1000)\"/>'\n                    '<use href=\"#pool\" transform=\"scale(0.8, 0.8) translate(1000, 0)\"/>'\n                    '<use href=\"#pool\"  transform=\"scale(1, 1.5) translate(',Strings.toString(Rando.number(pool_.seed, 0, 500)),', ',Strings.toString(Rando.number(pool_.seed, 0, 500)),')\"/>',\n                    '</g>',\n                    '<g filter=\"url(#bw)\">',\n                        '<rect width=\"1000\" height=\"1000\" fill=\"white\" filter=\"url(#internal-noise)\" opacity=\"0.15\"/>',\n                    '</g>',\n                '</g>',\n            '</svg>'\n        );\n\n        if(encode_) // encode the svg\n            return string(abi.encodePacked('data:image/svg+xml;base64,', Base64.encode(svg_)));\n\n        // return the raw svg\n        return string(svg_);\n\n    }\n\n\n}"
6     },
7     "sol/LTNT.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./LTNTFont.sol\";\nimport \"base64-sol/base64.sol\";\n\n\n//////////////////////////////////\n//\n//\n// LTNT\n// Passport NFTs for Latent Works\n//\n//\n//////////////////////////////////\n\n\n/// @title LTNT\n/// @author troels_a\n\ncontract LTNT is ERC721, Ownable {\n    \n    struct Param {\n        uint _uint;\n        address _address;\n        string _string;\n        bool _bool;\n    }\n\n    struct IssuerInfo {\n        string name;\n        string image;\n    }\n\n    struct Issuer {\n        address location;\n        Param param;\n    }\n\n    event Issued(uint indexed id, address indexed to);\n    event Stamped(uint indexed id, address indexed stamper);\n\n    LTNT_Meta private _ltnt_meta;\n\n    address[] private _issuers; ///@dev array of addresses registered as issuers\n    mapping(uint => mapping(address => bool)) private _stamps; ///@dev (ltnt => (issuer => is stamped?))\n    mapping(uint => mapping(address => Param)) private _params; ///@dev (ltnt => (issuer => stamp parameters));\n    mapping(uint => Issuer) private _issuer_for_id; ///@dev (ltnt => issuer) - the Issuer for a given LTNT\n    \n    uint private _ids; ///@dev LTNT _id counter\n\n    /// @dev pass address of onchain fonts to the constructor\n    constructor(address regular_, address italic_) ERC721(\"Latents\", \"LTNT\"){\n\n        LTNT_Meta ltnt_meta_ = new LTNT_Meta(address(this), regular_, italic_);\n        _ltnt_meta = LTNT_Meta(address(ltnt_meta_));\n\n    }\n\n\n\n\n    /// @notice Require a given address to be a registered issuer\n    /// @param caller_ the address to check for issuer privilegies\n    function _reqOnlyIssuer(address caller_) private view {\n        require(isIssuer(caller_), 'ONLY_ISSUER');\n    }\n\n\n\n    /// @notice Issue a token to the address\n    /// @param to_ the address to issue the LTNT to\n    /// @param param_ a Param struct of parameters associated with the token\n    /// @param stamp_ boolean determining wether the newly issued LTNT should be stamped by the issuer\n    /// @return uint the id of the newly issued LTNT\n    function issueTo(address to_, Param memory param_, bool stamp_) public returns(uint){ _reqOnlyIssuer(msg.sender);\n        \n        _ids++;\n        _safeMint(to_, _ids);\n        _issuer_for_id[_ids] = Issuer(msg.sender, param_);\n\n        emit Issued(_ids, to_);\n        \n        if(stamp_)\n            _stamp(_ids, msg.sender, param_);\n\n        return _ids;\n\n    }\n\n\n\n    /// @dev Lets a registered issuer stamp a given LTNT\n    /// @param id_ the ID of the LTNT to stamp\n    /// @param param_ a Param struct with any associated params\n    function stamp(uint id_, Param memory param_) public { _reqOnlyIssuer(msg.sender);\n        _stamp(id_, msg.sender, param_);\n    }\n\n\n\n    /// @dev internal stamping mechanism\n    /// @param id_ the id of the LTNT to stamp\n    /// @param issuer_ the address of the issuer stamping the LTNT\n    /// @param param_ a Param struct with stamp parameters\n    function _stamp(uint id_, address issuer_, Param memory param_) private {\n        _stamps[id_][issuer_] = true;\n        _params[id_][issuer_] = param_;\n        emit Stamped(_ids, issuer_);\n    }\n\n    /// @dev checks if a given id_ is stamped by address_\n    /// @param id_ the ID of the LTNT to check\n    /// @param address_ the address of the stamper\n    /// @return bool indicating wether LTNT is stamped\n    function hasStamp(uint id_, address address_) public view returns(bool){\n        return _stamps[id_][address_];\n    }\n\n    /// @dev get params for a given stamp on a LTNT\n    /// @param id_ the id of the LTNT\n    /// @param address_ the address of the stamper\n    /// @return Param the param to return\n    function getStampParams(uint id_, address address_) public view returns(Param memory){\n        return _params[id_][address_];\n    }\n\n    /// @dev Get the addresses of the issuers that have stamped a given LTNT\n    /// @param id_ the ID of the LTNT to fetch stamps for\n    /// @return addresses an array of issuer addresses that have stamped the LTNT\n    function getStamps(uint id_) public view returns(address[] memory){\n        \n        // First count the stamps\n        uint count;\n        for(uint i = 0; i < _issuers.length; i++){\n            if(_stamps[id_][_issuers[i]])\n                ++count;\n        }\n\n        // Init a stamps_ array with the right length from count_\n        address[] memory stamps_ = new address[](count);\n\n        // Loop over the issuers and save stampers in stamps_\n        count = 0;\n        for(uint i = 0; i < _issuers.length; i++){\n            if(_stamps[id_][_issuers[i]]){\n                stamps_[count] = _issuers[i];\n                ++count;\n            }\n        }\n\n        return stamps_;\n\n    }\n\n    /// @dev list all issuer addresses\n    /// @return addresses list of all issuers\n    function getIssuers() public view returns(address[] memory){\n        return _issuers;\n    }\n\n    /// @dev get the issuer of a LTNT\n    function getIssuerFor(uint id_) public view returns(LTNT.Issuer memory){\n        return _issuer_for_id[id_];\n    }\n\n    /// @dev set the meta contract\n    /// @param address_ the address of the meta contract\n    function setMetaContract(address address_) public onlyOwner {\n        _ltnt_meta = LTNT_Meta(address_);\n    }\n\n    /// @dev get the meta contract\n    /// @return LTNT_Meta the meta contract currently in use\n    function getMetaContract() public view returns(LTNT_Meta) {\n        return _ltnt_meta;\n    }\n\n    /// @notice register an issuer address\n    /// @param address_ the address of the issuer to add\n    function addIssuer(address address_) public onlyOwner {\n        _issuers.push(address_);\n    }\n    \n\n    /// @notice determine if an address is a LW project\n    /// @param address_ the address of the issuer\n    /// @return bool indicating wether the address is an issuer or not\n    function isIssuer(address address_) public view returns(bool){\n        for(uint i = 0; i < _issuers.length; i++) {\n            if(_issuers[i] == address_)\n                return true;\n        }\n        return false;\n    }\n\n\n    /// @notice the ERC721 tokenURI for a given LTNT\n    /// @param id_ the id of the LTNT\n    /// @return json_ base64 encoded data URI containing the JSON metadata\n    function tokenURI(uint id_) public view override returns(string memory json_){\n        return _ltnt_meta.getJSON(id_, true);\n    }\n\n\n}\n\n\n/// @title A title that should describe the contract/interface\n/// @author troels_a\n/// @dev Handles meta for this contract\ncontract LTNT_Meta {\n\n    LTNT public immutable _ltnt;\n\n    ///@dev latent fonts\n    XanhMonoRegularLatin public immutable _xanh_regular;\n    XanhMonoItalicLatin public immutable _xanh_italic;\n\n    constructor(address ltnt_, address regular_, address italic_){\n\n        _ltnt = LTNT(ltnt_);\n        _xanh_regular = XanhMonoRegularLatin(regular_);\n        _xanh_italic = XanhMonoItalicLatin(italic_);\n\n    }\n\n    /// @notice return image string for id_\n    /// @param id_ the id of the LTNT to retrieve the image for\n    /// @param encode_ encode output as base64 uri\n    /// @return string the image string\n    function getImage(uint id_, bool encode_) public view returns(string memory){\n\n        LTNT.Issuer memory issuer_for_id_ = _ltnt.getIssuerFor(id_);\n        LTNT.IssuerInfo memory issuer_info_ = LTNTIssuer(issuer_for_id_.location).issuerInfo(id_, issuer_for_id_.param);\n        LTNT.IssuerInfo memory stamper_;\n        LTNT.Param memory stamp_param_;\n        address[] memory issuers_ = _ltnt.getIssuers();\n\n        bytes memory stamps_svg_;\n        string memory delay_;\n        uint stamp_count_;\n        bool has_stamp_;\n\n        for(uint i = 0; i < issuers_.length; i++) {\n\n            delay_ = Strings.toString(i*150);\n            stamp_param_ = _ltnt.getStampParams(id_,issuers_[i]);\n            stamper_ = LTNTIssuer(issuers_[i]).issuerInfo(id_, stamp_param_);\n            has_stamp_ = _ltnt.hasStamp(id_, issuers_[i]);\n\n            stamps_svg_ = abi.encodePacked(stamps_svg_, '<text class=\"txt italic\" fill-opacity=\"0\" y=\"',Strings.toString(25*i),'\">',stamper_.name,' <animate attributeName=\"fill-opacity\" values=\"0;',has_stamp_ ? '1' : '0.4','\" dur=\"500ms\" repeatCount=\"1\" begin=\"',delay_,'ms\" fill=\"freeze\"/></text>');\n            if(has_stamp_)\n                ++stamp_count_;\n\n        }\n\n        bytes memory image_;\n        image_ = abi.encodePacked(\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 600 1000\" preserveAspectRatio=\"xMinYMin meet\">',\n                '<defs><style>', _xanh_regular.fontFace(), _xanh_italic.fontFace(),' .txt {font-family: \"Xanh Mono\"; font-size:20px; font-weight: normal; letter-spacing: 0.01em; fill: white;} .italic {font-style: italic;} .large {font-size: 55px;} .small {font-size: 12px;}</style><rect ry=\"30\" rx=\"30\" id=\"bg\" height=\"1000\" width=\"600\" fill=\"black\"/></defs>',\n                '<use href=\"#bg\"/>',\n                '<g transform=\"translate(65, 980) rotate(-90)\">',\n                    '<text class=\"txt large italic\">Latent Works</text>',\n                '</g>',\n                '<g transform=\"translate(537, 21) rotate(90)\">',\n                    '<text class=\"txt large italic\">LTNT #',Strings.toString(id_),'</text>',\n                '</g>',\n                '<g transform=\"translate(517, 22) rotate(90)\">',\n                    '<text class=\"txt small\">Issued by ',issuer_info_.name,unicode' Â· ', Strings.toString(stamp_count_) , stamp_count_ > 1 ? ' stamps' : ' stamp', '</text>',\n                '</g>'\n                '<g transform=\"translate(25, 25)\">',\n                    '<image width=\"300\" href=\"', issuer_info_.image, '\"/>',\n                '</g>',\n                '<g transform=\"translate(343, 41)\">',\n                    stamps_svg_,\n                '</g>',\n                '<g transform=\"translate(509, 980)\">',\n                    '<text class=\"txt small\">latent.works</text>',\n                '</g>',\n            '</svg>'\n        );\n\n        if(encode_)\n            image_ = abi.encodePacked('data:image/svg+xml;base64,', Base64.encode(image_));\n\n        return string(image_);\n\n    }\n\n\n    /// @notice return base64 encoded JSON metadata for id_\n    /// @param id_ the id of the LTNT to retrieve the image for\n    /// @param encode_ encode output as base64 uri\n    /// @return string the image string\n    function getJSON(uint id_, bool encode_) public view returns(string memory) {\n        \n        LTNT.Issuer memory issuer_for_id_ = _ltnt.getIssuerFor(id_);\n        LTNT.IssuerInfo memory issuer_info_ = LTNTIssuer(issuer_for_id_.location).issuerInfo(id_, issuer_for_id_.param);\n\n        bytes memory json_ = abi.encodePacked(\n            '{',\n                '\"name\":\"LTNT #',Strings.toString(id_),'\", ',\n                '\"image\": \"', getImage(id_, true),'\", ',\n                '\"description\": \"latent.works\",',\n                '\"attributes\": [',\n                    '{\"trait_type\": \"Stamps\", \"value\": ',Strings.toString(_ltnt.getStamps(id_).length),'},',\n                    '{\"trait_type\": \"Issuer\", \"value\": \"', issuer_info_.name, '\"}',\n                ']',\n            '}'\n        );\n\n        if(encode_)\n            json_ = abi.encodePacked('data:application/json;base64,', Base64.encode(json_));\n        \n        return string(json_);\n\n    }\n\n\n}\n\n\n/// @title LTNTIssuer\n/// @author troels_a\n/// @dev LTNTIssuers implement this contract and use issuerInfo to pass info to LTNT main contract\nabstract contract LTNTIssuer {\n    function issuerInfo(uint id_, LTNT.Param memory param_) external virtual view returns(LTNT.IssuerInfo memory);\n}"
9     },
10     "sol/lib/Rando.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nlibrary Rando {\n\n    function number(string memory seed, uint min, uint max) internal pure returns (uint) {\n      if (max <= min) return min;\n        return (uint256(keccak256(abi.encodePacked(seed))) % (max - min)) + min;\n    }\n\n}"
12     },
13     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
15     },
16     "sol/LTNTFont.sol": {
17       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\ncontract XanhMonoRegularLatin {\n    function fontFace() public pure returns(string memory){\n        return \"@font-face { font-family: 'Xanh Mono'; font-style: normal; font-weight: 400; font-display: swap; src: url(data:font/woff2;base64,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) format('woff2'); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD; }\";\n    }\n}\n\ncontract XanhMonoItalicLatin {\n    function fontFace() public pure returns(string memory){\n        return \"@font-face { font-family: 'Xanh Mono'; font-style: italic; font-weight: 400; font-display: swap; src: url(data:font/woff2;base64,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) format('woff2'); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD; }\";\n    }\n}"
18     },
19     "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
21     },
22     "base64-sol/base64.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
24     },
25     "@openzeppelin/contracts/access/Ownable.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
27     },
28     "@openzeppelin/contracts/utils/Address.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
30     },
31     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
33     },
34     "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
36     },
37     "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
39     },
40     "@openzeppelin/contracts/utils/Strings.sol": {
41       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
42     },
43     "@openzeppelin/contracts/utils/Context.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
45     },
46     "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
47       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
48     },
49     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
50       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
51     }
52   },
53   "settings": {
54     "optimizer": {
55       "enabled": false,
56       "runs": 200
57     },
58     "outputSelection": {
59       "*": {
60         "*": [
61           "evm.bytecode",
62           "evm.deployedBytecode",
63           "devdoc",
64           "userdoc",
65           "metadata",
66           "abi"
67         ]
68       }
69     },
70     "libraries": {}
71   }
72 }}