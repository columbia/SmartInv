1 {{
2   "language": "Solidity",
3   "sources": {
4     "/contracts/ERC20TokenGovernedProxy.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n\n// Copyright 2023 Energi Core\n\n// Energi Governance system is the fundamental part of Energi Core.\n\n// NOTE: It's not allowed to change the compiler due to byte-to-byte\n// match requirement.\n\npragma solidity 0.5.16;\n\nimport { NonReentrant } from './NonReentrant.sol';\n\nimport { SafeMath } from './libraries/SafeMath.sol';\n\nimport { IERC20TokenGovernedProxy } from './interfaces/IERC20TokenGovernedProxy.sol';\nimport { IGovernedContract } from './interfaces/IGovernedContract.sol';\nimport { IGovernedProxy } from './interfaces/IGovernedProxy.sol';\nimport { IUpgradeProposal } from './interfaces/IUpgradeProposal.sol';\nimport { ISporkRegistry } from './interfaces/ISporkRegistry.sol';\nimport { IGovernedERC20 } from './interfaces/IGovernedERC20.sol';\nimport { IOwnedERC20 } from './interfaces/IOwnedERC20.sol';\nimport { IERC20Token } from './interfaces/IERC20Token.sol';\n\n/**\n * SC-9: This contract has no chance of being updated. It must be stupid simple.\n *\n * If another upgrade logic is required in the future - it can be done as proxy stage II.\n */\ncontract ERC20TokenGovernedProxy is IERC20TokenGovernedProxy, IGovernedProxy, NonReentrant {\n    using SafeMath for uint256;\n\n    IGovernedContract public impl;\n    IGovernedContract public implementation; // only used for block explorers to detect contract as a proxy\n\n    IGovernedProxy public spork_proxy;\n\n    mapping(address => IGovernedContract) public upgrade_proposals;\n\n    IUpgradeProposal[] public upgrade_proposal_list;\n\n    modifier senderOrigin() {\n        // Internal calls are expected to use impl directly.\n        // That's due to use of call() instead of delegatecall() on purpose.\n        // solium-disable-next-line security/no-tx-origin\n        require(tx.origin == msg.sender, 'Only direct calls are allowed!');\n        _;\n    }\n\n    modifier onlyImpl() {\n        require(msg.sender == address(impl), 'Only calls from impl are allowed!');\n        _;\n    }\n\n    constructor(IGovernedContract _impl) public {\n        impl = _impl;\n        implementation = _impl; // to allow block explorers to find the impl contract\n    }\n\n    function setSporkProxy(address payable _sporkProxy) external onlyImpl {\n        spork_proxy = IGovernedProxy(_sporkProxy);\n    }\n\n    function emitAirdropRewardsClaimed(\n        address recipient,\n        uint256 claimAmountAirdrop,\n        uint256 claimAmountReferral1,\n        uint256 claimAmountReferral2,\n        uint256 claimAmountReferral3,\n        bytes4 airdropId,\n        uint256 lastClaimNonce,\n        uint256 claimNonce,\n        bytes calldata airdropServiceSignature\n    ) external onlyImpl {\n        emit AirdropRewardsClaimed(\n            recipient,\n            claimAmountAirdrop,\n            claimAmountReferral1,\n            claimAmountReferral2,\n            claimAmountReferral3,\n            airdropId,\n            lastClaimNonce,\n            claimNonce,\n            airdropServiceSignature\n        );\n    }\n\n    function emitTransfer(\n        address from,\n        address to,\n        uint256 value\n    ) external onlyImpl {\n        emit Transfer(from, to, value);\n    }\n\n    function emitApproval(\n        address owner,\n        address spender,\n        uint256 value\n    ) external onlyImpl {\n        emit Approval(owner, spender, value);\n    }\n\n    // ERC20 standard functions\n    //\n    function name() external view returns (string memory _name) {\n        _name = IERC20Token(address(uint160(address(impl)))).name();\n    }\n\n    function symbol() external view returns (string memory _symbol) {\n        _symbol = IERC20Token(address(uint160(address(impl)))).symbol();\n    }\n\n    function decimals() external view returns (uint256 _decimals) {\n        _decimals = IERC20Token(address(uint160(address(impl)))).decimals();\n    }\n\n    function balanceOf(address account) external view returns (uint256 _balance) {\n        _balance = IGovernedERC20(address(uint160(address(impl)))).balanceOf(account);\n    }\n\n    function allowance(address owner, address spender) external view returns (uint256 _allowance) {\n        _allowance = IGovernedERC20(address(uint160(address(impl)))).allowance(owner, spender);\n    }\n\n    function totalSupply() external view returns (uint256 _totalSupply) {\n        _totalSupply = IGovernedERC20(address(uint160(address(impl)))).totalSupply();\n    }\n\n    function approve(address spender, uint256 value) external returns (bool result) {\n        result = IGovernedERC20(address(uint160(address(impl)))).approve(\n            msg.sender,\n            spender,\n            value\n        );\n        emit Approval(msg.sender, spender, value);\n    }\n\n    function transfer(address to, uint256 value) external returns (bool result) {\n        result = IGovernedERC20(address(uint160(address(impl)))).transfer(msg.sender, to, value);\n        emit Transfer(msg.sender, to, value);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool result) {\n        result = IGovernedERC20(address(uint160(address(impl)))).transferFrom(\n            msg.sender,\n            from,\n            to,\n            value\n        );\n        emit Transfer(from, to, value);\n        uint256 newApproveAmount = IGovernedERC20(address(uint160(address(impl)))).allowance(\n            from,\n            msg.sender\n        );\n        emit Approval(from, msg.sender, newApproveAmount);\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool result) {\n        result = IGovernedERC20(address(uint160(address(impl)))).increaseAllowance(\n            msg.sender,\n            spender,\n            addedValue\n        );\n        uint256 newApproveAmount = IGovernedERC20(address(uint160(address(impl)))).allowance(\n            msg.sender,\n            spender\n        );\n        emit Approval(msg.sender, spender, newApproveAmount);\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        external\n        returns (bool result)\n    {\n        result = IGovernedERC20(address(uint160(address(impl)))).decreaseAllowance(\n            msg.sender,\n            spender,\n            subtractedValue\n        );\n        uint256 newApproveAmount = IGovernedERC20(address(uint160(address(impl)))).allowance(\n            msg.sender,\n            spender\n        );\n        emit Approval(msg.sender, spender, newApproveAmount);\n    }\n\n    // OwnedERC20 functions\n    //\n    function mint(address recipient, uint256 amount) external {\n        IOwnedERC20(address(uint160(address(impl)))).mint(recipient, amount);\n    }\n\n    function burn(address recipient, uint256 amount) external {\n        IOwnedERC20(address(uint160(address(impl)))).burn(recipient, amount);\n    }\n\n    // Governance functions\n    //\n    /**\n     * Pre-create a new contract first.\n     * Then propose upgrade based on that.\n     */\n    function proposeUpgrade(IGovernedContract _newImpl, uint256 _period)\n        external\n        payable\n        senderOrigin\n        noReentry\n        returns (IUpgradeProposal)\n    {\n        require(_newImpl != impl, 'Already active!');\n        require(_newImpl.proxy() == address(this), 'Wrong proxy!');\n\n        ISporkRegistry spork_reg = ISporkRegistry(address(spork_proxy.impl()));\n        IUpgradeProposal proposal = spork_reg.createUpgradeProposal.value(msg.value)(\n            _newImpl,\n            _period,\n            msg.sender\n        );\n\n        upgrade_proposals[address(proposal)] = _newImpl;\n        upgrade_proposal_list.push(proposal);\n\n        emit UpgradeProposal(_newImpl, proposal);\n\n        return proposal;\n    }\n\n    /**\n     * Once proposal is accepted, anyone can activate that.\n     */\n    function upgrade(IUpgradeProposal _proposal) external noReentry {\n        IGovernedContract new_impl = upgrade_proposals[address(_proposal)];\n        require(new_impl != impl, 'Already active!'); // in case it changes in the flight\n        require(address(new_impl) != address(0), 'Not registered!');\n        require(_proposal.isAccepted(), 'Not accepted!');\n\n        IGovernedContract old_impl = impl;\n\n        new_impl.migrate(old_impl);\n        impl = new_impl;\n        implementation = new_impl;\n        old_impl.destroy(new_impl);\n\n        // SECURITY: prevent downgrade attack\n        _cleanupProposal(_proposal);\n\n        // Return fee ASAP\n        _proposal.destroy();\n\n        emit Upgraded(new_impl, _proposal);\n    }\n\n    /**\n     * Map proposal to implementation\n     */\n    function upgradeProposalImpl(IUpgradeProposal _proposal)\n        external\n        view\n        returns (IGovernedContract new_impl)\n    {\n        new_impl = upgrade_proposals[address(_proposal)];\n    }\n\n    /**\n     * Lists all available upgrades\n     */\n    function listUpgradeProposals() external view returns (IUpgradeProposal[] memory proposals) {\n        uint256 len = upgrade_proposal_list.length;\n        proposals = new IUpgradeProposal[](len);\n\n        for (uint256 i = 0; i < len; ++i) {\n            proposals[i] = upgrade_proposal_list[i];\n        }\n\n        return proposals;\n    }\n\n    /**\n     * Once proposal is reject, anyone can start collect procedure.\n     */\n    function collectUpgradeProposal(IUpgradeProposal _proposal) external noReentry {\n        IGovernedContract new_impl = upgrade_proposals[address(_proposal)];\n        require(address(new_impl) != address(0), 'Not registered!');\n        _proposal.collect();\n        delete upgrade_proposals[address(_proposal)];\n\n        _cleanupProposal(_proposal);\n    }\n\n    function _cleanupProposal(IUpgradeProposal _proposal) internal {\n        delete upgrade_proposals[address(_proposal)];\n\n        uint256 len = upgrade_proposal_list.length;\n        for (uint256 i = 0; i < len; ++i) {\n            if (upgrade_proposal_list[i] == _proposal) {\n                upgrade_proposal_list[i] = upgrade_proposal_list[len - 1];\n                upgrade_proposal_list.pop();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Related to above\n     */\n    function proxy() external view returns (address) {\n        return address(this);\n    }\n\n    /**\n     * SECURITY: prevent on-behalf-of calls\n     */\n    function transferFrom(\n        address,\n        address,\n        address,\n        uint256\n    ) external pure {\n        revert('Good try');\n    }\n\n    /**\n     * SECURITY: prevent on-behalf-of calls\n     */\n    function increaseAllowance(\n        address,\n        address,\n        uint256\n    ) external pure {\n        revert('Good try');\n    }\n\n    /**\n     * SECURITY: prevent on-behalf-of calls\n     */\n    function decreaseAllowance(\n        address,\n        address,\n        uint256\n    ) external pure {\n        revert('Good try');\n    }\n\n    /**\n     * SECURITY: prevent on-behalf-of calls\n     */\n    function transfer(\n        address,\n        address,\n        uint256\n    ) external pure {\n        revert('Good try');\n    }\n\n    /**\n     * SECURITY: prevent on-behalf-of calls\n     */\n    function approve(\n        address,\n        address,\n        uint256\n    ) external pure {\n        revert('Good try');\n    }\n\n    /**\n     * SECURITY: prevent on-behalf-of calls\n     */\n    function migrate(IGovernedContract) external pure {\n        revert('Good try');\n    }\n\n    /**\n     * SECURITY: prevent on-behalf-of calls\n     */\n    function destroy(IGovernedContract) external pure {\n        revert('Good try');\n    }\n\n    /**\n     * Proxy all other calls to implementation.\n     */\n    function() external payable senderOrigin {\n        // SECURITY: senderOrigin() modifier is mandatory\n\n        // A dummy delegatecall opcode in the fallback function is necessary for\n        // block explorers to pick up the Energi proxy-implementation pattern\n        if (false) {\n            (bool success, bytes memory data) = address(0).delegatecall(\n                abi.encodeWithSignature('')\n            );\n            require(\n                success && !success && data.length == 0 && data.length != 0,\n                'ERC20TokenGovernedProxy: delegatecall cannot be used'\n            );\n        }\n\n        IGovernedContract impl_m = impl;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize)\n\n            let res := call(sub(gas, 10000), impl_m, callvalue, ptr, calldatasize, 0, 0)\n            // NOTE: returndatasize should allow repeatable calls\n            //       what should save one opcode.\n            returndatacopy(ptr, 0, returndatasize)\n\n            switch res\n            case 0 {\n                revert(ptr, returndatasize)\n            }\n            default {\n                return(ptr, returndatasize)\n            }\n        }\n    }\n}\n"
6     },
7     "/contracts/libraries/SafeMath.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\n// Copyright 2023 Energi Core\n\npragma solidity 0.5.16;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, 'SafeMath: addition overflow');\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, 'SafeMath: subtraction overflow');\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, 'SafeMath: multiplication overflow');\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, 'SafeMath: division by zero');\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, 'SafeMath: modulo by zero');\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
9     },
10     "/contracts/interfaces/IUpgradeProposal.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\n// Copyright 2023 Energi Core\n\n// Energi Governance system is the fundamental part of Energi Core.\n\n// NOTE: It's not allowed to change the compiler due to byte-to-byte\n// match requirement.\n\npragma solidity 0.5.16;\n\nimport { IProposal } from './IProposal.sol';\nimport { IGovernedContract } from './IGovernedContract.sol';\n\ncontract IUpgradeProposal is IProposal {\n    function impl() external view returns (IGovernedContract);\n}\n"
12     },
13     "/contracts/interfaces/ISporkRegistry.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\n// Copyright 2023 Energi Core\n\n// Energi Governance system is the fundamental part of Energi Core.\n\n// NOTE: It's not allowed to change the compiler due to byte-to-byte\n// match requirement.\n\npragma solidity 0.5.16;\n\nimport { IGovernedContract } from './IGovernedContract.sol';\nimport { IUpgradeProposal } from './IUpgradeProposal.sol';\n\ninterface ISporkRegistry {\n    function createUpgradeProposal(\n        IGovernedContract _impl,\n        uint256 _period,\n        address payable _fee_payer\n    ) external payable returns (IUpgradeProposal);\n\n    function consensusGasLimits() external view returns (uint256 callGas, uint256 xferGas);\n}\n"
15     },
16     "/contracts/interfaces/IProposal.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\n// Copyright 2023 Energi Core\n\n// Energi Governance system is the fundamental part of Energi Core.\n\n// NOTE: It's not allowed to change the compiler due to byte-to-byte\n// match requirement.\n\npragma solidity 0.5.16;\n\ninterface IProposal {\n    function parent() external view returns (address);\n\n    function created_block() external view returns (uint256);\n\n    function deadline() external view returns (uint256);\n\n    function fee_payer() external view returns (address payable);\n\n    function fee_amount() external view returns (uint256);\n\n    function accepted_weight() external view returns (uint256);\n\n    function rejected_weight() external view returns (uint256);\n\n    function total_weight() external view returns (uint256);\n\n    function quorum_weight() external view returns (uint256);\n\n    function isFinished() external view returns (bool);\n\n    function isAccepted() external view returns (bool);\n\n    function withdraw() external;\n\n    function destroy() external;\n\n    function collect() external;\n\n    function voteAccept() external;\n\n    function voteReject() external;\n\n    function setFee() external payable;\n\n    function canVote(address owner) external view returns (bool);\n}\n"
18     },
19     "/contracts/interfaces/IOwnedERC20.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\n// Copyright 2023 Energi Core\n\npragma solidity 0.5.16;\n\ninterface IOwnedERC20 {\n    function owner() external view returns (address _owner);\n\n    function setOwner(address _owner) external;\n\n    function mint(address recipient, uint256 amount) external;\n\n    function burn(address recipient, uint256 amount) external;\n}\n"
21     },
22     "/contracts/interfaces/IGovernedProxy.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\n// Copyright 2023 Energi Core\n\n// Energi Governance system is the fundamental part of Energi Core.\n\n// NOTE: It's not allowed to change the compiler due to byte-to-byte\n// match requirement.\n\npragma solidity 0.5.16;\n\nimport { IGovernedContract } from './IGovernedContract.sol';\nimport { IUpgradeProposal } from './IUpgradeProposal.sol';\n\ninterface IGovernedProxy {\n    event UpgradeProposal(IGovernedContract indexed impl, IUpgradeProposal proposal);\n\n    event Upgraded(IGovernedContract indexed impl, IUpgradeProposal proposal);\n\n    function impl() external view returns (IGovernedContract);\n\n    function proposeUpgrade(IGovernedContract _newImpl, uint256 _period)\n        external\n        payable\n        returns (IUpgradeProposal);\n\n    function upgrade(IUpgradeProposal _proposal) external;\n\n    function upgradeProposalImpl(IUpgradeProposal _proposal)\n        external\n        view\n        returns (IGovernedContract new_impl);\n\n    function listUpgradeProposals() external view returns (IUpgradeProposal[] memory proposals);\n\n    function collectUpgradeProposal(IUpgradeProposal _proposal) external;\n\n    function() external payable;\n}\n"
24     },
25     "/contracts/interfaces/IGovernedERC20.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n\n// Copyright 2023 Energi Core\n\npragma solidity 0.5.16;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IGovernedERC20 {\n    function erc20Storage() external view returns (address _erc20Storage);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n\n    function transferFrom(\n        address spender,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function increaseAllowance(\n        address sender,\n        address spender,\n        uint256 addedValue\n    ) external returns (bool);\n\n    function decreaseAllowance(\n        address sender,\n        address spender,\n        uint256 subtractedValue\n    ) external returns (bool);\n}\n"
27     },
28     "/contracts/interfaces/IGovernedContract.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n\n// Copyright 2023 Energi Core\n\n// Energi Governance system is the fundamental part of Energi Core.\n\n// NOTE: It's not allowed to change the compiler due to byte-to-byte\n// match requirement.\n\npragma solidity 0.5.16;\n\n/**\n * Genesis version of GovernedContract interface.\n *\n * Base Consensus interface for upgradable contracts.\n * Unlike common approach, the implementation is NOT expected to be\n * called through delegatecall() to minimize risks of shared storage.\n *\n * NOTE: it MUST NOT change after blockchain launch!\n */\n\ninterface IGovernedContract {\n    // Return actual proxy address for secure validation\n    function proxy() external view returns (address);\n\n    // It must check that the caller is the proxy\n    // and copy all required data from the old address.\n    function migrate(IGovernedContract _oldImpl) external;\n\n    // It must check that the caller is the proxy\n    // and self destruct to the new address.\n    function destroy(IGovernedContract _newImpl) external;\n\n    // function () external payable; // This line (from original Energi IGovernedContract) is commented because it\n    // makes truffle migrations fail\n}\n"
30     },
31     "/contracts/interfaces/IERC20TokenGovernedProxy.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n\n// Copyright 2023 Energi Core\n\npragma solidity 0.5.16;\n\ninterface IERC20TokenGovernedProxy {\n    event AirdropRewardsClaimed(\n        address indexed recipient,\n        uint256 claimAmountAirdrop,\n        uint256 claimAmountReferral1,\n        uint256 claimAmountReferral2,\n        uint256 claimAmountReferral3,\n        bytes4 airdropId,\n        uint256 lastClaimNonce,\n        uint256 claimNonce,\n        bytes airdropServiceSignature\n    );\n\n    // ERC20 events\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function setSporkProxy(address payable _sporkProxy) external;\n\n    function emitAirdropRewardsClaimed(\n        address recipient,\n        uint256 claimAmountAirdrop,\n        uint256 claimAmountReferral1,\n        uint256 claimAmountReferral2,\n        uint256 claimAmountReferral3,\n        bytes4 airdropId,\n        uint256 lastClaimNonce,\n        uint256 claimNonce,\n        bytes calldata airdropServiceSignature\n    ) external;\n\n    function emitTransfer(\n        address from,\n        address to,\n        uint256 value\n    ) external;\n\n    // ERC20 standard interface\n    function name() external view returns (string memory _name);\n\n    function symbol() external view returns (string memory _symbol);\n\n    function decimals() external view returns (uint256 _decimals);\n\n    function balanceOf(address account) external view returns (uint256 _balance);\n\n    function allowance(address owner, address spender) external view returns (uint256 _allowance);\n\n    function totalSupply() external view returns (uint256 _totalSupply);\n\n    function approve(address spender, uint256 value) external returns (bool result);\n\n    function transfer(address to, uint256 value) external returns (bool result);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool result);\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool result);\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        external\n        returns (bool result);\n}\n"
33     },
34     "/contracts/interfaces/IERC20Token.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n\n// Copyright 2023 Energi Core\n\npragma solidity 0.5.16;\n\ninterface IERC20Token {\n    function eRC20TokenStorage() external view returns (address _eRC20TokenStorage);\n\n    function name() external view returns (string memory _name);\n\n    function symbol() external view returns (string memory _symbol);\n\n    function decimals() external view returns (uint8 _decimals);\n\n    function getAirdropService() external view returns (address _airdropService);\n\n    function getAirdropLastClaimNonce(bytes4 airdropId, address _user)\n        external\n        view\n        returns (uint256 _lastClaimNonce);\n\n    // Setter functions\n    //\n    function setName(string calldata _name) external;\n\n    function setSymbol(string calldata _symbol) external;\n\n    function setDecimals(uint8 _decimals) external;\n\n    function setAirdropService(address _airdropService) external;\n\n    function setERC721ManagerProxy(address _eRC721ManagerProxy) external;\n\n    // Mint/burn functions\n    //\n    function mint(address recipient, uint256 amount) external;\n\n    function burn(address account, uint256 amount) external;\n\n    // ERC20 airdrop and airdrop referral rewards claim function\n    function claimAirdrop(\n        uint256 claimAmountAirdrop,\n        uint256 claimAmountReferral1,\n        uint256 claimAmountReferral2,\n        uint256 claimAmountReferral3,\n        bytes4 airdropId,\n        uint256 lastClaimNonce,\n        uint256 claimNonce,\n        bytes calldata airdropServiceSignature\n    ) external;\n}\n"
36     },
37     "/contracts/NonReentrant.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n\n// Copyright 2023 Energi Core\n\npragma solidity 0.5.16;\n\n/**\n * A little helper to protect contract from being re-entrant in state\n * modifying functions.\n */\n\ncontract NonReentrant {\n    uint256 private entry_guard;\n\n    modifier noReentry() {\n        require(entry_guard == 0, 'Reentry');\n        entry_guard = 1;\n        _;\n        entry_guard = 0;\n    }\n}\n"
39     }
40   },
41   "settings": {
42     "remappings": [],
43     "optimizer": {
44       "enabled": true,
45       "runs": 200
46     },
47     "evmVersion": "istanbul",
48     "libraries": {},
49     "outputSelection": {
50       "*": {
51         "*": [
52           "evm.bytecode",
53           "evm.deployedBytecode",
54           "devdoc",
55           "userdoc",
56           "metadata",
57           "abi"
58         ]
59       }
60     }
61   }
62 }}