1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/yam.sol": {
5       "content": "pragma solidity >= 0.5.0 < 0.6.0;\r\n\r\nimport \"./TokenInfoLib.sol\";\r\nimport \"./SymbolsLib.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./SignedSafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./SavingAccountParameters.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"./ABDK.sol\";\r\nimport \"./tokenbasic.sol\";\r\nimport \"./bkk.sol\";\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ninterface AllPool{\r\n    function is_Re(address user) view external  returns(bool);\r\n    // function set_user_isRe(address user,address pool,string calldata name) external;\r\n    function get_Address_pool(address user) view external  returns(address);\r\n}\r\n\r\ninterface IPlayerBook {\r\n    function settleReward( address from,uint256 amount ) external returns (uint256);\r\n}\r\ncontract SavingAccount is Ownable{\r\n\tusing TokenInfoLib for TokenInfoLib.TokenInfo;\r\n\tusing SymbolsLib for SymbolsLib.Symbols;\r\n\tusing SafeMath for uint256;\r\n\tusing SignedSafeMath for int256;\r\n\tusing SafeERC20 for IERC20;\r\n\r\n\t\r\n\tevent depositTokened(address onwer,uint256 amount,address tokenaddress);\r\n\tevent withdrawed(address onwer,uint256 amount,address tokenaddress);\r\n\tevent RewardAdded(uint256 reward);\r\n    event RewardPaid(address indexed user, uint256 reward);\r\n    \r\n    \r\n\tbool _hasStart = false;\r\n\tuint256 public _initReward = 0;\r\n\t\r\n\tIERC20 public _pros = IERC20(0x306Dd7CD66d964f598B4D2ec92b5a9B275D7fEb3);\r\n    address public _teamWallet = 0x89941E92E414c88179a830af5c10bde0E9245158;\r\n\taddress public _playbook = 0x21A4086a6Cdb332c851B76cccD21aCAB6428D9E4;\r\n\taddress public _allpool = 0xC682bD99eE552B6f7d931aFee2A9425806e155E9;\r\n\t\r\n\r\n\taddress public _ETH = 0x000000000000000000000000000000000000000E;\r\n\taddress public _USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n\taddress public _PROS = 0x306Dd7CD66d964f598B4D2ec92b5a9B275D7fEb3;\r\n\tuint256 DURATION = 1 days;\r\n\t\r\n    int128 dayNums = 0;\r\n\r\n    int128 baseReward = 80000;\r\n    \r\n    uint256 public base_ = 20*10e3;\r\n    uint256 public rate_forReward = 1;\r\n    uint256 public base_Rate_Reward = 100;\r\n\r\n\tstruct Account {\r\n\t\tmapping(address => TokenInfoLib.TokenInfo) tokenInfos;\r\n\t\tbool active;\r\n\t}\r\n// \tint256 public totalReward;\r\n\tmapping(address => Account) accounts;\r\n\tmapping(address => int256) totalDeposits;\r\n\tmapping(address => int256) totalLoans;\r\n\tmapping(address => int256) totalCollateral;\r\n    mapping(address => bool) loansAccount;\r\n\taddress[] activeAccounts;\r\n\taddress[] activeLoansAccount;\r\n\r\n    mapping(address => uint256)_initTokenReward;\r\n    uint256 public _startTime =  now + 365 days;\r\n    uint256 public _periodFinish = 0;\r\n    uint256 public _rewardRate = 0;\r\n    \r\n    mapping(address =>uint256) public _rewardRateList;\r\n    // uint256 public _lastUpdateTime;\r\n    mapping(address=>uint256) public _lastUpdateTime;\r\n    // uint256 public _rewardPerTokenStored;\r\n    mapping(address=>uint256) public _rewardPerTokenStored;\r\n    uint256 public _teamRewardRate = 0;\r\n    uint256 public _poolRewardRate = 0;\r\n    uint256 public _baseRate = 10000;\r\n    uint256 public _punishTime = 10 days;\r\n    \r\n    uint256 public one_Rate = 90;\r\n    uint256 public sec_Rate = 5;\r\n    uint256 public thr_Rate = 5;\r\n    uint256 public BASE_RATE_FORREWARD = 100;\r\n    \r\n    \r\n    mapping(address => mapping(address=>uint256)) public _userRewardPerTokenPaid;\r\n    mapping(address => mapping(address=>uint256)) public _rewards;\r\n    mapping(address => mapping(address=>uint256)) public _lastStakedTime;\r\n\tSymbolsLib.Symbols symbols;\r\n\tint256 constant BASE = 10**6;\r\n\tint BORROW_LTV = 66; //TODO check is this 60%?\r\n\tint LIQUIDATE_THREADHOLD = 85;\r\n\r\n\tconstructor() public {\r\n\t\tSavingAccountParameters params = new SavingAccountParameters();\r\n\t\taddress[] memory tokenAddresses = params.getTokenAddresses();\r\n\t\t//TODO This needs improvement as it could go out of gas\r\n\t\tsymbols.initialize(params.ratesURL(), params.tokenNames(), tokenAddresses);\r\n\t\t\r\n\t}\r\n\r\n\r\n\tfunction setprosToken(IERC20 token) public onlyOwner{\r\n\t    _pros = token;\r\n\t} \r\n\tfunction setAllpool(address pool)public onlyOwner {\r\n\t    _allpool = pool;\r\n\t}\r\n\t \r\n\tfunction setTeamToken(address tokenaddress) public onlyOwner{\r\n\t    _teamWallet = tokenaddress;\r\n\t}\r\n\t \r\n\tfunction set_tokens(address eth,address usdt,address pros) public onlyOwner{\r\n\t    _ETH = eth;\r\n\t    _USDT = usdt;\r\n\t    _PROS = pros;\r\n\t}\r\n\t \r\n\tfunction setPlaybook(address playbook) public onlyOwner{\r\n\t    _playbook = playbook;\r\n\t}\r\n\t\r\n\tfunction setRate_Reward(uint256 one,uint256 sec,uint256 thr,uint256 total)public onlyOwner{\r\n\t    one_Rate = one;\r\n\t    sec_Rate = sec;\r\n\t    thr_Rate = thr;\r\n\t    BASE_RATE_FORREWARD = total;\r\n\t}\r\n\t\r\n\tfunction() external payable {}\r\n\t\r\n\tfunction getAccountTotalUsdValue(address accountAddr) public view returns (int256 usdValue) {\r\n\t\treturn getAccountTotalUsdValue(accountAddr, true).add(getAccountTotalUsdValue(accountAddr, false));\r\n\t}\r\n\r\n\tfunction getAccountTotalUsdValue(address accountAddr, bool isPositive) private view returns (int256 usdValue){\r\n\t\tint256 totalUsdValue = 0;\r\n\t\tfor(uint i = 0; i < getCoinLength(); i++) {\r\n\t\t\tif (isPositive && accounts[accountAddr].tokenInfos[symbols.addressFromIndex(i)].totalAmount(block.timestamp) >= 0) {\r\n\t\t\t\ttotalUsdValue = totalUsdValue.add(\r\n\t\t\t\t\taccounts[accountAddr].tokenInfos[symbols.addressFromIndex(i)].totalAmount(block.timestamp)\r\n\t\t\t\t\t.mul(int256(symbols.priceFromIndex(i)))\r\n\t\t\t\t\t.div(BASE)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tif (!isPositive && accounts[accountAddr].tokenInfos[symbols.addressFromIndex(i)].totalAmount(block.timestamp) < 0) {\r\n\t\t\t\ttotalUsdValue = totalUsdValue.add(\r\n\t\t\t\t\taccounts[accountAddr].tokenInfos[symbols.addressFromIndex(i)].totalAmount(block.timestamp)\r\n\t\t\t\t\t.mul(int256(symbols.priceFromIndex(i)))\r\n\t\t\t\t\t.div(BASE)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn totalUsdValue;\r\n\t}\r\n\t\r\n\t\r\n\t\t\r\n\tfunction rewardPerToken(address tokenID) public view returns (uint256) { //to change to the address thing for dip problem \r\n        if (totalDeposits[tokenID] == 0) { //totalPower change ----- totaldipost[token] \r\n            return _rewardPerTokenStored[tokenID];\r\n        }\r\n        return\r\n            _rewardPerTokenStored[tokenID].add(\r\n                lastTimeRewardApplicable() \r\n                    .sub(_lastUpdateTime[tokenID])\r\n                    .mul(_rewardRateList[tokenID]) //change for the _rewardRate[token]\r\n                    .mul(1e18)\r\n                    .div(uint256(totalDeposits[tokenID])) //change for the totalPower[token] ---- \r\n            );\r\n    }\r\n    \r\n    \r\n    function lastTimeRewardApplicable() public view returns (uint256) {\r\n        return Math.min(block.timestamp, _periodFinish);\r\n    }\r\n    \r\n    \r\n    function earned(address account,address tokenID) public view returns (uint256) {\r\n        return\r\n            uint256(tokenBalanceOf(tokenID,account))\r\n                .mul(rewardPerToken(tokenID).sub(_userRewardPerTokenPaid[tokenID][account]))\r\n                .div(1e18)\r\n                .add(_rewards[tokenID][account]); //one token\r\n    }\r\n\t\r\n\t\r\n\tfunction earned(address account) public view returns (uint256) {\r\n        uint coinsLen = getCoinLength();\r\n        uint256 Total;\r\n        for (uint i = 0; i < coinsLen; i++) {\r\n\t\t\taddress tokenAddress = symbols.addressFromIndex(i);\r\n\t\t\tTotal = Total.add(earned(account,tokenAddress));\r\n\t\t}\r\n\t\treturn Total;\r\n    }\r\n\t\r\n\t\r\n    modifier checkHalve() {\r\n        if (block.timestamp >= _periodFinish) {\r\n            update_initreward();\r\n            _pros.mint(address(this), _initReward);\r\n            _rewardRate = _initReward.div(DURATION*3);\r\n            _rewardRateList[address(_PROS)] = _initReward.mul(one_Rate).div(DURATION*BASE_RATE_FORREWARD);\r\n            _rewardRateList[address(_USDT)] = _initReward.mul(sec_Rate).div(DURATION*BASE_RATE_FORREWARD);\r\n            _rewardRateList[address(_ETH)] = _initReward.mul(thr_Rate).div(DURATION*BASE_RATE_FORREWARD);\r\n            _periodFinish = block.timestamp.add(DURATION);\r\n        }\r\n        _;\r\n    }\r\n    \r\n    modifier checkStart() {\r\n        require(block.timestamp > _startTime, \"not start\");\r\n        _;\r\n    }\r\n    \r\n\tmodifier updateReward(address account,address tokenID) {\r\n        _rewardPerTokenStored[tokenID] = rewardPerToken(tokenID);\r\n        _lastUpdateTime[tokenID] = lastTimeRewardApplicable();\r\n        if (account != address(0)) {\r\n            _rewards[tokenID][account] = earned(account,tokenID);\r\n            _userRewardPerTokenPaid[tokenID][account] = _rewardPerTokenStored[tokenID];\r\n        }\r\n        _;\r\n    } \r\n    \r\n    modifier isRegister(){\r\n        require(AllPool(_allpool).is_Re(msg.sender)==true,\"address not register or name already register\");\r\n        _;\r\n    }\r\n   \r\n    \r\n    modifier updateRewardAll(address account) {\r\n        uint coinsLen = getCoinLength();\r\n        address[] memory tokens = new address[](coinsLen);\r\n        \r\n        for (uint i = 0; i < coinsLen; i++) {\r\n\t\t\taddress tokenAddress = symbols.addressFromIndex(i);\r\n\t\t\ttokens[i] = tokenAddress;\r\n\t\t}\r\n        for(uint i=0;i<3;i++){\r\n            address tokenID = tokens[i];\r\n            _rewardPerTokenStored[tokenID] = rewardPerToken(tokenID);\r\n            _lastUpdateTime[tokenID] = lastTimeRewardApplicable();\r\n            if (account != address(0)) {\r\n            _rewards[tokenID][account] = earned(account,tokenID);\r\n            _userRewardPerTokenPaid[tokenID][account] = _rewardPerTokenStored[tokenID];\r\n        }\r\n        }\r\n        _;\r\n    }\r\n\t\r\n\t\r\n\t/** \r\n\t * Get the overall state of the saving pool\r\n\t */\r\n\tfunction getMarketState() public view returns (address[] memory addresses,\r\n\t\tint256[] memory deposits\r\n\t\t)\r\n\t{\r\n\t\tuint coinsLen = getCoinLength();\r\n\r\n\t\taddresses = new address[](coinsLen);\r\n\t\tdeposits = new int256[](coinsLen);\r\n\r\n\r\n\t\tfor (uint i = 0; i < coinsLen; i++) {\r\n\t\t\taddress tokenAddress = symbols.addressFromIndex(i);\r\n\t\t\taddresses[i] = tokenAddress;\r\n\t\t\tdeposits[i] = totalDeposits[tokenAddress];\r\n\t\t}\r\n\r\n\t\treturn (addresses, deposits);\r\n\t}\r\n\r\n\t/*\r\n\t * Get the state of the given token\r\n\t */\r\n\tfunction getTokenState(address tokenAddress) public view returns (int256 deposits, int256 loans, int256 collateral)\r\n\t{\r\n\t\treturn (totalDeposits[tokenAddress], totalLoans[tokenAddress], totalCollateral[tokenAddress]);\r\n\t}\r\n\r\n\t/** \r\n\t * Get all balances for the sender's account\r\n\t */\r\n\t\r\n\tfunction getBalances() public view returns (address[] memory addresses, int256[] memory balances)\r\n\t{\r\n\t\tuint coinsLen = getCoinLength();\r\n\r\n\t\taddresses = new address[](coinsLen);\r\n\t\tbalances = new int256[](coinsLen);\r\n\r\n\t\tfor (uint i = 0; i < coinsLen; i++) {\r\n\t\t\taddress tokenAddress = symbols.addressFromIndex(i);\r\n\t\t\taddresses[i] = tokenAddress;\r\n\t\t\tbalances[i] = tokenBalanceOf(tokenAddress);\r\n\t\t}\r\n\r\n\t\treturn (addresses, balances);\r\n\t}\r\n\r\n\tfunction getActiveAccounts() public view returns (address[] memory) {\r\n\t\treturn activeAccounts;\r\n\t}\r\n    \r\n    function tokenBalanceOf(address tokenAddress,address account) public view returns (int256 amount) {\r\n\t\treturn accounts[account].tokenInfos[tokenAddress].totalAmount(block.timestamp);\r\n\t}\r\n\r\n\tfunction getCoinLength() public view returns (uint256 length){\r\n\t\treturn symbols.getCoinLength();\r\n\t}\r\n\r\n\tfunction tokenBalanceOf(address tokenAddress) public view returns (int256 amount) {\r\n\t\treturn accounts[msg.sender].tokenInfos[tokenAddress].totalAmount(block.timestamp);\r\n\t}\r\n\r\n\tfunction getCoinAddress(uint256 coinIndex) public view returns (address) {\r\n\t\treturn symbols.addressFromIndex(coinIndex);\r\n\t}\r\n\r\n\t/** \r\n\t * Deposit the amount of tokenAddress to the saving pool. \r\n\t */\r\n\t\r\n\tfunction depositToken(address tokenAddress, uint256 amount) updateReward(msg.sender,tokenAddress) checkHalve checkStart isRegister public payable {\r\n\t\tTokenInfoLib.TokenInfo storage tokenInfo = accounts[msg.sender].tokenInfos[tokenAddress];\r\n\t\tif (!accounts[msg.sender].active) {\r\n\t\t\taccounts[msg.sender].active = true;\r\n\t\t\tactiveAccounts.push(msg.sender);\r\n\t\t}\r\n        \r\n\t\tint256 currentBalance = tokenInfo.getCurrentTotalAmount();\r\n\r\n\t\trequire(currentBalance >= 0,\r\n\t\t\t\"Balance of the token must be zero or positive. To pay negative balance, please use repay button.\");\r\n        uint256 LastRatio = 0;\r\n        \r\n\t\t// deposited amount is new balance after addAmount minus previous balance\r\n\t\tint256 depositedAmount = tokenInfo.addAmount(amount, LastRatio, block.timestamp) - currentBalance;\r\n\t\ttotalDeposits[tokenAddress] = totalDeposits[tokenAddress].add(depositedAmount);\r\n        emit depositTokened(msg.sender,amount,tokenAddress);\r\n\t\treceive(msg.sender, amount, amount,tokenAddress);\r\n\t}\r\n\t\r\n\t\r\n\r\n\t/**\r\n\t * Withdraw tokens from saving pool. If the interest is not empty, the interest\r\n\t * will be deducted first.\r\n\t */\r\n\t \r\n\tfunction withdrawToken(address tokenAddress, uint256 amount) updateReward(msg.sender,tokenAddress) checkStart checkHalve public payable {\r\n\t\trequire(accounts[msg.sender].active, \"Account not active, please deposit first.\");\r\n\t\tTokenInfoLib.TokenInfo storage tokenInfo = accounts[msg.sender].tokenInfos[tokenAddress];\r\n\r\n\t\trequire(tokenInfo.totalAmount(block.timestamp) >= int256(amount), \"Insufficient balance.\");\r\n  \t\trequire(int256(getAccountTotalUsdValue(msg.sender, false).mul(-1)).mul(100) <= (getAccountTotalUsdValue(msg.sender, true) - int256(amount.mul(symbols.priceFromAddress(tokenAddress)).div(uint256(BASE)))).mul(BORROW_LTV));\r\n        \r\n        emit withdrawed(msg.sender,amount,tokenAddress);\r\n\t\ttokenInfo.minusAmount(amount, 0, block.timestamp);\r\n\t\ttotalDeposits[tokenAddress] = totalDeposits[tokenAddress].sub(int256(amount));\r\n\t\ttotalCollateral[tokenAddress] = totalCollateral[tokenAddress].sub(int256(amount));\r\n\r\n\t\tsend(msg.sender, amount, tokenAddress);\t\t\r\n\t}\r\n\r\n\r\n\r\n\tfunction receive(address from, uint256 amount, uint256 amounttwo,address tokenAddress) private {\r\n\t\tif (symbols.isEth(tokenAddress)) {\r\n            require(msg.value >= amounttwo, \"The amount is not sent from address.\");\r\n            msg.sender.transfer(msg.value-amounttwo);\r\n\t\t} else {\r\n\t\t\trequire(msg.value >= 0, \"msg.value must be 0 when receiving tokens\");\r\n\t\t\tif(tokenAddress!=_USDT ){\r\n\t\t\t    require(IERC20(tokenAddress).transferFrom(from, address(this), amount));\r\n\t\t\t}else{\r\n\t\t\t    basic(tokenAddress).transferFrom(from,address(this),amount);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\r\n\r\n\tfunction send(address to, uint256 amount, address tokenAddress) private {\r\n\t\tif (symbols.isEth(tokenAddress)) {\r\n\t\t\tmsg.sender.transfer(amount);\r\n\t\t} else {\r\n\t\t    if(tokenAddress!=_USDT){\r\n\t\t\t    require(IERC20(tokenAddress).transfer(to, amount));\r\n\t\t\t}else{\r\n\t\t\t    basic(tokenAddress).transfer(to, amount);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n    function getReward() public updateRewardAll(msg.sender) checkHalve checkStart {\r\n        \r\n        uint256 reward;\r\n        uint coinsLen = getCoinLength();\r\n        address[] memory tokens = new address[](coinsLen);\r\n        \r\n        for (uint i = 0; i < coinsLen; i++) {\r\n\t\t\taddress tokenAddress = symbols.addressFromIndex(i);\r\n\t\t\ttokens[i] = tokenAddress;\r\n\t\t\treward = reward.add(earned(msg.sender,tokens[i]));\r\n\t\t}\r\n        if (reward > 0) {\r\n            _rewards[tokens[0]][msg.sender] = 0;\r\n            _rewards[tokens[1]][msg.sender] = 0;\r\n            _rewards[tokens[2]][msg.sender] = 0;\r\n            \r\n            address set_play = AllPool(_allpool).get_Address_pool(msg.sender)==0x0000000000000000000000000000000000000000?_playbook:AllPool(_allpool).get_Address_pool(msg.sender);\r\n            uint256 fee = IPlayerBook(set_play).settleReward(msg.sender,reward);\r\n            if(fee>0){\r\n                _pros.safeTransfer(set_play,fee);\r\n            }\r\n            \r\n            uint256 teamReward = reward.mul(_teamRewardRate).div(_baseRate);\r\n            if(teamReward>0){\r\n                _pros.safeTransfer(_teamWallet, teamReward);\r\n            }\r\n            uint256 leftReward = reward.sub(fee).sub(teamReward);\r\n            uint256 poolReward = 0;\r\n            if(leftReward>0){\r\n                _pros.safeTransfer(msg.sender, leftReward);\r\n            }\r\n            emit RewardPaid(msg.sender,reward);\r\n        }\r\n        \r\n        \r\n    }\r\n \r\n   \r\n\t\r\n\r\n\t\r\n\tfunction update_initreward() private {\r\n\t    dayNums = dayNums + 1;\r\n        uint256 thisreward = base_.mul(rate_forReward).mul(10**18).mul((base_Rate_Reward.sub(rate_forReward))**(uint256(dayNums-1))).div(base_Rate_Reward**(uint256(dayNums)));\r\n\t    _initReward = uint256(thisreward);\r\n\t}\r\n\t\r\n\t\r\n\r\n    // set fix time to start reward\r\n    function startReward(uint256 startTime)\r\n        external\r\n        onlyOwner\r\n        updateReward(address(0),address(_ETH))\r\n    {\r\n        require(_hasStart == false, \"has started\");\r\n        _hasStart = true;\r\n        _startTime = startTime;\r\n        update_initreward();\r\n        _rewardRate = _initReward.div(DURATION*3); \r\n        _rewardRateList[address(_PROS)] = _initReward.mul(one_Rate).div(DURATION*BASE_RATE_FORREWARD);\r\n        _rewardRateList[address(_USDT)] = _initReward.mul(sec_Rate).div(DURATION*BASE_RATE_FORREWARD);\r\n        _rewardRateList[address(_ETH)] = _initReward.mul(thr_Rate).div(DURATION*BASE_RATE_FORREWARD);\r\n        _pros.mint(address(this), _initReward);\r\n        _lastUpdateTime[address(_ETH)] = _startTime;\r\n        _lastUpdateTime[address(_USDT)] = _startTime;\r\n        _lastUpdateTime[address(_PROS)] = _startTime; //for get the chushihua state\r\n        _periodFinish = _startTime.add(DURATION);\r\n\r\n        emit RewardAdded(_initReward);\r\n    }    \r\n}"
6     },
7     "contracts/TokenInfoLib.sol": {
8       "content": "pragma solidity >= 0.5.0 < 0.6.0;\r\n\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./SignedSafeMath.sol\";\r\nlibrary TokenInfoLib {\r\n    using SafeMath for uint256;\r\n\tusing SignedSafeMath for int256;\r\n    struct TokenInfo {\r\n\t\tint256 balance;\r\n\t\tint256 interest;\r\n\t\tuint256 rate;\r\n\t\tuint256 lastModification;\r\n\t}\r\n\tuint256 constant BASE = 10**12; // TODO: 12 vs 18?\r\n\tint256 constant POSITIVE = 1;\r\n\tint256 constant NEGATIVE = -1;\r\n\r\n\t// returns the sum of balance, interest posted to the account, and any additional intereset accrued up to the given timestamp\r\n\tfunction totalAmount(TokenInfo storage self, uint256 currentTimestamp) public view returns(int256) {\r\n\t\treturn self.balance.add(viewInterest(self, currentTimestamp));\r\n\t\t//用户总余额不再取决于出块时间差 \r\n\t\t//return self.balance;\r\n\t}\r\n\tfunction totalnumber(TokenInfo storage self)public view returns(int256){\r\n\t    return self.balance;\r\n\t}\r\n\r\n\t// returns the sum of balance and interest posted to the account\r\n\tfunction getCurrentTotalAmount(TokenInfo storage self) public view returns(int256) {\r\n\t\treturn self.balance.add(self.interest);\r\n\t}\r\n\t\r\n\tfunction getInterest(TokenInfo storage self,uint256 currentTimestamp)public view returns(int256){\r\n\t    return viewInterest(self, currentTimestamp);\r\n\t}\r\n\r\n\tfunction minusAmount(TokenInfo storage self, uint256 amount, uint256 rate, uint256 currentTimestamp) public {\r\n\t\tresetInterest(self, currentTimestamp);\r\n        int256 _amount = int256(amount);\r\n\t\tif (self.balance + self.interest > 0) {\r\n\t\t\tif (self.interest >= _amount) {\r\n\t\t\t\tself.interest = self.interest.sub(_amount);\r\n\t\t\t\t_amount = 0;\r\n\t\t\t} else if (self.balance.add(self.interest) >= _amount){\r\n\t\t\t\tself.balance = self.balance.sub(_amount.sub(self.interest));\r\n\t\t\t\tself.interest = 0;\r\n\t\t\t\t_amount = 0;\r\n\t\t\t} else {\r\n                _amount = _amount.sub(self.balance.add(self.interest));\r\n\t\t\t\tself.balance = 0;\r\n\t\t\t\tself.interest = 0;\r\n\t\t\t\tself.rate = 0;\r\n\t\t\t}\r\n\t\t}\r\n        if (_amount > 0) {\r\n\t\t\trequire(self.balance.add(self.interest) <= 0, \"To minus amount, the total balance must be smaller than 0.\");\r\n\t\t\tself.rate = mixRate(self, _amount, rate);\r\n\t\t\tself.balance = self.balance.sub(_amount);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction addAmount(TokenInfo storage self, uint256 amount, uint256 rate, uint256 currentTimestamp) public returns(int256) {\r\n\t\tresetInterest(self, currentTimestamp);\r\n\t\tint256 _amount = int256(amount);\r\n\t\tif (self.balance.add(self.interest) < 0) {\r\n            if (self.interest.add(_amount) <= 0) {\r\n                self.interest = self.interest.add(_amount);\r\n\t\t\t\t_amount = 0;\r\n\t\t\t} else if (self.balance.add(self.interest).add(_amount) <= 0) {\r\n\t\t\t\tself.balance = self.balance.add(_amount.add(self.interest));\r\n\t\t\t\tself.interest = 0;\r\n\t\t\t\t_amount = 0;\r\n\t\t\t} else {\r\n                _amount = _amount.add(self.balance.add(self.interest));\r\n\t\t\t\tself.balance = 0;\r\n                self.interest = 0;\r\n                self.rate = 0;\r\n\t\t\t}\r\n\t\t}\r\n        if (_amount > 0) {\r\n\t\t\trequire(self.balance.add(self.interest) >= 0, \"To add amount, the total balance must be larger than 0.\");\r\n\t\t\tself.rate = mixRate(self, _amount, rate);\r\n\t\t\tself.balance = self.balance.add(_amount);\r\n\t\t}\r\n\r\n\t\treturn totalAmount(self, currentTimestamp);\r\n\t}\r\n\r\n\tfunction mixRate(TokenInfo storage self, int256 amount, uint256 rate) private view returns (uint256){\r\n\t\t//TODO uint256(-self.balance) this will integer underflow - Critical Security risk\r\n\t\t//TODO Why do we need this???\r\n        uint256 _balance = self.balance >= 0 ? uint256(self.balance) : uint256(-self.balance);\r\n\t\tuint256 _amount = amount >= 0 ? uint256(amount) : uint256(-amount);\r\n\t\treturn _balance.mul(self.rate).add(_amount.mul(rate)).div(_balance + _amount);\r\n\t}\r\n\r\n\tfunction resetInterest(TokenInfo storage self, uint256 currentTimestamp) public {\r\n\t\tself.interest = viewInterest(self, currentTimestamp);\r\n\t\tself.lastModification = currentTimestamp;\r\n\t}\r\n\r\n\tfunction viewInterest(TokenInfo storage self, uint256 currentTimestamp) public view returns(int256) {\r\n        int256 _sign = self.balance < 0 ? NEGATIVE : POSITIVE;\r\n\t\t//TODO uint256(-amount) ???\r\n\t\tuint256 _balance = self.balance >= 0 ? uint256(self.balance) : uint256(-self.balance);\r\n\t\tuint256 _difference = currentTimestamp.sub(self.lastModification);\r\n\r\n\t\treturn self.interest\r\n\t\t\t.add(int256(_balance.mul(self.rate).mul(_difference).div(BASE)))\r\n\t\t\t.mul(_sign);\r\n\t}\r\n}"
9     },
10     "contracts/SymbolsLib.sol": {
11       "content": "pragma solidity >= 0.5.0 < 0.6.0;\r\nimport \"./SafeMath.sol\";\r\nimport \"./strings.sol\";\r\nlibrary SymbolsLib {\r\n    using SafeMath for uint256;\r\n\r\n\tstruct Symbols {\r\n\t\tuint count;\r\n\t\tmapping(uint => string) indexToSymbol;\r\n\t\tmapping(string => uint256) symbolToPrices; \r\n\t\tmapping(address => string) addressToSymbol; \r\n\t\tmapping(string => address) symbolToAddress;\r\n\t\tstring ratesURL;\r\n\t}\r\n\r\n\t/** \r\n\t *  initializes the symbols structure\r\n\t */\r\n\tfunction initialize(Symbols storage self, string memory ratesURL, string memory tokenNames, address[] memory tokenAddresses) public {\r\n\t\tstrings.slice memory delim = strings.toSlice(\",\");\r\n\t\tstrings.slice memory tokensList = strings.toSlice(tokenNames);\r\n\r\n\t\tself.count = strings.count(tokensList, delim) + 1;\r\n\t\trequire(self.count == tokenAddresses.length);\r\n\r\n\t\tself.ratesURL = ratesURL;\r\n\r\n\t\tfor(uint i = 0; i < self.count; i++) {\r\n\t\t\tstrings.slice memory token;\r\n\t\t\tstrings.split(tokensList, delim, token);\r\n\r\n\t\t \taddress tokenAddress = tokenAddresses[i];\r\n\t\t \tstring memory tokenName = strings.toString(token);\r\n\r\n\t\t \tself.indexToSymbol[i] = tokenName;\r\n\t\t \tself.addressToSymbol[tokenAddress] = tokenName;\r\n\t\t \tself.symbolToAddress[tokenName]  = tokenAddress;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getCoinLength(Symbols storage self) public view returns (uint length){ \r\n\t\treturn self.count; \r\n\t} \r\n\r\n\tfunction addressFromIndex(Symbols storage self, uint index) public view returns(address) {\r\n\t\trequire(index < self.count, \"coinIndex must be smaller than the coins length.\");\r\n\t\treturn self.symbolToAddress[self.indexToSymbol[index]];\r\n\t} \r\n\r\n\tfunction priceFromIndex(Symbols storage self, uint index) public view returns(uint256) {\r\n\t\trequire(index < self.count, \"coinIndex must be smaller than the coins length.\");\r\n\t\treturn self.symbolToPrices[self.indexToSymbol[index]];\r\n\t} \r\n\r\n\tfunction priceFromAddress(Symbols storage self, address tokenAddress) public view returns(uint256) {\r\n\t\treturn self.symbolToPrices[self.addressToSymbol[tokenAddress]];\r\n\t} \r\n\r\n\tfunction setPrice(Symbols storage self, uint index, uint256 price) public { \r\n\t\trequire(index < self.count, \"coinIndex must be smaller than the coins length.\");\r\n\t\tself.symbolToPrices[self.indexToSymbol[index]] = price;\r\n\t}\r\n\r\n\tfunction isEth(Symbols storage self, address tokenAddress) public view returns(bool) {\r\n\t\treturn self.symbolToAddress[\"ETH\"] == tokenAddress;\r\n\t}\r\n\r\n\t/** \r\n\t * Parse result from oracle, e.g. an example is [8110.44, 0.2189, 445.05, 1]. \r\n\t * The function will remove the '[' and ']' and split the string by ','. \r\n\t */\r\n\tfunction parseRates(Symbols storage self, string memory result,uint256 who) internal {\r\n\t\tstrings.slice memory delim = strings.toSlice(\",\");\r\n\t\tstrings.slice memory startChar = strings.toSlice(\"[\");\r\n\t\tstrings.slice memory endChar = strings.toSlice(\"]\");\r\n\t\tstrings.slice memory substring = strings.until(strings.beyond(strings.toSlice(result), startChar), endChar);\r\n\t\tuint count = strings.count(substring, delim) + 1;\r\n\t\t//ok \r\n\t\t\r\n\t\tfor(uint i = (who-1)*3; i < (who-1)*3+3; i++) {\r\n\t\t\tstrings.slice memory token;\r\n\t\t\tstrings.split(substring, delim, token);\r\n\t\t\tsetPrice(self, i, stringToUint(strings.toString(token)));\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction parseRatesbyself(Symbols storage self, string memory result) internal {\r\n\t\tstrings.slice memory delim = strings.toSlice(\",\");\r\n\t\tstrings.slice memory startChar = strings.toSlice(\"[\");\r\n\t\tstrings.slice memory endChar = strings.toSlice(\"]\");\r\n\t\tstrings.slice memory substring = strings.until(strings.beyond(strings.toSlice(result), startChar), endChar);\r\n\t\tuint count = strings.count(substring, delim) + 1;\r\n\t\t//ok \r\n\t\t\r\n\t\tfor(uint i = 0; i < count; i++) {\r\n\t\t\tstrings.slice memory token;\r\n\t\t\tstrings.split(substring, delim, token);\r\n\t\t\tsetPrice(self, i, stringToUint(strings.toString(token)));\r\n\t\t}\r\n\t}\r\n\r\n\t/** \r\n\t *  Helper function to convert string to number\r\n\t */\r\n\tfunction stringToUint(string memory numString) private pure returns(uint256 number) {\r\n\t\tbytes memory numBytes = bytes(numString);\r\n\t\tbool isFloat = false;\r\n\t\tuint times = 6;\r\n\t\tnumber = 0;\r\n\t\tfor(uint256 i = 0; i < numBytes.length; i ++) {\r\n\t\t\tif (numBytes[i] >= '0' && numBytes[i] <= '9' && times > 0) {\r\n\t\t\t\tnumber *= 10;\r\n\t\t\t\tnumber = number + uint8(numBytes[i]) - 48;\r\n\t\t\t\tif (isFloat) {\r\n\t\t\t\t\ttimes --;\r\n\t\t\t\t}\r\n\t\t\t} else if (numBytes[i] == '.') {\r\n\t\t\t\tisFloat = true;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile (times > 0) {\r\n\t\t\tnumber *= 10;\r\n\t\t\ttimes --;\r\n\t\t}\r\n\t\treturn number;\r\n\t}\r\n}"
12     },
13     "contracts/SafeMath.sol": {
14       "content": "// pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"
15     },
16     "contracts/SignedSafeMath.sol": {
17       "content": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Multiplies two signed integers, reverts on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(!(b == -1 && a == INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two signed integers, reverts on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two signed integers, reverts on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}"
18     },
19     "contracts/Ownable.sol": {
20       "content": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\n import \"./Context.sol\";\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}"
21     },
22     "contracts/SavingAccountParameters.sol": {
23       "content": "pragma solidity >= 0.5.0 < 0.6.0;\r\n\r\ncontract SavingAccountParameters {\r\n    string public ratesURL;\r\n\tstring public tokenNames;\r\n    address[] public tokenAddresses;\r\n\r\n    constructor() public payable{\r\n      tokenNames = \"ETH,USDT,PROS\";\r\n\t  tokenAddresses = new address[](3);\r\n\t  tokenAddresses[0] = 0x000000000000000000000000000000000000000E; \r\n      tokenAddresses[1] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; \r\n      tokenAddresses[2] = 0x306Dd7CD66d964f598B4D2ec92b5a9B275D7fEb3;//usdt //change address for test\r\n\t}\r\n\r\n\tfunction getTokenAddresses() public view returns(address[] memory){\r\n        return tokenAddresses;\r\n    }\r\n}"
24     },
25     "contracts/IERC20.sol": {
26       "content": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n    function mint(address account, uint amount) external;\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    \r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
27     },
28     "contracts/ABDK.sol": {
29       "content": "/*\r\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\npragma solidity ^0.5.0 || ^0.6.0;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n  /**\r\n   * Minimum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n  /**\r\n   * Maximum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n//   function fromInt (int256 x) internal pure returns (int128) {\r\n//     require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\r\n//     return int128 (x << 64);\r\n//   }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n   * rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64-bit integer number\r\n   */\r\n  function toInt (int128 x) internal pure returns (int64) {\r\n    return int64 (x >> 64);\r\n  }\r\n\r\n  /**\r\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n//   function fromUInt (uint256 x) internal pure returns (int128) {\r\n//     require (x <= 0x7FFFFFFFFFFFFFFF);\r\n//     return int128 (x << 64);\r\n//   }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n   * number rounding down.  Revert on underflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return unsigned 64-bit integer number\r\n   */\r\n//   function toUInt (int128 x) internal pure returns (uint64) {\r\n//     require (x >= 0);\r\n//     return uint64 (x >> 64);\r\n//   }\r\n\r\n//   /**\r\n//   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n//   * number rounding down.  Revert on overflow.\r\n//   *\r\n//   * @param x signed 128.128-bin fixed point number\r\n//   * @return signed 64.64-bit fixed point number\r\n//   */\r\n//   function from128x128 (int256 x) internal pure returns (int128) {\r\n//     int256 result = x >> 64;\r\n//     require (result >= MIN_64x64 && result <= MAX_64x64);\r\n//     return int128 (result);\r\n//   }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n   * number.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 128.128 fixed point number\r\n   */\r\n  function to128x128 (int128 x) internal pure returns (int256) {\r\n    return int256 (x) << 64;\r\n  }\r\n\r\n  /**\r\n   * Calculate x + y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function add (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) + y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x - y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sub (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) - y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function mul (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) * y >> 64;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n   * number and y is signed 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 256-bit integer number\r\n   */\r\n  function muli (int128 x, int256 y) internal pure returns (int256) {\r\n    if (x == MIN_64x64) {\r\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\r\n        y <= 0x1000000000000000000000000000000000000000000000000);\r\n      return -y << 63;\r\n    } else {\r\n      bool negativeResult = false;\r\n      if (x < 0) {\r\n        x = -x;\r\n        negativeResult = true;\r\n      }\r\n      if (y < 0) {\r\n        y = -y; // We rely on overflow behavior here\r\n        negativeResult = !negativeResult;\r\n      }\r\n      uint256 absoluteResult = mulu (x, uint256 (y));\r\n      if (negativeResult) {\r\n        require (absoluteResult <=\r\n          0x8000000000000000000000000000000000000000000000000000000000000000);\r\n        return -int256 (absoluteResult); // We rely on overflow behavior here\r\n      } else {\r\n        require (absoluteResult <=\r\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return int256 (absoluteResult);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\r\n    if (y == 0) return 0;\r\n\r\n    require (x >= 0);\r\n\r\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\r\n    uint256 hi = uint256 (x) * (y >> 128);\r\n\r\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    hi <<= 64;\r\n\r\n    require (hi <=\r\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n    return hi + lo;\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function div (int128 x, int128 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    int256 result = (int256 (x) << 64) / y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divi (int256 x, int256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n\r\n    bool negativeResult = false;\r\n    if (x < 0) {\r\n      x = -x; // We rely on overflow behavior here\r\n      negativeResult = true;\r\n    }\r\n    if (y < 0) {\r\n      y = -y; // We rely on overflow behavior here\r\n      negativeResult = !negativeResult;\r\n    }\r\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\r\n    if (negativeResult) {\r\n      require (absoluteResult <= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    uint128 result = divuu (x, y);\r\n    require (result <= uint128 (MAX_64x64));\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate -x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function neg (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return -x;\r\n  }\r\n\r\n  /**\r\n   * Calculate |x|.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function abs (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return x < 0 ? -x : x;\r\n  }\r\n\r\n  /**\r\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n//   function inv (int128 x) internal pure returns (int128) {\r\n//     require (x != 0);\r\n//     int256 result = int256 (0x100000000000000000000000000000000) / x;\r\n//     require (result >= MIN_64x64 && result <= MAX_64x64);\r\n//     return int128 (result);\r\n//   }\r\n\r\n//   /**\r\n//   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n//   *\r\n//   * @param x signed 64.64-bit fixed point number\r\n//   * @param y signed 64.64-bit fixed point number\r\n//   * @return signed 64.64-bit fixed point number\r\n//   */\r\n//   function avg (int128 x, int128 y) internal pure returns (int128) {\r\n//     return int128 ((int256 (x) + int256 (y)) >> 1);\r\n//   }\r\n\r\n//   /**\r\n//   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n//   * Revert on overflow or in case x * y is negative.\r\n//   *\r\n//   * @param x signed 64.64-bit fixed point number\r\n//   * @param y signed 64.64-bit fixed point number\r\n//   * @return signed 64.64-bit fixed point number\r\n//   */\r\n//   function gavg (int128 x, int128 y) internal pure returns (int128) {\r\n//     int256 m = int256 (x) * int256 (y);\r\n//     require (m >= 0);\r\n//     require (m <\r\n//         0x4000000000000000000000000000000000000000000000000000000000000000);\r\n//     return int128 (sqrtu (uint256 (m), uint256 (x) + uint256 (y) >> 1));\r\n//   }\r\n\r\n//   /**\r\n//   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n//   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n//   *\r\n//   * @param x signed 64.64-bit fixed point number\r\n//   * @param y uint256 value\r\n//   * @return signed 64.64-bit fixed point number\r\n//   */\r\n//   function pow (int128 x, uint256 y) internal pure returns (int128) {\r\n//     uint256 absoluteResult;\r\n//     bool negativeResult = false;\r\n//     if (x >= 0) {\r\n//       absoluteResult = powu (uint256 (x) << 63, y);\r\n//     } else {\r\n//       // We rely on overflow behavior here\r\n//       absoluteResult = powu (uint256 (uint128 (-x)) << 63, y);\r\n//       negativeResult = y & 1 > 0;\r\n//     }\r\n\r\n//     absoluteResult >>= 63;\r\n\r\n//     if (negativeResult) {\r\n//       require (absoluteResult <= 0x80000000000000000000000000000000);\r\n//       return -int128 (absoluteResult); // We rely on overflow behavior here\r\n//     } else {\r\n//       require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n//       return int128 (absoluteResult); // We rely on overflow behavior here\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//   * Calculate sqrt (x) rounding down.  Revert if x < 0.\r\n//   *\r\n//   * @param x signed 64.64-bit fixed point number\r\n//   * @return signed 64.64-bit fixed point number\r\n//   */\r\n//   function sqrt (int128 x) internal pure returns (int128) {\r\n//     require (x >= 0);\r\n//     return int128 (sqrtu (uint256 (x) << 64, 0x10000000000000000));\r\n//   }\r\n\r\n//   /**\r\n//   * Calculate binary logarithm of x.  Revert if x <= 0.\r\n//   *\r\n//   * @param x signed 64.64-bit fixed point number\r\n//   * @return signed 64.64-bit fixed point number\r\n//   */\r\n//   function log_2 (int128 x) internal pure returns (int128) {\r\n//     require (x > 0);\r\n\r\n//     int256 msb = 0;\r\n//     int256 xc = x;\r\n//     if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n//     if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n//     if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n//     if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n//     if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n//     if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n//     if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n//     int256 result = msb - 64 << 64;\r\n//     uint256 ux = uint256 (x) << 127 - msb;\r\n//     for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n//       ux *= ux;\r\n//       uint256 b = ux >> 255;\r\n//       ux >>= 127 + b;\r\n//       result += bit * int256 (b);\r\n//     }\r\n\r\n//     return int128 (result);\r\n//   }\r\n\r\n//   /**\r\n//   * Calculate natural logarithm of x.  Revert if x <= 0.\r\n//   *\r\n//   * @param x signed 64.64-bit fixed point number\r\n//   * @return signed 64.64-bit fixed point number\r\n//   */\r\n//   function ln (int128 x) internal pure returns (int128) {\r\n//     require (x > 0);\r\n\r\n//     return int128 (\r\n//         uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\r\n//   }\r\n\r\n  /**\r\n   * Calculate binary exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp_2 (int128 x) internal pure returns (int128) {\r\n    require (x < 0x400000000000000000); // Overflow\r\n\r\n    if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n    uint256 result = 0x80000000000000000000000000000000;\r\n\r\n    if (x & 0x8000000000000000 > 0)\r\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\r\n    if (x & 0x4000000000000000 > 0)\r\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\r\n    if (x & 0x2000000000000000 > 0)\r\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\r\n    if (x & 0x1000000000000000 > 0)\r\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\r\n    if (x & 0x800000000000000 > 0)\r\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\r\n    if (x & 0x400000000000000 > 0)\r\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\r\n    if (x & 0x200000000000000 > 0)\r\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\r\n    if (x & 0x100000000000000 > 0)\r\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\r\n    if (x & 0x80000000000000 > 0)\r\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\r\n    if (x & 0x40000000000000 > 0)\r\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\r\n    if (x & 0x20000000000000 > 0)\r\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\r\n    if (x & 0x10000000000000 > 0)\r\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\r\n    if (x & 0x8000000000000 > 0)\r\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\r\n    if (x & 0x4000000000000 > 0)\r\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\r\n    if (x & 0x2000000000000 > 0)\r\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\r\n    if (x & 0x1000000000000 > 0)\r\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\r\n    if (x & 0x800000000000 > 0)\r\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\r\n    if (x & 0x400000000000 > 0)\r\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\r\n    if (x & 0x200000000000 > 0)\r\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\r\n    if (x & 0x100000000000 > 0)\r\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\r\n    if (x & 0x80000000000 > 0)\r\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\r\n    if (x & 0x40000000000 > 0)\r\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\r\n    if (x & 0x20000000000 > 0)\r\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\r\n    if (x & 0x10000000000 > 0)\r\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\r\n    if (x & 0x8000000000 > 0)\r\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\r\n    if (x & 0x4000000000 > 0)\r\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\r\n    if (x & 0x2000000000 > 0)\r\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\r\n    if (x & 0x1000000000 > 0)\r\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\r\n    if (x & 0x800000000 > 0)\r\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\r\n    if (x & 0x400000000 > 0)\r\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\r\n    if (x & 0x200000000 > 0)\r\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\r\n    if (x & 0x100000000 > 0)\r\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\r\n    if (x & 0x80000000 > 0)\r\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\r\n    if (x & 0x40000000 > 0)\r\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\r\n    if (x & 0x20000000 > 0)\r\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\r\n    if (x & 0x10000000 > 0)\r\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\r\n    if (x & 0x8000000 > 0)\r\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\r\n    if (x & 0x4000000 > 0)\r\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\r\n    if (x & 0x2000000 > 0)\r\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\r\n    if (x & 0x1000000 > 0)\r\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\r\n    if (x & 0x800000 > 0)\r\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\r\n    if (x & 0x400000 > 0)\r\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\r\n    if (x & 0x200000 > 0)\r\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\r\n    if (x & 0x100000 > 0)\r\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\r\n    if (x & 0x80000 > 0)\r\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\r\n    if (x & 0x40000 > 0)\r\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\r\n    if (x & 0x20000 > 0)\r\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\r\n    if (x & 0x10000 > 0)\r\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\r\n    if (x & 0x8000 > 0)\r\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\r\n    if (x & 0x4000 > 0)\r\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\r\n    if (x & 0x2000 > 0)\r\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\r\n    if (x & 0x1000 > 0)\r\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\r\n    if (x & 0x800 > 0)\r\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\r\n    if (x & 0x400 > 0)\r\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\r\n    if (x & 0x200 > 0)\r\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\r\n    if (x & 0x100 > 0)\r\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\r\n    if (x & 0x80 > 0)\r\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\r\n    if (x & 0x40 > 0)\r\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\r\n    if (x & 0x20 > 0)\r\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\r\n    if (x & 0x10 > 0)\r\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\r\n    if (x & 0x8 > 0)\r\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\r\n    if (x & 0x4 > 0)\r\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\r\n    if (x & 0x2 > 0)\r\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\r\n    if (x & 0x1 > 0)\r\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\r\n\r\n    result >>= 63 - (x >> 64);\r\n    require (result <= uint256 (MAX_64x64));\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp (int128 x) internal pure returns (int128) {\r\n    require (x < 0x400000000000000000); // Overflow\r\n\r\n    if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n    return exp_2 (\r\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 64.64-bit fixed point number\r\n   */\r\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\r\n    require (y != 0);\r\n\r\n    uint256 result;\r\n\r\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      result = (x << 64) / y;\r\n    else {\r\n      uint256 msb = 192;\r\n      uint256 xc = x >> 192;\r\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\r\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 hi = result * (y >> 128);\r\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 xh = x >> 192;\r\n      uint256 xl = x << 64;\r\n\r\n      if (xl < lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n      lo = hi << 128;\r\n      if (xl < lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n\r\n      assert (xh == hi >> 128);\r\n\r\n      result += xl / y;\r\n    }\r\n\r\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    return uint128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\r\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 129.127-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return unsigned 129.127-bit fixed point number\r\n   */\r\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\r\n    if (y == 0) return 0x80000000000000000000000000000000;\r\n    else if (x == 0) return 0;\r\n    else {\r\n      int256 msb = 0;\r\n      uint256 xc = x;\r\n      if (xc >= 0x100000000000000000000000000000000) { xc >>= 128; msb += 128; }\r\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      int256 xe = msb - 127;\r\n      if (xe > 0) x >>= xe;\r\n      else x <<= -xe;\r\n\r\n      uint256 result = 0x80000000000000000000000000000000;\r\n      int256 re = 0;\r\n\r\n      while (y > 0) {\r\n        if (y & 1 > 0) {\r\n          result = result * x;\r\n          y -= 1;\r\n          re += xe;\r\n          if (result >=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            result >>= 128;\r\n            re += 1;\r\n          } else result >>= 127;\r\n          if (re < -127) return 0; // Underflow\r\n          require (re < 128); // Overflow\r\n        } else {\r\n          x = x * x;\r\n          y >>= 1;\r\n          xe <<= 1;\r\n          if (x >=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            x >>= 128;\r\n            xe += 1;\r\n          } else x >>= 127;\r\n          if (xe < -127) return 0; // Underflow\r\n          require (xe < 128); // Overflow\r\n        }\r\n      }\r\n\r\n      if (re > 0) result <<= re;\r\n      else if (re < 0) result >>= -re;\r\n\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n   * number.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return unsigned 128-bit integer number\r\n   */\r\n  function sqrtu (uint256 x, uint256 r) private pure returns (uint128) {\r\n    if (x == 0) return 0;\r\n    else {\r\n      require (r > 0);\r\n      while (true) {\r\n        uint256 rr = x / r;\r\n        if (r == rr || r + 1 == rr) return uint128 (r);\r\n        else if (r == rr + 1) return uint128 (rr);\r\n        r = r + rr + 1 >> 1;\r\n      }\r\n    }\r\n  }\r\n}"
30     },
31     "contracts/tokenbasic.sol": {
32       "content": "pragma solidity ^0.5.0;\r\n\r\ninterface basic{\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function transferFrom(address from, address to, uint value) external;\r\n    function approve(address spender, uint value) external;\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address who) external view returns (uint);\r\n    function transfer(address to, uint value) external;\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}"
33     },
34     "contracts/bkk.sol": {
35       "content": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface bkk {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external ;\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
36     },
37     "contracts/strings.sol": {
38       "content": "pragma solidity >= 0.5.0 < 0.6.0;  \r\n \r\nlibrary strings {  \r\n    struct slice {  \r\n        uint _len;  \r\n        uint _ptr;  \r\n    }  \r\n \r\n    function memcpy(uint dest, uint src, uint len) private pure {  \r\n        // Copy word-length chunks while possible  \r\n        for(; len >= 32; len -= 32) {  \r\n            assembly {  \r\n                mstore(dest, mload(src))  \r\n            }  \r\n            dest += 32;  \r\n            src += 32;  \r\n        }  \r\n \r\n        // Copy remaining bytes  \r\n        uint mask = 256 ** (32 - len) - 1;  \r\n        assembly {  \r\n            let srcpart := and(mload(src), not(mask))  \r\n                let destpart := and(mload(dest), mask)  \r\n                mstore(dest, or(destpart, srcpart))  \r\n        }  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Returns a slice containing the entire string.  \r\n     * @param self The string to make a slice from.  \r\n     * @return A newly allocated slice containing the entire string.  \r\n     */  \r\n    function toSlice(string memory self) internal pure returns (slice memory) {  \r\n        uint ptr;  \r\n        assembly {  \r\nptr := add(self, 0x20)  \r\n        }  \r\n        return slice(bytes(self).length, ptr);  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Returns the length of a null-terminated bytes32 string.  \r\n     * @param self The value to find the length of.  \r\n     * @return The length of the string, from 0 to 32.  \r\n     */  \r\n    function len(bytes32 self) internal pure returns (uint) {  \r\n        uint ret;  \r\n        if (self == 0)  \r\n            return 0;  \r\n        if (uint(self) & 0xffffffffffffffffffffffffffffffff == 0) {  \r\n            ret += 16;  \r\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);  \r\n        }  \r\n        if (uint(self) & 0xffffffffffffffff == 0) {  \r\n            ret += 8;  \r\n            self = bytes32(uint(self) / 0x10000000000000000);  \r\n        }  \r\n        if (uint(self) & 0xffffffff == 0) {  \r\n            ret += 4;  \r\n            self = bytes32(uint(self) / 0x100000000);  \r\n        }  \r\n        if (uint(self) & 0xffff == 0) {  \r\n            ret += 2;  \r\n            self = bytes32(uint(self) / 0x10000);  \r\n        }  \r\n        if (uint(self) & 0xff == 0) {  \r\n            ret += 1;  \r\n        }  \r\n        return 32 - ret;  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Returns a slice containing the entire bytes32, interpreted as a  \r\n     *      null-terminated utf-8 string.  \r\n     * @param self The bytes32 value to convert to a slice.  \r\n     * @return A new slice containing the value of the input argument up to the  \r\n     *         first null.  \r\n     */  \r\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {  \r\n        // Allocate space for `self` in memory, copy it there, and point ret at it  \r\n        assembly {  \r\n            let ptr := mload(0x40)  \r\n                mstore(0x40, add(ptr, 0x20))  \r\n                mstore(ptr, self)  \r\n                mstore(add(ret, 0x20), ptr)  \r\n        }  \r\n        ret._len = len(self);  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Returns a new slice containing the same data as the current slice.  \r\n     * @param self The slice to copy.  \r\n     * @return A new slice containing the same data as `self`.  \r\n     */  \r\n    function copy(slice memory self) internal pure returns (slice memory) {  \r\n        return slice(self._len, self._ptr);  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Copies a slice to a new string.  \r\n     * @param self The slice to copy.  \r\n     * @return A newly allocated string containing the slice's text.  \r\n     */  \r\n    function toString(slice memory self) internal pure returns (string memory) {  \r\n        string memory ret = new string(self._len);  \r\n        uint retptr;  \r\n        assembly { retptr := add(ret, 32) }  \r\n \r\n        memcpy(retptr, self._ptr, self._len);  \r\n        return ret;  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Returns the length in runes of the slice. Note that this operation  \r\n     *      takes time proportional to the length of the slice; avoid using it  \r\n     *      in loops, and call `slice.empty()` if you only need to know whether  \r\n     *      the slice is empty or not.  \r\n     * @param self The slice to operate on.  \r\n     * @return The length of the slice in runes.  \r\n     */  \r\n    function len(slice memory self) internal pure returns (uint l) {  \r\n        // Starting at ptr-31 means the LSB will be the byte we care about  \r\n        uint ptr = self._ptr - 31;  \r\n        uint end = ptr + self._len;  \r\n        for (l = 0; ptr < end; l++) {  \r\n            uint8 b;  \r\n            assembly { b := and(mload(ptr), 0xFF) }  \r\n            if (b < 0x80) {  \r\n                ptr += 1;  \r\n            } else if(b < 0xE0) {  \r\n                ptr += 2;  \r\n            } else if(b < 0xF0) {  \r\n                ptr += 3;  \r\n            } else if(b < 0xF8) {  \r\n                ptr += 4;  \r\n            } else if(b < 0xFC) {  \r\n                ptr += 5;  \r\n            } else {  \r\n                ptr += 6;  \r\n            }  \r\n        }  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Returns true if the slice is empty (has a length of 0).  \r\n     * @param self The slice to operate on.  \r\n     * @return True if the slice is empty, False otherwise.  \r\n     */  \r\n    function empty(slice memory self) internal pure returns (bool) {  \r\n        return self._len == 0;  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Returns a positive number if `other` comes lexicographically after  \r\n     *      `self`, a negative number if it comes before, or zero if the  \r\n     *      contents of the two slices are equal. Comparison is done per-rune,  \r\n     *      on unicode codepoints.  \r\n     * @param self The first slice to compare.  \r\n     * @param other The second slice to compare.  \r\n     * @return The result of the comparison.  \r\n     */  \r\n    function compare(slice memory self, slice memory other) internal pure returns (int) {  \r\n        uint shortest = self._len;  \r\n        if (other._len < self._len)  \r\n            shortest = other._len;  \r\n \r\n        uint selfptr = self._ptr;  \r\n        uint otherptr = other._ptr;  \r\n        for (uint idx = 0; idx < shortest; idx += 32) {  \r\n            uint a;  \r\n            uint b;  \r\n            assembly {  \r\na := mload(selfptr)  \r\n       b := mload(otherptr)  \r\n            }  \r\n            if (a != b) {  \r\n                // Mask out irrelevant bytes and check again  \r\n                uint256 mask = uint256(-1); // 0xffff...  \r\n                if(shortest < 32) {  \r\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);  \r\n                }  \r\n                uint256 diff = (a & mask) - (b & mask);  \r\n                if (diff != 0)  \r\n                    return int(diff);  \r\n            }  \r\n            selfptr += 32;  \r\n            otherptr += 32;  \r\n        }  \r\n        return int(self._len) - int(other._len);  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Returns true if the two slices contain the same text.  \r\n     * @param self The first slice to compare.  \r\n     * @param self The second slice to compare.  \r\n     * @return True if the slices are equal, false otherwise.  \r\n     */  \r\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {  \r\n        return compare(self, other) == 0;  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Extracts the first rune in the slice into `rune`, advancing the  \r\n     *      slice to point to the next rune and returning `self`.  \r\n     * @param self The slice to operate on.  \r\n     * @param rune The slice that will contain the first rune.  \r\n     * @return `rune`.  \r\n     */  \r\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {  \r\n        rune._ptr = self._ptr;  \r\n \r\n        if (self._len == 0) {  \r\n            rune._len = 0;  \r\n            return rune;  \r\n        }  \r\n \r\n        uint l;  \r\n        uint b;  \r\n        // Load the first byte of the rune into the LSBs of b  \r\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }  \r\n        if (b < 0x80) {  \r\n            l = 1;  \r\n        } else if(b < 0xE0) {  \r\n            l = 2;  \r\n        } else if(b < 0xF0) {  \r\n            l = 3;  \r\n        } else {  \r\n            l = 4;  \r\n        }  \r\n \r\n        // Check for truncated codepoints  \r\n        if (l > self._len) {  \r\n            rune._len = self._len;  \r\n            self._ptr += self._len;  \r\n            self._len = 0;  \r\n            return rune;  \r\n        }  \r\n \r\n        self._ptr += l;  \r\n        self._len -= l;  \r\n        rune._len = l;  \r\n        return rune;  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Returns the first rune in the slice, advancing the slice to point  \r\n     *      to the next rune.  \r\n     * @param self The slice to operate on.  \r\n     * @return A slice containing only the first rune from `self`.  \r\n     */  \r\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {  \r\n        nextRune(self, ret);  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Returns the number of the first codepoint in the slice.  \r\n     * @param self The slice to operate on.  \r\n     * @return The number of the first codepoint in the slice.  \r\n     */  \r\n    function ord(slice memory self) internal pure returns (uint ret) {  \r\n        if (self._len == 0) {  \r\n            return 0;  \r\n        }  \r\n \r\n        uint word;  \r\n        uint length;  \r\n        uint divisor = 2 ** 248;  \r\n \r\n        // Load the rune into the MSBs of b  \r\n        assembly { word:= mload(mload(add(self, 32))) }  \r\n        uint b = word / divisor;  \r\n        if (b < 0x80) {  \r\n            ret = b;  \r\n            length = 1;  \r\n        } else if(b < 0xE0) {  \r\n            ret = b & 0x1F;  \r\n            length = 2;  \r\n        } else if(b < 0xF0) {  \r\n            ret = b & 0x0F;  \r\n            length = 3;  \r\n        } else {  \r\n            ret = b & 0x07;  \r\n            length = 4;  \r\n        }  \r\n \r\n        // Check for truncated codepoints  \r\n        if (length > self._len) {  \r\n            return 0;  \r\n        }  \r\n \r\n        for (uint i = 1; i < length; i++) {  \r\n            divisor = divisor / 256;  \r\n            b = (word / divisor) & 0xFF;  \r\n            if (b & 0xC0 != 0x80) {  \r\n                // Invalid UTF-8 sequence  \r\n                return 0;  \r\n            }  \r\n            ret = (ret * 64) | (b & 0x3F);  \r\n        }  \r\n \r\n        return ret;  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Returns the keccak-256 hash of the slice.  \r\n     * @param self The slice to hash.  \r\n     * @return The hash of the slice.  \r\n     */  \r\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {  \r\n        assembly {  \r\nret := keccak256(mload(add(self, 32)), mload(self))  \r\n        }  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Returns true if `self` starts with `needle`.  \r\n     * @param self The slice to operate on.  \r\n     * @param needle The slice to search for.  \r\n     * @return True if the slice starts with the provided text, false otherwise.  \r\n     */  \r\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {  \r\n        if (self._len < needle._len) {  \r\n            return false;  \r\n        }  \r\n \r\n        if (self._ptr == needle._ptr) {  \r\n            return true;  \r\n        }  \r\n \r\n        bool equal;  \r\n        assembly {  \r\n            let length := mload(needle)  \r\n                let selfptr := mload(add(self, 0x20))  \r\n                let needleptr := mload(add(needle, 0x20))  \r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))  \r\n        }  \r\n        return equal;  \r\n    }  \r\n \r\n    /*  \r\n     * @dev If `self` starts with `needle`, `needle` is removed from the  \r\n     *      beginning of `self`. Otherwise, `self` is unmodified.  \r\n     * @param self The slice to operate on.  \r\n     * @param needle The slice to search for.  \r\n     * @return `self`  \r\n     */  \r\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {  \r\n        if (self._len < needle._len) {  \r\n            return self;  \r\n        }  \r\n \r\n        bool equal = true;  \r\n        if (self._ptr != needle._ptr) {  \r\n            assembly {  \r\n                let length := mload(needle)  \r\n                    let selfptr := mload(add(self, 0x20))  \r\n                    let needleptr := mload(add(needle, 0x20))  \r\n                    equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))  \r\n            }  \r\n        }  \r\n \r\n        if (equal) {  \r\n            self._len -= needle._len;  \r\n            self._ptr += needle._len;  \r\n        }  \r\n \r\n        return self;  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Returns true if the slice ends with `needle`.  \r\n     * @param self The slice to operate on.  \r\n     * @param needle The slice to search for.  \r\n     * @return True if the slice starts with the provided text, false otherwise.  \r\n     */  \r\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {  \r\n        if (self._len < needle._len) {  \r\n            return false;  \r\n        }  \r\n \r\n        uint selfptr = self._ptr + self._len - needle._len;  \r\n \r\n        if (selfptr == needle._ptr) {  \r\n            return true;  \r\n        }  \r\n \r\n        bool equal;  \r\n        assembly {  \r\n            let length := mload(needle)  \r\n                let needleptr := mload(add(needle, 0x20))  \r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))  \r\n        }  \r\n \r\n        return equal;  \r\n    }  \r\n \r\n    /*  \r\n     * @dev If `self` ends with `needle`, `needle` is removed from the  \r\n     *      end of `self`. Otherwise, `self` is unmodified.  \r\n     * @param self The slice to operate on.  \r\n     * @param needle The slice to search for.  \r\n     * @return `self`  \r\n     */  \r\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {  \r\n        if (self._len < needle._len) {  \r\n            return self;  \r\n        }  \r\n \r\n        uint selfptr = self._ptr + self._len - needle._len;  \r\n        bool equal = true;  \r\n        if (selfptr != needle._ptr) {  \r\n            assembly {  \r\n                let length := mload(needle)  \r\n                    let needleptr := mload(add(needle, 0x20))  \r\n                    equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))  \r\n            }  \r\n        }  \r\n \r\n        if (equal) {  \r\n            self._len -= needle._len;  \r\n        }  \r\n \r\n        return self;  \r\n    }  \r\n \r\n    // Returns the memory address of the first byte of the first occurrence of  \r\n    // `needle` in `self`, or the first byte after `self` if not found.  \r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {  \r\n        uint ptr = selfptr;  \r\n        uint idx;  \r\n \r\n        if (needlelen <= selflen) {  \r\n            if (needlelen <= 32) {  \r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));  \r\n \r\n                bytes32 needledata;  \r\n                assembly { needledata := and(mload(needleptr), mask) }  \r\n \r\n                uint end = selfptr + selflen - needlelen;  \r\n                bytes32 ptrdata;  \r\n                assembly { ptrdata := and(mload(ptr), mask) }  \r\n \r\n                while (ptrdata != needledata) {  \r\n                    if (ptr >= end)  \r\n                        return selfptr + selflen;  \r\n                    ptr++;  \r\n                    assembly { ptrdata := and(mload(ptr), mask) }  \r\n                }  \r\n                return ptr;  \r\n            } else {  \r\n                // For long needles, use hashing  \r\n                bytes32 hash;  \r\n                assembly { hash := keccak256(needleptr, needlelen) }  \r\n \r\n                for (idx = 0; idx <= selflen - needlelen; idx++) {  \r\n                    bytes32 testHash;  \r\n                    assembly { testHash := keccak256(ptr, needlelen) }  \r\n                    if (hash == testHash)  \r\n                        return ptr;  \r\n                    ptr += 1;  \r\n                }  \r\n            }  \r\n        }  \r\n        return selfptr + selflen;  \r\n    }  \r\n \r\n    // Returns the memory address of the first byte after the last occurrence of  \r\n    // `needle` in `self`, or the address of `self` if not found.  \r\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {  \r\n        uint ptr;  \r\n \r\n        if (needlelen <= selflen) {  \r\n            if (needlelen <= 32) {  \r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));  \r\n \r\n                bytes32 needledata;  \r\n                assembly { needledata := and(mload(needleptr), mask) }  \r\n \r\n                ptr = selfptr + selflen - needlelen;  \r\n                bytes32 ptrdata;  \r\n                assembly { ptrdata := and(mload(ptr), mask) }  \r\n \r\n                while (ptrdata != needledata) {  \r\n                    if (ptr <= selfptr)  \r\n                        return selfptr;  \r\n                    ptr--;  \r\n                    assembly { ptrdata := and(mload(ptr), mask) }  \r\n                }  \r\n                return ptr + needlelen;  \r\n            } else {  \r\n                // For long needles, use hashing  \r\n                bytes32 hash;  \r\n                assembly { hash := keccak256(needleptr, needlelen) }  \r\n                ptr = selfptr + (selflen - needlelen);  \r\n                while (ptr >= selfptr) {  \r\n                    bytes32 testHash;  \r\n                    assembly { testHash := keccak256(ptr, needlelen) }  \r\n                    if (hash == testHash)  \r\n                        return ptr + needlelen;  \r\n                    ptr -= 1;  \r\n                }  \r\n            }  \r\n        }  \r\n        return selfptr;  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Modifies `self` to contain everything from the first occurrence of  \r\n     *      `needle` to the end of the slice. `self` is set to the empty slice  \r\n     *      if `needle` is not found.  \r\n     * @param self The slice to search and modify.  \r\n     * @param needle The text to search for.  \r\n     * @return `self`.  \r\n     */  \r\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {  \r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);  \r\n        self._len -= ptr - self._ptr;  \r\n        self._ptr = ptr;  \r\n        return self;  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Modifies `self` to contain the part of the string from the start of  \r\n     *      `self` to the end of the first occurrence of `needle`. If `needle`  \r\n     *      is not found, `self` is set to the empty slice.  \r\n     * @param self The slice to search and modify.  \r\n     * @param needle The text to search for.  \r\n     * @return `self`.  \r\n     */  \r\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {  \r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);  \r\n        self._len = ptr - self._ptr;  \r\n        return self;  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Splits the slice, setting `self` to everything after the first  \r\n     *      occurrence of `needle`, and `token` to everything before it. If  \r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,  \r\n     *      and `token` is set to the entirety of `self`.  \r\n     * @param self The slice to split.  \r\n     * @param needle The text to search for in `self`.  \r\n     * @param token An output parameter to which the first token is written.  \r\n     * @return `token`.  \r\n     */  \r\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {  \r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);  \r\n        token._ptr = self._ptr;  \r\n        token._len = ptr - self._ptr;  \r\n        if (ptr == self._ptr + self._len) {  \r\n            // Not found  \r\n            self._len = 0;  \r\n        } else {  \r\n            self._len -= token._len + needle._len;  \r\n            self._ptr = ptr + needle._len;  \r\n        }  \r\n        return token;  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Splits the slice, setting `self` to everything after the first  \r\n     *      occurrence of `needle`, and returning everything before it. If  \r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,  \r\n     *      and the entirety of `self` is returned.  \r\n     * @param self The slice to split.  \r\n     * @param needle The text to search for in `self`.  \r\n     * @return The part of `self` up to the first occurrence of `delim`.  \r\n     */  \r\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {  \r\n        split(self, needle, token);  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Splits the slice, setting `self` to everything before the last  \r\n     *      occurrence of `needle`, and `token` to everything after it. If  \r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,  \r\n     *      and `token` is set to the entirety of `self`.  \r\n     * @param self The slice to split.  \r\n     * @param needle The text to search for in `self`.  \r\n     * @param token An output parameter to which the first token is written.  \r\n     * @return `token`.  \r\n     */  \r\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {  \r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);  \r\n        token._ptr = ptr;  \r\n        token._len = self._len - (ptr - self._ptr);  \r\n        if (ptr == self._ptr) {  \r\n            // Not found  \r\n            self._len = 0;  \r\n        } else {  \r\n            self._len -= token._len + needle._len;  \r\n        }  \r\n        return token;  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Splits the slice, setting `self` to everything before the last  \r\n     *      occurrence of `needle`, and returning everything after it. If  \r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,  \r\n     *      and the entirety of `self` is returned.  \r\n     * @param self The slice to split.  \r\n     * @param needle The text to search for in `self`.  \r\n     * @return The part of `self` after the last occurrence of `delim`.  \r\n     */  \r\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {  \r\n        rsplit(self, needle, token);  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.  \r\n     * @param self The slice to search.  \r\n     * @param needle The text to search for in `self`.  \r\n     * @return The number of occurrences of `needle` found in `self`.  \r\n     */  \r\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {  \r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;  \r\n        while (ptr <= self._ptr + self._len) {  \r\n            cnt++;  \r\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;  \r\n        }  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Returns True if `self` contains `needle`.  \r\n     * @param self The slice to search.  \r\n     * @param needle The text to search for in `self`.  \r\n     * @return True if `needle` is found in `self`, false otherwise.  \r\n     */  \r\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {  \r\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Returns a newly allocated string containing the concatenation of  \r\n     *      `self` and `other`.  \r\n     * @param self The first slice to concatenate.  \r\n     * @param other The second slice to concatenate.  \r\n     * @return The concatenation of the two strings.  \r\n     */  \r\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {  \r\n        string memory ret = new string(self._len + other._len);  \r\n        uint retptr;  \r\n        assembly { retptr := add(ret, 32) }  \r\n        memcpy(retptr, self._ptr, self._len);  \r\n        memcpy(retptr + self._len, other._ptr, other._len);  \r\n        return ret;  \r\n    }  \r\n \r\n    /*  \r\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a  \r\n     *      newly allocated string.  \r\n     * @param self The delimiter to use.  \r\n     * @param parts A list of slices to join.  \r\n     * @return A newly allocated string containing all the slices in `parts`,  \r\n     *         joined with `self`.  \r\n     */  \r\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {  \r\n        if (parts.length == 0)  \r\n            return \"\";  \r\n \r\n        uint length = self._len * (parts.length - 1);  \r\n        for(uint i = 0; i < parts.length; i++)  \r\n            length += parts[i]._len;  \r\n \r\n        string memory ret = new string(length);  \r\n        uint retptr;  \r\n        assembly { retptr := add(ret, 32) }  \r\n \r\n        for(uint i = 0; i < parts.length; i++) {  \r\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);  \r\n            retptr += parts[i]._len;  \r\n            if (i < parts.length - 1) {  \r\n                memcpy(retptr, self._ptr, self._len);  \r\n                retptr += self._len;  \r\n            }  \r\n        }  \r\n \r\n        return ret;  \r\n    }  \r\n}"
39     },
40     "contracts/Context.sol": {
41       "content": "pragma solidity ^0.5.0;\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}"
42     }
43   },
44   "settings": {
45     "optimizer": {
46       "enabled": true,
47       "runs": 200
48     },
49     "outputSelection": {
50       "*": {
51         "*": [
52           "evm.bytecode",
53           "evm.deployedBytecode",
54           "devdoc",
55           "userdoc",
56           "metadata",
57           "abi"
58         ]
59       }
60     },
61     "libraries": {
62       "contracts/SymbolsLib.sol": {
63         "SymbolsLib": "0x3414b7e8332b4da3e268ca7aa5bee6b9a25787f7"
64       },
65       "contracts/TokenInfoLib.sol": {
66         "TokenInfoLib": "0xab2ea31dba6270584486b6d7657fbfcd10f8bfae"
67       }
68     }
69   }
70 }}