1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/WrapMultisig.sol": {
5       "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.8.0;\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\nimport \"./base/WrapManager.sol\";\nimport \"./interfaces/ERC721TokenReceiver.sol\";\n\n/// @title Wrap protocol locking contract, based on Gnosis Safe contract work\ncontract WrapMultisig is MultisigManager, ERC721TokenReceiver {\n    using SafeMath for uint256;\n    using ECDSA for bytes32;\n\n    string public constant NAME = \"Wrap multisig\";\n    string public constant VERSION = \"1.0.0\";\n\n    bytes4 private constant ERC20_TRANSFER_SELECTOR =\n        bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n\n    bytes4 private constant ERC721_SAFE_TRANSFER_SELECTOR =\n        bytes4(keccak256(bytes(\"safeTransferFrom(address,address,uint256)\")));\n\n    //keccak256(\n    //    \"EIP712Domain(address verifyingContract)\"\n    //);\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749;\n\n    //keccak256(\n    //    \"WrapTx(address to,uint256 value,bytes data,string tezosOperation)\"\n    //);\n    bytes32 private constant UNWRAP_TX_TYPEHASH =\n        0x987804e036e2c4c5e32f45ccae87d65fb92de3f7d16998a7fa3910a01da2ab53;\n\n    mapping(string => bool) internal tezosOperations;\n\n    event ExecutionFailure(bytes32 txHash);\n    event ExecutionSuccess(bytes32 txHash);\n    event ERC20WrapAsked(\n        address user,\n        address token,\n        uint256 amount,\n        string tezosDestinationAddress\n    );\n    event ERC721WrapAsked(\n        address user,\n        address token,\n        uint256 tokenId,\n        string tezosDestinationAddress\n    );\n\n    bytes32 public domainSeparator;\n\n    /// @notice The administrator will be allowed to modify multisig members and quorum\n    /// @param _administrator Administrator of the multisig\n    constructor(address _administrator) {\n        require(\n            _administrator != address(0),\n            \"WRAP: INVALID_ADMINISTRATOR_PROVIDED\"\n        );\n        administrator = _administrator;\n    }\n\n    /// @notice Initialize multisig members and threshold\n    /// @dev This function can only be called once and set the domain separator\n    /// @param owners Initial members of the multisig\n    /// @param threshold Threshold of the multisig\n    function setup(address[] calldata owners, uint256 threshold)\n        external\n        authorized\n    {\n        require(domainSeparator == 0, \"WRAP: DOMAIN_SEPARATOR_ALREADY_SET\");\n        domainSeparator = keccak256(\n            abi.encode(DOMAIN_SEPARATOR_TYPEHASH, this)\n        );\n        _setup(owners, threshold);\n    }\n\n    /// @notice Transfer ERC20 tokens to the custody on behalf of the user\n    /// @param token Token contract address\n    /// @param amount Amount to put in custody\n    /// @param tezosAddress Destination address of the wrap on Tezos blockchain\n    function wrapERC20(\n        address token,\n        uint256 amount,\n        string calldata tezosAddress\n    ) external returns (bool success) {\n        require(amount > 0, \"WRAP: INVALID_AMOUNT\");\n        _erc20SafeTransferFrom(token, msg.sender, address(this), amount);\n        emit ERC20WrapAsked(msg.sender, token, amount, tezosAddress);\n        return true;\n    }\n\n    function _erc20SafeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        (bool success, bytes memory data) =\n            token.call(\n                abi.encodeWithSelector(ERC20_TRANSFER_SELECTOR, from, to, value)\n            );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"WRAP: ERC20_TRANSFER_FAILED\"\n        );\n    }\n\n    /// @notice Transfer ERC721 tokens to the custody on behalf of the user\n    /// @param token Token contract address\n    /// @param tokenId Id of the NFT to transfer\n    /// @param tezosAddress Destination address of the wrap on Tezos blockchain\n    function wrapERC721(\n        address token,\n        uint256 tokenId,\n        string calldata tezosAddress\n    ) external returns (bool success) {\n        _erc721SafeTransferFrom(token, msg.sender, address(this), tokenId);\n        emit ERC721WrapAsked(msg.sender, token, tokenId, tezosAddress);\n        return true;\n    }\n\n    function _erc721SafeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {\n        (bool success, bytes memory data) =\n            token.call(\n                abi.encodeWithSelector(\n                    ERC721_SAFE_TRANSFER_SELECTOR,\n                    from,\n                    to,\n                    tokenId\n                )\n            );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"WRAP: ERC721_TRANSFER_FAILED\"\n        );\n    }\n\n    /// @notice Allow to execute an unwrap transaction signed by multisig members\n    /// @dev tezosOperation is used as a nonce to protect against replay attacks\n    /// @param to Destination address of the transaction\n    /// @param value Ether value\n    /// @param data Data paylaod\n    /// @param tezosOperation Identifier of the tezos operation used to burn corresponding wrapped assets\n    /// @param signatures Packed signature data\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        string calldata tezosOperation,\n        bytes calldata signatures\n    ) external returns (bool success) {\n        require(\n            tezosOperations[tezosOperation] == false,\n            \"WRAP: TRANSACTION_ALREADY_PROCESSED\"\n        );\n        tezosOperations[tezosOperation] = true;\n        bytes memory txHashData =\n            encodeTransactionData(to, value, data, tezosOperation);\n        bytes32 txHash = keccak256(txHashData);\n        _checkSignatures(txHash, signatures);\n        success = _execute(to, value, data, gasleft());\n        if (success) emit ExecutionSuccess(txHash);\n        else emit ExecutionFailure(txHash);\n    }\n\n    function _execute(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly {\n            success := call(\n                txGas,\n                to,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n        }\n    }\n\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`\n    /// @notice Make sure to perform a bounds check for @param pos, to avoid out of bounds access on @param signatures\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\n    /// @param signatures concatenated rsv signatures\n    /// @return v v\n    /// @return r r\n    /// @return s s\n    function _signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }\n\n    /// @dev Checks whether the signature provided is valid for the provided hash. Will revert otherwise.\n    /// @param dataHash Hash of the data\n    /// @param signatures Signature data that should be verified.\n    function _checkSignatures(bytes32 dataHash, bytes memory signatures)\n        internal\n        view\n    {\n        uint256 _threshold = threshold;\n        require(_threshold > 0, \"WRAP: THRESHOLD_NOT_DEFINED\");\n        require(\n            signatures.length >= _threshold.mul(65),\n            \"WRAP: SIGNATURES_DATA_TOO_SHORT\"\n        );\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < _threshold; i++) {\n            (v, r, s) = _signatureSplit(signatures, i);\n            currentOwner = dataHash.toEthSignedMessageHash().recover(v, r, s);\n            require(\n                currentOwner > lastOwner &&\n                    owners[currentOwner] != address(0) &&\n                    currentOwner != SENTINEL_OWNERS,\n                \"WRAP: INVALID_OWNER_PROVIDED\"\n            );\n            lastOwner = currentOwner;\n        }\n    }\n\n    /// @notice Returns the bytes that are hashed to be signed by owners\n    /// @param to Destination address\n    /// @param value Ether value\n    /// @param data Data payload\n    /// @param tezosOperation Identifier of the tezos operation used to burn corresponding wrapped assets\n    /// @return Transaction hash bytes\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        string memory tezosOperation\n    ) public view returns (bytes memory) {\n        bytes32 wrapTxHash =\n            keccak256(\n                abi.encode(\n                    UNWRAP_TX_TYPEHASH,\n                    to,\n                    value,\n                    keccak256(data),\n                    tezosOperation\n                )\n            );\n        return\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0x01),\n                domainSeparator,\n                wrapTxHash\n            );\n    }\n\n    /// @notice Returns hash to be signed by owners\n    /// @param to Destination address\n    /// @param value Ether value\n    /// @param data Data payload\n    /// @param tezosOperation Identifier of the tezos operation used to burn corresponding wrapped assets\n    /// @return Transaction hash\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes memory data,\n        string memory tezosOperation\n    ) public view returns (bytes32) {\n        return\n            keccak256(encodeTransactionData(to, value, data, tezosOperation));\n    }\n\n    /// @notice Check if an unwrap were already processed\n    /// @param tezosOperation Identifier to check\n    /// @return true if already processed, false otherwise\n    function isTezosOperationProcessed(string memory tezosOperation)\n        public\n        view\n        returns (bool)\n    {\n        return tezosOperations[tezosOperation];\n    }\n\n    /// @notice Allow ERC721 safe transfers\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return 0x150b7a02;\n    }\n}\n"
6     },
7     "@openzeppelin/contracts/math/SafeMath.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
9     },
10     "@openzeppelin/contracts/cryptography/ECDSA.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
12     },
13     "contracts/base/WrapManager.sol": {
14       "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.8.0;\n\n/// @title MultisigManager - Manages a set of owners and a threshold to perform actions\n/// @notice Owners and threshold is managed by the administrator\ncontract MultisigManager {\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    address administrator;\n    mapping(address => address) internal owners;\n    uint256 ownerCount;\n    uint256 internal threshold;\n\n    modifier authorized() {\n        require(\n            msg.sender == administrator,\n            \"WRAP: METHOD_CAN_ONLY_BE_CALLED_BY_ADMINISTRATOR\"\n        );\n        _;\n    }\n\n    /// @dev Setup function sets initial storage of contract\n    /// @param _owners List of owners\n    /// @param _threshold Number of required confirmations for a Wrap transaction\n    function _setup(address[] memory _owners, uint256 _threshold) internal {\n        require(threshold == 0, \"WRAP: CONTRACT_ALREADY_SETUP\");\n        require(\n            _threshold <= _owners.length,\n            \"WRAP: THRESHOLD_CANNOT_EXCEED_OWNER_COUNT\"\n        );\n        require(_threshold >= 1, \"WRAP: THRESHOLD_NEEED_TO_BE_GREETER_THAN_0\");\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            address owner = _owners[i];\n            require(\n                owner != address(0) && owner != SENTINEL_OWNERS,\n                \"WRAP: INVALID_OWNER_PROVIDED\"\n            );\n            require(\n                owners[owner] == address(0),\n                \"WRAP: DUPLICATE_OWNER_ADDRESS_PROVIDED\"\n            );\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    /// @dev Allows to add a new owner and update the threshold at the same time\n    /// @notice Adds the owner `owner` and updates the threshold to `_threshold`\n    /// @param owner New owner address\n    /// @param _threshold New threshold\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        require(\n            owner != address(0) && owner != SENTINEL_OWNERS,\n            \"WRAP: INVALID_OWNER_ADDRESS_PROVIDED\"\n        );\n        require(\n            owners[owner] == address(0),\n            \"WRAP: ADDRESS_IS_ALREADY_AN_OWNER\"\n        );\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to remove an owner and update the threshold at the same time\n    /// @notice Removes the owner `owner` and updates the threshold to `_threshold`\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\n    /// @param owner Owner address to be removed\n    /// @param _threshold New threshold\n    function removeOwner(\n        address prevOwner,\n        address owner,\n        uint256 _threshold\n    ) public authorized {\n        require(\n            ownerCount - 1 >= _threshold,\n            \"WRAP: NEW_OWNER_COUNT_NEEDS_TO_BE_LONGER_THAN_THRESHOLD\"\n        );\n        require(\n            owner != address(0) && owner != SENTINEL_OWNERS,\n            \"WRAP: INVALID_OWNER_ADDRESS_PROVIDED\"\n        );\n        require(\n            owners[prevOwner] == owner,\n            \"WRAP: INVALID_PREV_OWNER_OWNER_PAIR_PROVIDED\"\n        );\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to swap/replace an owner with another address\n    /// @notice Replaces the owner `oldOwner` with `newOwner`\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\n    /// @param oldOwner Owner address to be replaced\n    /// @param newOwner New owner address\n    function swapOwner(\n        address prevOwner,\n        address oldOwner,\n        address newOwner\n    ) public authorized {\n        require(\n            newOwner != address(0) && newOwner != SENTINEL_OWNERS,\n            \"WRAP: INVALID_OWNER_ADDRESS_PROVIDED\"\n        );\n        require(\n            owners[newOwner] == address(0),\n            \"WRAP: ADDRESS_IS_ALREADY_AN_OWNER\"\n        );\n        require(\n            oldOwner != address(0) && oldOwner != SENTINEL_OWNERS,\n            \"WRAP: INVALID_OWNER_ADDRESS_PROVIDED\"\n        );\n        require(\n            owners[prevOwner] == oldOwner,\n            \"WRAP: INVALID_PREV_OWNER_OWNER_PAIR_PROVIDED\"\n        );\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    /// @dev Allows to update the number of required confirmations\n    /// @notice Changes the threshold to `_threshold`\n    /// @param _threshold New threshold\n    function changeThreshold(uint256 _threshold) public authorized {\n        require(\n            _threshold <= ownerCount,\n            \"WRAP: THRESHOLD_CANNOT_EXCEED_OWNER_COUNT\"\n        );\n        require(_threshold >= 1, \"WRAP: THRESHOLD_NEEED_TO_BE_GREETER_THAN_0\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    /// @notice Get multisig threshold\n    /// @return Threshold\n    function getThreshold() public view returns (uint256) {\n        return threshold;\n    }\n\n    /// @notice Allow to check if an address is owner of the multisig\n    /// @return True if owner, false otherwise\n    function isOwner(address owner) public view returns (bool) {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }\n\n    /// @notice Get multisig members\n    /// @return Owners list\n    function getOwners() public view returns (address[] memory) {\n        address[] memory array = new address[](ownerCount);\n\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index++;\n        }\n        return array;\n    }\n\n    /// @notice Get current multisig administrator\n    /// @return Administrator address\n    function getAdministrator() public view returns (address) {\n        return administrator;\n    }\n}\n"
15     },
16     "contracts/interfaces/ERC721TokenReceiver.sol": {
17       "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.8.0;\n\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external returns (bytes4);\n}\n"
18     }
19   },
20   "settings": {
21     "optimizer": {
22       "enabled": true,
23       "runs": 1000000
24     },
25     "outputSelection": {
26       "*": {
27         "*": [
28           "evm.bytecode",
29           "evm.deployedBytecode",
30           "abi"
31         ]
32       }
33     },
34     "metadata": {
35       "useLiteralContent": true
36     },
37     "libraries": {}
38   }
39 }}