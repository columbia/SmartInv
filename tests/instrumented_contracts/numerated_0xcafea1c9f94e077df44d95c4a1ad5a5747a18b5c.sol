1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/modules/oracles/TwapOracle.sol": {
5       "content": "/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\nimport \"@uniswap/lib/contracts/libraries/FixedPoint.sol\";\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\";\n\ncontract TwapOracle {\n  using FixedPoint for *;\n\n  struct Bucket {\n    uint timestamp;\n    uint price0Cumulative;\n    uint price1Cumulative;\n  }\n\n  event Updated(address indexed pair, uint timestamp, uint price0Cumulative, uint price1Cumulative);\n\n  uint constant public periodSize = 1800;\n  uint constant public periodsPerWindow = 8;\n  uint constant public windowSize = periodSize * periodsPerWindow;\n\n  address public factory;\n\n  // token pair => Bucket[8]\n  mapping(address => Bucket[8]) public buckets;\n\n  constructor (address _factory) public {\n    factory = _factory;\n  }\n\n  /* utils */\n\n  // https://uniswap.org/docs/v2/smart-contract-integration/getting-pair-addresses/\n  function _pairFor(address _factory, address tokenA, address tokenB) internal pure returns (address pair) {\n\n    // sort tokens\n    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n\n    require(token0 != token1, \"TWAP: identical addresses\");\n    require(token0 != address(0), \"TWAP: zero address\");\n\n    pair = address(uint(keccak256(abi.encodePacked(\n        hex'ff',\n        _factory,\n        keccak256(abi.encodePacked(token0, token1)),\n        hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'\n      ))));\n  }\n\n  function timestampToIndex(uint timestamp) internal pure returns (uint index) {\n    uint epochPeriod = timestamp / periodSize;\n    return epochPeriod % periodsPerWindow;\n  }\n\n  function pairFor(address tokenA, address tokenB) external view returns (address pair) {\n    return _pairFor(factory, tokenA, tokenB);\n  }\n\n  function currentBucketIndex() external view returns (uint index) {\n    return timestampToIndex(block.timestamp);\n  }\n\n  /* update */\n\n  function update(address[] calldata pairs) external {\n\n    for (uint i = 0; i < pairs.length; i++) {\n\n      // note: not reusing canUpdate() because we need the bucket variable\n      address pair = pairs[i];\n      uint index = timestampToIndex(block.timestamp);\n      Bucket storage bucket = buckets[pair][index];\n\n      if (block.timestamp - bucket.timestamp < periodSize) {\n        continue;\n      }\n\n      (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n      bucket.timestamp = block.timestamp;\n      bucket.price0Cumulative = price0Cumulative;\n      bucket.price1Cumulative = price1Cumulative;\n\n      emit Updated(pair, block.timestamp, price0Cumulative, price1Cumulative);\n    }\n  }\n\n  function canUpdate(address pair) external view returns (bool) {\n\n    uint index = timestampToIndex(block.timestamp);\n    Bucket storage bucket = buckets[pair][index];\n    uint timeElapsed = block.timestamp - bucket.timestamp;\n\n    return timeElapsed > periodSize;\n  }\n\n  /* consult */\n\n  function _getCumulativePrices(\n    address tokenIn,\n    address tokenOut\n  ) internal view returns (uint priceCumulativeStart, uint priceCumulativeEnd, uint timeElapsed) {\n\n    uint currentIndex = timestampToIndex(block.timestamp);\n    uint firstBucketIndex = (currentIndex + 1) % periodsPerWindow;\n\n    address pair = _pairFor(factory, tokenIn, tokenOut);\n    Bucket storage firstBucket = buckets[pair][firstBucketIndex];\n\n    timeElapsed = block.timestamp - firstBucket.timestamp;\n    require(timeElapsed <= windowSize, \"TWAP: missing historical reading\");\n    require(timeElapsed >= windowSize - periodSize * 2, \"TWAP: unexpected time elapsed\");\n\n    (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n\n    if (tokenIn < tokenOut) {\n      return (firstBucket.price0Cumulative, price0Cumulative, timeElapsed);\n    }\n\n    return (firstBucket.price1Cumulative, price1Cumulative, timeElapsed);\n  }\n\n  function _computeAmountOut(\n    uint priceCumulativeStart,\n    uint priceCumulativeEnd,\n    uint timeElapsed,\n    uint amountIn\n  ) internal pure returns (uint amountOut) {\n\n    // overflow is desired.\n    FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\n      uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n    );\n\n    return priceAverage.mul(amountIn).decode144();\n  }\n\n  /**\n   *  @dev Returns the amount out corresponding to the amount in for a given token using the\n   *  @dev   moving average over the time range [now - [windowSize, windowSize - periodSize * 2], now]\n   *  @dev   update must have been called for the bucket corresponding to timestamp `now - windowSize`\n   */\n  function consult(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\n\n    uint pastPriceCumulative;\n    uint currentPriceCumulative;\n    uint timeElapsed;\n\n    (pastPriceCumulative, currentPriceCumulative, timeElapsed) = _getCumulativePrices(tokenIn, tokenOut);\n\n    return _computeAmountOut(\n      pastPriceCumulative,\n      currentPriceCumulative,\n      timeElapsed,\n      amountIn\n    );\n  }\n\n}\n"
6     },
7     "@uniswap/lib/contracts/libraries/FixedPoint.sol": {
8       "content": "pragma solidity >=0.4.0;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n        uint z;\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n}\n"
9     },
10     "@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol": {
11       "content": "pragma solidity >=0.5.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}\n"
12     },
13     "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
14       "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
15     }
16   },
17   "settings": {
18     "optimizer": {
19       "enabled": true,
20       "runs": 200
21     },
22     "outputSelection": {
23       "*": {
24         "*": [
25           "evm.bytecode",
26           "evm.deployedBytecode",
27           "abi"
28         ]
29       }
30     },
31     "libraries": {}
32   }
33 }}