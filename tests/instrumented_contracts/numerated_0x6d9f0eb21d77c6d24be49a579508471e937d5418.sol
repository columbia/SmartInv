1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/antfarm/AntfarmRouter.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\nimport \"../interfaces/IAntfarmRouter.sol\";\nimport \"../interfaces/IAntfarmPair.sol\";\nimport \"../interfaces/IAntfarmFactory.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../libraries/TransferHelper.sol\";\nimport \"./AntfarmOracle.sol\";\nimport \"../utils/AntfarmRouterErrors.sol\";\n\n/// @title Antfarm Router for AntFarmPair\n/// @notice High-level contract that serves as the entrypoint for swapping\ncontract AntfarmRouter is IAntfarmRouter {\n    address public immutable factory;\n    address public immutable WETH;\n    address public immutable antfarmToken;\n\n    modifier ensure(uint256 deadline) {\n        if (deadline < block.timestamp) revert Expired();\n        _;\n    }\n\n    constructor(\n        address _factory,\n        address _WETH,\n        address _antfarmToken\n    ) {\n        require(_factory != address(0), \"NULL_FACTORY_ADDRESS\");\n        require(_WETH != address(0), \"NULL_WETH_ADDRESS\");\n        require(_antfarmToken != address(0), \"NULL_ATF_ADDRESS\");\n        factory = _factory;\n        WETH = _WETH;\n        antfarmToken = _antfarmToken;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    /// @notice Swaps an exact amount of input tokens for as many output tokens as possible\n    /// @param params The parameters necessary for the swap, encoded as `swapExactTokensForTokensParams` in calldata\n    // @param amountIn The amount of input tokens to send\n    // @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert\n    // @param maxFee Maximum fees to be paid\n    // @param path An array of token addresses\n    // @param fees Associated fee for each two token addresses within the path\n    // @param to Recipient of the output tokens\n    // @param deadline Unix timestamp after which the transaction will revert\n    /// @return amounts The input token amount and all subsequent output token amounts\n    function swapExactTokensForTokens(\n        swapExactTokensForTokensParams calldata params\n    )\n        external\n        virtual\n        ensure(params.deadline)\n        returns (uint256[] memory amounts)\n    {\n        uint256 amountIn = params.path[0] == antfarmToken\n            ? (params.amountIn * (1000 + params.fees[0])) / 1000\n            : params.amountIn;\n        amounts = getAmountsOut(amountIn, params.path, params.fees);\n        if (amounts[amounts.length - 1] < params.amountOutMin) {\n            revert InsufficientOutputAmount();\n        }\n        TransferHelper.safeTransferFrom(\n            params.path[0],\n            msg.sender,\n            pairFor(params.path[0], params.path[1], params.fees[0]),\n            amounts[0]\n        );\n        if (\n            _swap(amounts, params.path, params.fees, params.to) > params.maxFee\n        ) {\n            revert InsufficientMaxFee();\n        }\n    }\n\n    /// @notice Receive an exact amount of output tokens for as few input tokens as possible\n    /// @param params The parameters necessary for the swap, encoded as `swapTokensForExactTokensParams` in calldata\n    // @param amountOut The amount of output tokens to receive\n    // @param amountInMax The maximum amount of input tokens that can be required before the transaction reverts\n    // @param maxFee Maximum fees to be paid\n    // @param path An array of token addresses\n    // @param fees Associated fee for each two token addresses within the path\n    // @param to Recipient of the output tokens\n    // @param deadline Unix timestamp after which the transaction will revert\n    /// @return amounts The input token amount and all subsequent output token amounts\n    function swapTokensForExactTokens(\n        swapTokensForExactTokensParams calldata params\n    )\n        external\n        virtual\n        ensure(params.deadline)\n        returns (uint256[] memory amounts)\n    {\n        uint256 amountInMax = params.path[0] == antfarmToken\n            ? (params.amountInMax * (1000 + params.fees[0])) / 1000\n            : params.amountInMax;\n        amounts = getAmountsIn(params.amountOut, params.path, params.fees);\n        if (amounts[0] > amountInMax) revert ExcessiveInputAmount();\n        TransferHelper.safeTransferFrom(\n            params.path[0],\n            msg.sender,\n            pairFor(params.path[0], params.path[1], params.fees[0]),\n            amounts[0]\n        );\n        if (\n            _swap(amounts, params.path, params.fees, params.to) > params.maxFee\n        ) {\n            revert InsufficientMaxFee();\n        }\n    }\n\n    /// @notice Swaps an exact amount of ETH for as many output tokens as possible\n    /// @param params The parameters necessary for the swap, encoded as `swapExactETHForTokensParams` in calldata\n    // @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert\n    // @param maxFee Maximum fees to be paid\n    // @param path An array of token addresses\n    // @param fees Associated fee for each two token addresses within the path\n    // @param to Recipient of the output tokens\n    // @param deadline Unix timestamp after which the transaction will revert\n    /// @return amounts The input token amount and all subsequent output token amounts\n    function swapExactETHForTokens(swapExactETHForTokensParams calldata params)\n        external\n        payable\n        virtual\n        ensure(params.deadline)\n        returns (uint256[] memory amounts)\n    {\n        if (params.path[0] != WETH) revert InvalidPath();\n        amounts = getAmountsOut(msg.value, params.path, params.fees);\n        if (amounts[amounts.length - 1] < params.amountOutMin) {\n            revert InsufficientOutputAmount();\n        }\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(\n            IWETH(WETH).transfer(\n                pairFor(params.path[0], params.path[1], params.fees[0]),\n                amounts[0]\n            )\n        );\n        if (\n            _swap(amounts, params.path, params.fees, params.to) > params.maxFee\n        ) {\n            revert InsufficientMaxFee();\n        }\n    }\n\n    /// @notice Receive an exact amount of ETH for as few input tokens as possible\n    /// @param params The parameters necessary for the swap, encoded as `swapTokensForExactETHParams` in calldata\n    // @param amountOut The amount of ETH to receive\n    // @param amountInMax The maximum amount of input tokens that can be required before the transaction reverts\n    // @param maxFee Maximum fees to be paid\n    // @param path An array of token addresses\n    // @param fees Associated fee for each two token addresses within the path\n    // @param to Recipient of the output tokens\n    // @param deadline Unix timestamp after which the transaction will revert\n    /// @return amounts The input token amount and all subsequent output token amounts\n    function swapTokensForExactETH(swapTokensForExactETHParams calldata params)\n        external\n        virtual\n        ensure(params.deadline)\n        returns (uint256[] memory amounts)\n    {\n        if (params.path[params.path.length - 1] != WETH) revert InvalidPath();\n        uint256 amountInMax = params.path[0] == antfarmToken\n            ? (params.amountInMax * (1000 + params.fees[0])) / 1000\n            : params.amountInMax;\n        amounts = getAmountsIn(params.amountOut, params.path, params.fees);\n        if (amounts[0] > amountInMax) revert ExcessiveInputAmount();\n        TransferHelper.safeTransferFrom(\n            params.path[0],\n            msg.sender,\n            pairFor(params.path[0], params.path[1], params.fees[0]),\n            amounts[0]\n        );\n        if (\n            _swap(amounts, params.path, params.fees, address(this)) >\n            params.maxFee\n        ) {\n            revert InsufficientMaxFee();\n        }\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(params.to, amounts[amounts.length - 1]);\n    }\n\n    /// @notice Swaps an exact amount of tokens for as much ETH as possible\n    /// @param params The parameters necessary for the swap, encoded as `swapExactTokensForETHParams` in calldata\n    // @param amountIn The amount of input tokens to send\n    // @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert\n    // @param maxFee Maximum fees to be paid\n    // @param path An array of token addresses\n    // @param fees Associated fee for each two token addresses within the path\n    // @param to Recipient of the output tokens\n    // @param deadline Unix timestamp after which the transaction will revert\n    /// @return amounts The input token amount and all subsequent output token amounts\n    function swapExactTokensForETH(swapExactTokensForETHParams calldata params)\n        external\n        virtual\n        ensure(params.deadline)\n        returns (uint256[] memory amounts)\n    {\n        uint256 amountIn = params.path[0] == antfarmToken\n            ? (params.amountIn * (1000 + params.fees[0])) / 1000\n            : params.amountIn;\n        if (params.path[params.path.length - 1] != WETH) revert InvalidPath();\n        amounts = getAmountsOut(amountIn, params.path, params.fees);\n        if (amounts[amounts.length - 1] < params.amountOutMin) {\n            revert InsufficientOutputAmount();\n        }\n        TransferHelper.safeTransferFrom(\n            params.path[0],\n            msg.sender,\n            pairFor(params.path[0], params.path[1], params.fees[0]),\n            amounts[0]\n        );\n        if (\n            _swap(amounts, params.path, params.fees, address(this)) >\n            params.maxFee\n        ) {\n            revert InsufficientMaxFee();\n        }\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(params.to, amounts[amounts.length - 1]);\n    }\n\n    /// @notice Receive an exact amount of tokens for as little ETH as possible\n    /// @param params The parameters necessary for the swap, encoded as `swapETHForExactTokensParams` in calldata\n    // @param amountOut The amount of tokens to receive\n    // @param maxFee Maximum fees to be paid\n    // @param path An array of token addresses\n    // @param fees Associated fee for each two token addresses within the path\n    // @param to Recipient of the output tokens\n    // @param deadline Unix timestamp after which the transaction will revert\n    /// @return amounts The input token amount and all subsequent output token amounts\n    function swapETHForExactTokens(swapETHForExactTokensParams calldata params)\n        external\n        payable\n        virtual\n        ensure(params.deadline)\n        returns (uint256[] memory amounts)\n    {\n        if (params.path[0] != WETH) revert InvalidPath();\n        amounts = getAmountsIn(params.amountOut, params.path, params.fees);\n        if (amounts[0] > msg.value) revert ExcessiveInputAmount();\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(\n            IWETH(WETH).transfer(\n                pairFor(params.path[0], params.path[1], params.fees[0]),\n                amounts[0]\n            )\n        );\n        if (\n            _swap(amounts, params.path, params.fees, params.to) > params.maxFee\n        ) {\n            revert InsufficientMaxFee();\n        }\n        // refund dust ETH if any\n        if (msg.value > amounts[0])\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    /// @notice Identical to swapExactTokensForTokens, but succeeds for tokens that take a fee on transfer\n    /// @param params The parameters necessary for the swap, encoded as `swapExactTokensForTokensParams` in calldata\n    // @param amountIn The amount of input tokens to send\n    // @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert\n    // @param path An array of token addresses\n    // @param fees Associated fee for each two token addresses within the path\n    // @param to Recipient of the output tokens\n    // @param deadline Unix timestamp after which the transaction will revert\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        swapExactTokensForTokensParams calldata params\n    ) external virtual ensure(params.deadline) {\n        TransferHelper.safeTransferFrom(\n            params.path[0],\n            msg.sender,\n            pairFor(params.path[0], params.path[1], params.fees[0]),\n            params.amountIn\n        );\n        uint256 balanceBefore = IERC20(params.path[params.path.length - 1])\n            .balanceOf(params.to);\n        swapParams memory sParams = swapParams(\n            params.path,\n            params.fees,\n            params.to\n        );\n        if (_swapSupportingFeeOnTransferTokens(sParams) > params.maxFee) {\n            revert InsufficientMaxFee();\n        }\n        if (\n            IERC20(params.path[params.path.length - 1]).balanceOf(params.to) -\n                balanceBefore <\n            params.amountOutMin\n        ) {\n            revert InsufficientOutputAmount();\n        }\n    }\n\n    /// @notice Identical to swapExactETHForTokens, but succeeds for tokens that take a fee on transfer\n    /// @param params The parameters necessary for the swap, encoded as `swapExactETHForTokensParams` in calldata\n    // @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert\n    // @param path An array of token addresses\n    // @param fees Associated fee for each two token addresses within the path\n    // @param to Recipient of the output tokens\n    // @param deadline Unix timestamp after which the transaction will revert\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        swapExactETHForTokensParams calldata params\n    ) external payable virtual ensure(params.deadline) {\n        if (params.path[0] != WETH) revert InvalidPath();\n        uint256 amountIn = msg.value;\n        IWETH(WETH).deposit{value: amountIn}();\n        assert(\n            IWETH(WETH).transfer(\n                pairFor(params.path[0], params.path[1], params.fees[0]),\n                amountIn\n            )\n        );\n        uint256 balanceBefore = IERC20(params.path[params.path.length - 1])\n            .balanceOf(params.to);\n        swapParams memory sParams = swapParams(\n            params.path,\n            params.fees,\n            params.to\n        );\n        if (_swapSupportingFeeOnTransferTokens(sParams) > params.maxFee) {\n            revert InsufficientMaxFee();\n        }\n        if (\n            IERC20(params.path[params.path.length - 1]).balanceOf(params.to) -\n                balanceBefore <\n            params.amountOutMin\n        ) {\n            revert InsufficientOutputAmount();\n        }\n    }\n\n    /// @notice Identical to swapExactTokensForETH, but succeeds for tokens that take a fee on transfer\n    /// @param params The parameters necessary for the swap, encoded as `swapExactTokensForETHParams` in calldata\n    // @param amountIn The amount of input tokens to send\n    // @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert\n    // @param path An array of token addresses\n    // @param fees Associated fee for each two token addresses within the path\n    // @param to Recipient of the output tokens\n    // @param deadline Unix timestamp after which the transaction will revert\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        swapExactTokensForETHParams calldata params\n    ) external virtual ensure(params.deadline) {\n        if (params.path[params.path.length - 1] != WETH) revert InvalidPath();\n        TransferHelper.safeTransferFrom(\n            params.path[0],\n            msg.sender,\n            pairFor(params.path[0], params.path[1], params.fees[0]),\n            params.amountIn\n        );\n        swapParams memory sParams = swapParams(\n            params.path,\n            params.fees,\n            address(this)\n        );\n        if (_swapSupportingFeeOnTransferTokens(sParams) > params.maxFee) {\n            revert InsufficientMaxFee();\n        }\n        uint256 amountOut = IERC20(WETH).balanceOf(address(this));\n        if (amountOut < params.amountOutMin) revert InsufficientOutputAmount();\n        IWETH(WETH).withdraw(amountOut);\n        TransferHelper.safeTransferETH(params.to, amountOut);\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address tokenA,\n        address tokenB,\n        uint16 fee\n    ) public view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IAntfarmPair(\n            pairFor(tokenA, tokenB, fee)\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // SWAP\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(\n        uint256[] memory amounts,\n        address[] memory path,\n        uint16[] memory fees,\n        address _to\n    ) internal virtual returns (uint256 totalFee) {\n        for (uint256 i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            uint16 fee = fees[i];\n            IAntfarmPair antfarmPair = IAntfarmPair(\n                pairFor(input, output, fee)\n            );\n\n            (address token0, ) = sortTokens(input, output);\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amounts[i + 1])\n                : (amounts[i + 1], uint256(0));\n\n            {\n                uint256 amountIn = amounts[i];\n\n                if (input == antfarmToken) {\n                    totalFee = totalFee + ((amountIn * fee) / (1000 + fee));\n                } else if (output == antfarmToken) {\n                    totalFee =\n                        totalFee +\n                        ((amounts[i + 1] * fee) / (1000 - fee));\n                } else {\n                    uint256 feeToPay = antfarmPair.getFees(\n                        amount0Out,\n                        input == token0 ? amountIn : uint256(0),\n                        amount1Out,\n                        input == token0 ? uint256(0) : amountIn\n                    );\n\n                    TransferHelper.safeTransferFrom(\n                        antfarmToken,\n                        msg.sender,\n                        address(antfarmPair),\n                        feeToPay\n                    );\n\n                    totalFee = totalFee + feeToPay;\n                }\n            }\n\n            address to = i < path.length - 2\n                ? pairFor(output, path[i + 2], fees[i + 1])\n                : _to;\n            antfarmPair.swap(amount0Out, amount1Out, to);\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    function _swapSupportingFeeOnTransferTokens(swapParams memory sParams)\n        internal\n        virtual\n        returns (uint256 totalFee)\n    {\n        for (uint256 i; i < sParams.path.length - 1; i++) {\n            (address input, address output) = (\n                sParams.path[i],\n                sParams.path[i + 1]\n            );\n            uint16 fee = sParams.fees[i];\n            IAntfarmPair antfarmPair = IAntfarmPair(\n                pairFor(input, output, fee)\n            );\n\n            (address token0, ) = sortTokens(input, output);\n\n            uint256 amountIn;\n            uint256 amountOut;\n            {\n                (uint256 reserve0, uint256 reserve1, ) = antfarmPair\n                    .getReserves();\n                (uint256 reserveIn, uint256 reserveOut) = input == token0\n                    ? (reserve0, reserve1)\n                    : (reserve1, reserve0);\n\n                amountIn =\n                    IERC20(input).balanceOf(address(antfarmPair)) -\n                    reserveIn;\n\n                if (input == antfarmToken) {\n                    amountOut = getAmountOut(\n                        (amountIn * 1000) / (1000 + fee),\n                        reserveIn,\n                        reserveOut\n                    );\n                } else if (output == antfarmToken) {\n                    amountOut =\n                        (getAmountOut(amountIn, reserveIn, reserveOut) *\n                            (1000 - fee)) /\n                        1000;\n                } else {\n                    amountOut = getAmountOut(amountIn, reserveIn, reserveOut);\n                }\n            }\n\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOut)\n                : (amountOut, uint256(0));\n\n            if (input == antfarmToken) {\n                totalFee = totalFee + ((amountIn * fee) / (1000 + fee));\n            } else if (output == antfarmToken) {\n                totalFee = totalFee + ((amountIn * fee) / 1000);\n            } else {\n                uint256 feeToPay = antfarmPair.getFees(\n                    amount0Out,\n                    input == token0 ? amountIn : uint256(0),\n                    amount1Out,\n                    input == token0 ? uint256(0) : amountIn\n                );\n\n                TransferHelper.safeTransferFrom(\n                    antfarmToken,\n                    msg.sender,\n                    address(antfarmPair),\n                    feeToPay\n                );\n\n                totalFee = totalFee + feeToPay;\n            }\n\n            address to = i < sParams.path.length - 2\n                ? pairFor(output, sParams.path[i + 2], sParams.fees[i + 1])\n                : sParams.to;\n            antfarmPair.swap(amount0Out, amount1Out, to);\n        }\n    }\n\n    // **** LIBRARY FUNCTIONS ADDED INTO THE CONTRACT ****\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        view\n        returns (address token0, address token1)\n    {\n        if (tokenA == tokenB) revert IdenticalAddresses();\n        if (tokenA == antfarmToken || tokenB == antfarmToken) {\n            (token0, token1) = tokenA == antfarmToken\n                ? (antfarmToken, tokenB)\n                : (antfarmToken, tokenA);\n            if (token1 == address(0)) revert ZeroAddress();\n        } else {\n            (token0, token1) = tokenA < tokenB\n                ? (tokenA, tokenB)\n                : (tokenB, tokenA);\n            if (token0 == address(0)) revert ZeroAddress();\n        }\n    }\n\n    /// @notice Calculates the CREATE2 address for a pair without making any external calls\n    /// @param tokenA Token0 from the AntfarmPair\n    /// @param tokenB Token1 from the AntfarmPair\n    /// @param fee Associated fee to the AntfarmPair\n    /// @return pair The CREATE2 address for the desired AntFarmPair\n    function pairFor(\n        address tokenA,\n        address tokenB,\n        uint16 fee\n    ) internal view returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            factory,\n                            keccak256(\n                                abi.encodePacked(\n                                    token0,\n                                    token1,\n                                    fee,\n                                    antfarmToken\n                                )\n                            ),\n                            token0 == antfarmToken\n                                ? hex\"b174de46ec9038ead3d74ed04c79d4885d8e642175833c4da037d5e052492e5b\" // AtfPair init code hash\n                                : hex\"2f47d72b208014a5ba4f32371ac96dd421a39152dcaf104e8232b6c9f1a92280\" // Pair init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        uint256 amountIn,\n        address[] memory path,\n        uint16[] memory fees\n    ) internal view returns (uint256[] memory) {\n        if (path.length < 2) revert InvalidPath();\n        uint256[] memory amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                path[i],\n                path[i + 1],\n                fees[i]\n            );\n            if (path[i] == antfarmToken) {\n                amounts[i + 1] = getAmountOut(\n                    (amounts[i] * 1000) / (1000 + fees[i]),\n                    reserveIn,\n                    reserveOut\n                );\n            } else if (path[i + 1] == antfarmToken) {\n                amounts[i + 1] =\n                    (getAmountOut(amounts[i], reserveIn, reserveOut) *\n                        (1000 - fees[i])) /\n                    1000;\n            } else {\n                amounts[i + 1] = getAmountOut(\n                    amounts[i],\n                    reserveIn,\n                    reserveOut\n                );\n            }\n        }\n        return amounts;\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        uint256 amountOut,\n        address[] memory path,\n        uint16[] memory fees\n    ) internal view returns (uint256[] memory) {\n        if (path.length < 2) revert InvalidPath();\n        uint256[] memory amounts = new uint256[](path.length);\n        amounts[path.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                path[i - 1],\n                path[i],\n                fees[i - 1]\n            );\n            if (path[i - 1] == antfarmToken) {\n                amounts[i - 1] =\n                    (getAmountIn(amounts[i], reserveIn, reserveOut) *\n                        (1000 + fees[i - 1])) /\n                    1000;\n            } else if (path[i] == antfarmToken) {\n                amounts[i - 1] = getAmountIn(\n                    (amounts[i] * 1000) / (1000 - fees[i - 1]),\n                    reserveIn,\n                    reserveOut\n                );\n            } else {\n                amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n            }\n        }\n        return amounts;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256) {\n        if (amountIn == 0) revert InsufficientInputAmount();\n        if (reserveIn == 0 || reserveOut == 0) revert InsufficientLiquidity();\n        uint256 numerator = amountIn * reserveOut;\n        uint256 denominator = reserveIn + amountIn;\n        return numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256) {\n        if (amountOut == 0) revert InsufficientOutputAmount();\n        if (reserveIn == 0 || reserveOut == 0) revert InsufficientLiquidity();\n        uint256 numerator = reserveIn * amountOut;\n        uint256 denominator = reserveOut - amountOut;\n        return (numerator / denominator) + 1;\n    }\n}\n"
6     },
7     "contracts/interfaces/IAntfarmRouter.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\ninterface IAntfarmRouter {\n    function factory() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function antfarmToken() external view returns (address);\n\n    struct swapParams {\n        address[] path;\n        uint16[] fees;\n        address to;\n    }\n\n    struct swapExactTokensForTokensParams {\n        uint256 amountIn;\n        uint256 amountOutMin;\n        uint256 maxFee;\n        address[] path;\n        uint16[] fees;\n        address to;\n        uint256 deadline;\n    }\n\n    function swapExactTokensForTokens(\n        swapExactTokensForTokensParams calldata params\n    ) external returns (uint256[] memory amounts);\n\n    struct swapTokensForExactTokensParams {\n        uint256 amountOut;\n        uint256 amountInMax;\n        uint256 maxFee;\n        address[] path;\n        uint16[] fees;\n        address to;\n        uint256 deadline;\n    }\n\n    function swapTokensForExactTokens(\n        swapTokensForExactTokensParams calldata params\n    ) external returns (uint256[] memory amounts);\n\n    struct swapExactETHForTokensParams {\n        uint256 amountOutMin;\n        uint256 maxFee;\n        address[] path;\n        uint16[] fees;\n        address to;\n        uint256 deadline;\n    }\n\n    function swapExactETHForTokens(swapExactETHForTokensParams calldata params)\n        external\n        payable\n        returns (uint256[] memory amounts);\n\n    struct swapTokensForExactETHParams {\n        uint256 amountOut;\n        uint256 amountInMax;\n        uint256 maxFee;\n        address[] path;\n        uint16[] fees;\n        address to;\n        uint256 deadline;\n    }\n\n    function swapTokensForExactETH(swapTokensForExactETHParams calldata params)\n        external\n        returns (uint256[] memory amounts);\n\n    struct swapExactTokensForETHParams {\n        uint256 amountIn;\n        uint256 amountOutMin;\n        uint256 maxFee;\n        address[] path;\n        uint16[] fees;\n        address to;\n        uint256 deadline;\n    }\n\n    function swapExactTokensForETH(swapExactTokensForETHParams calldata params)\n        external\n        returns (uint256[] memory amounts);\n\n    struct swapETHForExactTokensParams {\n        uint256 amountOut;\n        uint256 maxFee;\n        address[] path;\n        uint16[] fees;\n        address to;\n        uint256 deadline;\n    }\n\n    function swapETHForExactTokens(swapETHForExactTokensParams calldata params)\n        external\n        payable\n        returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        swapExactTokensForTokensParams calldata params\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        swapExactETHForTokensParams calldata params\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        swapExactTokensForETHParams calldata params\n    ) external;\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address tokenA,\n        address tokenB,\n        uint16 fee\n    ) external view returns (uint256 reserveA, uint256 reserveB);\n}\n"
9     },
10     "contracts/libraries/TransferHelper.sol": {
11       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity =0.8.10;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper::safeApprove: approve failed\"\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper::safeTransfer: transfer failed\"\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper::transferFrom: transferFrom failed\"\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(\n            success,\n            \"TransferHelper::safeTransferETH: ETH transfer failed\"\n        );\n    }\n}\n"
12     },
13     "contracts/interfaces/IWETH.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
15     },
16     "contracts/interfaces/IAntfarmFactory.sol": {
17       "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\ninterface IAntfarmFactory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint16 fee,\n        uint256 allPairsLength\n    );\n\n    function possibleFees(uint256) external view returns (uint16);\n\n    function allPairs(uint256) external view returns (address);\n\n    function antfarmToken() external view returns (address);\n\n    function getPair(\n        address tokenA,\n        address tokenB,\n        uint16 fee\n    ) external view returns (address pair);\n\n    function feesForPair(\n        address tokenA,\n        address tokenB,\n        uint256\n    ) external view returns (uint16);\n\n    function getFeesForPair(address tokenA, address tokenB)\n        external\n        view\n        returns (uint16[8] memory fees);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        uint16 fee\n    ) external returns (address pair);\n}\n"
18     },
19     "contracts/interfaces/IAntfarmPair.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\nimport \"./IAntfarmBase.sol\";\n\ninterface IAntfarmPair is IAntfarmBase {\n    /// @notice Initialize the pair\n    /// @dev Can only be called by the factory\n    function initialize(\n        address,\n        address,\n        uint16,\n        address\n    ) external;\n\n    /// @notice The Antfarm token address\n    /// @return address Address\n    function antfarmToken() external view returns (address);\n\n    /// @notice The Oracle instance used to compute swap's fees\n    /// @return AntfarmOracle Oracle instance\n    function antfarmOracle() external view returns (address);\n\n    /// @notice Calcul fee to pay\n    /// @param amount0Out The token0 amount going out of the pool\n    /// @param amount0In The token0 amount going in the pool\n    /// @param amount1Out The token1 amount going out of the pool\n    /// @param amount1In The token1 amount going in the pool\n    /// @return feeToPay Calculated fee to be paid\n    function getFees(\n        uint256 amount0Out,\n        uint256 amount0In,\n        uint256 amount1Out,\n        uint256 amount1In\n    ) external view returns (uint256 feeToPay);\n\n    /// @notice Check for the best Oracle to use to perform fee calculation for a swap\n    /// @dev Returns address(0) if no better oracle is found.\n    /// @param maxReserve Actual oracle reserve0\n    /// @return bestOracle Address from the best oracle found\n    function scanOracles(uint112 maxReserve)\n        external\n        view\n        returns (address bestOracle);\n\n    /// @notice Update oracle for token\n    /// @custom:usability Update the current Oracle with a more suitable one. Revert if the current Oracle is already the more suitable\n    function updateOracle() external;\n}\n"
21     },
22     "contracts/antfarm/AntfarmOracle.sol": {
23       "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\nimport \"../libraries/fixedpoint/FixedPoint.sol\";\n\nerror InvalidToken();\n\n/// @title Antfarm Oracle for AntfarmPair\n/// @notice Fixed window oracle that recomputes the average price for the entire period once every period\ncontract AntfarmOracle {\n    using FixedPoint for *;\n\n    uint256 public constant PERIOD = 1 hours;\n\n    address public token1;\n    address public pair;\n\n    uint256 public price1CumulativeLast;\n    uint32 public blockTimestampLast;\n    FixedPoint.uq112x112 public price1Average;\n\n    bool public firstUpdateCall;\n\n    constructor(\n        address _token1,\n        uint256 _price1CumulativeLast,\n        uint32 _blockTimestampLast\n    ) {\n        token1 = _token1;\n        pair = msg.sender;\n        price1CumulativeLast = _price1CumulativeLast; // fetch the current accumulated price value (1 / 0)\n        blockTimestampLast = _blockTimestampLast;\n        firstUpdateCall = true;\n    }\n\n    /// @notice Average price update\n    /// @param price1Cumulative Price cumulative for the associated AntfarmPair's token1\n    /// @param blockTimestamp Last block timestamp for the associated AntfarmPair\n    /// @dev Only usable by the associated AntfarmPair\n    function update(uint256 price1Cumulative, uint32 blockTimestamp) external {\n        require(msg.sender == pair);\n        unchecked {\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n            // ensure that at least one full period has passed since the last update\n            if (timeElapsed >= PERIOD || firstUpdateCall) {\n                // overflow is desired, casting never truncates\n                // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n                price1Average = FixedPoint.uq112x112(\n                    uint224(\n                        (price1Cumulative - price1CumulativeLast) / timeElapsed\n                    )\n                );\n                price1CumulativeLast = price1Cumulative;\n                blockTimestampLast = blockTimestamp;\n                if (firstUpdateCall) {\n                    firstUpdateCall = false;\n                }\n            }\n        }\n    }\n\n    /// @notice Consult the average price for a given token\n    /// @param token Price cumulative for the associated AntfarmPair's token\n    /// @param amountIn The amount to get the value of\n    /// @return amountOut Return the calculated amount (always return 0 before update has been called successfully for the first time)\n    function consult(address token, uint256 amountIn)\n        external\n        view\n        returns (uint256 amountOut)\n    {\n        if (token == token1) {\n            amountOut = price1Average.mul(amountIn).decode144();\n        } else {\n            revert InvalidToken();\n        }\n    }\n}\n"
24     },
25     "contracts/utils/AntfarmRouterErrors.sol": {
26       "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\nerror Expired();\nerror InsufficientOutputAmount();\nerror InsufficientInputAmount();\nerror InsufficientLiquidity();\nerror InsufficientMaxFee();\nerror ExcessiveInputAmount();\nerror InvalidPath();\nerror IdenticalAddresses();\nerror ZeroAddress();\n"
27     },
28     "contracts/interfaces/IERC20.sol": {
29       "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n"
30     },
31     "contracts/interfaces/IAntfarmBase.sol": {
32       "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\nimport \"./pair/IAntfarmPairState.sol\";\nimport \"./pair/IAntfarmPairEvents.sol\";\nimport \"./pair/IAntfarmPairActions.sol\";\nimport \"./pair/IAntfarmPairDerivedState.sol\";\n\ninterface IAntfarmBase is\n    IAntfarmPairState,\n    IAntfarmPairEvents,\n    IAntfarmPairActions,\n    IAntfarmPairDerivedState\n{}\n"
33     },
34     "contracts/interfaces/pair/IAntfarmPairState.sol": {
35       "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\nimport \"../IAntfarmToken.sol\";\n\ninterface IAntfarmPairState {\n    /// @notice The contract that deployed the AntfarmPair, which must adhere to the IAntfarmFactory interface\n    /// @return address The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the AntfarmPair, sorted by address\n    /// @return address The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the AntfarmPair, sorted by address\n    /// @return address The token contract address\n    function token1() external view returns (address);\n\n    /// @notice Fee associated to the AntfarmPair instance\n    /// @return uint16 Fee\n    function fee() external view returns (uint16);\n\n    /// @notice The LP tokens total circulating supply\n    /// @return uint Total LP tokens\n    function totalSupply() external view returns (uint256);\n\n    /// @notice The AntFarmPair AntFarm's tokens cumulated fees\n    /// @return uint Total Antfarm tokens\n    function antfarmTokenReserve() external view returns (uint256);\n}\n"
36     },
37     "contracts/interfaces/pair/IAntfarmPairActions.sol": {
38       "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\ninterface IAntfarmPairActions {\n    /// @notice Mint liquidity for a specific position\n    /// @dev Low-level function. Should be called from another contract which performs all necessary checks\n    /// @param to The address to mint liquidity\n    /// @param positionId The ID to store the position to allow multiple positions for a single address\n    /// @return liquidity Minted liquidity\n    function mint(address to, uint256 positionId)\n        external\n        returns (uint256 liquidity);\n\n    /// @notice Burn liquidity from a specific position\n    /// @dev Low-level function. Should be called from another contract which performs all necessary checks\n    /// @param to The address to return the liquidity to\n    /// @param positionId The ID of the position to burn liquidity from\n    /// @param liquidity Liquidity amount to be burned\n    /// @return amount0 The token0 amount received from the liquidity burn\n    /// @return amount1 The token1 amount received from the liquidity burn\n    function burn(\n        address to,\n        uint256 liquidity,\n        uint256 positionId\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap tokens\n    /// @dev Low-level function. Should be called from another contract which performs all necessary checks\n    /// @param amount0Out token0 amount to be swapped\n    /// @param amount1Out token1 amount to be swapped\n    /// @param to The address to send the swapped tokens\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to\n    ) external;\n\n    /// @notice Force balances to match reserves\n    /// @param to The address to send excessive tokens\n    function skim(address to) external;\n\n    /// @notice Force reserves to match balances\n    function sync() external;\n\n    /// @notice Claim dividends for a specific position\n    /// @param to The address to receive claimed dividends\n    /// @param positionId The ID of the position to claim\n    /// @return claimedAmount The amount claimed\n    function claimDividend(address to, uint256 positionId)\n        external\n        returns (uint256 claimedAmount);\n}\n"
39     },
40     "contracts/interfaces/pair/IAntfarmPairEvents.sol": {
41       "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\ninterface IAntfarmPairEvents {\n    /// @notice Emitted when a position's liquidity is removed\n    /// @param sender The address that initiated the burn call\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    /// @param to The address to send token0 & token1\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that initiated the mint call\n    /// @param amount0 Required token0 for the minted liquidity\n    /// @param amount1 Required token1 for the minted liquidity\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call\n    /// @param amount0In Amount of token0 sent to the pair\n    /// @param amount1In Amount of token1 sent to the pair\n    /// @param amount0Out Amount of token0 going out of the pair\n    /// @param amount1Out Amount of token1 going out of the pair\n    /// @param to Address to transfer the swapped amount\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n\n    /// @notice Emitted by the pool for any call to Sync function\n    /// @param reserve0 reserve0 updated from the pair\n    /// @param reserve1 reserve1 updated from the pair\n    event Sync(uint112 reserve0, uint112 reserve1);\n}\n"
42     },
43     "contracts/interfaces/pair/IAntfarmPairDerivedState.sol": {
44       "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\ninterface IAntfarmPairDerivedState {\n    /// @notice Get position LP tokens\n    /// @param operator Position owner\n    /// @param positionId ID of the position\n    /// @return uint128 LP tokens owned by the operator\n    function getPositionLP(address operator, uint256 positionId)\n        external\n        view\n        returns (uint128);\n\n    /// @notice Get pair reserves\n    /// @return reserve0 Reserve for token0\n    /// @return reserve1 Reserve for token1\n    /// @return blockTimestampLast Last block proceeded\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    /// @notice Get Dividend from a specific position\n    /// @param operator The address used to get dividends\n    /// @param positionId Specific position\n    /// @return amount Dividends owned by the address\n    function claimableDividends(address operator, uint256 positionId)\n        external\n        view\n        returns (uint256 amount);\n}\n"
45     },
46     "contracts/interfaces/IAntfarmToken.sol": {
47       "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\ninterface IAntfarmToken {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function burn(uint256 _amount) external;\n}\n"
48     },
49     "contracts/libraries/fixedpoint/FixedPoint.sol": {
50       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport \"./FullMath.sol\";\nimport \"./Babylonian.sol\";\nimport \"./BitMath.sol\";\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 public constant RESOLUTION = 112;\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z = 0;\n        require(y == 0 || (z = self._x * y) / y == self._x, \"FixedPoint::mul: overflow\");\n        return uq144x112(z);\n    }\n\n    // multiply a UQ112x112 by an int and decode, returning an int\n    // reverts on overflow\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\n        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\n        require(z < 2**255, \"FixedPoint::muli: overflow\");\n        return y < 0 ? -int256(z) : int256(z);\n    }\n\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\n    // lossy\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        if (self._x == 0 || other._x == 0) {\n            return uq112x112(0);\n        }\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\n\n        // partial products\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\n\n        // so the bit shift does not overflow\n        require(upper <= type(uint112).max, \"FixedPoint::muluq: upper overflow\");\n\n        // this cannot exceed 256 bits, all values are 224 bits\n        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\n\n        // so the cast does not overflow\n        require(sum <= type(uint224).max, \"FixedPoint::muluq: sum overflow\");\n\n        return uq112x112(uint224(sum));\n    }\n\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        require(other._x > 0, \"FixedPoint::divuq: division by zero\");\n        if (self._x == other._x) {\n            return uq112x112(uint224(Q112));\n        }\n        if (self._x <= type(uint144).max) {\n            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\n            require(value <= type(uint224).max, \"FixedPoint::divuq: overflow\");\n            return uq112x112(uint224(value));\n        }\n\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\n        require(result <= type(uint224).max, \"FixedPoint::divuq: overflow\");\n        return uq112x112(uint224(result));\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // can be lossy\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint::fraction: division by zero\");\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator <= type(uint144).max) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n            return uq112x112(uint224(result));\n        }\n    }\n\n    // take the reciprocal of a UQ112x112\n    // reverts on overflow\n    // lossy\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, \"FixedPoint::reciprocal: reciprocal of zero\");\n        require(self._x != 1, \"FixedPoint::reciprocal: overflow\");\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    // lossy between 0/1 and 40 bits\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        if (self._x <= type(uint144).max) {\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\n        }\n\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n        safeShiftBits -= safeShiftBits % 2;\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\n    }\n}"
51     },
52     "contracts/libraries/fixedpoint/Babylonian.sol": {
53       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}"
54     },
55     "contracts/libraries/fixedpoint/BitMath.sol": {
56       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nlibrary BitMath {\n    // returns the 0 indexed position of the most significant bit of the input x\n    // s.t. x >= 2**msb and x < 2**(msb+1)\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, \"BitMath::mostSignificantBit: zero\");\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    // returns the 0 indexed position of the least significant bit of the input x\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, \"BitMath::leastSignificantBit: zero\");\n\n        r = 255;\n        if (x & type(uint128).max > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x & type(uint64).max > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & type(uint32).max > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & type(uint16).max > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & type(uint16).max > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n    }\n}"
57     },
58     "contracts/libraries/fixedpoint/FullMath.sol": {
59       "content": "// SPDX-License-Identifier: CC-BY-4.0\npragma solidity >=0.8.0;\n\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\n// license is CC-BY-4.0\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\n        uint256 mm = mulmod(x, y, type(uint256).max);\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & (type(uint256).max - d + 1) & d;\n        d /= pow2;\n        l /= pow2;\n        l += h * (((type(uint256).max - pow2 + 1) & pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n\n        if (h == 0) return l / d;\n\n        require(h < d, \"FullMath: FULLDIV_OVERFLOW\");\n        return fullDiv(l, h, d);\n    }\n}"
60     }
61   },
62   "settings": {
63     "optimizer": {
64       "enabled": true,
65       "runs": 1000
66     },
67     "outputSelection": {
68       "*": {
69         "*": [
70           "evm.bytecode",
71           "evm.deployedBytecode",
72           "devdoc",
73           "userdoc",
74           "metadata",
75           "abi"
76         ]
77       }
78     },
79     "metadata": {
80       "useLiteralContent": true
81     },
82     "libraries": {}
83   }
84 }}