1 // File: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFRequestIDBase.sol
2 
3 
4 pragma solidity ^0.8.0;
5 
6 contract VRFRequestIDBase {
7   /**
8    * @notice returns the seed which is actually input to the VRF coordinator
9    *
10    * @dev To prevent repetition of VRF output due to repetition of the
11    * @dev user-supplied seed, that seed is combined in a hash with the
12    * @dev user-specific nonce, and the address of the consuming contract. The
13    * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in
14    * @dev the final seed, but the nonce does protect against repetition in
15    * @dev requests which are included in a single block.
16    *
17    * @param _userSeed VRF seed input provided by user
18    * @param _requester Address of the requesting contract
19    * @param _nonce User-specific nonce at the time of the request
20    */
21   function makeVRFInputSeed(
22     bytes32 _keyHash,
23     uint256 _userSeed,
24     address _requester,
25     uint256 _nonce
26   ) internal pure returns (uint256) {
27     return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));
28   }
29 
30   /**
31    * @notice Returns the id for this request
32    * @param _keyHash The serviceAgreement ID to be used for this request
33    * @param _vRFInputSeed The seed to be passed directly to the VRF
34    * @return The id for this request
35    *
36    * @dev Note that _vRFInputSeed is not the seed passed by the consuming
37    * @dev contract, but the one generated by makeVRFInputSeed
38    */
39   function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {
40     return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
41   }
42 }
43 
44 // File: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/LinkTokenInterface.sol
45 
46 
47 pragma solidity ^0.8.0;
48 
49 interface LinkTokenInterface {
50   function allowance(address owner, address spender) external view returns (uint256 remaining);
51 
52   function approve(address spender, uint256 value) external returns (bool success);
53 
54   function balanceOf(address owner) external view returns (uint256 balance);
55 
56   function decimals() external view returns (uint8 decimalPlaces);
57 
58   function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);
59 
60   function increaseApproval(address spender, uint256 subtractedValue) external;
61 
62   function name() external view returns (string memory tokenName);
63 
64   function symbol() external view returns (string memory tokenSymbol);
65 
66   function totalSupply() external view returns (uint256 totalTokensIssued);
67 
68   function transfer(address to, uint256 value) external returns (bool success);
69 
70   function transferAndCall(
71     address to,
72     uint256 value,
73     bytes calldata data
74   ) external returns (bool success);
75 
76   function transferFrom(
77     address from,
78     address to,
79     uint256 value
80   ) external returns (bool success);
81 }
82 
83 // File: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFConsumerBase.sol
84 
85 
86 pragma solidity ^0.8.0;
87 
88 
89 
90 /** ****************************************************************************
91  * @notice Interface for contracts using VRF randomness
92  * *****************************************************************************
93  * @dev PURPOSE
94  *
95  * @dev Reggie the Random Oracle (not his real job) wants to provide randomness
96  * @dev to Vera the verifier in such a way that Vera can be sure he's not
97  * @dev making his output up to suit himself. Reggie provides Vera a public key
98  * @dev to which he knows the secret key. Each time Vera provides a seed to
99  * @dev Reggie, he gives back a value which is computed completely
100  * @dev deterministically from the seed and the secret key.
101  *
102  * @dev Reggie provides a proof by which Vera can verify that the output was
103  * @dev correctly computed once Reggie tells it to her, but without that proof,
104  * @dev the output is indistinguishable to her from a uniform random sample
105  * @dev from the output space.
106  *
107  * @dev The purpose of this contract is to make it easy for unrelated contracts
108  * @dev to talk to Vera the verifier about the work Reggie is doing, to provide
109  * @dev simple access to a verifiable source of randomness.
110  * *****************************************************************************
111  * @dev USAGE
112  *
113  * @dev Calling contracts must inherit from VRFConsumerBase, and can
114  * @dev initialize VRFConsumerBase's attributes in their constructor as
115  * @dev shown:
116  *
117  * @dev   contract VRFConsumer {
118  * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)
119  * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {
120  * @dev         <initialization with other arguments goes here>
121  * @dev       }
122  * @dev   }
123  *
124  * @dev The oracle will have given you an ID for the VRF keypair they have
125  * @dev committed to (let's call it keyHash), and have told you the minimum LINK
126  * @dev price for VRF service. Make sure your contract has sufficient LINK, and
127  * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you
128  * @dev want to generate randomness from.
129  *
130  * @dev Once the VRFCoordinator has received and validated the oracle's response
131  * @dev to your request, it will call your contract's fulfillRandomness method.
132  *
133  * @dev The randomness argument to fulfillRandomness is the actual random value
134  * @dev generated from your seed.
135  *
136  * @dev The requestId argument is generated from the keyHash and the seed by
137  * @dev makeRequestId(keyHash, seed). If your contract could have concurrent
138  * @dev requests open, you can use the requestId to track which seed is
139  * @dev associated with which randomness. See VRFRequestIDBase.sol for more
140  * @dev details. (See "SECURITY CONSIDERATIONS" for principles to keep in mind,
141  * @dev if your contract could have multiple requests in flight simultaneously.)
142  *
143  * @dev Colliding `requestId`s are cryptographically impossible as long as seeds
144  * @dev differ. (Which is critical to making unpredictable randomness! See the
145  * @dev next section.)
146  *
147  * *****************************************************************************
148  * @dev SECURITY CONSIDERATIONS
149  *
150  * @dev A method with the ability to call your fulfillRandomness method directly
151  * @dev could spoof a VRF response with any random value, so it's critical that
152  * @dev it cannot be directly called by anything other than this base contract
153  * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).
154  *
155  * @dev For your users to trust that your contract's random behavior is free
156  * @dev from malicious interference, it's best if you can write it so that all
157  * @dev behaviors implied by a VRF response are executed *during* your
158  * @dev fulfillRandomness method. If your contract must store the response (or
159  * @dev anything derived from it) and use it later, you must ensure that any
160  * @dev user-significant behavior which depends on that stored value cannot be
161  * @dev manipulated by a subsequent VRF request.
162  *
163  * @dev Similarly, both miners and the VRF oracle itself have some influence
164  * @dev over the order in which VRF responses appear on the blockchain, so if
165  * @dev your contract could have multiple VRF requests in flight simultaneously,
166  * @dev you must ensure that the order in which the VRF responses arrive cannot
167  * @dev be used to manipulate your contract's user-significant behavior.
168  *
169  * @dev Since the ultimate input to the VRF is mixed with the block hash of the
170  * @dev block in which the request is made, user-provided seeds have no impact
171  * @dev on its economic security properties. They are only included for API
172  * @dev compatability with previous versions of this contract.
173  *
174  * @dev Since the block hash of the block which contains the requestRandomness
175  * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful
176  * @dev miner could, in principle, fork the blockchain to evict the block
177  * @dev containing the request, forcing the request to be included in a
178  * @dev different block with a different hash, and therefore a different input
179  * @dev to the VRF. However, such an attack would incur a substantial economic
180  * @dev cost. This cost scales with the number of blocks the VRF oracle waits
181  * @dev until it calls responds to a request.
182  */
183 abstract contract VRFConsumerBase is VRFRequestIDBase {
184   /**
185    * @notice fulfillRandomness handles the VRF response. Your contract must
186    * @notice implement it. See "SECURITY CONSIDERATIONS" above for important
187    * @notice principles to keep in mind when implementing your fulfillRandomness
188    * @notice method.
189    *
190    * @dev VRFConsumerBase expects its subcontracts to have a method with this
191    * @dev signature, and will call it once it has verified the proof
192    * @dev associated with the randomness. (It is triggered via a call to
193    * @dev rawFulfillRandomness, below.)
194    *
195    * @param requestId The Id initially returned by requestRandomness
196    * @param randomness the VRF output
197    */
198   function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;
199 
200   /**
201    * @dev In order to keep backwards compatibility we have kept the user
202    * seed field around. We remove the use of it because given that the blockhash
203    * enters later, it overrides whatever randomness the used seed provides.
204    * Given that it adds no security, and can easily lead to misunderstandings,
205    * we have removed it from usage and can now provide a simpler API.
206    */
207   uint256 private constant USER_SEED_PLACEHOLDER = 0;
208 
209   /**
210    * @notice requestRandomness initiates a request for VRF output given _seed
211    *
212    * @dev The fulfillRandomness method receives the output, once it's provided
213    * @dev by the Oracle, and verified by the vrfCoordinator.
214    *
215    * @dev The _keyHash must already be registered with the VRFCoordinator, and
216    * @dev the _fee must exceed the fee specified during registration of the
217    * @dev _keyHash.
218    *
219    * @dev The _seed parameter is vestigial, and is kept only for API
220    * @dev compatibility with older versions. It can't *hurt* to mix in some of
221    * @dev your own randomness, here, but it's not necessary because the VRF
222    * @dev oracle will mix the hash of the block containing your request into the
223    * @dev VRF seed it ultimately uses.
224    *
225    * @param _keyHash ID of public key against which randomness is generated
226    * @param _fee The amount of LINK to send with the request
227    *
228    * @return requestId unique ID for this request
229    *
230    * @dev The returned requestId can be used to distinguish responses to
231    * @dev concurrent requests. It is passed as the first argument to
232    * @dev fulfillRandomness.
233    */
234   function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {
235     LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));
236     // This is the seed passed to VRFCoordinator. The oracle will mix this with
237     // the hash of the block containing this request to obtain the seed/input
238     // which is finally passed to the VRF cryptographic machinery.
239     uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);
240     // nonces[_keyHash] must stay in sync with
241     // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above
242     // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).
243     // This provides protection against the user repeating their input seed,
244     // which would result in a predictable/duplicate output, if multiple such
245     // requests appeared in the same block.
246     nonces[_keyHash] = nonces[_keyHash] + 1;
247     return makeRequestId(_keyHash, vRFSeed);
248   }
249 
250   LinkTokenInterface internal immutable LINK;
251   address private immutable vrfCoordinator;
252 
253   // Nonces for each VRF key from which randomness has been requested.
254   //
255   // Must stay in sync with VRFCoordinator[_keyHash][this]
256   mapping(bytes32 => uint256) /* keyHash */ /* nonce */
257     private nonces;
258 
259   /**
260    * @param _vrfCoordinator address of VRFCoordinator contract
261    * @param _link address of LINK token contract
262    *
263    * @dev https://docs.chain.link/docs/link-token-contracts
264    */
265   constructor(address _vrfCoordinator, address _link) {
266     vrfCoordinator = _vrfCoordinator;
267     LINK = LinkTokenInterface(_link);
268   }
269 
270   // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF
271   // proof. rawFulfillRandomness then calls fulfillRandomness, after validating
272   // the origin of the call
273   function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {
274     require(msg.sender == vrfCoordinator, "Only VRFCoordinator can fulfill");
275     fulfillRandomness(requestId, randomness);
276   }
277 }
278 
279 // File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol
280 
281 
282 // OpenZeppelin Contracts v4.3.2 (utils/Strings.sol)
283 
284 pragma solidity ^0.8.0;
285 
286 /**
287  * @dev String operations.
288  */
289 library Strings {
290     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
291 
292     /**
293      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
294      */
295     function toString(uint256 value) internal pure returns (string memory) {
296         // Inspired by OraclizeAPI's implementation - MIT licence
297         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
298 
299         if (value == 0) {
300             return "0";
301         }
302         uint256 temp = value;
303         uint256 digits;
304         while (temp != 0) {
305             digits++;
306             temp /= 10;
307         }
308         bytes memory buffer = new bytes(digits);
309         while (value != 0) {
310             digits -= 1;
311             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
312             value /= 10;
313         }
314         return string(buffer);
315     }
316 
317     /**
318      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
319      */
320     function toHexString(uint256 value) internal pure returns (string memory) {
321         if (value == 0) {
322             return "0x00";
323         }
324         uint256 temp = value;
325         uint256 length = 0;
326         while (temp != 0) {
327             length++;
328             temp >>= 8;
329         }
330         return toHexString(value, length);
331     }
332 
333     /**
334      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
335      */
336     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
337         bytes memory buffer = new bytes(2 * length + 2);
338         buffer[0] = "0";
339         buffer[1] = "x";
340         for (uint256 i = 2 * length + 1; i > 1; --i) {
341             buffer[i] = _HEX_SYMBOLS[value & 0xf];
342             value >>= 4;
343         }
344         require(value == 0, "Strings: hex length insufficient");
345         return string(buffer);
346     }
347 }
348 
349 // File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol
350 
351 
352 // OpenZeppelin Contracts v4.3.2 (utils/Context.sol)
353 
354 pragma solidity ^0.8.0;
355 
356 /**
357  * @dev Provides information about the current execution context, including the
358  * sender of the transaction and its data. While these are generally available
359  * via msg.sender and msg.data, they should not be accessed in such a direct
360  * manner, since when dealing with meta-transactions the account sending and
361  * paying for execution may not be the actual sender (as far as an application
362  * is concerned).
363  *
364  * This contract is only required for intermediate, library-like contracts.
365  */
366 abstract contract Context {
367     function _msgSender() internal view virtual returns (address) {
368         return msg.sender;
369     }
370 
371     function _msgData() internal view virtual returns (bytes calldata) {
372         return msg.data;
373     }
374 }
375 
376 // File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol
377 
378 
379 // OpenZeppelin Contracts v4.3.2 (access/Ownable.sol)
380 
381 pragma solidity ^0.8.0;
382 
383 
384 /**
385  * @dev Contract module which provides a basic access control mechanism, where
386  * there is an account (an owner) that can be granted exclusive access to
387  * specific functions.
388  *
389  * By default, the owner account will be the one that deploys the contract. This
390  * can later be changed with {transferOwnership}.
391  *
392  * This module is used through inheritance. It will make available the modifier
393  * `onlyOwner`, which can be applied to your functions to restrict their use to
394  * the owner.
395  */
396 abstract contract Ownable is Context {
397     address private _owner;
398 
399     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
400 
401     /**
402      * @dev Initializes the contract setting the deployer as the initial owner.
403      */
404     constructor() {
405         _transferOwnership(_msgSender());
406     }
407 
408     /**
409      * @dev Returns the address of the current owner.
410      */
411     function owner() public view virtual returns (address) {
412         return _owner;
413     }
414 
415     /**
416      * @dev Throws if called by any account other than the owner.
417      */
418     modifier onlyOwner() {
419         require(owner() == _msgSender(), "Ownable: caller is not the owner");
420         _;
421     }
422 
423     /**
424      * @dev Leaves the contract without owner. It will not be possible to call
425      * `onlyOwner` functions anymore. Can only be called by the current owner.
426      *
427      * NOTE: Renouncing ownership will leave the contract without an owner,
428      * thereby removing any functionality that is only available to the owner.
429      */
430     function renounceOwnership() public virtual onlyOwner {
431         _transferOwnership(address(0));
432     }
433 
434     /**
435      * @dev Transfers ownership of the contract to a new account (`newOwner`).
436      * Can only be called by the current owner.
437      */
438     function transferOwnership(address newOwner) public virtual onlyOwner {
439         require(newOwner != address(0), "Ownable: new owner is the zero address");
440         _transferOwnership(newOwner);
441     }
442 
443     /**
444      * @dev Transfers ownership of the contract to a new account (`newOwner`).
445      * Internal function without access restriction.
446      */
447     function _transferOwnership(address newOwner) internal virtual {
448         address oldOwner = _owner;
449         _owner = newOwner;
450         emit OwnershipTransferred(oldOwner, newOwner);
451     }
452 }
453 
454 // File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol
455 
456 
457 // OpenZeppelin Contracts v4.3.2 (utils/Address.sol)
458 
459 pragma solidity ^0.8.0;
460 
461 /**
462  * @dev Collection of functions related to the address type
463  */
464 library Address {
465     /**
466      * @dev Returns true if `account` is a contract.
467      *
468      * [IMPORTANT]
469      * ====
470      * It is unsafe to assume that an address for which this function returns
471      * false is an externally-owned account (EOA) and not a contract.
472      *
473      * Among others, `isContract` will return false for the following
474      * types of addresses:
475      *
476      *  - an externally-owned account
477      *  - a contract in construction
478      *  - an address where a contract will be created
479      *  - an address where a contract lived, but was destroyed
480      * ====
481      */
482     function isContract(address account) internal view returns (bool) {
483         // This method relies on extcodesize, which returns 0 for contracts in
484         // construction, since the code is only stored at the end of the
485         // constructor execution.
486 
487         uint256 size;
488         assembly {
489             size := extcodesize(account)
490         }
491         return size > 0;
492     }
493 
494     /**
495      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
496      * `recipient`, forwarding all available gas and reverting on errors.
497      *
498      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
499      * of certain opcodes, possibly making contracts go over the 2300 gas limit
500      * imposed by `transfer`, making them unable to receive funds via
501      * `transfer`. {sendValue} removes this limitation.
502      *
503      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
504      *
505      * IMPORTANT: because control is transferred to `recipient`, care must be
506      * taken to not create reentrancy vulnerabilities. Consider using
507      * {ReentrancyGuard} or the
508      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
509      */
510     function sendValue(address payable recipient, uint256 amount) internal {
511         require(address(this).balance >= amount, "Address: insufficient balance");
512 
513         (bool success, ) = recipient.call{value: amount}("");
514         require(success, "Address: unable to send value, recipient may have reverted");
515     }
516 
517     /**
518      * @dev Performs a Solidity function call using a low level `call`. A
519      * plain `call` is an unsafe replacement for a function call: use this
520      * function instead.
521      *
522      * If `target` reverts with a revert reason, it is bubbled up by this
523      * function (like regular Solidity function calls).
524      *
525      * Returns the raw returned data. To convert to the expected return value,
526      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
527      *
528      * Requirements:
529      *
530      * - `target` must be a contract.
531      * - calling `target` with `data` must not revert.
532      *
533      * _Available since v3.1._
534      */
535     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
536         return functionCall(target, data, "Address: low-level call failed");
537     }
538 
539     /**
540      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
541      * `errorMessage` as a fallback revert reason when `target` reverts.
542      *
543      * _Available since v3.1._
544      */
545     function functionCall(
546         address target,
547         bytes memory data,
548         string memory errorMessage
549     ) internal returns (bytes memory) {
550         return functionCallWithValue(target, data, 0, errorMessage);
551     }
552 
553     /**
554      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
555      * but also transferring `value` wei to `target`.
556      *
557      * Requirements:
558      *
559      * - the calling contract must have an ETH balance of at least `value`.
560      * - the called Solidity function must be `payable`.
561      *
562      * _Available since v3.1._
563      */
564     function functionCallWithValue(
565         address target,
566         bytes memory data,
567         uint256 value
568     ) internal returns (bytes memory) {
569         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
570     }
571 
572     /**
573      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
574      * with `errorMessage` as a fallback revert reason when `target` reverts.
575      *
576      * _Available since v3.1._
577      */
578     function functionCallWithValue(
579         address target,
580         bytes memory data,
581         uint256 value,
582         string memory errorMessage
583     ) internal returns (bytes memory) {
584         require(address(this).balance >= value, "Address: insufficient balance for call");
585         require(isContract(target), "Address: call to non-contract");
586 
587         (bool success, bytes memory returndata) = target.call{value: value}(data);
588         return verifyCallResult(success, returndata, errorMessage);
589     }
590 
591     /**
592      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
593      * but performing a static call.
594      *
595      * _Available since v3.3._
596      */
597     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
598         return functionStaticCall(target, data, "Address: low-level static call failed");
599     }
600 
601     /**
602      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
603      * but performing a static call.
604      *
605      * _Available since v3.3._
606      */
607     function functionStaticCall(
608         address target,
609         bytes memory data,
610         string memory errorMessage
611     ) internal view returns (bytes memory) {
612         require(isContract(target), "Address: static call to non-contract");
613 
614         (bool success, bytes memory returndata) = target.staticcall(data);
615         return verifyCallResult(success, returndata, errorMessage);
616     }
617 
618     /**
619      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
620      * but performing a delegate call.
621      *
622      * _Available since v3.4._
623      */
624     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
625         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
626     }
627 
628     /**
629      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
630      * but performing a delegate call.
631      *
632      * _Available since v3.4._
633      */
634     function functionDelegateCall(
635         address target,
636         bytes memory data,
637         string memory errorMessage
638     ) internal returns (bytes memory) {
639         require(isContract(target), "Address: delegate call to non-contract");
640 
641         (bool success, bytes memory returndata) = target.delegatecall(data);
642         return verifyCallResult(success, returndata, errorMessage);
643     }
644 
645     /**
646      * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
647      * revert reason using the provided one.
648      *
649      * _Available since v4.3._
650      */
651     function verifyCallResult(
652         bool success,
653         bytes memory returndata,
654         string memory errorMessage
655     ) internal pure returns (bytes memory) {
656         if (success) {
657             return returndata;
658         } else {
659             // Look for revert reason and bubble it up if present
660             if (returndata.length > 0) {
661                 // The easiest way to bubble the revert reason is using memory via assembly
662 
663                 assembly {
664                     let returndata_size := mload(returndata)
665                     revert(add(32, returndata), returndata_size)
666                 }
667             } else {
668                 revert(errorMessage);
669             }
670         }
671     }
672 }
673 
674 // File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/IERC721Receiver.sol
675 
676 
677 // OpenZeppelin Contracts v4.3.2 (token/ERC721/IERC721Receiver.sol)
678 
679 pragma solidity ^0.8.0;
680 
681 /**
682  * @title ERC721 token receiver interface
683  * @dev Interface for any contract that wants to support safeTransfers
684  * from ERC721 asset contracts.
685  */
686 interface IERC721Receiver {
687     /**
688      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
689      * by `operator` from `from`, this function is called.
690      *
691      * It must return its Solidity selector to confirm the token transfer.
692      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
693      *
694      * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
695      */
696     function onERC721Received(
697         address operator,
698         address from,
699         uint256 tokenId,
700         bytes calldata data
701     ) external returns (bytes4);
702 }
703 
704 // File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol
705 
706 
707 // OpenZeppelin Contracts v4.3.2 (utils/introspection/IERC165.sol)
708 
709 pragma solidity ^0.8.0;
710 
711 /**
712  * @dev Interface of the ERC165 standard, as defined in the
713  * https://eips.ethereum.org/EIPS/eip-165[EIP].
714  *
715  * Implementers can declare support of contract interfaces, which can then be
716  * queried by others ({ERC165Checker}).
717  *
718  * For an implementation, see {ERC165}.
719  */
720 interface IERC165 {
721     /**
722      * @dev Returns true if this contract implements the interface defined by
723      * `interfaceId`. See the corresponding
724      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
725      * to learn more about how these ids are created.
726      *
727      * This function call must use less than 30 000 gas.
728      */
729     function supportsInterface(bytes4 interfaceId) external view returns (bool);
730 }
731 
732 // File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165.sol
733 
734 
735 // OpenZeppelin Contracts v4.3.2 (utils/introspection/ERC165.sol)
736 
737 pragma solidity ^0.8.0;
738 
739 
740 /**
741  * @dev Implementation of the {IERC165} interface.
742  *
743  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
744  * for the additional interface id that will be supported. For example:
745  *
746  * ```solidity
747  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
748  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
749  * }
750  * ```
751  *
752  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
753  */
754 abstract contract ERC165 is IERC165 {
755     /**
756      * @dev See {IERC165-supportsInterface}.
757      */
758     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
759         return interfaceId == type(IERC165).interfaceId;
760     }
761 }
762 
763 // File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/IERC721.sol
764 
765 
766 // OpenZeppelin Contracts v4.3.2 (token/ERC721/IERC721.sol)
767 
768 pragma solidity ^0.8.0;
769 
770 
771 /**
772  * @dev Required interface of an ERC721 compliant contract.
773  */
774 interface IERC721 is IERC165 {
775     /**
776      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
777      */
778     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
779 
780     /**
781      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
782      */
783     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
784 
785     /**
786      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
787      */
788     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
789 
790     /**
791      * @dev Returns the number of tokens in ``owner``'s account.
792      */
793     function balanceOf(address owner) external view returns (uint256 balance);
794 
795     /**
796      * @dev Returns the owner of the `tokenId` token.
797      *
798      * Requirements:
799      *
800      * - `tokenId` must exist.
801      */
802     function ownerOf(uint256 tokenId) external view returns (address owner);
803 
804     /**
805      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
806      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
807      *
808      * Requirements:
809      *
810      * - `from` cannot be the zero address.
811      * - `to` cannot be the zero address.
812      * - `tokenId` token must exist and be owned by `from`.
813      * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
814      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
815      *
816      * Emits a {Transfer} event.
817      */
818     function safeTransferFrom(
819         address from,
820         address to,
821         uint256 tokenId
822     ) external;
823 
824     /**
825      * @dev Transfers `tokenId` token from `from` to `to`.
826      *
827      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
828      *
829      * Requirements:
830      *
831      * - `from` cannot be the zero address.
832      * - `to` cannot be the zero address.
833      * - `tokenId` token must be owned by `from`.
834      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
835      *
836      * Emits a {Transfer} event.
837      */
838     function transferFrom(
839         address from,
840         address to,
841         uint256 tokenId
842     ) external;
843 
844     /**
845      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
846      * The approval is cleared when the token is transferred.
847      *
848      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
849      *
850      * Requirements:
851      *
852      * - The caller must own the token or be an approved operator.
853      * - `tokenId` must exist.
854      *
855      * Emits an {Approval} event.
856      */
857     function approve(address to, uint256 tokenId) external;
858 
859     /**
860      * @dev Returns the account approved for `tokenId` token.
861      *
862      * Requirements:
863      *
864      * - `tokenId` must exist.
865      */
866     function getApproved(uint256 tokenId) external view returns (address operator);
867 
868     /**
869      * @dev Approve or remove `operator` as an operator for the caller.
870      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
871      *
872      * Requirements:
873      *
874      * - The `operator` cannot be the caller.
875      *
876      * Emits an {ApprovalForAll} event.
877      */
878     function setApprovalForAll(address operator, bool _approved) external;
879 
880     /**
881      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
882      *
883      * See {setApprovalForAll}
884      */
885     function isApprovedForAll(address owner, address operator) external view returns (bool);
886 
887     /**
888      * @dev Safely transfers `tokenId` token from `from` to `to`.
889      *
890      * Requirements:
891      *
892      * - `from` cannot be the zero address.
893      * - `to` cannot be the zero address.
894      * - `tokenId` token must exist and be owned by `from`.
895      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
896      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
897      *
898      * Emits a {Transfer} event.
899      */
900     function safeTransferFrom(
901         address from,
902         address to,
903         uint256 tokenId,
904         bytes calldata data
905     ) external;
906 }
907 
908 // File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/extensions/IERC721Metadata.sol
909 
910 
911 // OpenZeppelin Contracts v4.3.2 (token/ERC721/extensions/IERC721Metadata.sol)
912 
913 pragma solidity ^0.8.0;
914 
915 
916 /**
917  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
918  * @dev See https://eips.ethereum.org/EIPS/eip-721
919  */
920 interface IERC721Metadata is IERC721 {
921     /**
922      * @dev Returns the token collection name.
923      */
924     function name() external view returns (string memory);
925 
926     /**
927      * @dev Returns the token collection symbol.
928      */
929     function symbol() external view returns (string memory);
930 
931     /**
932      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
933      */
934     function tokenURI(uint256 tokenId) external view returns (string memory);
935 }
936 
937 // File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol
938 
939 
940 // OpenZeppelin Contracts v4.3.2 (token/ERC721/ERC721.sol)
941 
942 pragma solidity ^0.8.0;
943 
944 
945 
946 
947 
948 
949 
950 
951 /**
952  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
953  * the Metadata extension, but not including the Enumerable extension, which is available separately as
954  * {ERC721Enumerable}.
955  */
956 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
957     using Address for address;
958     using Strings for uint256;
959 
960     // Token name
961     string private _name;
962 
963     // Token symbol
964     string private _symbol;
965 
966     // Mapping from token ID to owner address
967     mapping(uint256 => address) private _owners;
968 
969     // Mapping owner address to token count
970     mapping(address => uint256) private _balances;
971 
972     // Mapping from token ID to approved address
973     mapping(uint256 => address) private _tokenApprovals;
974 
975     // Mapping from owner to operator approvals
976     mapping(address => mapping(address => bool)) private _operatorApprovals;
977 
978     /**
979      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
980      */
981     constructor(string memory name_, string memory symbol_) {
982         _name = name_;
983         _symbol = symbol_;
984     }
985 
986     /**
987      * @dev See {IERC165-supportsInterface}.
988      */
989     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
990         return
991             interfaceId == type(IERC721).interfaceId ||
992             interfaceId == type(IERC721Metadata).interfaceId ||
993             super.supportsInterface(interfaceId);
994     }
995 
996     /**
997      * @dev See {IERC721-balanceOf}.
998      */
999     function balanceOf(address owner) public view virtual override returns (uint256) {
1000         require(owner != address(0), "ERC721: balance query for the zero address");
1001         return _balances[owner];
1002     }
1003 
1004     /**
1005      * @dev See {IERC721-ownerOf}.
1006      */
1007     // 0xInuarashi was here...
1008     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
1009         return _owners[tokenId];
1010     }
1011 
1012     /**
1013      * @dev See {IERC721Metadata-name}.
1014      */
1015     function name() public view virtual override returns (string memory) {
1016         return _name;
1017     }
1018 
1019     /**
1020      * @dev See {IERC721Metadata-symbol}.
1021      */
1022     function symbol() public view virtual override returns (string memory) {
1023         return _symbol;
1024     }
1025 
1026     /**
1027      * @dev See {IERC721Metadata-tokenURI}.
1028      */
1029     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
1030         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1031 
1032         string memory baseURI = _baseURI();
1033         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
1034     }
1035 
1036     /**
1037      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
1038      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
1039      * by default, can be overriden in child contracts.
1040      */
1041     function _baseURI() internal view virtual returns (string memory) {
1042         return "";
1043     }
1044 
1045     /**
1046      * @dev See {IERC721-approve}.
1047      */
1048     function approve(address to, uint256 tokenId) public virtual override {
1049         address owner = ERC721.ownerOf(tokenId);
1050         require(to != owner, "ERC721: approval to current owner");
1051 
1052         require(
1053             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
1054             "ERC721: approve caller is not owner nor approved for all"
1055         );
1056 
1057         _approve(to, tokenId);
1058     }
1059 
1060     /**
1061      * @dev See {IERC721-getApproved}.
1062      */
1063     function getApproved(uint256 tokenId) public view virtual override returns (address) {
1064         require(_exists(tokenId), "ERC721: approved query for nonexistent token");
1065 
1066         return _tokenApprovals[tokenId];
1067     }
1068 
1069     /**
1070      * @dev See {IERC721-setApprovalForAll}.
1071      */
1072     function setApprovalForAll(address operator, bool approved) public virtual override {
1073         _setApprovalForAll(_msgSender(), operator, approved);
1074     }
1075 
1076     /**
1077      * @dev See {IERC721-isApprovedForAll}.
1078      */
1079     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
1080         return _operatorApprovals[owner][operator];
1081     }
1082 
1083     /**
1084      * @dev See {IERC721-transferFrom}.
1085      */
1086     function transferFrom(
1087         address from,
1088         address to,
1089         uint256 tokenId
1090     ) public virtual override {
1091         //solhint-disable-next-line max-line-length
1092         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
1093 
1094         _transfer(from, to, tokenId);
1095     }
1096 
1097     /**
1098      * @dev See {IERC721-safeTransferFrom}.
1099      */
1100     function safeTransferFrom(
1101         address from,
1102         address to,
1103         uint256 tokenId
1104     ) public virtual override {
1105         safeTransferFrom(from, to, tokenId, "");
1106     }
1107 
1108     /**
1109      * @dev See {IERC721-safeTransferFrom}.
1110      */
1111     function safeTransferFrom(
1112         address from,
1113         address to,
1114         uint256 tokenId,
1115         bytes memory _data
1116     ) public virtual override {
1117         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
1118         _safeTransfer(from, to, tokenId, _data);
1119     }
1120 
1121     /**
1122      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
1123      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
1124      *
1125      * `_data` is additional data, it has no specified format and it is sent in call to `to`.
1126      *
1127      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
1128      * implement alternative mechanisms to perform token transfer, such as signature-based.
1129      *
1130      * Requirements:
1131      *
1132      * - `from` cannot be the zero address.
1133      * - `to` cannot be the zero address.
1134      * - `tokenId` token must exist and be owned by `from`.
1135      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1136      *
1137      * Emits a {Transfer} event.
1138      */
1139     function _safeTransfer(
1140         address from,
1141         address to,
1142         uint256 tokenId,
1143         bytes memory _data
1144     ) internal virtual {
1145         _transfer(from, to, tokenId);
1146         require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
1147     }
1148 
1149     /**
1150      * @dev Returns whether `tokenId` exists.
1151      *
1152      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
1153      *
1154      * Tokens start existing when they are minted (`_mint`),
1155      * and stop existing when they are burned (`_burn`).
1156      */
1157     function _exists(uint256 tokenId) internal view virtual returns (bool) {
1158         return _owners[tokenId] != address(0);
1159     }
1160 
1161     /**
1162      * @dev Returns whether `spender` is allowed to manage `tokenId`.
1163      *
1164      * Requirements:
1165      *
1166      * - `tokenId` must exist.
1167      */
1168     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
1169         require(_exists(tokenId), "ERC721: operator query for nonexistent token");
1170         address owner = ERC721.ownerOf(tokenId);
1171         return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
1172     }
1173 
1174     /**
1175      * @dev Safely mints `tokenId` and transfers it to `to`.
1176      *
1177      * Requirements:
1178      *
1179      * - `tokenId` must not exist.
1180      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1181      *
1182      * Emits a {Transfer} event.
1183      */
1184     function _safeMint(address to, uint256 tokenId) internal virtual {
1185         _safeMint(to, tokenId, "");
1186     }
1187 
1188     /**
1189      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
1190      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
1191      */
1192     function _safeMint(
1193         address to,
1194         uint256 tokenId,
1195         bytes memory _data
1196     ) internal virtual {
1197         _mint(to, tokenId);
1198         require(
1199             _checkOnERC721Received(address(0), to, tokenId, _data),
1200             "ERC721: transfer to non ERC721Receiver implementer"
1201         );
1202     }
1203 
1204     /**
1205      * @dev Mints `tokenId` and transfers it to `to`.
1206      *
1207      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
1208      *
1209      * Requirements:
1210      *
1211      * - `tokenId` must not exist.
1212      * - `to` cannot be the zero address.
1213      *
1214      * Emits a {Transfer} event.
1215      */
1216     function _mint(address to, uint256 tokenId) internal virtual {
1217         require(to != address(0), "ERC721: mint to the zero address");
1218         require(!_exists(tokenId), "ERC721: token already minted");
1219 
1220         _beforeTokenTransfer(address(0), to, tokenId);
1221 
1222         _balances[to] += 1;
1223         _owners[tokenId] = to;
1224 
1225         emit Transfer(address(0), to, tokenId);
1226     }
1227 
1228     /**
1229      * @dev Destroys `tokenId`.
1230      * The approval is cleared when the token is burned.
1231      *
1232      * Requirements:
1233      *
1234      * - `tokenId` must exist.
1235      *
1236      * Emits a {Transfer} event.
1237      */
1238     function _burn(uint256 tokenId) internal virtual {
1239         address owner = ERC721.ownerOf(tokenId);
1240 
1241         _beforeTokenTransfer(owner, address(0), tokenId);
1242 
1243         // Clear approvals
1244         _approve(address(0), tokenId);
1245 
1246         _balances[owner] -= 1;
1247         delete _owners[tokenId];
1248 
1249         emit Transfer(owner, address(0), tokenId);
1250     }
1251 
1252     /**
1253      * @dev Transfers `tokenId` from `from` to `to`.
1254      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
1255      *
1256      * Requirements:
1257      *
1258      * - `to` cannot be the zero address.
1259      * - `tokenId` token must be owned by `from`.
1260      *
1261      * Emits a {Transfer} event.
1262      */
1263     function _transfer(
1264         address from,
1265         address to,
1266         uint256 tokenId
1267     ) internal virtual {
1268         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
1269         require(to != address(0), "ERC721: transfer to the zero address");
1270 
1271         _beforeTokenTransfer(from, to, tokenId);
1272 
1273         // Clear approvals from the previous owner
1274         _approve(address(0), tokenId);
1275 
1276         _balances[from] -= 1;
1277         _balances[to] += 1;
1278         _owners[tokenId] = to;
1279 
1280         emit Transfer(from, to, tokenId);
1281     }
1282 
1283     /**
1284      * @dev Approve `to` to operate on `tokenId`
1285      *
1286      * Emits a {Approval} event.
1287      */
1288     function _approve(address to, uint256 tokenId) internal virtual {
1289         _tokenApprovals[tokenId] = to;
1290         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
1291     }
1292 
1293     /**
1294      * @dev Approve `operator` to operate on all of `owner` tokens
1295      *
1296      * Emits a {ApprovalForAll} event.
1297      */
1298     function _setApprovalForAll(
1299         address owner,
1300         address operator,
1301         bool approved
1302     ) internal virtual {
1303         require(owner != operator, "ERC721: approve to caller");
1304         _operatorApprovals[owner][operator] = approved;
1305         emit ApprovalForAll(owner, operator, approved);
1306     }
1307 
1308     /**
1309      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
1310      * The call is not executed if the target address is not a contract.
1311      *
1312      * @param from address representing the previous owner of the given token ID
1313      * @param to target address that will receive the tokens
1314      * @param tokenId uint256 ID of the token to be transferred
1315      * @param _data bytes optional data to send along with the call
1316      * @return bool whether the call correctly returned the expected magic value
1317      */
1318     function _checkOnERC721Received(
1319         address from,
1320         address to,
1321         uint256 tokenId,
1322         bytes memory _data
1323     ) private returns (bool) {
1324         if (to.isContract()) {
1325             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
1326                 return retval == IERC721Receiver.onERC721Received.selector;
1327             } catch (bytes memory reason) {
1328                 if (reason.length == 0) {
1329                     revert("ERC721: transfer to non ERC721Receiver implementer");
1330                 } else {
1331                     assembly {
1332                         revert(add(32, reason), mload(reason))
1333                     }
1334                 }
1335             }
1336         } else {
1337             return true;
1338         }
1339     }
1340 
1341     /**
1342      * @dev Hook that is called before any token transfer. This includes minting
1343      * and burning.
1344      *
1345      * Calling conditions:
1346      *
1347      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1348      * transferred to `to`.
1349      * - When `from` is zero, `tokenId` will be minted for `to`.
1350      * - When `to` is zero, ``from``'s `tokenId` will be burned.
1351      * - `from` and `to` are never both zero.
1352      *
1353      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1354      */
1355     function _beforeTokenTransfer(
1356         address from,
1357         address to,
1358         uint256 tokenId
1359     ) internal virtual {}
1360 }
1361 
1362 // File: generativefungi.sol
1363 
1364 //SPDX-License-Identifier: MIT
1365 
1366 //                                             
1367 //                                    
1368 //                                     
1369 //                                   
1370 //                             
1371 //                                            
1372 
1373 pragma solidity ^0.8.0;
1374 
1375 
1376 
1377 
1378 contract nonFungibleFungiGenerative is ERC721, Ownable, VRFConsumerBase {
1379     /* Created by: 0xInuarashi
1380     Discord: 0xInuarashi#1234
1381     Twitter: https://twitter.com/0xinuarashi
1382 
1383     NonFungibleFungi Generative
1384     Features: 
1385         1. VRF Random Generator [X]
1386         2. Mint for MintPass [X] */
1387 
1388     /*
1389     This is for Rinkeby
1390     constructor() ERC721("Non Fungible Fungi", "NFF") 
1391     VRFConsumerBase(
1392         0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B,
1393         0x01BE23585060835E02B77ef475b0Cc51aA1e0709
1394     ) {
1395         keyHash = 0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311;
1396         fee = 0.1 * (10**18);
1397     }
1398     */
1399 
1400     // This is for Mainnet
1401     constructor() ERC721("Non Fungible Fungi", "NFF") 
1402     VRFConsumerBase(
1403         0xf0d54349aDdcf704F77AE15b96510dEA15cb7952,
1404         0x514910771AF9Ca656af840dff83E8264EcF986CA
1405     ) {
1406         keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445;
1407         fee = 2 * (10**18);
1408     }
1409 
1410     // General NFT Variables
1411     uint public constant maxTokens = 10000;
1412     uint public totalSupply = 0;
1413 
1414     string internal baseTokenURI;
1415     string internal baseTokenURI_EXT;
1416 
1417     event Mint(address indexed to, uint mintPassId, uint tokenId);
1418 
1419     modifier onlySender {
1420         require(msg.sender == tx.origin, "No smart contracts!");
1421         _;
1422     }
1423 
1424     // Withdraw Ether
1425     function withdrawEther() public onlyOwner {
1426         payable(msg.sender).transfer(address(this).balance); 
1427     }
1428 
1429 
1430     // Mint Pass Interfacing
1431     address public mintPassAddress;
1432     IERC721 MintPass;
1433 
1434     function setMintPass(address address_) public onlyOwner {
1435         mintPassAddress = address_;
1436         MintPass = IERC721(address_);
1437     }
1438 
1439     ////////////////////////// VRF /////////////////////////////
1440     bytes32 internal keyHash;
1441     uint internal fee;
1442     uint internal randomResult;
1443     
1444     // VRF Functions
1445     function getRandomNumber() public onlyOwner returns (bytes32 requestId) {
1446         require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK!");
1447         return requestRandomness(keyHash, fee);
1448     }
1449     function fulfillRandomness(bytes32 requestId, uint randomness) internal override {
1450         randomResult = randomness;
1451     }    
1452     function getRandomResult() public view onlyOwner returns (uint) {
1453         return randomResult;
1454     }
1455 
1456     // >>> Now, the VRF is stored in [uint internal randomResult]
1457     ////////////////////////// VRF /////////////////////////////
1458 
1459     /////////////////////// Token ID Generator ////////////////////////
1460     // ** Thanks LarvaLabs for this big brain method. **             //
1461     // This function is modified by 0xInuarashi                      //
1462     // and now includes the usage of generated input from VRF.       //
1463     ///////////////////////////////////////////////////////////////////
1464 
1465     uint[maxTokens] internal indices;
1466     uint32 internal nonce;
1467 
1468     function getVRFRandomIndex(uint tokenId_) internal returns (uint) {
1469         require(randomResult != 0, "VRF Random Result has not been set!");
1470         uint _tokensRemaining = maxTokens - totalSupply; // require that this calculation is possible from all caller functions
1471         uint _maxIndex = _tokensRemaining == 0 ? 0 : _tokensRemaining - 1; // shorthand if for safety 
1472         uint _rand = uint(keccak256(abi.encodePacked(randomResult, nonce, tokenId_, msg.sender, block.difficulty, block.timestamp))) % _tokensRemaining; // magic random
1473     
1474         uint _output = 0;
1475 
1476         _output = indices[_rand] != 0 ? indices[_rand] :_rand;
1477         indices[_rand] = indices[_maxIndex] == 0 ? _maxIndex : indices[_maxIndex];
1478 
1479         uint32 _nonceAdd = uint32(uint256(keccak256(abi.encodePacked(randomResult, nonce, tokenId_, msg.sender, block.difficulty, block.timestamp)))) % 10; // magic nonce
1480         nonce += _nonceAdd; // increase nonce
1481 
1482         return _output;
1483     }
1484 
1485     /////////////////////// Token ID Generator ////////////////////////
1486 
1487     // Minting with MintPass, It uses VRF and Token ID Generator
1488     bool public mintWithPassEnabled;
1489 
1490     // mapping(uint => uint) mintPassUsed; // some safety
1491 
1492     modifier mintWithPass {
1493         require(mintWithPassEnabled, "Minting with Mint Pass is not enabled yet!");
1494         _;
1495     }
1496 
1497     function setMintWithPassStatus(bool bool_) public onlyOwner {
1498         mintWithPassEnabled = bool_;
1499     }
1500 
1501     function mintWithMintPass(uint mintPassId_) public onlySender mintWithPass {
1502         require(msg.sender == MintPass.ownerOf(mintPassId_), "You are not the owner of this mint pass!");
1503         require(maxTokens > totalSupply, "No more available tokens!");
1504 
1505         // require(mintPassUsed[mintPassId_] == 0, "This mint pass is already used!"); // this should never happen
1506         // mintPassUsed[mintPassId_]++; // increment this mapping as used
1507 
1508         MintPass.transferFrom(msg.sender, address(this), mintPassId_); // transfer the mint pass to this address (equivalent to burning it)
1509 
1510         uint _mintId = getVRFRandomIndex(mintPassId_);
1511         totalSupply++;
1512 
1513         _mint(msg.sender, _mintId);
1514         emit Mint(msg.sender, mintPassId_, _mintId);
1515     }
1516 
1517     function multiMintWithMintPass(uint[] memory mintPassIds_) public onlySender mintWithPass {
1518         for (uint i = 0; i < mintPassIds_.length; i++) {
1519             mintWithMintPass(mintPassIds_[i]);
1520         }
1521     }
1522 
1523     // 0xInuarashi Custom Functions (Saves Gas!)
1524     function multiTransferFrom(address from_, address to_, uint256[] memory tokenIds_) public {
1525         for (uint256 i = 0; i < tokenIds_.length; i++) {
1526             transferFrom(from_, to_, tokenIds_[i]);
1527         }
1528     }
1529     function multiSafeTransferFrom(address from_, address to_, uint256[] memory tokenIds_, bytes memory data_) public {
1530         for (uint256 i = 0; i < tokenIds_.length; i++) {
1531             safeTransferFrom(from_, to_, tokenIds_[i], data_);
1532         }
1533     }
1534 
1535     // General NFT Administration
1536     function setBaseTokenURI(string memory uri_) external onlyOwner {
1537         baseTokenURI = uri_;
1538     }
1539     function setBaseTokenURI_EXT(string memory ext_) external onlyOwner {
1540         baseTokenURI_EXT = ext_;
1541     }
1542 
1543     // View Functions
1544     function tokenURI(uint tokenId_) public view override returns (string memory) {
1545         require(_exists(tokenId_), "Query for non-existent token!");
1546         return string(abi.encodePacked(baseTokenURI, Strings.toString(tokenId_), baseTokenURI_EXT));
1547     }
1548     function walletOfOwner(address address_) public view returns (uint[] memory) {
1549         uint _balance = balanceOf(address_); // get balance of address
1550         uint[] memory _tokens = new uint[](_balance); // initialize array 
1551         uint _index;
1552         for (uint i = 0; i < maxTokens; i++) {
1553             if (address_ == ownerOf(i)) { _tokens[_index] = i; _index++; }
1554         }
1555         return _tokens;
1556     }
1557 }