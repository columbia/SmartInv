1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/GHSTStakingDiamond.sol": {
5       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.3;\r\npragma experimental ABIEncoderV2;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge\r\n* Aavegotchi GHST Staking Diamond\r\n* 18 October 2020\r\n* \r\n* \r\n* Uses the diamond-2, version 1.3.4, diamond implementation:\r\n* https://github.com/mudgen/diamond-2\r\n/******************************************************************************/\r\n\r\nimport \"./libraries/LibDiamond.sol\";\r\nimport \"./interfaces/IDiamondLoupe.sol\";\r\nimport \"./interfaces/IDiamondCut.sol\";\r\nimport \"./interfaces/IERC173.sol\";\r\nimport \"./interfaces/IERC165.sol\";\r\nimport \"./libraries/AppStorage.sol\";\r\nimport \"./interfaces/IERC1155Metadata_URI.sol\";\r\n\r\ncontract GHSTStakingDiamond {\r\n    AppStorage s;\r\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\r\n\r\n    constructor(\r\n        IDiamondCut.FacetCut[] memory _diamondCut,\r\n        address _owner,\r\n        address _ghstContract,\r\n        address _uniV2PoolContract\r\n    ) {\r\n        require(_owner != address(0), \"GHSTStakingDiamond: _owner can't be address(0)\");\r\n        require(_ghstContract != address(0), \"GHSTStakingDiamond: _ghstContract can't be address(0)\");\r\n        require(_uniV2PoolContract != address(0), \"GHSTStakingDiamond: _uniV2PoolContract can't be address(0)\");\r\n\r\n        LibDiamond.diamondCut(_diamondCut, address(0), new bytes(0));\r\n        LibDiamond.setContractOwner(_owner);\r\n\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n\r\n        s.ghstContract = _ghstContract;\r\n        s.uniV2PoolContract = _uniV2PoolContract;\r\n        s.ticketsBaseUri = \"https://aavegotchi.com/metadata/\";\r\n\r\n        // adding ERC165 data\r\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\r\n        //ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\r\n\r\n        // ERC1155\r\n        // ERC165 identifier for the main token standard.\r\n        ds.supportedInterfaces[0xd9b67a26] = true;\r\n\r\n        // ERC1155\r\n        // ERC1155Metadata_URI\r\n        ds.supportedInterfaces[IERC1155Metadata_URI.uri.selector] = true;\r\n\r\n        // create wearable tickets:\r\n        emit TransferSingle(msg.sender, address(0), address(0), 0, 0);\r\n        emit TransferSingle(msg.sender, address(0), address(0), 1, 0);\r\n        emit TransferSingle(msg.sender, address(0), address(0), 2, 0);\r\n        emit TransferSingle(msg.sender, address(0), address(0), 3, 0);\r\n        emit TransferSingle(msg.sender, address(0), address(0), 4, 0);\r\n        emit TransferSingle(msg.sender, address(0), address(0), 5, 0);\r\n    }\r\n\r\n    // Find facet for function that is called and execute the\r\n    // function if a facet is found and return any value.\r\n    fallback() external payable {\r\n        LibDiamond.DiamondStorage storage ds;\r\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n        address facet = address(bytes20(ds.facets[msg.sig]));\r\n        require(facet != address(0), \"GHSTSTaking: Function does not exist\");\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch result\r\n                case 0 {\r\n                    revert(0, returndatasize())\r\n                }\r\n                default {\r\n                    return(0, returndatasize())\r\n                }\r\n        }\r\n    }\r\n\r\n    receive() external payable {\r\n        revert(\"GHSTStaking: Does not accept ether\");\r\n    }\r\n}\r\n"
6     },
7     "contracts/libraries/LibDiamond.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.3;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge\n*\n* Implementation of Diamond facet.\n* Uses the diamond-2 version 1.3.4 implementation:\n* https://github.com/mudgen/diamond-2\n*\n* This is gas optimized by reducing storage reads and storage writes.\n* This code is as complex as it is to reduce gas costs.\n/******************************************************************************/\n\nimport \"../interfaces/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct DiamondStorage {\n        // maps function selectors to the facets that execute the functions.\n        // and maps the selectors to their position in the selectorSlots array.\n        // func selector => address facet, selector position\n        mapping(bytes4 => bytes32) facets;\n        // array of slots of function selectors.\n        // each slot holds 8 function selectors.\n        mapping(uint256 => bytes32) selectorSlots;\n        // The number of function selectors in selectorSlots\n        uint16 selectorCount;\n        // owner of the contract\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n        _;\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        if (selectorCount % 8 > 0) {\n            // get last selectorSlot\n            selectorSlot = ds.selectorSlots[selectorCount / 8];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        if (selectorCount % 8 > 0) {\n            ds.selectorSlots[selectorCount / 8] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        DiamondStorage storage ds = diamondStorage();\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            require(_newFacetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\n                // add facet for selector\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n                uint256 selectorInSlotPosition = (_selectorCount % 8) * 32;\n                // clear selector position in slot and add selector\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    ds.selectorSlots[_selectorCount / 8] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            require(_newFacetAddress != address(0), \"LibDiamondCut: Replace facet can't be address(0)\");\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n                // replace old facet address\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n            uint256 selectorSlotCount = _selectorCount / 8;\n            uint256 selectorInSlotIndex = (_selectorCount % 8) - 1;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = ds.facets[selector];\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n                    // only useful if immutable functions exist\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\n                    // replace selector with last selector in ds.facets\n                    // gets the last selector\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex * 32));\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\n                    }\n                    delete ds.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    oldSelectorsSlotCount = oldSelectorCount / 8;\n                    oldSelectorInSlotPosition = (oldSelectorCount % 8) * 32;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete ds.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n                selectorInSlotIndex--;\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex + 1;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
9     },
10     "contracts/interfaces/IDiamondCut.sol": {
11       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.3;\r\npragma experimental ABIEncoderV2;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n/******************************************************************************/\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}\r\n"
12     },
13     "contracts/interfaces/IDiamondLoupe.sol": {
14       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.3;\r\npragma experimental ABIEncoderV2;\r\n\r\n// A loupe is a small magnifying glass used to look at diamonds.\r\n// These functions look at diamonds\r\ninterface IDiamondLoupe {\r\n    /// These functions are expected to be called frequently\r\n    /// by tools.\r\n\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Gets all facet addresses and their four byte function selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory facets_);\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\r\n}\r\n"
15     },
16     "contracts/interfaces/IERC173.sol": {
17       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.3;\r\n\r\n/// @title ERC-173 Contract Ownership Standard\r\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\n/* is ERC165 */\r\ninterface IERC173 {\r\n    /// @dev This emits when ownership of a contract changes.\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice Get the address of the owner\r\n    /// @return owner_ The address of the owner.\r\n    function owner() external view returns (address owner_);\r\n\r\n    /// @notice Set the address of the new owner of the contract\r\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\r\n    /// @param _newOwner The address of the new owner of the contract\r\n    function transferOwnership(address _newOwner) external;\r\n}\r\n"
18     },
19     "contracts/interfaces/IERC165.sol": {
20       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.3;\r\n\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceId The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n"
21     },
22     "contracts/libraries/AppStorage.sol": {
23       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.3;\r\n\r\nstruct Account {\r\n    uint96 ghst;\r\n    uint96 uniV2PoolTokens;\r\n    uint40 lastUpdate;\r\n    uint104 frens;\r\n}\r\n\r\nstruct Ticket {\r\n    // user address => balance\r\n    mapping(address => uint256) accountBalances;\r\n    uint96 totalSupply;\r\n}\r\n\r\nstruct AppStorage {\r\n    mapping(address => mapping(address => bool)) approved;\r\n    mapping(address => Account) accounts;\r\n    mapping(uint256 => Ticket) tickets;\r\n    address ghstContract;\r\n    address uniV2PoolContract;\r\n    string ticketsBaseUri;\r\n}\r\n"
24     },
25     "contracts/interfaces/IERC1155Metadata_URI.sol": {
26       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.3;\r\n\r\n/**\r\n    Note: The ERC-165 identifier for this interface is 0x0e89341c.\r\n*/\r\ninterface IERC1155Metadata_URI {\r\n    /**\r\n        @notice A distinct Uniform Resource Identifier (URI) for a given token.\r\n        @dev URIs are defined in RFC 3986.\r\n        The URI MUST point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".        \r\n        @return URI string\r\n    */\r\n    function uri(uint256 _id) external view returns (string memory);\r\n}\r\n"
27     }
28   },
29   "settings": {
30     "metadata": {
31       "useLiteralContent": true
32     },
33     "optimizer": {
34       "enabled": true,
35       "runs": 20000
36     },
37     "outputSelection": {
38       "*": {
39         "*": [
40           "evm.bytecode",
41           "evm.deployedBytecode",
42           "abi"
43         ]
44       }
45     },
46     "libraries": {}
47   }
48 }}