1 {"GazeERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.1;\n\nimport \"./Owned.sol\";\n\ncontract gazeERC20 is Owned {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address =\u003e uint256) public balanceOf;\n    mapping (address =\u003e mapping (address =\u003e uint256)) public allowance;\n\n    // Below are public events on the blockchain that will notify clients\n\t\n\t// This notifies clients about the tokens amount transfer between accounts \n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    \n    // This notifies clients about the tokens amount approved to _spender to use on account _owner\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    // This notifies clients about the tokens amount burnt\n    event Burn(address indexed _from, uint256 _value);\n\t\n\t// This notifies clients about the tokens amount minted\n    event Mint(address indexed _to, uint256 _value);\n\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n\t *\n\t * @param _initialSupply Total initial amount of tokens\n     * @param _name full name of the token\n\t * @param _symbol short name of the token\n     */\n    constructor (\n        uint256 _initialSupply,\n        string memory _name,\n        string memory _symbol\n    ) public {\n\t\trequire(_initialSupply\u003e0);\n        totalSupply = _initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                \t // Give the contract owner all initial tokens\n        name = _name;  \n        symbol = _symbol;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint256 _value) internal {\n\t\trequire(_from != address(0), \"transfer attempt from zero address\"); // Prevent transfer from 0x0 address.\n        require(_to != address(0), \"transfer attempt to zero address\"); // Prevent transfer to 0x0 address.\n        require(balanceOf[_from] \u003e= _value, \"from address balance is not enough\");\n        require(balanceOf[_to] + _value \u003e= balanceOf[_to], \"destination address balance overflow\"); // Check for overflows\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value The amount of token minimal units (10**(-18)) to send\n     */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value The amount of token minimal units (10**(-18)) to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_value \u003c= allowance[_from][msg.sender], \"transfer not allowed\");     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value The max amount of token minimal units (10**(-18)) it can spend\n     */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n\t\trequire(_spender != address(0));\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of token minimal units (10**(-18)) to burn\n     */\n    function burnFrom(address _from, uint256 _value) public onlyOwner returns (bool) {\n        require(balanceOf[_from] \u003e= _value, \"address balance is smaller, than amount to burn\");\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        totalSupply -= _value;                              // Update totalSupply\n        emit Burn(_from, _value);\n\t\tassert(totalSupply \u003e= 0);\n        return true;\n    }\n\t\n   /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of token minimal units (10**(-18)) to burn\n     */\n    function burn(uint256 _value) public onlyOwner returns (bool) {\n        return burnFrom(msg.sender, _value);\n    }\n\t\n    /**\n     * Create new tokens to account\n\t *\n\t * Create _mintAmount of new tokens to account _target\n\t *\n\t * @param _mintAmount the amount of token minimal units (10**(-18)) to mint\n\t * @param _target the address to own new mint tokens\n     *\n     * Internal function, can be called from the contract and it\u0027s children contracts only\n     */\n\tfunction _mintToken(address _target, uint256 _mintAmount) internal {\n\t\trequire(_target != address(0), \"mint attempt to zero address\"); // Prevent mint to 0x0 address.\n\t\trequire(totalSupply + _mintAmount \u003e totalSupply);\n        balanceOf[_target] += _mintAmount;\n        totalSupply += _mintAmount;\n        emit Mint(_target, _mintAmount);\n    }\n\t\n\t/**\n     * Create tokens to account\n     *\n     * Create `_mintAmount` tokens  and set them to _target account.\n     *\n     * @param _target the address for new tokens\n     * @param _mintAmount the amount of token minimal units (10**(-18)) to create\n     */\n\tfunction mintToken(address _target, uint256 _mintAmount) public onlyOwner returns (bool) {\n\t\t_mintToken(_target, _mintAmount);\n\t\treturn true;\n\t}\n\t\n\t/**\n     * Destroy contract\n     *\n\t * @param _beneficiary Address to send all contract\u0027s Ether balance\n     */\n\tfunction destroy(address payable _beneficiary) public onlyOwner {\n\t\trequire(_beneficiary != address(0), \"beneficiary is zero address\");\n\t\tselfdestruct(_beneficiary);\n\t}\n\t\n\treceive() external payable { \n\t\trevert();\n\t}\n}"},"Owned.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.6.1;\r\n\r\ncontract Owned {\r\n\taddress payable internal owner;\r\n\r\n\tconstructor() internal {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyOwner {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferOwnership(address payable newOwner) public onlyOwner {\r\n\t\towner = newOwner;\r\n\t}\r\n}"}}