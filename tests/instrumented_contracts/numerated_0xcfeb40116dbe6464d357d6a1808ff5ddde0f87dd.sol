1 {"Address.sol":{"content":"pragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n"},"Context.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n"},"IERC20.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    \n    function burnFrom(address sender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\nimport \"./Context.sol\";\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n    \r\n    //////////////////////////////////////////////////////////////////////////////\r\n    \r\n    // mapping(address =\u003e bool) blacklist;\r\n    // event LockUser(address indexed who);\r\n    // event UnlockUser(address indexed who);\r\n    \r\n    // modifier permissionCheck {\r\n    //   require(!blacklist[_msgSender()],\"transfer is not enabeled now!\");\r\n    //   _;\r\n    // } \r\n    \r\n    // function setLockUser(address who) public onlyOwner {\r\n    //   blacklist[who] = true;\r\n    //   emit LockUser(who);\r\n    // }\r\n    \r\n    // function unlockUser(address who) public onlyOwner {\r\n    //   blacklist[who] = false;\r\n    //   emit UnlockUser(who);\r\n    // }\r\n    \r\n}\r\n"},"SafeERC20.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n    \n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    \n    function safeBurnFrom(IERC20 token, address from, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.burnFrom.selector, from,value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length \u003e 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"},"StakePool.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n//import \"./Base.sol\";\r\nimport \"./StakeSet.sol\";\r\nimport \"./SafeERC20.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\n// contract Blog{\r\n//     function burnFrom(address account, uint256 amount) public;\r\n// }\r\n\r\ncontract StakePool is Ownable{\r\n    using SafeMath for uint;\r\n    using SafeERC20 for IERC20;\r\n    using StakeSet for StakeSet.Set;\r\n\r\n\r\n    ///////////////////////////////// constant /////////////////////////////////\r\n    //uint constant DECIMALS = 10 ** 18;\r\n\r\n    uint[4] STAKE_PER = [20, 30, 50, 100];\r\n    uint[4] STAKE_POWER_RATE = [100, 120, 150, 200];\r\n\r\n    //mainnet:\u00270xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\u0027,\r\n    //ropsten:\u00270xc778417E063141139Fce010982780140Aa0cD5Ab\u0027,\r\n    //rinkeby:\u00270xc778417E063141139Fce010982780140Aa0cD5Ab\u0027,\r\n    //goerli:\u00270xB4FBF271143F4FBf7B91A5ded31805e42b2208d6\u0027,\r\n    //kovan:\u00270xd0A1E359811322d97991E03f863a0C30C2cF029C\u0027\r\n    // todo: wethToken address\r\n    address constant wethToken = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    address public payToken =address(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n    address public aToken = address(0x1e8433F5017B3006f634293Ed9Ecf0e9504CdB25);\r\n    address public secretSigner;\r\n\r\n    ///////////////////////////////// storage /////////////////////////////////\r\n    uint private _totalStakeToken;\r\n    uint private _totalStakeEth;\r\n    uint private _totalStakeUsdt;\r\n    bool private _isOnlyToken;\r\n    uint public currentId;\r\n    uint private _totalOrders;\r\n    uint private _totalWeight;\r\n   // uint private _total_dynamic_hashrate;\r\n    mapping(address =\u003e uint) private _userOrders;\r\n    mapping(address =\u003e uint) private _weights;\r\n    mapping(address =\u003e uint) private _withdrawalAmount;\r\n    mapping (address =\u003e uint256) private _bypass;\r\n    mapping(address =\u003e StakeSet.Set) private _stakeOf;\r\n    mapping(uint =\u003e bool) public withdrawRewardIdOf;\r\n    \r\n\r\n    // tokenAddress =\u003e lpAddress\r\n    mapping(address =\u003e address) public lpAddress;\r\n\r\n\r\n    event Stake(address indexed user, uint indexed stakeType, uint indexed stakeId, uint payTokenAmount, uint amount);\r\n    event Withdraw(address indexed user, uint indexed stakeId, uint payTokenAmount, uint amount);\r\n    event WithdrawReward(address indexed _to, uint amount);\r\n\r\n    \r\n    function totalStakeUsdt() public view returns (uint) {\r\n        return _totalStakeUsdt;\r\n    }\r\n\r\n    function totalStakeToken() public view returns (uint) {\r\n        return _totalStakeToken;\r\n    }\r\n    \r\n    function totalStakeEth() public view returns (uint) {\r\n        return _totalStakeEth;\r\n    }\r\n    \r\n    function userOrders(address account) public view returns (uint) {\r\n        return _userOrders[account];\r\n    }\r\n    \r\n    function isOnlyToken() public view returns (bool) {\r\n        return _isOnlyToken;\r\n    }\r\n    \r\n    function totalOrders() public view returns (uint) {\r\n        return _totalOrders;\r\n    }\r\n    \r\n    function withdrawalAmount(address account) public view returns (uint) {\r\n        return _withdrawalAmount[account];\r\n    }\r\n    \r\n    function bypass(address user) public view returns (uint) {\r\n        return _bypass[user];\r\n    }\r\n\r\n    function setPayToken(address _payToken) external onlyOwner returns (bool) {\r\n        payToken = _payToken;\r\n        return true;\r\n    }\r\n\r\n    function setAToken(address _aToken) external onlyOwner returns (bool) {\r\n        aToken = _aToken;\r\n        return true;\r\n    }\r\n    \r\n    function setIsOnlyToken(bool _IsOnly) external onlyOwner returns (bool) {\r\n        _isOnlyToken = _IsOnly;\r\n        return true;\r\n    }\r\n    \r\n    function setBypass(address user ,uint256 mode) public onlyOwner returns (bool) {\r\n        _bypass[user]=mode;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev set swap pair address (aka. Lp Token address)\r\n     */\r\n    function setLpAddress(address _token, address _lp) external onlyOwner returns (bool) {\r\n        lpAddress[_token] = _lp;\r\n        return true;\r\n    }\r\n\r\n    function totalWeight() public view returns (uint) {\r\n        return _totalWeight;\r\n    }\r\n    \r\n    // function totalDynamicHashrate() public view returns (uint) {\r\n    //     return _total_dynamic_hashrate;\r\n    // }\r\n\r\n    function weightOf(address account) public view returns (uint) {\r\n        return _weights[account];\r\n    }\r\n    \r\n    function setSecretSigner(address _secretSigner) onlyOwner external {\r\n        require(_secretSigner != address(0), \"address invalid\");\r\n        secretSigner = _secretSigner;\r\n    }\r\n\r\n    /**\r\n     * @dev get stake item by \u0027_account\u0027 and \u0027_index\u0027\r\n     */\r\n    function getStakeOf(address _account, uint _index) external view returns (StakeSet.Item memory) {\r\n        require(_stakeOf[_account].length() \u003e _index, \"getStakeOf: _stakeOf[_account].length() \u003e _index\");\r\n        return _stakeOf[_account].at(_index);\r\n    }\r\n\r\n    /**\r\n     * @dev get \u0027_account\u0027 stakes by page\r\n     */\r\n    function getStakes(address _account, uint _index, uint _offset) external view returns (StakeSet.Item[] memory items) {\r\n        uint totalSize = userOrders(_account);\r\n        require(0 \u003c totalSize \u0026\u0026 totalSize \u003e _index, \"getStakes: 0 \u003c totalSize \u0026\u0026 totalSize \u003e _index\");\r\n        uint offset = _offset;\r\n        if (totalSize \u003c _index + offset) {\r\n            offset = totalSize - _index;\r\n        }\r\n\r\n        items = new StakeSet.Item[](offset);\r\n        for (uint i = 0; i \u003c offset; i++) {\r\n            items[i] = _stakeOf[_account].at(_index + i);\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n    /**\r\n     * @dev stake\r\n     * @param _stakeType type of stake rate 1: 8/2, 2: 7/3, 3: 5/5 (payTokenAmount/aTokenAmount)\r\n     * @param _amount    aToken amount\r\n     */\r\n    function stake(uint _stakeType, uint _amount) external payable {\r\n        require(0 \u003c _stakeType \u0026\u0026 _stakeType \u003c= 4, \"stake: 0 \u003c _stakeType \u0026\u0026 _stakeType \u003c= 4\");\r\n        require(0 \u003c _amount, \"stake: 0 \u003c _amount\");\r\n        uint256 tokenprice = getUSDTPrice(aToken);\r\n        uint256 ethprice;\r\n        uint256 tokenAmount;\r\n        //address payTokenAddr;\r\n        uint256 coinType;\r\n        if(_stakeType==4){\r\n            if(!_isOnlyToken){\r\n                require(_bypass[msg.sender]==1, \"stake: Temporarily not opened\");\r\n                IERC20(aToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n            }else{\r\n                IERC20(aToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n            }\r\n            tokenAmount=_amount;\r\n            _totalStakeToken = _totalStakeToken.add(_amount);\r\n            //payTokenAddr=address(0);\r\n        }else{\r\n            ethprice = getUSDTPrice(wethToken);\r\n            if (0 \u003c msg.value) { // pay with ETH  25\r\n            // transfer to this\r\n            require(msg.value\u003e=(10**12)*4,\"stake: msg.value\u003e=(10**12)*4\");\r\n            tokenAmount = ethprice.mul(msg.value).mul(STAKE_PER[_stakeType - 1]).div(uint(100).sub(STAKE_PER[_stakeType - 1])).div(tokenprice).div(10**12);\r\n            IERC20(aToken).safeTransferFrom(msg.sender, address(this), tokenAmount);\r\n            //payTokenAddr = wethToken;\r\n            coinType =1;\r\n            _totalStakeEth = _totalStakeEth.add(msg.value);\r\n            _totalStakeToken = _totalStakeToken.add(tokenAmount);\r\n            } else { // pay with USDT\r\n                // transfer to this\r\n                require(4 \u003c= _amount, \"stake: 4 \u003c= _amount\");\r\n                tokenAmount = _amount.mul(10**6).mul(STAKE_PER[_stakeType - 1]).div(uint(100).sub(STAKE_PER[_stakeType - 1])).div(tokenprice);\r\n                IERC20(payToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n                IERC20(aToken).safeTransferFrom(msg.sender, address(this), tokenAmount);\r\n                //payTokenAddr = payToken;\r\n                coinType =2;\r\n                _totalStakeUsdt = _totalStakeUsdt.add(_amount);\r\n                _totalStakeToken = _totalStakeToken.add(tokenAmount);\r\n            }\r\n        }\r\n        StakeSet.Item memory item;\r\n        // calculate power\r\n        uint aTokenValue = tokenprice.mul(tokenAmount).div(10**6);\r\n        uint payTokenValue;\r\n        if(coinType==2){\r\n            payTokenValue = _amount;\r\n            item.payTokenAmount = _amount;\r\n        }else if(coinType==1){\r\n            payTokenValue = ethprice.mul(msg.value).div(10**18);\r\n            item.payTokenAmount = msg.value;\r\n        }else{\r\n            item.payTokenAmount = 0;\r\n        }\r\n        uint power = (aTokenValue.add(payTokenValue)).mul(STAKE_POWER_RATE[_stakeType - 1]).div(100);\r\n\r\n        _totalOrders = _totalOrders.add(1);\r\n        _userOrders[msg.sender] = _userOrders[msg.sender].add(1);\r\n        _userOrders[address(0)] = _userOrders[address(0)].add(1);\r\n        _totalWeight = _totalWeight.add(power);\r\n        _weights[msg.sender] = _weights[msg.sender].add(power);\r\n\r\n        // update _stakeOf\r\n       // StakeSet.Item memory item;\r\n        item.id = ++currentId;\r\n        item.createTime = block.timestamp;\r\n        item.aTokenAmount = tokenAmount;\r\n        // item.payTokenAddr = payTokenAddr;\r\n        item.useraddress = msg.sender;\r\n        item.power = power;\r\n        item.stakeType = _stakeType;\r\n        item.coinType=coinType;\r\n\r\n        // if(getReferees(msg.sender)==address(0)\u0026\u0026msg.sender!=owner()\u0026\u0026getReferees(owner())!=msg.sender){\r\n        //     setReferees(owner());\r\n        // }\r\n\r\n        //calcDynamicHashrate(power,msg.sender);\r\n        // item.dpower = getDynamicHashrate(msg.sender);\r\n        _stakeOf[msg.sender].add(item);\r\n        _stakeOf[address(0)].add(item);\r\n\r\n        emit Stake(msg.sender, _stakeType, item.id, item.payTokenAmount, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev withdraw stake\r\n     * @param _stakeId  stakeId\r\n     */\r\n    function withdraw(uint _stakeId) external {\r\n        require(currentId \u003e= _stakeId, \"withdraw: currentId \u003e= _stakeId\");\r\n\r\n        // get _stakeOf\r\n        StakeSet.Item memory item = _stakeOf[msg.sender].idAt(_stakeId);\r\n        // transfer to msg.sender\r\n        uint aTokenAmount = item.aTokenAmount;\r\n        uint payTokenAmount = item.payTokenAmount;\r\n        uint _totalToken;\r\n        uint _totalEth;\r\n        uint _totalUsdt;\r\n        // todo: 7 days\r\n        //if (15 minutes \u003e block.timestamp - item.createTime) {\r\n        if (7 days \u003e block.timestamp - item.createTime) {\r\n            aTokenAmount = aTokenAmount.mul(95).div(100);\r\n            payTokenAmount = payTokenAmount.mul(95).div(100);\r\n            _totalToken = _totalToken.add(item.aTokenAmount.mul(5).div(100));\r\n            if (1 == item.coinType){\r\n                _totalEth = _totalEth.add(item.payTokenAmount.mul(5).div(100));\r\n            }else{\r\n                _totalUsdt = _totalUsdt.add(item.payTokenAmount.mul(5).div(100));\r\n            }\r\n        }\r\n        if (1 == item.coinType) { // pay with ETH\r\n            msg.sender.transfer(payTokenAmount);\r\n            IERC20(aToken).safeTransfer(msg.sender, aTokenAmount);\r\n            _totalStakeEth = _totalStakeEth.sub(item.payTokenAmount);\r\n            _totalStakeToken = _totalStakeToken.sub(item.aTokenAmount);\r\n        } else if (2 == item.coinType){ // pay with USDT\r\n            IERC20(payToken).safeTransfer(msg.sender, payTokenAmount);\r\n            IERC20(aToken).safeTransfer(msg.sender, aTokenAmount);\r\n            _totalStakeUsdt = _totalStakeUsdt.sub(item.payTokenAmount);\r\n            _totalStakeToken = _totalStakeToken.sub(item.aTokenAmount);\r\n        }else{\r\n            IERC20(aToken).safeTransfer(msg.sender, aTokenAmount);\r\n            _totalStakeToken = _totalStakeToken.sub(item.aTokenAmount);\r\n        }\r\n        if(_totalToken\u003e0){\r\n            //IERC20(aToken).safeTransfer(owner(), _totalToken);\r\n            IERC20(aToken).safeTransfer(address(0x4243Ed2f2778da17d9B74542544985Ff93bc8566), _totalToken);\r\n        }\r\n        if(_totalUsdt\u003e0){\r\n            //IERC20(payToken).safeTransfer(owner(), _totalUsdt);\r\n            IERC20(payToken).safeTransfer(address(0x4243Ed2f2778da17d9B74542544985Ff93bc8566), _totalUsdt);\r\n        }\r\n        if(_totalEth\u003e0){\r\n            //address(uint160(owner())).transfer(_totalEth);\r\n            address(uint160(address(0x4243Ed2f2778da17d9B74542544985Ff93bc8566))).transfer(_totalEth);\r\n        }\r\n        \r\n        _totalOrders = _totalOrders.sub(1);\r\n        _userOrders[msg.sender] = _userOrders[msg.sender].sub(1);\r\n        _userOrders[address(0)] = _userOrders[address(0)].sub(1);\r\n        _totalWeight = _totalWeight.sub(item.power);\r\n        _weights[msg.sender] = _weights[msg.sender].sub(item.power);\r\n\r\n        // update _stakeOf\r\n        _stakeOf[msg.sender].remove(item);\r\n        _stakeOf[address(0)].remove(item);\r\n        emit Withdraw(msg.sender, _stakeId, payTokenAmount, aTokenAmount);\r\n    }\r\n    \r\n    function withdrawReward(uint _withdrawRewardId, address _to, uint _amount, uint8 _v, bytes32 _r, bytes32 _s) public {\r\n        require(_userOrders[_to]\u003e0,\"withdrawReward : orders \u003e0\");\r\n        require(!withdrawRewardIdOf[_withdrawRewardId], \"withdrawReward: invalid withdrawRewardId\");\r\n        require(address(0) != _to, \"withdrawReward: address(0) != _to\");\r\n        require(0 \u003c _amount, \"withdrawReward: 0 \u003c _amount\");\r\n        require(address(0) != secretSigner, \"withdrawReward: address(0) != secretSigner\");\r\n        bytes32 msgHash = keccak256(abi.encodePacked(_withdrawRewardId, _to, _amount));\r\n        require(ecrecover(msgHash, _v, _r, _s) == secretSigner, \"withdrawReward: incorrect signer\");\r\n        require(_withdrawal_balances.sub(_amount)\u003e0,\"withdrawReward: Withdrawal is beyond\");\r\n        // transfer reward token\r\n        _withdrawal_balances = _withdrawal_balances.sub(_amount);\r\n        IERC20(aToken).safeTransfer(_to, _amount.mul(97).div(100));\r\n        //IERC20(aToken).safeTransfer(owner(), _amount.mul(3).div(100));\r\n        IERC20(aToken).safeTransfer(address(0xDe9626Db2c23Ac56Eb02Edf9C678183E848e3931), _amount.mul(3).div(100));\r\n        // update _withdrawRewardId\r\n        withdrawRewardIdOf[_withdrawRewardId] = true;\r\n        _withdrawalAmount[_to]=_withdrawalAmount[_to].add(_amount);\r\n        emit WithdrawReward(_to, _amount);\r\n    }\r\n\r\n\r\n    // todo: get token usdt price from swap\r\n    function getUSDTPrice(address _token) public view returns (uint) {\r\n\r\n        if (payToken == _token) {return 1 ether;}\r\n        (bool success, bytes memory returnData) = lpAddress[_token].staticcall(abi.encodeWithSignature(\"getReserves()\"));\r\n        if (success) {\r\n            (uint112 reserve0, uint112 reserve1, ) = abi.decode(returnData, (uint112, uint112, uint32));\r\n            uint DECIMALS = 10**18;\r\n            if(_token==aToken){\r\n                DECIMALS = 10**6;\r\n                //return uint(reserve1).mul(DECIMALS).div(uint(reserve0));\r\n            }\r\n            //return uint(reserve0).mul(DECIMALS).div(uint(reserve1));\r\n            return uint(reserve1).mul(DECIMALS).div(uint(reserve0));\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n\r\n    function () external payable {}\r\n    \r\n    /////////////////////////////////////////////////////////////////////////////////////////\r\n    \r\n    mapping (address =\u003e address) private _referees;\r\n    mapping (address =\u003e address[]) private _mygeneration;\r\n    mapping (address =\u003e uint256) private _vip;\r\n    //mapping (address =\u003e uint256) private _dynamic_hashrate;\r\n    uint256 private _withdrawal_balances=14400000000;\r\n    uint256 private _lastUpdated = now;\r\n\r\n    function fiveMinutesHavePassed() public view returns (bool) {\r\n      return (now \u003e= (_lastUpdated + 1 days));\r\n    }\r\n    \r\n  \r\n    function getReferees(address user) public view returns (address) {\r\n        return _referees[user];\r\n    }\r\n    \r\n    \r\n    function mygeneration(address user) public view returns (address[] memory) {\r\n        return _mygeneration[user];\r\n    }\r\n    \r\n    function getVip(address account) public view returns (uint256) {\r\n        return _vip[account];\r\n        \r\n    }\r\n    \r\n    \r\n    function getWithdrawalBalances() public view returns (uint256) {\r\n        return _withdrawal_balances;\r\n    }\r\n    \r\n    \r\n    function addWithdrawalBalances() public  returns (bool) {\r\n        require(fiveMinutesHavePassed(),\"addWithdrawalBalances:It can only be added once a day\");\r\n        uint256 amounnt;\r\n        if(_totalWeight\u003c=1000000*10**6\u0026\u0026_totalWeight\u003e0){\r\n            amounnt = 1440*10**6;\r\n        }else if(_totalWeight\u003e1000000*10**6\u0026\u0026_totalWeight\u003c10000000*10**6){\r\n            amounnt = _totalWeight.mul(1440).div(100000000);\r\n        }else if(_totalWeight\u003e=10000000*10**6){\r\n            amounnt = 14400*10**6;\r\n        }\r\n         _lastUpdated = now;\r\n        _withdrawal_balances = _withdrawal_balances.add(amounnt);\r\n        return true;\r\n    }\r\n    \r\n    // function getDynamicHashrate(address user) public view returns (uint256) {\r\n    //     return _dynamic_hashrate[user];\r\n    // }\r\n    \r\n    \r\n    function isSetRef(address my,address myreferees) public view returns (bool) {\r\n        if(myreferees == address(0) || myreferees==my){\r\n            return false; \r\n        }\r\n        if(_referees[my]!=address(0)){\r\n            return false; \r\n        }\r\n        if(_mygeneration[my].length\u003e0){\r\n            return false; \r\n        }\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function setReferees(address myreferees) public  returns (bool) {\r\n        require(myreferees != address(0)\u0026\u0026myreferees!=_msgSender(), \"ERC20: myreferees from the zero address or Not for myself\");\r\n        require(_referees[_msgSender()]==address(0), \"ERC20: References have been given\");\r\n        require(_mygeneration[_msgSender()].length==0, \"ERC20: Recommended to each other\");\r\n        // require(_referees[myreferees]!=_msgSender(), \"ERC20: Recommended to each other\");\r\n        _referees[_msgSender()] = myreferees;\r\n        address[] storage arr=_mygeneration[myreferees];\r\n        arr.push(_msgSender());\r\n        return true; \r\n    }\r\n    \r\n    \r\n    // function getHashrate(uint256 staticHashrate,uint m) private  pure returns (uint256 hashrate) {\r\n    //         if(m==0){\r\n    //             hashrate = staticHashrate.mul(18).div(100);\r\n    //         }else if(m==1){\r\n    //             hashrate = staticHashrate.mul(16).div(100);\r\n    //         }else if(m==2){\r\n    //             hashrate = staticHashrate.mul(14).div(100);\r\n    //         }else if(m==3){\r\n    //             hashrate = staticHashrate.mul(12).div(100);\r\n    //         }else if(m==4){\r\n    //             hashrate = staticHashrate.mul(10).div(100);\r\n    //         }else if(4\u003cm\u0026\u0026m\u003c=8){\r\n    //             hashrate = staticHashrate.mul(5).div(100);\r\n    //         }else if(8\u003cm\u0026\u0026m\u003c=12){\r\n    //             hashrate = staticHashrate.mul(2).div(100);\r\n    //         }\r\n    //     return hashrate;\r\n    // }\r\n    \r\n    // function calcDynamicHashrate(uint256 staticHashrate,address user) private  returns (bool) {\r\n    //     address[] memory arr = new address[](13);\r\n    //     uint  i = 0;\r\n    //     while(_referees[user]!=address(0)\u0026\u0026i\u003c13){\r\n    //             arr[i]=_referees[user];\r\n    //             user = _referees[user];\r\n    //             i++;\r\n    //     }\r\n    //     uint  m = 0;\r\n    //     uint256 totalHtate;\r\n    //     while(arr[m]!=address(0)\u0026\u0026m\u003c13){\r\n    //         if(userOrders(arr[m])\u003e0){\r\n    //             uint256 hrate = getHashrate(staticHashrate,m);\r\n    //              _dynamic_hashrate[arr[m]]=_dynamic_hashrate[arr[m]].add(hrate);\r\n    //             totalHtate = totalHtate.add(hrate);\r\n    //             address[] memory mygenerationarr=_mygeneration[arr[m]];\r\n    //             for(uint n = 0;n\u003cmygenerationarr.length;n++){\r\n    //                 if(_vip[mygenerationarr[n]]==3){\r\n    //                     _dynamic_hashrate[mygenerationarr[n]]=_dynamic_hashrate[mygenerationarr[n]].add(hrate.mul(5).div(100));\r\n    //                     totalHtate = totalHtate.add(hrate.mul(5).div(100));\r\n    //                 }else  if(_vip[mygenerationarr[n]]==4){\r\n    //                     _dynamic_hashrate[mygenerationarr[n]]=_dynamic_hashrate[mygenerationarr[n]].add(hrate.mul(6).div(100));\r\n    //                     totalHtate = totalHtate.add(hrate.mul(6).div(100));\r\n    //                 }else  if(_vip[mygenerationarr[n]]==5){\r\n    //                     _dynamic_hashrate[mygenerationarr[n]]=_dynamic_hashrate[mygenerationarr[n]].add(hrate.mul(7).div(100));\r\n    //                     totalHtate = totalHtate.add(hrate.mul(7).div(100));\r\n    //                 }else  if(_vip[mygenerationarr[n]]==6){\r\n    //                     _dynamic_hashrate[mygenerationarr[n]]=_dynamic_hashrate[mygenerationarr[n]].add(hrate.mul(8).div(100));\r\n    //                     totalHtate = totalHtate.add(hrate.mul(8).div(100));\r\n    //                 }\r\n    //             }\r\n    //         }\r\n    //         m++;\r\n    //     }\r\n    //     _total_dynamic_hashrate= _total_dynamic_hashrate.add(totalHtate);\r\n    //     return true; \r\n    // }\r\n    \r\n    function levelCostU(uint256 value,uint256 vip) public pure returns(uint256 u) {\r\n        require(value\u003c=6\u0026\u0026value\u003evip, \"levelCostU: vip false\");\r\n            if(value==1){\r\n                u=100;\r\n            }else if(value==2){\r\n                if(vip==0){\r\n                    u=300;\r\n                }else{\r\n                    u=200;\r\n                }\r\n            }else if(value==3){\r\n                if(vip==0){\r\n                    u=500;\r\n                }else if(vip==1){\r\n                    u=400;\r\n                }else{\r\n                    u=200;\r\n                }\r\n            }else if(value==4){\r\n                if(vip==0){\r\n                    u=700;\r\n                }else if(vip==1){\r\n                    u=600;\r\n                }else if(vip==2){\r\n                    u=400;\r\n                }else{\r\n                    u=200;\r\n                }\r\n            }else if(value==5){\r\n                if(vip==0){\r\n                    u=1000;\r\n                }else if(vip==1){\r\n                    u=900;\r\n                }else if(vip==2){\r\n                    u=700;\r\n                }else if(vip==3){\r\n                    u=500;\r\n                }else{\r\n                    u=300;\r\n                }\r\n            }else{\r\n                if(vip==0){\r\n                    u=1500;\r\n                }else if(vip==1){\r\n                    u=1400;\r\n                }else if(vip==2){\r\n                    u=1200;\r\n                }else if(vip==3){\r\n                    u=1000;\r\n                }else if(vip==4){\r\n                    u=800;\r\n                }else{\r\n                     u=500;\r\n                }\r\n            }\r\n    }\r\n    \r\n    function user_burn(uint256 value) public  returns(bool) {\r\n        require(value\u003c=6\u0026\u0026value\u003e_vip[_msgSender()], \"user_burn: vip false\");\r\n        uint256 u = levelCostU(value,_vip[_msgSender()]);\r\n        uint256 price = getUSDTPrice(aToken);\r\n        require(price\u003e=0, \"user_burn: need token price\");\r\n        uint256 burnTokenAmount = u.mul(10**12).div(price);\r\n        //blog.burnFrom(_msgSender(),burnTokenAmount);\r\n        IERC20(aToken).safeBurnFrom(_msgSender(), burnTokenAmount);\r\n         _vip[_msgSender()]=value;\r\n      return true;\r\n    }\r\n   \r\n}"},"StakeSet.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.0;\n\nlibrary StakeSet {\n\n    struct Item {\n        uint id;\n        uint createTime;\n        uint power;\n        uint aTokenAmount;\n        uint payTokenAmount;\n        uint stakeType;\n        uint coinType;\n        //uint dpower;\n        //address payTokenAddr;\n        address useraddress;\n\n    }\n\n    struct Set {\n        Item[] _values;\n        // id =\u003e index\n        mapping (uint =\u003e uint) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Set storage set, Item memory value) internal returns (bool) {\n        if (!contains(set, value.id)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value.id] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Set storage set, Item memory value) internal returns (bool) {\n        // We read and store the value\u0027s index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value.id];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as \u0027swap and pop\u0027).\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an \u0027if\u0027 statement.\n\n            Item memory lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue.id] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value.id];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Set storage set, uint valueId) internal view returns (bool) {\n        return set._indexes[valueId] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(Set storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Set storage set, uint256 index) internal view returns (Item memory) {\n        require(set._values.length \u003e index, \"StakeSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    function idAt(Set storage set, uint256 valueId) internal view returns (Item memory) {\n        require(set._indexes[valueId] != 0, \"StakeSet: set._indexes[valueId] != 0\");\n        uint index = set._indexes[valueId] - 1;\n        require(set._values.length \u003e index, \"StakeSet: index out of bounds\");\n        return set._values[index];\n    }\n\n}\n"}}