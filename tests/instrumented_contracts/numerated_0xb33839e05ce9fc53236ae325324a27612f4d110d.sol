1 {{
2   "language": "Solidity",
3   "sources": {
4     "/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/governance/BaseGovernanceModule.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../interfaces/IGovernanceModule.sol\";\n\n\nabstract contract BaseGovernanceModule is IGovernanceModule {\n    address public immutable mothership;\n\n    modifier onlyMothership {\n        require(msg.sender == mothership, \"Access restricted to mothership\");\n\n        _;\n    }\n\n    constructor(address _mothership) public {\n        mothership = _mothership;\n    }\n\n    function notifyStakesChanged(address[] calldata accounts, uint256[] calldata newBalances) external override onlyMothership {\n        require(accounts.length == newBalances.length, \"Arrays length should be equal\");\n\n        for(uint256 i = 0; i < accounts.length; ++i) {\n            _notifyStakeChanged(accounts[i], newBalances[i]);\n        }\n    }\n\n    function notifyStakeChanged(address account, uint256 newBalance) external override onlyMothership {\n        _notifyStakeChanged(account, newBalance);\n    }\n\n    function _notifyStakeChanged(address account, uint256 newBalance) internal virtual;\n}\n"
6     },
7     "/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/governance/ExchangeGovernance.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../interfaces/IExchangeGovernance.sol\";\nimport \"../libraries/ExchangeConstants.sol\";\nimport \"../libraries/LiquidVoting.sol\";\nimport \"../libraries/SafeCast.sol\";\nimport \"../utils/BalanceAccounting.sol\";\nimport \"./BaseGovernanceModule.sol\";\n\n\ncontract ExchangeGovernance is IExchangeGovernance, BaseGovernanceModule, BalanceAccounting {\n    using Vote for Vote.Data;\n    using LiquidVoting for LiquidVoting.Data;\n    using VirtualVote for VirtualVote.Data;\n    using SafeCast for uint256;\n\n    event LeftoverGovernanceShareUpdate(address indexed user, uint256 vote, bool isDefault, uint256 amount);\n    event LeftoverReferralShareUpdate(address indexed user, uint256 vote, bool isDefault, uint256 amount);\n    event LeftoverTeamShareUpdate(address indexed user, uint256 vote, bool isDefault, uint256 amount);\n\n    LiquidVoting.Data private _leftoverGovernanceShare;\n    LiquidVoting.Data private _leftoverReferralShare;\n\n    constructor(address _mothership) public BaseGovernanceModule(_mothership) {\n        _leftoverGovernanceShare.data.result = ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE.toUint104();\n        _leftoverReferralShare.data.result = ExchangeConstants._DEFAULT_LEFTOVER_REF_SHARE.toUint104();\n    }\n\n    function parameters() external view override returns(uint256 govShare, uint256 refShare, uint256 teamShare) {\n        govShare = _leftoverGovernanceShare.data.current();\n        refShare = _leftoverReferralShare.data.current();\n        teamShare = ExchangeConstants._LEFTOVER_TOTAL_SHARE.sub(govShare).sub(refShare);\n    }\n\n    function leftoverGovernanceShare() external view override returns(uint256) {\n        return _leftoverGovernanceShare.data.current();\n    }\n\n    function leftoverGovernanceShareVotes(address user) external view returns(uint256) {\n        return _leftoverGovernanceShare.votes[user].get(ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE);\n    }\n\n    function virtualLeftoverGovernanceShare() external view returns(uint104, uint104, uint48) {\n        return (_leftoverGovernanceShare.data.oldResult, _leftoverGovernanceShare.data.result, _leftoverGovernanceShare.data.time);\n    }\n\n    //\n\n    function leftoverReferralShare() external view override returns(uint256) {\n        return _leftoverReferralShare.data.current();\n    }\n\n    function leftoverReferralShareVotes(address user) external view returns(uint256) {\n        return _leftoverReferralShare.votes[user].get(ExchangeConstants._DEFAULT_LEFTOVER_REF_SHARE);\n    }\n\n    function virtualLeftoverReferralShare() external view returns(uint104, uint104, uint48) {\n        return (_leftoverReferralShare.data.oldResult, _leftoverReferralShare.data.result, _leftoverReferralShare.data.time);\n    }\n\n    //\n\n    function leftoverTeamShare() external view override returns(uint256) {\n        return ExchangeConstants._LEFTOVER_TOTAL_SHARE\n            .sub(_leftoverGovernanceShare.data.current())\n            .sub(_leftoverReferralShare.data.current());\n    }\n\n    function leftoverTeamShareVotes(address user) external view returns(uint256) {\n        return ExchangeConstants._LEFTOVER_TOTAL_SHARE\n            .sub(_leftoverGovernanceShare.votes[user].get(ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE))\n            .sub(_leftoverReferralShare.votes[user].get(ExchangeConstants._DEFAULT_LEFTOVER_REF_SHARE));\n    }\n\n    function virtualLeftoverTeamShare() external view returns(uint104, uint104, uint48) {\n        return (\n            ExchangeConstants._LEFTOVER_TOTAL_SHARE\n                .sub(_leftoverGovernanceShare.data.oldResult)\n                .sub(_leftoverReferralShare.data.oldResult).toUint104(),\n            ExchangeConstants._LEFTOVER_TOTAL_SHARE\n                .sub(_leftoverGovernanceShare.data.result)\n                .sub(_leftoverReferralShare.data.result).toUint104(),\n            _leftoverGovernanceShare.data.time\n        );\n    }\n\n    ///\n\n    function leftoverShareVote(uint256 govShare, uint256 refShare) external {\n        uint256 teamShare = ExchangeConstants._LEFTOVER_TOTAL_SHARE\n            .sub(govShare.add(refShare), \"Leftover shares are too high\");\n\n        uint256 balance = balanceOf(msg.sender);\n        uint256 supply = totalSupply();\n\n        _leftoverGovernanceShare.updateVote(\n            msg.sender,\n            _leftoverGovernanceShare.votes[msg.sender],\n            Vote.init(govShare),\n            balance,\n            supply,\n            ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE,\n            _emitLeftoverGovernanceShareVoteUpdate\n        );\n\n        _leftoverReferralShare.updateVote(\n            msg.sender,\n            _leftoverReferralShare.votes[msg.sender],\n            Vote.init(refShare),\n            balance,\n            supply,\n            ExchangeConstants._DEFAULT_LEFTOVER_REF_SHARE,\n            _emitLeftoverReferralShareVoteUpdate\n        );\n\n        _emitLeftoverTeamShareVoteUpdate(msg.sender, teamShare, false, balance);\n    }\n\n    function discardLeftoverShareVote() external {\n        uint256 balance = balanceOf(msg.sender);\n        uint256 supply = totalSupply();\n\n        _leftoverGovernanceShare.updateVote(\n           msg.sender,\n           _leftoverGovernanceShare.votes[msg.sender],\n           Vote.init(),\n           balance,\n           supply,\n           ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE,\n           _emitLeftoverGovernanceShareVoteUpdate\n        );\n\n        _leftoverReferralShare.updateVote(\n           msg.sender,\n           _leftoverReferralShare.votes[msg.sender],\n           Vote.init(),\n           balance,\n           supply,\n           ExchangeConstants._DEFAULT_LEFTOVER_REF_SHARE,\n           _emitLeftoverReferralShareVoteUpdate\n        );\n\n        _emitLeftoverTeamShareVoteUpdate(msg.sender, ExchangeConstants._DEFAULT_LEFTOVER_TEAM_SHARE, true, balance);\n    }\n\n    function _notifyStakeChanged(address account, uint256 newBalance) internal override {\n        uint256 balance = _set(account, newBalance);\n        if (newBalance == balance) {\n            return;\n        }\n\n        Vote.Data memory govShareVote = _leftoverGovernanceShare.votes[account];\n        Vote.Data memory refShareVote = _leftoverReferralShare.votes[account];\n        uint256 teamShare = ExchangeConstants._LEFTOVER_TOTAL_SHARE\n            .sub(govShareVote.get(ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE))\n            .sub(refShareVote.get(ExchangeConstants._DEFAULT_LEFTOVER_REF_SHARE));\n        uint256 supply = totalSupply();\n\n        _leftoverGovernanceShare.updateBalance(\n            account,\n            govShareVote,\n            balance,\n            newBalance,\n            supply,\n            ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE,\n            _emitLeftoverGovernanceShareVoteUpdate\n        );\n\n        _leftoverReferralShare.updateBalance(\n            account,\n            refShareVote,\n            balance,\n            newBalance,\n            supply,\n            ExchangeConstants._DEFAULT_LEFTOVER_REF_SHARE,\n            _emitLeftoverReferralShareVoteUpdate\n        );\n\n        _emitLeftoverTeamShareVoteUpdate(\n            account,\n            teamShare,\n            govShareVote.isDefault(),\n            newBalance\n        );\n    }\n\n    function _emitLeftoverGovernanceShareVoteUpdate(address user, uint256 newDefaultShare, bool isDefault, uint256 balance) private {\n        emit LeftoverGovernanceShareUpdate(user, newDefaultShare, isDefault, balance);\n    }\n\n    function _emitLeftoverReferralShareVoteUpdate(address user, uint256 newDefaultShare, bool isDefault, uint256 balance) private {\n        emit LeftoverReferralShareUpdate(user, newDefaultShare, isDefault, balance);\n    }\n\n    function _emitLeftoverTeamShareVoteUpdate(address user, uint256 newDefaultShare, bool isDefault, uint256 balance) private {\n        emit LeftoverTeamShareUpdate(user, newDefaultShare, isDefault, balance);\n    }\n}\n"
9     },
10     "/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/interfaces/IExchangeGovernance.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n\ninterface IExchangeGovernance {\n    function parameters() external view returns(uint256, uint256, uint256);\n\n    function leftoverReferralShare() external view returns(uint256);\n    function leftoverGovernanceShare() external view returns(uint256);\n    function leftoverTeamShare() external view returns(uint256);\n}\n"
12     },
13     "/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/interfaces/IGovernanceModule.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n\ninterface IGovernanceModule {\n    function notifyStakeChanged(address account, uint256 newBalance) external;\n    function notifyStakesChanged(address[] calldata accounts, uint256[] calldata newBalances) external;\n}\n"
15     },
16     "/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/libraries/ExchangeConstants.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n\nlibrary ExchangeConstants {\n    uint256 internal constant _LEFTOVER_TOTAL_SHARE = 1e18;           // 100%\n    uint256 internal constant _DEFAULT_LEFTOVER_GOV_SHARE = 0.34e18;  // 34%\n    uint256 internal constant _DEFAULT_LEFTOVER_REF_SHARE = 0.33e18;  // 33%\n    uint256 internal constant _DEFAULT_LEFTOVER_TEAM_SHARE = 0.33e18; // 33%\n}\n"
18     },
19     "/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/libraries/LiquidVoting.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./SafeCast.sol\";\nimport \"./VirtualVote.sol\";\nimport \"./Vote.sol\";\n\n\nlibrary LiquidVoting {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using Vote for Vote.Data;\n    using VirtualVote for VirtualVote.Data;\n\n    struct Data {\n        VirtualVote.Data data;\n        uint256 _weightedSum;\n        uint256 _defaultVotes;\n        mapping(address => Vote.Data) votes;\n    }\n\n    function updateVote(\n        LiquidVoting.Data storage self,\n        address user,\n        Vote.Data memory oldVote,\n        Vote.Data memory newVote,\n        uint256 balance,\n        uint256 totalSupply,\n        uint256 defaultVote,\n        function(address, uint256, bool, uint256) emitEvent\n    ) internal {\n        return _update(self, user, oldVote, newVote, balance, balance, totalSupply, defaultVote, emitEvent);\n    }\n\n    function updateBalance(\n        LiquidVoting.Data storage self,\n        address user,\n        Vote.Data memory oldVote,\n        uint256 oldBalance,\n        uint256 newBalance,\n        uint256 newTotalSupply,\n        uint256 defaultVote,\n        function(address, uint256, bool, uint256) emitEvent\n    ) internal {\n        return _update(self, user, oldVote, newBalance == 0 ? Vote.init() : oldVote, oldBalance, newBalance, newTotalSupply, defaultVote, emitEvent);\n    }\n\n    function _update(\n        LiquidVoting.Data storage self,\n        address user,\n        Vote.Data memory oldVote,\n        Vote.Data memory newVote,\n        uint256 oldBalance,\n        uint256 newBalance,\n        uint256 newTotalSupply,\n        uint256 defaultVote,\n        function(address, uint256, bool, uint256) emitEvent\n    ) private {\n        uint256 oldWeightedSum = self._weightedSum;\n        uint256 newWeightedSum = oldWeightedSum;\n        uint256 oldDefaultVotes = self._defaultVotes;\n        uint256 newDefaultVotes = oldDefaultVotes;\n\n        if (oldVote.isDefault()) {\n            newDefaultVotes = newDefaultVotes.sub(oldBalance);\n        } else {\n            newWeightedSum = newWeightedSum.sub(oldBalance.mul(oldVote.get(defaultVote)));\n        }\n\n        if (newVote.isDefault()) {\n            newDefaultVotes = newDefaultVotes.add(newBalance);\n        } else {\n            newWeightedSum = newWeightedSum.add(newBalance.mul(newVote.get(defaultVote)));\n        }\n\n        if (newWeightedSum != oldWeightedSum) {\n            self._weightedSum = newWeightedSum;\n        }\n\n        if (newDefaultVotes != oldDefaultVotes) {\n            self._defaultVotes = newDefaultVotes;\n        }\n\n        {\n            uint256 newResult = newTotalSupply == 0 ? defaultVote : newWeightedSum.add(newDefaultVotes.mul(defaultVote)).div(newTotalSupply);\n            VirtualVote.Data memory data = self.data;\n            if (newResult != data.result) {\n                self.data.oldResult = data.current().toUint104();\n                self.data.result = newResult.toUint104();\n                self.data.time = block.timestamp.toUint48();\n            }\n        }\n\n        if (!newVote.eq(oldVote)) {\n            self.votes[user] = newVote;\n        }\n\n        emitEvent(user, newVote.get(defaultVote), newVote.isDefault(), newBalance);\n    }\n}\n"
21     },
22     "/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/libraries/SafeCast.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nlibrary SafeCast {\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value < 2**216, \"value does not fit in 216 bits\");\n        return uint216(value);\n    }\n\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value < 2**104, \"value does not fit in 104 bits\");\n        return uint104(value);\n    }\n\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value < 2**48, \"value does not fit in 48 bits\");\n        return uint48(value);\n    }\n\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value < 2**40, \"value does not fit in 40 bits\");\n        return uint40(value);\n    }\n}\n"
24     },
25     "/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/libraries/VirtualVote.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\nlibrary VirtualVote {\n    using SafeMath for uint256;\n\n    uint256 private constant _VOTE_DECAY_PERIOD = 1 days;\n\n    struct Data {\n        uint104 oldResult;\n        uint104 result;\n        uint48 time;\n    }\n\n    function current(VirtualVote.Data memory self) internal view returns(uint256) {\n        uint256 timePassed = Math.min(_VOTE_DECAY_PERIOD, block.timestamp.sub(self.time));\n        uint256 timeRemain = _VOTE_DECAY_PERIOD.sub(timePassed);\n        return uint256(self.oldResult).mul(timeRemain).add(\n            uint256(self.result).mul(timePassed)\n        ).div(_VOTE_DECAY_PERIOD);\n    }\n}\n"
27     },
28     "/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/libraries/Vote.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\n\nlibrary Vote {\n    struct Data {\n        uint256 value;\n    }\n\n    function eq(Vote.Data memory self, Vote.Data memory vote) internal pure returns(bool) {\n        return self.value == vote.value;\n    }\n\n    function init() internal pure returns(Vote.Data memory data) {\n        return Vote.Data({\n            value: 0\n        });\n    }\n\n    function init(uint256 vote) internal pure returns(Vote.Data memory data) {\n        return Vote.Data({\n            value: vote + 1\n        });\n    }\n\n    function isDefault(Data memory self) internal pure returns(bool) {\n        return self.value == 0;\n    }\n\n    function get(Data memory self, uint256 defaultVote) internal pure returns(uint256) {\n        if (self.value > 0) {\n            return self.value - 1;\n        }\n        return defaultVote;\n    }\n\n    function get(Data memory self, function() external view returns(uint256) defaultVoteFn) internal view returns(uint256) {\n        if (self.value > 0) {\n            return self.value - 1;\n        }\n        return defaultVoteFn();\n    }\n}\n"
30     },
31     "/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/utils/BalanceAccounting.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\ncontract BalanceAccounting {\n    using SafeMath for uint256;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        _balances[account] = _balances[account].sub(amount, \"Burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n    }\n\n    function _set(address account, uint256 amount) internal virtual returns(uint256 oldAmount) {\n        oldAmount = _balances[account];\n        if (oldAmount != amount) {\n            _balances[account] = amount;\n            _totalSupply = _totalSupply.add(amount).sub(oldAmount);\n        }\n    }\n}\n"
33     },
34     "@openzeppelin/contracts/math/Math.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
36     },
37     "@openzeppelin/contracts/math/SafeMath.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
39     }
40   },
41   "settings": {
42     "remappings": [],
43     "optimizer": {
44       "enabled": true,
45       "runs": 10000
46     },
47     "evmVersion": "istanbul",
48     "libraries": {},
49     "outputSelection": {
50       "*": {
51         "*": [
52           "evm.bytecode",
53           "evm.deployedBytecode",
54           "abi"
55         ]
56       }
57     }
58   }
59 }}