1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/modules/capital/Pool.sol": {
5       "content": "/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"../../abstract/MasterAware.sol\";\nimport \"../cover/Quotation.sol\";\nimport \"../oracles/PriceFeedOracle.sol\";\nimport \"../token/NXMToken.sol\";\nimport \"../token/TokenController.sol\";\nimport \"./MCR.sol\";\nimport \"./SwapAgent.sol\";\n\ncontract Pool is MasterAware, ReentrancyGuard {\n  using Address for address;\n  using SafeMath for uint;\n  using SafeERC20 for IERC20;\n\n  /* storage */\n  address[] public assets;\n  mapping(address => SwapAgent.AssetData) public assetData;\n\n  // contracts\n  Quotation public quotation;\n  NXMToken public nxmToken;\n  TokenController public tokenController;\n  MCR public mcr;\n\n  // parameters\n  address public twapOracle;\n  address public swapController;\n  uint public minPoolEth;\n  PriceFeedOracle public priceFeedOracle;\n\n  /* constants */\n  address constant public ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  uint public constant MCR_RATIO_DECIMALS = 4;\n  uint public constant MAX_MCR_RATIO = 40000; // 400%\n  uint public constant MAX_BUY_SELL_MCR_ETH_FRACTION = 500; // 5%. 4 decimal points\n\n  uint internal constant CONSTANT_C = 5800000;\n  uint internal constant CONSTANT_A = 1028 * 1e13;\n  uint internal constant TOKEN_EXPONENT = 4;\n\n  /* events */\n  event Payout(address indexed to, address indexed asset, uint amount);\n  event NXMSold (address indexed member, uint nxmIn, uint ethOut);\n  event NXMBought (address indexed member, uint ethIn, uint nxmOut);\n  event Swapped(address indexed fromAsset, address indexed toAsset, uint amountIn, uint amountOut);\n\n  /* logic */\n  modifier onlySwapController {\n    require(msg.sender == swapController, \"Pool: not swapController\");\n    _;\n  }\n\n  constructor (\n    address[] memory _assets,\n    uint112[] memory _minAmounts,\n    uint112[] memory _maxAmounts,\n    uint[] memory _maxSlippageRatios,\n    address _master,\n    address _priceOracle,\n    address _twapOracle,\n    address _swapController\n  ) public {\n\n    require(_assets.length == _minAmounts.length, \"Pool: length mismatch\");\n    require(_assets.length == _maxAmounts.length, \"Pool: length mismatch\");\n    require(_assets.length == _maxSlippageRatios.length, \"Pool: length mismatch\");\n\n    for (uint i = 0; i < _assets.length; i++) {\n\n      address asset = _assets[i];\n      require(asset != address(0), \"Pool: asset is zero address\");\n      require(_maxAmounts[i] >= _minAmounts[i], \"Pool: max < min\");\n      require(_maxSlippageRatios[i] <= 1 ether, \"Pool: max < min\");\n\n      assets.push(asset);\n      assetData[asset].minAmount = _minAmounts[i];\n      assetData[asset].maxAmount = _maxAmounts[i];\n      assetData[asset].maxSlippageRatio = _maxSlippageRatios[i];\n    }\n\n    master = INXMMaster(_master);\n    priceFeedOracle = PriceFeedOracle(_priceOracle);\n    twapOracle = _twapOracle;\n    swapController = _swapController;\n  }\n\n  // fallback function\n  function() external payable {}\n\n  // for legacy Pool1 upgrade compatibility\n  function sendEther() external payable {}\n\n  /**\n   * @dev Calculates total value of all pool assets in ether\n   */\n  function getPoolValueInEth() public view returns (uint) {\n\n    uint total = address(this).balance;\n\n    for (uint i = 0; i < assets.length; i++) {\n\n      address assetAddress = assets[i];\n      IERC20 token = IERC20(assetAddress);\n\n      uint rate = priceFeedOracle.getAssetToEthRate(assetAddress);\n      require(rate > 0, \"Pool: zero rate\");\n\n      uint assetBalance = token.balanceOf(address(this));\n      uint assetValue = assetBalance.mul(rate).div(1e18);\n\n      total = total.add(assetValue);\n    }\n\n    return total;\n  }\n\n  /* asset related functions */\n\n  function getAssets() external view returns (address[] memory) {\n    return assets;\n  }\n\n  function getAssetDetails(address _asset) external view returns (\n    uint balance,\n    uint112 min,\n    uint112 max,\n    uint32 lastAssetSwapTime,\n    uint maxSlippageRatio\n  ) {\n\n    IERC20 token = IERC20(_asset);\n    balance = token.balanceOf(address(this));\n    SwapAgent.AssetData memory data = assetData[_asset];\n\n    return (balance, data.minAmount, data.maxAmount, data.lastSwapTime, data.maxSlippageRatio);\n  }\n\n  function addAsset(\n    address _asset,\n    uint112 _min,\n    uint112 _max,\n    uint _maxSlippageRatio\n  ) external onlyGovernance {\n\n    require(_asset != address(0), \"Pool: asset is zero address\");\n    require(_max >= _min, \"Pool: max < min\");\n    require(_maxSlippageRatio <= 1 ether, \"Pool: max slippage ratio > 1\");\n\n    for (uint i = 0; i < assets.length; i++) {\n      require(_asset != assets[i], \"Pool: asset exists\");\n    }\n\n    assets.push(_asset);\n    assetData[_asset] = SwapAgent.AssetData(_min, _max, 0, _maxSlippageRatio);\n  }\n\n  function removeAsset(address _asset) external onlyGovernance {\n\n    for (uint i = 0; i < assets.length; i++) {\n\n      if (_asset != assets[i]) {\n        continue;\n      }\n\n      delete assetData[_asset];\n      assets[i] = assets[assets.length - 1];\n      assets.pop();\n\n      return;\n    }\n\n    revert(\"Pool: asset not found\");\n  }\n\n  function setAssetDetails(\n    address _asset,\n    uint112 _min,\n    uint112 _max,\n    uint _maxSlippageRatio\n  ) external onlyGovernance {\n\n    require(_min <= _max, \"Pool: min > max\");\n    require(_maxSlippageRatio <= 1 ether, \"Pool: max slippage ratio > 1\");\n\n    for (uint i = 0; i < assets.length; i++) {\n\n      if (_asset != assets[i]) {\n        continue;\n      }\n\n      assetData[_asset].minAmount = _min;\n      assetData[_asset].maxAmount = _max;\n      assetData[_asset].maxSlippageRatio = _maxSlippageRatio;\n\n      return;\n    }\n\n    revert(\"Pool: asset not found\");\n  }\n\n  /* swap functions */\n\n  function getSwapQuote(\n    uint tokenAmountIn,\n    IERC20 fromToken,\n    IERC20 toToken\n  ) public view returns (uint tokenAmountOut) {\n\n    return SwapAgent.getSwapQuote(\n      tokenAmountIn,\n      fromToken,\n      toToken\n    );\n  }\n\n  function swapETHForAsset(\n    address toTokenAddress,\n    uint amountIn,\n    uint amountOutMin\n  ) external whenNotPaused onlySwapController nonReentrant {\n\n    SwapAgent.AssetData storage assetDetails = assetData[toTokenAddress];\n\n    uint amountOut = SwapAgent.swapETHForAsset(\n      twapOracle,\n      assetDetails,\n      toTokenAddress,\n      amountIn,\n      amountOutMin,\n      minPoolEth\n    );\n\n    emit Swapped(ETH, toTokenAddress, amountIn, amountOut);\n  }\n\n  function swapAssetForETH(\n    address fromTokenAddress,\n    uint amountIn,\n    uint amountOutMin\n  ) external whenNotPaused onlySwapController nonReentrant {\n\n    uint amountOut = SwapAgent.swapAssetForETH(\n      twapOracle,\n      assetData[fromTokenAddress],\n      fromTokenAddress,\n      amountIn,\n      amountOutMin\n    );\n\n    emit Swapped(fromTokenAddress, ETH, amountIn, amountOut);\n  }\n\n  /* claim related functions */\n\n  /**\n   * @dev Execute the payout in case a claim is accepted\n   * @param asset token address or 0xEee...EEeE for ether\n   * @param payoutAddress send funds to this address\n   * @param amount amount to send\n   */\n  function sendClaimPayout (\n    address asset,\n    address payable payoutAddress,\n    uint amount\n  ) external onlyInternal nonReentrant returns (bool success) {\n\n    bool ok;\n\n    if (asset == ETH) {\n      // solhint-disable-next-line avoid-low-level-calls\n      (ok, /* data */) = payoutAddress.call.value(amount)(\"\");\n    } else {\n      ok =  _safeTokenTransfer(asset, payoutAddress, amount);\n    }\n\n    if (ok) {\n      emit Payout(payoutAddress, asset, amount);\n    }\n\n    return ok;\n  }\n\n  /**\n   * @dev safeTransfer implementation that does not revert\n   * @param tokenAddress ERC20 address\n   * @param to destination\n   * @param value amount to send\n   * @return success true if the transfer was successfull\n   */\n  function _safeTokenTransfer (\n    address tokenAddress,\n    address to,\n    uint256 value\n  ) internal returns (bool) {\n\n    // token address is not a contract\n    if (!tokenAddress.isContract()) {\n      return false;\n    }\n\n    IERC20 token = IERC20(tokenAddress);\n    bytes memory data = abi.encodeWithSelector(token.transfer.selector, to, value);\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = tokenAddress.call(data);\n\n    // low-level call failed/reverted\n    if (!success) {\n      return false;\n    }\n\n    // tokens that don't have return data\n    if (returndata.length == 0) {\n      return true;\n    }\n\n    // tokens that have return data will return a bool\n    return abi.decode(returndata, (bool));\n  }\n\n  /* pool lifecycle functions */\n\n  function transferAsset(\n    address asset,\n    address payable destination,\n    uint amount\n  ) external onlyGovernance nonReentrant {\n\n    require(assetData[asset].maxAmount == 0, \"Pool: max not zero\");\n    require(destination != address(0), \"Pool: dest zero\");\n\n    IERC20 token = IERC20(asset);\n    uint balance = token.balanceOf(address(this));\n    uint transferableAmount = amount > balance ? balance : amount;\n\n    token.safeTransfer(destination, transferableAmount);\n  }\n\n  function upgradeCapitalPool(address payable newPoolAddress) external onlyMaster nonReentrant {\n\n    // transfer ether\n    uint ethBalance = address(this).balance;\n    (bool ok, /* data */) = newPoolAddress.call.value(ethBalance)(\"\");\n    require(ok, \"Pool: transfer failed\");\n\n    // transfer assets\n    for (uint i = 0; i < assets.length; i++) {\n      IERC20 token = IERC20(assets[i]);\n      uint tokenBalance = token.balanceOf(address(this));\n      token.safeTransfer(newPoolAddress, tokenBalance);\n    }\n\n  }\n\n  /**\n   * @dev Update dependent contract address\n   * @dev Implements MasterAware interface function\n   */\n  function changeDependentContractAddress() public {\n    nxmToken = NXMToken(master.tokenAddress());\n    tokenController = TokenController(master.getLatestAddress(\"TC\"));\n    quotation = Quotation(master.getLatestAddress(\"QT\"));\n    mcr = MCR(master.getLatestAddress(\"MC\"));\n  }\n\n  /* cover purchase functions */\n\n  /// @dev Enables user to purchase cover with funding in ETH.\n  /// @param smartCAdd Smart Contract Address\n  function makeCoverBegin(\n    address smartCAdd,\n    bytes4 coverCurr,\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) public payable onlyMember whenNotPaused {\n\n    require(coverCurr == \"ETH\", \"Pool: Unexpected asset type\");\n    require(msg.value == coverDetails[1], \"Pool: ETH amount does not match premium\");\n\n    quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n  }\n\n  /**\n   * @dev Enables user to purchase cover via currency asset eg DAI\n   */\n  function makeCoverUsingCA(\n    address smartCAdd,\n    bytes4 coverCurr,\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) public onlyMember whenNotPaused {\n    require(coverCurr != \"ETH\", \"Pool: Unexpected asset type\");\n    quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n  }\n\n  function transferAssetFrom (address asset, address from, uint amount) public onlyInternal whenNotPaused {\n    IERC20 token = IERC20(asset);\n    token.safeTransferFrom(from, address(this), amount);\n  }\n\n  /* token sale functions */\n\n  /**\n   * @dev (DEPRECATED, use sellTokens function instead) Allows selling of NXM for ether.\n   * Seller first needs to give this contract allowance to\n   * transfer/burn tokens in the NXMToken contract\n   * @param  _amount Amount of NXM to sell\n   * @return success returns true on successfull sale\n   */\n  function sellNXMTokens(uint _amount) public onlyMember whenNotPaused returns (bool success) {\n    sellNXM(_amount, 0);\n    return true;\n  }\n\n  /**\n   * @dev (DEPRECATED, use calculateNXMForEth function instead) Returns the amount of wei a seller will get for selling NXM\n   * @param amount Amount of NXM to sell\n   * @return weiToPay Amount of wei the seller will get\n   */\n  function getWei(uint amount) external view returns (uint weiToPay) {\n    return getEthForNXM(amount);\n  }\n\n  /**\n   * @dev Buys NXM tokens with ETH.\n   * @param  minTokensOut Minimum amount of tokens to be bought. Revert if boughtTokens falls below this number.\n   * @return boughtTokens number of bought tokens.\n   */\n  function buyNXM(uint minTokensOut) public payable onlyMember whenNotPaused {\n\n    uint ethIn = msg.value;\n    require(ethIn > 0, \"Pool: ethIn > 0\");\n\n    uint totalAssetValue = getPoolValueInEth().sub(ethIn);\n    uint mcrEth = mcr.getLastMCREther();\n    uint mcrRatio = calculateMCRRatio(totalAssetValue, mcrEth);\n    require(mcrRatio <= MAX_MCR_RATIO, \"Pool: Cannot purchase if MCR% > 400%\");\n    uint tokensOut = calculateNXMForEth(ethIn, totalAssetValue, mcrEth);\n    require(tokensOut >= minTokensOut, \"Pool: tokensOut is less than minTokensOut\");\n    tokenController.mint(msg.sender, tokensOut);\n\n    emit NXMBought(msg.sender, ethIn, tokensOut);\n  }\n\n  /**\n   * @dev Sell NXM tokens and receive ETH.\n   * @param tokenAmount Amount of tokens to sell.\n   * @param  minEthOut Minimum amount of ETH to be received. Revert if ethOut falls below this number.\n   * @return ethOut amount of ETH received in exchange for the tokens.\n   */\n  function sellNXM(uint tokenAmount, uint minEthOut) public onlyMember nonReentrant whenNotPaused {\n\n    require(nxmToken.balanceOf(msg.sender) >= tokenAmount, \"Pool: Not enough balance\");\n    require(nxmToken.isLockedForMV(msg.sender) <= now, \"Pool: NXM tokens are locked for voting\");\n\n    uint currentTotalAssetValue = getPoolValueInEth();\n    uint mcrEth = mcr.getLastMCREther();\n    uint ethOut = calculateEthForNXM(tokenAmount, currentTotalAssetValue, mcrEth);\n    require(currentTotalAssetValue.sub(ethOut) >= mcrEth, \"Pool: MCR% cannot fall below 100%\");\n    require(ethOut >= minEthOut, \"Pool: ethOut < minEthOut\");\n\n    tokenController.burnFrom(msg.sender, tokenAmount);\n    (bool ok, /* data */) = msg.sender.call.value(ethOut)(\"\");\n    require(ok, \"Pool: Sell transfer failed\");\n\n    emit NXMSold(msg.sender, tokenAmount, ethOut);\n  }\n\n  /**\n   * @dev Get value in tokens for an ethAmount purchase.\n   * @param ethAmount amount of ETH used for buying.\n   * @return tokenValue tokens obtained by buying worth of ethAmount\n   */\n  function getNXMForEth(\n    uint ethAmount\n  ) public view returns (uint) {\n    uint totalAssetValue = getPoolValueInEth();\n    uint mcrEth = mcr.getLastMCREther();\n    return calculateNXMForEth(ethAmount, totalAssetValue, mcrEth);\n  }\n\n  function calculateNXMForEth(\n    uint ethAmount,\n    uint currentTotalAssetValue,\n    uint mcrEth\n  ) public pure returns (uint) {\n\n    require(\n      ethAmount <= mcrEth.mul(MAX_BUY_SELL_MCR_ETH_FRACTION).div(10 ** MCR_RATIO_DECIMALS),\n      \"Pool: Purchases worth higher than 5% of MCReth are not allowed\"\n    );\n\n    /*\n      The price formula is:\n      P(V) = A + MCReth / C *  MCR% ^ 4\n      where MCR% = V / MCReth\n      P(V) = A + 1 / (C * MCReth ^ 3) *  V ^ 4\n\n      To compute the number of tokens issued we can integrate with respect to V the following:\n        ΔT = ΔV / P(V)\n        which assumes that for an infinitesimally small change in locked value V price is constant and we\n        get an infinitesimally change in token supply ΔT.\n      This is not computable on-chain, below we use an approximation that works well assuming\n       * MCR% stays within [100%, 400%]\n       * ethAmount <= 5% * MCReth\n\n      Use a simplified formula excluding the constant A price offset to compute the amount of tokens to be minted.\n      AdjustedP(V) = 1 / (C * MCReth ^ 3) *  V ^ 4\n      AdjustedP(V) = 1 / (C * MCReth ^ 3) *  V ^ 4\n\n      For a very small variation in tokens ΔT, we have,  ΔT = ΔV / P(V), to get total T we integrate with respect to V.\n      adjustedTokenAmount = ∫ (dV / AdjustedP(V)) from V0 (currentTotalAssetValue) to V1 (nextTotalAssetValue)\n      adjustedTokenAmount = ∫ ((C * MCReth ^ 3) / V ^ 4 * dV) from V0 to V1\n      Evaluating the above using the antiderivative of the function we get:\n      adjustedTokenAmount = - MCReth ^ 3 * C / (3 * V1 ^3) + MCReth * C /(3 * V0 ^ 3)\n    */\n\n    if (currentTotalAssetValue == 0 || mcrEth.div(currentTotalAssetValue) > 1e12) {\n      /*\n       If the currentTotalAssetValue = 0, adjustedTokenPrice approaches 0. Therefore we can assume the price is A.\n       If currentTotalAssetValue is far smaller than mcrEth, MCR% approaches 0, let the price be A (baseline price).\n       This avoids overflow in the calculateIntegralAtPoint computation.\n       This approximation is safe from arbitrage since at MCR% < 100% no sells are possible.\n      */\n      uint tokenPrice = CONSTANT_A;\n      return ethAmount.mul(1e18).div(tokenPrice);\n    }\n\n    // MCReth * C /(3 * V0 ^ 3)\n    uint point0 = calculateIntegralAtPoint(currentTotalAssetValue, mcrEth);\n    // MCReth * C / (3 * V1 ^3)\n    uint nextTotalAssetValue = currentTotalAssetValue.add(ethAmount);\n    uint point1 = calculateIntegralAtPoint(nextTotalAssetValue, mcrEth);\n    uint adjustedTokenAmount = point0.sub(point1);\n    /*\n      Compute a preliminary adjustedTokenPrice for the minted tokens based on the adjustedTokenAmount above,\n      and to that add the A constant (the price offset previously removed in the adjusted Price formula)\n      to obtain the finalPrice and ultimately the tokenValue based on the finalPrice.\n\n      adjustedPrice = ethAmount / adjustedTokenAmount\n      finalPrice = adjustedPrice + A\n      tokenValue = ethAmount  / finalPrice\n    */\n    // ethAmount is multiplied by 1e18 to cancel out the multiplication factor of 1e18 of the adjustedTokenAmount\n    uint adjustedTokenPrice = ethAmount.mul(1e18).div(adjustedTokenAmount);\n    uint tokenPrice = adjustedTokenPrice.add(CONSTANT_A);\n\n    return ethAmount.mul(1e18).div(tokenPrice);\n  }\n\n  /**\n   * @dev integral(V) =  MCReth ^ 3 * C / (3 * V ^ 3) * 1e18\n   * computation result is multiplied by 1e18 to allow for a precision of 18 decimals.\n   * NOTE: omits the minus sign of the correct integral to use a uint result type for simplicity\n   * WARNING: this low-level function should be called from a contract which checks that\n   * mcrEth / assetValue < 1e17 (no overflow) and assetValue != 0\n   */\n  function calculateIntegralAtPoint(\n    uint assetValue,\n    uint mcrEth\n  ) internal pure returns (uint) {\n\n    return CONSTANT_C\n      .mul(1e18)\n      .div(3)\n      .mul(mcrEth).div(assetValue)\n      .mul(mcrEth).div(assetValue)\n      .mul(mcrEth).div(assetValue);\n  }\n\n  function getEthForNXM(uint nxmAmount) public view returns (uint ethAmount) {\n    uint currentTotalAssetValue = getPoolValueInEth();\n    uint mcrEth = mcr.getLastMCREther();\n    return calculateEthForNXM(nxmAmount, currentTotalAssetValue, mcrEth);\n  }\n\n  /**\n   * @dev Computes token sell value for a tokenAmount in ETH with a sell spread of 2.5%.\n   * for values in ETH of the sale <= 1% * MCReth the sell spread is very close to the exact value of 2.5%.\n   * for values higher than that sell spread may exceed 2.5%\n   * (The higher amount being sold at any given time the higher the spread)\n   */\n  function calculateEthForNXM(\n    uint nxmAmount,\n    uint currentTotalAssetValue,\n    uint mcrEth\n  ) public pure returns (uint) {\n\n    // Step 1. Calculate spot price at current values and amount of ETH if tokens are sold at that price\n    uint spotPrice0 = calculateTokenSpotPrice(currentTotalAssetValue, mcrEth);\n    uint spotEthAmount = nxmAmount.mul(spotPrice0).div(1e18);\n\n    //  Step 2. Calculate spot price using V = currentTotalAssetValue - spotEthAmount from step 1\n    uint totalValuePostSpotPriceSell = currentTotalAssetValue.sub(spotEthAmount);\n    uint spotPrice1 = calculateTokenSpotPrice(totalValuePostSpotPriceSell, mcrEth);\n\n    // Step 3. Min [average[Price(0), Price(1)] x ( 1 - Sell Spread), Price(1) ]\n    // Sell Spread = 2.5%\n    uint averagePriceWithSpread = spotPrice0.add(spotPrice1).div(2).mul(975).div(1000);\n    uint finalPrice = averagePriceWithSpread < spotPrice1 ? averagePriceWithSpread : spotPrice1;\n    uint ethAmount = finalPrice.mul(nxmAmount).div(1e18);\n\n    require(\n      ethAmount <= mcrEth.mul(MAX_BUY_SELL_MCR_ETH_FRACTION).div(10 ** MCR_RATIO_DECIMALS),\n      \"Pool: Sales worth more than 5% of MCReth are not allowed\"\n    );\n\n    return ethAmount;\n  }\n\n  function calculateMCRRatio(uint totalAssetValue, uint mcrEth) public pure returns (uint) {\n    return totalAssetValue.mul(10 ** MCR_RATIO_DECIMALS).div(mcrEth);\n  }\n\n  /**\n  * @dev Calculates token price in ETH 1 NXM token. TokenPrice = A + (MCReth / C) * MCR%^4\n  */\n  function calculateTokenSpotPrice(uint totalAssetValue, uint mcrEth) public pure returns (uint tokenPrice) {\n\n    uint mcrRatio = calculateMCRRatio(totalAssetValue, mcrEth);\n    uint precisionDecimals = 10 ** TOKEN_EXPONENT.mul(MCR_RATIO_DECIMALS);\n\n    return mcrEth\n      .mul(mcrRatio ** TOKEN_EXPONENT)\n      .div(CONSTANT_C)\n      .div(precisionDecimals)\n      .add(CONSTANT_A);\n  }\n\n  /**\n   * @dev Returns the NXM price in a given asset\n   * @param asset Asset name.\n   */\n  function getTokenPrice(address asset) public view returns (uint tokenPrice) {\n\n    uint totalAssetValue = getPoolValueInEth();\n    uint mcrEth = mcr.getLastMCREther();\n    uint tokenSpotPriceEth = calculateTokenSpotPrice(totalAssetValue, mcrEth);\n\n    return priceFeedOracle.getAssetForEth(asset, tokenSpotPriceEth);\n  }\n\n  function getMCRRatio() public view returns (uint) {\n    uint totalAssetValue = getPoolValueInEth();\n    uint mcrEth = mcr.getLastMCREther();\n    return calculateMCRRatio(totalAssetValue, mcrEth);\n  }\n\n  function updateUintParameters(bytes8 code, uint value) external onlyGovernance {\n\n    if (code == \"MIN_ETH\") {\n      minPoolEth = value;\n      return;\n    }\n\n    revert(\"Pool: unknown parameter\");\n  }\n\n  function updateAddressParameters(bytes8 code, address value) external onlyGovernance {\n\n    if (code == \"TWAP\") {\n      twapOracle = value;\n      return;\n    }\n\n    if (code == \"SWAP\") {\n      swapController = value;\n      return;\n    }\n\n    if (code == \"PRC_FEED\") {\n      priceFeedOracle = PriceFeedOracle(value);\n      return;\n    }\n\n    revert(\"Pool: unknown parameter\");\n  }\n}\n"
6     },
7     "@openzeppelin/contracts/math/SafeMath.sol": {
8       "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
9     },
10     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
11       "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
12     },
13     "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
14       "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
15     },
16     "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
17       "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n * metering changes introduced in the Istanbul hardfork.\n */\ncontract ReentrancyGuard {\n    bool private _notEntered;\n\n    constructor () internal {\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}\n"
18     },
19     "@openzeppelin/contracts/utils/Address.sol": {
20       "content": "pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
21     },
22     "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
23       "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
24     },
25     "contracts/abstract/MasterAware.sol": {
26       "content": "/*\n    Copyright (C) 2020 NexusMutual.io\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/\n*/\n\npragma solidity ^0.5.0;\n\nimport \"./INXMMaster.sol\";\n\ncontract MasterAware {\n\n  INXMMaster public master;\n\n  modifier onlyMember {\n    require(master.isMember(msg.sender), \"Caller is not a member\");\n    _;\n  }\n\n  modifier onlyInternal {\n    require(master.isInternal(msg.sender), \"Caller is not an internal contract\");\n    _;\n  }\n\n  modifier onlyMaster {\n    if (address(master) != address(0)) {\n      require(address(master) == msg.sender, \"Not master\");\n    }\n    _;\n  }\n\n  modifier onlyGovernance {\n    require(\n      master.checkIsAuthToGoverned(msg.sender),\n      \"Caller is not authorized to govern\"\n    );\n    _;\n  }\n\n  modifier whenPaused {\n    require(master.isPause(), \"System is not paused\");\n    _;\n  }\n\n  modifier whenNotPaused {\n    require(!master.isPause(), \"System is paused\");\n    _;\n  }\n\n  function changeMasterAddress(address masterAddress) public onlyMaster {\n    master = INXMMaster(masterAddress);\n  }\n}\n"
27     },
28     "contracts/modules/cover/Quotation.sol": {
29       "content": "/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../capital/MCR.sol\";\nimport \"../capital/PoolData.sol\";\nimport \"../claims/ClaimsReward.sol\";\nimport \"../governance/MemberRoles.sol\";\nimport \"../token/TokenController.sol\";\nimport \"../token/TokenData.sol\";\nimport \"../token/TokenFunctions.sol\";\nimport \"./QuotationData.sol\";\n\ncontract Quotation is Iupgradable {\n  using SafeMath for uint;\n\n  TokenFunctions public tf;\n  TokenController public tc;\n  TokenData public td;\n  Pool public pool;\n  PoolData public pd;\n  QuotationData public qd;\n  MCR public m1;\n  MemberRoles public mr;\n  ClaimsReward public cr;\n\n  bool internal locked;\n\n  event RefundEvent(address indexed user, bool indexed status, uint holdedCoverID, bytes32 reason);\n\n  modifier noReentrancy() {\n    require(!locked, \"Reentrant call.\");\n    locked = true;\n    _;\n    locked = false;\n  }\n\n  /**\n   * @dev Iupgradable Interface to update dependent contract address\n   */\n  function changeDependentContractAddress() public onlyInternal {\n    m1 = MCR(ms.getLatestAddress(\"MC\"));\n    tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\n    tc = TokenController(ms.getLatestAddress(\"TC\"));\n    td = TokenData(ms.getLatestAddress(\"TD\"));\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\n    pd = PoolData(ms.getLatestAddress(\"PD\"));\n    mr = MemberRoles(ms.getLatestAddress(\"MR\"));\n    cr = ClaimsReward(ms.getLatestAddress(\"CR\"));\n    pool = Pool(ms.getLatestAddress(\"P1\"));\n  }\n\n  function sendEther() public payable {\n\n  }\n\n  /**\n   * @dev Expires a cover after a set period of time.\n   * Changes the status of the Cover and reduces the current\n   * sum assured of all areas in which the quotation lies\n   * Unlocks the CN tokens of the cover. Updates the Total Sum Assured value.\n   * @param _cid Cover Id.\n   */\n  function expireCover(uint _cid) public {\n    require(checkCoverExpired(_cid) && qd.getCoverStatusNo(_cid) != uint(QuotationData.CoverStatus.CoverExpired));\n\n    tf.unlockCN(_cid);\n    bytes4 curr;\n    address scAddress;\n    uint sumAssured;\n    (,, scAddress, curr, sumAssured,) = qd.getCoverDetailsByCoverID1(_cid);\n    if (qd.getCoverStatusNo(_cid) != uint(QuotationData.CoverStatus.ClaimAccepted))\n      _removeSAFromCSA(_cid, sumAssured);\n    qd.changeCoverStatusNo(_cid, uint8(QuotationData.CoverStatus.CoverExpired));\n  }\n\n  /**\n   * @dev Checks if a cover should get expired/closed or not.\n   * @param _cid Cover Index.\n   * @return expire true if the Cover's time has expired, false otherwise.\n   */\n  function checkCoverExpired(uint _cid) public view returns (bool expire) {\n\n    expire = qd.getValidityOfCover(_cid) < uint64(now);\n\n  }\n\n  /**\n   * @dev Updates the Sum Assured Amount of all the quotation.\n   * @param _cid Cover id\n   * @param _amount that will get subtracted Current Sum Assured\n   * amount that comes under a quotation.\n   */\n  function removeSAFromCSA(uint _cid, uint _amount) public onlyInternal {\n    _removeSAFromCSA(_cid, _amount);\n  }\n\n  /**\n   * @dev Makes Cover funded via NXM tokens.\n   * @param smartCAdd Smart Contract Address\n   */\n  function makeCoverUsingNXMTokens(\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    bytes4 coverCurr,\n    address smartCAdd,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  )\n  public\n  isMemberAndcheckPause\n  {\n\n    tc.burnFrom(msg.sender, coverDetails[2]); // need burn allowance\n    _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s, true);\n  }\n\n  /**\n   * @dev Verifies cover details signed off chain.\n   * @param from address of funder.\n   * @param scAddress Smart Contract Address\n   */\n  function verifyCoverDetails(\n    address payable from,\n    address scAddress,\n    bytes4 coverCurr,\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  )\n  public\n  onlyInternal\n  {\n    _verifyCoverDetails(\n      from,\n      scAddress,\n      coverCurr,\n      coverDetails,\n      coverPeriod,\n      _v,\n      _r,\n      _s,\n      false\n    );\n  }\n\n  /**\n   * @dev Verifies signature.\n   * @param coverDetails details related to cover.\n   * @param coverPeriod validity of cover.\n   * @param smaratCA smarat contract address.\n   * @param _v argument from vrs hash.\n   * @param _r argument from vrs hash.\n   * @param _s argument from vrs hash.\n   */\n  function verifySign(\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    bytes4 curr,\n    address smaratCA,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  )\n  public\n  view\n  returns (bool)\n  {\n    require(smaratCA != address(0));\n    require(pd.capReached() == 1, \"Can not buy cover until cap reached for 1st time\");\n    bytes32 hash = getOrderHash(coverDetails, coverPeriod, curr, smaratCA);\n    return isValidSignature(hash, _v, _r, _s);\n  }\n\n  /**\n   * @dev Gets order hash for given cover details.\n   * @param coverDetails details realted to cover.\n   * @param coverPeriod validity of cover.\n   * @param smaratCA smarat contract address.\n   */\n  function getOrderHash(\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    bytes4 curr,\n    address smaratCA\n  )\n  public\n  view\n  returns (bytes32)\n  {\n    return keccak256(\n      abi.encodePacked(\n        coverDetails[0],\n        curr, coverPeriod,\n        smaratCA,\n        coverDetails[1],\n        coverDetails[2],\n        coverDetails[3],\n        coverDetails[4],\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @dev Verifies signature.\n   * @param hash order hash\n   * @param v argument from vrs hash.\n   * @param r argument from vrs hash.\n   * @param s argument from vrs hash.\n   */\n  function isValidSignature(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public view returns (bool) {\n    bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n    bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\n    address a = ecrecover(prefixedHash, v, r, s);\n    return (a == qd.getAuthQuoteEngine());\n  }\n\n  /**\n   * @dev to get the status of recently holded coverID\n   * @param userAdd is the user address in concern\n   * @return the status of the concerned coverId\n   */\n  function getRecentHoldedCoverIdStatus(address userAdd) public view returns (int) {\n\n    uint holdedCoverLen = qd.getUserHoldedCoverLength(userAdd);\n    if (holdedCoverLen == 0) {\n      return - 1;\n    } else {\n      uint holdedCoverID = qd.getUserHoldedCoverByIndex(userAdd, holdedCoverLen.sub(1));\n      return int(qd.holdedCoverIDStatus(holdedCoverID));\n    }\n  }\n\n  /**\n   * @dev to get the verdict of kyc process\n   * @param status is the kyc status\n   * @param _add is the address of member\n   */\n  function kycVerdict(address _add, bool status) public checkPause noReentrancy {\n    require(msg.sender == qd.kycAuthAddress());\n    _kycTrigger(status, _add);\n  }\n\n  /**\n   * @dev transfering Ethers to newly created quotation contract.\n   */\n  function transferAssetsToNewContract(address newAdd) public onlyInternal noReentrancy {\n    uint amount = address(this).balance;\n    IERC20 erc20;\n    if (amount > 0) {\n      // newAdd.transfer(amount);\n      Quotation newQT = Quotation(newAdd);\n      newQT.sendEther.value(amount)();\n    }\n    uint currAssetLen = pd.getAllCurrenciesLen();\n    for (uint64 i = 1; i < currAssetLen; i++) {\n      bytes4 currName = pd.getCurrenciesByIndex(i);\n      address currAddr = pd.getCurrencyAssetAddress(currName);\n      erc20 = IERC20(currAddr); // solhint-disable-line\n      if (erc20.balanceOf(address(this)) > 0) {\n        require(erc20.transfer(newAdd, erc20.balanceOf(address(this))));\n      }\n    }\n  }\n\n\n  /**\n   * @dev Creates cover of the quotation, changes the status of the quotation ,\n   * updates the total sum assured and locks the tokens of the cover against a quote.\n   * @param from Quote member Ethereum address.\n   */\n\n  function _makeCover(//solhint-disable-line\n    address payable from,\n    address scAddress,\n    bytes4 coverCurr,\n    uint[] memory coverDetails,\n    uint16 coverPeriod\n  )\n  internal\n  {\n    uint cid = qd.getCoverLength();\n\n    qd.addCover(\n      coverPeriod,\n      coverDetails[0],\n      from,\n      coverCurr,\n      scAddress,\n      coverDetails[1],\n      coverDetails[2]\n    );\n\n    uint coverNoteAmount = (coverDetails[2].mul(qd.tokensRetained())).div(100);\n    tc.mint(from, coverNoteAmount);\n    tf.lockCN(coverNoteAmount, coverPeriod, cid, from);\n    qd.addInTotalSumAssured(coverCurr, coverDetails[0]);\n    qd.addInTotalSumAssuredSC(scAddress, coverCurr, coverDetails[0]);\n\n    tf.pushStakerRewards(scAddress, coverDetails[2]);\n  }\n\n  /**\n   * @dev Makes a cover.\n   * @param from address of funder.\n   * @param scAddress Smart Contract Address\n   */\n  function _verifyCoverDetails(\n    address payable from,\n    address scAddress,\n    bytes4 coverCurr,\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s,\n    bool isNXM\n  ) internal {\n    require(coverDetails[3] > now);\n    require(!qd.timestampRepeated(coverDetails[4]));\n    qd.setTimestampRepeated(coverDetails[4]);\n    require(coverPeriod >= 30 && coverPeriod <= 365, \"Quotation: Cover period out of bounds\");\n\n    address asset = cr.getCurrencyAssetAddress(coverCurr);\n    if (coverCurr != \"ETH\" && !isNXM) {\n      pool.transferAssetFrom(asset, from, coverDetails[1]);\n    }\n\n    require(verifySign(coverDetails, coverPeriod, coverCurr, scAddress, _v, _r, _s));\n    _makeCover(from, scAddress, coverCurr, coverDetails, coverPeriod);\n  }\n\n  /**\n   * @dev Updates the Sum Assured Amount of all the quotation.\n   * @param _cid Cover id\n   * @param _amount that will get subtracted Current Sum Assured\n   * amount that comes under a quotation.\n   */\n  function _removeSAFromCSA(uint _cid, uint _amount) internal checkPause {\n    address _add;\n    bytes4 coverCurr;\n    (,, _add, coverCurr,,) = qd.getCoverDetailsByCoverID1(_cid);\n    qd.subFromTotalSumAssured(coverCurr, _amount);\n    qd.subFromTotalSumAssuredSC(_add, coverCurr, _amount);\n  }\n\n  /**\n   * @dev to trigger the kyc process\n   * @param status is the kyc status\n   * @param _add is the address of member\n   */\n  function _kycTrigger(bool status, address _add) internal {\n\n    uint holdedCoverLen = qd.getUserHoldedCoverLength(_add).sub(1);\n    uint holdedCoverID = qd.getUserHoldedCoverByIndex(_add, holdedCoverLen);\n    address payable userAdd;\n    address scAddress;\n    bytes4 coverCurr;\n    uint16 coverPeriod;\n    uint[]  memory coverDetails = new uint[](4);\n    IERC20 erc20;\n\n    (, userAdd, coverDetails) = qd.getHoldedCoverDetailsByID2(holdedCoverID);\n    (, scAddress, coverCurr, coverPeriod) = qd.getHoldedCoverDetailsByID1(holdedCoverID);\n    require(qd.refundEligible(userAdd));\n    qd.setRefundEligible(userAdd, false);\n    require(qd.holdedCoverIDStatus(holdedCoverID) == uint(QuotationData.HCIDStatus.kycPending));\n    uint joinFee = td.joiningFee();\n    if (status) {\n      mr.payJoiningFee.value(joinFee)(userAdd);\n      if (coverDetails[3] > now) {\n        qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycPass));\n        if (coverCurr == \"ETH\") {\n          (bool ok,) = address(pool).call.value(coverDetails[1])(\"\");\n          require(ok, \"Quotation: ether transfer to pool failed\");\n        } else {\n          erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); // solhint-disable-line\n          require(erc20.transfer(address(pool), coverDetails[1]));\n        }\n        emit RefundEvent(userAdd, status, holdedCoverID, \"KYC Passed\");\n        _makeCover(userAdd, scAddress, coverCurr, coverDetails, coverPeriod);\n\n      } else {\n        qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycPassNoCover));\n        if (coverCurr == \"ETH\") {\n          userAdd.transfer(coverDetails[1]);\n        } else {\n          erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); // solhint-disable-line\n          require(erc20.transfer(userAdd, coverDetails[1]));\n        }\n        emit RefundEvent(userAdd, status, holdedCoverID, \"Cover Failed\");\n      }\n    } else {\n      qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycFailedOrRefunded));\n      uint totalRefund = joinFee;\n      if (coverCurr == \"ETH\") {\n        totalRefund = coverDetails[1].add(joinFee);\n      } else {\n        erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); // solhint-disable-line\n        require(erc20.transfer(userAdd, coverDetails[1]));\n      }\n      userAdd.transfer(totalRefund);\n      emit RefundEvent(userAdd, status, holdedCoverID, \"KYC Failed\");\n    }\n\n  }\n}\n"
30     },
31     "contracts/modules/oracles/PriceFeedOracle.sol": {
32       "content": "/* Copyright (C) 2020 NexusMutual.io\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract Aggregator {\n  function latestAnswer() public view returns (int);\n}\n\ncontract PriceFeedOracle {\n  using SafeMath for uint;\n\n  mapping (address => address) public aggregators;\n  address public daiAddress;\n  address constant public ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  constructor (address[] memory assets, address[] memory _aggregators, address _daiAddress) public {\n    require(assets.length == _aggregators.length, \"PriceFeedOracle: assets and _aggregators need to have same length\");\n    for (uint i = 0; i < assets.length; i++) {\n      aggregators[assets[i]] = _aggregators[i];\n    }\n    daiAddress = _daiAddress;\n  }\n\n  /**\n   * @dev Returns the amount of ether in wei that are equivalent to 1 unit (10 ** decimals) of asset\n   * @param asset quoted currency\n   * @return price in ether\n   */\n  function getAssetToEthRate(address asset) public view returns (uint) {\n\n    if (asset == ETH) {\n      return 1 ether;\n    }\n\n    address aggregatorAddress = aggregators[asset];\n\n    if (aggregatorAddress == address(0)) {\n      revert(\"PriceFeedOracle: Oracle asset not found\");\n    }\n\n    int rate = Aggregator(aggregatorAddress).latestAnswer();\n    require(rate > 0, \"PriceFeedOracle: Rate must be > 0\");\n\n    return uint(rate);\n  }\n\n  /**\n  * @dev Returns the amount of currency that is equivalent to ethIn amount of ether.\n  * @param asset quoted  Supported values: [\"DAI\", \"ETH\"]\n  * @param ethIn amount of ether to be converted to the currency\n  * @return price in ether\n  */\n  function getAssetForEth(address asset, uint ethIn) external view returns (uint) {\n\n    if (asset == daiAddress) {\n      return ethIn.mul(1e18).div(getAssetToEthRate(daiAddress));\n    }\n\n    if (asset == ETH) {\n      return ethIn;\n    }\n\n    revert(\"PriceFeedOracle: Unknown asset\");\n  }\n\n}\n"
33     },
34     "contracts/modules/token/NXMToken.sol": {
35       "content": "/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\nimport \"./external/OZIERC20.sol\";\nimport \"./external/OZSafeMath.sol\";\n\ncontract NXMToken is OZIERC20 {\n  using OZSafeMath for uint256;\n\n  event WhiteListed(address indexed member);\n\n  event BlackListed(address indexed member);\n\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowed;\n\n  mapping(address => bool) public whiteListed;\n\n  mapping(address => uint) public isLockedForMV;\n\n  uint256 private _totalSupply;\n\n  string public name = \"NXM\";\n  string public symbol = \"NXM\";\n  uint8 public decimals = 18;\n  address public operator;\n\n  modifier canTransfer(address _to) {\n    require(whiteListed[_to]);\n    _;\n  }\n\n  modifier onlyOperator() {\n    if (operator != address(0))\n      require(msg.sender == operator);\n    _;\n  }\n\n  constructor(address _founderAddress, uint _initialSupply) public {\n    _mint(_founderAddress, _initialSupply);\n  }\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param owner The address to query the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address owner) public view returns (uint256) {\n    return _balances[owner];\n  }\n\n  /**\n  * @dev Function to check the amount of tokens that an owner allowed to a spender.\n  * @param owner address The address which owns the funds.\n  * @param spender address The address which will spend the funds.\n  * @return A uint256 specifying the amount of tokens still available for the spender.\n  */\n  function allowance(\n    address owner,\n    address spender\n  )\n  public\n  view\n  returns (uint256)\n  {\n    return _allowed[owner][spender];\n  }\n\n  /**\n  * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n  * Beware that changing an allowance with this method brings the risk that someone may use both the old\n  * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n  * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n  * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n  * @param spender The address which will spend the funds.\n  * @param value The amount of tokens to be spent.\n  */\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n  * @dev Increase the amount of tokens that an owner allowed to a spender.\n  * approve should be called when allowed_[_spender] == 0. To increment\n  * allowed value is better to use this function to avoid 2 calls (and wait until\n  * the first transaction is mined)\n  * From MonolithDAO Token.sol\n  * @param spender The address which will spend the funds.\n  * @param addedValue The amount of tokens to increase the allowance by.\n  */\n  function increaseAllowance(\n    address spender,\n    uint256 addedValue\n  )\n  public\n  returns (bool)\n  {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = (\n    _allowed[msg.sender][spender].add(addedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n  * @dev Decrease the amount of tokens that an owner allowed to a spender.\n  * approve should be called when allowed_[_spender] == 0. To decrement\n  * allowed value is better to use this function to avoid 2 calls (and wait until\n  * the first transaction is mined)\n  * From MonolithDAO Token.sol\n  * @param spender The address which will spend the funds.\n  * @param subtractedValue The amount of tokens to decrease the allowance by.\n  */\n  function decreaseAllowance(\n    address spender,\n    uint256 subtractedValue\n  )\n  public\n  returns (bool)\n  {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = (\n    _allowed[msg.sender][spender].sub(subtractedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n  * @dev Adds a user to whitelist\n  * @param _member address to add to whitelist\n  */\n  function addToWhiteList(address _member) public onlyOperator returns (bool) {\n    whiteListed[_member] = true;\n    emit WhiteListed(_member);\n    return true;\n  }\n\n  /**\n  * @dev removes a user from whitelist\n  * @param _member address to remove from whitelist\n  */\n  function removeFromWhiteList(address _member) public onlyOperator returns (bool) {\n    whiteListed[_member] = false;\n    emit BlackListed(_member);\n    return true;\n  }\n\n  /**\n  * @dev change operator address\n  * @param _newOperator address of new operator\n  */\n  function changeOperator(address _newOperator) public onlyOperator returns (bool) {\n    operator = _newOperator;\n    return true;\n  }\n\n  /**\n  * @dev burns an amount of the tokens of the message sender\n  * account.\n  * @param amount The amount that will be burnt.\n  */\n  function burn(uint256 amount) public returns (bool) {\n    _burn(msg.sender, amount);\n    return true;\n  }\n\n  /**\n  * @dev Burns a specific amount of tokens from the target address and decrements allowance\n  * @param from address The address which you want to send tokens from\n  * @param value uint256 The amount of token to be burned\n  */\n  function burnFrom(address from, uint256 value) public returns (bool) {\n    _burnFrom(from, value);\n    return true;\n  }\n\n  /**\n  * @dev function that mints an amount of the token and assigns it to\n  * an account.\n  * @param account The account that will receive the created tokens.\n  * @param amount The amount that will be created.\n  */\n  function mint(address account, uint256 amount) public onlyOperator {\n    _mint(account, amount);\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function transfer(address to, uint256 value) public canTransfer(to) returns (bool) {\n\n    require(isLockedForMV[msg.sender] < now); // if not voted under governance\n    require(value <= _balances[msg.sender]);\n    _transfer(to, value);\n    return true;\n  }\n\n  /**\n  * @dev Transfer tokens to the operator from the specified address\n  * @param from The address to transfer from.\n  * @param value The amount to be transferred.\n  */\n  function operatorTransfer(address from, uint256 value) public onlyOperator returns (bool) {\n    require(value <= _balances[from]);\n    _transferFrom(from, operator, value);\n    return true;\n  }\n\n  /**\n  * @dev Transfer tokens from one address to another\n  * @param from address The address which you want to send tokens from\n  * @param to address The address which you want to transfer to\n  * @param value uint256 the amount of tokens to be transferred\n  */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n  public\n  canTransfer(to)\n  returns (bool)\n  {\n    require(isLockedForMV[from] < now); // if not voted under governance\n    require(value <= _balances[from]);\n    require(value <= _allowed[from][msg.sender]);\n    _transferFrom(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Lock the user's tokens\n   * @param _of user's address.\n   */\n  function lockForMemberVote(address _of, uint _days) public onlyOperator {\n    if (_days.add(now) > isLockedForMV[_of])\n      isLockedForMV[_of] = _days.add(now);\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function _transfer(address to, uint256 value) internal {\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\n    _balances[to] = _balances[to].add(value);\n    emit Transfer(msg.sender, to, value);\n  }\n\n  /**\n  * @dev Transfer tokens from one address to another\n  * @param from address The address which you want to send tokens from\n  * @param to address The address which you want to transfer to\n  * @param value uint256 the amount of tokens to be transferred\n  */\n  function _transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n  internal\n  {\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    emit Transfer(from, to, value);\n  }\n\n  /**\n  * @dev Internal function that mints an amount of the token and assigns it to\n  * an account. This encapsulates the modification of balances such that the\n  * proper events are emitted.\n  * @param account The account that will receive the created tokens.\n  * @param amount The amount that will be created.\n  */\n  function _mint(address account, uint256 amount) internal {\n    require(account != address(0));\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n  * @dev Internal function that burns an amount of the token of a given\n  * account.\n  * @param account The account whose tokens will be burnt.\n  * @param amount The amount that will be burnt.\n  */\n  function _burn(address account, uint256 amount) internal {\n    require(amount <= _balances[account]);\n\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[account] = _balances[account].sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n  * @dev Internal function that burns an amount of the token of a given\n  * account, deducting from the sender's allowance for said account. Uses the\n  * internal burn function.\n  * @param account The account whose tokens will be burnt.\n  * @param value The amount that will be burnt.\n  */\n  function _burnFrom(address account, uint256 value) internal {\n    require(value <= _allowed[account][msg.sender]);\n\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\n    // this function needs to emit an event with the updated approval.\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n      value);\n    _burn(account, value);\n  }\n}\n"
36     },
37     "contracts/modules/token/TokenController.sol": {
38       "content": "/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../abstract/Iupgradable.sol\";\nimport \"../../interfaces/IPooledStaking.sol\";\nimport \"./NXMToken.sol\";\nimport \"./external/IERC1132.sol\";\n\ncontract TokenController is IERC1132, Iupgradable {\n  using SafeMath for uint256;\n\n  event Burned(address indexed member, bytes32 lockedUnder, uint256 amount);\n\n  NXMToken public token;\n  IPooledStaking public pooledStaking;\n  uint public minCALockTime = uint(30).mul(1 days);\n  bytes32 private constant CLA = bytes32(\"CLA\");\n\n  /**\n  * @dev Just for interface\n  */\n  function changeDependentContractAddress() public {\n    token = NXMToken(ms.tokenAddress());\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\"PS\"));\n  }\n\n  /**\n   * @dev to change the operator address\n   * @param _newOperator is the new address of operator\n   */\n  function changeOperator(address _newOperator) public onlyInternal {\n    token.changeOperator(_newOperator);\n  }\n\n  /**\n   * @dev Proxies token transfer through this contract to allow staking when members are locked for voting\n   * @param _from   Source address\n   * @param _to     Destination address\n   * @param _value  Amount to transfer\n   */\n  function operatorTransfer(address _from, address _to, uint _value) onlyInternal external returns (bool) {\n    require(msg.sender == address(pooledStaking), \"Call is only allowed from PooledStaking address\");\n    require(token.operatorTransfer(_from, _value), \"Operator transfer failed\");\n    require(token.transfer(_to, _value), \"Internal transfer failed\");\n    return true;\n  }\n\n  /**\n  * @dev Locks a specified amount of tokens,\n  *    for CLA reason and for a specified time\n  * @param _reason The reason to lock tokens, currently restricted to CLA\n  * @param _amount Number of tokens to be locked\n  * @param _time Lock time in seconds\n  */\n  function lock(bytes32 _reason, uint256 _amount, uint256 _time) public checkPause returns (bool)\n  {\n    require(_reason == CLA, \"Restricted to reason CLA\");\n    require(minCALockTime <= _time, \"Should lock for minimum time\");\n    // If tokens are already locked, then functions extendLock or\n    // increaseLockAmount should be used to make any changes\n    _lock(msg.sender, _reason, _amount, _time);\n    return true;\n  }\n\n  /**\n  * @dev Locks a specified amount of tokens against an address,\n  *    for a specified reason and time\n  * @param _reason The reason to lock tokens\n  * @param _amount Number of tokens to be locked\n  * @param _time Lock time in seconds\n  * @param _of address whose tokens are to be locked\n  */\n  function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time)\n  public\n  onlyInternal\n  returns (bool)\n  {\n    // If tokens are already locked, then functions extendLock or\n    // increaseLockAmount should be used to make any changes\n    _lock(_of, _reason, _amount, _time);\n    return true;\n  }\n\n  /**\n  * @dev Extends lock for reason CLA for a specified time\n  * @param _reason The reason to lock tokens, currently restricted to CLA\n  * @param _time Lock extension time in seconds\n  */\n  function extendLock(bytes32 _reason, uint256 _time)\n  public\n  checkPause\n  returns (bool)\n  {\n    require(_reason == CLA, \"Restricted to reason CLA\");\n    _extendLock(msg.sender, _reason, _time);\n    return true;\n  }\n\n  /**\n  * @dev Extends lock for a specified reason and time\n  * @param _reason The reason to lock tokens\n  * @param _time Lock extension time in seconds\n  */\n  function extendLockOf(address _of, bytes32 _reason, uint256 _time)\n  public\n  onlyInternal\n  returns (bool)\n  {\n    _extendLock(_of, _reason, _time);\n    return true;\n  }\n\n  /**\n  * @dev Increase number of tokens locked for a CLA reason\n  * @param _reason The reason to lock tokens, currently restricted to CLA\n  * @param _amount Number of tokens to be increased\n  */\n  function increaseLockAmount(bytes32 _reason, uint256 _amount)\n  public\n  checkPause\n  returns (bool)\n  {\n    require(_reason == CLA, \"Restricted to reason CLA\");\n    require(_tokensLocked(msg.sender, _reason) > 0);\n    token.operatorTransfer(msg.sender, _amount);\n\n    locked[msg.sender][_reason].amount = locked[msg.sender][_reason].amount.add(_amount);\n    emit Locked(msg.sender, _reason, _amount, locked[msg.sender][_reason].validity);\n    return true;\n  }\n\n  /**\n   * @dev burns tokens of an address\n   * @param _of is the address to burn tokens of\n   * @param amount is the amount to burn\n   * @return the boolean status of the burning process\n   */\n  function burnFrom(address _of, uint amount) public onlyInternal returns (bool) {\n    return token.burnFrom(_of, amount);\n  }\n\n  /**\n  * @dev Burns locked tokens of a user\n  * @param _of address whose tokens are to be burned\n  * @param _reason lock reason for which tokens are to be burned\n  * @param _amount amount of tokens to burn\n  */\n  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) public onlyInternal {\n    _burnLockedTokens(_of, _reason, _amount);\n  }\n\n  /**\n  * @dev reduce lock duration for a specified reason and time\n  * @param _of The address whose tokens are locked\n  * @param _reason The reason to lock tokens\n  * @param _time Lock reduction time in seconds\n  */\n  function reduceLock(address _of, bytes32 _reason, uint256 _time) public onlyInternal {\n    _reduceLock(_of, _reason, _time);\n  }\n\n  /**\n  * @dev Released locked tokens of an address locked for a specific reason\n  * @param _of address whose tokens are to be released from lock\n  * @param _reason reason of the lock\n  * @param _amount amount of tokens to release\n  */\n  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount)\n  public\n  onlyInternal\n  {\n    _releaseLockedTokens(_of, _reason, _amount);\n  }\n\n  /**\n  * @dev Adds an address to whitelist maintained in the contract\n  * @param _member address to add to whitelist\n  */\n  function addToWhitelist(address _member) public onlyInternal {\n    token.addToWhiteList(_member);\n  }\n\n  /**\n  * @dev Removes an address from the whitelist in the token\n  * @param _member address to remove\n  */\n  function removeFromWhitelist(address _member) public onlyInternal {\n    token.removeFromWhiteList(_member);\n  }\n\n  /**\n  * @dev Mints new token for an address\n  * @param _member address to reward the minted tokens\n  * @param _amount number of tokens to mint\n  */\n  function mint(address _member, uint _amount) public onlyInternal {\n    token.mint(_member, _amount);\n  }\n\n  /**\n   * @dev Lock the user's tokens\n   * @param _of user's address.\n   */\n  function lockForMemberVote(address _of, uint _days) public onlyInternal {\n    token.lockForMemberVote(_of, _days);\n  }\n\n  /**\n  * @dev Unlocks the unlockable tokens against CLA of a specified address\n  * @param _of Address of user, claiming back unlockable tokens against CLA\n  */\n  function unlock(address _of)\n  public\n  checkPause\n  returns (uint256 unlockableTokens)\n  {\n    unlockableTokens = _tokensUnlockable(_of, CLA);\n    if (unlockableTokens > 0) {\n      locked[_of][CLA].claimed = true;\n      emit Unlocked(_of, CLA, unlockableTokens);\n      require(token.transfer(_of, unlockableTokens));\n    }\n  }\n\n  /**\n   * @dev Updates Uint Parameters of a code\n   * @param code whose details we want to update\n   * @param val value to set\n   */\n  function updateUintParameters(bytes8 code, uint val) public {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    if (code == \"MNCLT\") {\n      minCALockTime = val.mul(1 days);\n    } else {\n      revert(\"Invalid param code\");\n    }\n  }\n\n  /**\n  * @dev Gets the validity of locked tokens of a specified address\n  * @param _of The address to query the validity\n  * @param reason reason for which tokens were locked\n  */\n  function getLockedTokensValidity(address _of, bytes32 reason)\n  public\n  view\n  returns (uint256 validity)\n  {\n    validity = locked[_of][reason].validity;\n  }\n\n  /**\n  * @dev Gets the unlockable tokens of a specified address\n  * @param _of The address to query the the unlockable token count of\n  */\n  function getUnlockableTokens(address _of)\n  public\n  view\n  returns (uint256 unlockableTokens)\n  {\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\n      unlockableTokens = unlockableTokens.add(_tokensUnlockable(_of, lockReason[_of][i]));\n    }\n  }\n\n  /**\n  * @dev Returns tokens locked for a specified address for a\n  *    specified reason\n  *\n  * @param _of The address whose tokens are locked\n  * @param _reason The reason to query the lock tokens for\n  */\n  function tokensLocked(address _of, bytes32 _reason)\n  public\n  view\n  returns (uint256 amount)\n  {\n    return _tokensLocked(_of, _reason);\n  }\n\n  /**\n  * @dev Returns unlockable tokens for a specified address for a specified reason\n  * @param _of The address to query the the unlockable token count of\n  * @param _reason The reason to query the unlockable tokens for\n  */\n  function tokensUnlockable(address _of, bytes32 _reason)\n  public\n  view\n  returns (uint256 amount)\n  {\n    return _tokensUnlockable(_of, _reason);\n  }\n\n  function totalSupply() public view returns (uint256)\n  {\n    return token.totalSupply();\n  }\n\n  /**\n  * @dev Returns tokens locked for a specified address for a\n  *    specified reason at a specific time\n  *\n  * @param _of The address whose tokens are locked\n  * @param _reason The reason to query the lock tokens for\n  * @param _time The timestamp to query the lock tokens for\n  */\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\n  public\n  view\n  returns (uint256 amount)\n  {\n    return _tokensLockedAtTime(_of, _reason, _time);\n  }\n\n  /**\n  * @dev Returns the total amount of tokens held by an address:\n  *   transferable + locked + staked for pooled staking - pending burns.\n  *   Used by Claims and Governance in member voting to calculate the user's vote weight.\n  *\n  * @param _of The address to query the total balance of\n  * @param _of The address to query the total balance of\n  */\n  function totalBalanceOf(address _of) public view returns (uint256 amount) {\n\n    amount = token.balanceOf(_of);\n\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\n      amount = amount.add(_tokensLocked(_of, lockReason[_of][i]));\n    }\n\n    uint stakerReward = pooledStaking.stakerReward(_of);\n    uint stakerDeposit = pooledStaking.stakerDeposit(_of);\n\n    amount = amount.add(stakerDeposit).add(stakerReward);\n  }\n\n  /**\n  * @dev Returns the total locked tokens at time\n  *   Returns the total amount of locked and staked tokens at a given time. Used by MemberRoles to check eligibility\n  *   for withdraw / switch membership. Includes tokens locked for Claim Assessment and staked for Risk Assessment.\n  *   Does not take into account pending burns.\n  *\n  * @param _of member whose locked tokens are to be calculate\n  * @param _time timestamp when the tokens should be locked\n  */\n  function totalLockedBalance(address _of, uint256 _time) public view returns (uint256 amount) {\n\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\n      amount = amount.add(_tokensLockedAtTime(_of, lockReason[_of][i], _time));\n    }\n\n    amount = amount.add(pooledStaking.stakerDeposit(_of));\n  }\n\n  /**\n  * @dev Locks a specified amount of tokens against an address,\n  *    for a specified reason and time\n  * @param _of address whose tokens are to be locked\n  * @param _reason The reason to lock tokens\n  * @param _amount Number of tokens to be locked\n  * @param _time Lock time in seconds\n  */\n  function _lock(address _of, bytes32 _reason, uint256 _amount, uint256 _time) internal {\n    require(_tokensLocked(_of, _reason) == 0);\n    require(_amount != 0);\n\n    if (locked[_of][_reason].amount == 0) {\n      lockReason[_of].push(_reason);\n    }\n\n    require(token.operatorTransfer(_of, _amount));\n\n    uint256 validUntil = now.add(_time); // solhint-disable-line\n    locked[_of][_reason] = LockToken(_amount, validUntil, false);\n    emit Locked(_of, _reason, _amount, validUntil);\n  }\n\n  /**\n  * @dev Returns tokens locked for a specified address for a\n  *    specified reason\n  *\n  * @param _of The address whose tokens are locked\n  * @param _reason The reason to query the lock tokens for\n  */\n  function _tokensLocked(address _of, bytes32 _reason)\n  internal\n  view\n  returns (uint256 amount)\n  {\n    if (!locked[_of][_reason].claimed) {\n      amount = locked[_of][_reason].amount;\n    }\n  }\n\n  /**\n  * @dev Returns tokens locked for a specified address for a\n  *    specified reason at a specific time\n  *\n  * @param _of The address whose tokens are locked\n  * @param _reason The reason to query the lock tokens for\n  * @param _time The timestamp to query the lock tokens for\n  */\n  function _tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\n  internal\n  view\n  returns (uint256 amount)\n  {\n    if (locked[_of][_reason].validity > _time) {\n      amount = locked[_of][_reason].amount;\n    }\n  }\n\n  /**\n  * @dev Extends lock for a specified reason and time\n  * @param _of The address whose tokens are locked\n  * @param _reason The reason to lock tokens\n  * @param _time Lock extension time in seconds\n  */\n  function _extendLock(address _of, bytes32 _reason, uint256 _time) internal {\n    require(_tokensLocked(_of, _reason) > 0);\n    emit Unlocked(_of, _reason, locked[_of][_reason].amount);\n    locked[_of][_reason].validity = locked[_of][_reason].validity.add(_time);\n    emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\n  }\n\n  /**\n  * @dev reduce lock duration for a specified reason and time\n  * @param _of The address whose tokens are locked\n  * @param _reason The reason to lock tokens\n  * @param _time Lock reduction time in seconds\n  */\n  function _reduceLock(address _of, bytes32 _reason, uint256 _time) internal {\n    require(_tokensLocked(_of, _reason) > 0);\n    emit Unlocked(_of, _reason, locked[_of][_reason].amount);\n    locked[_of][_reason].validity = locked[_of][_reason].validity.sub(_time);\n    emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\n  }\n\n  /**\n  * @dev Returns unlockable tokens for a specified address for a specified reason\n  * @param _of The address to query the the unlockable token count of\n  * @param _reason The reason to query the unlockable tokens for\n  */\n  function _tokensUnlockable(address _of, bytes32 _reason) internal view returns (uint256 amount)\n  {\n    if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed) {\n      amount = locked[_of][_reason].amount;\n    }\n  }\n\n  /**\n  * @dev Burns locked tokens of a user\n  * @param _of address whose tokens are to be burned\n  * @param _reason lock reason for which tokens are to be burned\n  * @param _amount amount of tokens to burn\n  */\n  function _burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal {\n    uint256 amount = _tokensLocked(_of, _reason);\n    require(amount >= _amount);\n\n    if (amount == _amount) {\n      locked[_of][_reason].claimed = true;\n    }\n\n    locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\n    if (locked[_of][_reason].amount == 0) {\n      _removeReason(_of, _reason);\n    }\n    token.burn(_amount);\n    emit Burned(_of, _reason, _amount);\n  }\n\n  /**\n  * @dev Released locked tokens of an address locked for a specific reason\n  * @param _of address whose tokens are to be released from lock\n  * @param _reason reason of the lock\n  * @param _amount amount of tokens to release\n  */\n  function _releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal\n  {\n    uint256 amount = _tokensLocked(_of, _reason);\n    require(amount >= _amount);\n\n    if (amount == _amount) {\n      locked[_of][_reason].claimed = true;\n    }\n\n    locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\n    if (locked[_of][_reason].amount == 0) {\n      _removeReason(_of, _reason);\n    }\n    require(token.transfer(_of, _amount));\n    emit Unlocked(_of, _reason, _amount);\n  }\n\n  function _removeReason(address _of, bytes32 _reason) internal {\n    uint len = lockReason[_of].length;\n    for (uint i = 0; i < len; i++) {\n      if (lockReason[_of][i] == _reason) {\n        lockReason[_of][i] = lockReason[_of][len.sub(1)];\n        lockReason[_of].pop();\n        break;\n      }\n    }\n  }\n}\n"
39     },
40     "contracts/modules/capital/MCR.sol": {
41       "content": "/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../capital/Pool.sol\";\nimport \"../cover/QuotationData.sol\";\nimport \"../governance/MemberRoles.sol\";\nimport \"../governance/ProposalCategory.sol\";\nimport \"../oracles/PriceFeedOracle.sol\";\nimport \"../token/NXMToken.sol\";\nimport \"../token/TokenData.sol\";\nimport \"./PoolData.sol\";\n\ncontract MCR is Iupgradable {\n  using SafeMath for uint;\n\n  Pool public pool;\n  PoolData public pd;\n  NXMToken public tk;\n  QuotationData public qd;\n  MemberRoles public mr;\n  TokenData public td;\n  ProposalCategory public proposalCategory;\n\n  uint private constant minCapFactor = uint(10) ** 21;\n\n  uint public variableMincap;\n  uint public dynamicMincapThresholdx100 = 13000;\n  uint public dynamicMincapIncrementx100 = 100;\n\n  event MCREvent(\n    uint indexed date,\n    uint blockNumber,\n    bytes4[] allCurr,\n    uint[] allCurrRates,\n    uint mcrEtherx100,\n    uint mcrPercx100,\n    uint vFull\n  );\n\n  constructor (address masterAddress) public {\n\n    changeMasterAddress(masterAddress);\n\n    // we'll pass the zero address on the first deploy\n    // due to missing previous MCR contract\n    if (masterAddress == address(0)) {\n      return;\n    }\n\n    address mcrAddress = ms.getLatestAddress(\"MC\");\n    MCR previousMCR = MCR(mcrAddress);\n\n    // fetch MCR parameters from previous contract\n    variableMincap = previousMCR.variableMincap();\n    dynamicMincapThresholdx100 = previousMCR.dynamicMincapThresholdx100();\n    dynamicMincapIncrementx100 = previousMCR.dynamicMincapIncrementx100();\n  }\n\n  /**\n   * @dev Adds new MCR data.\n   * @param mcrP  Minimum Capital Requirement in percentage.\n   * @param vF Pool fund value in Ether used in the last full daily calculation of the Capital model.\n   * @param onlyDate  Date(yyyymmdd) at which MCR details are getting added.\n   */\n  function addMCRData(\n    uint mcrP,\n    uint mcrE,\n    uint vF,\n    bytes4[] calldata curr,\n    uint[] calldata _threeDayAvg,\n    uint64 onlyDate\n  )\n  external\n  checkPause\n  {\n    require(proposalCategory.constructorCheck());\n    require(pd.isnotarise(msg.sender));\n    if (mr.launched() && pd.capReached() != 1) {\n\n      if (mcrP >= 10000)\n        pd.setCapReached(1);\n\n    }\n    uint len = pd.getMCRDataLength();\n    _addMCRData(len, onlyDate, curr, mcrE, mcrP, vF, _threeDayAvg);\n  }\n\n  // proxying this call through mcr contract to get rid of pd from pool\n  function getLastMCREther() external view returns (uint) {\n    return pd.getLastMCREther();\n  }\n\n  /**\n   * @dev Iupgradable Interface to update dependent contract address\n   */\n  function changeDependentContractAddress() public {\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\n    pool = Pool(ms.getLatestAddress(\"P1\"));\n    pd = PoolData(ms.getLatestAddress(\"PD\"));\n    tk = NXMToken(ms.tokenAddress());\n    mr = MemberRoles(ms.getLatestAddress(\"MR\"));\n    td = TokenData(ms.getLatestAddress(\"TD\"));\n    proposalCategory = ProposalCategory(ms.getLatestAddress(\"PC\"));\n  }\n\n  /**\n   * @dev Gets total sum assured (in ETH).\n   * @return amount of sum assured\n   */\n  function getAllSumAssurance() public view returns (uint) {\n\n    PriceFeedOracle priceFeed = pool.priceFeedOracle();\n    address daiAddress = priceFeed.daiAddress();\n\n    uint ethAmount = qd.getTotalSumAssured(\"ETH\").mul(1e18);\n    uint daiAmount = qd.getTotalSumAssured(\"DAI\").mul(1e18);\n\n    uint daiRate = priceFeed.getAssetToEthRate(daiAddress);\n    uint daiAmountInEth = daiAmount.mul(daiRate).div(1e18);\n\n    return ethAmount.add(daiAmountInEth);\n  }\n\n  function getThresholdValues(uint vtp, uint vF, uint totalSA, uint minCap) public view returns (uint lowerThreshold, uint upperThreshold)\n  {\n    minCap = (minCap.mul(minCapFactor)).add(variableMincap);\n    uint lower = 0;\n    if (vtp >= vF) {\n      // Max Threshold = [MAX(Vtp, Vfull) x 120] / mcrMinCap\n      upperThreshold = vtp.mul(120).mul(100).div((minCap));\n    } else {\n      upperThreshold = vF.mul(120).mul(100).div((minCap));\n    }\n\n    if (vtp > 0) {\n      lower = totalSA.mul(pd.shockParameter()).div(100);\n      if (lower < minCap.mul(11).div(10))\n        lower = minCap.mul(11).div(10);\n    }\n    if (lower > 0) {\n      // Min Threshold = [Vtp / MAX(TotalActiveSA x ShockParameter, mcrMinCap x 1.1)] x 100\n      lowerThreshold = vtp.mul(100).mul(100).div(lower);\n    }\n  }\n\n  /**\n   * @dev Gets Uint Parameters of a code\n   * @param code whose details we want\n   * @return string value of the code\n   * @return associated amount (time or perc or value) to the code\n   */\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\n    codeVal = code;\n    if (code == \"DMCT\") {\n      val = dynamicMincapThresholdx100;\n\n    } else if (code == \"DMCI\") {\n\n      val = dynamicMincapIncrementx100;\n\n    }\n\n  }\n\n  /**\n   * @dev Updates Uint Parameters of a code\n   * @param code whose details we want to update\n   * @param val value to set\n   */\n  function updateUintParameters(bytes8 code, uint val) public {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    if (code == \"DMCT\") {\n      dynamicMincapThresholdx100 = val;\n\n    } else if (code == \"DMCI\") {\n\n      dynamicMincapIncrementx100 = val;\n\n    }\n    else {\n      revert(\"Invalid param code\");\n    }\n\n  }\n\n  /**\n   * @dev Adds MCR Data. Checks if MCR is within valid\n   * thresholds in order to rule out any incorrect calculations\n   */\n  function _addMCRData(\n    uint len,\n    uint64 newMCRDate,\n    bytes4[] memory curr,\n    uint mcrE,\n    uint mcrP,\n    uint vF,\n    uint[] memory _threeDayAvg\n  )\n  internal\n  {\n    uint lowerThreshold = 0;\n    uint upperThreshold = 0;\n\n    if (len > 1) {\n      uint vtp = pool.getPoolValueInEth();\n      (lowerThreshold, upperThreshold) = getThresholdValues(vtp, vF, getAllSumAssurance(), pd.minCap());\n    }\n\n    if (mcrP > dynamicMincapThresholdx100) {\n      variableMincap = (variableMincap.mul(dynamicMincapIncrementx100.add(10000)).add(minCapFactor.mul(pd.minCap().mul(dynamicMincapIncrementx100)))).div(10000);\n    }\n\n    // Explanation for above formula :-\n    // actual formula -> variableMinCap =  variableMinCap + (variableMinCap+minCap)*dynamicMincapIncrement/100\n    // Implemented formula is simplified form of actual formula.\n    // Let consider above formula as b = b + (a+b)*c/100\n    // here, dynamicMincapIncrement is in x100 format.\n    // so b+(a+b)*cx100/10000 can be written as => (10000.b + b.cx100 + a.cx100)/10000.\n    // It can further simplify to (b.(10000+cx100) + a.cx100)/10000.\n    if (len == 1 || (mcrP) >= lowerThreshold && (mcrP) <= upperThreshold) {\n\n      pd.pushMCRData(mcrP, mcrE, vF, newMCRDate);\n\n      for (uint i = 0; i < curr.length; i++) {\n        pd.updateCAAvgRate(curr[i], _threeDayAvg[i]);\n      }\n\n      emit MCREvent(newMCRDate, block.number, curr, _threeDayAvg, mcrE, mcrP, vF);\n      return;\n    }\n\n    revert(\"MCR: Failed\");\n  }\n\n}\n"
42     },
43     "contracts/modules/capital/SwapAgent.sol": {
44       "content": "/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../external/uniswap/IUniswapV2Router02.sol\";\nimport \"../oracles/TwapOracle.sol\";\n\nlibrary SwapAgent {\n  using SafeMath for uint;\n\n  struct AssetData {\n    uint112 minAmount;\n    uint112 maxAmount;\n    uint32 lastSwapTime;\n    // 18 decimals of precision. 0.01% -> 0.0001 -> 1e14\n    uint maxSlippageRatio;\n  }\n\n  IUniswapV2Router02 constant public router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n  uint constant public MAX_LIQUIDITY_RATIO = 3 * 1e15;\n\n  function getSwapQuote(\n    uint tokenAmountIn,\n    IERC20 fromToken,\n    IERC20 toToken\n  ) public view returns (uint tokenAmountOut) {\n\n    address[] memory path = new address[](2);\n    path[0] = address(fromToken);\n    path[1] = address(toToken);\n    uint[] memory amountsOut = router.getAmountsOut(tokenAmountIn, path);\n\n    return amountsOut[1];\n  }\n\n  function swapETHForAsset(\n    address _oracle,\n    AssetData storage assetData,\n    address toTokenAddress,\n    uint amountIn,\n    uint amountOutMin,\n    uint minLeftETH\n  ) external returns (uint) {\n\n    uint balanceBefore = IERC20(toTokenAddress).balanceOf(address(this));\n    address WETH = router.WETH();\n\n    {\n      // scope for swap frequency check\n      uint timeSinceLastTrade = block.timestamp.sub(uint(assetData.lastSwapTime));\n      require(timeSinceLastTrade > TwapOracle(_oracle).periodSize(), \"SwapAgent: too fast\");\n    }\n\n    {\n      // scope for liquidity check\n      address pairAddress = TwapOracle(_oracle).pairFor(WETH, toTokenAddress);\n      IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n      (uint112 reserve0, uint112 reserve1, /* time */) = pair.getReserves();\n\n      uint ethReserve = WETH < toTokenAddress ? reserve0 : reserve1;\n      uint maxTradable = ethReserve.mul(MAX_LIQUIDITY_RATIO).div(1e18);\n\n      require(amountIn <= maxTradable, \"SwapAgent: exceeds max tradable amount\");\n    }\n\n    {\n      // scope for ether checks\n      uint ethBalanceBefore = address(this).balance;\n      uint ethBalanceAfter = ethBalanceBefore.sub(amountIn);\n      require(ethBalanceAfter >= minLeftETH, \"SwapAgent: insufficient ether left\");\n    }\n\n    {\n      // scope for token checks\n      uint avgAmountOut = TwapOracle(_oracle).consult(WETH, amountIn, toTokenAddress);\n      uint maxSlippageAmount = avgAmountOut.mul(assetData.maxSlippageRatio).div(1e18);\n      uint minOutOnMaxSlippage = avgAmountOut.sub(maxSlippageAmount);\n\n      // gas optimisation: reads both values using a single SLOAD\n      (uint minAssetAmount, uint maxAssetAmount) = (assetData.minAmount, assetData.maxAmount);\n\n      require(amountOutMin >= minOutOnMaxSlippage, \"SwapAgent: amountOutMin < minOutOnMaxSlippage\");\n      require(balanceBefore < minAssetAmount, \"SwapAgent: balanceBefore >= min\");\n      require(balanceBefore.add(amountOutMin) <= maxAssetAmount, \"SwapAgent: balanceAfter > max\");\n    }\n\n    address[] memory path = new address[](2);\n    path[0] = WETH;\n    path[1] = toTokenAddress;\n    router.swapExactETHForTokens.value(amountIn)(amountOutMin, path, address(this), block.timestamp);\n\n    assetData.lastSwapTime = uint32(block.timestamp);\n\n    uint balanceAfter = IERC20(toTokenAddress).balanceOf(address(this));\n    uint amountOut = balanceAfter.sub(balanceBefore);\n\n    return amountOut;\n  }\n\n  function swapAssetForETH(\n    address _oracle,\n    AssetData storage assetData,\n    address fromTokenAddress,\n    uint amountIn,\n    uint amountOutMin\n  ) external returns (uint) {\n\n    uint tokenBalanceBefore = IERC20(fromTokenAddress).balanceOf(address(this));\n    uint balanceBefore = address(this).balance;\n    address WETH = router.WETH();\n\n    {\n      // scope for swap frequency check\n      uint timeSinceLastTrade = block.timestamp.sub(uint(assetData.lastSwapTime));\n      require(timeSinceLastTrade > TwapOracle(_oracle).periodSize(), \"SwapAgent: too fast\");\n    }\n\n    {\n      // scope for liquidity check\n      address pairAddress = TwapOracle(_oracle).pairFor(fromTokenAddress, WETH);\n      IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n      (uint112 reserve0, uint112 reserve1, /* time */) = pair.getReserves();\n\n      uint tokenReserve = fromTokenAddress < WETH ? reserve0 : reserve1;\n      uint maxTradable = tokenReserve.mul(MAX_LIQUIDITY_RATIO).div(1e18);\n\n      require(amountIn <= maxTradable, \"SwapAgent: exceeds max tradable amount\");\n    }\n\n    {\n      // scope for token checks\n      uint avgAmountOut = TwapOracle(_oracle).consult(fromTokenAddress, amountIn, WETH);\n      uint maxSlippageAmount = avgAmountOut.mul(assetData.maxSlippageRatio).div(1e18);\n      uint minOutOnMaxSlippage = avgAmountOut.sub(maxSlippageAmount);\n\n      // gas optimisation: reads both values using a single SLOAD\n      (uint minAssetAmount, uint maxAssetAmount) = (assetData.minAmount, assetData.maxAmount);\n\n      require(amountOutMin >= minOutOnMaxSlippage, \"SwapAgent: amountOutMin < minOutOnMaxSlippage\");\n      require(tokenBalanceBefore > maxAssetAmount, \"SwapAgent: tokenBalanceBefore <= max\");\n      require(tokenBalanceBefore.sub(amountIn) >= minAssetAmount, \"SwapAgent: tokenBalanceAfter < min\");\n    }\n\n    address[] memory path = new address[](2);\n    path[0] = fromTokenAddress;\n    path[1] = router.WETH();\n    IERC20(fromTokenAddress).approve(address(router), amountIn);\n    router.swapExactTokensForETH(amountIn, amountOutMin, path, address(this), block.timestamp);\n\n    assetData.lastSwapTime = uint32(block.timestamp);\n\n    uint balanceAfter = address(this).balance;\n    uint amountOut = balanceAfter.sub(balanceBefore);\n\n    return amountOut;\n  }\n\n}\n"
45     },
46     "contracts/abstract/INXMMaster.sol": {
47       "content": "/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\ncontract INXMMaster {\n\n  address public tokenAddress;\n\n  address public owner;\n\n  uint public pauseTime;\n\n  function delegateCallBack(bytes32 myid) external;\n\n  function masterInitialized() public view returns (bool);\n\n  function isInternal(address _add) public view returns (bool);\n\n  function isPause() public view returns (bool check);\n\n  function isOwner(address _add) public view returns (bool);\n\n  function isMember(address _add) public view returns (bool);\n\n  function checkIsAuthToGoverned(address _add) public view returns (bool);\n\n  function updatePauseTime(uint _time) public;\n\n  function dAppLocker() public view returns (address _add);\n\n  function dAppToken() public view returns (address _add);\n\n  function getLatestAddress(bytes2 _contractName) public view returns (address payable contractAddress);\n}\n"
48     },
49     "contracts/modules/capital/PoolData.sol": {
50       "content": "/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../abstract/Iupgradable.sol\";\n\ncontract DSValue {\n  function peek() public view returns (bytes32, bool);\n\n  function read() public view returns (bytes32);\n}\n\ncontract PoolData is Iupgradable {\n  using SafeMath for uint;\n\n  struct ApiId {\n    bytes4 typeOf;\n    bytes4 currency;\n    uint id;\n    uint64 dateAdd;\n    uint64 dateUpd;\n  }\n\n  struct CurrencyAssets {\n    address currAddress;\n    uint baseMin;\n    uint varMin;\n  }\n\n  struct InvestmentAssets {\n    address currAddress;\n    bool status;\n    uint64 minHoldingPercX100;\n    uint64 maxHoldingPercX100;\n    uint8 decimals;\n  }\n\n  struct IARankDetails {\n    bytes4 maxIACurr;\n    uint64 maxRate;\n    bytes4 minIACurr;\n    uint64 minRate;\n  }\n\n  struct McrData {\n    uint mcrPercx100;\n    uint mcrEther;\n    uint vFull; //Pool funds\n    uint64 date;\n  }\n\n  IARankDetails[] internal allIARankDetails;\n  McrData[] public allMCRData;\n\n  bytes4[] internal allInvestmentCurrencies;\n  bytes4[] internal allCurrencies;\n  bytes32[] public allAPIcall;\n  mapping(bytes32 => ApiId) public allAPIid;\n  mapping(uint64 => uint) internal datewiseId;\n  mapping(bytes16 => uint) internal currencyLastIndex;\n  mapping(bytes4 => CurrencyAssets) internal allCurrencyAssets;\n  mapping(bytes4 => InvestmentAssets) internal allInvestmentAssets;\n  mapping(bytes4 => uint) internal caAvgRate;\n  mapping(bytes4 => uint) internal iaAvgRate;\n\n  address public notariseMCR;\n  address public daiFeedAddress;\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\n  uint public uniswapDeadline;\n  uint public liquidityTradeCallbackTime;\n  uint public lastLiquidityTradeTrigger;\n  uint64 internal lastDate;\n  uint public variationPercX100;\n  uint public iaRatesTime;\n  uint public minCap;\n  uint public mcrTime;\n  uint public a;\n  uint public shockParameter;\n  uint public c;\n  uint public mcrFailTime;\n  uint public ethVolumeLimit;\n  uint public capReached;\n  uint public capacityLimit;\n\n  constructor(address _notariseAdd, address _daiFeedAdd, address _daiAdd) public {\n    notariseMCR = _notariseAdd;\n    daiFeedAddress = _daiFeedAdd;\n    c = 5800000;\n    a = 1028;\n    mcrTime = 24 hours;\n    mcrFailTime = 6 hours;\n    allMCRData.push(McrData(0, 0, 0, 0));\n    minCap = 12000 * DECIMAL1E18;\n    shockParameter = 50;\n    variationPercX100 = 100; // 1%\n    iaRatesTime = 24 hours; // 24 hours in seconds\n    uniswapDeadline = 20 minutes;\n    liquidityTradeCallbackTime = 4 hours;\n    ethVolumeLimit = 4;\n    capacityLimit = 10;\n    allCurrencies.push(\"ETH\");\n    allCurrencyAssets[\"ETH\"] = CurrencyAssets(address(0), 1000 * DECIMAL1E18, 0);\n    allCurrencies.push(\"DAI\");\n    allCurrencyAssets[\"DAI\"] = CurrencyAssets(_daiAdd, 50000 * DECIMAL1E18, 0);\n    allInvestmentCurrencies.push(\"ETH\");\n    allInvestmentAssets[\"ETH\"] = InvestmentAssets(address(0), true, 2500, 10000, 18);\n    allInvestmentCurrencies.push(\"DAI\");\n    allInvestmentAssets[\"DAI\"] = InvestmentAssets(_daiAdd, true, 250, 1500, 18);\n  }\n\n  /**\n   * @dev to set the maximum cap allowed\n   * @param val is the new value\n   */\n  function setCapReached(uint val) external onlyInternal {\n    capReached = val;\n  }\n\n  /// @dev Updates the 3 day average rate of a IA currency.\n  /// To be replaced by MakerDao's on chain rates\n  /// @param curr IA Currency Name.\n  /// @param rate Average exchange rate X 100 (of last 3 days).\n  function updateIAAvgRate(bytes4 curr, uint rate) external onlyInternal {\n    iaAvgRate[curr] = rate;\n  }\n\n  /// @dev Updates the 3 day average rate of a CA currency.\n  /// To be replaced by MakerDao's on chain rates\n  /// @param curr Currency Name.\n  /// @param rate Average exchange rate X 100 (of last 3 days).\n  function updateCAAvgRate(bytes4 curr, uint rate) external onlyInternal {\n    caAvgRate[curr] = rate;\n  }\n\n  /// @dev Adds details of (Minimum Capital Requirement)MCR.\n  /// @param mcrp Minimum Capital Requirement percentage (MCR% * 100 ,Ex:for 54.56% ,given 5456)\n  /// @param vf Pool fund value in Ether used in the last full daily calculation from the Capital model.\n  function pushMCRData(uint mcrp, uint mcre, uint vf, uint64 time) external onlyInternal {\n    allMCRData.push(McrData(mcrp, mcre, vf, time));\n  }\n\n  /**\n   * @dev Updates the Timestamp at which result of oracalize call is received.\n   */\n  function updateDateUpdOfAPI(bytes32 myid) external onlyInternal {\n    allAPIid[myid].dateUpd = uint64(now);\n  }\n\n  /**\n   * @dev Saves the details of the Oraclize API.\n   * @param myid Id return by the oraclize query.\n   * @param _typeof type of the query for which oraclize call is made.\n   * @param id ID of the proposal,quote,cover etc. for which oraclize call is made\n   */\n  function saveApiDetails(bytes32 myid, bytes4 _typeof, uint id) external onlyInternal {\n    allAPIid[myid] = ApiId(_typeof, \"\", id, uint64(now), uint64(now));\n  }\n\n  /**\n   * @dev Stores the id return by the oraclize query.\n   * Maintains record of all the Ids return by oraclize query.\n   * @param myid Id return by the oraclize query.\n   */\n  function addInAllApiCall(bytes32 myid) external onlyInternal {\n    allAPIcall.push(myid);\n  }\n\n  /**\n   * @dev Saves investment asset rank details.\n   * @param maxIACurr Maximum ranked investment asset currency.\n   * @param maxRate Maximum ranked investment asset rate.\n   * @param minIACurr Minimum ranked investment asset currency.\n   * @param minRate Minimum ranked investment asset rate.\n   * @param date in yyyymmdd.\n   */\n  function saveIARankDetails(\n    bytes4 maxIACurr,\n    uint64 maxRate,\n    bytes4 minIACurr,\n    uint64 minRate,\n    uint64 date\n  )\n  external\n  onlyInternal\n  {\n    allIARankDetails.push(IARankDetails(maxIACurr, maxRate, minIACurr, minRate));\n    datewiseId[date] = allIARankDetails.length.sub(1);\n  }\n\n  /**\n   * @dev to get the time for the laste liquidity trade trigger\n   */\n  function setLastLiquidityTradeTrigger() external onlyInternal {\n    lastLiquidityTradeTrigger = now;\n  }\n\n  /**\n   * @dev Updates Last Date.\n   */\n  function updatelastDate(uint64 newDate) external onlyInternal {\n    lastDate = newDate;\n  }\n\n  /**\n   * @dev Adds currency asset currency.\n   * @param curr currency of the asset\n   * @param currAddress address of the currency\n   * @param baseMin base minimum in 10^18.\n   */\n  function addCurrencyAssetCurrency(\n    bytes4 curr,\n    address currAddress,\n    uint baseMin\n  )\n  external\n  {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    allCurrencies.push(curr);\n    allCurrencyAssets[curr] = CurrencyAssets(currAddress, baseMin, 0);\n  }\n\n  /**\n   * @dev Adds investment asset.\n   */\n  function addInvestmentAssetCurrency(\n    bytes4 curr,\n    address currAddress,\n    bool status,\n    uint64 minHoldingPercX100,\n    uint64 maxHoldingPercX100,\n    uint8 decimals\n  )\n  external\n  {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    allInvestmentCurrencies.push(curr);\n    allInvestmentAssets[curr] = InvestmentAssets(currAddress, status,\n      minHoldingPercX100, maxHoldingPercX100, decimals);\n  }\n\n  /**\n   * @dev Changes base minimum of a given currency asset.\n   */\n  function changeCurrencyAssetBaseMin(bytes4 curr, uint baseMin) external {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    allCurrencyAssets[curr].baseMin = baseMin;\n  }\n\n  /**\n   * @dev changes variable minimum of a given currency asset.\n   */\n  function changeCurrencyAssetVarMin(bytes4 curr, uint varMin) external onlyInternal {\n    allCurrencyAssets[curr].varMin = varMin;\n  }\n\n  /**\n   * @dev Changes the investment asset status.\n   */\n  function changeInvestmentAssetStatus(bytes4 curr, bool status) external {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    allInvestmentAssets[curr].status = status;\n  }\n\n  /**\n   * @dev Changes the investment asset Holding percentage of a given currency.\n   */\n  function changeInvestmentAssetHoldingPerc(\n    bytes4 curr,\n    uint64 minPercX100,\n    uint64 maxPercX100\n  )\n  external\n  {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    allInvestmentAssets[curr].minHoldingPercX100 = minPercX100;\n    allInvestmentAssets[curr].maxHoldingPercX100 = maxPercX100;\n  }\n\n  /**\n   * @dev Gets Currency asset token address.\n   */\n  function changeCurrencyAssetAddress(bytes4 curr, address currAdd) external {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    allCurrencyAssets[curr].currAddress = currAdd;\n  }\n\n  /**\n   * @dev Changes Investment asset token address.\n   */\n  function changeInvestmentAssetAddressAndDecimal(\n    bytes4 curr,\n    address currAdd,\n    uint8 newDecimal\n  )\n  external\n  {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    allInvestmentAssets[curr].currAddress = currAdd;\n    allInvestmentAssets[curr].decimals = newDecimal;\n  }\n\n  /// @dev Changes address allowed to post MCR.\n  function changeNotariseAddress(address _add) external onlyInternal {\n    notariseMCR = _add;\n  }\n\n  /// @dev updates daiFeedAddress address.\n  /// @param _add address of DAI feed.\n  function changeDAIfeedAddress(address _add) external onlyInternal {\n    daiFeedAddress = _add;\n  }\n\n  /**\n   * @dev Gets Uint Parameters of a code\n   * @param code whose details we want\n   * @return string value of the code\n   * @return associated amount (time or perc or value) to the code\n   */\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\n    codeVal = code;\n    if (code == \"MCRTIM\") {\n      val = mcrTime / (1 hours);\n\n    } else if (code == \"MCRFTIM\") {\n\n      val = mcrFailTime / (1 hours);\n\n    } else if (code == \"MCRMIN\") {\n\n      val = minCap;\n\n    } else if (code == \"MCRSHOCK\") {\n\n      val = shockParameter;\n\n    } else if (code == \"MCRCAPL\") {\n\n      val = capacityLimit;\n\n    } else if (code == \"IMZ\") {\n\n      val = variationPercX100;\n\n    } else if (code == \"IMRATET\") {\n\n      val = iaRatesTime / (1 hours);\n\n    } else if (code == \"IMUNIDL\") {\n\n      val = uniswapDeadline / (1 minutes);\n\n    } else if (code == \"IMLIQT\") {\n\n      val = liquidityTradeCallbackTime / (1 hours);\n\n    } else if (code == \"IMETHVL\") {\n\n      val = ethVolumeLimit;\n\n    } else if (code == \"C\") {\n      val = c;\n\n    } else if (code == \"A\") {\n\n      val = a;\n\n    }\n\n  }\n\n  /// @dev Checks whether a given address can notaise MCR data or not.\n  /// @param _add Address.\n  /// @return res Returns 0 if address is not authorized, else 1.\n  function isnotarise(address _add) external view returns (bool res) {\n    res = false;\n    if (_add == notariseMCR)\n      res = true;\n  }\n\n  /// @dev Gets the details of last added MCR.\n  /// @return mcrPercx100 Total Minimum Capital Requirement percentage of that month of year(multiplied by 100).\n  /// @return vFull Total Pool fund value in Ether used in the last full daily calculation.\n  function getLastMCR() external view returns (uint mcrPercx100, uint mcrEtherx1E18, uint vFull, uint64 date) {\n    uint index = allMCRData.length.sub(1);\n    return (\n    allMCRData[index].mcrPercx100,\n    allMCRData[index].mcrEther,\n    allMCRData[index].vFull,\n    allMCRData[index].date\n    );\n  }\n\n  /// @dev Gets last Minimum Capital Requirement percentage of Capital Model\n  /// @return val MCR% value,multiplied by 100.\n  function getLastMCRPerc() external view returns (uint) {\n    return allMCRData[allMCRData.length.sub(1)].mcrPercx100;\n  }\n\n  /// @dev Gets last Ether price of Capital Model\n  /// @return val ether value,multiplied by 100.\n  function getLastMCREther() external view returns (uint) {\n    return allMCRData[allMCRData.length.sub(1)].mcrEther;\n  }\n\n  /// @dev Gets Pool fund value in Ether used in the last full daily calculation from the Capital model.\n  function getLastVfull() external view returns (uint) {\n    return allMCRData[allMCRData.length.sub(1)].vFull;\n  }\n\n  /// @dev Gets last Minimum Capital Requirement in Ether.\n  /// @return date of MCR.\n  function getLastMCRDate() external view returns (uint64 date) {\n    date = allMCRData[allMCRData.length.sub(1)].date;\n  }\n\n  /// @dev Gets details for token price calculation.\n  function getTokenPriceDetails(bytes4 curr) external view returns (uint _a, uint _c, uint rate) {\n    _a = a;\n    _c = c;\n    rate = _getAvgRate(curr, false);\n  }\n\n  /// @dev Gets the total number of times MCR calculation has been made.\n  function getMCRDataLength() external view returns (uint len) {\n    len = allMCRData.length;\n  }\n\n  /**\n   * @dev Gets investment asset rank details by given date.\n   */\n  function getIARankDetailsByDate(\n    uint64 date\n  )\n  external\n  view\n  returns (\n    bytes4 maxIACurr,\n    uint64 maxRate,\n    bytes4 minIACurr,\n    uint64 minRate\n  )\n  {\n    uint index = datewiseId[date];\n    return (\n    allIARankDetails[index].maxIACurr,\n    allIARankDetails[index].maxRate,\n    allIARankDetails[index].minIACurr,\n    allIARankDetails[index].minRate\n    );\n  }\n\n  /**\n   * @dev Gets Last Date.\n   */\n  function getLastDate() external view returns (uint64 date) {\n    return lastDate;\n  }\n\n  /**\n   * @dev Gets investment currency for a given index.\n   */\n  function getInvestmentCurrencyByIndex(uint index) external view returns (bytes4 currName) {\n    return allInvestmentCurrencies[index];\n  }\n\n  /**\n   * @dev Gets count of investment currency.\n   */\n  function getInvestmentCurrencyLen() external view returns (uint len) {\n    return allInvestmentCurrencies.length;\n  }\n\n  /**\n   * @dev Gets all the investment currencies.\n   */\n  function getAllInvestmentCurrencies() external view returns (bytes4[] memory currencies) {\n    return allInvestmentCurrencies;\n  }\n\n  /**\n   * @dev Gets All currency for a given index.\n   */\n  function getCurrenciesByIndex(uint index) external view returns (bytes4 currName) {\n    return allCurrencies[index];\n  }\n\n  /**\n   * @dev Gets count of All currency.\n   */\n  function getAllCurrenciesLen() external view returns (uint len) {\n    return allCurrencies.length;\n  }\n\n  /**\n   * @dev Gets all currencies\n   */\n  function getAllCurrencies() external view returns (bytes4[] memory currencies) {\n    return allCurrencies;\n  }\n\n  /**\n   * @dev Gets currency asset details for a given currency.\n   */\n  function getCurrencyAssetVarBase(\n    bytes4 curr\n  )\n  external\n  view\n  returns (\n    bytes4 currency,\n    uint baseMin,\n    uint varMin\n  )\n  {\n    return (\n    curr,\n    allCurrencyAssets[curr].baseMin,\n    allCurrencyAssets[curr].varMin\n    );\n  }\n\n  /**\n   * @dev Gets minimum variable value for currency asset.\n   */\n  function getCurrencyAssetVarMin(bytes4 curr) external view returns (uint varMin) {\n    return allCurrencyAssets[curr].varMin;\n  }\n\n  /**\n   * @dev Gets base minimum of  a given currency asset.\n   */\n  function getCurrencyAssetBaseMin(bytes4 curr) external view returns (uint baseMin) {\n    return allCurrencyAssets[curr].baseMin;\n  }\n\n  /**\n   * @dev Gets investment asset maximum and minimum holding percentage of a given currency.\n   */\n  function getInvestmentAssetHoldingPerc(\n    bytes4 curr\n  )\n  external\n  view\n  returns (\n    uint64 minHoldingPercX100,\n    uint64 maxHoldingPercX100\n  )\n  {\n    return (\n    allInvestmentAssets[curr].minHoldingPercX100,\n    allInvestmentAssets[curr].maxHoldingPercX100\n    );\n  }\n\n  /**\n   * @dev Gets investment asset decimals.\n   */\n  function getInvestmentAssetDecimals(bytes4 curr) external view returns (uint8 decimal) {\n    return allInvestmentAssets[curr].decimals;\n  }\n\n  /**\n   * @dev Gets investment asset maximum holding percentage of a given currency.\n   */\n  function getInvestmentAssetMaxHoldingPerc(bytes4 curr) external view returns (uint64 maxHoldingPercX100) {\n    return allInvestmentAssets[curr].maxHoldingPercX100;\n  }\n\n  /**\n   * @dev Gets investment asset minimum holding percentage of a given currency.\n   */\n  function getInvestmentAssetMinHoldingPerc(bytes4 curr) external view returns (uint64 minHoldingPercX100) {\n    return allInvestmentAssets[curr].minHoldingPercX100;\n  }\n\n  /**\n   * @dev Gets investment asset details of a given currency\n   */\n  function getInvestmentAssetDetails(\n    bytes4 curr\n  )\n  external\n  view\n  returns (\n    bytes4 currency,\n    address currAddress,\n    bool status,\n    uint64 minHoldingPerc,\n    uint64 maxHoldingPerc,\n    uint8 decimals\n  )\n  {\n    return (\n    curr,\n    allInvestmentAssets[curr].currAddress,\n    allInvestmentAssets[curr].status,\n    allInvestmentAssets[curr].minHoldingPercX100,\n    allInvestmentAssets[curr].maxHoldingPercX100,\n    allInvestmentAssets[curr].decimals\n    );\n  }\n\n  /**\n   * @dev Gets Currency asset token address.\n   */\n  function getCurrencyAssetAddress(bytes4 curr) external view returns (address) {\n    return allCurrencyAssets[curr].currAddress;\n  }\n\n  /**\n   * @dev Gets investment asset token address.\n   */\n  function getInvestmentAssetAddress(bytes4 curr) external view returns (address) {\n    return allInvestmentAssets[curr].currAddress;\n  }\n\n  /**\n   * @dev Gets investment asset active Status of a given currency.\n   */\n  function getInvestmentAssetStatus(bytes4 curr) external view returns (bool status) {\n    return allInvestmentAssets[curr].status;\n  }\n\n  /**\n   * @dev Gets type of oraclize query for a given Oraclize Query ID.\n   * @param myid Oraclize Query ID identifying the query for which the result is being received.\n   * @return _typeof It could be of type \"quote\",\"quotation\",\"cover\",\"claim\" etc.\n   */\n  function getApiIdTypeOf(bytes32 myid) external view returns (bytes4) {\n    return allAPIid[myid].typeOf;\n  }\n\n  /**\n   * @dev Gets ID associated to oraclize query for a given Oraclize Query ID.\n   * @param myid Oraclize Query ID identifying the query for which the result is being received.\n   * @return id1 It could be the ID of \"proposal\",\"quotation\",\"cover\",\"claim\" etc.\n   */\n  function getIdOfApiId(bytes32 myid) external view returns (uint) {\n    return allAPIid[myid].id;\n  }\n\n  /**\n   * @dev Gets the Timestamp of a oracalize call.\n   */\n  function getDateAddOfAPI(bytes32 myid) external view returns (uint64) {\n    return allAPIid[myid].dateAdd;\n  }\n\n  /**\n   * @dev Gets the Timestamp at which result of oracalize call is received.\n   */\n  function getDateUpdOfAPI(bytes32 myid) external view returns (uint64) {\n    return allAPIid[myid].dateUpd;\n  }\n\n  /**\n   * @dev Gets currency by oracalize id.\n   */\n  function getCurrOfApiId(bytes32 myid) external view returns (bytes4) {\n    return allAPIid[myid].currency;\n  }\n\n  /**\n   * @dev Gets ID return by the oraclize query of a given index.\n   * @param index Index.\n   * @return myid ID return by the oraclize query.\n   */\n  function getApiCallIndex(uint index) external view returns (bytes32 myid) {\n    myid = allAPIcall[index];\n  }\n\n  /**\n   * @dev Gets Length of API call.\n   */\n  function getApilCallLength() external view returns (uint) {\n    return allAPIcall.length;\n  }\n\n  /**\n   * @dev Get Details of Oraclize API when given Oraclize Id.\n   * @param myid ID return by the oraclize query.\n   * @return _typeof ype of the query for which oraclize\n   * call is made.(\"proposal\",\"quote\",\"quotation\" etc.)\n   */\n  function getApiCallDetails(\n    bytes32 myid\n  )\n  external\n  view\n  returns (\n    bytes4 _typeof,\n    bytes4 curr,\n    uint id,\n    uint64 dateAdd,\n    uint64 dateUpd\n  )\n  {\n    return (\n    allAPIid[myid].typeOf,\n    allAPIid[myid].currency,\n    allAPIid[myid].id,\n    allAPIid[myid].dateAdd,\n    allAPIid[myid].dateUpd\n    );\n  }\n\n  /**\n   * @dev Updates Uint Parameters of a code\n   * @param code whose details we want to update\n   * @param val value to set\n   */\n  function updateUintParameters(bytes8 code, uint val) public {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    if (code == \"MCRTIM\") {\n      _changeMCRTime(val * 1 hours);\n\n    } else if (code == \"MCRFTIM\") {\n\n      _changeMCRFailTime(val * 1 hours);\n\n    } else if (code == \"MCRMIN\") {\n\n      _changeMinCap(val);\n\n    } else if (code == \"MCRSHOCK\") {\n\n      _changeShockParameter(val);\n\n    } else if (code == \"MCRCAPL\") {\n\n      _changeCapacityLimit(val);\n\n    } else if (code == \"IMZ\") {\n\n      _changeVariationPercX100(val);\n\n    } else if (code == \"IMRATET\") {\n\n      _changeIARatesTime(val * 1 hours);\n\n    } else if (code == \"IMUNIDL\") {\n\n      _changeUniswapDeadlineTime(val * 1 minutes);\n\n    } else if (code == \"IMLIQT\") {\n\n      _changeliquidityTradeCallbackTime(val * 1 hours);\n\n    } else if (code == \"IMETHVL\") {\n\n      _setEthVolumeLimit(val);\n\n    } else if (code == \"C\") {\n      _changeC(val);\n\n    } else if (code == \"A\") {\n\n      _changeA(val);\n\n    } else {\n      revert(\"Invalid param code\");\n    }\n\n  }\n\n  /**\n   * @dev to get the average rate of currency rate\n   * @param curr is the currency in concern\n   * @return required rate\n   */\n  function getCAAvgRate(bytes4 curr) public view returns (uint rate) {\n    return _getAvgRate(curr, false);\n  }\n\n  /**\n   * @dev to get the average rate of investment rate\n   * @param curr is the investment in concern\n   * @return required rate\n   */\n  function getIAAvgRate(bytes4 curr) public view returns (uint rate) {\n    return _getAvgRate(curr, true);\n  }\n\n  function changeDependentContractAddress() public onlyInternal {}\n\n  /// @dev Gets the average rate of a CA currency.\n  /// @param curr Currency Name.\n  /// @return rate Average rate X 100(of last 3 days).\n  function _getAvgRate(bytes4 curr, bool isIA) internal view returns (uint rate) {\n    if (curr == \"DAI\") {\n      DSValue ds = DSValue(daiFeedAddress);\n      rate = uint(ds.read()).div(uint(10) ** 16);\n    } else if (isIA) {\n      rate = iaAvgRate[curr];\n    } else {\n      rate = caAvgRate[curr];\n    }\n  }\n\n  /**\n   * @dev to set the ethereum volume limit\n   * @param val is the new limit value\n   */\n  function _setEthVolumeLimit(uint val) internal {\n    ethVolumeLimit = val;\n  }\n\n  /// @dev Sets minimum Cap.\n  function _changeMinCap(uint newCap) internal {\n    minCap = newCap;\n  }\n\n  /// @dev Sets Shock Parameter.\n  function _changeShockParameter(uint newParam) internal {\n    shockParameter = newParam;\n  }\n\n  /// @dev Changes time period for obtaining new MCR data from external oracle query.\n  function _changeMCRTime(uint _time) internal {\n    mcrTime = _time;\n  }\n\n  /// @dev Sets MCR Fail time.\n  function _changeMCRFailTime(uint _time) internal {\n    mcrFailTime = _time;\n  }\n\n  /**\n   * @dev to change the uniswap deadline time\n   * @param newDeadline is the value\n   */\n  function _changeUniswapDeadlineTime(uint newDeadline) internal {\n    uniswapDeadline = newDeadline;\n  }\n\n  /**\n   * @dev to change the liquidity trade call back time\n   * @param newTime is the new value to be set\n   */\n  function _changeliquidityTradeCallbackTime(uint newTime) internal {\n    liquidityTradeCallbackTime = newTime;\n  }\n\n  /**\n   * @dev Changes time after which investment asset rates need to be fed.\n   */\n  function _changeIARatesTime(uint _newTime) internal {\n    iaRatesTime = _newTime;\n  }\n\n  /**\n   * @dev Changes the variation range percentage.\n   */\n  function _changeVariationPercX100(uint newPercX100) internal {\n    variationPercX100 = newPercX100;\n  }\n\n  /// @dev Changes Growth Step\n  function _changeC(uint newC) internal {\n    c = newC;\n  }\n\n  /// @dev Changes scaling factor.\n  function _changeA(uint val) internal {\n    a = val;\n  }\n\n  /**\n   * @dev to change the capacity limit\n   * @param val is the new value\n   */\n  function _changeCapacityLimit(uint val) internal {\n    capacityLimit = val;\n  }\n}\n"
51     },
52     "contracts/modules/claims/ClaimsReward.sol": {
53       "content": "/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\n//Claims Reward Contract contains the functions for calculating number of tokens\n// that will get rewarded, unlocked or burned depending upon the status of claim.\n\npragma solidity ^0.5.0;\n\nimport \"../../interfaces/IPooledStaking.sol\";\nimport \"../capital/Pool.sol\";\nimport \"../cover/QuotationData.sol\";\nimport \"../governance/Governance.sol\";\nimport \"../token/TokenData.sol\";\nimport \"../token/TokenFunctions.sol\";\nimport \"./Claims.sol\";\nimport \"./ClaimsData.sol\";\n\ncontract ClaimsReward is Iupgradable {\n  using SafeMath for uint;\n\n  NXMToken internal tk;\n  TokenController internal tc;\n  TokenFunctions internal tf;\n  TokenData internal td;\n  QuotationData internal qd;\n  Claims internal c1;\n  ClaimsData internal cd;\n  Pool internal pool;\n  Governance internal gv;\n  IPooledStaking internal pooledStaking;\n  MemberRoles internal memberRoles;\n\n  // assigned in constructor\n  address public DAI;\n\n  // constants\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\n\n  constructor (address masterAddress, address _daiAddress) public {\n    changeMasterAddress(masterAddress);\n    DAI = _daiAddress;\n  }\n\n  function changeDependentContractAddress() public onlyInternal {\n    c1 = Claims(ms.getLatestAddress(\"CL\"));\n    cd = ClaimsData(ms.getLatestAddress(\"CD\"));\n    tk = NXMToken(ms.tokenAddress());\n    tc = TokenController(ms.getLatestAddress(\"TC\"));\n    td = TokenData(ms.getLatestAddress(\"TD\"));\n    tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\n    gv = Governance(ms.getLatestAddress(\"GV\"));\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\"PS\"));\n    memberRoles = MemberRoles(ms.getLatestAddress(\"MR\"));\n    pool = Pool(ms.getLatestAddress(\"P1\"));\n  }\n\n  /// @dev Decides the next course of action for a given claim.\n  function changeClaimStatus(uint claimid) public checkPause onlyInternal {\n\n    (, uint coverid) = cd.getClaimCoverId(claimid);\n    (, uint status) = cd.getClaimStatusNumber(claimid);\n\n    // when current status is \"Pending-Claim Assessor Vote\"\n    if (status == 0) {\n      _changeClaimStatusCA(claimid, coverid, status);\n    } else if (status >= 1 && status <= 5) {\n      _changeClaimStatusMV(claimid, coverid, status);\n    } else if (status == 12) {// when current status is \"Claim Accepted Payout Pending\"\n\n      bool payoutSucceeded = attemptClaimPayout(coverid);\n\n      if (payoutSucceeded) {\n        c1.setClaimStatus(claimid, 14);\n      } else {\n        c1.setClaimStatus(claimid, 12);\n      }\n    }\n\n    c1.changePendingClaimStart();\n  }\n\n  function getCurrencyAssetAddress(bytes4 currency) public view returns (address) {\n\n    if (currency == \"ETH\") {\n      return ETH;\n    }\n\n    if (currency == \"DAI\") {\n      return DAI;\n    }\n\n    revert(\"ClaimsReward: unknown asset\");\n  }\n\n  function attemptClaimPayout(uint coverId) internal returns (bool success) {\n\n    uint sumAssured = qd.getCoverSumAssured(coverId);\n    // TODO: when adding new cover currencies, fetch the correct decimals for this multiplication\n    uint sumAssuredWei = sumAssured.mul(1e18);\n\n    // get asset address\n    bytes4 coverCurrency = qd.getCurrencyOfCover(coverId);\n    address asset = getCurrencyAssetAddress(coverCurrency);\n\n    // get payout address\n    address payable coverHolder = qd.getCoverMemberAddress(coverId);\n    address payable payoutAddress = memberRoles.getClaimPayoutAddress(coverHolder);\n\n    // execute the payout\n    bool payoutSucceeded = pool.sendClaimPayout(asset, payoutAddress, sumAssuredWei);\n\n    if (payoutSucceeded) {\n\n      // burn staked tokens\n      (, address scAddress) = qd.getscAddressOfCover(coverId);\n      uint tokenPrice = pool.getTokenPrice(asset);\n\n      // note: for new assets \"18\" needs to be replaced with target asset decimals\n      uint burnNXMAmount = sumAssuredWei.mul(1e18).div(tokenPrice);\n      pooledStaking.pushBurn(scAddress, burnNXMAmount);\n\n      // adjust total sum assured\n      (, address coverContract) = qd.getscAddressOfCover(coverId);\n      qd.subFromTotalSumAssured(coverCurrency, sumAssured);\n      qd.subFromTotalSumAssuredSC(coverContract, coverCurrency, sumAssured);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /// @dev Amount of tokens to be rewarded to a user for a particular vote id.\n  /// @param check 1 -> CA vote, else member vote\n  /// @param voteid vote id for which reward has to be Calculated\n  /// @param flag if 1 calculate even if claimed,else don't calculate if already claimed\n  /// @return tokenCalculated reward to be given for vote id\n  /// @return lastClaimedCheck true if final verdict is still pending for that voteid\n  /// @return tokens number of tokens locked under that voteid\n  /// @return perc percentage of reward to be given.\n  function getRewardToBeGiven(\n    uint check,\n    uint voteid,\n    uint flag\n  )\n  public\n  view\n  returns (\n    uint tokenCalculated,\n    bool lastClaimedCheck,\n    uint tokens,\n    uint perc\n  )\n\n  {\n    uint claimId;\n    int8 verdict;\n    bool claimed;\n    uint tokensToBeDist;\n    uint totalTokens;\n    (tokens, claimId, verdict, claimed) = cd.getVoteDetails(voteid);\n    lastClaimedCheck = false;\n    int8 claimVerdict = cd.getFinalVerdict(claimId);\n    if (claimVerdict == 0) {\n      lastClaimedCheck = true;\n    }\n\n    if (claimVerdict == verdict && (claimed == false || flag == 1)) {\n\n      if (check == 1) {\n        (perc, , tokensToBeDist) = cd.getClaimRewardDetail(claimId);\n      } else {\n        (, perc, tokensToBeDist) = cd.getClaimRewardDetail(claimId);\n      }\n\n      if (perc > 0) {\n        if (check == 1) {\n          if (verdict == 1) {\n            (, totalTokens,) = cd.getClaimsTokenCA(claimId);\n          } else {\n            (,, totalTokens) = cd.getClaimsTokenCA(claimId);\n          }\n        } else {\n          if (verdict == 1) {\n            (, totalTokens,) = cd.getClaimsTokenMV(claimId);\n          } else {\n            (,, totalTokens) = cd.getClaimsTokenMV(claimId);\n          }\n        }\n        tokenCalculated = (perc.mul(tokens).mul(tokensToBeDist)).div(totalTokens.mul(100));\n\n\n      }\n    }\n  }\n\n  /// @dev Transfers all tokens held by contract to a new contract in case of upgrade.\n  function upgrade(address _newAdd) public onlyInternal {\n    uint amount = tk.balanceOf(address(this));\n    if (amount > 0) {\n      require(tk.transfer(_newAdd, amount));\n    }\n\n  }\n\n  /// @dev Total reward in token due for claim by a user.\n  /// @return total total number of tokens\n  function getRewardToBeDistributedByUser(address _add) public view returns (uint total) {\n    uint lengthVote = cd.getVoteAddressCALength(_add);\n    uint lastIndexCA;\n    uint lastIndexMV;\n    uint tokenForVoteId;\n    uint voteId;\n    (lastIndexCA, lastIndexMV) = cd.getRewardDistributedIndex(_add);\n\n    for (uint i = lastIndexCA; i < lengthVote; i++) {\n      voteId = cd.getVoteAddressCA(_add, i);\n      (tokenForVoteId,,,) = getRewardToBeGiven(1, voteId, 0);\n      total = total.add(tokenForVoteId);\n    }\n\n    lengthVote = cd.getVoteAddressMemberLength(_add);\n\n    for (uint j = lastIndexMV; j < lengthVote; j++) {\n      voteId = cd.getVoteAddressMember(_add, j);\n      (tokenForVoteId,,,) = getRewardToBeGiven(0, voteId, 0);\n      total = total.add(tokenForVoteId);\n    }\n    return (total);\n  }\n\n  /// @dev Gets reward amount and claiming status for a given claim id.\n  /// @return reward amount of tokens to user.\n  /// @return claimed true if already claimed false if yet to be claimed.\n  function getRewardAndClaimedStatus(uint check, uint claimId) public view returns (uint reward, bool claimed) {\n    uint voteId;\n    uint claimid;\n    uint lengthVote;\n\n    if (check == 1) {\n      lengthVote = cd.getVoteAddressCALength(msg.sender);\n      for (uint i = 0; i < lengthVote; i++) {\n        voteId = cd.getVoteAddressCA(msg.sender, i);\n        (, claimid, , claimed) = cd.getVoteDetails(voteId);\n        if (claimid == claimId) {break;}\n      }\n    } else {\n      lengthVote = cd.getVoteAddressMemberLength(msg.sender);\n      for (uint j = 0; j < lengthVote; j++) {\n        voteId = cd.getVoteAddressMember(msg.sender, j);\n        (, claimid, , claimed) = cd.getVoteDetails(voteId);\n        if (claimid == claimId) {break;}\n      }\n    }\n    (reward,,,) = getRewardToBeGiven(check, voteId, 1);\n\n  }\n\n  /**\n   * @dev Function used to claim all pending rewards : Claims Assessment + Risk Assessment + Governance\n   * Claim assesment, Risk assesment, Governance rewards\n   */\n  function claimAllPendingReward(uint records) public isMemberAndcheckPause {\n    _claimRewardToBeDistributed(records);\n    pooledStaking.withdrawReward(msg.sender);\n    uint governanceRewards = gv.claimReward(msg.sender, records);\n    if (governanceRewards > 0) {\n      require(tk.transfer(msg.sender, governanceRewards));\n    }\n  }\n\n  /**\n   * @dev Function used to get pending rewards of a particular user address.\n   * @param _add user address.\n   * @return total reward amount of the user\n   */\n  function getAllPendingRewardOfUser(address _add) public view returns (uint) {\n    uint caReward = getRewardToBeDistributedByUser(_add);\n    uint pooledStakingReward = pooledStaking.stakerReward(_add);\n    uint governanceReward = gv.getPendingReward(_add);\n    return caReward.add(pooledStakingReward).add(governanceReward);\n  }\n\n  /// @dev Rewards/Punishes users who  participated in Claims assessment.\n  //    Unlocking and burning of the tokens will also depend upon the status of claim.\n  /// @param claimid Claim Id.\n  function _rewardAgainstClaim(uint claimid, uint coverid, uint status) internal {\n\n    uint premiumNXM = qd.getCoverPremiumNXM(coverid);\n    uint distributableTokens = premiumNXM.mul(cd.claimRewardPerc()).div(100); // 20% of premium\n\n    uint percCA;\n    uint percMV;\n\n    (percCA, percMV) = cd.getRewardStatus(status);\n    cd.setClaimRewardDetail(claimid, percCA, percMV, distributableTokens);\n\n    if (percCA > 0 || percMV > 0) {\n      tc.mint(address(this), distributableTokens);\n    }\n\n    // denied\n    if (status == 6 || status == 9 || status == 11) {\n\n      cd.changeFinalVerdict(claimid, - 1);\n      td.setDepositCN(coverid, false); // Unset flag\n      tf.burnDepositCN(coverid); // burn Deposited CN\n\n    // accepted\n    } else if (status == 7 || status == 8 || status == 10) {\n\n      cd.changeFinalVerdict(claimid, 1);\n      td.setDepositCN(coverid, false); // Unset flag\n      tf.unlockCN(coverid);\n\n      bool payoutSucceeded = attemptClaimPayout(coverid);\n\n      // 12 = payout pending, 14 = payout succeeded\n      uint nextStatus = payoutSucceeded ? 14 : 12;\n      c1.setClaimStatus(claimid, nextStatus);\n    }\n  }\n\n  /// @dev Computes the result of Claim Assessors Voting for a given claim id.\n  function _changeClaimStatusCA(uint claimid, uint coverid, uint status) internal {\n    // Check if voting should be closed or not\n    if (c1.checkVoteClosing(claimid) == 1) {\n      uint caTokens = c1.getCATokens(claimid, 0); // converted in cover currency.\n      uint accept;\n      uint deny;\n      uint acceptAndDeny;\n      bool rewardOrPunish;\n      uint sumAssured;\n      (, accept) = cd.getClaimVote(claimid, 1);\n      (, deny) = cd.getClaimVote(claimid, - 1);\n      acceptAndDeny = accept.add(deny);\n      accept = accept.mul(100);\n      deny = deny.mul(100);\n\n      if (caTokens == 0) {\n        status = 3;\n      } else {\n        sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\n        // Min threshold reached tokens used for voting > 5* sum assured\n        if (caTokens > sumAssured.mul(5)) {\n\n          if (accept.div(acceptAndDeny) > 70) {\n            status = 7;\n            qd.changeCoverStatusNo(coverid, uint8(QuotationData.CoverStatus.ClaimAccepted));\n            rewardOrPunish = true;\n          } else if (deny.div(acceptAndDeny) > 70) {\n            status = 6;\n            qd.changeCoverStatusNo(coverid, uint8(QuotationData.CoverStatus.ClaimDenied));\n            rewardOrPunish = true;\n          } else if (accept.div(acceptAndDeny) > deny.div(acceptAndDeny)) {\n            status = 4;\n          } else {\n            status = 5;\n          }\n\n        } else {\n\n          if (accept.div(acceptAndDeny) > deny.div(acceptAndDeny)) {\n            status = 2;\n          } else {\n            status = 3;\n          }\n        }\n      }\n\n      c1.setClaimStatus(claimid, status);\n\n      if (rewardOrPunish) {\n        _rewardAgainstClaim(claimid, coverid, status);\n      }\n    }\n  }\n\n  /// @dev Computes the result of Member Voting for a given claim id.\n  function _changeClaimStatusMV(uint claimid, uint coverid, uint status) internal {\n\n    // Check if voting should be closed or not\n    if (c1.checkVoteClosing(claimid) == 1) {\n      uint8 coverStatus;\n      uint statusOrig = status;\n      uint mvTokens = c1.getCATokens(claimid, 1); // converted in cover currency.\n\n      // If tokens used for acceptance >50%, claim is accepted\n      uint sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\n      uint thresholdUnreached = 0;\n      // Minimum threshold for member voting is reached only when\n      // value of tokens used for voting > 5* sum assured of claim id\n      if (mvTokens < sumAssured.mul(5)) {\n        thresholdUnreached = 1;\n      }\n\n      uint accept;\n      (, accept) = cd.getClaimMVote(claimid, 1);\n      uint deny;\n      (, deny) = cd.getClaimMVote(claimid, - 1);\n\n      if (accept.add(deny) > 0) {\n        if (accept.mul(100).div(accept.add(deny)) >= 50 && statusOrig > 1 &&\n        statusOrig <= 5 && thresholdUnreached == 0) {\n          status = 8;\n          coverStatus = uint8(QuotationData.CoverStatus.ClaimAccepted);\n        } else if (deny.mul(100).div(accept.add(deny)) >= 50 && statusOrig > 1 &&\n        statusOrig <= 5 && thresholdUnreached == 0) {\n          status = 9;\n          coverStatus = uint8(QuotationData.CoverStatus.ClaimDenied);\n        }\n      }\n\n      if (thresholdUnreached == 1 && (statusOrig == 2 || statusOrig == 4)) {\n        status = 10;\n        coverStatus = uint8(QuotationData.CoverStatus.ClaimAccepted);\n      } else if (thresholdUnreached == 1 && (statusOrig == 5 || statusOrig == 3 || statusOrig == 1)) {\n        status = 11;\n        coverStatus = uint8(QuotationData.CoverStatus.ClaimDenied);\n      }\n\n      c1.setClaimStatus(claimid, status);\n      qd.changeCoverStatusNo(coverid, uint8(coverStatus));\n      // Reward/Punish Claim Assessors and Members who participated in Claims assessment\n      _rewardAgainstClaim(claimid, coverid, status);\n    }\n  }\n\n  /// @dev Allows a user to claim all pending  Claims assessment rewards.\n  function _claimRewardToBeDistributed(uint _records) internal {\n    uint lengthVote = cd.getVoteAddressCALength(msg.sender);\n    uint voteid;\n    uint lastIndex;\n    (lastIndex,) = cd.getRewardDistributedIndex(msg.sender);\n    uint total = 0;\n    uint tokenForVoteId = 0;\n    bool lastClaimedCheck;\n    uint _days = td.lockCADays();\n    bool claimed;\n    uint counter = 0;\n    uint claimId;\n    uint perc;\n    uint i;\n    uint lastClaimed = lengthVote;\n\n    for (i = lastIndex; i < lengthVote && counter < _records; i++) {\n      voteid = cd.getVoteAddressCA(msg.sender, i);\n      (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\n      if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n        lastClaimed = i;\n      }\n      (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n      if (perc > 0 && !claimed) {\n        counter++;\n        cd.setRewardClaimed(voteid, true);\n      } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\n        (perc,,) = cd.getClaimRewardDetail(claimId);\n        if (perc == 0) {\n          counter++;\n        }\n        cd.setRewardClaimed(voteid, true);\n      }\n      if (tokenForVoteId > 0) {\n        total = tokenForVoteId.add(total);\n      }\n    }\n    if (lastClaimed == lengthVote) {\n      cd.setRewardDistributedIndexCA(msg.sender, i);\n    }\n    else {\n      cd.setRewardDistributedIndexCA(msg.sender, lastClaimed);\n    }\n    lengthVote = cd.getVoteAddressMemberLength(msg.sender);\n    lastClaimed = lengthVote;\n    _days = _days.mul(counter);\n    if (tc.tokensLockedAtTime(msg.sender, \"CLA\", now) > 0) {\n      tc.reduceLock(msg.sender, \"CLA\", _days);\n    }\n    (, lastIndex) = cd.getRewardDistributedIndex(msg.sender);\n    lastClaimed = lengthVote;\n    counter = 0;\n    for (i = lastIndex; i < lengthVote && counter < _records; i++) {\n      voteid = cd.getVoteAddressMember(msg.sender, i);\n      (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);\n      if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n        lastClaimed = i;\n      }\n      (, claimId, , claimed) = cd.getVoteDetails(voteid);\n      if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\n        cd.setRewardClaimed(voteid, true);\n        counter++;\n      }\n      if (tokenForVoteId > 0) {\n        total = tokenForVoteId.add(total);\n      }\n    }\n    if (total > 0) {\n      require(tk.transfer(msg.sender, total));\n    }\n    if (lastClaimed == lengthVote) {\n      cd.setRewardDistributedIndexMV(msg.sender, i);\n    }\n    else {\n      cd.setRewardDistributedIndexMV(msg.sender, lastClaimed);\n    }\n  }\n\n  /**\n   * @dev Function used to claim the commission earned by the staker.\n   */\n  function _claimStakeCommission(uint _records, address _user) external onlyInternal {\n    uint total = 0;\n    uint len = td.getStakerStakedContractLength(_user);\n    uint lastCompletedStakeCommission = td.lastCompletedStakeCommission(_user);\n    uint commissionEarned;\n    uint commissionRedeemed;\n    uint maxCommission;\n    uint lastCommisionRedeemed = len;\n    uint counter;\n    uint i;\n\n    for (i = lastCompletedStakeCommission; i < len && counter < _records; i++) {\n      commissionRedeemed = td.getStakerRedeemedStakeCommission(_user, i);\n      commissionEarned = td.getStakerEarnedStakeCommission(_user, i);\n      maxCommission = td.getStakerInitialStakedAmountOnContract(\n        _user, i).mul(td.stakerMaxCommissionPer()).div(100);\n      if (lastCommisionRedeemed == len && maxCommission != commissionEarned)\n        lastCommisionRedeemed = i;\n      td.pushRedeemedStakeCommissions(_user, i, commissionEarned.sub(commissionRedeemed));\n      total = total.add(commissionEarned.sub(commissionRedeemed));\n      counter++;\n    }\n    if (lastCommisionRedeemed == len) {\n      td.setLastCompletedStakeCommissionIndex(_user, i);\n    } else {\n      td.setLastCompletedStakeCommissionIndex(_user, lastCommisionRedeemed);\n    }\n\n    if (total > 0)\n      require(tk.transfer(_user, total)); // solhint-disable-line\n  }\n\n}\n"
54     },
55     "contracts/modules/governance/MemberRoles.sol": {
56       "content": "/* Copyright (C) 2017 GovBlocks.io\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\nimport \"../claims/ClaimsReward.sol\";\nimport \"../cover/QuotationData.sol\";\nimport \"../token/TokenController.sol\";\nimport \"../token/TokenData.sol\";\nimport \"../token/TokenFunctions.sol\";\nimport \"./Governance.sol\";\nimport \"./external/Governed.sol\";\n\ncontract MemberRoles is Governed, Iupgradable {\n\n  TokenController public dAppToken;\n  TokenData internal td;\n  QuotationData internal qd;\n  ClaimsReward internal cr;\n  Governance internal gv;\n  TokenFunctions internal tf;\n  NXMToken public tk;\n\n  struct MemberRoleDetails {\n    uint memberCounter;\n    mapping(address => bool) memberActive;\n    address[] memberAddress;\n    address authorized;\n  }\n\n  enum Role {UnAssigned, AdvisoryBoard, Member, Owner}\n\n  event MemberRole(uint256 indexed roleId, bytes32 roleName, string roleDescription);\n\n  event switchedMembership(address indexed previousMember, address indexed newMember, uint timeStamp);\n\n  event ClaimPayoutAddressSet(address indexed member, address indexed payoutAddress);\n\n  MemberRoleDetails[] internal memberRoleData;\n  bool internal constructorCheck;\n  uint public maxABCount;\n  bool public launched;\n  uint public launchedOn;\n\n  mapping (address => address payable) internal claimPayoutAddress;\n\n  modifier checkRoleAuthority(uint _memberRoleId) {\n    if (memberRoleData[_memberRoleId].authorized != address(0))\n      require(msg.sender == memberRoleData[_memberRoleId].authorized);\n    else\n      require(isAuthorizedToGovern(msg.sender), \"Not Authorized\");\n    _;\n  }\n\n  /**\n   * @dev to swap advisory board member\n   * @param _newABAddress is address of new AB member\n   * @param _removeAB is advisory board member to be removed\n   */\n  function swapABMember(\n    address _newABAddress,\n    address _removeAB\n  )\n  external\n  checkRoleAuthority(uint(Role.AdvisoryBoard)) {\n\n    _updateRole(_newABAddress, uint(Role.AdvisoryBoard), true);\n    _updateRole(_removeAB, uint(Role.AdvisoryBoard), false);\n\n  }\n\n  /**\n   * @dev to swap the owner address\n   * @param _newOwnerAddress is the new owner address\n   */\n  function swapOwner(\n    address _newOwnerAddress\n  )\n  external {\n    require(msg.sender == address(ms));\n    _updateRole(ms.owner(), uint(Role.Owner), false);\n    _updateRole(_newOwnerAddress, uint(Role.Owner), true);\n  }\n\n  /**\n   * @dev is used to add initital advisory board members\n   * @param abArray is the list of initial advisory board members\n   */\n  function addInitialABMembers(address[] calldata abArray) external onlyOwner {\n\n    //Ensure that NXMaster has initialized.\n    require(ms.masterInitialized());\n\n    require(maxABCount >=\n      SafeMath.add(numberOfMembers(uint(Role.AdvisoryBoard)), abArray.length)\n    );\n    //AB count can't exceed maxABCount\n    for (uint i = 0; i < abArray.length; i++) {\n      require(checkRole(abArray[i], uint(MemberRoles.Role.Member)));\n      _updateRole(abArray[i], uint(Role.AdvisoryBoard), true);\n    }\n  }\n\n  /**\n   * @dev to change max number of AB members allowed\n   * @param _val is the new value to be set\n   */\n  function changeMaxABCount(uint _val) external onlyInternal {\n    maxABCount = _val;\n  }\n\n  /**\n   * @dev Iupgradable Interface to update dependent contract address\n   */\n  function changeDependentContractAddress() public {\n    td = TokenData(ms.getLatestAddress(\"TD\"));\n    cr = ClaimsReward(ms.getLatestAddress(\"CR\"));\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\n    gv = Governance(ms.getLatestAddress(\"GV\"));\n    tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\n    tk = NXMToken(ms.tokenAddress());\n    dAppToken = TokenController(ms.getLatestAddress(\"TC\"));\n  }\n\n  /**\n   * @dev to change the master address\n   * @param _masterAddress is the new master address\n   */\n  function changeMasterAddress(address _masterAddress) public {\n    if (masterAddress != address(0))\n      require(masterAddress == msg.sender);\n    masterAddress = _masterAddress;\n    ms = INXMMaster(_masterAddress);\n    nxMasterAddress = _masterAddress;\n\n  }\n\n  /**\n   * @dev to initiate the member roles\n   * @param _firstAB is the address of the first AB member\n   * @param memberAuthority is the authority (role) of the member\n   */\n  function memberRolesInitiate(address _firstAB, address memberAuthority) public {\n    require(!constructorCheck);\n    _addInitialMemberRoles(_firstAB, memberAuthority);\n    constructorCheck = true;\n  }\n\n  /// @dev Adds new member role\n  /// @param _roleName New role name\n  /// @param _roleDescription New description hash\n  /// @param _authorized Authorized member against every role id\n  function addRole(//solhint-disable-line\n    bytes32 _roleName,\n    string memory _roleDescription,\n    address _authorized\n  )\n  public\n  onlyAuthorizedToGovern {\n    _addRole(_roleName, _roleDescription, _authorized);\n  }\n\n  /// @dev Assign or Delete a member from specific role.\n  /// @param _memberAddress Address of Member\n  /// @param _roleId RoleId to update\n  /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\n  function updateRole(//solhint-disable-line\n    address _memberAddress,\n    uint _roleId,\n    bool _active\n  )\n  public\n  checkRoleAuthority(_roleId) {\n    _updateRole(_memberAddress, _roleId, _active);\n  }\n\n  /**\n   * @dev to add members before launch\n   * @param userArray is list of addresses of members\n   * @param tokens is list of tokens minted for each array element\n   */\n  function addMembersBeforeLaunch(address[] memory userArray, uint[] memory tokens) public onlyOwner {\n    require(!launched);\n\n    for (uint i = 0; i < userArray.length; i++) {\n      require(!ms.isMember(userArray[i]));\n      dAppToken.addToWhitelist(userArray[i]);\n      _updateRole(userArray[i], uint(Role.Member), true);\n      dAppToken.mint(userArray[i], tokens[i]);\n    }\n    launched = true;\n    launchedOn = now;\n\n  }\n\n  /**\n    * @dev Called by user to pay joining membership fee\n    */\n  function payJoiningFee(address _userAddress) public payable {\n    require(_userAddress != address(0));\n    require(!ms.isPause(), \"Emergency Pause Applied\");\n    if (msg.sender == address(ms.getLatestAddress(\"QT\"))) {\n      require(td.walletAddress() != address(0), \"No walletAddress present\");\n      dAppToken.addToWhitelist(_userAddress);\n      _updateRole(_userAddress, uint(Role.Member), true);\n      td.walletAddress().transfer(msg.value);\n    } else {\n      require(!qd.refundEligible(_userAddress));\n      require(!ms.isMember(_userAddress));\n      require(msg.value == td.joiningFee());\n      qd.setRefundEligible(_userAddress, true);\n    }\n  }\n\n  /**\n   * @dev to perform kyc verdict\n   * @param _userAddress whose kyc is being performed\n   * @param verdict of kyc process\n   */\n  function kycVerdict(address payable _userAddress, bool verdict) public {\n\n    require(msg.sender == qd.kycAuthAddress());\n    require(!ms.isPause());\n    require(_userAddress != address(0));\n    require(!ms.isMember(_userAddress));\n    require(qd.refundEligible(_userAddress));\n    if (verdict) {\n      qd.setRefundEligible(_userAddress, false);\n      uint fee = td.joiningFee();\n      dAppToken.addToWhitelist(_userAddress);\n      _updateRole(_userAddress, uint(Role.Member), true);\n      td.walletAddress().transfer(fee); // solhint-disable-line\n\n    } else {\n      qd.setRefundEligible(_userAddress, false);\n      _userAddress.transfer(td.joiningFee()); // solhint-disable-line\n    }\n  }\n\n  /**\n   * @dev Called by existed member if wish to Withdraw membership.\n   */\n  function withdrawMembership() public {\n\n    require(!ms.isPause() && ms.isMember(msg.sender));\n    require(dAppToken.totalLockedBalance(msg.sender, now) == 0); // solhint-disable-line\n    require(!tf.isLockedForMemberVote(msg.sender)); // No locked tokens for Member/Governance voting\n    require(cr.getAllPendingRewardOfUser(msg.sender) == 0); // No pending reward to be claimed(claim assesment).\n    require(dAppToken.tokensUnlockable(msg.sender, \"CLA\") == 0, \"Member should have no CLA unlockable tokens\");\n\n    gv.removeDelegation(msg.sender);\n    dAppToken.burnFrom(msg.sender, tk.balanceOf(msg.sender));\n    _updateRole(msg.sender, uint(Role.Member), false);\n    dAppToken.removeFromWhitelist(msg.sender); // need clarification on whitelist\n\n    if (claimPayoutAddress[msg.sender] != address(0)) {\n      claimPayoutAddress[msg.sender] = address(0);\n      emit ClaimPayoutAddressSet(msg.sender, address(0));\n    }\n  }\n\n  /**\n   * @dev Called by existed member if wish to switch membership to other address.\n   * @param _add address of user to forward membership.\n   */\n  function switchMembership(address _add) external {\n\n    require(!ms.isPause() && ms.isMember(msg.sender) && !ms.isMember(_add));\n    require(dAppToken.totalLockedBalance(msg.sender, now) == 0); // solhint-disable-line\n    require(!tf.isLockedForMemberVote(msg.sender)); // No locked tokens for Member/Governance voting\n    require(cr.getAllPendingRewardOfUser(msg.sender) == 0); // No pending reward to be claimed(claim assesment).\n    require(dAppToken.tokensUnlockable(msg.sender, \"CLA\") == 0, \"Member should have no CLA unlockable tokens\");\n\n    gv.removeDelegation(msg.sender);\n    dAppToken.addToWhitelist(_add);\n    _updateRole(_add, uint(Role.Member), true);\n    tk.transferFrom(msg.sender, _add, tk.balanceOf(msg.sender));\n    _updateRole(msg.sender, uint(Role.Member), false);\n    dAppToken.removeFromWhitelist(msg.sender);\n\n    address payable previousPayoutAddress = claimPayoutAddress[msg.sender];\n\n    if (previousPayoutAddress != address(0)) {\n\n      address payable storedAddress = previousPayoutAddress == _add ? address(0) : previousPayoutAddress;\n\n      claimPayoutAddress[msg.sender] = address(0);\n      claimPayoutAddress[_add] = storedAddress;\n\n      // emit event for old address reset\n      emit ClaimPayoutAddressSet(msg.sender, address(0));\n\n      if (storedAddress != address(0)) {\n        // emit event for setting the payout address on the new member address if it's non zero\n        emit ClaimPayoutAddressSet(_add, storedAddress);\n      }\n    }\n\n    emit switchedMembership(msg.sender, _add, now);\n  }\n\n  function getClaimPayoutAddress(address payable _member) external view returns (address payable) {\n    address payable payoutAddress = claimPayoutAddress[_member];\n    return payoutAddress != address(0) ? payoutAddress : _member;\n  }\n\n  function setClaimPayoutAddress(address payable _address) external {\n\n    require(!ms.isPause(), \"system is paused\");\n    require(ms.isMember(msg.sender), \"sender is not a member\");\n    require(_address != msg.sender, \"should be different than the member address\");\n\n    claimPayoutAddress[msg.sender] = _address;\n    emit ClaimPayoutAddressSet(msg.sender, _address);\n  }\n\n  /// @dev Return number of member roles\n  function totalRoles() public view returns (uint256) {//solhint-disable-line\n    return memberRoleData.length;\n  }\n\n  /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\n  /// @param _roleId roleId to update its Authorized Address\n  /// @param _newAuthorized New authorized address against role id\n  function changeAuthorized(uint _roleId, address _newAuthorized) public checkRoleAuthority(_roleId) {//solhint-disable-line\n    memberRoleData[_roleId].authorized = _newAuthorized;\n  }\n\n  /// @dev Gets the member addresses assigned by a specific role\n  /// @param _memberRoleId Member role id\n  /// @return roleId Role id\n  /// @return allMemberAddress Member addresses of specified role id\n  function members(uint _memberRoleId) public view returns (uint, address[] memory memberArray) {//solhint-disable-line\n    uint length = memberRoleData[_memberRoleId].memberAddress.length;\n    uint i;\n    uint j = 0;\n    memberArray = new address[](memberRoleData[_memberRoleId].memberCounter);\n    for (i = 0; i < length; i++) {\n      address member = memberRoleData[_memberRoleId].memberAddress[i];\n      if (memberRoleData[_memberRoleId].memberActive[member] && !_checkMemberInArray(member, memberArray)) {//solhint-disable-line\n        memberArray[j] = member;\n        j++;\n      }\n    }\n\n    return (_memberRoleId, memberArray);\n  }\n\n  /// @dev Gets all members' length\n  /// @param _memberRoleId Member role id\n  /// @return memberRoleData[_memberRoleId].memberCounter Member length\n  function numberOfMembers(uint _memberRoleId) public view returns (uint) {//solhint-disable-line\n    return memberRoleData[_memberRoleId].memberCounter;\n  }\n\n  /// @dev Return member address who holds the right to add/remove any member from specific role.\n  function authorized(uint _memberRoleId) public view returns (address) {//solhint-disable-line\n    return memberRoleData[_memberRoleId].authorized;\n  }\n\n  /// @dev Get All role ids array that has been assigned to a member so far.\n  function roles(address _memberAddress) public view returns (uint[] memory) {//solhint-disable-line\n    uint length = memberRoleData.length;\n    uint[] memory assignedRoles = new uint[](length);\n    uint counter = 0;\n    for (uint i = 1; i < length; i++) {\n      if (memberRoleData[i].memberActive[_memberAddress]) {\n        assignedRoles[counter] = i;\n        counter++;\n      }\n    }\n    return assignedRoles;\n  }\n\n  /// @dev Returns true if the given role id is assigned to a member.\n  /// @param _memberAddress Address of member\n  /// @param _roleId Checks member's authenticity with the roleId.\n  /// i.e. Returns true if this roleId is assigned to member\n  function checkRole(address _memberAddress, uint _roleId) public view returns (bool) {//solhint-disable-line\n    if (_roleId == uint(Role.UnAssigned))\n      return true;\n    else\n      if (memberRoleData[_roleId].memberActive[_memberAddress]) //solhint-disable-line\n        return true;\n      else\n        return false;\n  }\n\n  /// @dev Return total number of members assigned against each role id.\n  /// @return totalMembers Total members in particular role id\n  function getMemberLengthForAllRoles() public view returns (uint[] memory totalMembers) {//solhint-disable-line\n    totalMembers = new uint[](memberRoleData.length);\n    for (uint i = 0; i < memberRoleData.length; i++) {\n      totalMembers[i] = numberOfMembers(i);\n    }\n  }\n\n  /**\n   * @dev to update the member roles\n   * @param _memberAddress in concern\n   * @param _roleId the id of role\n   * @param _active if active is true, add the member, else remove it\n   */\n  function _updateRole(address _memberAddress,\n    uint _roleId,\n    bool _active) internal {\n    // require(_roleId != uint(Role.TokenHolder), \"Membership to Token holder is detected automatically\");\n    if (_active) {\n      require(!memberRoleData[_roleId].memberActive[_memberAddress]);\n      memberRoleData[_roleId].memberCounter = SafeMath.add(memberRoleData[_roleId].memberCounter, 1);\n      memberRoleData[_roleId].memberActive[_memberAddress] = true;\n      memberRoleData[_roleId].memberAddress.push(_memberAddress);\n    } else {\n      require(memberRoleData[_roleId].memberActive[_memberAddress]);\n      memberRoleData[_roleId].memberCounter = SafeMath.sub(memberRoleData[_roleId].memberCounter, 1);\n      delete memberRoleData[_roleId].memberActive[_memberAddress];\n    }\n  }\n\n  /// @dev Adds new member role\n  /// @param _roleName New role name\n  /// @param _roleDescription New description hash\n  /// @param _authorized Authorized member against every role id\n  function _addRole(\n    bytes32 _roleName,\n    string memory _roleDescription,\n    address _authorized\n  ) internal {\n    emit MemberRole(memberRoleData.length, _roleName, _roleDescription);\n    memberRoleData.push(MemberRoleDetails(0, new address[](0), _authorized));\n  }\n\n  /**\n   * @dev to check if member is in the given member array\n   * @param _memberAddress in concern\n   * @param memberArray in concern\n   * @return boolean to represent the presence\n   */\n  function _checkMemberInArray(\n    address _memberAddress,\n    address[] memory memberArray\n  )\n  internal\n  pure\n  returns (bool memberExists)\n  {\n    uint i;\n    for (i = 0; i < memberArray.length; i++) {\n      if (memberArray[i] == _memberAddress) {\n        memberExists = true;\n        break;\n      }\n    }\n  }\n\n  /**\n   * @dev to add initial member roles\n   * @param _firstAB is the member address to be added\n   * @param memberAuthority is the member authority(role) to be added for\n   */\n  function _addInitialMemberRoles(address _firstAB, address memberAuthority) internal {\n    maxABCount = 5;\n    _addRole(\"Unassigned\", \"Unassigned\", address(0));\n    _addRole(\n      \"Advisory Board\",\n      \"Selected few members that are deeply entrusted by the dApp. An ideal advisory board should be a mix of skills of domain, governance, research, technology, consulting etc to improve the performance of the dApp.\", //solhint-disable-line\n      address(0)\n    );\n    _addRole(\n      \"Member\",\n      \"Represents all users of Mutual.\", //solhint-disable-line\n      memberAuthority\n    );\n    _addRole(\n      \"Owner\",\n      \"Represents Owner of Mutual.\", //solhint-disable-line\n      address(0)\n    );\n    // _updateRole(_firstAB, uint(Role.AdvisoryBoard), true);\n    _updateRole(_firstAB, uint(Role.Owner), true);\n    // _updateRole(_firstAB, uint(Role.Member), true);\n    launchedOn = 0;\n  }\n\n  function memberAtIndex(uint _memberRoleId, uint index) external view returns (address, bool) {\n    address memberAddress = memberRoleData[_memberRoleId].memberAddress[index];\n    return (memberAddress, memberRoleData[_memberRoleId].memberActive[memberAddress]);\n  }\n\n  function membersLength(uint _memberRoleId) external view returns (uint) {\n    return memberRoleData[_memberRoleId].memberAddress.length;\n  }\n}\n"
57     },
58     "contracts/modules/token/TokenData.sol": {
59       "content": "/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../abstract/Iupgradable.sol\";\n\ncontract TokenData is Iupgradable {\n  using SafeMath for uint;\n\n  address payable public walletAddress;\n  uint public lockTokenTimeAfterCoverExp;\n  uint public bookTime;\n  uint public lockCADays;\n  uint public lockMVDays;\n  uint public scValidDays;\n  uint public joiningFee;\n  uint public stakerCommissionPer;\n  uint public stakerMaxCommissionPer;\n  uint public tokenExponent;\n  uint public priceStep;\n\n  struct StakeCommission {\n    uint commissionEarned;\n    uint commissionRedeemed;\n  }\n\n  struct Stake {\n    address stakedContractAddress;\n    uint stakedContractIndex;\n    uint dateAdd;\n    uint stakeAmount;\n    uint unlockedAmount;\n    uint burnedAmount;\n    uint unLockableBeforeLastBurn;\n  }\n\n  struct Staker {\n    address stakerAddress;\n    uint stakerIndex;\n  }\n\n  struct CoverNote {\n    uint amount;\n    bool isDeposited;\n  }\n\n  /**\n   * @dev mapping of uw address to array of sc address to fetch\n   * all staked contract address of underwriter, pushing\n   * data into this array of Stake returns stakerIndex\n   */\n  mapping(address => Stake[]) public stakerStakedContracts;\n\n  /**\n   * @dev mapping of sc address to array of UW address to fetch\n   * all underwritters of the staked smart contract\n   * pushing data into this mapped array returns scIndex\n   */\n  mapping(address => Staker[]) public stakedContractStakers;\n\n  /**\n   * @dev mapping of staked contract Address to the array of StakeCommission\n   * here index of this array is stakedContractIndex\n   */\n  mapping(address => mapping(uint => StakeCommission)) public stakedContractStakeCommission;\n\n  mapping(address => uint) public lastCompletedStakeCommission;\n\n  /**\n   * @dev mapping of the staked contract address to the current\n   * staker index who will receive commission.\n   */\n  mapping(address => uint) public stakedContractCurrentCommissionIndex;\n\n  /**\n   * @dev mapping of the staked contract address to the\n   * current staker index to burn token from.\n   */\n  mapping(address => uint) public stakedContractCurrentBurnIndex;\n\n  /**\n   * @dev mapping to return true if Cover Note deposited against coverId\n   */\n  mapping(uint => CoverNote) public depositedCN;\n\n  mapping(address => uint) internal isBookedTokens;\n\n  event Commission(\n    address indexed stakedContractAddress,\n    address indexed stakerAddress,\n    uint indexed scIndex,\n    uint commissionAmount\n  );\n\n  constructor(address payable _walletAdd) public {\n    walletAddress = _walletAdd;\n    bookTime = 12 hours;\n    joiningFee = 2000000000000000; // 0.002 Ether\n    lockTokenTimeAfterCoverExp = 35 days;\n    scValidDays = 250;\n    lockCADays = 7 days;\n    lockMVDays = 2 days;\n    stakerCommissionPer = 20;\n    stakerMaxCommissionPer = 50;\n    tokenExponent = 4;\n    priceStep = 1000;\n  }\n\n  /**\n   * @dev Change the wallet address which receive Joining Fee\n   */\n  function changeWalletAddress(address payable _address) external onlyInternal {\n    walletAddress = _address;\n  }\n\n  /**\n   * @dev Gets Uint Parameters of a code\n   * @param code whose details we want\n   * @return string value of the code\n   * @return associated amount (time or perc or value) to the code\n   */\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\n    codeVal = code;\n    if (code == \"TOKEXP\") {\n\n      val = tokenExponent;\n\n    } else if (code == \"TOKSTEP\") {\n\n      val = priceStep;\n\n    } else if (code == \"RALOCKT\") {\n\n      val = scValidDays;\n\n    } else if (code == \"RACOMM\") {\n\n      val = stakerCommissionPer;\n\n    } else if (code == \"RAMAXC\") {\n\n      val = stakerMaxCommissionPer;\n\n    } else if (code == \"CABOOKT\") {\n\n      val = bookTime / (1 hours);\n\n    } else if (code == \"CALOCKT\") {\n\n      val = lockCADays / (1 days);\n\n    } else if (code == \"MVLOCKT\") {\n\n      val = lockMVDays / (1 days);\n\n    } else if (code == \"QUOLOCKT\") {\n\n      val = lockTokenTimeAfterCoverExp / (1 days);\n\n    } else if (code == \"JOINFEE\") {\n\n      val = joiningFee;\n\n    }\n  }\n\n  /**\n  * @dev Just for interface\n  */\n  function changeDependentContractAddress() public {//solhint-disable-line\n  }\n\n  /**\n   * @dev to get the contract staked by a staker\n   * @param _stakerAddress is the address of the staker\n   * @param _stakerIndex is the index of staker\n   * @return the address of staked contract\n   */\n  function getStakerStakedContractByIndex(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  public\n  view\n  returns (address stakedContractAddress)\n  {\n    stakedContractAddress = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakedContractAddress;\n  }\n\n  /**\n   * @dev to get the staker's staked burned\n   * @param _stakerAddress is the address of the staker\n   * @param _stakerIndex is the index of staker\n   * @return amount burned\n   */\n  function getStakerStakedBurnedByIndex(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  public\n  view\n  returns (uint burnedAmount)\n  {\n    burnedAmount = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].burnedAmount;\n  }\n\n  /**\n   * @dev to get the staker's staked unlockable before the last burn\n   * @param _stakerAddress is the address of the staker\n   * @param _stakerIndex is the index of staker\n   * @return unlockable staked tokens\n   */\n  function getStakerStakedUnlockableBeforeLastBurnByIndex(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  public\n  view\n  returns (uint unlockable)\n  {\n    unlockable = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].unLockableBeforeLastBurn;\n  }\n\n  /**\n   * @dev to get the staker's staked contract index\n   * @param _stakerAddress is the address of the staker\n   * @param _stakerIndex is the index of staker\n   * @return is the index of the smart contract address\n   */\n  function getStakerStakedContractIndex(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  public\n  view\n  returns (uint scIndex)\n  {\n    scIndex = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakedContractIndex;\n  }\n\n  /**\n   * @dev to get the staker index of the staked contract\n   * @param _stakedContractAddress is the address of the staked contract\n   * @param _stakedContractIndex is the index of staked contract\n   * @return is the index of the staker\n   */\n  function getStakedContractStakerIndex(\n    address _stakedContractAddress,\n    uint _stakedContractIndex\n  )\n  public\n  view\n  returns (uint sIndex)\n  {\n    sIndex = stakedContractStakers[\n    _stakedContractAddress][_stakedContractIndex].stakerIndex;\n  }\n\n  /**\n   * @dev to get the staker's initial staked amount on the contract\n   * @param _stakerAddress is the address of the staker\n   * @param _stakerIndex is the index of staker\n   * @return staked amount\n   */\n  function getStakerInitialStakedAmountOnContract(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  public\n  view\n  returns (uint amount)\n  {\n    amount = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakeAmount;\n  }\n\n  /**\n   * @dev to get the staker's staked contract length\n   * @param _stakerAddress is the address of the staker\n   * @return length of staked contract\n   */\n  function getStakerStakedContractLength(\n    address _stakerAddress\n  )\n  public\n  view\n  returns (uint length)\n  {\n    length = stakerStakedContracts[_stakerAddress].length;\n  }\n\n  /**\n   * @dev to get the staker's unlocked tokens which were staked\n   * @param _stakerAddress is the address of the staker\n   * @param _stakerIndex is the index of staker\n   * @return amount\n   */\n  function getStakerUnlockedStakedTokens(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  public\n  view\n  returns (uint amount)\n  {\n    amount = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].unlockedAmount;\n  }\n\n  /**\n   * @dev pushes the unlocked staked tokens by a staker.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker to distribute commission.\n   * @param _amount amount to be given as commission.\n   */\n  function pushUnlockedStakedTokens(\n    address _stakerAddress,\n    uint _stakerIndex,\n    uint _amount\n  )\n  public\n  onlyInternal\n  {\n    stakerStakedContracts[_stakerAddress][\n    _stakerIndex].unlockedAmount = stakerStakedContracts[_stakerAddress][\n    _stakerIndex].unlockedAmount.add(_amount);\n  }\n\n  /**\n   * @dev pushes the Burned tokens for a staker.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker.\n   * @param _amount amount to be burned.\n   */\n  function pushBurnedTokens(\n    address _stakerAddress,\n    uint _stakerIndex,\n    uint _amount\n  )\n  public\n  onlyInternal\n  {\n    stakerStakedContracts[_stakerAddress][\n    _stakerIndex].burnedAmount = stakerStakedContracts[_stakerAddress][\n    _stakerIndex].burnedAmount.add(_amount);\n  }\n\n  /**\n   * @dev pushes the unLockable tokens for a staker before last burn.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker.\n   * @param _amount amount to be added to unlockable.\n   */\n  function pushUnlockableBeforeLastBurnTokens(\n    address _stakerAddress,\n    uint _stakerIndex,\n    uint _amount\n  )\n  public\n  onlyInternal\n  {\n    stakerStakedContracts[_stakerAddress][\n    _stakerIndex].unLockableBeforeLastBurn = stakerStakedContracts[_stakerAddress][\n    _stakerIndex].unLockableBeforeLastBurn.add(_amount);\n  }\n\n  /**\n   * @dev sets the unLockable tokens for a staker before last burn.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker.\n   * @param _amount amount to be added to unlockable.\n   */\n  function setUnlockableBeforeLastBurnTokens(\n    address _stakerAddress,\n    uint _stakerIndex,\n    uint _amount\n  )\n  public\n  onlyInternal\n  {\n    stakerStakedContracts[_stakerAddress][\n    _stakerIndex].unLockableBeforeLastBurn = _amount;\n  }\n\n  /**\n   * @dev pushes the earned commission earned by a staker.\n   * @param _stakerAddress address of staker.\n   * @param _stakedContractAddress address of smart contract.\n   * @param _stakedContractIndex index of the staker to distribute commission.\n   * @param _commissionAmount amount to be given as commission.\n   */\n  function pushEarnedStakeCommissions(\n    address _stakerAddress,\n    address _stakedContractAddress,\n    uint _stakedContractIndex,\n    uint _commissionAmount\n  )\n  public\n  onlyInternal\n  {\n    stakedContractStakeCommission[_stakedContractAddress][_stakedContractIndex].\n    commissionEarned = stakedContractStakeCommission[_stakedContractAddress][\n    _stakedContractIndex].commissionEarned.add(_commissionAmount);\n\n    emit Commission(\n      _stakerAddress,\n      _stakedContractAddress,\n      _stakedContractIndex,\n      _commissionAmount\n    );\n  }\n\n  /**\n   * @dev pushes the redeemed commission redeemed by a staker.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker to distribute commission.\n   * @param _amount amount to be given as commission.\n   */\n  function pushRedeemedStakeCommissions(\n    address _stakerAddress,\n    uint _stakerIndex,\n    uint _amount\n  )\n  public\n  onlyInternal\n  {\n    uint stakedContractIndex = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakedContractIndex;\n    address stakedContractAddress = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakedContractAddress;\n    stakedContractStakeCommission[stakedContractAddress][stakedContractIndex].\n    commissionRedeemed = stakedContractStakeCommission[\n    stakedContractAddress][stakedContractIndex].commissionRedeemed.add(_amount);\n  }\n\n  /**\n   * @dev Gets stake commission given to an underwriter\n   * for particular stakedcontract on given index.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker commission.\n   */\n  function getStakerEarnedStakeCommission(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  public\n  view\n  returns (uint)\n  {\n    return _getStakerEarnedStakeCommission(_stakerAddress, _stakerIndex);\n  }\n\n  /**\n   * @dev Gets stake commission redeemed by an underwriter\n   * for particular staked contract on given index.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker commission.\n   * @return commissionEarned total amount given to staker.\n   */\n  function getStakerRedeemedStakeCommission(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  public\n  view\n  returns (uint)\n  {\n    return _getStakerRedeemedStakeCommission(_stakerAddress, _stakerIndex);\n  }\n\n  /**\n   * @dev Gets total stake commission given to an underwriter\n   * @param _stakerAddress address of staker.\n   * @return totalCommissionEarned total commission earned by staker.\n   */\n  function getStakerTotalEarnedStakeCommission(\n    address _stakerAddress\n  )\n  public\n  view\n  returns (uint totalCommissionEarned)\n  {\n    totalCommissionEarned = 0;\n    for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {\n      totalCommissionEarned = totalCommissionEarned.\n      add(_getStakerEarnedStakeCommission(_stakerAddress, i));\n    }\n  }\n\n  /**\n   * @dev Gets total stake commission given to an underwriter\n   * @param _stakerAddress address of staker.\n   * @return totalCommissionEarned total commission earned by staker.\n   */\n  function getStakerTotalReedmedStakeCommission(\n    address _stakerAddress\n  )\n  public\n  view\n  returns (uint totalCommissionRedeemed)\n  {\n    totalCommissionRedeemed = 0;\n    for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {\n      totalCommissionRedeemed = totalCommissionRedeemed.add(\n        _getStakerRedeemedStakeCommission(_stakerAddress, i));\n    }\n  }\n\n  /**\n   * @dev set flag to deposit/ undeposit cover note\n   * against a cover Id\n   * @param coverId coverId of Cover\n   * @param flag true/false for deposit/undeposit\n   */\n  function setDepositCN(uint coverId, bool flag) public onlyInternal {\n\n    if (flag == true) {\n      require(!depositedCN[coverId].isDeposited, \"Cover note already deposited\");\n    }\n\n    depositedCN[coverId].isDeposited = flag;\n  }\n\n  /**\n   * @dev set locked cover note amount\n   * against a cover Id\n   * @param coverId coverId of Cover\n   * @param amount amount of nxm to be locked\n   */\n  function setDepositCNAmount(uint coverId, uint amount) public onlyInternal {\n\n    depositedCN[coverId].amount = amount;\n  }\n\n  /**\n   * @dev to get the staker address on a staked contract\n   * @param _stakedContractAddress is the address of the staked contract in concern\n   * @param _stakedContractIndex is the index of staked contract's index\n   * @return address of staker\n   */\n  function getStakedContractStakerByIndex(\n    address _stakedContractAddress,\n    uint _stakedContractIndex\n  )\n  public\n  view\n  returns (address stakerAddress)\n  {\n    stakerAddress = stakedContractStakers[\n    _stakedContractAddress][_stakedContractIndex].stakerAddress;\n  }\n\n  /**\n   * @dev to get the length of stakers on a staked contract\n   * @param _stakedContractAddress is the address of the staked contract in concern\n   * @return length in concern\n   */\n  function getStakedContractStakersLength(\n    address _stakedContractAddress\n  )\n  public\n  view\n  returns (uint length)\n  {\n    length = stakedContractStakers[_stakedContractAddress].length;\n  }\n\n  /**\n   * @dev Adds a new stake record.\n   * @param _stakerAddress staker address.\n   * @param _stakedContractAddress smart contract address.\n   * @param _amount amountof NXM to be staked.\n   */\n  function addStake(\n    address _stakerAddress,\n    address _stakedContractAddress,\n    uint _amount\n  )\n  public\n  onlyInternal\n  returns (uint scIndex)\n  {\n    scIndex = (stakedContractStakers[_stakedContractAddress].push(\n      Staker(_stakerAddress, stakerStakedContracts[_stakerAddress].length))).sub(1);\n    stakerStakedContracts[_stakerAddress].push(\n      Stake(_stakedContractAddress, scIndex, now, _amount, 0, 0, 0));\n  }\n\n  /**\n   * @dev books the user's tokens for maintaining Assessor Velocity,\n   * i.e. once a token is used to cast a vote as a Claims assessor,\n   * @param _of user's address.\n   */\n  function bookCATokens(address _of) public onlyInternal {\n    require(!isCATokensBooked(_of), \"Tokens already booked\");\n    isBookedTokens[_of] = now.add(bookTime);\n  }\n\n  /**\n   * @dev to know if claim assessor's tokens are booked or not\n   * @param _of is the claim assessor's address in concern\n   * @return boolean representing the status of tokens booked\n   */\n  function isCATokensBooked(address _of) public view returns (bool res) {\n    if (now < isBookedTokens[_of])\n      res = true;\n  }\n\n  /**\n   * @dev Sets the index which will receive commission.\n   * @param _stakedContractAddress smart contract address.\n   * @param _index current index.\n   */\n  function setStakedContractCurrentCommissionIndex(\n    address _stakedContractAddress,\n    uint _index\n  )\n  public\n  onlyInternal\n  {\n    stakedContractCurrentCommissionIndex[_stakedContractAddress] = _index;\n  }\n\n  /**\n   * @dev Sets the last complete commission index\n   * @param _stakerAddress smart contract address.\n   * @param _index current index.\n   */\n  function setLastCompletedStakeCommissionIndex(\n    address _stakerAddress,\n    uint _index\n  )\n  public\n  onlyInternal\n  {\n    lastCompletedStakeCommission[_stakerAddress] = _index;\n  }\n\n  /**\n   * @dev Sets the index till which commission is distrubuted.\n   * @param _stakedContractAddress smart contract address.\n   * @param _index current index.\n   */\n  function setStakedContractCurrentBurnIndex(\n    address _stakedContractAddress,\n    uint _index\n  )\n  public\n  onlyInternal\n  {\n    stakedContractCurrentBurnIndex[_stakedContractAddress] = _index;\n  }\n\n  /**\n   * @dev Updates Uint Parameters of a code\n   * @param code whose details we want to update\n   * @param val value to set\n   */\n  function updateUintParameters(bytes8 code, uint val) public {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    if (code == \"TOKEXP\") {\n\n      _setTokenExponent(val);\n\n    } else if (code == \"TOKSTEP\") {\n\n      _setPriceStep(val);\n\n    } else if (code == \"RALOCKT\") {\n\n      _changeSCValidDays(val);\n\n    } else if (code == \"RACOMM\") {\n\n      _setStakerCommissionPer(val);\n\n    } else if (code == \"RAMAXC\") {\n\n      _setStakerMaxCommissionPer(val);\n\n    } else if (code == \"CABOOKT\") {\n\n      _changeBookTime(val * 1 hours);\n\n    } else if (code == \"CALOCKT\") {\n\n      _changelockCADays(val * 1 days);\n\n    } else if (code == \"MVLOCKT\") {\n\n      _changelockMVDays(val * 1 days);\n\n    } else if (code == \"QUOLOCKT\") {\n\n      _setLockTokenTimeAfterCoverExp(val * 1 days);\n\n    } else if (code == \"JOINFEE\") {\n\n      _setJoiningFee(val);\n\n    } else {\n      revert(\"Invalid param code\");\n    }\n  }\n\n  /**\n   * @dev Internal function to get stake commission given to an\n   * underwriter for particular stakedcontract on given index.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker commission.\n   */\n  function _getStakerEarnedStakeCommission(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  internal\n  view\n  returns (uint amount)\n  {\n    uint _stakedContractIndex;\n    address _stakedContractAddress;\n    _stakedContractAddress = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakedContractAddress;\n    _stakedContractIndex = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakedContractIndex;\n    amount = stakedContractStakeCommission[\n    _stakedContractAddress][_stakedContractIndex].commissionEarned;\n  }\n\n  /**\n   * @dev Internal function to get stake commission redeemed by an\n   * underwriter for particular stakedcontract on given index.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker commission.\n   */\n  function _getStakerRedeemedStakeCommission(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  internal\n  view\n  returns (uint amount)\n  {\n    uint _stakedContractIndex;\n    address _stakedContractAddress;\n    _stakedContractAddress = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakedContractAddress;\n    _stakedContractIndex = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakedContractIndex;\n    amount = stakedContractStakeCommission[\n    _stakedContractAddress][_stakedContractIndex].commissionRedeemed;\n  }\n\n  /**\n   * @dev to set the percentage of staker commission\n   * @param _val is new percentage value\n   */\n  function _setStakerCommissionPer(uint _val) internal {\n    stakerCommissionPer = _val;\n  }\n\n  /**\n   * @dev to set the max percentage of staker commission\n   * @param _val is new percentage value\n   */\n  function _setStakerMaxCommissionPer(uint _val) internal {\n    stakerMaxCommissionPer = _val;\n  }\n\n  /**\n   * @dev to set the token exponent value\n   * @param _val is new value\n   */\n  function _setTokenExponent(uint _val) internal {\n    tokenExponent = _val;\n  }\n\n  /**\n   * @dev to set the price step\n   * @param _val is new value\n   */\n  function _setPriceStep(uint _val) internal {\n    priceStep = _val;\n  }\n\n  /**\n   * @dev Changes number of days for which NXM needs to staked in case of underwriting\n   */\n  function _changeSCValidDays(uint _days) internal {\n    scValidDays = _days;\n  }\n\n  /**\n   * @dev Changes the time period up to which tokens will be locked.\n   *      Used to generate the validity period of tokens booked by\n   *      a user for participating in claim's assessment/claim's voting.\n   */\n  function _changeBookTime(uint _time) internal {\n    bookTime = _time;\n  }\n\n  /**\n   * @dev Changes lock CA days - number of days for which tokens\n   * are locked while submitting a vote.\n   */\n  function _changelockCADays(uint _val) internal {\n    lockCADays = _val;\n  }\n\n  /**\n   * @dev Changes lock MV days - number of days for which tokens are locked\n   * while submitting a vote.\n   */\n  function _changelockMVDays(uint _val) internal {\n    lockMVDays = _val;\n  }\n\n  /**\n   * @dev Changes extra lock period for a cover, post its expiry.\n   */\n  function _setLockTokenTimeAfterCoverExp(uint time) internal {\n    lockTokenTimeAfterCoverExp = time;\n  }\n\n  /**\n   * @dev Set the joining fee for membership\n   */\n  function _setJoiningFee(uint _amount) internal {\n    joiningFee = _amount;\n  }\n}\n"
60     },
61     "contracts/modules/token/TokenFunctions.sol": {
62       "content": "/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../interfaces/IPooledStaking.sol\";\nimport \"../cover/QuotationData.sol\";\nimport \"./NXMToken.sol\";\nimport \"./TokenController.sol\";\nimport \"./TokenData.sol\";\n\ncontract TokenFunctions is Iupgradable {\n  using SafeMath for uint;\n\n  NXMToken public tk;\n  TokenController public tc;\n  TokenData public td;\n  QuotationData public qd;\n  IPooledStaking public pooledStaking;\n\n  event BurnCATokens(uint claimId, address addr, uint amount);\n\n  /**\n   * @dev Rewards stakers on purchase of cover on smart contract.\n   * @param _contractAddress smart contract address.\n   * @param _coverPriceNXM cover price in NXM.\n   */\n  function pushStakerRewards(address _contractAddress, uint _coverPriceNXM) external onlyInternal {\n    uint rewardValue = _coverPriceNXM.mul(td.stakerCommissionPer()).div(100);\n    pooledStaking.accumulateReward(_contractAddress, rewardValue);\n  }\n\n  /**\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\n   * @param _of address of the coverHolder.\n   * @param _coverId coverId of the cover.\n   */\n  function getUserLockedCNTokens(address _of, uint _coverId) external view returns (uint) {\n    return _getUserLockedCNTokens(_of, _coverId);\n  }\n\n  /**\n   * @dev to get the all the cover locked tokens of a user\n   * @param _of is the user address in concern\n   * @return amount locked\n   */\n  function getUserAllLockedCNTokens(address _of) external view returns (uint amount) {\n    for (uint i = 0; i < qd.getUserCoverLength(_of); i++) {\n      amount = amount.add(_getUserLockedCNTokens(_of, qd.getAllCoversOfUser(_of)[i]));\n    }\n  }\n\n  /**\n   * @dev Returns amount of NXM Tokens locked as Cover Note against given coverId.\n   * @param _coverId coverId of the cover.\n   */\n  function getLockedCNAgainstCover(uint _coverId) external view returns (uint) {\n    return _getLockedCNAgainstCover(_coverId);\n  }\n\n  /**\n   * @dev Change Dependent Contract Address\n   */\n  function changeDependentContractAddress() public {\n    tk = NXMToken(ms.tokenAddress());\n    td = TokenData(ms.getLatestAddress(\"TD\"));\n    tc = TokenController(ms.getLatestAddress(\"TC\"));\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\"PS\"));\n  }\n\n  /**\n   * @dev Set the flag to check if cover note is deposited against the cover id\n   * @param coverId Cover Id.\n   */\n  function depositCN(uint coverId) public onlyInternal returns (bool success) {\n    require(_getLockedCNAgainstCover(coverId) > 0, \"No cover note available\");\n    td.setDepositCN(coverId, true);\n    success = true;\n  }\n\n  /**\n   * @param _of address of Member\n   * @param _coverId Cover Id\n   * @param _lockTime Pending Time + Cover Period 7*1 days\n   */\n  function extendCNEPOff(address _of, uint _coverId, uint _lockTime) public onlyInternal {\n    uint timeStamp = now.add(_lockTime);\n    uint coverValidUntil = qd.getValidityOfCover(_coverId);\n    if (timeStamp >= coverValidUntil) {\n      bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, _coverId));\n      tc.extendLockOf(_of, reason, timeStamp);\n    }\n  }\n\n  /**\n   * @dev to burn the deposited cover tokens\n   * @param coverId is id of cover whose tokens have to be burned\n   * @return the status of the successful burning\n   */\n  function burnDepositCN(uint coverId) public onlyInternal returns (bool success) {\n    address _of = qd.getCoverMemberAddress(coverId);\n    uint amount;\n    (amount,) = td.depositedCN(coverId);\n    amount = (amount.mul(50)).div(100);\n    bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, coverId));\n    tc.burnLockedTokens(_of, reason, amount);\n    success = true;\n  }\n\n  /**\n   * @dev Unlocks covernote locked against a given cover\n   * @param coverId id of cover\n   */\n  function unlockCN(uint coverId) public onlyInternal {\n    (, bool isDeposited) = td.depositedCN(coverId);\n    require(!isDeposited, \"Cover note is deposited and can not be released\");\n    uint lockedCN = _getLockedCNAgainstCover(coverId);\n    if (lockedCN != 0) {\n      address coverHolder = qd.getCoverMemberAddress(coverId);\n      bytes32 reason = keccak256(abi.encodePacked(\"CN\", coverHolder, coverId));\n      tc.releaseLockedTokens(coverHolder, reason, lockedCN);\n    }\n  }\n\n  /**\n   * @dev Burns tokens used for fraudulent voting against a claim\n   * @param claimid Claim Id.\n   * @param _value number of tokens to be burned\n   * @param _of Claim Assessor's address.\n   */\n  function burnCAToken(uint claimid, uint _value, address _of) public {\n\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    tc.burnLockedTokens(_of, \"CLA\", _value);\n    emit BurnCATokens(claimid, _of, _value);\n  }\n\n  /**\n   * @dev to lock cover note tokens\n   * @param coverNoteAmount is number of tokens to be locked\n   * @param coverPeriod is cover period in concern\n   * @param coverId is the cover id of cover in concern\n   * @param _of address whose tokens are to be locked\n   */\n  function lockCN(\n    uint coverNoteAmount,\n    uint coverPeriod,\n    uint coverId,\n    address _of\n  )\n  public\n  onlyInternal\n  {\n    uint validity = (coverPeriod * 1 days).add(td.lockTokenTimeAfterCoverExp());\n    bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, coverId));\n    td.setDepositCNAmount(coverId, coverNoteAmount);\n    tc.lockOf(_of, reason, coverNoteAmount, validity);\n  }\n\n  /**\n   * @dev to check if a  member is locked for member vote\n   * @param _of is the member address in concern\n   * @return the boolean status\n   */\n  function isLockedForMemberVote(address _of) public view returns (bool) {\n    return now < tk.isLockedForMV(_of);\n  }\n\n  /**\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\n   * @param _coverId coverId of the cover.\n   */\n  function _getLockedCNAgainstCover(uint _coverId) internal view returns (uint) {\n    address coverHolder = qd.getCoverMemberAddress(_coverId);\n    bytes32 reason = keccak256(abi.encodePacked(\"CN\", coverHolder, _coverId));\n    return tc.tokensLockedAtTime(coverHolder, reason, now);\n  }\n\n  /**\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\n   * @param _of address of the coverHolder.\n   * @param _coverId coverId of the cover.\n   */\n  function _getUserLockedCNTokens(address _of, uint _coverId) internal view returns (uint) {\n    bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, _coverId));\n    return tc.tokensLockedAtTime(_of, reason, now);\n  }\n}\n"
63     },
64     "contracts/modules/cover/QuotationData.sol": {
65       "content": "/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../abstract/Iupgradable.sol\";\n\ncontract QuotationData is Iupgradable {\n  using SafeMath for uint;\n\n  enum HCIDStatus {NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover}\n\n  enum CoverStatus {Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested}\n\n  struct Cover {\n    address payable memberAddress;\n    bytes4 currencyCode;\n    uint sumAssured;\n    uint16 coverPeriod;\n    uint validUntil;\n    address scAddress;\n    uint premiumNXM;\n  }\n\n  struct HoldCover {\n    uint holdCoverId;\n    address payable userAddress;\n    address scAddress;\n    bytes4 coverCurr;\n    uint[] coverDetails;\n    uint16 coverPeriod;\n  }\n\n  address public authQuoteEngine;\n\n  mapping(bytes4 => uint) internal currencyCSA;\n  mapping(address => uint[]) internal userCover;\n  mapping(address => uint[]) public userHoldedCover;\n  mapping(address => bool) public refundEligible;\n  mapping(address => mapping(bytes4 => uint)) internal currencyCSAOfSCAdd;\n  mapping(uint => uint8) public coverStatus;\n  mapping(uint => uint) public holdedCoverIDStatus;\n  mapping(uint => bool) public timestampRepeated;\n\n\n  Cover[] internal allCovers;\n  HoldCover[] internal allCoverHolded;\n\n  uint public stlp;\n  uint public stl;\n  uint public pm;\n  uint public minDays;\n  uint public tokensRetained;\n  address public kycAuthAddress;\n\n  event CoverDetailsEvent(\n    uint indexed cid,\n    address scAdd,\n    uint sumAssured,\n    uint expiry,\n    uint premium,\n    uint premiumNXM,\n    bytes4 curr\n  );\n\n  event CoverStatusEvent(uint indexed cid, uint8 statusNum);\n\n  constructor(address _authQuoteAdd, address _kycAuthAdd) public {\n    authQuoteEngine = _authQuoteAdd;\n    kycAuthAddress = _kycAuthAdd;\n    stlp = 90;\n    stl = 100;\n    pm = 30;\n    minDays = 30;\n    tokensRetained = 10;\n    allCovers.push(Cover(address(0), \"0x00\", 0, 0, 0, address(0), 0));\n    uint[] memory arr = new uint[](1);\n    allCoverHolded.push(HoldCover(0, address(0), address(0), 0x00, arr, 0));\n\n  }\n\n  /// @dev Adds the amount in Total Sum Assured of a given currency of a given smart contract address.\n  /// @param _add Smart Contract Address.\n  /// @param _amount Amount to be added.\n  function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\n    currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].add(_amount);\n  }\n\n  /// @dev Subtracts the amount from Total Sum Assured of a given currency and smart contract address.\n  /// @param _add Smart Contract Address.\n  /// @param _amount Amount to be subtracted.\n  function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\n    currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].sub(_amount);\n  }\n\n  /// @dev Subtracts the amount from Total Sum Assured of a given currency.\n  /// @param _curr Currency Name.\n  /// @param _amount Amount to be subtracted.\n  function subFromTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\n    currencyCSA[_curr] = currencyCSA[_curr].sub(_amount);\n  }\n\n  /// @dev Adds the amount in Total Sum Assured of a given currency.\n  /// @param _curr Currency Name.\n  /// @param _amount Amount to be added.\n  function addInTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\n    currencyCSA[_curr] = currencyCSA[_curr].add(_amount);\n  }\n\n  /// @dev sets bit for timestamp to avoid replay attacks.\n  function setTimestampRepeated(uint _timestamp) external onlyInternal {\n    timestampRepeated[_timestamp] = true;\n  }\n\n  /// @dev Creates a blank new cover.\n  function addCover(\n    uint16 _coverPeriod,\n    uint _sumAssured,\n    address payable _userAddress,\n    bytes4 _currencyCode,\n    address _scAddress,\n    uint premium,\n    uint premiumNXM\n  )\n  external\n  onlyInternal\n  {\n    uint expiryDate = now.add(uint(_coverPeriod).mul(1 days));\n    allCovers.push(Cover(_userAddress, _currencyCode,\n      _sumAssured, _coverPeriod, expiryDate, _scAddress, premiumNXM));\n    uint cid = allCovers.length.sub(1);\n    userCover[_userAddress].push(cid);\n    emit CoverDetailsEvent(cid, _scAddress, _sumAssured, expiryDate, premium, premiumNXM, _currencyCode);\n  }\n\n  /// @dev create holded cover which will process after verdict of KYC.\n  function addHoldCover(\n    address payable from,\n    address scAddress,\n    bytes4 coverCurr,\n    uint[] calldata coverDetails,\n    uint16 coverPeriod\n  )\n  external\n  onlyInternal\n  {\n    uint holdedCoverLen = allCoverHolded.length;\n    holdedCoverIDStatus[holdedCoverLen] = uint(HCIDStatus.kycPending);\n    allCoverHolded.push(HoldCover(holdedCoverLen, from, scAddress,\n      coverCurr, coverDetails, coverPeriod));\n    userHoldedCover[from].push(allCoverHolded.length.sub(1));\n\n  }\n\n  ///@dev sets refund eligible bit.\n  ///@param _add user address.\n  ///@param status indicates if user have pending kyc.\n  function setRefundEligible(address _add, bool status) external onlyInternal {\n    refundEligible[_add] = status;\n  }\n\n  /// @dev to set current status of particular holded coverID (1 for not completed KYC,\n  /// 2 for KYC passed, 3 for failed KYC or full refunded,\n  /// 4 for KYC completed but cover not processed)\n  function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external onlyInternal {\n    holdedCoverIDStatus[holdedCoverID] = status;\n  }\n\n  /**\n   * @dev to set address of kyc authentication\n   * @param _add is the new address\n   */\n  function setKycAuthAddress(address _add) external onlyInternal {\n    kycAuthAddress = _add;\n  }\n\n  /// @dev Changes authorised address for generating quote off chain.\n  function changeAuthQuoteEngine(address _add) external onlyInternal {\n    authQuoteEngine = _add;\n  }\n\n  /**\n   * @dev Gets Uint Parameters of a code\n   * @param code whose details we want\n   * @return string value of the code\n   * @return associated amount (time or perc or value) to the code\n   */\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\n    codeVal = code;\n\n    if (code == \"STLP\") {\n      val = stlp;\n\n    } else if (code == \"STL\") {\n\n      val = stl;\n\n    } else if (code == \"PM\") {\n\n      val = pm;\n\n    } else if (code == \"QUOMIND\") {\n\n      val = minDays;\n\n    } else if (code == \"QUOTOK\") {\n\n      val = tokensRetained;\n\n    }\n\n  }\n\n  /// @dev Gets Product details.\n  /// @return  _minDays minimum cover period.\n  /// @return  _PM Profit margin.\n  /// @return  _STL short term Load.\n  /// @return  _STLP short term load period.\n  function getProductDetails()\n  external\n  view\n  returns (\n    uint _minDays,\n    uint _pm,\n    uint _stl,\n    uint _stlp\n  )\n  {\n\n    _minDays = minDays;\n    _pm = pm;\n    _stl = stl;\n    _stlp = stlp;\n  }\n\n  /// @dev Gets total number covers created till date.\n  function getCoverLength() external view returns (uint len) {\n    return (allCovers.length);\n  }\n\n  /// @dev Gets Authorised Engine address.\n  function getAuthQuoteEngine() external view returns (address _add) {\n    _add = authQuoteEngine;\n  }\n\n  /// @dev Gets the Total Sum Assured amount of a given currency.\n  function getTotalSumAssured(bytes4 _curr) external view returns (uint amount) {\n    amount = currencyCSA[_curr];\n  }\n\n  /// @dev Gets all the Cover ids generated by a given address.\n  /// @param _add User's address.\n  /// @return allCover array of covers.\n  function getAllCoversOfUser(address _add) external view returns (uint[] memory allCover) {\n    return (userCover[_add]);\n  }\n\n  /// @dev Gets total number of covers generated by a given address\n  function getUserCoverLength(address _add) external view returns (uint len) {\n    len = userCover[_add].length;\n  }\n\n  /// @dev Gets the status of a given cover.\n  function getCoverStatusNo(uint _cid) external view returns (uint8) {\n    return coverStatus[_cid];\n  }\n\n  /// @dev Gets the Cover Period (in days) of a given cover.\n  function getCoverPeriod(uint _cid) external view returns (uint32 cp) {\n    cp = allCovers[_cid].coverPeriod;\n  }\n\n  /// @dev Gets the Sum Assured Amount of a given cover.\n  function getCoverSumAssured(uint _cid) external view returns (uint sa) {\n    sa = allCovers[_cid].sumAssured;\n  }\n\n  /// @dev Gets the Currency Name in which a given cover is assured.\n  function getCurrencyOfCover(uint _cid) external view returns (bytes4 curr) {\n    curr = allCovers[_cid].currencyCode;\n  }\n\n  /// @dev Gets the validity date (timestamp) of a given cover.\n  function getValidityOfCover(uint _cid) external view returns (uint date) {\n    date = allCovers[_cid].validUntil;\n  }\n\n  /// @dev Gets Smart contract address of cover.\n  function getscAddressOfCover(uint _cid) external view returns (uint, address) {\n    return (_cid, allCovers[_cid].scAddress);\n  }\n\n  /// @dev Gets the owner address of a given cover.\n  function getCoverMemberAddress(uint _cid) external view returns (address payable _add) {\n    _add = allCovers[_cid].memberAddress;\n  }\n\n  /// @dev Gets the premium amount of a given cover in NXM.\n  function getCoverPremiumNXM(uint _cid) external view returns (uint _premiumNXM) {\n    _premiumNXM = allCovers[_cid].premiumNXM;\n  }\n\n  /// @dev Provides the details of a cover Id\n  /// @param _cid cover Id\n  /// @return memberAddress cover user address.\n  /// @return scAddress smart contract Address\n  /// @return currencyCode currency of cover\n  /// @return sumAssured sum assured of cover\n  /// @return premiumNXM premium in NXM\n  function getCoverDetailsByCoverID1(\n    uint _cid\n  )\n  external\n  view\n  returns (\n    uint cid,\n    address _memberAddress,\n    address _scAddress,\n    bytes4 _currencyCode,\n    uint _sumAssured,\n    uint premiumNXM\n  )\n  {\n    return (\n    _cid,\n    allCovers[_cid].memberAddress,\n    allCovers[_cid].scAddress,\n    allCovers[_cid].currencyCode,\n    allCovers[_cid].sumAssured,\n    allCovers[_cid].premiumNXM\n    );\n  }\n\n  /// @dev Provides details of a cover Id\n  /// @param _cid cover Id\n  /// @return status status of cover.\n  /// @return sumAssured Sum assurance of cover.\n  /// @return coverPeriod Cover Period of cover (in days).\n  /// @return validUntil is validity of cover.\n  function getCoverDetailsByCoverID2(\n    uint _cid\n  )\n  external\n  view\n  returns (\n    uint cid,\n    uint8 status,\n    uint sumAssured,\n    uint16 coverPeriod,\n    uint validUntil\n  )\n  {\n\n    return (\n    _cid,\n    coverStatus[_cid],\n    allCovers[_cid].sumAssured,\n    allCovers[_cid].coverPeriod,\n    allCovers[_cid].validUntil\n    );\n  }\n\n  /// @dev Provides details of a holded cover Id\n  /// @param _hcid holded cover Id\n  /// @return scAddress SmartCover address of cover.\n  /// @return coverCurr currency of cover.\n  /// @return coverPeriod Cover Period of cover (in days).\n  function getHoldedCoverDetailsByID1(\n    uint _hcid\n  )\n  external\n  view\n  returns (\n    uint hcid,\n    address scAddress,\n    bytes4 coverCurr,\n    uint16 coverPeriod\n  )\n  {\n    return (\n    _hcid,\n    allCoverHolded[_hcid].scAddress,\n    allCoverHolded[_hcid].coverCurr,\n    allCoverHolded[_hcid].coverPeriod\n    );\n  }\n\n  /// @dev Gets total number holded covers created till date.\n  function getUserHoldedCoverLength(address _add) external view returns (uint) {\n    return userHoldedCover[_add].length;\n  }\n\n  /// @dev Gets holded cover index by index of user holded covers.\n  function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint) {\n    return userHoldedCover[_add][index];\n  }\n\n  /// @dev Provides the details of a holded cover Id\n  /// @param _hcid holded cover Id\n  /// @return memberAddress holded cover user address.\n  /// @return coverDetails array contains SA, Cover Currency Price,Price in NXM, Expiration time of Qoute.\n  function getHoldedCoverDetailsByID2(\n    uint _hcid\n  )\n  external\n  view\n  returns (\n    uint hcid,\n    address payable memberAddress,\n    uint[] memory coverDetails\n  )\n  {\n    return (\n    _hcid,\n    allCoverHolded[_hcid].userAddress,\n    allCoverHolded[_hcid].coverDetails\n    );\n  }\n\n  /// @dev Gets the Total Sum Assured amount of a given currency and smart contract address.\n  function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns (uint amount) {\n    amount = currencyCSAOfSCAdd[_add][_curr];\n  }\n\n  //solhint-disable-next-line\n  function changeDependentContractAddress() public {}\n\n  /// @dev Changes the status of a given cover.\n  /// @param _cid cover Id.\n  /// @param _stat New status.\n  function changeCoverStatusNo(uint _cid, uint8 _stat) public onlyInternal {\n    coverStatus[_cid] = _stat;\n    emit CoverStatusEvent(_cid, _stat);\n  }\n\n  /**\n   * @dev Updates Uint Parameters of a code\n   * @param code whose details we want to update\n   * @param val value to set\n   */\n  function updateUintParameters(bytes8 code, uint val) public {\n\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    if (code == \"STLP\") {\n      _changeSTLP(val);\n\n    } else if (code == \"STL\") {\n\n      _changeSTL(val);\n\n    } else if (code == \"PM\") {\n\n      _changePM(val);\n\n    } else if (code == \"QUOMIND\") {\n\n      _changeMinDays(val);\n\n    } else if (code == \"QUOTOK\") {\n\n      _setTokensRetained(val);\n\n    } else {\n\n      revert(\"Invalid param code\");\n    }\n\n  }\n\n  /// @dev Changes the existing Profit Margin value\n  function _changePM(uint _pm) internal {\n    pm = _pm;\n  }\n\n  /// @dev Changes the existing Short Term Load Period (STLP) value.\n  function _changeSTLP(uint _stlp) internal {\n    stlp = _stlp;\n  }\n\n  /// @dev Changes the existing Short Term Load (STL) value.\n  function _changeSTL(uint _stl) internal {\n    stl = _stl;\n  }\n\n  /// @dev Changes the existing Minimum cover period (in days)\n  function _changeMinDays(uint _days) internal {\n    minDays = _days;\n  }\n\n  /**\n   * @dev to set the the amount of tokens retained\n   * @param val is the amount retained\n   */\n  function _setTokensRetained(uint val) internal {\n    tokensRetained = val;\n  }\n}\n"
66     },
67     "contracts/modules/governance/ProposalCategory.sol": {
68       "content": "/* Copyright (C) 2017 GovBlocks.io\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\npragma solidity ^0.5.0;\n\nimport \"../../abstract/Iupgradable.sol\";\nimport \"./MemberRoles.sol\";\nimport \"./external/Governed.sol\";\nimport \"./external/IProposalCategory.sol\";\n\ncontract ProposalCategory is Governed, IProposalCategory, Iupgradable {\n\n  bool public constructorCheck;\n  MemberRoles internal mr;\n\n  struct CategoryStruct {\n    uint memberRoleToVote;\n    uint majorityVotePerc;\n    uint quorumPerc;\n    uint[] allowedToCreateProposal;\n    uint closingTime;\n    uint minStake;\n  }\n\n  struct CategoryAction {\n    uint defaultIncentive;\n    address contractAddress;\n    bytes2 contractName;\n  }\n\n  CategoryStruct[] internal allCategory;\n  mapping(uint => CategoryAction) internal categoryActionData;\n  mapping(uint => uint) public categoryABReq;\n  mapping(uint => uint) public isSpecialResolution;\n  mapping(uint => bytes) public categoryActionHashes;\n\n  bool public categoryActionHashUpdated;\n\n  /**\n  * @dev Adds new category (Discontinued, moved functionality to newCategory)\n  * @param _name Category name\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\n  * @param _closingTime Vote closing time for Each voting layer\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\n  * @param _contractAddress address of contract to call after proposal is accepted\n  * @param _contractName name of contract to be called after proposal is accepted\n  * @param _incentives rewards to distributed after proposal is accepted\n  */\n  function addCategory(\n    string calldata _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] calldata _allowedToCreateProposal,\n    uint _closingTime,\n    string calldata _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] calldata _incentives\n  ) external {}\n\n  /**\n  * @dev Initiates Default settings for Proposal Category contract (Adding default categories)\n  */\n  function proposalCategoryInitiate() external {}\n\n  /**\n  * @dev Initiates Default action function hashes for existing categories\n  * To be called after the contract has been upgraded by governance\n  */\n  function updateCategoryActionHashes() external onlyOwner {\n\n    require(!categoryActionHashUpdated, \"Category action hashes already updated\");\n    categoryActionHashUpdated = true;\n    categoryActionHashes[1] = abi.encodeWithSignature(\"addRole(bytes32,string,address)\");\n    categoryActionHashes[2] = abi.encodeWithSignature(\"updateRole(address,uint256,bool)\");\n    categoryActionHashes[3] = abi.encodeWithSignature(\"newCategory(string,uint256,uint256,uint256,uint256[],uint256,string,address,bytes2,uint256[],string)\"); // solhint-disable-line\n    categoryActionHashes[4] = abi.encodeWithSignature(\"editCategory(uint256,string,uint256,uint256,uint256,uint256[],uint256,string,address,bytes2,uint256[],string)\"); // solhint-disable-line\n    categoryActionHashes[5] = abi.encodeWithSignature(\"upgradeContractImplementation(bytes2,address)\");\n    categoryActionHashes[6] = abi.encodeWithSignature(\"startEmergencyPause()\");\n    categoryActionHashes[7] = abi.encodeWithSignature(\"addEmergencyPause(bool,bytes4)\");\n    categoryActionHashes[8] = abi.encodeWithSignature(\"burnCAToken(uint256,uint256,address)\");\n    categoryActionHashes[9] = abi.encodeWithSignature(\"setUserClaimVotePausedOn(address)\");\n    categoryActionHashes[12] = abi.encodeWithSignature(\"transferEther(uint256,address)\");\n    categoryActionHashes[13] = abi.encodeWithSignature(\"addInvestmentAssetCurrency(bytes4,address,bool,uint64,uint64,uint8)\"); // solhint-disable-line\n    categoryActionHashes[14] = abi.encodeWithSignature(\"changeInvestmentAssetHoldingPerc(bytes4,uint64,uint64)\");\n    categoryActionHashes[15] = abi.encodeWithSignature(\"changeInvestmentAssetStatus(bytes4,bool)\");\n    categoryActionHashes[16] = abi.encodeWithSignature(\"swapABMember(address,address)\");\n    categoryActionHashes[17] = abi.encodeWithSignature(\"addCurrencyAssetCurrency(bytes4,address,uint256)\");\n    categoryActionHashes[20] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\n    categoryActionHashes[21] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\n    categoryActionHashes[22] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\n    categoryActionHashes[23] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\n    categoryActionHashes[24] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\n    categoryActionHashes[25] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\n    categoryActionHashes[26] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\n    categoryActionHashes[27] = abi.encodeWithSignature(\"updateAddressParameters(bytes8,address)\");\n    categoryActionHashes[28] = abi.encodeWithSignature(\"updateOwnerParameters(bytes8,address)\");\n    categoryActionHashes[29] = abi.encodeWithSignature(\"upgradeMultipleContracts(bytes2[],address[])\");\n    categoryActionHashes[30] = abi.encodeWithSignature(\"changeCurrencyAssetAddress(bytes4,address)\");\n    categoryActionHashes[31] = abi.encodeWithSignature(\"changeCurrencyAssetBaseMin(bytes4,uint256)\");\n    categoryActionHashes[32] = abi.encodeWithSignature(\"changeInvestmentAssetAddressAndDecimal(bytes4,address,uint8)\"); // solhint-disable-line\n    categoryActionHashes[33] = abi.encodeWithSignature(\"externalLiquidityTrade()\");\n  }\n\n  /**\n  * @dev Gets Total number of categories added till now\n  */\n  function totalCategories() external view returns (uint) {\n    return allCategory.length;\n  }\n\n  /**\n  * @dev Gets category details\n  */\n  function category(uint _categoryId) external view returns (uint, uint, uint, uint, uint[] memory, uint, uint) {\n    return (\n    _categoryId,\n    allCategory[_categoryId].memberRoleToVote,\n    allCategory[_categoryId].majorityVotePerc,\n    allCategory[_categoryId].quorumPerc,\n    allCategory[_categoryId].allowedToCreateProposal,\n    allCategory[_categoryId].closingTime,\n    allCategory[_categoryId].minStake\n    );\n  }\n\n  /**\n  * @dev Gets category ab required and isSpecialResolution\n  * @return the category id\n  * @return if AB voting is required\n  * @return is category a special resolution\n  */\n  function categoryExtendedData(uint _categoryId) external view returns (uint, uint, uint) {\n    return (\n    _categoryId,\n    categoryABReq[_categoryId],\n    isSpecialResolution[_categoryId]\n    );\n  }\n\n  /**\n   * @dev Gets the category acion details\n   * @param _categoryId is the category id in concern\n   * @return the category id\n   * @return the contract address\n   * @return the contract name\n   * @return the default incentive\n   */\n  function categoryAction(uint _categoryId) external view returns (uint, address, bytes2, uint) {\n\n    return (\n    _categoryId,\n    categoryActionData[_categoryId].contractAddress,\n    categoryActionData[_categoryId].contractName,\n    categoryActionData[_categoryId].defaultIncentive\n    );\n  }\n\n  /**\n   * @dev Gets the category acion details of a category id\n   * @param _categoryId is the category id in concern\n   * @return the category id\n   * @return the contract address\n   * @return the contract name\n   * @return the default incentive\n   * @return action function hash\n   */\n  function categoryActionDetails(uint _categoryId) external view returns (uint, address, bytes2, uint, bytes memory) {\n    return (\n    _categoryId,\n    categoryActionData[_categoryId].contractAddress,\n    categoryActionData[_categoryId].contractName,\n    categoryActionData[_categoryId].defaultIncentive,\n    categoryActionHashes[_categoryId]\n    );\n  }\n\n  /**\n  * @dev Updates dependant contract addresses\n  */\n  function changeDependentContractAddress() public {\n    mr = MemberRoles(ms.getLatestAddress(\"MR\"));\n  }\n\n  /**\n  * @dev Adds new category\n  * @param _name Category name\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\n  * @param _closingTime Vote closing time for Each voting layer\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\n  * @param _contractAddress address of contract to call after proposal is accepted\n  * @param _contractName name of contract to be called after proposal is accepted\n  * @param _incentives rewards to distributed after proposal is accepted\n  * @param _functionHash function signature to be executed\n  */\n  function newCategory(\n    string memory _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] memory _allowedToCreateProposal,\n    uint _closingTime,\n    string memory _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] memory _incentives,\n    string memory _functionHash\n  )\n  public\n  onlyAuthorizedToGovern\n  {\n\n    require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n    require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n    require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n    //If category is special resolution role authorized should be member\n    if (_incentives[3] == 1) {\n      require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n      _majorityVotePerc = 0;\n      _quorumPerc = 0;\n    }\n\n    _addCategory(\n      _name,\n      _memberRoleToVote,\n      _majorityVotePerc,\n      _quorumPerc,\n      _allowedToCreateProposal,\n      _closingTime,\n      _actionHash,\n      _contractAddress,\n      _contractName,\n      _incentives\n    );\n\n\n    if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n      categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);\n    }\n  }\n\n  /**\n   * @dev Changes the master address and update it's instance\n   * @param _masterAddress is the new master address\n   */\n  function changeMasterAddress(address _masterAddress) public {\n    if (masterAddress != address(0))\n      require(masterAddress == msg.sender);\n    masterAddress = _masterAddress;\n    ms = INXMMaster(_masterAddress);\n    nxMasterAddress = _masterAddress;\n\n  }\n\n  /**\n  * @dev Updates category details (Discontinued, moved functionality to editCategory)\n  * @param _categoryId Category id that needs to be updated\n  * @param _name Category name\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\n  * @param _closingTime Vote closing time for Each voting layer\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\n  * @param _contractAddress address of contract to call after proposal is accepted\n  * @param _contractName name of contract to be called after proposal is accepted\n  * @param _incentives rewards to distributed after proposal is accepted\n  */\n  function updateCategory(\n    uint _categoryId,\n    string memory _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] memory _allowedToCreateProposal,\n    uint _closingTime,\n    string memory _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] memory _incentives\n  ) public {}\n\n  /**\n  * @dev Updates category details\n  * @param _categoryId Category id that needs to be updated\n  * @param _name Category name\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\n  * @param _closingTime Vote closing time for Each voting layer\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\n  * @param _contractAddress address of contract to call after proposal is accepted\n  * @param _contractName name of contract to be called after proposal is accepted\n  * @param _incentives rewards to distributed after proposal is accepted\n  * @param _functionHash function signature to be executed\n  */\n  function editCategory(\n    uint _categoryId,\n    string memory _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] memory _allowedToCreateProposal,\n    uint _closingTime,\n    string memory _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] memory _incentives,\n    string memory _functionHash\n  )\n  public\n  onlyAuthorizedToGovern\n  {\n    require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\n\n    require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n    require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n    require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n    //If category is special resolution role authorized should be member\n    if (_incentives[3] == 1) {\n      require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n      _majorityVotePerc = 0;\n      _quorumPerc = 0;\n    }\n\n    delete categoryActionHashes[_categoryId];\n    if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n      categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);\n    }\n    allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\n    allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\n    allCategory[_categoryId].closingTime = _closingTime;\n    allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\n    allCategory[_categoryId].minStake = _incentives[0];\n    allCategory[_categoryId].quorumPerc = _quorumPerc;\n    categoryActionData[_categoryId].defaultIncentive = _incentives[1];\n    categoryActionData[_categoryId].contractName = _contractName;\n    categoryActionData[_categoryId].contractAddress = _contractAddress;\n    categoryABReq[_categoryId] = _incentives[2];\n    isSpecialResolution[_categoryId] = _incentives[3];\n    emit Category(_categoryId, _name, _actionHash);\n  }\n\n  /**\n  * @dev Internal call to add new category\n  * @param _name Category name\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\n  * @param _closingTime Vote closing time for Each voting layer\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\n  * @param _contractAddress address of contract to call after proposal is accepted\n  * @param _contractName name of contract to be called after proposal is accepted\n  * @param _incentives rewards to distributed after proposal is accepted\n  */\n  function _addCategory(\n    string memory _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] memory _allowedToCreateProposal,\n    uint _closingTime,\n    string memory _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] memory _incentives\n  )\n  internal\n  {\n    require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\n    allCategory.push(\n      CategoryStruct(\n        _memberRoleToVote,\n        _majorityVotePerc,\n        _quorumPerc,\n        _allowedToCreateProposal,\n        _closingTime,\n        _incentives[0]\n      )\n    );\n    uint categoryId = allCategory.length - 1;\n    categoryActionData[categoryId] = CategoryAction(_incentives[1], _contractAddress, _contractName);\n    categoryABReq[categoryId] = _incentives[2];\n    isSpecialResolution[categoryId] = _incentives[3];\n    emit Category(categoryId, _name, _actionHash);\n  }\n\n  /**\n  * @dev Internal call to check if given roles are valid or not\n  */\n  function _verifyMemberRoles(uint _memberRoleToVote, uint[] memory _allowedToCreateProposal)\n  internal view returns (uint) {\n    uint totalRoles = mr.totalRoles();\n    if (_memberRoleToVote >= totalRoles) {\n      return 0;\n    }\n    for (uint i = 0; i < _allowedToCreateProposal.length; i++) {\n      if (_allowedToCreateProposal[i] >= totalRoles) {\n        return 0;\n      }\n    }\n    return 1;\n  }\n\n}\n"
69     },
70     "contracts/modules/token/external/OZIERC20.sol": {
71       "content": "pragma solidity ^0.5.0;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface OZIERC20 {\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function approve(address spender, uint256 value)\n  external returns (bool);\n\n  function transferFrom(address from, address to, uint256 value)\n  external returns (bool);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address who) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external view returns (uint256);\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n"
72     },
73     "contracts/modules/token/external/OZSafeMath.sol": {
74       "content": "pragma solidity ^0.5.0;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary OZSafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n"
75     },
76     "contracts/abstract/Iupgradable.sol": {
77       "content": "pragma solidity ^0.5.0;\n\nimport \"./INXMMaster.sol\";\n\ncontract Iupgradable {\n\n  INXMMaster public ms;\n  address public nxMasterAddress;\n\n  modifier onlyInternal {\n    require(ms.isInternal(msg.sender));\n    _;\n  }\n\n  modifier isMemberAndcheckPause {\n    require(ms.isPause() == false && ms.isMember(msg.sender) == true);\n    _;\n  }\n\n  modifier onlyOwner {\n    require(ms.isOwner(msg.sender));\n    _;\n  }\n\n  modifier checkPause {\n    require(ms.isPause() == false);\n    _;\n  }\n\n  modifier isMember {\n    require(ms.isMember(msg.sender), \"Not member\");\n    _;\n  }\n\n  /**\n   * @dev Iupgradable Interface to update dependent contract address\n   */\n  function changeDependentContractAddress() public;\n\n  /**\n   * @dev change master address\n   * @param _masterAddress is the new address\n   */\n  function changeMasterAddress(address _masterAddress) public {\n    if (address(ms) != address(0)) {\n      require(address(ms) == msg.sender, \"Not master\");\n    }\n\n    ms = INXMMaster(_masterAddress);\n    nxMasterAddress = _masterAddress;\n  }\n\n}\n"
78     },
79     "contracts/interfaces/IPooledStaking.sol": {
80       "content": "pragma solidity ^0.5.0;\n\n\ninterface IPooledStaking {\n\n  function accumulateReward(address contractAddress, uint amount) external;\n\n  function pushBurn(address contractAddress, uint amount) external;\n\n  function hasPendingActions() external view returns (bool);\n\n  function contractStake(address contractAddress) external view returns (uint);\n\n  function stakerReward(address staker) external view returns (uint);\n\n  function stakerDeposit(address staker) external view returns (uint);\n\n  function stakerContractStake(address staker, address contractAddress) external view returns (uint);\n\n  function withdraw(uint amount) external;\n\n  function stakerMaxWithdrawable(address stakerAddress) external view returns (uint);\n\n  function withdrawReward(address stakerAddress) external;\n}\n"
81     },
82     "contracts/modules/token/external/IERC1132.sol": {
83       "content": "pragma solidity ^0.5.0;\n\n/**\n * @title ERC1132 interface\n * @dev see https://github.com/ethereum/EIPs/issues/1132\n */\n\ncontract IERC1132 {\n  /**\n   * @dev Reasons why a user's tokens have been locked\n   */\n  mapping(address => bytes32[]) public lockReason;\n\n  /**\n   * @dev locked token structure\n   */\n  struct LockToken {\n    uint256 amount;\n    uint256 validity;\n    bool claimed;\n  }\n\n  /**\n   * @dev Holds number & validity of tokens locked for a given reason for\n   *      a specified address\n   */\n  mapping(address => mapping(bytes32 => LockToken)) public locked;\n\n  /**\n   * @dev Records data of all the tokens Locked\n   */\n  event Locked(\n    address indexed _of,\n    bytes32 indexed _reason,\n    uint256 _amount,\n    uint256 _validity\n  );\n\n  /**\n   * @dev Records data of all the tokens unlocked\n   */\n  event Unlocked(\n    address indexed _of,\n    bytes32 indexed _reason,\n    uint256 _amount\n  );\n\n  /**\n   * @dev Locks a specified amount of tokens against an address,\n   *      for a specified reason and time\n   * @param _reason The reason to lock tokens\n   * @param _amount Number of tokens to be locked\n   * @param _time Lock time in seconds\n   */\n  function lock(bytes32 _reason, uint256 _amount, uint256 _time)\n  public returns (bool);\n\n  /**\n   * @dev Returns tokens locked for a specified address for a\n   *      specified reason\n   *\n   * @param _of The address whose tokens are locked\n   * @param _reason The reason to query the lock tokens for\n   */\n  function tokensLocked(address _of, bytes32 _reason)\n  public view returns (uint256 amount);\n\n  /**\n   * @dev Returns tokens locked for a specified address for a\n   *      specified reason at a specific time\n   *\n   * @param _of The address whose tokens are locked\n   * @param _reason The reason to query the lock tokens for\n   * @param _time The timestamp to query the lock tokens for\n   */\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\n  public view returns (uint256 amount);\n\n  /**\n   * @dev Returns total tokens held by an address (locked + transferable)\n   * @param _of The address to query the total balance of\n   */\n  function totalBalanceOf(address _of)\n  public view returns (uint256 amount);\n\n  /**\n   * @dev Extends lock for a specified reason and time\n   * @param _reason The reason to lock tokens\n   * @param _time Lock extension time in seconds\n   */\n  function extendLock(bytes32 _reason, uint256 _time)\n  public returns (bool);\n\n  /**\n   * @dev Increase number of tokens locked for a specified reason\n   * @param _reason The reason to lock tokens\n   * @param _amount Number of tokens to be increased\n   */\n  function increaseLockAmount(bytes32 _reason, uint256 _amount)\n  public returns (bool);\n\n  /**\n   * @dev Returns unlockable tokens for a specified address for a specified reason\n   * @param _of The address to query the the unlockable token count of\n   * @param _reason The reason to query the unlockable tokens for\n   */\n  function tokensUnlockable(address _of, bytes32 _reason)\n  public view returns (uint256 amount);\n\n  /**\n   * @dev Unlocks the unlockable tokens of a specified address\n   * @param _of Address of user, claiming back unlockable tokens\n   */\n  function unlock(address _of)\n  public returns (uint256 unlockableTokens);\n\n  /**\n   * @dev Gets the unlockable tokens of a specified address\n   * @param _of The address to query the the unlockable token count of\n   */\n  function getUnlockableTokens(address _of)\n  public view returns (uint256 unlockableTokens);\n\n}\n"
84     },
85     "contracts/modules/governance/Governance.sol": {
86       "content": "// /* Copyright (C) 2017 GovBlocks.io\r\n\r\n//   This program is free software: you can redistribute it and/or modify\r\n//     it under the terms of the GNU General Public License as published by\r\n//     the Free Software Foundation, either version 3 of the License, or\r\n//     (at your option) any later version.\r\n\r\n//   This program is distributed in the hope that it will be useful,\r\n//     but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n//     GNU General Public License for more details.\r\n\r\n//   You should have received a copy of the GNU General Public License\r\n//     along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../token/TokenController.sol\";\r\nimport \"./MemberRoles.sol\";\r\nimport \"./ProposalCategory.sol\";\r\nimport \"./external/IGovernance.sol\";\r\n\r\ncontract Governance is IGovernance, Iupgradable {\r\n\r\n  using SafeMath for uint;\r\n\r\n  enum ProposalStatus {\r\n    Draft,\r\n    AwaitingSolution,\r\n    VotingStarted,\r\n    Accepted,\r\n    Rejected,\r\n    Majority_Not_Reached_But_Accepted,\r\n    Denied\r\n  }\r\n\r\n  struct ProposalData {\r\n    uint propStatus;\r\n    uint finalVerdict;\r\n    uint category;\r\n    uint commonIncentive;\r\n    uint dateUpd;\r\n    address owner;\r\n  }\r\n\r\n  struct ProposalVote {\r\n    address voter;\r\n    uint proposalId;\r\n    uint dateAdd;\r\n  }\r\n\r\n  struct VoteTally {\r\n    mapping(uint => uint) memberVoteValue;\r\n    mapping(uint => uint) abVoteValue;\r\n    uint voters;\r\n  }\r\n\r\n  struct DelegateVote {\r\n    address follower;\r\n    address leader;\r\n    uint lastUpd;\r\n  }\r\n\r\n  ProposalVote[] internal allVotes;\r\n  DelegateVote[] public allDelegation;\r\n\r\n  mapping(uint => ProposalData) internal allProposalData;\r\n  mapping(uint => bytes[]) internal allProposalSolutions;\r\n  mapping(address => uint[]) internal allVotesByMember;\r\n  mapping(uint => mapping(address => bool)) public rewardClaimed;\r\n  mapping(address => mapping(uint => uint)) public memberProposalVote;\r\n  mapping(address => uint) public followerDelegation;\r\n  mapping(address => uint) internal followerCount;\r\n  mapping(address => uint[]) internal leaderDelegation;\r\n  mapping(uint => VoteTally) public proposalVoteTally;\r\n  mapping(address => bool) public isOpenForDelegation;\r\n  mapping(address => uint) public lastRewardClaimed;\r\n\r\n  bool internal constructorCheck;\r\n  uint public tokenHoldingTime;\r\n  uint internal roleIdAllowedToCatgorize;\r\n  uint internal maxVoteWeigthPer;\r\n  uint internal specialResolutionMajPerc;\r\n  uint internal maxFollowers;\r\n  uint internal totalProposals;\r\n  uint internal maxDraftTime;\r\n\r\n  MemberRoles internal memberRole;\r\n  ProposalCategory internal proposalCategory;\r\n  TokenController internal tokenInstance;\r\n\r\n  mapping(uint => uint) public proposalActionStatus;\r\n  mapping(uint => uint) internal proposalExecutionTime;\r\n  mapping(uint => mapping(address => bool)) public proposalRejectedByAB;\r\n  mapping(uint => uint) internal actionRejectedCount;\r\n\r\n  bool internal actionParamsInitialised;\r\n  uint internal actionWaitingTime;\r\n  uint constant internal AB_MAJ_TO_REJECT_ACTION = 3;\r\n\r\n  enum ActionStatus {\r\n    Pending,\r\n    Accepted,\r\n    Rejected,\r\n    Executed,\r\n    NoAction\r\n  }\r\n\r\n  /**\r\n  * @dev Called whenever an action execution is failed.\r\n  */\r\n  event ActionFailed (\r\n    uint256 proposalId\r\n  );\r\n\r\n  /**\r\n  * @dev Called whenever an AB member rejects the action execution.\r\n  */\r\n  event ActionRejected (\r\n    uint256 indexed proposalId,\r\n    address rejectedBy\r\n  );\r\n\r\n  /**\r\n  * @dev Checks if msg.sender is proposal owner\r\n  */\r\n  modifier onlyProposalOwner(uint _proposalId) {\r\n    require(msg.sender == allProposalData[_proposalId].owner, \"Not allowed\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if proposal is opened for voting\r\n  */\r\n  modifier voteNotStarted(uint _proposalId) {\r\n    require(allProposalData[_proposalId].propStatus < uint(ProposalStatus.VotingStarted));\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if msg.sender is allowed to create proposal under given category\r\n  */\r\n  modifier isAllowed(uint _categoryId) {\r\n    require(allowedToCreateProposal(_categoryId), \"Not allowed\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if msg.sender is allowed categorize proposal under given category\r\n  */\r\n  modifier isAllowedToCategorize() {\r\n    require(memberRole.checkRole(msg.sender, roleIdAllowedToCatgorize), \"Not allowed\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if msg.sender had any pending rewards to be claimed\r\n  */\r\n  modifier checkPendingRewards {\r\n    require(getPendingReward(msg.sender) == 0, \"Claim reward\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Event emitted whenever a proposal is categorized\r\n  */\r\n  event ProposalCategorized(\r\n    uint indexed proposalId,\r\n    address indexed categorizedBy,\r\n    uint categoryId\r\n  );\r\n\r\n  /**\r\n   * @dev Removes delegation of an address.\r\n   * @param _add address to undelegate.\r\n   */\r\n  function removeDelegation(address _add) external onlyInternal {\r\n    _unDelegate(_add);\r\n  }\r\n\r\n  /**\r\n  * @dev Creates a new proposal\r\n  * @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n  * @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n  */\r\n  function createProposal(\r\n    string calldata _proposalTitle,\r\n    string calldata _proposalSD,\r\n    string calldata _proposalDescHash,\r\n    uint _categoryId\r\n  )\r\n  external isAllowed(_categoryId)\r\n  {\r\n    require(ms.isMember(msg.sender), \"Not Member\");\r\n\r\n    _createProposal(_proposalTitle, _proposalSD, _proposalDescHash, _categoryId);\r\n  }\r\n\r\n  /**\r\n  * @dev Edits the details of an existing proposal\r\n  * @param _proposalId Proposal id that details needs to be updated\r\n  * @param _proposalDescHash Proposal description hash having long and short description of proposal.\r\n  */\r\n  function updateProposal(\r\n    uint _proposalId,\r\n    string calldata _proposalTitle,\r\n    string calldata _proposalSD,\r\n    string calldata _proposalDescHash\r\n  )\r\n  external onlyProposalOwner(_proposalId)\r\n  {\r\n    require(\r\n      allProposalSolutions[_proposalId].length < 2,\r\n      \"Not allowed\"\r\n    );\r\n    allProposalData[_proposalId].propStatus = uint(ProposalStatus.Draft);\r\n    allProposalData[_proposalId].category = 0;\r\n    allProposalData[_proposalId].commonIncentive = 0;\r\n    emit Proposal(\r\n      allProposalData[_proposalId].owner,\r\n      _proposalId,\r\n      now,\r\n      _proposalTitle,\r\n      _proposalSD,\r\n      _proposalDescHash\r\n    );\r\n  }\r\n\r\n  /**\r\n  * @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\r\n  */\r\n  function categorizeProposal(\r\n    uint _proposalId,\r\n    uint _categoryId,\r\n    uint _incentive\r\n  )\r\n  external\r\n  voteNotStarted(_proposalId) isAllowedToCategorize\r\n  {\r\n    _categorizeProposal(_proposalId, _categoryId, _incentive);\r\n  }\r\n\r\n  /**\r\n  * @dev Submit proposal with solution\r\n  * @param _proposalId Proposal id\r\n  * @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n  */\r\n  function submitProposalWithSolution(\r\n    uint _proposalId,\r\n    string calldata _solutionHash,\r\n    bytes calldata _action\r\n  )\r\n  external\r\n  onlyProposalOwner(_proposalId)\r\n  {\r\n\r\n    require(allProposalData[_proposalId].propStatus == uint(ProposalStatus.AwaitingSolution));\r\n\r\n    _proposalSubmission(_proposalId, _solutionHash, _action);\r\n  }\r\n\r\n  /**\r\n  * @dev Creates a new proposal with solution\r\n  * @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n  * @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n  * @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n  */\r\n  function createProposalwithSolution(\r\n    string calldata _proposalTitle,\r\n    string calldata _proposalSD,\r\n    string calldata _proposalDescHash,\r\n    uint _categoryId,\r\n    string calldata _solutionHash,\r\n    bytes calldata _action\r\n  )\r\n  external isAllowed(_categoryId)\r\n  {\r\n\r\n\r\n    uint proposalId = totalProposals;\r\n\r\n    _createProposal(_proposalTitle, _proposalSD, _proposalDescHash, _categoryId);\r\n\r\n    require(_categoryId > 0);\r\n\r\n    _proposalSubmission(\r\n      proposalId,\r\n      _solutionHash,\r\n      _action\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Submit a vote on the proposal.\r\n   * @param _proposalId to vote upon.\r\n   * @param _solutionChosen is the chosen vote.\r\n   */\r\n  function submitVote(uint _proposalId, uint _solutionChosen) external {\r\n\r\n    require(allProposalData[_proposalId].propStatus ==\r\n      uint(Governance.ProposalStatus.VotingStarted), \"Not allowed\");\r\n\r\n    require(_solutionChosen < allProposalSolutions[_proposalId].length);\r\n\r\n\r\n    _submitVote(_proposalId, _solutionChosen);\r\n  }\r\n\r\n  /**\r\n   * @dev Closes the proposal.\r\n   * @param _proposalId of proposal to be closed.\r\n   */\r\n  function closeProposal(uint _proposalId) external {\r\n    uint category = allProposalData[_proposalId].category;\r\n\r\n\r\n    uint _memberRole;\r\n    if (allProposalData[_proposalId].dateUpd.add(maxDraftTime) <= now &&\r\n      allProposalData[_proposalId].propStatus < uint(ProposalStatus.VotingStarted)) {\r\n      _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n    } else {\r\n      require(canCloseProposal(_proposalId) == 1);\r\n      (, _memberRole,,,,,) = proposalCategory.category(allProposalData[_proposalId].category);\r\n      if (_memberRole == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n        _closeAdvisoryBoardVote(_proposalId, category);\r\n      } else {\r\n        _closeMemberVote(_proposalId, category);\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Claims reward for member.\r\n   * @param _memberAddress to claim reward of.\r\n   * @param _maxRecords maximum number of records to claim reward for.\r\n   _proposals list of proposals of which reward will be claimed.\r\n   * @return amount of pending reward.\r\n   */\r\n  function claimReward(address _memberAddress, uint _maxRecords)\r\n  external returns (uint pendingDAppReward)\r\n  {\r\n\r\n    uint voteId;\r\n    address leader;\r\n    uint lastUpd;\r\n\r\n    require(msg.sender == ms.getLatestAddress(\"CR\"));\r\n\r\n    uint delegationId = followerDelegation[_memberAddress];\r\n    DelegateVote memory delegationData = allDelegation[delegationId];\r\n    if (delegationId > 0 && delegationData.leader != address(0)) {\r\n      leader = delegationData.leader;\r\n      lastUpd = delegationData.lastUpd;\r\n    } else\r\n      leader = _memberAddress;\r\n\r\n    uint proposalId;\r\n    uint totalVotes = allVotesByMember[leader].length;\r\n    uint lastClaimed = totalVotes;\r\n    uint j;\r\n    uint i;\r\n    for (i = lastRewardClaimed[_memberAddress]; i < totalVotes && j < _maxRecords; i++) {\r\n      voteId = allVotesByMember[leader][i];\r\n      proposalId = allVotes[voteId].proposalId;\r\n      if (proposalVoteTally[proposalId].voters > 0 && (allVotes[voteId].dateAdd > (\r\n      lastUpd.add(tokenHoldingTime)) || leader == _memberAddress)) {\r\n        if (allProposalData[proposalId].propStatus > uint(ProposalStatus.VotingStarted)) {\r\n          if (!rewardClaimed[voteId][_memberAddress]) {\r\n            pendingDAppReward = pendingDAppReward.add(\r\n              allProposalData[proposalId].commonIncentive.div(\r\n                proposalVoteTally[proposalId].voters\r\n              )\r\n            );\r\n            rewardClaimed[voteId][_memberAddress] = true;\r\n            j++;\r\n          }\r\n        } else {\r\n          if (lastClaimed == totalVotes) {\r\n            lastClaimed = i;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (lastClaimed == totalVotes) {\r\n      lastRewardClaimed[_memberAddress] = i;\r\n    } else {\r\n      lastRewardClaimed[_memberAddress] = lastClaimed;\r\n    }\r\n\r\n    if (j > 0) {\r\n      emit RewardClaimed(\r\n        _memberAddress,\r\n        pendingDAppReward\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Sets delegation acceptance status of individual user\r\n   * @param _status delegation acceptance status\r\n   */\r\n  function setDelegationStatus(bool _status) external isMemberAndcheckPause checkPendingRewards {\r\n    isOpenForDelegation[msg.sender] = _status;\r\n  }\r\n\r\n  /**\r\n   * @dev Delegates vote to an address.\r\n   * @param _add is the address to delegate vote to.\r\n   */\r\n  function delegateVote(address _add) external isMemberAndcheckPause checkPendingRewards {\r\n\r\n    require(ms.masterInitialized());\r\n\r\n    require(allDelegation[followerDelegation[_add]].leader == address(0));\r\n\r\n    if (followerDelegation[msg.sender] > 0) {\r\n      require((allDelegation[followerDelegation[msg.sender]].lastUpd).add(tokenHoldingTime) < now);\r\n    }\r\n\r\n    require(!alreadyDelegated(msg.sender));\r\n    require(!memberRole.checkRole(msg.sender, uint(MemberRoles.Role.Owner)));\r\n    require(!memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)));\r\n\r\n\r\n    require(followerCount[_add] < maxFollowers);\r\n\r\n    if (allVotesByMember[msg.sender].length > 0) {\r\n      require((allVotes[allVotesByMember[msg.sender][allVotesByMember[msg.sender].length - 1]].dateAdd).add(tokenHoldingTime)\r\n        < now);\r\n    }\r\n\r\n    require(ms.isMember(_add));\r\n\r\n    require(isOpenForDelegation[_add]);\r\n\r\n    allDelegation.push(DelegateVote(msg.sender, _add, now));\r\n    followerDelegation[msg.sender] = allDelegation.length - 1;\r\n    leaderDelegation[_add].push(allDelegation.length - 1);\r\n    followerCount[_add]++;\r\n    lastRewardClaimed[msg.sender] = allVotesByMember[_add].length;\r\n  }\r\n\r\n  /**\r\n   * @dev Undelegates the sender\r\n   */\r\n  function unDelegate() external isMemberAndcheckPause checkPendingRewards {\r\n    _unDelegate(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Triggers action of accepted proposal after waiting time is finished\r\n   */\r\n  function triggerAction(uint _proposalId) external {\r\n    require(proposalActionStatus[_proposalId] == uint(ActionStatus.Accepted) && proposalExecutionTime[_proposalId] <= now, \"Cannot trigger\");\r\n    _triggerAction(_proposalId, allProposalData[_proposalId].category);\r\n  }\r\n\r\n  /**\r\n   * @dev Provides option to Advisory board member to reject proposal action execution within actionWaitingTime, if found suspicious\r\n   */\r\n  function rejectAction(uint _proposalId) external {\r\n    require(memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)) && proposalExecutionTime[_proposalId] > now);\r\n\r\n    require(proposalActionStatus[_proposalId] == uint(ActionStatus.Accepted));\r\n\r\n    require(!proposalRejectedByAB[_proposalId][msg.sender]);\r\n\r\n    require(\r\n      keccak256(proposalCategory.categoryActionHashes(allProposalData[_proposalId].category))\r\n      != keccak256(abi.encodeWithSignature(\"swapABMember(address,address)\"))\r\n    );\r\n\r\n    proposalRejectedByAB[_proposalId][msg.sender] = true;\r\n    actionRejectedCount[_proposalId]++;\r\n    emit ActionRejected(_proposalId, msg.sender);\r\n    if (actionRejectedCount[_proposalId] == AB_MAJ_TO_REJECT_ACTION) {\r\n      proposalActionStatus[_proposalId] = uint(ActionStatus.Rejected);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Sets intial actionWaitingTime value\r\n   * To be called after governance implementation has been updated\r\n   */\r\n  function setInitialActionParameters() external onlyOwner {\r\n    require(!actionParamsInitialised);\r\n    actionParamsInitialised = true;\r\n    actionWaitingTime = 24 * 1 hours;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Uint Parameters of a code\r\n   * @param code whose details we want\r\n   * @return string value of the code\r\n   * @return associated amount (time or perc or value) to the code\r\n   */\r\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\r\n\r\n    codeVal = code;\r\n\r\n    if (code == \"GOVHOLD\") {\r\n\r\n      val = tokenHoldingTime / (1 days);\r\n\r\n    } else if (code == \"MAXFOL\") {\r\n\r\n      val = maxFollowers;\r\n\r\n    } else if (code == \"MAXDRFT\") {\r\n\r\n      val = maxDraftTime / (1 days);\r\n\r\n    } else if (code == \"EPTIME\") {\r\n\r\n      val = ms.pauseTime() / (1 days);\r\n\r\n    } else if (code == \"ACWT\") {\r\n\r\n      val = actionWaitingTime / (1 hours);\r\n\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets all details of a propsal\r\n   * @param _proposalId whose details we want\r\n   * @return proposalId\r\n   * @return category\r\n   * @return status\r\n   * @return finalVerdict\r\n   * @return totalReward\r\n   */\r\n  function proposal(uint _proposalId)\r\n  external\r\n  view\r\n  returns (\r\n    uint proposalId,\r\n    uint category,\r\n    uint status,\r\n    uint finalVerdict,\r\n    uint totalRewar\r\n  )\r\n  {\r\n    return (\r\n    _proposalId,\r\n    allProposalData[_proposalId].category,\r\n    allProposalData[_proposalId].propStatus,\r\n    allProposalData[_proposalId].finalVerdict,\r\n    allProposalData[_proposalId].commonIncentive\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets some details of a propsal\r\n   * @param _proposalId whose details we want\r\n   * @return proposalId\r\n   * @return number of all proposal solutions\r\n   * @return amount of votes\r\n   */\r\n  function proposalDetails(uint _proposalId) external view returns (uint, uint, uint) {\r\n    return (\r\n    _proposalId,\r\n    allProposalSolutions[_proposalId].length,\r\n    proposalVoteTally[_proposalId].voters\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets solution action on a proposal\r\n   * @param _proposalId whose details we want\r\n   * @param _solution whose details we want\r\n   * @return action of a solution on a proposal\r\n   */\r\n  function getSolutionAction(uint _proposalId, uint _solution) external view returns (uint, bytes memory) {\r\n    return (\r\n    _solution,\r\n    allProposalSolutions[_proposalId][_solution]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets length of propsal\r\n   * @return length of propsal\r\n   */\r\n  function getProposalLength() external view returns (uint) {\r\n    return totalProposals;\r\n  }\r\n\r\n  /**\r\n   * @dev Get followers of an address\r\n   * @return get followers of an address\r\n   */\r\n  function getFollowers(address _add) external view returns (uint[] memory) {\r\n    return leaderDelegation[_add];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets pending rewards of a member\r\n   * @param _memberAddress in concern\r\n   * @return amount of pending reward\r\n   */\r\n  function getPendingReward(address _memberAddress)\r\n  public view returns (uint pendingDAppReward)\r\n  {\r\n    uint delegationId = followerDelegation[_memberAddress];\r\n    address leader;\r\n    uint lastUpd;\r\n    DelegateVote memory delegationData = allDelegation[delegationId];\r\n\r\n    if (delegationId > 0 && delegationData.leader != address(0)) {\r\n      leader = delegationData.leader;\r\n      lastUpd = delegationData.lastUpd;\r\n    } else\r\n      leader = _memberAddress;\r\n\r\n    uint proposalId;\r\n    for (uint i = lastRewardClaimed[_memberAddress]; i < allVotesByMember[leader].length; i++) {\r\n      if (allVotes[allVotesByMember[leader][i]].dateAdd > (\r\n      lastUpd.add(tokenHoldingTime)) || leader == _memberAddress) {\r\n        if (!rewardClaimed[allVotesByMember[leader][i]][_memberAddress]) {\r\n          proposalId = allVotes[allVotesByMember[leader][i]].proposalId;\r\n          if (proposalVoteTally[proposalId].voters > 0 && allProposalData[proposalId].propStatus\r\n          > uint(ProposalStatus.VotingStarted)) {\r\n            pendingDAppReward = pendingDAppReward.add(\r\n              allProposalData[proposalId].commonIncentive.div(\r\n                proposalVoteTally[proposalId].voters\r\n              )\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Updates Uint Parameters of a code\r\n   * @param code whose details we want to update\r\n   * @param val value to set\r\n   */\r\n  function updateUintParameters(bytes8 code, uint val) public {\r\n\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    if (code == \"GOVHOLD\") {\r\n\r\n      tokenHoldingTime = val * 1 days;\r\n\r\n    } else if (code == \"MAXFOL\") {\r\n\r\n      maxFollowers = val;\r\n\r\n    } else if (code == \"MAXDRFT\") {\r\n\r\n      maxDraftTime = val * 1 days;\r\n\r\n    } else if (code == \"EPTIME\") {\r\n\r\n      ms.updatePauseTime(val * 1 days);\r\n\r\n    } else if (code == \"ACWT\") {\r\n\r\n      actionWaitingTime = val * 1 hours;\r\n\r\n    } else {\r\n\r\n      revert(\"Invalid code\");\r\n\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Updates all dependency addresses to latest ones from Master\r\n  */\r\n  function changeDependentContractAddress() public {\r\n    tokenInstance = TokenController(ms.dAppLocker());\r\n    memberRole = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n    proposalCategory = ProposalCategory(ms.getLatestAddress(\"PC\"));\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if msg.sender is allowed to create a proposal under given category\r\n  */\r\n  function allowedToCreateProposal(uint category) public view returns (bool check) {\r\n    if (category == 0)\r\n      return true;\r\n    uint[] memory mrAllowed;\r\n    (,,,, mrAllowed,,) = proposalCategory.category(category);\r\n    for (uint i = 0; i < mrAllowed.length; i++) {\r\n      if (mrAllowed[i] == 0 || memberRole.checkRole(msg.sender, mrAllowed[i]))\r\n        return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if an address is already delegated\r\n   * @param _add in concern\r\n   * @return bool value if the address is delegated or not\r\n   */\r\n  function alreadyDelegated(address _add) public view returns (bool delegated) {\r\n    for (uint i = 0; i < leaderDelegation[_add].length; i++) {\r\n      if (allDelegation[leaderDelegation[_add][i]].leader == _add) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Checks If the proposal voting time is up and it's ready to close\r\n  *      i.e. Closevalue is 1 if proposal is ready to be closed, 2 if already closed, 0 otherwise!\r\n  * @param _proposalId Proposal id to which closing value is being checked\r\n  */\r\n  function canCloseProposal(uint _proposalId)\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    uint dateUpdate;\r\n    uint pStatus;\r\n    uint _closingTime;\r\n    uint _roleId;\r\n    uint majority;\r\n    pStatus = allProposalData[_proposalId].propStatus;\r\n    dateUpdate = allProposalData[_proposalId].dateUpd;\r\n    (, _roleId, majority, , , _closingTime,) = proposalCategory.category(allProposalData[_proposalId].category);\r\n    if (\r\n      pStatus == uint(ProposalStatus.VotingStarted)\r\n    ) {\r\n      uint numberOfMembers = memberRole.numberOfMembers(_roleId);\r\n      if (_roleId == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n        if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100).div(numberOfMembers) >= majority\r\n        || proposalVoteTally[_proposalId].abVoteValue[1].add(proposalVoteTally[_proposalId].abVoteValue[0]) == numberOfMembers\r\n          || dateUpdate.add(_closingTime) <= now) {\r\n\r\n          return 1;\r\n        }\r\n      } else {\r\n        if (numberOfMembers == proposalVoteTally[_proposalId].voters\r\n          || dateUpdate.add(_closingTime) <= now)\r\n          return 1;\r\n      }\r\n    } else if (pStatus > uint(ProposalStatus.VotingStarted)) {\r\n      return 2;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Id of member role allowed to categorize the proposal\r\n   * @return roleId allowed to categorize the proposal\r\n   */\r\n  function allowedToCatgorize() public view returns (uint roleId) {\r\n    return roleIdAllowedToCatgorize;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets vote tally data\r\n   * @param _proposalId in concern\r\n   * @param _solution of a proposal id\r\n   * @return member vote value\r\n   * @return advisory board vote value\r\n   * @return amount of votes\r\n   */\r\n  function voteTallyData(uint _proposalId, uint _solution) public view returns (uint, uint, uint) {\r\n    return (proposalVoteTally[_proposalId].memberVoteValue[_solution],\r\n    proposalVoteTally[_proposalId].abVoteValue[_solution], proposalVoteTally[_proposalId].voters);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to create proposal\r\n   * @param _proposalTitle of proposal\r\n   * @param _proposalSD is short description of proposal\r\n   * @param _proposalDescHash IPFS hash value of propsal\r\n   * @param _categoryId of proposal\r\n   */\r\n  function _createProposal(\r\n    string memory _proposalTitle,\r\n    string memory _proposalSD,\r\n    string memory _proposalDescHash,\r\n    uint _categoryId\r\n  )\r\n  internal\r\n  {\r\n    require(proposalCategory.categoryABReq(_categoryId) == 0 || _categoryId == 0);\r\n    uint _proposalId = totalProposals;\r\n    allProposalData[_proposalId].owner = msg.sender;\r\n    allProposalData[_proposalId].dateUpd = now;\r\n    allProposalSolutions[_proposalId].push(\"\");\r\n    totalProposals++;\r\n\r\n    emit Proposal(\r\n      msg.sender,\r\n      _proposalId,\r\n      now,\r\n      _proposalTitle,\r\n      _proposalSD,\r\n      _proposalDescHash\r\n    );\r\n\r\n    if (_categoryId > 0)\r\n      _categorizeProposal(_proposalId, _categoryId, 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to categorize a proposal\r\n   * @param _proposalId of proposal\r\n   * @param _categoryId of proposal\r\n   * @param _incentive is commonIncentive\r\n   */\r\n  function _categorizeProposal(\r\n    uint _proposalId,\r\n    uint _categoryId,\r\n    uint _incentive\r\n  )\r\n  internal\r\n  {\r\n    require(\r\n      _categoryId > 0 && _categoryId < proposalCategory.totalCategories(),\r\n      \"Invalid category\"\r\n    );\r\n    allProposalData[_proposalId].category = _categoryId;\r\n    allProposalData[_proposalId].commonIncentive = _incentive;\r\n    allProposalData[_proposalId].propStatus = uint(ProposalStatus.AwaitingSolution);\r\n\r\n    emit ProposalCategorized(_proposalId, msg.sender, _categoryId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to add solution to a proposal\r\n   * @param _proposalId in concern\r\n   * @param _action on that solution\r\n   * @param _solutionHash string value\r\n   */\r\n  function _addSolution(uint _proposalId, bytes memory _action, string memory _solutionHash)\r\n  internal\r\n  {\r\n    allProposalSolutions[_proposalId].push(_action);\r\n    emit Solution(_proposalId, msg.sender, allProposalSolutions[_proposalId].length - 1, _solutionHash, now);\r\n  }\r\n\r\n  /**\r\n  * @dev Internal call to add solution and open proposal for voting\r\n  */\r\n  function _proposalSubmission(\r\n    uint _proposalId,\r\n    string memory _solutionHash,\r\n    bytes memory _action\r\n  )\r\n  internal\r\n  {\r\n\r\n    uint _categoryId = allProposalData[_proposalId].category;\r\n    if (proposalCategory.categoryActionHashes(_categoryId).length == 0) {\r\n      require(keccak256(_action) == keccak256(\"\"));\r\n      proposalActionStatus[_proposalId] = uint(ActionStatus.NoAction);\r\n    }\r\n\r\n    _addSolution(\r\n      _proposalId,\r\n      _action,\r\n      _solutionHash\r\n    );\r\n\r\n    _updateProposalStatus(_proposalId, uint(ProposalStatus.VotingStarted));\r\n    (, , , , , uint closingTime,) = proposalCategory.category(_categoryId);\r\n    emit CloseProposalOnTime(_proposalId, closingTime.add(now));\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to submit vote\r\n   * @param _proposalId of proposal in concern\r\n   * @param _solution for that proposal\r\n   */\r\n  function _submitVote(uint _proposalId, uint _solution) internal {\r\n\r\n    uint delegationId = followerDelegation[msg.sender];\r\n    uint mrSequence;\r\n    uint majority;\r\n    uint closingTime;\r\n    (, mrSequence, majority, , , closingTime,) = proposalCategory.category(allProposalData[_proposalId].category);\r\n\r\n    require(allProposalData[_proposalId].dateUpd.add(closingTime) > now, \"Closed\");\r\n\r\n    require(memberProposalVote[msg.sender][_proposalId] == 0, \"Not allowed\");\r\n    require((delegationId == 0) || (delegationId > 0 && allDelegation[delegationId].leader == address(0) &&\r\n    _checkLastUpd(allDelegation[delegationId].lastUpd)));\r\n\r\n    require(memberRole.checkRole(msg.sender, mrSequence), \"Not Authorized\");\r\n    uint totalVotes = allVotes.length;\r\n\r\n    allVotesByMember[msg.sender].push(totalVotes);\r\n    memberProposalVote[msg.sender][_proposalId] = totalVotes;\r\n\r\n    allVotes.push(ProposalVote(msg.sender, _proposalId, now));\r\n\r\n    emit Vote(msg.sender, _proposalId, totalVotes, now, _solution);\r\n    if (mrSequence == uint(MemberRoles.Role.Owner)) {\r\n      if (_solution == 1)\r\n        _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), allProposalData[_proposalId].category, 1, MemberRoles.Role.Owner);\r\n      else\r\n        _updateProposalStatus(_proposalId, uint(ProposalStatus.Rejected));\r\n\r\n    } else {\r\n      uint numberOfMembers = memberRole.numberOfMembers(mrSequence);\r\n      _setVoteTally(_proposalId, _solution, mrSequence);\r\n\r\n      if (mrSequence == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n        if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100).div(numberOfMembers)\r\n        >= majority\r\n          || (proposalVoteTally[_proposalId].abVoteValue[1].add(proposalVoteTally[_proposalId].abVoteValue[0])) == numberOfMembers) {\r\n          emit VoteCast(_proposalId);\r\n        }\r\n      } else {\r\n        if (numberOfMembers == proposalVoteTally[_proposalId].voters)\r\n          emit VoteCast(_proposalId);\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to set vote tally of a proposal\r\n   * @param _proposalId of proposal in concern\r\n   * @param _solution of proposal in concern\r\n   * @param mrSequence number of members for a role\r\n   */\r\n  function _setVoteTally(uint _proposalId, uint _solution, uint mrSequence) internal\r\n  {\r\n    uint categoryABReq;\r\n    uint isSpecialResolution;\r\n    (, categoryABReq, isSpecialResolution) = proposalCategory.categoryExtendedData(allProposalData[_proposalId].category);\r\n    if (memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)) && (categoryABReq > 0) ||\r\n      mrSequence == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n      proposalVoteTally[_proposalId].abVoteValue[_solution]++;\r\n    }\r\n    tokenInstance.lockForMemberVote(msg.sender, tokenHoldingTime);\r\n    if (mrSequence != uint(MemberRoles.Role.AdvisoryBoard)) {\r\n      uint voteWeight;\r\n      uint voters = 1;\r\n      uint tokenBalance = tokenInstance.totalBalanceOf(msg.sender);\r\n      uint totalSupply = tokenInstance.totalSupply();\r\n      if (isSpecialResolution == 1) {\r\n        voteWeight = tokenBalance.add(10 ** 18);\r\n      } else {\r\n        voteWeight = (_minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100))).add(10 ** 18);\r\n      }\r\n      DelegateVote memory delegationData;\r\n      for (uint i = 0; i < leaderDelegation[msg.sender].length; i++) {\r\n        delegationData = allDelegation[leaderDelegation[msg.sender][i]];\r\n        if (delegationData.leader == msg.sender &&\r\n          _checkLastUpd(delegationData.lastUpd)) {\r\n          if (memberRole.checkRole(delegationData.follower, mrSequence)) {\r\n            tokenBalance = tokenInstance.totalBalanceOf(delegationData.follower);\r\n            tokenInstance.lockForMemberVote(delegationData.follower, tokenHoldingTime);\r\n            voters++;\r\n            if (isSpecialResolution == 1) {\r\n              voteWeight = voteWeight.add(tokenBalance.add(10 ** 18));\r\n            } else {\r\n              voteWeight = voteWeight.add((_minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100))).add(10 ** 18));\r\n            }\r\n          }\r\n        }\r\n      }\r\n      proposalVoteTally[_proposalId].memberVoteValue[_solution] = proposalVoteTally[_proposalId].memberVoteValue[_solution].add(voteWeight);\r\n      proposalVoteTally[_proposalId].voters = proposalVoteTally[_proposalId].voters + voters;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets minimum of two numbers\r\n   * @param a one of the two numbers\r\n   * @param b one of the two numbers\r\n   * @return minimum number out of the two\r\n   */\r\n  function _minOf(uint a, uint b) internal pure returns (uint res) {\r\n    res = a;\r\n    if (res > b)\r\n      res = b;\r\n  }\r\n\r\n  /**\r\n   * @dev Check the time since last update has exceeded token holding time or not\r\n   * @param _lastUpd is last update time\r\n   * @return the bool which tells if the time since last update has exceeded token holding time or not\r\n   */\r\n  function _checkLastUpd(uint _lastUpd) internal view returns (bool) {\r\n    return (now - _lastUpd) > tokenHoldingTime;\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if the vote count against any solution passes the threshold value or not.\r\n  */\r\n  function _checkForThreshold(uint _proposalId, uint _category) internal view returns (bool check) {\r\n    uint categoryQuorumPerc;\r\n    uint roleAuthorized;\r\n    (, roleAuthorized, , categoryQuorumPerc, , ,) = proposalCategory.category(_category);\r\n    check = ((proposalVoteTally[_proposalId].memberVoteValue[0]\r\n    .add(proposalVoteTally[_proposalId].memberVoteValue[1]))\r\n    .mul(100))\r\n    .div(\r\n      tokenInstance.totalSupply().add(\r\n        memberRole.numberOfMembers(roleAuthorized).mul(10 ** 18)\r\n      )\r\n    ) >= categoryQuorumPerc;\r\n  }\r\n\r\n  /**\r\n   * @dev Called when vote majority is reached\r\n   * @param _proposalId of proposal in concern\r\n   * @param _status of proposal in concern\r\n   * @param category of proposal in concern\r\n   * @param max vote value of proposal in concern\r\n   */\r\n  function _callIfMajReached(uint _proposalId, uint _status, uint category, uint max, MemberRoles.Role role) internal {\r\n\r\n    allProposalData[_proposalId].finalVerdict = max;\r\n    _updateProposalStatus(_proposalId, _status);\r\n    emit ProposalAccepted(_proposalId);\r\n    if (proposalActionStatus[_proposalId] != uint(ActionStatus.NoAction)) {\r\n      if (role == MemberRoles.Role.AdvisoryBoard) {\r\n        _triggerAction(_proposalId, category);\r\n      } else {\r\n        proposalActionStatus[_proposalId] = uint(ActionStatus.Accepted);\r\n        proposalExecutionTime[_proposalId] = actionWaitingTime.add(now);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to trigger action of accepted proposal\r\n   */\r\n  function _triggerAction(uint _proposalId, uint _categoryId) internal {\r\n    proposalActionStatus[_proposalId] = uint(ActionStatus.Executed);\r\n    bytes2 contractName;\r\n    address actionAddress;\r\n    bytes memory _functionHash;\r\n    (, actionAddress, contractName, , _functionHash) = proposalCategory.categoryActionDetails(_categoryId);\r\n    if (contractName == \"MS\") {\r\n      actionAddress = address(ms);\r\n    } else if (contractName != \"EX\") {\r\n      actionAddress = ms.getLatestAddress(contractName);\r\n    }\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool actionStatus,) = actionAddress.call(abi.encodePacked(_functionHash, allProposalSolutions[_proposalId][1]));\r\n    if (actionStatus) {\r\n      emit ActionSuccess(_proposalId);\r\n    } else {\r\n      proposalActionStatus[_proposalId] = uint(ActionStatus.Accepted);\r\n      emit ActionFailed(_proposalId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to update proposal status\r\n   * @param _proposalId of proposal in concern\r\n   * @param _status of proposal to set\r\n   */\r\n  function _updateProposalStatus(uint _proposalId, uint _status) internal {\r\n    if (_status == uint(ProposalStatus.Rejected) || _status == uint(ProposalStatus.Denied)) {\r\n      proposalActionStatus[_proposalId] = uint(ActionStatus.NoAction);\r\n    }\r\n    allProposalData[_proposalId].dateUpd = now;\r\n    allProposalData[_proposalId].propStatus = _status;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to undelegate a follower\r\n   * @param _follower is address of follower to undelegate\r\n   */\r\n  function _unDelegate(address _follower) internal {\r\n    uint followerId = followerDelegation[_follower];\r\n    if (followerId > 0) {\r\n\r\n      followerCount[allDelegation[followerId].leader] = followerCount[allDelegation[followerId].leader].sub(1);\r\n      allDelegation[followerId].leader = address(0);\r\n      allDelegation[followerId].lastUpd = now;\r\n\r\n      lastRewardClaimed[_follower] = allVotesByMember[_follower].length;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to close member voting\r\n   * @param _proposalId of proposal in concern\r\n   * @param category of proposal in concern\r\n   */\r\n  function _closeMemberVote(uint _proposalId, uint category) internal {\r\n    uint isSpecialResolution;\r\n    uint abMaj;\r\n    (, abMaj, isSpecialResolution) = proposalCategory.categoryExtendedData(category);\r\n    if (isSpecialResolution == 1) {\r\n      uint acceptedVotePerc = proposalVoteTally[_proposalId].memberVoteValue[1].mul(100)\r\n      .div(\r\n        tokenInstance.totalSupply().add(\r\n          memberRole.numberOfMembers(uint(MemberRoles.Role.Member)).mul(10 ** 18)\r\n        ));\r\n      if (acceptedVotePerc >= specialResolutionMajPerc) {\r\n        _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\r\n      } else {\r\n        _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n      }\r\n    } else {\r\n      if (_checkForThreshold(_proposalId, category)) {\r\n        uint majorityVote;\r\n        (,, majorityVote,,,,) = proposalCategory.category(category);\r\n        if (\r\n          ((proposalVoteTally[_proposalId].memberVoteValue[1].mul(100))\r\n          .div(proposalVoteTally[_proposalId].memberVoteValue[0]\r\n          .add(proposalVoteTally[_proposalId].memberVoteValue[1])\r\n          ))\r\n          >= majorityVote\r\n        ) {\r\n          _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\r\n        } else {\r\n          _updateProposalStatus(_proposalId, uint(ProposalStatus.Rejected));\r\n        }\r\n      } else {\r\n        if (abMaj > 0 && proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\r\n        .div(memberRole.numberOfMembers(uint(MemberRoles.Role.AdvisoryBoard))) >= abMaj) {\r\n          _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\r\n        } else {\r\n          _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n        }\r\n      }\r\n    }\r\n\r\n    if (proposalVoteTally[_proposalId].voters > 0) {\r\n      tokenInstance.mint(ms.getLatestAddress(\"CR\"), allProposalData[_proposalId].commonIncentive);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to close advisory board voting\r\n   * @param _proposalId of proposal in concern\r\n   * @param category of proposal in concern\r\n   */\r\n  function _closeAdvisoryBoardVote(uint _proposalId, uint category) internal {\r\n    uint _majorityVote;\r\n    MemberRoles.Role _roleId = MemberRoles.Role.AdvisoryBoard;\r\n    (,, _majorityVote,,,,) = proposalCategory.category(category);\r\n    if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\r\n    .div(memberRole.numberOfMembers(uint(_roleId))) >= _majorityVote) {\r\n      _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, _roleId);\r\n    } else {\r\n      _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n    }\r\n\r\n  }\r\n\r\n}\r\n"
87     },
88     "contracts/modules/governance/external/Governed.sol": {
89       "content": "/* Copyright (C) 2017 GovBlocks.io\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\n\ninterface IMaster {\n  function getLatestAddress(bytes2 _module) external view returns (address);\n}\n\ncontract Governed {\n\n  address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\n\n  /// @dev modifier that allows only the authorized addresses to execute the function\n  modifier onlyAuthorizedToGovern() {\n    IMaster ms = IMaster(masterAddress);\n    require(ms.getLatestAddress(\"GV\") == msg.sender, \"Not authorized\");\n    _;\n  }\n\n  /// @dev checks if an address is authorized to govern\n  function isAuthorizedToGovern(address _toCheck) public view returns (bool) {\n    IMaster ms = IMaster(masterAddress);\n    return (ms.getLatestAddress(\"GV\") == _toCheck);\n  }\n\n}\n"
90     },
91     "contracts/modules/claims/Claims.sol": {
92       "content": "/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\nimport \"../capital/Pool.sol\";\nimport \"../claims/ClaimsReward.sol\";\nimport \"../token/NXMToken.sol\";\nimport \"../token/TokenController.sol\";\nimport \"../token/TokenFunctions.sol\";\nimport \"./ClaimsData.sol\";\n\ncontract Claims is Iupgradable {\n  using SafeMath for uint;\n\n  TokenFunctions internal tf;\n  NXMToken internal tk;\n  TokenController internal tc;\n  ClaimsReward internal cr;\n  Pool internal p1;\n  ClaimsData internal cd;\n  TokenData internal td;\n  QuotationData internal qd;\n\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\n\n  /**\n   * @dev Sets the status of claim using claim id.\n   * @param claimId claim id.\n   * @param stat status to be set.\n   */\n  function setClaimStatus(uint claimId, uint stat) external onlyInternal {\n    _setClaimStatus(claimId, stat);\n  }\n\n  /**\n   * @dev Gets claim details of claim id = pending claim start + given index\n   */\n  function getClaimFromNewStart(\n    uint index\n  )\n  external\n  view\n  returns (\n    uint coverId,\n    uint claimId,\n    int8 voteCA,\n    int8 voteMV,\n    uint statusnumber\n  )\n  {\n    (coverId, claimId, voteCA, voteMV, statusnumber) = cd.getClaimFromNewStart(index, msg.sender);\n  }\n\n  /**\n   * @dev Gets details of a claim submitted by the calling user, at a given index\n   */\n  function getUserClaimByIndex(\n    uint index\n  )\n  external\n  view\n  returns (\n    uint status,\n    uint coverId,\n    uint claimId\n  )\n  {\n    uint statusno;\n    (statusno, coverId, claimId) = cd.getUserClaimByIndex(index, msg.sender);\n    status = statusno;\n  }\n\n  /**\n   * @dev Gets details of a given claim id.\n   * @param _claimId Claim Id.\n   * @return status Current status of claim id\n   * @return finalVerdict Decision made on the claim, 1 -> acceptance, -1 -> denial\n   * @return claimOwner Address through which claim is submitted\n   * @return coverId Coverid associated with the claim id\n   */\n  function getClaimbyIndex(uint _claimId) external view returns (\n    uint claimId,\n    uint status,\n    int8 finalVerdict,\n    address claimOwner,\n    uint coverId\n  )\n  {\n    uint stat;\n    claimId = _claimId;\n    (, coverId, finalVerdict, stat,,) = cd.getClaim(_claimId);\n    claimOwner = qd.getCoverMemberAddress(coverId);\n    status = stat;\n  }\n\n  /**\n   * @dev Calculates total amount that has been used to assess a claim.\n   * Computaion:Adds acceptCA(tokens used for voting in favor of a claim)\n   * denyCA(tokens used for voting against a claim) *  current token price.\n   * @param claimId Claim Id.\n   * @param member Member type 0 -> Claim Assessors, else members.\n   * @return tokens Total Amount used in Claims assessment.\n   */\n  function getCATokens(uint claimId, uint member) external view returns (uint tokens) {\n    uint coverId;\n    (, coverId) = cd.getClaimCoverId(claimId);\n\n    bytes4 currency = qd.getCurrencyOfCover(coverId);\n    address asset = cr.getCurrencyAssetAddress(currency);\n    uint tokenx1e18 = p1.getTokenPrice(asset);\n\n    uint accept;\n    uint deny;\n    if (member == 0) {\n      (, accept, deny) = cd.getClaimsTokenCA(claimId);\n    } else {\n      (, accept, deny) = cd.getClaimsTokenMV(claimId);\n    }\n    tokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18); // amount (not in tokens)\n  }\n\n  /**\n   * Iupgradable Interface to update dependent contract address\n   */\n  function changeDependentContractAddress() public onlyInternal {\n    tk = NXMToken(ms.tokenAddress());\n    td = TokenData(ms.getLatestAddress(\"TD\"));\n    tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\n    tc = TokenController(ms.getLatestAddress(\"TC\"));\n    p1 = Pool(ms.getLatestAddress(\"P1\"));\n    cr = ClaimsReward(ms.getLatestAddress(\"CR\"));\n    cd = ClaimsData(ms.getLatestAddress(\"CD\"));\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\n  }\n\n  /**\n   * @dev Updates the pending claim start variable,\n   * the lowest claim id with a pending decision/payout.\n   */\n  function changePendingClaimStart() public onlyInternal {\n\n    uint origstat;\n    uint state12Count;\n    uint pendingClaimStart = cd.pendingClaimStart();\n    uint actualClaimLength = cd.actualClaimLength();\n    for (uint i = pendingClaimStart; i < actualClaimLength; i++) {\n      (, , , origstat, , state12Count) = cd.getClaim(i);\n\n      if (origstat > 5 && ((origstat != 12) || (origstat == 12 && state12Count >= 60))) {\n        cd.setpendingClaimStart(i);\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @dev Submits a claim for a given cover note.\n   * Adds claim to queue incase of emergency pause else directly submits the claim.\n   * @param coverId Cover Id.\n   */\n  function submitClaim(uint coverId) public {\n    address qadd = qd.getCoverMemberAddress(coverId);\n    require(qadd == msg.sender);\n    uint8 cStatus;\n    (, cStatus,,,) = qd.getCoverDetailsByCoverID2(coverId);\n    require(cStatus != uint8(QuotationData.CoverStatus.ClaimSubmitted), \"Claim already submitted\");\n    require(cStatus != uint8(QuotationData.CoverStatus.CoverExpired), \"Cover already expired\");\n    if (ms.isPause() == false) {\n      _addClaim(coverId, now, qadd);\n    } else {\n      cd.setClaimAtEmergencyPause(coverId, now, false);\n      qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.Requested));\n    }\n  }\n\n  /**\n   * @dev Submits the Claims queued once the emergency pause is switched off.\n   */\n  function submitClaimAfterEPOff() public onlyInternal {\n    uint lengthOfClaimSubmittedAtEP = cd.getLengthOfClaimSubmittedAtEP();\n    uint firstClaimIndexToSubmitAfterEP = cd.getFirstClaimIndexToSubmitAfterEP();\n    uint coverId;\n    uint dateUpd;\n    bool submit;\n    address qadd;\n    for (uint i = firstClaimIndexToSubmitAfterEP; i < lengthOfClaimSubmittedAtEP; i++) {\n      (coverId, dateUpd, submit) = cd.getClaimOfEmergencyPauseByIndex(i);\n      require(submit == false);\n      qadd = qd.getCoverMemberAddress(coverId);\n      _addClaim(coverId, dateUpd, qadd);\n      cd.setClaimSubmittedAtEPTrue(i, true);\n    }\n    cd.setFirstClaimIndexToSubmitAfterEP(lengthOfClaimSubmittedAtEP);\n  }\n\n  /**\n   * @dev Castes vote for members who have tokens locked under Claims Assessment\n   * @param claimId  claim id.\n   * @param verdict 1 for Accept,-1 for Deny.\n   */\n  function submitCAVote(uint claimId, int8 verdict) public isMemberAndcheckPause {\n    require(checkVoteClosing(claimId) != 1);\n    require(cd.userClaimVotePausedOn(msg.sender).add(cd.pauseDaysCA()) < now);\n    uint tokens = tc.tokensLockedAtTime(msg.sender, \"CLA\", now.add(cd.claimDepositTime()));\n    require(tokens > 0);\n    uint stat;\n    (, stat) = cd.getClaimStatusNumber(claimId);\n    require(stat == 0);\n    require(cd.getUserClaimVoteCA(msg.sender, claimId) == 0);\n    td.bookCATokens(msg.sender);\n    cd.addVote(msg.sender, tokens, claimId, verdict);\n    cd.callVoteEvent(msg.sender, claimId, \"CAV\", tokens, now, verdict);\n    uint voteLength = cd.getAllVoteLength();\n    cd.addClaimVoteCA(claimId, voteLength);\n    cd.setUserClaimVoteCA(msg.sender, claimId, voteLength);\n    cd.setClaimTokensCA(claimId, verdict, tokens);\n    tc.extendLockOf(msg.sender, \"CLA\", td.lockCADays());\n    int close = checkVoteClosing(claimId);\n    if (close == 1) {\n      cr.changeClaimStatus(claimId);\n    }\n  }\n\n  /**\n   * @dev Submits a member vote for assessing a claim.\n   * Tokens other than those locked under Claims\n   * Assessment can be used to cast a vote for a given claim id.\n   * @param claimId Selected claim id.\n   * @param verdict 1 for Accept,-1 for Deny.\n   */\n  function submitMemberVote(uint claimId, int8 verdict) public isMemberAndcheckPause {\n    require(checkVoteClosing(claimId) != 1);\n    uint stat;\n    uint tokens = tc.totalBalanceOf(msg.sender);\n    (, stat) = cd.getClaimStatusNumber(claimId);\n    require(stat >= 1 && stat <= 5);\n    require(cd.getUserClaimVoteMember(msg.sender, claimId) == 0);\n    cd.addVote(msg.sender, tokens, claimId, verdict);\n    cd.callVoteEvent(msg.sender, claimId, \"MV\", tokens, now, verdict);\n    tc.lockForMemberVote(msg.sender, td.lockMVDays());\n    uint voteLength = cd.getAllVoteLength();\n    cd.addClaimVotemember(claimId, voteLength);\n    cd.setUserClaimVoteMember(msg.sender, claimId, voteLength);\n    cd.setClaimTokensMV(claimId, verdict, tokens);\n    int close = checkVoteClosing(claimId);\n    if (close == 1) {\n      cr.changeClaimStatus(claimId);\n    }\n  }\n\n  /**\n  * @dev Pause Voting of All Pending Claims when Emergency Pause Start.\n  */\n  function pauseAllPendingClaimsVoting() public onlyInternal {\n    uint firstIndex = cd.pendingClaimStart();\n    uint actualClaimLength = cd.actualClaimLength();\n    for (uint i = firstIndex; i < actualClaimLength; i++) {\n      if (checkVoteClosing(i) == 0) {\n        uint dateUpd = cd.getClaimDateUpd(i);\n        cd.setPendingClaimDetails(i, (dateUpd.add(cd.maxVotingTime())).sub(now), false);\n      }\n    }\n  }\n\n  /**\n   * @dev Resume the voting phase of all Claims paused due to an emergency pause.\n   */\n  function startAllPendingClaimsVoting() public onlyInternal {\n    uint firstIndx = cd.getFirstClaimIndexToStartVotingAfterEP();\n    uint i;\n    uint lengthOfClaimVotingPause = cd.getLengthOfClaimVotingPause();\n    for (i = firstIndx; i < lengthOfClaimVotingPause; i++) {\n      uint pendingTime;\n      uint claimID;\n      (claimID, pendingTime,) = cd.getPendingClaimDetailsByIndex(i);\n      uint pTime = (now.sub(cd.maxVotingTime())).add(pendingTime);\n      cd.setClaimdateUpd(claimID, pTime);\n      cd.setPendingClaimVoteStatus(i, true);\n      uint coverid;\n      (, coverid) = cd.getClaimCoverId(claimID);\n      address qadd = qd.getCoverMemberAddress(coverid);\n      tf.extendCNEPOff(qadd, coverid, pendingTime.add(cd.claimDepositTime()));\n    }\n    cd.setFirstClaimIndexToStartVotingAfterEP(i);\n  }\n\n  /**\n   * @dev Checks if voting of a claim should be closed or not.\n   * @param claimId Claim Id.\n   * @return close 1 -> voting should be closed, 0 -> if voting should not be closed,\n   * -1 -> voting has already been closed.\n   */\n  function checkVoteClosing(uint claimId) public view returns (int8 close) {\n    close = 0;\n    uint status;\n    (, status) = cd.getClaimStatusNumber(claimId);\n    uint dateUpd = cd.getClaimDateUpd(claimId);\n    if (status == 12 && dateUpd.add(cd.payoutRetryTime()) < now) {\n      if (cd.getClaimState12Count(claimId) < 60)\n        close = 1;\n    }\n\n    if (status > 5 && status != 12) {\n      close = - 1;\n    } else if (status != 12 && dateUpd.add(cd.maxVotingTime()) <= now) {\n      close = 1;\n    } else if (status != 12 && dateUpd.add(cd.minVotingTime()) >= now) {\n      close = 0;\n    } else if (status == 0 || (status >= 1 && status <= 5)) {\n      close = _checkVoteClosingFinal(claimId, status);\n    }\n\n  }\n\n  /**\n   * @dev Checks if voting of a claim should be closed or not.\n   * Internally called by checkVoteClosing method\n   * for Claims whose status number is 0 or status number lie between 2 and 6.\n   * @param claimId Claim Id.\n   * @param status Current status of claim.\n   * @return close 1 if voting should be closed,0 in case voting should not be closed,\n   * -1 if voting has already been closed.\n   */\n  function _checkVoteClosingFinal(uint claimId, uint status) internal view returns (int8 close) {\n    close = 0;\n    uint coverId;\n    (, coverId) = cd.getClaimCoverId(claimId);\n\n    bytes4 currency = qd.getCurrencyOfCover(coverId);\n    address asset = cr.getCurrencyAssetAddress(currency);\n    uint tokenx1e18 = p1.getTokenPrice(asset);\n\n    uint accept;\n    uint deny;\n    (, accept, deny) = cd.getClaimsTokenCA(claimId);\n    uint caTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);\n    (, accept, deny) = cd.getClaimsTokenMV(claimId);\n    uint mvTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);\n    uint sumassured = qd.getCoverSumAssured(coverId).mul(DECIMAL1E18);\n    if (status == 0 && caTokens >= sumassured.mul(10)) {\n      close = 1;\n    } else if (status >= 1 && status <= 5 && mvTokens >= sumassured.mul(10)) {\n      close = 1;\n    }\n  }\n\n  /**\n   * @dev Changes the status of an existing claim id, based on current\n   * status and current conditions of the system\n   * @param claimId Claim Id.\n   * @param stat status number.\n   */\n  function _setClaimStatus(uint claimId, uint stat) internal {\n\n    uint origstat;\n    uint state12Count;\n    uint dateUpd;\n    uint coverId;\n    (, coverId, , origstat, dateUpd, state12Count) = cd.getClaim(claimId);\n    (, origstat) = cd.getClaimStatusNumber(claimId);\n\n    if (stat == 12 && origstat == 12) {\n      cd.updateState12Count(claimId, 1);\n    }\n    cd.setClaimStatus(claimId, stat);\n\n    if (state12Count >= 60 && stat == 12) {\n      cd.setClaimStatus(claimId, 13);\n      qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimDenied));\n    }\n\n    cd.setClaimdateUpd(claimId, now);\n  }\n\n  /**\n   * @dev Submits a claim for a given cover note.\n   * Set deposits flag against cover.\n   */\n  function _addClaim(uint coverId, uint time, address add) internal {\n    tf.depositCN(coverId);\n    uint len = cd.actualClaimLength();\n    cd.addClaim(len, coverId, add, now);\n    cd.callClaimEvent(coverId, add, len, time);\n    qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimSubmitted));\n  }\n}\n"
93     },
94     "contracts/modules/claims/ClaimsData.sol": {
95       "content": "/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../abstract/Iupgradable.sol\";\n\ncontract ClaimsData is Iupgradable {\n  using SafeMath for uint;\n\n  struct Claim {\n    uint coverId;\n    uint dateUpd;\n  }\n\n  struct Vote {\n    address voter;\n    uint tokens;\n    uint claimId;\n    int8 verdict;\n    bool rewardClaimed;\n  }\n\n  struct ClaimsPause {\n    uint coverid;\n    uint dateUpd;\n    bool submit;\n  }\n\n  struct ClaimPauseVoting {\n    uint claimid;\n    uint pendingTime;\n    bool voting;\n  }\n\n  struct RewardDistributed {\n    uint lastCAvoteIndex;\n    uint lastMVvoteIndex;\n\n  }\n\n  struct ClaimRewardDetails {\n    uint percCA;\n    uint percMV;\n    uint tokenToBeDist;\n\n  }\n\n  struct ClaimTotalTokens {\n    uint accept;\n    uint deny;\n  }\n\n  struct ClaimRewardStatus {\n    uint percCA;\n    uint percMV;\n  }\n\n  ClaimRewardStatus[] internal rewardStatus;\n\n  Claim[] internal allClaims;\n  Vote[] internal allvotes;\n  ClaimsPause[] internal claimPause;\n  ClaimPauseVoting[] internal claimPauseVotingEP;\n\n  mapping(address => RewardDistributed) internal voterVoteRewardReceived;\n  mapping(uint => ClaimRewardDetails) internal claimRewardDetail;\n  mapping(uint => ClaimTotalTokens) internal claimTokensCA;\n  mapping(uint => ClaimTotalTokens) internal claimTokensMV;\n  mapping(uint => int8) internal claimVote;\n  mapping(uint => uint) internal claimsStatus;\n  mapping(uint => uint) internal claimState12Count;\n  mapping(uint => uint[]) internal claimVoteCA;\n  mapping(uint => uint[]) internal claimVoteMember;\n  mapping(address => uint[]) internal voteAddressCA;\n  mapping(address => uint[]) internal voteAddressMember;\n  mapping(address => uint[]) internal allClaimsByAddress;\n  mapping(address => mapping(uint => uint)) internal userClaimVoteCA;\n  mapping(address => mapping(uint => uint)) internal userClaimVoteMember;\n  mapping(address => uint) public userClaimVotePausedOn;\n\n  uint internal claimPauseLastsubmit;\n  uint internal claimStartVotingFirstIndex;\n  uint public pendingClaimStart;\n  uint public claimDepositTime;\n  uint public maxVotingTime;\n  uint public minVotingTime;\n  uint public payoutRetryTime;\n  uint public claimRewardPerc;\n  uint public minVoteThreshold;\n  uint public maxVoteThreshold;\n  uint public majorityConsensus;\n  uint public pauseDaysCA;\n\n  event ClaimRaise(\n    uint indexed coverId,\n    address indexed userAddress,\n    uint claimId,\n    uint dateSubmit\n  );\n\n  event VoteCast(\n    address indexed userAddress,\n    uint indexed claimId,\n    bytes4 indexed typeOf,\n    uint tokens,\n    uint submitDate,\n    int8 verdict\n  );\n\n  constructor() public {\n    pendingClaimStart = 1;\n    maxVotingTime = 48 * 1 hours;\n    minVotingTime = 12 * 1 hours;\n    payoutRetryTime = 24 * 1 hours;\n    allvotes.push(Vote(address(0), 0, 0, 0, false));\n    allClaims.push(Claim(0, 0));\n    claimDepositTime = 7 days;\n    claimRewardPerc = 20;\n    minVoteThreshold = 5;\n    maxVoteThreshold = 10;\n    majorityConsensus = 70;\n    pauseDaysCA = 3 days;\n    _addRewardIncentive();\n  }\n\n  /**\n   * @dev Updates the pending claim start variable,\n   * the lowest claim id with a pending decision/payout.\n   */\n  function setpendingClaimStart(uint _start) external onlyInternal {\n    require(pendingClaimStart <= _start);\n    pendingClaimStart = _start;\n  }\n\n  /**\n   * @dev Updates the max vote index for which claim assessor has received reward\n   * @param _voter address of the voter.\n   * @param caIndex last index till which reward was distributed for CA\n   */\n  function setRewardDistributedIndexCA(address _voter, uint caIndex) external onlyInternal {\n    voterVoteRewardReceived[_voter].lastCAvoteIndex = caIndex;\n\n  }\n\n  /**\n   * @dev Used to pause claim assessor activity for 3 days\n   * @param user Member address whose claim voting ability needs to be paused\n   */\n  function setUserClaimVotePausedOn(address user) external {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    userClaimVotePausedOn[user] = now;\n  }\n\n  /**\n   * @dev Updates the max vote index for which member has received reward\n   * @param _voter address of the voter.\n   * @param mvIndex last index till which reward was distributed for member\n   */\n  function setRewardDistributedIndexMV(address _voter, uint mvIndex) external onlyInternal {\n\n    voterVoteRewardReceived[_voter].lastMVvoteIndex = mvIndex;\n  }\n\n  /**\n   * @param claimid claim id.\n   * @param percCA reward Percentage reward for claim assessor\n   * @param percMV reward Percentage reward for members\n   * @param tokens total tokens to be rewarded\n   */\n  function setClaimRewardDetail(\n    uint claimid,\n    uint percCA,\n    uint percMV,\n    uint tokens\n  )\n  external\n  onlyInternal\n  {\n    claimRewardDetail[claimid].percCA = percCA;\n    claimRewardDetail[claimid].percMV = percMV;\n    claimRewardDetail[claimid].tokenToBeDist = tokens;\n  }\n\n  /**\n   * @dev Sets the reward claim status against a vote id.\n   * @param _voteid vote Id.\n   * @param claimed true if reward for vote is claimed, else false.\n   */\n  function setRewardClaimed(uint _voteid, bool claimed) external onlyInternal {\n    allvotes[_voteid].rewardClaimed = claimed;\n  }\n\n  /**\n   * @dev Sets the final vote's result(either accepted or declined)of a claim.\n   * @param _claimId Claim Id.\n   * @param _verdict 1 if claim is accepted,-1 if declined.\n   */\n  function changeFinalVerdict(uint _claimId, int8 _verdict) external onlyInternal {\n    claimVote[_claimId] = _verdict;\n  }\n\n  /**\n   * @dev Creates a new claim.\n   */\n  function addClaim(\n    uint _claimId,\n    uint _coverId,\n    address _from,\n    uint _nowtime\n  )\n  external\n  onlyInternal\n  {\n    allClaims.push(Claim(_coverId, _nowtime));\n    allClaimsByAddress[_from].push(_claimId);\n  }\n\n  /**\n   * @dev Add Vote's details of a given claim.\n   */\n  function addVote(\n    address _voter,\n    uint _tokens,\n    uint claimId,\n    int8 _verdict\n  )\n  external\n  onlyInternal\n  {\n    allvotes.push(Vote(_voter, _tokens, claimId, _verdict, false));\n  }\n\n  /**\n   * @dev Stores the id of the claim assessor vote given to a claim.\n   * Maintains record of all votes given by all the CA to a claim.\n   * @param _claimId Claim Id to which vote has given by the CA.\n   * @param _voteid Vote Id.\n   */\n  function addClaimVoteCA(uint _claimId, uint _voteid) external onlyInternal {\n    claimVoteCA[_claimId].push(_voteid);\n  }\n\n  /**\n   * @dev Sets the id of the vote.\n   * @param _from Claim assessor's address who has given the vote.\n   * @param _claimId Claim Id for which vote has been given by the CA.\n   * @param _voteid Vote Id which will be stored against the given _from and claimid.\n   */\n  function setUserClaimVoteCA(\n    address _from,\n    uint _claimId,\n    uint _voteid\n  )\n  external\n  onlyInternal\n  {\n    userClaimVoteCA[_from][_claimId] = _voteid;\n    voteAddressCA[_from].push(_voteid);\n  }\n\n  /**\n   * @dev Stores the tokens locked by the Claim Assessors during voting of a given claim.\n   * @param _claimId Claim Id.\n   * @param _vote 1 for accept and increases the tokens of claim as accept,\n   * -1 for deny and increases the tokens of claim as deny.\n   * @param _tokens Number of tokens.\n   */\n  function setClaimTokensCA(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\n    if (_vote == 1)\n      claimTokensCA[_claimId].accept = claimTokensCA[_claimId].accept.add(_tokens);\n    if (_vote == - 1)\n      claimTokensCA[_claimId].deny = claimTokensCA[_claimId].deny.add(_tokens);\n  }\n\n  /**\n   * @dev Stores the tokens locked by the Members during voting of a given claim.\n   * @param _claimId Claim Id.\n   * @param _vote 1 for accept and increases the tokens of claim as accept,\n   * -1 for deny and increases the tokens of claim as deny.\n   * @param _tokens Number of tokens.\n   */\n  function setClaimTokensMV(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\n    if (_vote == 1)\n      claimTokensMV[_claimId].accept = claimTokensMV[_claimId].accept.add(_tokens);\n    if (_vote == - 1)\n      claimTokensMV[_claimId].deny = claimTokensMV[_claimId].deny.add(_tokens);\n  }\n\n  /**\n   * @dev Stores the id of the member vote given to a claim.\n   * Maintains record of all votes given by all the Members to a claim.\n   * @param _claimId Claim Id to which vote has been given by the Member.\n   * @param _voteid Vote Id.\n   */\n  function addClaimVotemember(uint _claimId, uint _voteid) external onlyInternal {\n    claimVoteMember[_claimId].push(_voteid);\n  }\n\n  /**\n   * @dev Sets the id of the vote.\n   * @param _from Member's address who has given the vote.\n   * @param _claimId Claim Id for which vote has been given by the Member.\n   * @param _voteid Vote Id which will be stored against the given _from and claimid.\n   */\n  function setUserClaimVoteMember(\n    address _from,\n    uint _claimId,\n    uint _voteid\n  )\n  external\n  onlyInternal\n  {\n    userClaimVoteMember[_from][_claimId] = _voteid;\n    voteAddressMember[_from].push(_voteid);\n\n  }\n\n  /**\n   * @dev Increases the count of failure until payout of a claim is successful.\n   */\n  function updateState12Count(uint _claimId, uint _cnt) external onlyInternal {\n    claimState12Count[_claimId] = claimState12Count[_claimId].add(_cnt);\n  }\n\n  /**\n   * @dev Sets status of a claim.\n   * @param _claimId Claim Id.\n   * @param _stat Status number.\n   */\n  function setClaimStatus(uint _claimId, uint _stat) external onlyInternal {\n    claimsStatus[_claimId] = _stat;\n  }\n\n  /**\n   * @dev Sets the timestamp of a given claim at which the Claim's details has been updated.\n   * @param _claimId Claim Id of claim which has been changed.\n   * @param _dateUpd timestamp at which claim is updated.\n   */\n  function setClaimdateUpd(uint _claimId, uint _dateUpd) external onlyInternal {\n    allClaims[_claimId].dateUpd = _dateUpd;\n  }\n\n  /**\n   @dev Queues Claims during Emergency Pause.\n   */\n  function setClaimAtEmergencyPause(\n    uint _coverId,\n    uint _dateUpd,\n    bool _submit\n  )\n  external\n  onlyInternal\n  {\n    claimPause.push(ClaimsPause(_coverId, _dateUpd, _submit));\n  }\n\n  /**\n   * @dev Set submission flag for Claims queued during emergency pause.\n   * Set to true after EP is turned off and the claim is submitted .\n   */\n  function setClaimSubmittedAtEPTrue(uint _index, bool _submit) external onlyInternal {\n    claimPause[_index].submit = _submit;\n  }\n\n  /**\n   * @dev Sets the index from which claim needs to be\n   * submitted when emergency pause is swithched off.\n   */\n  function setFirstClaimIndexToSubmitAfterEP(\n    uint _firstClaimIndexToSubmit\n  )\n  external\n  onlyInternal\n  {\n    claimPauseLastsubmit = _firstClaimIndexToSubmit;\n  }\n\n  /**\n   * @dev Sets the pending vote duration for a claim in case of emergency pause.\n   */\n  function setPendingClaimDetails(\n    uint _claimId,\n    uint _pendingTime,\n    bool _voting\n  )\n  external\n  onlyInternal\n  {\n    claimPauseVotingEP.push(ClaimPauseVoting(_claimId, _pendingTime, _voting));\n  }\n\n  /**\n   * @dev Sets voting flag true after claim is reopened for voting after emergency pause.\n   */\n  function setPendingClaimVoteStatus(uint _claimId, bool _vote) external onlyInternal {\n    claimPauseVotingEP[_claimId].voting = _vote;\n  }\n\n  /**\n   * @dev Sets the index from which claim needs to be\n   * reopened when emergency pause is swithched off.\n   */\n  function setFirstClaimIndexToStartVotingAfterEP(\n    uint _claimStartVotingFirstIndex\n  )\n  external\n  onlyInternal\n  {\n    claimStartVotingFirstIndex = _claimStartVotingFirstIndex;\n  }\n\n  /**\n   * @dev Calls Vote Event.\n   */\n  function callVoteEvent(\n    address _userAddress,\n    uint _claimId,\n    bytes4 _typeOf,\n    uint _tokens,\n    uint _submitDate,\n    int8 _verdict\n  )\n  external\n  onlyInternal\n  {\n    emit VoteCast(\n      _userAddress,\n      _claimId,\n      _typeOf,\n      _tokens,\n      _submitDate,\n      _verdict\n    );\n  }\n\n  /**\n   * @dev Calls Claim Event.\n   */\n  function callClaimEvent(\n    uint _coverId,\n    address _userAddress,\n    uint _claimId,\n    uint _datesubmit\n  )\n  external\n  onlyInternal\n  {\n    emit ClaimRaise(_coverId, _userAddress, _claimId, _datesubmit);\n  }\n\n  /**\n   * @dev Gets Uint Parameters by parameter code\n   * @param code whose details we want\n   * @return string value of the parameter\n   * @return associated amount (time or perc or value) to the code\n   */\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\n    codeVal = code;\n    if (code == \"CAMAXVT\") {\n      val = maxVotingTime / (1 hours);\n\n    } else if (code == \"CAMINVT\") {\n\n      val = minVotingTime / (1 hours);\n\n    } else if (code == \"CAPRETRY\") {\n\n      val = payoutRetryTime / (1 hours);\n\n    } else if (code == \"CADEPT\") {\n\n      val = claimDepositTime / (1 days);\n\n    } else if (code == \"CAREWPER\") {\n\n      val = claimRewardPerc;\n\n    } else if (code == \"CAMINTH\") {\n\n      val = minVoteThreshold;\n\n    } else if (code == \"CAMAXTH\") {\n\n      val = maxVoteThreshold;\n\n    } else if (code == \"CACONPER\") {\n\n      val = majorityConsensus;\n\n    } else if (code == \"CAPAUSET\") {\n      val = pauseDaysCA / (1 days);\n    }\n\n  }\n\n  /**\n   * @dev Get claim queued during emergency pause by index.\n   */\n  function getClaimOfEmergencyPauseByIndex(\n    uint _index\n  )\n  external\n  view\n  returns (\n    uint coverId,\n    uint dateUpd,\n    bool submit\n  )\n  {\n    coverId = claimPause[_index].coverid;\n    dateUpd = claimPause[_index].dateUpd;\n    submit = claimPause[_index].submit;\n  }\n\n  /**\n   * @dev Gets the Claim's details of given claimid.\n   */\n  function getAllClaimsByIndex(\n    uint _claimId\n  )\n  external\n  view\n  returns (\n    uint coverId,\n    int8 vote,\n    uint status,\n    uint dateUpd,\n    uint state12Count\n  )\n  {\n    return (\n    allClaims[_claimId].coverId,\n    claimVote[_claimId],\n    claimsStatus[_claimId],\n    allClaims[_claimId].dateUpd,\n    claimState12Count[_claimId]\n    );\n  }\n\n  /**\n   * @dev Gets the vote id of a given claim of a given Claim Assessor.\n   */\n  function getUserClaimVoteCA(\n    address _add,\n    uint _claimId\n  )\n  external\n  view\n  returns (uint idVote)\n  {\n    return userClaimVoteCA[_add][_claimId];\n  }\n\n  /**\n   * @dev Gets the vote id of a given claim of a given member.\n   */\n  function getUserClaimVoteMember(\n    address _add,\n    uint _claimId\n  )\n  external\n  view\n  returns (uint idVote)\n  {\n    return userClaimVoteMember[_add][_claimId];\n  }\n\n  /**\n   * @dev Gets the count of all votes.\n   */\n  function getAllVoteLength() external view returns (uint voteCount) {\n    return allvotes.length.sub(1); // Start Index always from 1.\n  }\n\n  /**\n   * @dev Gets the status number of a given claim.\n   * @param _claimId Claim id.\n   * @return statno Status Number.\n   */\n  function getClaimStatusNumber(uint _claimId) external view returns (uint claimId, uint statno) {\n    return (_claimId, claimsStatus[_claimId]);\n  }\n\n  /**\n   * @dev Gets the reward percentage to be distributed for a given status id\n   * @param statusNumber the number of type of status\n   * @return percCA reward Percentage for claim assessor\n   * @return percMV reward Percentage for members\n   */\n  function getRewardStatus(uint statusNumber) external view returns (uint percCA, uint percMV) {\n    return (rewardStatus[statusNumber].percCA, rewardStatus[statusNumber].percMV);\n  }\n\n  /**\n   * @dev Gets the number of tries that have been made for a successful payout of a Claim.\n   */\n  function getClaimState12Count(uint _claimId) external view returns (uint num) {\n    num = claimState12Count[_claimId];\n  }\n\n  /**\n   * @dev Gets the last update date of a claim.\n   */\n  function getClaimDateUpd(uint _claimId) external view returns (uint dateupd) {\n    dateupd = allClaims[_claimId].dateUpd;\n  }\n\n  /**\n   * @dev Gets all Claims created by a user till date.\n   * @param _member user's address.\n   * @return claimarr List of Claims id.\n   */\n  function getAllClaimsByAddress(address _member) external view returns (uint[] memory claimarr) {\n    return allClaimsByAddress[_member];\n  }\n\n  /**\n   * @dev Gets the number of tokens that has been locked\n   * while giving vote to a claim by  Claim Assessors.\n   * @param _claimId Claim Id.\n   * @return accept Total number of tokens when CA accepts the claim.\n   * @return deny Total number of tokens when CA declines the claim.\n   */\n  function getClaimsTokenCA(\n    uint _claimId\n  )\n  external\n  view\n  returns (\n    uint claimId,\n    uint accept,\n    uint deny\n  )\n  {\n    return (\n    _claimId,\n    claimTokensCA[_claimId].accept,\n    claimTokensCA[_claimId].deny\n    );\n  }\n\n  /**\n   * @dev Gets the number of tokens that have been\n   * locked while assessing a claim as a member.\n   * @param _claimId Claim Id.\n   * @return accept Total number of tokens in acceptance of the claim.\n   * @return deny Total number of tokens against the claim.\n   */\n  function getClaimsTokenMV(\n    uint _claimId\n  )\n  external\n  view\n  returns (\n    uint claimId,\n    uint accept,\n    uint deny\n  )\n  {\n    return (\n    _claimId,\n    claimTokensMV[_claimId].accept,\n    claimTokensMV[_claimId].deny\n    );\n  }\n\n  /**\n   * @dev Gets the total number of votes cast as Claims assessor for/against a given claim\n   */\n  function getCaClaimVotesToken(uint _claimId) external view returns (uint claimId, uint cnt) {\n    claimId = _claimId;\n    cnt = 0;\n    for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {\n      cnt = cnt.add(allvotes[claimVoteCA[_claimId][i]].tokens);\n    }\n  }\n\n  /**\n   * @dev Gets the total number of tokens cast as a member for/against a given claim\n   */\n  function getMemberClaimVotesToken(\n    uint _claimId\n  )\n  external\n  view\n  returns (uint claimId, uint cnt)\n  {\n    claimId = _claimId;\n    cnt = 0;\n    for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {\n      cnt = cnt.add(allvotes[claimVoteMember[_claimId][i]].tokens);\n    }\n  }\n\n  /**\n   * @dev Provides information of a vote when given its vote id.\n   * @param _voteid Vote Id.\n   */\n  function getVoteDetails(uint _voteid)\n  external view\n  returns (\n    uint tokens,\n    uint claimId,\n    int8 verdict,\n    bool rewardClaimed\n  )\n  {\n    return (\n    allvotes[_voteid].tokens,\n    allvotes[_voteid].claimId,\n    allvotes[_voteid].verdict,\n    allvotes[_voteid].rewardClaimed\n    );\n  }\n\n  /**\n   * @dev Gets the voter's address of a given vote id.\n   */\n  function getVoterVote(uint _voteid) external view returns (address voter) {\n    return allvotes[_voteid].voter;\n  }\n\n  /**\n   * @dev Provides information of a Claim when given its claim id.\n   * @param _claimId Claim Id.\n   */\n  function getClaim(\n    uint _claimId\n  )\n  external\n  view\n  returns (\n    uint claimId,\n    uint coverId,\n    int8 vote,\n    uint status,\n    uint dateUpd,\n    uint state12Count\n  )\n  {\n    return (\n    _claimId,\n    allClaims[_claimId].coverId,\n    claimVote[_claimId],\n    claimsStatus[_claimId],\n    allClaims[_claimId].dateUpd,\n    claimState12Count[_claimId]\n    );\n  }\n\n  /**\n   * @dev Gets the total number of votes of a given claim.\n   * @param _claimId Claim Id.\n   * @param _ca if 1: votes given by Claim Assessors to a claim,\n   * else returns the number of votes of given by Members to a claim.\n   * @return len total number of votes for/against a given claim.\n   */\n  function getClaimVoteLength(\n    uint _claimId,\n    uint8 _ca\n  )\n  external\n  view\n  returns (uint claimId, uint len)\n  {\n    claimId = _claimId;\n    if (_ca == 1)\n      len = claimVoteCA[_claimId].length;\n    else\n      len = claimVoteMember[_claimId].length;\n  }\n\n  /**\n   * @dev Gets the verdict of a vote using claim id and index.\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\n   * @return ver 1 if vote was given in favour,-1 if given in against.\n   */\n  function getVoteVerdict(\n    uint _claimId,\n    uint _index,\n    uint8 _ca\n  )\n  external\n  view\n  returns (int8 ver)\n  {\n    if (_ca == 1)\n      ver = allvotes[claimVoteCA[_claimId][_index]].verdict;\n    else\n      ver = allvotes[claimVoteMember[_claimId][_index]].verdict;\n  }\n\n  /**\n   * @dev Gets the Number of tokens of a vote using claim id and index.\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\n   * @return tok Number of tokens.\n   */\n  function getVoteToken(\n    uint _claimId,\n    uint _index,\n    uint8 _ca\n  )\n  external\n  view\n  returns (uint tok)\n  {\n    if (_ca == 1)\n      tok = allvotes[claimVoteCA[_claimId][_index]].tokens;\n    else\n      tok = allvotes[claimVoteMember[_claimId][_index]].tokens;\n  }\n\n  /**\n   * @dev Gets the Voter's address of a vote using claim id and index.\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\n   * @return voter Voter's address.\n   */\n  function getVoteVoter(\n    uint _claimId,\n    uint _index,\n    uint8 _ca\n  )\n  external\n  view\n  returns (address voter)\n  {\n    if (_ca == 1)\n      voter = allvotes[claimVoteCA[_claimId][_index]].voter;\n    else\n      voter = allvotes[claimVoteMember[_claimId][_index]].voter;\n  }\n\n  /**\n   * @dev Gets total number of Claims created by a user till date.\n   * @param _add User's address.\n   */\n  function getUserClaimCount(address _add) external view returns (uint len) {\n    len = allClaimsByAddress[_add].length;\n  }\n\n  /**\n   * @dev Calculates number of Claims that are in pending state.\n   */\n  function getClaimLength() external view returns (uint len) {\n    len = allClaims.length.sub(pendingClaimStart);\n  }\n\n  /**\n   * @dev Gets the Number of all the Claims created till date.\n   */\n  function actualClaimLength() external view returns (uint len) {\n    len = allClaims.length;\n  }\n\n  /**\n   * @dev Gets details of a claim.\n   * @param _index claim id = pending claim start + given index\n   * @param _add User's address.\n   * @return coverid cover against which claim has been submitted.\n   * @return claimId Claim  Id.\n   * @return voteCA verdict of vote given as a Claim Assessor.\n   * @return voteMV verdict of vote given as a Member.\n   * @return statusnumber Status of claim.\n   */\n  function getClaimFromNewStart(\n    uint _index,\n    address _add\n  )\n  external\n  view\n  returns (\n    uint coverid,\n    uint claimId,\n    int8 voteCA,\n    int8 voteMV,\n    uint statusnumber\n  )\n  {\n    uint i = pendingClaimStart.add(_index);\n    coverid = allClaims[i].coverId;\n    claimId = i;\n    if (userClaimVoteCA[_add][i] > 0)\n      voteCA = allvotes[userClaimVoteCA[_add][i]].verdict;\n    else\n      voteCA = 0;\n\n    if (userClaimVoteMember[_add][i] > 0)\n      voteMV = allvotes[userClaimVoteMember[_add][i]].verdict;\n    else\n      voteMV = 0;\n\n    statusnumber = claimsStatus[i];\n  }\n\n  /**\n   * @dev Gets details of a claim of a user at a given index.\n   */\n  function getUserClaimByIndex(\n    uint _index,\n    address _add\n  )\n  external\n  view\n  returns (\n    uint status,\n    uint coverid,\n    uint claimId\n  )\n  {\n    claimId = allClaimsByAddress[_add][_index];\n    status = claimsStatus[claimId];\n    coverid = allClaims[claimId].coverId;\n  }\n\n  /**\n   * @dev Gets Id of all the votes given to a claim.\n   * @param _claimId Claim Id.\n   * @return ca id of all the votes given by Claim assessors to a claim.\n   * @return mv id of all the votes given by members to a claim.\n   */\n  function getAllVotesForClaim(\n    uint _claimId\n  )\n  external\n  view\n  returns (\n    uint claimId,\n    uint[] memory ca,\n    uint[] memory mv\n  )\n  {\n    return (_claimId, claimVoteCA[_claimId], claimVoteMember[_claimId]);\n  }\n\n  /**\n   * @dev Gets Number of tokens deposit in a vote using\n   * Claim assessor's address and claim id.\n   * @return tokens Number of deposited tokens.\n   */\n  function getTokensClaim(\n    address _of,\n    uint _claimId\n  )\n  external\n  view\n  returns (\n    uint claimId,\n    uint tokens\n  )\n  {\n    return (_claimId, allvotes[userClaimVoteCA[_of][_claimId]].tokens);\n  }\n\n  /**\n   * @param _voter address of the voter.\n   * @return lastCAvoteIndex last index till which reward was distributed for CA\n   * @return lastMVvoteIndex last index till which reward was distributed for member\n   */\n  function getRewardDistributedIndex(\n    address _voter\n  )\n  external\n  view\n  returns (\n    uint lastCAvoteIndex,\n    uint lastMVvoteIndex\n  )\n  {\n    return (\n    voterVoteRewardReceived[_voter].lastCAvoteIndex,\n    voterVoteRewardReceived[_voter].lastMVvoteIndex\n    );\n  }\n\n  /**\n   * @param claimid claim id.\n   * @return perc_CA reward Percentage for claim assessor\n   * @return perc_MV reward Percentage for members\n   * @return tokens total tokens to be rewarded\n   */\n  function getClaimRewardDetail(\n    uint claimid\n  )\n  external\n  view\n  returns (\n    uint percCA,\n    uint percMV,\n    uint tokens\n  )\n  {\n    return (\n    claimRewardDetail[claimid].percCA,\n    claimRewardDetail[claimid].percMV,\n    claimRewardDetail[claimid].tokenToBeDist\n    );\n  }\n\n  /**\n   * @dev Gets cover id of a claim.\n   */\n  function getClaimCoverId(uint _claimId) external view returns (uint claimId, uint coverid) {\n    return (_claimId, allClaims[_claimId].coverId);\n  }\n\n  /**\n   * @dev Gets total number of tokens staked during voting by Claim Assessors.\n   * @param _claimId Claim Id.\n   * @param _verdict 1 to get total number of accept tokens, -1 to get total number of deny tokens.\n   * @return token token Number of tokens(either accept or deny on the basis of verdict given as parameter).\n   */\n  function getClaimVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token) {\n    claimId = _claimId;\n    token = 0;\n    for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {\n      if (allvotes[claimVoteCA[_claimId][i]].verdict == _verdict)\n        token = token.add(allvotes[claimVoteCA[_claimId][i]].tokens);\n    }\n  }\n\n  /**\n   * @dev Gets total number of tokens staked during voting by Members.\n   * @param _claimId Claim Id.\n   * @param _verdict 1 to get total number of accept tokens,\n   *  -1 to get total number of deny tokens.\n   * @return token token Number of tokens(either accept or\n   * deny on the basis of verdict given as parameter).\n   */\n  function getClaimMVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token) {\n    claimId = _claimId;\n    token = 0;\n    for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {\n      if (allvotes[claimVoteMember[_claimId][i]].verdict == _verdict)\n        token = token.add(allvotes[claimVoteMember[_claimId][i]].tokens);\n    }\n  }\n\n  /**\n   * @param _voter address  of voteid\n   * @param index index to get voteid in CA\n   */\n  function getVoteAddressCA(address _voter, uint index) external view returns (uint) {\n    return voteAddressCA[_voter][index];\n  }\n\n  /**\n   * @param _voter address  of voter\n   * @param index index to get voteid in member vote\n   */\n  function getVoteAddressMember(address _voter, uint index) external view returns (uint) {\n    return voteAddressMember[_voter][index];\n  }\n\n  /**\n   * @param _voter address  of voter\n   */\n  function getVoteAddressCALength(address _voter) external view returns (uint) {\n    return voteAddressCA[_voter].length;\n  }\n\n  /**\n   * @param _voter address  of voter\n   */\n  function getVoteAddressMemberLength(address _voter) external view returns (uint) {\n    return voteAddressMember[_voter].length;\n  }\n\n  /**\n   * @dev Gets the Final result of voting of a claim.\n   * @param _claimId Claim id.\n   * @return verdict 1 if claim is accepted, -1 if declined.\n   */\n  function getFinalVerdict(uint _claimId) external view returns (int8 verdict) {\n    return claimVote[_claimId];\n  }\n\n  /**\n   * @dev Get number of Claims queued for submission during emergency pause.\n   */\n  function getLengthOfClaimSubmittedAtEP() external view returns (uint len) {\n    len = claimPause.length;\n  }\n\n  /**\n   * @dev Gets the index from which claim needs to be\n   * submitted when emergency pause is swithched off.\n   */\n  function getFirstClaimIndexToSubmitAfterEP() external view returns (uint indexToSubmit) {\n    indexToSubmit = claimPauseLastsubmit;\n  }\n\n  /**\n   * @dev Gets number of Claims to be reopened for voting post emergency pause period.\n   */\n  function getLengthOfClaimVotingPause() external view returns (uint len) {\n    len = claimPauseVotingEP.length;\n  }\n\n  /**\n   * @dev Gets claim details to be reopened for voting after emergency pause.\n   */\n  function getPendingClaimDetailsByIndex(\n    uint _index\n  )\n  external\n  view\n  returns (\n    uint claimId,\n    uint pendingTime,\n    bool voting\n  )\n  {\n    claimId = claimPauseVotingEP[_index].claimid;\n    pendingTime = claimPauseVotingEP[_index].pendingTime;\n    voting = claimPauseVotingEP[_index].voting;\n  }\n\n  /**\n   * @dev Gets the index from which claim needs to be reopened when emergency pause is swithched off.\n   */\n  function getFirstClaimIndexToStartVotingAfterEP() external view returns (uint firstindex) {\n    firstindex = claimStartVotingFirstIndex;\n  }\n\n  /**\n   * @dev Updates Uint Parameters of a code\n   * @param code whose details we want to update\n   * @param val value to set\n   */\n  function updateUintParameters(bytes8 code, uint val) public {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    if (code == \"CAMAXVT\") {\n      _setMaxVotingTime(val * 1 hours);\n\n    } else if (code == \"CAMINVT\") {\n\n      _setMinVotingTime(val * 1 hours);\n\n    } else if (code == \"CAPRETRY\") {\n\n      _setPayoutRetryTime(val * 1 hours);\n\n    } else if (code == \"CADEPT\") {\n\n      _setClaimDepositTime(val * 1 days);\n\n    } else if (code == \"CAREWPER\") {\n\n      _setClaimRewardPerc(val);\n\n    } else if (code == \"CAMINTH\") {\n\n      _setMinVoteThreshold(val);\n\n    } else if (code == \"CAMAXTH\") {\n\n      _setMaxVoteThreshold(val);\n\n    } else if (code == \"CACONPER\") {\n\n      _setMajorityConsensus(val);\n\n    } else if (code == \"CAPAUSET\") {\n      _setPauseDaysCA(val * 1 days);\n    } else {\n\n      revert(\"Invalid param code\");\n    }\n\n  }\n\n  /**\n   * @dev Iupgradable Interface to update dependent contract address\n   */\n  function changeDependentContractAddress() public onlyInternal {}\n\n  /**\n   * @dev Adds status under which a claim can lie.\n   * @param percCA reward percentage for claim assessor\n   * @param percMV reward percentage for members\n   */\n  function _pushStatus(uint percCA, uint percMV) internal {\n    rewardStatus.push(ClaimRewardStatus(percCA, percMV));\n  }\n\n  /**\n   * @dev adds reward incentive for all possible claim status for Claim assessors and members\n   */\n  function _addRewardIncentive() internal {\n    _pushStatus(0, 0); // 0  Pending-Claim Assessor Vote\n    _pushStatus(0, 0); // 1 Pending-Claim Assessor Vote Denied, Pending Member Vote\n    _pushStatus(0, 0); // 2 Pending-CA Vote Threshold not Reached Accept, Pending Member Vote\n    _pushStatus(0, 0); // 3 Pending-CA Vote Threshold not Reached Deny, Pending Member Vote\n    _pushStatus(0, 0); // 4 Pending-CA Consensus not reached Accept, Pending Member Vote\n    _pushStatus(0, 0); // 5 Pending-CA Consensus not reached Deny, Pending Member Vote\n    _pushStatus(100, 0); // 6 Final-Claim Assessor Vote Denied\n    _pushStatus(100, 0); // 7 Final-Claim Assessor Vote Accepted\n    _pushStatus(0, 100); // 8 Final-Claim Assessor Vote Denied, MV Accepted\n    _pushStatus(0, 100); // 9 Final-Claim Assessor Vote Denied, MV Denied\n    _pushStatus(0, 0); // 10 Final-Claim Assessor Vote Accept, MV Nodecision\n    _pushStatus(0, 0); // 11 Final-Claim Assessor Vote Denied, MV Nodecision\n    _pushStatus(0, 0); // 12 Claim Accepted Payout Pending\n    _pushStatus(0, 0); // 13 Claim Accepted No Payout\n    _pushStatus(0, 0); // 14 Claim Accepted Payout Done\n  }\n\n  /**\n   * @dev Sets Maximum time(in seconds) for which claim assessment voting is open\n   */\n  function _setMaxVotingTime(uint _time) internal {\n    maxVotingTime = _time;\n  }\n\n  /**\n   *  @dev Sets Minimum time(in seconds) for which claim assessment voting is open\n   */\n  function _setMinVotingTime(uint _time) internal {\n    minVotingTime = _time;\n  }\n\n  /**\n   *  @dev Sets Minimum vote threshold required\n   */\n  function _setMinVoteThreshold(uint val) internal {\n    minVoteThreshold = val;\n  }\n\n  /**\n   *  @dev Sets Maximum vote threshold required\n   */\n  function _setMaxVoteThreshold(uint val) internal {\n    maxVoteThreshold = val;\n  }\n\n  /**\n   *  @dev Sets the value considered as Majority Consenus in voting\n   */\n  function _setMajorityConsensus(uint val) internal {\n    majorityConsensus = val;\n  }\n\n  /**\n   * @dev Sets the payout retry time\n   */\n  function _setPayoutRetryTime(uint _time) internal {\n    payoutRetryTime = _time;\n  }\n\n  /**\n   *  @dev Sets percentage of reward given for claim assessment\n   */\n  function _setClaimRewardPerc(uint _val) internal {\n\n    claimRewardPerc = _val;\n  }\n\n  /**\n   * @dev Sets the time for which claim is deposited.\n   */\n  function _setClaimDepositTime(uint _time) internal {\n\n    claimDepositTime = _time;\n  }\n\n  /**\n   *  @dev Sets number of days claim assessment will be paused\n   */\n  function _setPauseDaysCA(uint val) internal {\n    pauseDaysCA = val;\n  }\n}\n"
96     },
97     "contracts/external/uniswap/IUniswapV2Router02.sol": {
98       "content": "pragma solidity ^0.5.0;\n\nimport './IUniswapV2Router01.sol';\n\ncontract IUniswapV2Router02 is IUniswapV2Router01 {\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n  ) external returns (uint amountETH);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external;\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external payable;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external;\n}\n"
99     },
100     "contracts/modules/oracles/TwapOracle.sol": {
101       "content": "/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\nimport \"@uniswap/lib/contracts/libraries/FixedPoint.sol\";\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\";\n\ncontract TwapOracle {\n  using FixedPoint for *;\n\n  struct Bucket {\n    uint timestamp;\n    uint price0Cumulative;\n    uint price1Cumulative;\n  }\n\n  event Updated(address indexed pair, uint timestamp, uint price0Cumulative, uint price1Cumulative);\n\n  uint constant public periodSize = 1800;\n  uint constant public periodsPerWindow = 8;\n  uint constant public windowSize = periodSize * periodsPerWindow;\n\n  address public factory;\n\n  // token pair => Bucket[8]\n  mapping(address => Bucket[8]) public buckets;\n\n  constructor (address _factory) public {\n    factory = _factory;\n  }\n\n  /* utils */\n\n  // https://uniswap.org/docs/v2/smart-contract-integration/getting-pair-addresses/\n  function _pairFor(address _factory, address tokenA, address tokenB) internal pure returns (address pair) {\n\n    // sort tokens\n    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n\n    require(token0 != token1, \"TWAP: identical addresses\");\n    require(token0 != address(0), \"TWAP: zero address\");\n\n    pair = address(uint(keccak256(abi.encodePacked(\n        hex'ff',\n        _factory,\n        keccak256(abi.encodePacked(token0, token1)),\n        hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'\n      ))));\n  }\n\n  function timestampToIndex(uint timestamp) internal pure returns (uint index) {\n    uint epochPeriod = timestamp / periodSize;\n    return epochPeriod % periodsPerWindow;\n  }\n\n  function pairFor(address tokenA, address tokenB) external view returns (address pair) {\n    return _pairFor(factory, tokenA, tokenB);\n  }\n\n  function currentBucketIndex() external view returns (uint index) {\n    return timestampToIndex(block.timestamp);\n  }\n\n  /* update */\n\n  function update(address[] calldata pairs) external {\n\n    for (uint i = 0; i < pairs.length; i++) {\n\n      // note: not reusing canUpdate() because we need the bucket variable\n      address pair = pairs[i];\n      uint index = timestampToIndex(block.timestamp);\n      Bucket storage bucket = buckets[pair][index];\n\n      if (block.timestamp - bucket.timestamp < periodSize) {\n        continue;\n      }\n\n      (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n      bucket.timestamp = block.timestamp;\n      bucket.price0Cumulative = price0Cumulative;\n      bucket.price1Cumulative = price1Cumulative;\n\n      emit Updated(pair, block.timestamp, price0Cumulative, price1Cumulative);\n    }\n  }\n\n  function canUpdate(address pair) external view returns (bool) {\n\n    uint index = timestampToIndex(block.timestamp);\n    Bucket storage bucket = buckets[pair][index];\n    uint timeElapsed = block.timestamp - bucket.timestamp;\n\n    return timeElapsed > periodSize;\n  }\n\n  /* consult */\n\n  function _getCumulativePrices(\n    address tokenIn,\n    address tokenOut\n  ) internal view returns (uint priceCumulativeStart, uint priceCumulativeEnd, uint timeElapsed) {\n\n    uint currentIndex = timestampToIndex(block.timestamp);\n    uint firstBucketIndex = (currentIndex + 1) % periodsPerWindow;\n\n    address pair = _pairFor(factory, tokenIn, tokenOut);\n    Bucket storage firstBucket = buckets[pair][firstBucketIndex];\n\n    timeElapsed = block.timestamp - firstBucket.timestamp;\n    require(timeElapsed <= windowSize, \"TWAP: missing historical reading\");\n    require(timeElapsed >= windowSize - periodSize * 2, \"TWAP: unexpected time elapsed\");\n\n    (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n\n    if (tokenIn < tokenOut) {\n      return (firstBucket.price0Cumulative, price0Cumulative, timeElapsed);\n    }\n\n    return (firstBucket.price1Cumulative, price1Cumulative, timeElapsed);\n  }\n\n  function _computeAmountOut(\n    uint priceCumulativeStart,\n    uint priceCumulativeEnd,\n    uint timeElapsed,\n    uint amountIn\n  ) internal pure returns (uint amountOut) {\n\n    // overflow is desired.\n    FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\n      uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n    );\n\n    return priceAverage.mul(amountIn).decode144();\n  }\n\n  /**\n   *  @dev Returns the amount out corresponding to the amount in for a given token using the\n   *  @dev   moving average over the time range [now - [windowSize, windowSize - periodSize * 2], now]\n   *  @dev   update must have been called for the bucket corresponding to timestamp `now - windowSize`\n   */\n  function consult(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\n\n    uint pastPriceCumulative;\n    uint currentPriceCumulative;\n    uint timeElapsed;\n\n    (pastPriceCumulative, currentPriceCumulative, timeElapsed) = _getCumulativePrices(tokenIn, tokenOut);\n\n    return _computeAmountOut(\n      pastPriceCumulative,\n      currentPriceCumulative,\n      timeElapsed,\n      amountIn\n    );\n  }\n\n}\n"
102     },
103     "contracts/external/uniswap/IUniswapV2Router01.sol": {
104       "content": "pragma solidity ^0.5.0;\n\ninterface IUniswapV2Router01 {\n\n  function factory() external pure returns (address);\n\n  function WETH() external pure returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountA, uint amountB, uint liquidity);\n\n  function addLiquidityETH(\n    address token,\n    uint amountTokenDesired,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountA, uint amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountToken, uint amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n  ) external returns (uint amountA, uint amountB);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n  ) external returns (uint amountToken, uint amountETH);\n\n  function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n  external\n  payable\n  returns (uint[] memory amounts);\n\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n  external\n  returns (uint[] memory amounts);\n\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n  external\n  returns (uint[] memory amounts);\n\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n  external\n  payable\n  returns (uint[] memory amounts);\n\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
105     },
106     "@uniswap/lib/contracts/libraries/FixedPoint.sol": {
107       "content": "pragma solidity >=0.4.0;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n        uint z;\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n}\n"
108     },
109     "@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol": {
110       "content": "pragma solidity >=0.5.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}\n"
111     },
112     "contracts/modules/governance/external/IGovernance.sol": {
113       "content": "/* Copyright (C) 2017 GovBlocks.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\ncontract IGovernance {\n\n  event Proposal(\n    address indexed proposalOwner,\n    uint256 indexed proposalId,\n    uint256 dateAdd,\n    string proposalTitle,\n    string proposalSD,\n    string proposalDescHash\n  );\n\n  event Solution(\n    uint256 indexed proposalId,\n    address indexed solutionOwner,\n    uint256 indexed solutionId,\n    string solutionDescHash,\n    uint256 dateAdd\n  );\n\n  event Vote(\n    address indexed from,\n    uint256 indexed proposalId,\n    uint256 indexed voteId,\n    uint256 dateAdd,\n    uint256 solutionChosen\n  );\n\n  event RewardClaimed(\n    address indexed member,\n    uint gbtReward\n  );\n\n  /// @dev VoteCast event is called whenever a vote is cast that can potentially close the proposal.\n  event VoteCast (uint256 proposalId);\n\n  /// @dev ProposalAccepted event is called when a proposal is accepted so that a server can listen that can\n  ///      call any offchain actions\n  event ProposalAccepted (uint256 proposalId);\n\n  /// @dev CloseProposalOnTime event is called whenever a proposal is created or updated to close it on time.\n  event CloseProposalOnTime (\n    uint256 indexed proposalId,\n    uint256 time\n  );\n\n  /// @dev ActionSuccess event is called whenever an onchain action is executed.\n  event ActionSuccess (\n    uint256 proposalId\n  );\n\n  /// @dev Creates a new proposal\n  /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\n  /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\n  function createProposal(\n    string calldata _proposalTitle,\n    string calldata _proposalSD,\n    string calldata _proposalDescHash,\n    uint _categoryId\n  )\n  external;\n\n  /// @dev Edits the details of an existing proposal and creates new version\n  /// @param _proposalId Proposal id that details needs to be updated\n  /// @param _proposalDescHash Proposal description hash having long and short description of proposal.\n  function updateProposal(\n    uint _proposalId,\n    string calldata _proposalTitle,\n    string calldata _proposalSD,\n    string calldata _proposalDescHash\n  )\n  external;\n\n  /// @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\n  function categorizeProposal(\n    uint _proposalId,\n    uint _categoryId,\n    uint _incentives\n  )\n  external;\n\n  /// @dev Submit proposal with solution\n  /// @param _proposalId Proposal id\n  /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\n  function submitProposalWithSolution(\n    uint _proposalId,\n    string calldata _solutionHash,\n    bytes calldata _action\n  )\n  external;\n\n  /// @dev Creates a new proposal with solution and votes for the solution\n  /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\n  /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\n  /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\n  function createProposalwithSolution(\n    string calldata _proposalTitle,\n    string calldata _proposalSD,\n    string calldata _proposalDescHash,\n    uint _categoryId,\n    string calldata _solutionHash,\n    bytes calldata _action\n  )\n  external;\n\n  /// @dev Casts vote\n  /// @param _proposalId Proposal id\n  /// @param _solutionChosen solution chosen while voting. _solutionChosen[0] is the chosen solution\n  function submitVote(uint _proposalId, uint _solutionChosen) external;\n\n  function closeProposal(uint _proposalId) external;\n\n  function claimReward(address _memberAddress, uint _maxRecords) external returns (uint pendingDAppReward);\n\n  function proposal(uint _proposalId)\n  external\n  view\n  returns (\n    uint proposalId,\n    uint category,\n    uint status,\n    uint finalVerdict,\n    uint totalReward\n  );\n\n  function canCloseProposal(uint _proposalId) public view returns (uint closeValue);\n\n  function allowedToCatgorize() public view returns (uint roleId);\n\n}\n"
114     },
115     "contracts/modules/governance/external/IProposalCategory.sol": {
116       "content": "/* Copyright (C) 2017 GovBlocks.io\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\ncontract IProposalCategory {\n\n  event Category(\n    uint indexed categoryId,\n    string categoryName,\n    string actionHash\n  );\n\n  /// @dev Adds new category\n  /// @param _name Category name\n  /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\n  /// @param _allowedToCreateProposal Member roles allowed to create the proposal\n  /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\n  /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\n  /// @param _closingTime Vote closing time for Each voting layer\n  /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\n  /// @param _contractAddress address of contract to call after proposal is accepted\n  /// @param _contractName name of contract to be called after proposal is accepted\n  /// @param _incentives rewards to distributed after proposal is accepted\n  function addCategory(\n    string calldata _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] calldata _allowedToCreateProposal,\n    uint _closingTime,\n    string calldata _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] calldata _incentives\n  )\n  external;\n\n  /// @dev gets category details\n  function category(uint _categoryId)\n  external\n  view\n  returns (\n    uint categoryId,\n    uint memberRoleToVote,\n    uint majorityVotePerc,\n    uint quorumPerc,\n    uint[] memory allowedToCreateProposal,\n    uint closingTime,\n    uint minStake\n  );\n\n  ///@dev gets category action details\n  function categoryAction(uint _categoryId)\n  external\n  view\n  returns (\n    uint categoryId,\n    address contractAddress,\n    bytes2 contractName,\n    uint defaultIncentive\n  );\n\n  /// @dev Gets Total number of categories added till now\n  function totalCategories() external view returns (uint numberOfCategories);\n\n  /// @dev Updates category details\n  /// @param _categoryId Category id that needs to be updated\n  /// @param _name Category name\n  /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\n  /// @param _allowedToCreateProposal Member roles allowed to create the proposal\n  /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\n  /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\n  /// @param _closingTime Vote closing time for Each voting layer\n  /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\n  /// @param _contractAddress address of contract to call after proposal is accepted\n  /// @param _contractName name of contract to be called after proposal is accepted\n  /// @param _incentives rewards to distributed after proposal is accepted\n  function updateCategory(\n    uint _categoryId,\n    string memory _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] memory _allowedToCreateProposal,\n    uint _closingTime,\n    string memory _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] memory _incentives\n  )\n  public;\n\n}\n"
117     }
118   },
119   "settings": {
120     "optimizer": {
121       "enabled": true,
122       "runs": 200
123     },
124     "outputSelection": {
125       "*": {
126         "*": [
127           "evm.bytecode",
128           "evm.deployedBytecode",
129           "abi"
130         ]
131       }
132     },
133     "libraries": {
134       "contracts/modules/capital/SwapAgent.sol": {
135         "SwapAgent": "0xcafea6a946406b0b48a77348a4f70dfeed0f4664"
136       }
137     }
138   }
139 }}