1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "istanbul",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "enabled": true,
12       "runs": 100
13     },
14     "remappings": [],
15     "outputSelection": {
16       "*": {
17         "*": [
18           "evm.bytecode",
19           "evm.deployedBytecode",
20           "devdoc",
21           "userdoc",
22           "metadata",
23           "abi"
24         ]
25       }
26     }
27   },
28   "sources": {
29     "@openzeppelin/contracts-ethereum-package/contracts/introspection/IERC165.sol": {
30       "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
31     },
32     "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol": {
33       "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
34     },
35     "@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721.sol": {
36       "content": "pragma solidity ^0.6.2;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
37     },
38     "@openzeppelin/contracts/cryptography/MerkleProof.sol": {
39       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
40     },
41     "contracts/interfaces/ICommunityRewards.sol": {
42       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721.sol\";\n\nimport \"../interfaces/IERC20withDec.sol\";\n\ninterface ICommunityRewards is IERC721 {\n  function rewardsToken() external view returns (IERC20withDec);\n\n  function claimableRewards(uint256 tokenId) external view returns (uint256 rewards);\n\n  function totalVestedAt(\n    uint256 start,\n    uint256 end,\n    uint256 granted,\n    uint256 cliffLength,\n    uint256 vestingInterval,\n    uint256 revokedAt,\n    uint256 time\n  ) external pure returns (uint256 rewards);\n\n  function grant(\n    address recipient,\n    uint256 amount,\n    uint256 vestingLength,\n    uint256 cliffLength,\n    uint256 vestingInterval\n  ) external returns (uint256 tokenId);\n\n  function loadRewards(uint256 rewards) external;\n\n  function revokeGrant(uint256 tokenId) external;\n\n  function getReward(uint256 tokenId) external;\n\n  event RewardAdded(uint256 reward);\n  event Granted(\n    address indexed user,\n    uint256 indexed tokenId,\n    uint256 amount,\n    uint256 vestingLength,\n    uint256 cliffLength,\n    uint256 vestingInterval\n  );\n  event GrantRevoked(uint256 indexed tokenId, uint256 totalUnvested);\n  event RewardPaid(address indexed user, uint256 indexed tokenId, uint256 reward);\n}\n"
43     },
44     "contracts/interfaces/IERC20withDec.sol": {
45       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\n\n/*\nOnly addition is the `decimals` function, which we need, and which both our Fidu and USDC use, along with most ERC20's.\n*/\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20withDec is IERC20 {\n  /**\n   * @dev Returns the number of decimals used for the token\n   */\n  function decimals() external view returns (uint8);\n}\n"
46     },
47     "contracts/interfaces/IMerkleDistributor.sol": {
48       "content": "// SPDX-License-Identifier: GPL-3.0-only\n// solhint-disable-next-line max-line-length\n// Adapted from https://github.com/Uniswap/merkle-distributor/blob/c3255bfa2b684594ecd562cacd7664b0f18330bf/contracts/interfaces/IMerkleDistributor.sol.\npragma solidity 0.6.12;\n\n/// @notice Enables the granting of a CommunityRewards grant, if the grant details exist in this\n/// contract's Merkle root.\ninterface IMerkleDistributor {\n  /// @notice Returns the address of the CommunityRewards contract whose grants are distributed by this contract.\n  function communityRewards() external view returns (address);\n\n  /// @notice Returns the merkle root of the merkle tree containing grant details available to accept.\n  function merkleRoot() external view returns (bytes32);\n\n  /// @notice Returns true if the index has been marked accepted.\n  function isGrantAccepted(uint256 index) external view returns (bool);\n\n  /// @notice Causes the sender to accept the grant consisting of the given details. Reverts if\n  /// the inputs (which includes who the sender is) are invalid.\n  function acceptGrant(\n    uint256 index,\n    uint256 amount,\n    uint256 vestingLength,\n    uint256 cliffLength,\n    uint256 vestingInterval,\n    bytes32[] calldata merkleProof\n  ) external;\n\n  /// @notice This event is triggered whenever a call to #acceptGrant succeeds.\n  event GrantAccepted(\n    uint256 indexed tokenId,\n    uint256 indexed index,\n    address indexed account,\n    uint256 amount,\n    uint256 vestingLength,\n    uint256 cliffLength,\n    uint256 vestingInterval\n  );\n}\n"
49     },
50     "contracts/rewards/MerkleDistributor.sol": {
51       "content": "// SPDX-License-Identifier: GPL-3.0-only\n// solhint-disable-next-line max-line-length\n// Adapted from https://github.com/Uniswap/merkle-distributor/blob/c3255bfa2b684594ecd562cacd7664b0f18330bf/contracts/MerkleDistributor.sol.\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\n\nimport \"../interfaces/ICommunityRewards.sol\";\nimport \"../interfaces/IMerkleDistributor.sol\";\n\ncontract MerkleDistributor is IMerkleDistributor {\n  address public immutable override communityRewards;\n  bytes32 public immutable override merkleRoot;\n\n  // @dev This is a packed array of booleans.\n  mapping(uint256 => uint256) private acceptedBitMap;\n\n  constructor(address communityRewards_, bytes32 merkleRoot_) public {\n    require(communityRewards_ != address(0), \"Cannot use the null address\");\n    require(merkleRoot_ != 0, \"Invalid merkle root provided\");\n    communityRewards = communityRewards_;\n    merkleRoot = merkleRoot_;\n  }\n\n  function isGrantAccepted(uint256 index) public view override returns (bool) {\n    uint256 acceptedWordIndex = index / 256;\n    uint256 acceptedBitIndex = index % 256;\n    uint256 acceptedWord = acceptedBitMap[acceptedWordIndex];\n    uint256 mask = (1 << acceptedBitIndex);\n    return acceptedWord & mask == mask;\n  }\n\n  function _setGrantAccepted(uint256 index) private {\n    uint256 acceptedWordIndex = index / 256;\n    uint256 acceptedBitIndex = index % 256;\n    acceptedBitMap[acceptedWordIndex] = acceptedBitMap[acceptedWordIndex] | (1 << acceptedBitIndex);\n  }\n\n  function acceptGrant(\n    uint256 index,\n    uint256 amount,\n    uint256 vestingLength,\n    uint256 cliffLength,\n    uint256 vestingInterval,\n    bytes32[] calldata merkleProof\n  ) external override {\n    require(!isGrantAccepted(index), \"Grant already accepted\");\n\n    // Verify the merkle proof.\n    //\n    /// @dev Per the Warning in\n    /// https://github.com/ethereum/solidity/blob/v0.6.12/docs/abi-spec.rst#non-standard-packed-mode,\n    /// it is important that no more than one of the arguments to `abi.encodePacked()` here be a\n    /// dynamic type (see definition in\n    /// https://github.com/ethereum/solidity/blob/v0.6.12/docs/abi-spec.rst#formal-specification-of-the-encoding).\n    bytes32 node = keccak256(abi.encodePacked(index, msg.sender, amount, vestingLength, cliffLength, vestingInterval));\n    require(MerkleProof.verify(merkleProof, merkleRoot, node), \"Invalid proof\");\n\n    // Mark it accepted and perform the granting.\n    _setGrantAccepted(index);\n    uint256 tokenId = ICommunityRewards(communityRewards).grant(\n      msg.sender,\n      amount,\n      vestingLength,\n      cliffLength,\n      vestingInterval\n    );\n\n    emit GrantAccepted(tokenId, index, msg.sender, amount, vestingLength, cliffLength, vestingInterval);\n  }\n}\n"
52     }
53   }
54 }}