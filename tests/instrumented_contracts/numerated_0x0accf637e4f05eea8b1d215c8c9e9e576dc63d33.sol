1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/PartyBidFactory.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.5;\n\nimport {InitializedProxy} from \"./InitializedProxy.sol\";\nimport {PartyBid} from \"./PartyBid.sol\";\nimport {Structs} from \"./Structs.sol\";\n\n/**\n * @title PartyBid Factory\n * @author Anna Carroll\n *\n * WARNING: A malicious MarketWrapper contract could be used to steal user funds;\n * A poorly implemented MarketWrapper contract could permanently lose access to the NFT.\n * When deploying a PartyBid, exercise extreme caution.\n * Only use MarketWrapper contracts that have been audited and tested.\n */\ncontract PartyBidFactory {\n    //======== Events ========\n\n    event PartyBidDeployed(\n        address partyBidProxy,\n        address creator,\n        address nftContract,\n        uint256 tokenId,\n        address marketWrapper,\n        uint256 auctionId,\n        address splitRecipient,\n        uint256 splitBasisPoints,\n        address gatedToken,\n        uint256 gatedTokenAmount,\n        string name,\n        string symbol\n    );\n\n    //======== Immutable storage =========\n\n    address public immutable logic;\n    address public immutable partyDAOMultisig;\n    address public immutable tokenVaultFactory;\n    address public immutable weth;\n\n    //======== Mutable storage =========\n\n    // PartyBid proxy => block number deployed at\n    mapping(address => uint256) public deployedAt;\n\n    //======== Constructor =========\n\n    constructor(\n        address _partyDAOMultisig,\n        address _tokenVaultFactory,\n        address _weth\n    ) {\n        partyDAOMultisig = _partyDAOMultisig;\n        tokenVaultFactory = _tokenVaultFactory;\n        weth = _weth;\n        // deploy logic contract\n        PartyBid _logicContract = new PartyBid(_partyDAOMultisig, _tokenVaultFactory, _weth);\n        // store logic contract address\n        logic = address(_logicContract);\n    }\n\n    //======== Deploy function =========\n\n    function startParty(\n        address _marketWrapper,\n        address _nftContract,\n        uint256 _tokenId,\n        uint256 _auctionId,\n        Structs.AddressAndAmount calldata _split,\n        Structs.AddressAndAmount calldata _tokenGate,\n        string memory _name,\n        string memory _symbol\n    ) external returns (address partyBidProxy) {\n        bytes memory _initializationCalldata =\n            abi.encodeWithSelector(\n                PartyBid.initialize.selector,\n                _marketWrapper,\n                _nftContract,\n                _tokenId,\n                _auctionId,\n                _split,\n                _tokenGate,\n                _name,\n                _symbol\n            );\n\n        partyBidProxy = address(\n            new InitializedProxy(\n                logic,\n                _initializationCalldata\n            )\n        );\n\n        deployedAt[partyBidProxy] = block.number;\n\n        emit PartyBidDeployed(\n            partyBidProxy,\n            msg.sender,\n            _nftContract,\n            _tokenId,\n            _marketWrapper,\n            _auctionId,\n            _split.addr,\n            _split.amount,\n            _tokenGate.addr,\n            _tokenGate.amount,\n            _name,\n            _symbol\n        );\n    }\n}\n"
6     },
7     "contracts/InitializedProxy.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.5;\n\n/**\n * @title InitializedProxy\n * @author Anna Carroll\n */\ncontract InitializedProxy {\n    // address of logic contract\n    address public immutable logic;\n\n    // ======== Constructor =========\n\n    constructor(\n        address _logic,\n        bytes memory _initializationCalldata\n    ) {\n        logic = _logic;\n        // Delegatecall into the logic contract, supplying initialization calldata\n        (bool _ok, bytes memory returnData) =\n            _logic.delegatecall(_initializationCalldata);\n        // Revert if delegatecall to implementation reverts\n        require(_ok, string(returnData));\n    }\n\n    // ======== Fallback =========\n\n    fallback() external payable {\n        address _impl = logic;\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            switch result\n                case 0 {\n                    revert(ptr, size)\n                }\n                default {\n                    return(ptr, size)\n                }\n        }\n    }\n\n    // ======== Receive =========\n\n    receive() external payable {} // solhint-disable-line no-empty-blocks\n}\n"
9     },
10     "contracts/PartyBid.sol": {
11       "content": "/*\n\n      ___           ___           ___           ___           ___           ___                       ___\n     /\\  \\         /\\  \\         /\\  \\         /\\  \\         |\\__\\         /\\  \\          ___        /\\  \\\n    /::\\  \\       /::\\  \\       /::\\  \\        \\:\\  \\        |:|  |       /::\\  \\        /\\  \\      /::\\  \\\n   /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\        \\:\\  \\       |:|  |      /:/\\:\\  \\       \\:\\  \\    /:/\\:\\  \\\n  /::\\~\\:\\  \\   /::\\~\\:\\  \\   /::\\~\\:\\  \\       /::\\  \\      |:|__|__   /::\\~\\:\\__\\      /::\\__\\  /:/  \\:\\__\\\n /:/\\:\\ \\:\\__\\ /:/\\:\\ \\:\\__\\ /:/\\:\\ \\:\\__\\     /:/\\:\\__\\     /::::\\__\\ /:/\\:\\ \\:|__|  __/:/\\/__/ /:/__/ \\:|__|\n \\/__\\:\\/:/  / \\/__\\:\\/:/  / \\/_|::\\/:/  /    /:/  \\/__/    /:/~~/~    \\:\\~\\:\\/:/  / /\\/:/  /    \\:\\  \\ /:/  /\n      \\::/  /       \\::/  /     |:|::/  /    /:/  /        /:/  /       \\:\\ \\::/  /  \\::/__/      \\:\\  /:/  /\n       \\/__/        /:/  /      |:|\\/__/     \\/__/         \\/__/         \\:\\/:/  /    \\:\\__\\       \\:\\/:/  /\n                   /:/  /       |:|  |                                    \\::/__/      \\/__/        \\::/__/\n                   \\/__/         \\|__|                                     ~~                        ~~\n\nAnna Carroll for PartyDAO\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.5;\n\n// ============ Internal Imports ============\nimport {Party} from \"./Party.sol\";\nimport {IMarketWrapper} from \"./market-wrapper/IMarketWrapper.sol\";\nimport {Structs} from \"./Structs.sol\";\n\ncontract PartyBid is Party {\n    // partyStatus Transitions:\n    //   (1) PartyStatus.ACTIVE on deploy\n    //   (2) PartyStatus.WON or PartyStatus.LOST on finalize()\n\n    // ============ Internal Constants ============\n\n    // PartyBid version 3\n    uint16 public constant VERSION = 3;\n\n    // ============ Public Not-Mutated Storage ============\n\n    // market wrapper contract exposing interface for\n    // market auctioning the NFT\n    IMarketWrapper public marketWrapper;\n    // ID of auction within market contract\n    uint256 public auctionId;\n\n    // ============ Public Mutable Storage ============\n\n    // the highest bid submitted by PartyBid\n    uint256 public highestBid;\n\n    // ============ Events ============\n\n    event Bid(uint256 amount);\n\n    event Finalized(PartyStatus result, uint256 totalSpent, uint256 fee, uint256 totalContributed);\n\n    // ======== Constructor =========\n\n    constructor(\n        address _partyDAOMultisig,\n        address _tokenVaultFactory,\n        address _weth\n    ) Party(_partyDAOMultisig, _tokenVaultFactory, _weth) {}\n\n    // ======== Initializer =========\n\n    function initialize(\n        address _marketWrapper,\n        address _nftContract,\n        uint256 _tokenId,\n        uint256 _auctionId,\n        Structs.AddressAndAmount calldata _split,\n        Structs.AddressAndAmount calldata _tokenGate,\n        string memory _name,\n        string memory _symbol\n    ) external initializer {\n        // validate auction exists\n        require(\n            IMarketWrapper(_marketWrapper).auctionIdMatchesToken(\n                _auctionId,\n                _nftContract,\n                _tokenId\n            ),\n            \"PartyBid::initialize: auctionId doesn't match token\"\n        );\n        // initialize & validate shared Party variables\n        __Party_init(_nftContract, _tokenId, _split, _tokenGate, _name, _symbol);\n        // set PartyBid-specific state variables\n        marketWrapper = IMarketWrapper(_marketWrapper);\n        auctionId = _auctionId;\n    }\n\n    // ======== External: Contribute =========\n\n    /**\n     * @notice Contribute to the Party's treasury\n     * while the Party is still active\n     * @dev Emits a Contributed event upon success; callable by anyone\n     */\n    function contribute() external payable nonReentrant {\n        _contribute();\n    }\n\n    // ======== External: Bid =========\n\n    /**\n     * @notice Submit a bid to the Market\n     * @dev Reverts if insufficient funds to place the bid and pay PartyDAO fees,\n     * or if any external auction checks fail (including if PartyBid is current high bidder)\n     * Emits a Bid event upon success.\n     * Callable by any contributor\n     */\n    function bid() external nonReentrant {\n        require(\n            partyStatus == PartyStatus.ACTIVE,\n            \"PartyBid::bid: auction not active\"\n        );\n        require(\n            totalContributed[msg.sender] > 0,\n            \"PartyBid::bid: only contributors can bid\"\n        );\n        require(\n            address(this) !=\n                marketWrapper.getCurrentHighestBidder(\n                    auctionId\n                ),\n            \"PartyBid::bid: already highest bidder\"\n        );\n        require(\n            !marketWrapper.isFinalized(auctionId),\n            \"PartyBid::bid: auction already finalized\"\n        );\n        // get the minimum next bid for the auction\n        uint256 _bid = marketWrapper.getMinimumBid(auctionId);\n        // ensure there is enough ETH to place the bid including PartyDAO fee\n        require(\n            _bid <= getMaximumBid(),\n            \"PartyBid::bid: insufficient funds to bid\"\n        );\n        // submit bid to Auction contract using delegatecall\n        (bool success, bytes memory returnData) =\n            address(marketWrapper).delegatecall(\n                abi.encodeWithSignature(\"bid(uint256,uint256)\", auctionId, _bid)\n            );\n        require(\n            success,\n            string(\n                abi.encodePacked(\n                    \"PartyBid::bid: place bid failed: \",\n                    returnData\n                )\n            )\n        );\n        // update highest bid submitted & emit success event\n        highestBid = _bid;\n        emit Bid(_bid);\n    }\n\n    // ======== External: Finalize =========\n\n    /**\n     * @notice Finalize the state of the auction\n     * @dev Emits a Finalized event upon success; callable by anyone\n     */\n    function finalize() external nonReentrant {\n        require(\n            partyStatus == PartyStatus.ACTIVE,\n            \"PartyBid::finalize: auction not active\"\n        );\n        // finalize auction if it hasn't already been done\n        if (!marketWrapper.isFinalized(auctionId)) {\n            marketWrapper.finalize(auctionId);\n        }\n        // after the auction has been finalized,\n        // if the NFT is owned by the PartyBid, then the PartyBid won the auction\n        address _owner = _getOwner();\n        partyStatus = _owner == address(this) ? PartyStatus.WON : PartyStatus.LOST;\n        uint256 _ethFee;\n        // if the auction was won,\n        if (partyStatus == PartyStatus.WON) {\n            // record totalSpent,\n            // send ETH fees to PartyDAO,\n            // fractionalize the Token\n            // send Token fees to PartyDAO & split proceeds to split recipient\n            _ethFee = _closeSuccessfulParty(highestBid);\n        }\n        // set the contract status & emit result\n        emit Finalized(partyStatus, totalSpent, _ethFee, totalContributedToParty);\n    }\n\n    // ======== Public: Utility Calculations =========\n\n    /**\n     * @notice The maximum bid that can be submitted\n     * while paying the ETH fee to PartyDAO\n     * @return _maxBid the maximum bid\n     */\n    function getMaximumBid() public view returns (uint256 _maxBid) {\n        _maxBid = getMaximumSpend();\n    }\n}\n"
12     },
13     "contracts/Structs.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.5;\n\ninterface Structs {\n    struct AddressAndAmount {\n        address addr;\n        uint256 amount;\n    }\n}\n"
15     },
16     "contracts/Party.sol": {
17       "content": "/*\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\_____________________________________________________________/\\\\\\\\\\\\\\\\\\\\\\\\________/\\\\\\\\\\\\\\\\\\__________/\\\\\\\\\\______\n _\\/\\\\\\/////////\\\\\\__________________________________________________________\\/\\\\\\////////\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\\\\\______/\\\\\\///\\\\\\____\n  _\\/\\\\\\_______\\/\\\\\\__________________________________/\\\\\\_________/\\\\\\__/\\\\\\_\\/\\\\\\______\\//\\\\\\__/\\\\\\/////////\\\\\\___/\\\\\\/__\\///\\\\\\__\n   _\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/___/\\\\\\\\\\\\\\\\\\_____/\\\\/\\\\\\\\\\\\\\___/\\\\\\\\\\\\\\\\\\\\\\___\\//\\\\\\/\\\\\\__\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_______\\/\\\\\\__/\\\\\\______\\//\\\\\\_\n    _\\/\\\\\\/////////____\\////////\\\\\\___\\/\\\\\\/////\\\\\\_\\////\\\\\\////_____\\//\\\\\\\\\\___\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_\n     _\\/\\\\\\_______________/\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\___\\///_____\\/\\\\\\__________\\//\\\\\\____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\/////////\\\\\\_\\//\\\\\\______/\\\\\\__\n      _\\/\\\\\\______________/\\\\\\/////\\\\\\__\\/\\\\\\____________\\/\\\\\\_/\\\\___/\\\\_/\\\\\\_____\\/\\\\\\_______/\\\\\\__\\/\\\\\\_______\\/\\\\\\__\\///\\\\\\__/\\\\\\____\n       _\\/\\\\\\_____________\\//\\\\\\\\\\\\\\\\/\\\\_\\/\\\\\\____________\\//\\\\\\\\\\___\\//\\\\\\\\/______\\/\\\\\\\\\\\\\\\\\\\\\\\\/___\\/\\\\\\_______\\/\\\\\\____\\///\\\\\\\\\\/_____\n        _\\///_______________\\////////\\//__\\///______________\\/////_____\\////________\\////////////_____\\///________\\///_______\\/////_______\n\nAnna Carroll for PartyDAO\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.5;\n\n// ============ External Imports: Inherited Contracts ============\n// NOTE: we inherit from OpenZeppelin upgradeable contracts\n// because of the proxy structure used for cheaper deploys\n// (the proxies are NOT actually upgradeable)\nimport {\nReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {\nERC721HolderUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\n// ============ External Imports: External Contracts & Contract Interfaces ============\nimport {\nIERC721VaultFactory\n} from \"./external/interfaces/IERC721VaultFactory.sol\";\nimport {ITokenVault} from \"./external/interfaces/ITokenVault.sol\";\nimport {IWETH} from \"./external/interfaces/IWETH.sol\";\nimport {\nIERC721Metadata\n} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {\nIERC20\n} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// ============ Internal Imports ============\nimport {Structs} from \"./Structs.sol\";\n\ncontract Party is ReentrancyGuardUpgradeable, ERC721HolderUpgradeable {\n    // ============ Enums ============\n\n    // State Transitions:\n    //   (1) ACTIVE on deploy\n    //   (2) WON if the Party has won the token\n    //   (2) LOST if the Party is over & did not win the token\n    enum PartyStatus {ACTIVE, WON, LOST}\n\n    // ============ Structs ============\n\n    struct Contribution {\n        uint256 amount;\n        uint256 previousTotalContributedToParty;\n    }\n\n    // ============ Internal Constants ============\n\n    // tokens are minted at a rate of 1 ETH : 1000 tokens\n    uint16 internal constant TOKEN_SCALE = 1000;\n    // PartyDAO receives an ETH fee equal to 2.5% of the amount spent\n    uint16 internal constant ETH_FEE_BASIS_POINTS = 250;\n    // PartyDAO receives a token fee equal to 2.5% of the total token supply\n    uint16 internal constant TOKEN_FEE_BASIS_POINTS = 250;\n    // token is relisted on Fractional with an\n    // initial reserve price equal to 2x the price of the token\n    uint8 internal constant RESALE_MULTIPLIER = 2;\n\n    // ============ Immutables ============\n\n    address public immutable partyFactory;\n    address public immutable partyDAOMultisig;\n    IERC721VaultFactory public immutable tokenVaultFactory;\n    IWETH public immutable weth;\n\n    // ============ Public Not-Mutated Storage ============\n\n    // NFT contract\n    IERC721Metadata public nftContract;\n    // ID of token within NFT contract\n    uint256 public tokenId;\n    // Fractionalized NFT vault responsible for post-purchase experience\n    ITokenVault public tokenVault;\n    // the address that will receive a portion of the tokens\n    // if the Party successfully buys the token\n    address public splitRecipient;\n    // percent of the total token supply\n    // taken by the splitRecipient\n    uint256 public splitBasisPoints;\n    // address of token that users need to hold to contribute\n    // address(0) if party is not token gated\n    IERC20 public gatedToken;\n    // amount of token that users need to hold to contribute\n    // 0 if party is not token gated\n    uint256 public gatedTokenAmount;\n    // ERC-20 name and symbol for fractional tokens\n    string public name;\n    string public symbol;\n\n    // ============ Public Mutable Storage ============\n\n    // state of the contract\n    PartyStatus public partyStatus;\n    // total ETH deposited by all contributors\n    uint256 public totalContributedToParty;\n    // the total spent buying the token;\n    // 0 if the NFT is not won; price of token + 2.5% PartyDAO fee if NFT is won\n    uint256 public totalSpent;\n    // contributor => array of Contributions\n    mapping(address => Contribution[]) public contributions;\n    // contributor => total amount contributed\n    mapping(address => uint256) public totalContributed;\n    // contributor => true if contribution has been claimed\n    mapping(address => bool) public claimed;\n\n    // ============ Events ============\n\n    event Contributed(\n        address indexed contributor,\n        uint256 amount,\n        uint256 previousTotalContributedToParty,\n        uint256 totalFromContributor\n    );\n\n    event Claimed(\n        address indexed contributor,\n        uint256 totalContributed,\n        uint256 excessContribution,\n        uint256 tokenAmount\n    );\n\n    // ======== Modifiers =========\n\n    modifier onlyPartyDAO() {\n        require(\n            msg.sender == partyDAOMultisig,\n            \"Party:: only PartyDAO multisig\"\n        );\n        _;\n    }\n\n    // ======== Constructor =========\n\n    constructor(\n        address _partyDAOMultisig,\n        address _tokenVaultFactory,\n        address _weth\n    ) {\n        partyFactory = msg.sender;\n        partyDAOMultisig = _partyDAOMultisig;\n        tokenVaultFactory = IERC721VaultFactory(_tokenVaultFactory);\n        weth = IWETH(_weth);\n    }\n\n    // ======== Internal: Initialize =========\n\n    function __Party_init(\n        address _nftContract,\n        uint256 _tokenId,\n        Structs.AddressAndAmount calldata _split,\n        Structs.AddressAndAmount calldata _tokenGate,\n        string memory _name,\n        string memory _symbol\n    ) internal {\n        require(msg.sender == partyFactory, \"Party::__Party_init: only factory can init\");\n        // validate token exists (must set nftContract & tokenId before _getOwner)\n        nftContract = IERC721Metadata(_nftContract);\n        tokenId = _tokenId;\n        require(_getOwner() != address(0), \"Party::__Party_init: NFT getOwner failed\");\n        // if split is non-zero,\n        if (_split.addr != address(0) && _split.amount != 0) {\n            // validate that party split won't retain the total token supply\n            uint256 _remainingBasisPoints = 10000 - TOKEN_FEE_BASIS_POINTS;\n            require(_split.amount < _remainingBasisPoints, \"Party::__Party_init: basis points can't take 100%\");\n            splitBasisPoints = _split.amount;\n            splitRecipient = _split.addr;\n        }\n        // if token gating is non-zero\n        if (_tokenGate.addr != address(0) && _tokenGate.amount != 0) {\n            // call totalSupply to verify that address is ERC-20 token contract\n            IERC20(_tokenGate.addr).totalSupply();\n            gatedToken = IERC20(_tokenGate.addr);\n            gatedTokenAmount = _tokenGate.amount;\n        }\n        // initialize ReentrancyGuard and ERC721Holder\n        __ReentrancyGuard_init();\n        __ERC721Holder_init();\n        // set storage variables\n        name = _name;\n        symbol = _symbol;\n    }\n\n    // ======== Internal: Contribute =========\n\n    /**\n     * @notice Contribute to the Party's treasury\n     * while the Party is still active\n     * @dev Emits a Contributed event upon success; callable by anyone\n     */\n    function _contribute() internal {\n        require(\n            partyStatus == PartyStatus.ACTIVE,\n            \"Party::contribute: party not active\"\n        );\n        address _contributor = msg.sender;\n        uint256 _amount = msg.value;\n        // if token gated, require that contributor has balance of gated tokens\n        if (address(gatedToken) != address(0)) {\n            require(gatedToken.balanceOf(_contributor) >= gatedTokenAmount, \"Party::contribute: must hold tokens to contribute\");\n        }\n        require(_amount > 0, \"Party::contribute: must contribute more than 0\");\n        // get the current contract balance\n        uint256 _previousTotalContributedToParty = totalContributedToParty;\n        // add contribution to contributor's array of contributions\n        Contribution memory _contribution =\n            Contribution({\n                amount: _amount,\n                previousTotalContributedToParty: _previousTotalContributedToParty\n            });\n        contributions[_contributor].push(_contribution);\n        // add to contributor's total contribution\n        totalContributed[_contributor] = totalContributed[_contributor] + _amount;\n        // add to party's total contribution & emit event\n        totalContributedToParty = _previousTotalContributedToParty + _amount;\n        emit Contributed(\n            _contributor,\n            _amount,\n            _previousTotalContributedToParty,\n            totalContributed[_contributor]\n        );\n    }\n\n    // ======== External: Claim =========\n\n    /**\n     * @notice Claim the tokens and excess ETH owed\n     * to a single contributor after the party has ended\n     * @dev Emits a Claimed event upon success\n     * callable by anyone (doesn't have to be the contributor)\n     * @param _contributor the address of the contributor\n     */\n    function claim(address _contributor) external nonReentrant {\n        // ensure party has finalized\n        require(\n            partyStatus != PartyStatus.ACTIVE,\n            \"Party::claim: party not finalized\"\n        );\n        // ensure contributor submitted some ETH\n        require(\n            totalContributed[_contributor] != 0,\n            \"Party::claim: not a contributor\"\n        );\n        // ensure the contributor hasn't already claimed\n        require(\n            !claimed[_contributor],\n            \"Party::claim: contribution already claimed\"\n        );\n        // mark the contribution as claimed\n        claimed[_contributor] = true;\n        // calculate the amount of fractional NFT tokens owed to the user\n        // based on how much ETH they contributed towards the party,\n        // and the amount of excess ETH owed to the user\n        (uint256 _tokenAmount, uint256 _ethAmount) =\n        getClaimAmounts(_contributor);\n        // transfer tokens to contributor for their portion of ETH used\n        _transferTokens(_contributor, _tokenAmount);\n        // if there is excess ETH, send it back to the contributor\n        _transferETHOrWETH(_contributor, _ethAmount);\n        emit Claimed(\n            _contributor,\n            totalContributed[_contributor],\n            _ethAmount,\n            _tokenAmount\n        );\n    }\n\n    // ======== External: Emergency Escape Hatches (PartyDAO Multisig Only) =========\n\n    /**\n     * @notice Escape hatch: in case of emergency,\n     * PartyDAO can use emergencyWithdrawEth to withdraw\n     * ETH stuck in the contract\n     */\n    function emergencyWithdrawEth(uint256 _value)\n        external\n        onlyPartyDAO\n    {\n        _transferETHOrWETH(partyDAOMultisig, _value);\n    }\n\n    /**\n     * @notice Escape hatch: in case of emergency,\n     * PartyDAO can use emergencyCall to call an external contract\n     * (e.g. to withdraw a stuck NFT or stuck ERC-20s)\n     */\n    function emergencyCall(address _contract, bytes memory _calldata)\n        external\n        onlyPartyDAO\n        returns (bool _success, bytes memory _returnData)\n    {\n        (_success, _returnData) = _contract.call(_calldata);\n        require(_success, string(_returnData));\n    }\n\n    /**\n     * @notice Escape hatch: in case of emergency,\n     * PartyDAO can force the Party to finalize with status LOST\n     * (e.g. if finalize is not callable)\n     */\n    function emergencyForceLost()\n        external\n        onlyPartyDAO\n    {\n        // set partyStatus to LOST\n        partyStatus = PartyStatus.LOST;\n    }\n\n    // ======== Public: Utility Calculations =========\n\n    /**\n     * @notice Convert ETH value to equivalent token amount\n     */\n    function valueToTokens(uint256 _value)\n        public\n        pure\n        returns (uint256 _tokens)\n    {\n        _tokens = _value * TOKEN_SCALE;\n    }\n\n    /**\n     * @notice The maximum amount that can be spent by the Party\n     * while paying the ETH fee to PartyDAO\n     * @return _maxSpend the maximum spend\n     */\n    function getMaximumSpend() public view returns (uint256 _maxSpend) {\n        _maxSpend = (totalContributedToParty * 10000) / (10000 + ETH_FEE_BASIS_POINTS);\n    }\n\n    /**\n     * @notice Calculate the amount of fractional NFT tokens owed to the contributor\n     * based on how much ETH they contributed towards buying the token,\n     * and the amount of excess ETH owed to the contributor\n     * based on how much ETH they contributed *not* used towards buying the token\n     * @param _contributor the address of the contributor\n     * @return _tokenAmount the amount of fractional NFT tokens owed to the contributor\n     * @return _ethAmount the amount of excess ETH owed to the contributor\n     */\n    function getClaimAmounts(address _contributor)\n        public\n        view\n        returns (uint256 _tokenAmount, uint256 _ethAmount)\n    {\n        require(partyStatus != PartyStatus.ACTIVE, \"Party::getClaimAmounts: party still active; amounts undetermined\");\n        uint256 _totalContributed = totalContributed[_contributor];\n        if (partyStatus == PartyStatus.WON) {\n            // calculate the amount of this contributor's ETH\n            // that was used to buy the token\n            uint256 _totalEthUsed = totalEthUsed(_contributor);\n            if (_totalEthUsed > 0) {\n                _tokenAmount = valueToTokens(_totalEthUsed);\n            }\n            // the rest of the contributor's ETH should be returned\n            _ethAmount = _totalContributed - _totalEthUsed;\n        } else {\n            // if the token wasn't bought, no ETH was spent;\n            // all of the contributor's ETH should be returned\n            _ethAmount = _totalContributed;\n        }\n    }\n\n    /**\n     * @notice Calculate the total amount of a contributor's funds\n     * that were used towards the buying the token\n     * @dev always returns 0 until the party has been finalized\n     * @param _contributor the address of the contributor\n     * @return _total the sum of the contributor's funds that were\n     * used towards buying the token\n     */\n    function totalEthUsed(address _contributor)\n        public\n        view\n        returns (uint256 _total)\n    {\n        require(partyStatus != PartyStatus.ACTIVE, \"Party::totalEthUsed: party still active; amounts undetermined\");\n        // load total amount spent once from storage\n        uint256 _totalSpent = totalSpent;\n        // get all of the contributor's contributions\n        Contribution[] memory _contributions = contributions[_contributor];\n        for (uint256 i = 0; i < _contributions.length; i++) {\n            // calculate how much was used from this individual contribution\n            uint256 _amount = _ethUsed(_totalSpent, _contributions[i]);\n            // if we reach a contribution that was not used,\n            // no subsequent contributions will have been used either,\n            // so we can stop calculating to save some gas\n            if (_amount == 0) break;\n            _total = _total + _amount;\n        }\n    }\n\n    // ============ Internal ============\n\n    function _closeSuccessfulParty(uint256 _nftCost) internal returns (uint256 _ethFee) {\n        // calculate PartyDAO fee & record total spent\n        _ethFee = _getEthFee(_nftCost);\n        totalSpent = _nftCost + _ethFee;\n        // transfer ETH fee to PartyDAO\n        _transferETHOrWETH(partyDAOMultisig, _ethFee);\n        // deploy fractionalized NFT vault\n        // and mint fractional ERC-20 tokens\n        _fractionalizeNFT(_nftCost);\n    }\n\n    /**\n     * @notice Calculate ETH fee for PartyDAO\n     * NOTE: Remove this fee causes a critical vulnerability\n     * allowing anyone to exploit a Party via price manipulation.\n     * See Security Review in README for more info.\n     * @return _fee the portion of _amount represented by scaling to ETH_FEE_BASIS_POINTS\n     */\n    function _getEthFee(uint256 _amount) internal pure returns (uint256 _fee) {\n        _fee = (_amount * ETH_FEE_BASIS_POINTS) / 10000;\n    }\n\n    /**\n     * @notice Calculate token amount for specified token recipient\n     * @return _totalSupply the total token supply\n     * @return _partyDAOAmount the amount of tokens for partyDAO fee,\n     * which is equivalent to TOKEN_FEE_BASIS_POINTS of total supply\n     * @return _splitRecipientAmount the amount of tokens for the token recipient,\n     * which is equivalent to splitBasisPoints of total supply\n     */\n    function _getTokenInflationAmounts(uint256 _amountSpent)\n        internal\n        view\n        returns (uint256 _totalSupply, uint256 _partyDAOAmount, uint256 _splitRecipientAmount)\n    {\n        // the token supply will be inflated to provide a portion of the\n        // total supply for PartyDAO, and a portion for the splitRecipient\n        uint256 inflationBasisPoints = TOKEN_FEE_BASIS_POINTS + splitBasisPoints;\n        _totalSupply = valueToTokens((_amountSpent * 10000) / (10000 - inflationBasisPoints));\n        // PartyDAO receives TOKEN_FEE_BASIS_POINTS of the total supply\n        _partyDAOAmount = (_totalSupply * TOKEN_FEE_BASIS_POINTS) / 10000;\n        // splitRecipient receives splitBasisPoints of the total supply\n        _splitRecipientAmount = (_totalSupply * splitBasisPoints) / 10000;\n    }\n\n    /**\n    * @notice Query the NFT contract to get the token owner\n    * @dev nftContract must implement the ERC-721 token standard exactly:\n    * function ownerOf(uint256 _tokenId) external view returns (address);\n    * See https://eips.ethereum.org/EIPS/eip-721\n    * @dev Returns address(0) if NFT token or NFT contract\n    * no longer exists (token burned or contract self-destructed)\n    * @return _owner the owner of the NFT\n    */\n    function _getOwner() internal view returns (address _owner) {\n        (bool _success, bytes memory _returnData) =\n            address(nftContract).staticcall(\n                abi.encodeWithSignature(\n                    \"ownerOf(uint256)\",\n                    tokenId\n                )\n        );\n        if (_success && _returnData.length > 0) {\n            _owner = abi.decode(_returnData, (address));\n        }\n    }\n\n    /**\n     * @notice Upon winning the token, transfer the NFT\n     * to fractional.art vault & mint fractional ERC-20 tokens\n     */\n    function _fractionalizeNFT(uint256 _amountSpent) internal {\n        // approve fractionalized NFT Factory to withdraw NFT\n        nftContract.approve(address(tokenVaultFactory), tokenId);\n        // Party \"votes\" for a reserve price on Fractional\n        // equal to 2x the price of the token\n        uint256 _listPrice = RESALE_MULTIPLIER * _amountSpent;\n        // users receive tokens at a rate of 1:TOKEN_SCALE for each ETH they contributed that was ultimately spent\n        // partyDAO receives a percentage of the total token supply equivalent to TOKEN_FEE_BASIS_POINTS\n        // splitRecipient receives a percentage of the total token supply equivalent to splitBasisPoints\n        (uint256 _tokenSupply, uint256 _partyDAOAmount, uint256 _splitRecipientAmount) = _getTokenInflationAmounts(totalSpent);\n        // deploy fractionalized NFT vault\n        uint256 vaultNumber =\n            tokenVaultFactory.mint(\n                name,\n                symbol,\n                address(nftContract),\n                tokenId,\n                _tokenSupply,\n                _listPrice,\n                0\n            );\n        // store token vault address to storage\n        tokenVault = ITokenVault(tokenVaultFactory.vaults(vaultNumber));\n        // transfer curator to null address (burn the curator role)\n        tokenVault.updateCurator(address(0));\n        // transfer tokens to PartyDAO multisig\n        _transferTokens(partyDAOMultisig, _partyDAOAmount);\n        // transfer tokens to token recipient\n        if (splitRecipient != address(0)) {\n            _transferTokens(splitRecipient, _splitRecipientAmount);\n        }\n    }\n\n    // ============ Internal: Claim ============\n\n    /**\n     * @notice Calculate the amount of a single Contribution\n     * that was used towards buying the token\n     * @param _contribution the Contribution struct\n     * @return the amount of funds from this contribution\n     * that were used towards buying the token\n     */\n    function _ethUsed(uint256 _totalSpent, Contribution memory _contribution)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (\n            _contribution.previousTotalContributedToParty +\n            _contribution.amount <=\n            _totalSpent\n        ) {\n            // contribution was fully used\n            return _contribution.amount;\n        } else if (\n            _contribution.previousTotalContributedToParty < _totalSpent\n        ) {\n            // contribution was partially used\n            return _totalSpent - _contribution.previousTotalContributedToParty;\n        }\n        // contribution was not used\n        return 0;\n    }\n\n    // ============ Internal: TransferTokens ============\n\n    /**\n    * @notice Transfer tokens to a recipient\n    * @param _to recipient of tokens\n    * @param _value amount of tokens\n    */\n    function _transferTokens(address _to, uint256 _value) internal {\n        // skip if attempting to send 0 tokens\n        if (_value == 0) {\n            return;\n        }\n        // guard against rounding errors;\n        // if token amount to send is greater than contract balance,\n        // send full contract balance\n        uint256 _partyBalance = tokenVault.balanceOf(address(this));\n        if (_value > _partyBalance) {\n            _value = _partyBalance;\n        }\n        tokenVault.transfer(_to, _value);\n    }\n\n    // ============ Internal: TransferEthOrWeth ============\n\n    /**\n     * @notice Attempt to transfer ETH to a recipient;\n     * if transferring ETH fails, transfer WETH insteads\n     * @param _to recipient of ETH or WETH\n     * @param _value amount of ETH or WETH\n     */\n    function _transferETHOrWETH(address _to, uint256 _value) internal {\n        // skip if attempting to send 0 ETH\n        if (_value == 0) {\n            return;\n        }\n        // guard against rounding errors;\n        // if ETH amount to send is greater than contract balance,\n        // send full contract balance\n        if (_value > address(this).balance) {\n            _value = address(this).balance;\n        }\n        // Try to transfer ETH to the given recipient.\n        if (!_attemptETHTransfer(_to, _value)) {\n            // If the transfer fails, wrap and send as WETH\n            weth.deposit{value: _value}();\n            weth.transfer(_to, _value);\n            // At this point, the recipient can unwrap WETH.\n        }\n    }\n\n    /**\n     * @notice Attempt to transfer ETH to a recipient\n     * @dev Sending ETH is not guaranteed to succeed\n     * this method will return false if it fails.\n     * We will limit the gas used in transfers, and handle failure cases.\n     * @param _to recipient of ETH\n     * @param _value amount of ETH\n     */\n    function _attemptETHTransfer(address _to, uint256 _value)\n        internal\n        returns (bool)\n    {\n        // Here increase the gas limit a reasonable amount above the default, and try\n        // to send ETH to the recipient.\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\n        (bool success, ) = _to.call{value: _value, gas: 30000}(\"\");\n        return success;\n    }\n}\n"
18     },
19     "contracts/market-wrapper/IMarketWrapper.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.5;\n\n/**\n * @title IMarketWrapper\n * @author Anna Carroll\n * @notice IMarketWrapper provides a common interface for\n * interacting with NFT auction markets.\n * Contracts can abstract their interactions with\n * different NFT markets using IMarketWrapper.\n * NFT markets can become compatible with any contract\n * using IMarketWrapper by deploying a MarketWrapper contract\n * that implements this interface using the logic of their Market.\n *\n * WARNING: MarketWrapper contracts should NEVER write to storage!\n * When implementing a MarketWrapper, exercise caution; a poorly implemented\n * MarketWrapper contract could permanently lose access to the NFT or user funds.\n */\ninterface IMarketWrapper {\n    /**\n     * @notice Given the auctionId, nftContract, and tokenId, check that:\n     * 1. the auction ID matches the token\n     * referred to by tokenId + nftContract\n     * 2. the auctionId refers to an *ACTIVE* auction\n     * (e.g. an auction that will accept bids)\n     * within this market contract\n     * 3. any additional validation to ensure that\n     * a PartyBid can bid on this auction\n     * (ex: if the market allows arbitrary bidding currencies,\n     * check that the auction currency is ETH)\n     * Note: This function probably should have been named \"isValidAuction\"\n     * @dev Called in PartyBid.sol in `initialize` at line 174\n     * @return TRUE if the auction is valid\n     */\n    function auctionIdMatchesToken(\n        uint256 auctionId,\n        address nftContract,\n        uint256 tokenId\n    ) external view returns (bool);\n\n    /**\n     * @notice Calculate the minimum next bid for this auction.\n     * PartyBid contracts always submit the minimum possible\n     * bid that will be accepted by the Market contract.\n     * usually, this is either the reserve price (if there are no bids)\n     * or a certain percentage increase above the current highest bid\n     * @dev Called in PartyBid.sol in `bid` at line 251\n     * @return minimum bid amount\n     */\n    function getMinimumBid(uint256 auctionId) external view returns (uint256);\n\n    /**\n     * @notice Query the current highest bidder for this auction\n     * It is assumed that there is always 1 winning highest bidder for an auction\n     * This is used to ensure that PartyBid cannot outbid itself if it is already winning\n     * @dev Called in PartyBid.sol in `bid` at line 241\n     * @return highest bidder\n     */\n    function getCurrentHighestBidder(uint256 auctionId)\n        external\n        view\n        returns (address);\n\n    /**\n     * @notice Submit bid to Market contract\n     * @dev Called in PartyBid.sol in `bid` at line 259\n     */\n    function bid(uint256 auctionId, uint256 bidAmount) external;\n\n    /**\n     * @notice Determine whether the auction has been finalized\n     * Used to check if it is still possible to bid\n     * And to determine whether the PartyBid should finalize the auction\n     * @dev Called in PartyBid.sol in `bid` at line 247\n     * @dev and in `finalize` at line 288\n     * @return TRUE if the auction has been finalized\n     */\n    function isFinalized(uint256 auctionId) external view returns (bool);\n\n    /**\n     * @notice Finalize the results of the auction\n     * on the Market contract\n     * It is assumed  that this operation is performed once for each auction,\n     * that after it is done the auction is over and the NFT has been\n     * transferred to the auction winner.\n     * @dev Called in PartyBid.sol in `finalize` at line 289\n     */\n    function finalize(uint256 auctionId) external;\n}\n"
21     },
22     "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
24     },
25     "@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721ReceiverUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n  /**\n   * @dev Implementation of the {IERC721Receiver} interface.\n   *\n   * Accepts all token transfers.\n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n   */\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\n    function __ERC721Holder_init() internal initializer {\n        __ERC721Holder_init_unchained();\n    }\n\n    function __ERC721Holder_init_unchained() internal initializer {\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n    uint256[50] private __gap;\n}\n"
27     },
28     "contracts/external/interfaces/IERC721VaultFactory.sol": {
29       "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.5;\n\ninterface IERC721VaultFactory {\n    /// @notice the mapping of vault number to vault address\n    function vaults(uint256) external returns (address);\n\n    /// @notice the function to mint a new vault\n    /// @param _name the desired name of the vault\n    /// @param _symbol the desired sumbol of the vault\n    /// @param _token the ERC721 token address fo the NFT\n    /// @param _id the uint256 ID of the token\n    /// @param _listPrice the initial price of the NFT\n    /// @return the ID of the vault\n    function mint(string memory _name, string memory _symbol, address _token, uint256 _id, uint256 _supply, uint256 _listPrice, uint256 _fee) external returns(uint256);\n}\n"
30     },
31     "contracts/external/interfaces/ITokenVault.sol": {
32       "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.5;\n\ninterface ITokenVault {\n    /// @notice allow curator to update the curator address\n    /// @param _curator the new curator\n    function updateCurator(address _curator) external;\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) external view returns (uint256);\n}"
33     },
34     "contracts/external/interfaces/IWETH.sol": {
35       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.5;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n}\n"
36     },
37     "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
39     },
40     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
41       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
42     },
43     "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
45     },
46     "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
47       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
48     },
49     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
50       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
51     },
52     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
53       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
54     }
55   },
56   "settings": {
57     "optimizer": {
58       "enabled": true,
59       "runs": 999999
60     },
61     "outputSelection": {
62       "*": {
63         "*": [
64           "evm.bytecode",
65           "evm.deployedBytecode",
66           "devdoc",
67           "userdoc",
68           "metadata",
69           "abi"
70         ]
71       }
72     },
73     "libraries": {}
74   }
75 }}