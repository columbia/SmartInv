1 {{
2   "language": "Solidity",
3   "sources": {
4     "/contracts/nft-bridge/MainnetNftBridgePool.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.3;\n\nimport \"./IRainiCard.sol\";\nimport \"../tokens/IRainiCustomNFT.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\n\ninterface INftStakingPool {\n  function getTokenStaminaTotal(uint256 _tokenId, address _nftContractAddress) external view returns (uint32 stamina);\n  function setTokenStaminaTotal(uint32 _stamina, uint256 _tokenId, address _nftContractAddress) external;\n}\n\ncontract MainnetNftBridgePool is IERC721Receiver, IERC1155Receiver, AccessControl, ReentrancyGuard {\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  event CardsDeposited(\n    uint256 nftContractId,\n    address indexed spender,\n    address recipient,\n    uint256 amount,\n    uint256 requestId,\n    uint128 cardId,\n    uint32 level,\n    uint32 number,\n    uint32 stamina,\n    bytes1 mintedContractChar,\n    bytes state\n  );\n\n  event EthWithdrawn(uint256 amount);\n  event AutoWithdrawFeeSet(bool autoWithdraw);\n  event ConfigSet(address cardToken, address nftV1Token, address nftV2Token);\n  event TreasuryAddressSet(address treasuryAddress);\n  event FeesSet(uint256 card, uint256 nftV1, uint256 nftV2);\n  event ItemFeeSet(uint256 card, uint256 nftV1, uint256 nftV2);\n\n  event CardsWithdrawn(uint256 nftContractId, address indexed owner, uint256 requestId, uint256 cardId, uint256 amount);\n\n  mapping(uint256 => address) public nftContracts;\n  mapping(uint256 => bool) public hasSubcontracts;\n\n  // contractId => cardId => bool\n  mapping(uint256 => mapping(uint256 => bool)) public cardDisabled;\n\n  // _contractId => _cardId => _cardLevel => _mintedContractChar => uint256 _number\n  mapping(uint256 => mapping(uint256 => mapping(uint256 => mapping(bytes1 => mapping(uint256 => uint256))))) public heldTokens;\n\n  uint256 public baseFee;\n  uint256 public stateUpdateFee;\n  uint256 public staminaUpdateFee;\n  uint256 public gasPrice;\n  mapping(uint256 => uint256) public itemFee;\n\n  uint256 private requestId;\n  bool    private autoWithdrawFee;\n  address private treasuryAddress;\n\n  address public nftStakingPoolAddress;\n\n  mapping(uint256 => bool) requestWithdrawn;\n\n  constructor() {\n    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    _setupRole(MINTER_ROLE, _msgSender());\n  }\n\n  modifier onlyMinter() {\n    require(hasRole(MINTER_ROLE, _msgSender()), \"MainnetNftBridgePool: caller is not a minter\");\n    _;\n  }\n\n  modifier onlyOwner() {\n    require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"MainnetNftBridgePool: caller is not an owner\");\n    _;\n  }\n\n  function setFees(uint256  _baseFee, uint256 _stateUpdateFee, uint256 _staminaUpdateFee, uint256[] calldata _contractId, uint256[] calldata  _itemFee)\n    external onlyOwner {\n      baseFee = _baseFee;\n      stateUpdateFee = _stateUpdateFee;\n      staminaUpdateFee = _staminaUpdateFee;\n\n      for (uint256 i; i < _contractId.length; i++) {\n        itemFee[_contractId[i]] = _itemFee[i];\n      }\n  }\n\n  function setGasPrice(uint256 _gasPrice) \n      external {\n        require(hasRole(MINTER_ROLE, _msgSender()) || hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), 'no access');\n        gasPrice = _gasPrice;\n  }\n\n  function setContracts(uint256[] calldata _contractId, address[] calldata _contractAddress, bool[] calldata _hasSubcontracts)\n    external onlyOwner {\n      for (uint256 i; i < _contractId.length; i++) {\n        nftContracts[_contractId[i]] = _contractAddress[i];\n        hasSubcontracts[_contractId[i]] = _hasSubcontracts[i];\n      }\n  }\n\n  function setDisabledCards(uint256[] calldata _contractId, uint256[] calldata _ids, bool[] calldata _disabled) \n    external onlyOwner {\n      for (uint256 i; i < _ids.length; i++) {\n        cardDisabled[_contractId[i]][_ids[i]] = _disabled[i];\n      }\n  }\n\n  function setAutoWithdrawFee(bool _autoWithdrawFee)\n    external onlyOwner {\n      autoWithdrawFee = _autoWithdrawFee;\n      emit AutoWithdrawFeeSet(autoWithdrawFee);\n  }\n\n  function setTreasuryAddress(address _treasuryAddress)\n    external onlyOwner {\n      treasuryAddress = _treasuryAddress;\n      emit TreasuryAddressSet(_treasuryAddress);\n  }\n\n  function setNftStakingPoolAddress(address _nftStakingPoolAddress)\n    external onlyOwner {\n      nftStakingPoolAddress = (_nftStakingPoolAddress);\n  }\n\n  function getSubContractTokenState(address _token, uint256 _cardId, uint256 _tokenId) \n    internal view returns(bytes memory) {\n      (,,,,,,,address subContract) = IRainiCard(_token).cards(_cardId);\n          \n      if (subContract != address(0)) {\n        return IRainiCustomNFT(subContract).getTokenState(_tokenId);\n      }\n\n      return '';\n  }\n\n  function handleFeesWithdraw(uint256 _fee, uint256 _refund) internal {\n    if (_refund > 0) {\n      (bool refundSuccess, ) = _msgSender().call{ value: _refund }(\"\");\n      require(refundSuccess, \"MainnetNftBridgePool: refund transfer failed\");\n    }\n\n    if (autoWithdrawFee) {\n      (bool withdrawSuccess, ) = treasuryAddress.call{ value: _fee }(\"\");\n      require(withdrawSuccess, \"MainnetNftBridgePool: withdraw transfer failed\");\n    }\n  }\n\n  function updateSubContractState(address _token, uint256 _cardId, uint256 _tokenId, bytes calldata state) internal {\n    if (state.length == 0) return;\n\n    (,,,,,,,address subContract) = IRainiCard(_token).cards(_cardId);\n    uint256[] memory ids = new uint256[](1);\n    bytes[] memory states = new bytes[](1);\n    ids[0] = _tokenId;\n    states[0] = state;\n    \n    if (subContract != address(0)) {\n      IRainiCustomNFT(subContract).setTokenStates(ids, states);\n    }\n  }\n\n  function updateStamina(address _token, uint256 _tokenId, uint32 _stamina) internal {\n    if (_stamina == 0 || nftStakingPoolAddress == address(0)) return;\n\n    INftStakingPool(nftStakingPoolAddress).setTokenStaminaTotal(_stamina, _tokenId, _token);\n  }\n\n  struct DepositVars {\n    uint256 fee;\n    uint256 requestId;\n  }\n\n  function deposit(address _recipient, uint256[] calldata _contractId, uint256[] calldata _tokenIds, uint256[] calldata _amounts) \n    external payable nonReentrant {\n      require(_tokenIds.length == _amounts.length, \"MainnetNftBridgePool: input arrays not equal\");\n\n      DepositVars memory _locals =  DepositVars(\n        baseFee,\n        requestId\n      );\n\n      for (uint256 i; i < _tokenIds.length; i++) {\n        IRainiCard nftContract = IRainiCard(nftContracts[_contractId[i]]);\n        IRainiCard.TokenVars memory tokenVars = IRainiCard.TokenVars(0,0,0,0);\n        (tokenVars.cardId, tokenVars.level, tokenVars.number, tokenVars.mintedContractChar) = nftContract.tokenVars(_tokenIds[i]);\n        require(!cardDisabled[_contractId[i]][tokenVars.cardId], \"MainnetNftBridgePool: bridging this card disabled\");\n        nftContract.safeTransferFrom(_msgSender(), address(this), _tokenIds[i], _amounts[i], \"\");\n        setHeldToken(_tokenIds[i], _contractId[i], tokenVars.cardId, tokenVars.level, tokenVars.mintedContractChar, tokenVars.number);\n        _locals.requestId++;\n\n        _locals.fee += itemFee[_contractId[i]];\n\n        bytes memory state = \"\";\n        if (tokenVars.number > 0 && hasSubcontracts[_contractId[i]]) {\n          state = getSubContractTokenState(address(nftContract), tokenVars.cardId, _tokenIds[i]);\n          if (state.length > 0) {\n            _locals.fee += stateUpdateFee;\n          }\n        }\n\n        uint32 stamina = 0;\n        if (nftStakingPoolAddress != address(0)) {\n          stamina = INftStakingPool(nftStakingPoolAddress).getTokenStaminaTotal(_tokenIds[i], address(nftContract));\n          if (stamina != 0) {\n            _locals.fee += staminaUpdateFee;\n          }\n        }\n\n        emit CardsDeposited(\n          _contractId[i],\n          _msgSender(),\n          _recipient,\n          _amounts[i],\n          _locals.requestId,\n          tokenVars.cardId,\n          tokenVars.level,\n          tokenVars.number,\n          stamina,\n          tokenVars.mintedContractChar,\n          state\n        );\n      }\n\n      _locals.fee *= gasPrice;\n \n      require(msg.value >= _locals.fee, \"MainnetNftBridgePool: not enough funds\");\n      handleFeesWithdraw(_locals.fee, msg.value - _locals.fee);\n\n      requestId = _locals.requestId;\n  }\n\n  function getDepositFee(address _recipient, uint256[] calldata _contractId, uint256[] calldata _tokenIds, uint256[] calldata _amounts) \n    public view returns (uint256 fee) {\n      require(_tokenIds.length == _amounts.length, \"MainnetNftBridgePool: input arrays not equal\");\n\n      DepositVars memory _locals =  DepositVars(\n        baseFee,\n        requestId\n      );\n\n      for (uint256 i; i < _tokenIds.length; i++) {\n        IRainiCard nftContract = IRainiCard(nftContracts[_contractId[i]]);\n        IRainiCard.TokenVars memory tokenVars = IRainiCard.TokenVars(0,0,0,0);\n        (tokenVars.cardId, tokenVars.level, tokenVars.number, tokenVars.mintedContractChar) = nftContract.tokenVars(_tokenIds[i]);\n        require(!cardDisabled[_contractId[i]][tokenVars.cardId], \"MainnetNftBridgePool: bridging this card disabled\");\n\n        _locals.fee += itemFee[_contractId[i]];\n\n        bytes memory state = \"\";\n        if (tokenVars.number > 0 && hasSubcontracts[_contractId[i]]) {\n          state = getSubContractTokenState(address(nftContract), tokenVars.cardId, _tokenIds[i]);\n          if (state.length > 0) {\n            _locals.fee += stateUpdateFee;\n          }\n        }\n\n        uint32 stamina = 0;\n        if (nftStakingPoolAddress != address(0)) {\n          INftStakingPool(nftStakingPoolAddress).getTokenStaminaTotal(_tokenIds[i], address(nftContract));\n          if (stamina != 0) {\n            _locals.fee += staminaUpdateFee;\n          }\n        }\n      }\n\n      _locals.fee *= gasPrice;\n      return _locals.fee;\n  }\n\n  function setHeldToken(uint256 tokenId, uint256 _contractId, uint256 _cardId, uint256 _cardLevel, bytes1 _mintedContractChar, uint256 _number) internal {\n    if (_number == 0) {\n      _mintedContractChar = bytes1(0);\n    }\n    if (heldTokens[_contractId][_cardId][_cardLevel][_mintedContractChar][_number] != tokenId) {\n      heldTokens[_contractId][_cardId][_cardLevel][_mintedContractChar][_number] = tokenId;\n    }\n  }\n\n\n  function findHeldToken(uint256 _contractId, uint256 _cardId, uint256 _cardLevel, bytes1 _mintedContractChar, uint256 _number) public view returns (uint256) {\n    if (_number == 0) {\n      _mintedContractChar = bytes1(0);\n    }\n    return heldTokens[_contractId][_cardId][_cardLevel][_mintedContractChar][_number];\n  }\n\n  struct WithdrawNftVars {\n    uint256 tokenId;\n    uint256 amount;\n    uint256 leftAmount;\n  }\n\n  function withdrawNft(uint256 _contractId, address _recipient, uint256 _cardId, uint256 _cardLevel, uint256 _amount, bytes1 _mintedContractChar, uint256 _number, uint256 _requestsId, uint32 _stamina, bytes calldata _state) \n    public onlyMinter {\n\n      if (requestWithdrawn[_requestsId]) {\n        return;\n      }\n\n      requestWithdrawn[_requestsId] = true;\n\n      WithdrawNftVars memory _locals = WithdrawNftVars(0, 0, 0);\n\n      IRainiCard nftContract = IRainiCard(nftContracts[_contractId]);\n\n      _locals.tokenId = findHeldToken(_contractId, _cardId, _cardLevel, _mintedContractChar, _number);\n      _locals.amount = 0;\n      if (_locals.tokenId > 0) {\n        _locals.amount = nftContract.balanceOf(address(this), _locals.tokenId);\n      }\n      \n      _locals.leftAmount = _amount;\n\n      if (_locals.amount > 0) {\n        if (_locals.amount > _amount) {\n          _locals.leftAmount = 0;\n          nftContract.safeTransferFrom(address(this), _recipient, _locals.tokenId, _amount, bytes(''));\n        } else {\n          _locals.leftAmount -= _locals.amount;\n          nftContract.safeTransferFrom(address(this), _recipient, _locals.tokenId, _locals.amount, bytes(''));\n          setHeldToken(0, _contractId, _cardId, _cardLevel, _mintedContractChar, _number);\n        }\n        \n        updateStamina(address(nftContract), _locals.tokenId, _stamina);\n        updateSubContractState(address(nftContract), _cardId, _locals.tokenId, _state);\n      } \n\n      if (_locals.leftAmount > 0) {\n        if (hasSubcontracts[_contractId]) {\n          nftContract.mint(_recipient, _cardId, _cardLevel, _locals.leftAmount, _mintedContractChar, _number, new uint256[](0));\n          updateSubContractState(address(nftContract), _cardId, nftContract.maxTokenId(), _state);\n        } else {\n          nftContract.mint(_recipient, _cardId, _cardLevel, _locals.leftAmount, _mintedContractChar, _number);\n        }\n        updateStamina(address(nftContract), nftContract.maxTokenId(), _stamina);\n      }\n\n      emit CardsWithdrawn(_contractId, _recipient, _requestsId, _cardId, _amount);\n  }\n\n  function bulkWithdrawNfts(uint232[] memory _contractId, address[] memory _recipient, uint256[] memory _cardId, uint256[] memory _cardLevel, uint256[] memory _amount, bytes1[] memory _mintedContractChar, uint256[] memory _number, uint256[] memory _requestsId, uint32[] memory _stamina, bytes[] calldata _state) \n    external onlyMinter {\n      for (uint256 i; i < _contractId.length; i++) {\n        withdrawNft(_contractId[i], _recipient[i], _cardId[i], _cardLevel[i], _amount[i],_mintedContractChar[i], _number[i], _requestsId[i], _stamina[i], _state[i]);\n      }\n  }\n\n  function withdrawEth(uint256 _amount)\n    external onlyOwner {\n      require(_amount <= address(this).balance, \"MainnetNftBridgePool: not enough balance\");\n      \n      (bool success, ) = _msgSender().call{ value: _amount }(\"\");\n      require(success, \"MainnetNftBridgePool: transfer failed\");\n\n      emit EthWithdrawn(_amount);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) \n    public virtual override returns (bytes4) {\n      return this.onERC721Received.selector;\n  }\n\n  function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n    public virtual override returns (bytes4) {\n      return this.onERC1155Received.selector;\n  }\n\n  function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n    public virtual override returns (bytes4) {\n      return this.onERC1155BatchReceived.selector;\n  }\n}\n"
6     },
7     "/contracts/tokens/IRainiCustomNFT.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.3;\n\ninterface IRainiCustomNFT {\n  function onTransfered(address from, address to, uint256 id, uint256 amount, bytes memory data) external;\n  function onMerged(uint256 _newTokenId, uint256[] memory _tokenId, address _nftContractAddress, uint256[] memory data) external;\n  function onMinted(address _to, uint256 _tokenId, uint256 _cardId, uint256 _cardLevel, uint256 _amount, bytes1 _mintedContractChar, uint256 _number, uint256[] memory _data) external;\n  \n  function setTokenStates(uint256[] memory id, bytes[] memory state) external;\n\n  function getTokenState(uint256 id) external view returns (bytes memory);\n  function uri(uint256 id) external view returns (string memory);\n}"
9     },
10     "/contracts/nft-bridge/IRainiCard.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\npragma solidity ^0.8.0;\n\nabstract contract IRainiCard is IERC1155 {\n  struct TokenVars {\n    uint128 cardId;\n    uint32 level;\n    uint32 number;\n    bytes1 mintedContractChar;\n  }\n\n  struct Card {\n    uint64 costInUnicorns;\n    uint64 costInRainbows;\n    uint16 maxMintsPerAddress;\n    uint32 maxSupply; // number of base tokens mintable\n    uint32 allocation; // number of base tokens mintable with points on this contract\n    uint32 mintTimeStart; // the timestamp from which the card can be minted\n    bool locked;\n    address subContract;\n  }\n  \n  mapping(uint256 => TokenVars) public tokenVars;\n  \n  mapping(uint256 => Card) public cards;\n\n  uint256 public maxTokenId;\n\n  function mint(address _to, uint256 _cardId, uint256 _cardLevel, uint256 _amount, bytes1 _mintedContractChar, uint256 _number, uint256[] memory _data) virtual external;\n\n  function mint(address _to, uint256 _cardId, uint256 _cardLevel, uint256 _amount, bytes1 _mintedContractChar, uint256 _number) virtual external;\n\n  function getTotalBalance(address _address) virtual external view returns (uint256[][] memory amounts);\n\n  function getTotalBalance(address _address, uint256 _cardCount) virtual external view returns (uint256[][] memory amounts);\n\n  function burn(address _owner, uint256 _tokenId, uint256 _amount) virtual external;\n}\n"
12     },
13     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
15     },
16     "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
18     },
19     "@openzeppelin/contracts/utils/Strings.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
21     },
22     "@openzeppelin/contracts/utils/Context.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
24     },
25     "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
27     },
28     "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
30     },
31     "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
33     },
34     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
36     },
37     "@openzeppelin/contracts/access/IAccessControl.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
39     },
40     "@openzeppelin/contracts/access/AccessControl.sol": {
41       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
42     }
43   },
44   "settings": {
45     "remappings": [],
46     "optimizer": {
47       "enabled": true,
48       "runs": 200
49     },
50     "evmVersion": "istanbul",
51     "libraries": {},
52     "outputSelection": {
53       "*": {
54         "*": [
55           "evm.bytecode",
56           "evm.deployedBytecode",
57           "devdoc",
58           "userdoc",
59           "metadata",
60           "abi"
61         ]
62       }
63     }
64   }
65 }}