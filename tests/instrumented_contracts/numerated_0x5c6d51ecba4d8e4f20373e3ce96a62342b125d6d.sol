1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/council/libraries/ERC20PermitWithMint.sol": {
5       "content": "// SPDX-License-Identifier: Apache-2.0\n// Largely based on https://github.com/element-fi/elf-contracts/blob/a6cb960896301b7562ced70a8b221f3cc964ea0a/contracts/libraries/ERC20PermitWithSupply.sol\n\npragma solidity ^0.8.3;\n\nimport \"./ERC20Permit.sol\";\nimport \"./Authorizable.sol\";\n\n// This contract adds total supply and minting to the generic erc20\ncontract ERC20PermitWithMint is ERC20Permit, Authorizable {\n    /// @notice Initializes the erc20 contract\n    /// @param name_ the value 'name' will be set to\n    /// @param symbol_ the value 'symbol' will be set to\n    /// @param owner_ address which has the power to mint\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address owner_\n    ) ERC20Permit(name_, symbol_) {\n        setOwner(owner_);\n    }\n\n    // The stored totalSupply, it equals all tokens minted - all tokens burned\n    uint256 public totalSupply;\n\n    /// @notice Allows the governance to mint\n    /// @param account the account to addd tokens to\n    /// @param amount the amount of tokens to add\n    function mint(address account, uint256 amount) external onlyOwner {\n        _mint(account, amount);\n    }\n\n    /// @notice This function overrides the ERC20Permit Library's _mint and causes it\n    ///          to track total supply.\n    /// @param account the account to addd tokens to\n    /// @param amount the amount of tokens to add\n    function _mint(address account, uint256 amount) internal override {\n        // Increase account balance\n        balanceOf[account] = balanceOf[account] + amount;\n        // Increase total supply\n        totalSupply += amount;\n        // Emit a transfer from zero to emulate a mint\n        emit Transfer(address(0), account, amount);\n    }\n\n    /// @notice Allows the governance to burn\n    /// @param account the account to burn from\n    /// @param amount the amount of token to burn\n    function burn(address account, uint256 amount) external onlyOwner {\n        _burn(account, amount);\n    }\n\n    /// @notice This function overrides the ERC20Permit Library's _burn to decrement total supply\n    /// @param account the account to burn from\n    /// @param amount the amount of token to burn\n    function _burn(address account, uint256 amount) internal override {\n        // Decrease user balance\n        uint256 currentBalance = balanceOf[account];\n        // This logic prevents a reversion if the _burn is frontrun\n        if (currentBalance < amount) {\n            balanceOf[account] = 0;\n        } else {\n            balanceOf[account] = currentBalance - amount;\n        }\n        // Decrease total supply\n        totalSupply -= amount;\n        // Emit an event tracking the burn\n        emit Transfer(account, address(0), amount);\n    }\n}\n"
6     },
7     "contracts/council/libraries/ERC20Permit.sol": {
8       "content": "// SPDX-License-Identifier: Apache-2.0\n// Copied from https://github.com/element-fi/elf-contracts/blob/a6cb960896301b7562ced70a8b221f3cc964ea0a/contracts/libraries/ERC20Permit.sol\n\npragma solidity ^0.8.3;\n\nimport \"../interfaces/IERC20Permit.sol\";\n\n// This default erc20 library is designed for max efficiency and security.\n// WARNING: By default it does not include totalSupply which breaks the ERC20 standard\n//          to use a fully standard compliant ERC20 use 'ERC20PermitWithSupply\"\nabstract contract ERC20Permit is IERC20Permit {\n    // --- ERC20 Data ---\n    // The name of the erc20 token\n    string public name;\n    // The symbol of the erc20 token\n    string public override symbol;\n    // The decimals of the erc20 token, should default to 18 for new tokens\n    uint8 public override decimals;\n\n    // A mapping which tracks user token balances\n    mapping(address => uint256) public override balanceOf;\n    // A mapping which tracks which addresses a user allows to move their tokens\n    mapping(address => mapping(address => uint256)) public override allowance;\n    // A mapping which tracks the permit signature nonces for users\n    mapping(address => uint256) public override nonces;\n\n    // --- EIP712 niceties ---\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 public override DOMAIN_SEPARATOR;\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice Initializes the erc20 contract\n    /// @param name_ the value 'name' will be set to\n    /// @param symbol_ the value 'symbol' will be set to\n    /// @dev decimals default to 18 and must be reset by an inheriting contract for\n    ///      non standard decimal values\n    constructor(string memory name_, string memory symbol_) {\n        // Set the state variables\n        name = name_;\n        symbol = symbol_;\n        decimals = 18;\n\n        // By setting these addresses to 0 attempting to execute a transfer to\n        // either of them will revert. This is a gas efficient way to prevent\n        // a common user mistake where they transfer to the token address.\n        // These values are not considered 'real' tokens and so are not included\n        // in 'total supply' which only contains minted tokens.\n        balanceOf[address(0)] = type(uint256).max;\n        balanceOf[address(this)] = type(uint256).max;\n\n        // Optional extra state manipulation\n        _extraConstruction();\n\n        // Computes the EIP 712 domain separator which prevents user signed messages for\n        // this contract to be replayed in other contracts.\n        // https://eips.ethereum.org/EIPS/eip-712\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    /// @notice An optional override function to execute and change state before immutable assignment\n    function _extraConstruction() internal virtual {}\n\n    // --- Token ---\n    /// @notice Allows a token owner to send tokens to another address\n    /// @param recipient The address which will be credited with the tokens\n    /// @param amount The amount user token to send\n    /// @return returns true on success, reverts on failure so cannot return false.\n    /// @dev transfers to this contract address or 0 will fail\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        // We forward this call to 'transferFrom'\n        return transferFrom(msg.sender, recipient, amount);\n    }\n\n    /// @notice Transfers an amount of erc20 from a spender to a receipt\n    /// @param spender The source of the ERC20 tokens\n    /// @param recipient The destination of the ERC20 tokens\n    /// @param amount the number of tokens to send\n    /// @return returns true on success and reverts on failure\n    /// @dev will fail transfers which send funds to this contract or 0\n    function transferFrom(\n        address spender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        // Load balance and allowance\n        uint256 balance = balanceOf[spender];\n        require(balance >= amount, \"ERC20: insufficient-balance\");\n        // We potentially have to change allowances\n        if (spender != msg.sender) {\n            // Loading the allowance in the if block prevents vanilla transfers\n            // from paying for the sload.\n            uint256 allowed = allowance[spender][msg.sender];\n            // If the allowance is max we do not reduce it\n            // Note - This means that max allowances will be more gas efficient\n            // by not requiring a sstore on 'transferFrom'\n            if (allowed != type(uint256).max) {\n                require(allowed >= amount, \"ERC20: insufficient-allowance\");\n                allowance[spender][msg.sender] = allowed - amount;\n            }\n        }\n        // Update the balances\n        balanceOf[spender] = balance - amount;\n        // Note - In the constructor we initialize the 'balanceOf' of address 0 and\n        //        the token address to uint256.max and so in 8.0 transfers to those\n        //        addresses revert on this step.\n        balanceOf[recipient] = balanceOf[recipient] + amount;\n        // Emit the needed event\n        emit Transfer(spender, recipient, amount);\n        // Return that this call succeeded\n        return true;\n    }\n\n    /// @notice This internal minting function allows inheriting contracts\n    ///         to mint tokens in the way they wish.\n    /// @param account the address which will receive the token.\n    /// @param amount the amount of token which they will receive\n    /// @dev This function is virtual so that it can be overridden, if you\n    ///      are reviewing this contract for security you should ensure to\n    ///      check for overrides\n    function _mint(address account, uint256 amount) internal virtual {\n        // Add tokens to the account\n        balanceOf[account] = balanceOf[account] + amount;\n        // Emit an event to track the minting\n        emit Transfer(address(0), account, amount);\n    }\n\n    /// @notice This internal burning function allows inheriting contracts to\n    ///         burn tokens in the way they see fit.\n    /// @param account the account to remove tokens from\n    /// @param amount  the amount of tokens to remove\n    /// @dev This function is virtual so that it can be overridden, if you\n    ///      are reviewing this contract for security you should ensure to\n    ///      check for overrides\n    function _burn(address account, uint256 amount) internal virtual {\n        // Reduce the balance of the account\n        balanceOf[account] = balanceOf[account] - amount;\n        // Emit an event tracking transfers\n        emit Transfer(account, address(0), amount);\n    }\n\n    /// @notice This function allows a user to approve an account which can transfer\n    ///         tokens on their behalf.\n    /// @param account The account which will be approve to transfer tokens\n    /// @param amount The approval amount, if set to uint256.max the allowance does not go down on transfers.\n    /// @return returns true for compatibility with the ERC20 standard\n    function approve(address account, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        // Set the senders allowance for account to amount\n        allowance[msg.sender][account] = amount;\n        // Emit an event to track approvals\n        emit Approval(msg.sender, account, amount);\n        return true;\n    }\n\n    /// @notice This function allows a caller who is not the owner of an account to execute the functionality of 'approve' with the owners signature.\n    /// @param owner the owner of the account which is having the new approval set\n    /// @param spender the address which will be allowed to spend owner's tokens\n    /// @param value the new allowance value\n    /// @param deadline the timestamp which the signature must be submitted by to be valid\n    /// @param v Extra ECDSA data which allows public key recovery from signature assumed to be 27 or 28\n    /// @param r The r component of the ECDSA signature\n    /// @param s The s component of the ECDSA signature\n    /// @dev The signature for this function follows EIP 712 standard and should be generated with the\n    ///      eth_signTypedData JSON RPC call instead of the eth_sign JSON RPC call. If using out of date\n    ///      parity signing libraries the v component may need to be adjusted. Also it is very rare but possible\n    ///      for v to be other values, those values are not supported.\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        // The EIP 712 digest for this function\n        bytes32 digest =\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR,\n                    keccak256(\n                        abi.encode(\n                            PERMIT_TYPEHASH,\n                            owner,\n                            spender,\n                            value,\n                            nonces[owner],\n                            deadline\n                        )\n                    )\n                )\n            );\n        // Require that the owner is not zero\n        require(owner != address(0), \"ERC20: invalid-address-0\");\n        // Require that we have a valid signature from the owner\n        require(owner == ecrecover(digest, v, r, s), \"ERC20: invalid-permit\");\n        // Require that the signature is not expired\n        require(\n            deadline == 0 || block.timestamp <= deadline,\n            \"ERC20: permit-expired\"\n        );\n        // Format the signature to the default format\n        require(\n            uint256(s) <=\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"ERC20: invalid signature 's' value\"\n        );\n        // Increment the signature nonce to prevent replay\n        nonces[owner]++;\n        // Set the allowance to the new value\n        allowance[owner][spender] = value;\n        // Emit an approval event to be able to track this happening\n        emit Approval(owner, spender, value);\n    }\n\n    /// @notice Internal function which allows inheriting contract to set custom decimals\n    /// @param decimals_ the new decimal value\n    function _setupDecimals(uint8 decimals_) internal {\n        // Set the decimals\n        decimals = decimals_;\n    }\n}\n"
9     },
10     "contracts/council/libraries/Authorizable.sol": {
11       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.7.0;\n\ncontract Authorizable {\n    // This contract allows a flexible authorization scheme\n\n    // The owner who can change authorization status\n    address public owner;\n    // A mapping from an address to its authorization status\n    mapping(address => bool) public authorized;\n\n    /// @dev We set the deployer to the owner\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// @dev This modifier checks if the msg.sender is the owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Sender not owner\");\n        _;\n    }\n\n    /// @dev This modifier checks if an address is authorized\n    modifier onlyAuthorized() {\n        require(isAuthorized(msg.sender), \"Sender not Authorized\");\n        _;\n    }\n\n    /// @dev Returns true if an address is authorized\n    /// @param who the address to check\n    /// @return true if authorized false if not\n    function isAuthorized(address who) public view returns (bool) {\n        return authorized[who];\n    }\n\n    /// @dev Privileged function authorize an address\n    /// @param who the address to authorize\n    function authorize(address who) external onlyOwner() {\n        _authorize(who);\n    }\n\n    /// @dev Privileged function to de authorize an address\n    /// @param who The address to remove authorization from\n    function deauthorize(address who) external onlyOwner() {\n        authorized[who] = false;\n    }\n\n    /// @dev Function to change owner\n    /// @param who The new owner address\n    function setOwner(address who) public onlyOwner() {\n        owner = who;\n    }\n\n    /// @dev Inheritable function which authorizes someone\n    /// @param who the address to authorize\n    function _authorize(address who) internal {\n        authorized[who] = true;\n    }\n}\n"
12     },
13     "contracts/council/interfaces/IERC20Permit.sol": {
14       "content": "// Forked from openzepplin\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.3;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit is IERC20 {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
15     },
16     "contracts/council/interfaces/IERC20.sol": {
17       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\ninterface IERC20 {\n    function symbol() external view returns (string memory);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    // Note this is non standard but nearly all ERC20 have exposed decimal functions\n    function decimals() external view returns (uint8);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
18     }
19   },
20   "settings": {
21     "optimizer": {
22       "enabled": true,
23       "runs": 10000
24     },
25     "outputSelection": {
26       "*": {
27         "*": [
28           "evm.bytecode",
29           "evm.deployedBytecode",
30           "devdoc",
31           "userdoc",
32           "metadata",
33           "abi"
34         ]
35       }
36     },
37     "libraries": {}
38   }
39 }}