1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/Kitten.sol": {
5       "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\nimport \"@rari-capital/solmate/src/tokens/ERC721.sol\";\n\nimport \"./interfaces/IKitten.sol\";\nimport \"./interfaces/IMetadata.sol\";\n\n/// @title Kitten\n/// @author kitten devs\n/// @notice h/t crypto coven for some beautiful ERC721 inspiration.\ncontract Kitten is IKitten, ERC721, IERC2981, Ownable {\n    /// STORAGE ///\n\n    /// @notice Allowed max supply of Kittens.\n    uint256 public constant MAX_KITTENS = 9500;\n\n    /// @notice Per-wallet Kitten cap.\n    uint256 public constant MAX_KITTENS_PER_WALLET = 4;\n\n    /// @notice Public sale.\n    bool public isPublicSaleActive;\n    uint256 public constant PUBLIC_SALE_PRICE = 0.088 ether;\n\n    /// @notice Community sale (determined in Discord).\n    bool public isCommunitySaleActive;\n    uint256 public constant COMMUNITY_SALE_PRICE = 0.077 ether;\n\n    /// @notice Merkle root for first community sale claims.\n    bytes32 public communityFirstClaimMerkleRoot;\n\n    /// @notice Addresses that have claimed a first community mint.\n    mapping(address => bool) public claimedFirst;\n\n    /// @notice Second community sale list for addresses with two claims.\n    bytes32 public communitySecondClaimMerkleRoot;\n\n    /// @notice Addresses that have claimed a second community mint.\n    mapping(address => bool) public claimedSecond;\n\n    /// @notice Counters for addresses that have participated in public sale.\n    mapping(address => bool) public publicSaleParticipants;\n\n    /// @notice Team + gift kittens.\n    uint256 public numGiftedKittens;\n    uint256 public constant MAX_GIFTED_KITTENS = 400;\n\n    /// @notice Royalty percentage. Must be an integer percentage.\n    uint8 public royaltyPercent = 5;\n\n    /// @notice Shifting kitten metadata prereveal.\n    bool public hasShifted = false;\n    uint256 public metadataOffset = 0;\n\n    /// @notice Metadata reveal trigger.\n    bool public isRevealed = false;\n\n    /// @notice Mapping of token ID to traits.\n    mapping(uint256 => Kitten) public kittens;\n\n    /// @notice Mapping of Kittens using special renderer.\n    mapping(uint256 => bool) public specialMode;\n\n    /// @notice List of probabilities for each trait type.\n    uint16[][9] public traitRarities;\n\n    /// @notice List of aliases for AJ Walker's Alias Algorithm.\n    uint16[][9] public traitAliases;\n\n    /// @notice Sauce up the prices.\n    uint256[4] private sauce = [\n        0.00002 ether,\n        0.00006 ether,\n        0.00001 ether,\n        0.00007 ether\n    ];\n\n    /// @notice Addresses that can perform admin functionality, e.g. gifting.\n    mapping(address => bool) private admins;\n\n    /// @notice Address of the metadata renderer.\n    address public renderer;\n\n    /// @notice Used for increased pseudorandomness.\n    bytes32 private entropy;\n\n    /// @notice Counter of minted tokens.\n    uint256 public tokenCounter;\n\n    /// CONSTRUCTOR ///\n\n    constructor() ERC721(\"WarKitten\", \"KITTEN\") {\n        // This looks insane, but it works.\n\n        // Backgrounds.\n        traitRarities[0] = [\n            232, 201,  77,  70, 47, 136,\n            174,  93, 110, 232, 77, 115,\n            118, 117, 198, 121, 56,  61,\n            62, 106, 106, 255, 52\n        ];\n        traitAliases[0] = [\n            1,  5,\n            0,  1,\n            1,  6,\n            8,  5,\n            9,  10,\n            11, 12,\n            14, 8,\n            15, 21,\n            8,  9,\n            10, 12,\n            12, 0,\n            15\n        ];\n\n        // Bodies.\n        traitRarities[1] = [\n            167, 192, 215,  98, 221, 252, 165, 207, 210, 133,\n            184, 182, 109, 219, 143, 202,  61, 249, 207, 196,\n            185, 214, 143, 120, 135,  76, 109, 233, 168, 247,\n            141, 176,  56, 143, 109, 130, 204, 148, 170, 240,\n            232, 165, 165, 143, 250, 244, 201, 245,  72, 131,\n            139, 200, 120, 207, 133, 173,  63,  70,  83, 185,\n            223, 253, 120, 126, 165, 193, 120, 255, 128\n        ];\n        traitAliases[1] = [\n            1,  2,  4,  1,\n            8,  2,  2,  2,\n            9,  10, 15, 2,\n            4,  4,  4,  17,\n            8,  21, 9,  9,\n            9,  27, 9,  9,\n            15, 17, 21, 28,\n            29, 30, 38, 21,\n            28, 29, 29, 30,\n            38, 38, 39, 45,\n            38, 38, 39, 45,\n            45, 46, 47, 48,\n            51, 45, 46, 54,\n            47, 47, 55, 60,\n            48, 54, 61, 61,\n            61, 63, 63, 65,\n            65, 67, 65, 0,\n            67\n        ];\n\n        // Clothes.\n        traitRarities[2] = [\n            201, 251, 190, 122, 143,  97,  46, 224, 233, 131, 203,\n            253, 194, 153, 153, 153,  56, 126,  81,  66, 106,  97,\n            62,  50,  50,  72,  50,  50,  81, 179, 153,  72, 253,\n            184, 228, 112, 130, 108,  62,  62, 131, 153, 108, 151,\n            234,  91, 203, 111, 233, 102,  54,  72,  85,  58, 184,\n            153, 112,  81, 131,  91,  31, 215, 117, 203, 153, 212,\n            97, 153, 184, 218, 114, 255\n        ];\n        traitAliases[2] = [\n            1,  2,  8,  0,  2,  8, 12, 12, 12, 12, 29, 29,\n            29, 29, 34, 34, 36, 43, 47, 61, 62, 65, 69, 69,\n            70, 70, 70, 71, 71, 34, 71, 71, 71, 71, 36, 71,\n            43, 71, 71, 71, 71, 71, 71, 44, 47, 71, 71, 48,\n            61, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71,\n            71, 62, 65, 71, 71, 69, 71, 71, 71, 70, 71, 0\n        ];\n\n        // Ears.\n        traitRarities[3] = [\n            23,  26,  52,  35, 152,\n            158, 200, 107, 157,  30,\n            87, 189, 255\n        ];\n        traitAliases[3] = [\n            4,  7, 7, 11,  5,\n            6,  7, 8, 11, 11,\n            12, 12, 0\n        ];\n\n        // Eyes.\n        traitRarities[4] = [\n            51,  70, 187, 151, 126, 163,  60,\n            51,  27,  30,  97, 237,  69, 249,\n            19,  34, 163,  90, 144, 117, 105,\n            125, 169, 136,  27,  90, 109,  47,\n            255\n        ];\n        traitAliases[4] = [\n            4, 28, 28, 28,  5, 22, 28, 28,\n            28, 28, 28, 28, 28, 28, 28, 28,\n            28, 28, 28, 28, 28, 28, 28, 28,\n            28, 28, 28, 28, 0\n        ];\n\n        // Heads.\n        traitRarities[5] = [\n            145, 127,  47,  13,  27, 221, 228, 147, 241, 114,  65, 199,\n            49,  29, 215,  51,  98, 255, 189,  53,  56,  58,  32,  42,\n            67, 209,  89, 212,  60,  45,  31,  33,  16,  20,  40,  62,\n            168, 189, 131,  36, 105, 216,  74,  87, 155, 252,  71,  71,\n            118, 193, 216,  67, 196, 203,  78, 242,  22, 145,  46,  89,\n            100, 123, 221, 147, 167,  25,  38, 125, 138, 214, 143, 190,\n            232,  74, 175,  40, 216, 221, 218, 130, 242, 191, 255\n        ];\n        traitAliases[5] = [\n            6, 11, 16, 22, 37, 37,  8, 37, 11, 41, 43, 14,\n            48, 58, 16, 62, 17, 22, 71, 73, 79, 81, 26, 82,\n            82, 82, 36, 82, 82, 82, 82, 82, 82, 82, 82, 82,\n            37, 41, 82, 82, 82, 43, 82, 44, 45, 48, 82, 82,\n            49, 50, 55, 82, 82, 82, 82, 58, 82, 82, 61, 82,\n            82, 62, 71, 82, 82, 82, 82, 82, 82, 82, 82, 72,\n            73, 74, 77, 82, 82, 79, 82, 80, 81, 82, 0\n        ];\n\n        // Necks.\n        traitRarities[6] = [\n            67,  70, 23, 86,  51,\n            56, 121, 67, 60, 255\n        ];\n        traitAliases[6] = [\n            9, 9, 9, 9, 9,\n            9, 9, 9, 9, 0\n        ];\n\n        // Paws.\n        traitRarities[7] = [\n            193, 133, 111, 230, 106,  89,  59, 126,  94, 197,  94,\n            236, 239, 115, 198,  85,  24, 204,  28, 150,  78,  80,\n            217, 222,  90, 128, 120,  48, 130, 188, 122, 192,  61,\n            63,  67,  69,  70,  87,  33,  97, 120, 232, 124,  89,\n            99, 218,  41, 244,  93, 230, 107, 239,  96,  81, 109,\n            85,  74,  25,  98,  87, 254, 130, 102, 165,  56,  78,\n            250, 119, 255\n        ];\n        traitAliases[7] = [\n            1,  3,  0,  8,  1,  8, 24, 28,  9, 11, 39, 12,\n            24, 44, 44, 44, 57, 65, 65, 67, 67, 68, 68, 68,\n            28, 68, 68, 68, 29, 31, 68, 39, 68, 68, 68, 68,\n            68, 68, 68, 40, 41, 44, 68, 68, 45, 47, 68, 57,\n            68, 68, 68, 68, 68, 68, 68, 68, 68, 63, 68, 68,\n            68, 68, 68, 65, 68, 66, 67, 68, 0\n        ];\n\n        // Special.\n        traitRarities[8] = [\n            12, 10,   8, 14,\n            19, 17, 255\n        ];\n        traitAliases[8] = [\n            6, 6, 6, 6, 6, 6, 0\n        ];\n    }\n\n    /// MODIFIERS ///\n\n    /// @notice Some anti-bot restrictions.\n    modifier noCheats() {\n        uint256 size = 0;\n        address account = msg.sender;\n        assembly {\n            size := extcodesize(account)\n        }\n\n        require(\n            admins[msg.sender] || (msg.sender == tx.origin && size == 0),\n            \"You're trying to cheat!\"\n        );\n        _;\n\n        // Use the last caller hash to add entropy to next caller.\n        entropy = keccak256(abi.encodePacked(account, block.coinbase));\n    }\n\n    modifier increaseEntropy() {\n        _;\n\n        // Use the last caller hash to add entropy to next caller.\n        entropy = keccak256(abi.encodePacked(msg.sender, block.coinbase));\n    }\n\n    modifier onlyAdmin() {\n        require(admins[msg.sender], \"Must be an admin\");\n        _;\n    }\n\n    modifier publicSaleActive() {\n        require(isPublicSaleActive, \"Public sale is not open\");\n        _;\n    }\n\n    modifier communitySaleActive() {\n        require(isCommunitySaleActive, \"Community sale is not open\");\n        _;\n    }\n\n    modifier canMintKittens(uint256 numberOfTokens) {\n        require(numberOfTokens > 0, \"Cannot mint zero\");\n        require(numberOfTokens <= MAX_KITTENS_PER_WALLET, \"Max kittens to mint exceeded\");\n        require(\n            tokenCounter + numberOfTokens <= MAX_KITTENS,\n            \"Not enough kittens remaining to mint\"\n        );\n        _;\n    }\n\n    modifier canGiftKittens(uint256 num) {\n        require(\n            numGiftedKittens + num <= MAX_GIFTED_KITTENS,\n            \"Not enough kittens remaining to gift\"\n        );\n        require(\n            tokenCounter + num <= MAX_KITTENS,\n            \"Not enough kittens remaining to mint\"\n        );\n        _;\n    }\n\n    modifier isCorrectCommunitySalePayment() {\n        require(msg.value == COMMUNITY_SALE_PRICE, \"Incorrect ETH value sent\");\n        _;\n    }\n\n    modifier isCorrectPublicSalePayment(uint256 number) {\n        require(msg.value == (PUBLIC_SALE_PRICE * number) + sauce[number - 1], \"Incorrect ETH value sent\");\n        _;\n    }\n\n    /// MINTING ///\n\n    function mint(uint256 amount, address to)\n        external\n        payable\n        publicSaleActive\n        canMintKittens(amount)\n        isCorrectPublicSalePayment(amount)\n        noCheats\n    {\n        require(!publicSaleParticipants[msg.sender], \"Already minted\");\n\n        publicSaleParticipants[msg.sender] = true;\n\n        uint256 seed = _rand();\n        for (uint64 i = 0; i < amount; ++i) {\n            _mintKitten(seed, to);\n        }\n    }\n\n    function mintCommunitySale(\n        address to,\n        bytes32[] calldata merkleProof\n    )\n        external\n        payable\n        communitySaleActive\n        canMintKittens(1)\n        isCorrectCommunitySalePayment\n        noCheats\n    {\n        // We have two checks here, since some addresses have two claims.\n\n        if (claimedFirst[to]) {\n            // Check for second claim.\n            require(!claimedSecond[to], \"Already claimed\");\n\n            require(_isValidMerkleProof(merkleProof, communitySecondClaimMerkleRoot, to), \"Already claimed\");\n\n            claimedSecond[to] = true;\n            _mintKitten(_rand(), to);\n        } else {\n            // First claim.\n            require(_isValidMerkleProof(merkleProof, communityFirstClaimMerkleRoot, to), \"Address not in list\");\n\n            claimedFirst[to] = true;\n            _mintKitten(_rand(), to);\n        }\n    }\n\n    function reserveForGifting(uint256 amount)\n        external\n        onlyAdmin\n        canGiftKittens(amount)\n        increaseEntropy\n    {\n        numGiftedKittens += amount;\n\n        uint256 seed = _rand();\n        for (uint256 i = 0; i < amount; i++) {\n            _mintKitten(seed, msg.sender);\n        }\n    }\n\n    function giftKittens(address[] calldata addresses)\n        external\n        onlyAdmin\n        canGiftKittens(addresses.length)\n        increaseEntropy\n    {\n        uint256 numToGift = addresses.length;\n        numGiftedKittens += numToGift;\n\n        uint256 seed = _rand();\n        for (uint256 i = 0; i < numToGift; i++) {\n            _mintKitten(seed, addresses[i]);\n        }\n    }\n\n    function _mintKitten(uint256 seed, address to) internal {\n        uint256 tokenId = _getNextTokenId();\n        kittens[tokenId] = selectTraits(_randomize(seed, tokenId));\n\n        _safeMint(to, tokenId);\n    }\n\n    /// IKITTEN ///\n\n    function getOwner(uint256 tokenId) public view returns (address) {\n        return ownerOf[tokenId];\n    }\n\n    function getNextTokenId() public view returns (uint256) {\n        return tokenCounter + 1;\n    }\n\n    function getKitten(uint256 tokenId) public view returns (Kitten memory) {\n        require(_exists(tokenId), \"No such kitten\");\n\n        return kittens[_getOffsetTokenId(tokenId)];\n    }\n\n    /// @notice Returns a single trait value for a Kitten.\n    function getTrait(uint256 tokenId, Trait trait) public view returns (uint8) {\n        require(_exists(tokenId), \"No such kitten\");\n\n        Kitten storage kitten = kittens[_getOffsetTokenId(tokenId)];\n\n        if (trait == Trait.Background)      return kitten.background;\n        else if (trait == Trait.Body)       return kitten.body;\n        else if (trait == Trait.Clothes)    return kitten.clothes;\n        else if (trait == Trait.Ears)       return kitten.ears;\n        else if (trait == Trait.Eyes)       return kitten.eyes;\n        else if (trait == Trait.Head)       return kitten.head;\n        else if (trait == Trait.Neck)       return kitten.neck;\n        else if (trait == Trait.Special)    return kitten.special;\n        else return kitten.weapon;\n    }\n\n    /// @notice Updates a single trait for a Kitten.\n    /// @dev Used for swapping traits after battles.\n    function updateTrait(uint256 tokenId, Trait trait, uint8 value) public onlyAdmin {\n        require(_exists(tokenId), \"No such kitten\");\n\n        Kitten storage kitten = kittens[_getOffsetTokenId(tokenId)];\n\n        if (trait == Trait.Background)      kitten.background = value;\n        else if (trait == Trait.Body)       kitten.body = value;\n        else if (trait == Trait.Clothes)    kitten.clothes = value;\n        else if (trait == Trait.Ears)       kitten.ears = value;\n        else if (trait == Trait.Eyes)       kitten.eyes = value;\n        else if (trait == Trait.Head)       kitten.head = value;\n        else if (trait == Trait.Neck)       kitten.neck = value;\n        else if (trait == Trait.Special)    kitten.special = value;\n        else if (trait == Trait.Weapon)     kitten.weapon = value;\n    }\n\n    /// @notice Toggle the Kitten's mode.\n    function setKittenMode(uint256 tokenId, bool special) external {\n        // Must be sender's Kitten.\n        require(ownerOf[tokenId] == msg.sender, \"Not your kitten\");\n\n        specialMode[tokenId] = special;\n    }\n\n    /// HELPERS ///\n\n    function _isValidMerkleProof(\n        bytes32[] calldata merkleProof,\n        bytes32 root,\n        address account\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(\n            merkleProof,\n            root,\n            keccak256(abi.encodePacked(account))\n        );\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return ownerOf[tokenId] != address(0) && tokenId <= MAX_KITTENS;\n    }\n\n    /// @notice Returns a shifted token ID once we've performed the reveal shift.\n    /// @dev Ensure the shift is done *before* reveal is toggled.\n    function _getOffsetTokenId(uint256 tokenId) internal view virtual returns (uint256) {\n        if (!hasShifted || metadataOffset == 0) {\n            return tokenId;\n        }\n\n        return ((tokenId + metadataOffset) % MAX_KITTENS) + 1;\n    }\n\n    function _getNextTokenId() private returns (uint256) {\n        ++ tokenCounter;\n        return tokenCounter;\n    }\n\n    /// TRAITS ///\n\n    /// @notice Uses AJ Walker's Alias algorithm for O(1) rarity table lookup.\n    /// @notice Ensures O(1) instead of O(n), reduces mint cost.\n    /// @notice Probability & alias tables are generated off-chain beforehand.\n    function selectTrait(uint16 seed, uint8 traitType)\n        internal\n        view\n        returns (uint8)\n    {\n        uint8 trait = uint8(seed) % uint8(traitRarities[traitType].length);\n        // If a selected random trait probability is selected (biased coin) return that trait.\n        if (seed >> 8 < traitRarities[traitType][trait]) return trait;\n        return uint8(traitAliases[traitType][trait]);\n    }\n\n    /// @notice Constructs a Kitten with weighted random attributes.\n    function selectTraits(uint256 seed)\n        internal\n        view\n        returns (Kitten memory kitten)\n    {\n\n        kitten.background   = selectTrait(uint16(seed & 0xFFFF), 0) + 1;\n        seed >>= 16;\n        kitten.body         = selectTrait(uint16(seed & 0xFFFF), 1) + 1;\n        seed >>= 16;\n        kitten.clothes      = selectTrait(uint16(seed & 0xFFFF), 2) + 1;\n        seed >>= 16;\n        kitten.ears         = selectTrait(uint16(seed & 0xFFFF), 3) + 1;\n        seed >>= 16;\n        kitten.eyes         = selectTrait(uint16(seed & 0xFFFF), 4) + 1;\n        seed >>= 16;\n        kitten.head         = selectTrait(uint16(seed & 0xFFFF), 5) + 1;\n        seed >>= 16;\n        kitten.neck         = selectTrait(uint16(seed & 0xFFFF), 6) + 1;\n        seed >>= 16;\n        kitten.weapon       = selectTrait(uint16(seed & 0xFFFF), 7) + 1;\n        seed >>= 16;\n        kitten.special      = selectTrait(uint16(seed & 0xFFFF), 8) + 1;\n    }\n\n    /// ADMIN ///\n\n    /// @notice Adds or removes an admin address.\n    function setAdmin(address admin, bool isAdmin) external onlyOwner {\n        admins[admin] = isAdmin;\n    }\n\n    function setRenderer(address _renderer) external onlyAdmin {\n        renderer = _renderer;\n    }\n\n    function setIsPublicSaleActive(bool _isPublicSaleActive)\n        external\n        onlyOwner\n    {\n        isPublicSaleActive = _isPublicSaleActive;\n    }\n\n    function setIsCommunitySaleActive(bool _isCommunitySaleActive)\n        external\n        onlyOwner\n    {\n        isCommunitySaleActive = _isCommunitySaleActive;\n    }\n\n    function setFirstCommunityListMerkleRoot(bytes32 merkleRoot) external onlyOwner {\n        communityFirstClaimMerkleRoot = merkleRoot;\n    }\n\n    function setSecondCommunityListMerkleRoot(bytes32 merkleRoot) external onlyOwner {\n        communitySecondClaimMerkleRoot = merkleRoot;\n    }\n\n    function setRoyaltyPercentage(uint8 percent) external onlyOwner {\n        royaltyPercent = percent;\n    }\n\n    /// @notice Sets a shifted metadata offset so that Kitten traits aren't mapped precisely to token ID.\n    /// @notice This ensures you can't predict which Kitten traits you'll get at mint time.\n    /// @dev The actual offset ends up being this offset + 1, since we do a modulo on the supply and start with token 1.\n    function setMetadataOffset(uint256 offset) external onlyOwner {\n        if (!hasShifted) {\n            metadataOffset = offset;\n            hasShifted = true;\n        }\n    }\n\n    /// @notice Resets the metadata shift offset to 0 in case something unexpected happens.\n    /// @dev We wouldn't be able to shift again, since the offset is a one-time setter (no rugs!).\n    function resetMetadataOffset() external onlyOwner {\n        metadataOffset = 0;\n    }\n\n    function setRevealed() external onlyOwner {\n        isRevealed = true;\n    }\n\n    /// @notice Break glass in case of emergency.\n    function deSauce() external onlyOwner {\n        sauce = [0, 0, 0, 0];\n    }\n\n    /// @notice Send contract balance to owner.\n    function withdraw() external onlyOwner {\n        (bool success, ) = owner().call{value: address(this).balance}(\"\");\n        require(success, \"Withdraw failed\");\n    }\n\n    /// @notice Do our best to get mistakenly sent ERC20s out of the contract.\n    function withdrawTokens(address token) external onlyOwner {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).transfer(msg.sender, balance);\n    }\n\n    /// RANDOMNESS ///\n\n    /// @notice Create a bit more randomness by hashing a seed with another input value.\n    /// @dev We do this to \"re-hash\" pseudorandom values within the same tx.\n    /// @dev h/t 0xBasset.\n    function _randomize(uint256 rand, uint256 zest) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encode(rand, zest)));\n    }\n\n    /// @notice Generates a pseudorandom number based on the current block and caller.\n    /// @dev This will be the same if called in the same tx without changing entropy.\n    function _rand() internal view returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.basefee, block.coinbase, entropy)));\n    }\n\n    /// OVERRIDES ///\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        virtual\n        override(ERC721, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC2981).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        require(_exists(tokenId), \"Nonexistent token\");\n\n        if (!isRevealed) {\n            return IMetadata(renderer).getPlaceholderURI(tokenId);\n        }\n\n        Kitten storage kitten = kittens[_getOffsetTokenId(tokenId)];\n        return IMetadata(renderer).getTokenURI(tokenId, kitten, specialMode[tokenId]);\n    }\n\n    /// @notice Royalty metadata.\n    /// @dev See {IERC165-royaltyInfo}.\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        override\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        require(_exists(tokenId), \"Nonexistent token\");\n\n        return (address(this), (salePrice * royaltyPercent) / 100);\n    }\n}\n"
6     },
7     "@openzeppelin/contracts/access/Ownable.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
9     },
10     "@openzeppelin/contracts/interfaces/IERC20.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
12     },
13     "@openzeppelin/contracts/interfaces/IERC2981.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be payed in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
15     },
16     "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
18     },
19     "@rari-capital/solmate/src/tokens/ERC721.sol": {
20       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(uint256 => address) public ownerOf;\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = ownerOf[id];\n\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            balanceOf[owner]--;\n        }\n\n        delete ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
21     },
22     "contracts/interfaces/IKitten.sol": {
23       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\ninterface IKitten {\n    enum Trait {\n        Background,\n        Body,\n        Clothes,\n        Ears,\n        Eyes,\n        Head,\n        Neck,\n        Special,\n        Weapon\n    }\n\n    struct Kitten {\n        uint8 background;\n        uint8 body;\n        uint8 clothes;\n        uint8 ears;\n        uint8 eyes;\n        uint8 head;\n        uint8 neck;\n        uint8 special;\n        uint8 weapon;\n    }\n\n    /// ERC721-like\n\n    function getOwner(uint256 tokenId) external view returns (address);\n\n    function getNextTokenId() external view returns (uint256);\n\n    /// WarKittens\n\n    function mint(uint256 amount, address to) external payable;\n\n    function mintCommunitySale(address to, bytes32[] calldata merkleProof) external payable;\n\n    function reserveForGifting(uint256 amount) external;\n\n    function giftKittens(address[] calldata addresses) external;\n\n    function getKitten(uint256 tokenId) external view returns (Kitten memory);\n\n    function getTrait(uint256 tokenId, Trait trait) external view returns (uint8);\n\n    function updateTrait(uint256 tokenId, Trait trait, uint8 value) external;\n}\n"
24     },
25     "contracts/interfaces/IMetadata.sol": {
26       "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"./IKitten.sol\";\n\ninterface IMetadata {\n    function getPlaceholderURI(uint256 tokenId) external view returns (string memory);\n\n    function getTokenURI(uint256 tokenId, IKitten.Kitten calldata kitten, bool offChain)\n        external\n        view\n        returns (string memory);\n\n    function uploadTraits(\n        uint8 trait,\n        uint8[] calldata traitIds,\n        string[] calldata names,\n        string[] calldata images\n    ) external;\n}\n"
27     },
28     "@openzeppelin/contracts/utils/Context.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
30     },
31     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
33     },
34     "@openzeppelin/contracts/interfaces/IERC165.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
36     },
37     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
39     }
40   },
41   "settings": {
42     "optimizer": {
43       "enabled": true,
44       "runs": 2000
45     },
46     "outputSelection": {
47       "*": {
48         "*": [
49           "evm.bytecode",
50           "evm.deployedBytecode",
51           "devdoc",
52           "userdoc",
53           "metadata",
54           "abi"
55         ]
56       }
57     },
58     "metadata": {
59       "useLiteralContent": true
60     },
61     "libraries": {}
62   }
63 }}