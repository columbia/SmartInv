1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/minter-suite/MinterDALinV1.sol": {
5       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"../interfaces/0.8.x/IGenArt721CoreContractV1.sol\";\nimport \"../interfaces/0.8.x/IMinterFilterV0.sol\";\nimport \"../interfaces/0.8.x/IFilteredMinterV0.sol\";\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\npragma solidity 0.8.9;\n\n/**\n * @title Filtered Minter contract that allows tokens to be minted with ETH.\n * Pricing is achieved using an automated Dutch-auction mechanism.\n * @author Art Blocks Inc.\n */\ncontract MinterDALinV1 is ReentrancyGuard, IFilteredMinterV0 {\n    /// Auction details updated for project `projectId`.\n    event SetAuctionDetails(\n        uint256 indexed projectId,\n        uint256 _auctionTimestampStart,\n        uint256 _auctionTimestampEnd,\n        uint256 _startPrice,\n        uint256 _basePrice\n    );\n\n    /// Auction details cleared for project `projectId`.\n    event ResetAuctionDetails(uint256 indexed projectId);\n\n    /// Minimum allowed auction length updated\n    event MinimumAuctionLengthSecondsUpdated(\n        uint256 _minimumAuctionLengthSeconds\n    );\n\n    /// Core contract address this minter interacts with\n    address public immutable genArt721CoreAddress;\n\n    /// This contract handles cores with interface IV1\n    IGenArt721CoreContractV1 private immutable genArtCoreContract;\n\n    /// Minter filter address this minter interacts with\n    address public immutable minterFilterAddress;\n\n    /// Minter filter this minter may interact with.\n    IMinterFilterV0 private immutable minterFilter;\n\n    /// minterType for this minter\n    string public constant minterType = \"MinterDALinV1\";\n\n    uint256 constant ONE_MILLION = 1_000_000;\n\n    /// projectId => has project reached its maximum number of invocations?\n    mapping(uint256 => bool) public projectMaxHasBeenInvoked;\n    /// projectId => project's maximum number of invocations\n    mapping(uint256 => uint256) public projectMaxInvocations;\n    /// Minimum auction length in seconds\n    uint256 public minimumAuctionLengthSeconds = 3600;\n\n    /// projectId => auction parameters\n    mapping(uint256 => AuctionParameters) public projectAuctionParameters;\n    struct AuctionParameters {\n        uint256 timestampStart;\n        uint256 timestampEnd;\n        uint256 startPrice;\n        uint256 basePrice;\n    }\n\n    modifier onlyCoreWhitelisted() {\n        require(\n            genArtCoreContract.isWhitelisted(msg.sender),\n            \"Only Core whitelisted\"\n        );\n        _;\n    }\n\n    modifier onlyArtist(uint256 _projectId) {\n        require(\n            (msg.sender ==\n                genArtCoreContract.projectIdToArtistAddress(_projectId)),\n            \"Only Artist\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Initializes contract to be a Filtered Minter for\n     * `_minterFilter`, integrated with Art Blocks core contract\n     * at address `_genArt721Address`.\n     * @param _genArt721Address Art Blocks core contract address for\n     * which this contract will be a minter.\n     * @param _minterFilter Minter filter for which\n     * this will a filtered minter.\n     */\n    constructor(address _genArt721Address, address _minterFilter)\n        ReentrancyGuard()\n    {\n        genArt721CoreAddress = _genArt721Address;\n        genArtCoreContract = IGenArt721CoreContractV1(_genArt721Address);\n        minterFilterAddress = _minterFilter;\n        minterFilter = IMinterFilterV0(_minterFilter);\n        require(\n            minterFilter.genArt721CoreAddress() == _genArt721Address,\n            \"Illegal contract pairing\"\n        );\n    }\n\n    /**\n     * @notice Sets the maximum invocations of project `_projectId` based\n     * on the value currently defined in the core contract.\n     * @param _projectId Project ID to set the maximum invocations for.\n     * @dev also checks and may refresh projectMaxHasBeenInvoked for project\n     * @dev this enables gas reduction after maxInvocations have been reached -\n     * core contracts shall still enforce a maxInvocation check during mint.\n     */\n    function setProjectMaxInvocations(uint256 _projectId)\n        external\n        onlyCoreWhitelisted\n    {\n        uint256 invocations;\n        uint256 maxInvocations;\n        (, , invocations, maxInvocations, , , , , ) = genArtCoreContract\n            .projectTokenInfo(_projectId);\n        // update storage with results\n        projectMaxInvocations[_projectId] = maxInvocations;\n        if (invocations < maxInvocations) {\n            projectMaxHasBeenInvoked[_projectId] = false;\n        }\n    }\n\n    /**\n     * @notice Warning: Disabling purchaseTo is not supported on this minter.\n     * This method exists purely for interface-conformance purposes.\n     */\n    function togglePurchaseToDisabled(uint256 _projectId)\n        external\n        view\n        onlyArtist(_projectId)\n    {\n        revert(\"Action not supported\");\n    }\n\n    /**\n     * @notice Sets minimum auction length to `_minimumAuctionLengthSeconds`\n     * for all projects.\n     * @param _minimumAuctionLengthSeconds Minimum auction length in seconds.\n     */\n    function setMinimumAuctionLengthSeconds(\n        uint256 _minimumAuctionLengthSeconds\n    ) external onlyCoreWhitelisted {\n        minimumAuctionLengthSeconds = _minimumAuctionLengthSeconds;\n        emit MinimumAuctionLengthSecondsUpdated(_minimumAuctionLengthSeconds);\n    }\n\n    ////// Auction Functions\n    /**\n     * @notice Sets auction details for project `_projectId`.\n     * @param _projectId Project ID to set auction details for.\n     * @param _auctionTimestampStart Timestamp at which to start the auction.\n     * @param _auctionTimestampEnd Timestamp at which to end the auction.\n     * @param _startPrice Price at which to start the auction, in Wei.\n     * @param _basePrice Resting price of the auction, in Wei.\n     */\n    function setAuctionDetails(\n        uint256 _projectId,\n        uint256 _auctionTimestampStart,\n        uint256 _auctionTimestampEnd,\n        uint256 _startPrice,\n        uint256 _basePrice\n    ) external onlyArtist(_projectId) {\n        AuctionParameters memory auctionParams = projectAuctionParameters[\n            _projectId\n        ];\n        require(\n            auctionParams.timestampStart == 0 ||\n                block.timestamp < auctionParams.timestampStart,\n            \"No modifications mid-auction\"\n        );\n        require(\n            block.timestamp < _auctionTimestampStart,\n            \"Only future auctions\"\n        );\n        require(\n            _auctionTimestampEnd > _auctionTimestampStart,\n            \"Auction end must be greater than auction start\"\n        );\n        require(\n            _auctionTimestampEnd >=\n                _auctionTimestampStart + minimumAuctionLengthSeconds,\n            \"Auction length must be at least minimumAuctionLengthSeconds\"\n        );\n        require(\n            _startPrice > _basePrice,\n            \"Auction start price must be greater than auction end price\"\n        );\n        projectAuctionParameters[_projectId] = AuctionParameters(\n            _auctionTimestampStart,\n            _auctionTimestampEnd,\n            _startPrice,\n            _basePrice\n        );\n        emit SetAuctionDetails(\n            _projectId,\n            _auctionTimestampStart,\n            _auctionTimestampEnd,\n            _startPrice,\n            _basePrice\n        );\n    }\n\n    /**\n     * @notice Resets auction details for project `_projectId`, zero-ing out all\n     * relevant auction fields. Not intended to be used in normal auction\n     * operation, but rather only in case of the need to halt an auction.\n     * @param _projectId Project ID to set auction details for.\n     */\n    function resetAuctionDetails(uint256 _projectId)\n        external\n        onlyCoreWhitelisted\n    {\n        delete projectAuctionParameters[_projectId];\n        emit ResetAuctionDetails(_projectId);\n    }\n\n    /**\n     * @notice Purchases a token from project `_projectId`.\n     * @param _projectId Project ID to mint a token on.\n     * @return tokenId Token ID of minted token\n     */\n    function purchase(uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId)\n    {\n        tokenId = purchaseTo(msg.sender, _projectId);\n        return tokenId;\n    }\n\n    /**\n     * @notice Purchases a token from project `_projectId` and sets\n     * the token's owner to `_to`.\n     * @param _to Address to be the new token's owner.\n     * @param _projectId Project ID to mint a token on.\n     * @return tokenId Token ID of minted token\n     */\n    function purchaseTo(address _to, uint256 _projectId)\n        public\n        payable\n        nonReentrant\n        returns (uint256 tokenId)\n    {\n        // CHECKS\n        require(\n            !projectMaxHasBeenInvoked[_projectId],\n            \"Maximum number of invocations reached\"\n        );\n\n        // _getPrice reverts if auction is unconfigured or has not started\n        uint256 currentPriceInWei = _getPrice(_projectId);\n        require(\n            msg.value >= currentPriceInWei,\n            \"Must send minimum value to mint!\"\n        );\n\n        // EFFECTS\n        tokenId = minterFilter.mint(_to, _projectId, msg.sender);\n        // what if projectMaxInvocations[_projectId] is 0 (default value)?\n        // that is intended, so that by default the minter allows infinite transactions,\n        // allowing the artblocks contract to stop minting\n        // uint256 tokenInvocation = tokenId % ONE_MILLION;\n        if (\n            projectMaxInvocations[_projectId] > 0 &&\n            tokenId % ONE_MILLION == projectMaxInvocations[_projectId] - 1\n        ) {\n            projectMaxHasBeenInvoked[_projectId] = true;\n        }\n\n        // INTERACTIONS\n        _splitFundsETHAuction(_projectId, currentPriceInWei);\n\n        return tokenId;\n    }\n\n    /**\n     * @dev splits ETH funds between sender (if refund), foundation,\n     * artist, and artist's additional payee for a token purchased on\n     * project `_projectId`.\n     * @dev utilizes transfer() to send ETH, which may fail if access\n     * lists are not properly populated when purchasing tokens.\n     * @param _projectId Project ID for which funds shall be split.\n     * @param _currentPriceInWei Current price of token, in Wei.\n     */\n    function _splitFundsETHAuction(\n        uint256 _projectId,\n        uint256 _currentPriceInWei\n    ) internal {\n        if (msg.value > 0) {\n            uint256 refund = msg.value - _currentPriceInWei;\n            if (refund > 0) {\n                (bool success_, ) = msg.sender.call{value: refund}(\"\");\n                require(success_, \"Refund failed\");\n            }\n            uint256 foundationAmount = (_currentPriceInWei *\n                genArtCoreContract.artblocksPercentage()) / 100;\n            if (foundationAmount > 0) {\n                (bool success_, ) = genArtCoreContract.artblocksAddress().call{\n                    value: foundationAmount\n                }(\"\");\n                require(success_, \"Foundation payment failed\");\n            }\n            uint256 projectFunds = _currentPriceInWei - foundationAmount;\n            uint256 additionalPayeeAmount;\n            if (\n                genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                    _projectId\n                ) > 0\n            ) {\n                additionalPayeeAmount =\n                    (projectFunds *\n                        genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                            _projectId\n                        )) /\n                    100;\n                if (additionalPayeeAmount > 0) {\n                    (bool success_, ) = genArtCoreContract\n                        .projectIdToAdditionalPayee(_projectId)\n                        .call{value: additionalPayeeAmount}(\"\");\n                    require(success_, \"Additional payment failed\");\n                }\n            }\n            uint256 creatorFunds = projectFunds - additionalPayeeAmount;\n            if (creatorFunds > 0) {\n                (bool success_, ) = genArtCoreContract\n                    .projectIdToArtistAddress(_projectId)\n                    .call{value: creatorFunds}(\"\");\n                require(success_, \"Artist payment failed\");\n            }\n        }\n    }\n\n    /**\n     * @notice Gets price of minting a token on project `_projectId` given\n     * the project's AuctionParameters and current block timestamp.\n     * Reverts if auction has not yet started or auction is unconfigured.\n     * @param _projectId Project ID to get price of token for.\n     * @return current price of token in Wei\n     */\n    function _getPrice(uint256 _projectId) private view returns (uint256) {\n        AuctionParameters memory auctionParams = projectAuctionParameters[\n            _projectId\n        ];\n        require(\n            block.timestamp > auctionParams.timestampStart,\n            \"Auction not yet started\"\n        );\n        if (block.timestamp >= auctionParams.timestampEnd) {\n            require(auctionParams.timestampEnd > 0, \"Only configured auctions\");\n            return auctionParams.basePrice;\n        }\n        uint256 elapsedTime = block.timestamp - auctionParams.timestampStart;\n        uint256 duration = auctionParams.timestampEnd -\n            auctionParams.timestampStart;\n        uint256 startToEndDiff = auctionParams.startPrice -\n            auctionParams.basePrice;\n        return\n            auctionParams.startPrice -\n            ((elapsedTime * startToEndDiff) / duration);\n    }\n\n    /**\n     * @notice Gets if price of token is configured, price of minting a\n     * token on project `_projectId`, and currency symbol and address to be\n     * used as payment. Supersedes any core contract price information.\n     * @param _projectId Project ID to get price information for.\n     * @return isConfigured true only if project's auction parameters have been\n     * configured on this minter\n     * @return tokenPriceInWei current price of token on this minter - invalid\n     * if auction has not yet been configured\n     * @return currencySymbol currency symbol for purchases of project on this\n     * minter. This minter always returns \"ETH\"\n     * @return currencyAddress currency address for purchases of project on\n     * this minter. This minter always returns null address, reserved for ether\n     */\n    function getPriceInfo(uint256 _projectId)\n        external\n        view\n        returns (\n            bool isConfigured,\n            uint256 tokenPriceInWei,\n            string memory currencySymbol,\n            address currencyAddress\n        )\n    {\n        AuctionParameters memory auctionParams = projectAuctionParameters[\n            _projectId\n        ];\n        isConfigured = (auctionParams.startPrice > 0);\n        if (block.timestamp <= auctionParams.timestampStart) {\n            // Provide a reasonable value for `tokenPriceInWei` when it would\n            // otherwise revert, using the starting price before auction starts.\n            tokenPriceInWei = auctionParams.startPrice;\n        } else if (auctionParams.timestampEnd == 0) {\n            // In the case of unconfigured auction, return price of zero when\n            // it would otherwise revert\n            tokenPriceInWei = 0;\n        } else {\n            tokenPriceInWei = _getPrice(_projectId);\n        }\n        currencySymbol = \"ETH\";\n        currencyAddress = address(0);\n    }\n}\n"
6     },
7     "contracts/interfaces/0.8.x/IGenArt721CoreContractV1.sol": {
8       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IGenArt721CoreContractV1 {\n    event Mint(\n        address indexed _to,\n        uint256 indexed _tokenId,\n        uint256 indexed _projectId\n    );\n\n    // getter function of public variable\n    function admin() external view returns (address);\n\n    // getter function of public variable\n    function nextProjectId() external view returns (uint256);\n\n    // getter function of public mapping\n    function tokenIdToProjectId(uint256 tokenId)\n        external\n        view\n        returns (uint256 projectId);\n\n    function isWhitelisted(address sender) external view returns (bool);\n\n    // @dev this is not available in V0\n    function isMintWhitelisted(address minter) external view returns (bool);\n\n    function projectIdToArtistAddress(uint256 _projectId)\n        external\n        view\n        returns (address payable);\n\n    function projectIdToAdditionalPayee(uint256 _projectId)\n        external\n        view\n        returns (address payable);\n\n    function projectIdToAdditionalPayeePercentage(uint256 _projectId)\n        external\n        view\n        returns (uint256);\n\n    function projectTokenInfo(uint256 _projectId)\n        external\n        view\n        returns (\n            address,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            address,\n            uint256,\n            string memory,\n            address\n        );\n\n    function artblocksAddress() external view returns (address payable);\n\n    function artblocksPercentage() external view returns (uint256);\n\n    function mint(\n        address _to,\n        uint256 _projectId,\n        address _by\n    ) external returns (uint256 tokenId);\n\n    function getRoyaltyData(uint256 _tokenId)\n        external\n        view\n        returns (\n            address artistAddress,\n            address additionalPayee,\n            uint256 additionalPayeePercentage,\n            uint256 royaltyFeeByID\n        );\n}\n"
9     },
10     "contracts/interfaces/0.8.x/IMinterFilterV0.sol": {
11       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IMinterFilterV0 {\n    /**\n     * @notice Approved minter `_minterAddress`.\n     */\n    event MinterApproved(address indexed _minterAddress, string _minterType);\n\n    /**\n     * @notice Revoked approval for minter `_minterAddress`\n     */\n    event MinterRevoked(address indexed _minterAddress);\n\n    /**\n     * @notice Minter `_minterAddress` of type `_minterType`\n     * registered for project `_projectId`.\n     */\n    event ProjectMinterRegistered(\n        uint256 indexed _projectId,\n        address indexed _minterAddress,\n        string _minterType\n    );\n\n    /**\n     * @notice Any active minter removed for project `_projectId`.\n     */\n    event ProjectMinterRemoved(uint256 indexed _projectId);\n\n    function genArt721CoreAddress() external returns (address);\n\n    function setMinterForProject(uint256, address) external;\n\n    function removeMinterForProject(uint256) external;\n\n    function mint(\n        address _to,\n        uint256 _projectId,\n        address sender\n    ) external returns (uint256);\n\n    function getMinterForProject(uint256) external view returns (address);\n\n    function projectHasMinter(uint256) external view returns (bool);\n}\n"
12     },
13     "contracts/interfaces/0.8.x/IFilteredMinterV0.sol": {
14       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IFilteredMinterV0 {\n    /**\n     * @notice Price per token in wei updated for project `_projectId` to\n     * `_pricePerTokenInWei`.\n     */\n    event PricePerTokenInWeiUpdated(\n        uint256 indexed _projectId,\n        uint256 indexed _pricePerTokenInWei\n    );\n\n    /**\n     * @notice Currency updated for project `_projectId` to symbol\n     * `_currencySymbol` and address `_currencyAddress`.\n     */\n    event ProjectCurrencyInfoUpdated(\n        uint256 indexed _projectId,\n        address indexed _currencyAddress,\n        string _currencySymbol\n    );\n\n    /// togglePurchaseToDisabled updated\n    event PurchaseToDisabledUpdated(\n        uint256 indexed _projectId,\n        bool _purchaseToDisabled\n    );\n\n    // getter function of public variable\n    function minterType() external view returns (string memory);\n\n    function genArt721CoreAddress() external returns (address);\n\n    function minterFilterAddress() external returns (address);\n\n    // Triggers a purchase of a token from the desired project, to the\n    // TX-sending address.\n    function purchase(uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId);\n\n    // Triggers a purchase of a token from the desired project, to the specified\n    // receiving address.\n    function purchaseTo(address _to, uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId);\n\n    // Toggles the ability for `purchaseTo` to be called directly with a\n    // specified receiving address that differs from the TX-sending address.\n    function togglePurchaseToDisabled(uint256 _projectId) external;\n\n    // Called to make the minter contract aware of the max invocations for a\n    // given project.\n    function setProjectMaxInvocations(uint256 _projectId) external;\n\n    // Gets if token price is configured, token price in wei, currency symbol,\n    // and currency address, assuming this is project's minter.\n    // Supersedes any defined core price.\n    function getPriceInfo(uint256 _projectId)\n        external\n        view\n        returns (\n            bool isConfigured,\n            uint256 tokenPriceInWei,\n            string memory currencySymbol,\n            address currencyAddress\n        );\n}\n"
15     },
16     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
18     }
19   },
20   "settings": {
21     "optimizer": {
22       "enabled": true,
23       "runs": 100
24     },
25     "outputSelection": {
26       "*": {
27         "*": [
28           "evm.bytecode",
29           "evm.deployedBytecode",
30           "devdoc",
31           "userdoc",
32           "metadata",
33           "abi"
34         ]
35       }
36     },
37     "libraries": {}
38   }
39 }}