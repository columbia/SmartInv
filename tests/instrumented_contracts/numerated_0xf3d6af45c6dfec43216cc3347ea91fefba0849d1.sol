1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/Dubi.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./ERC20.sol\";\nimport \"./Purpose.sol\";\n\ncontract Dubi is ERC20 {\n    Purpose private immutable _prps;\n\n    constructor(\n        uint256 initialSupply,\n        address optIn,\n        address purpose,\n        address hodl,\n        address externalAddress1,\n        address externalAddress2,\n        address externalAddress3\n    )\n        public\n        ERC20(\n            \"Decentralized Universal Basic Income\",\n            \"DUBI\",\n            optIn,\n            hodl,\n            externalAddress1,\n            externalAddress2,\n            externalAddress3\n        )\n    {\n        _mintInitialSupply(msg.sender, initialSupply);\n\n        _prps = Purpose(purpose);\n    }\n\n    function hodlMint(address to, uint256 amount) public {\n        require(msg.sender == _hodlAddress, \"DUBI-2\");\n        _mint(to, amount);\n    }\n\n    function purposeMint(address to, uint256 amount) public {\n        require(msg.sender == address(_prps), \"DUBI-3\");\n        _mint(to, amount);\n    }\n\n    function _callerIsDeployTimeKnownContract()\n        internal\n        override\n        view\n        returns (bool)\n    {\n        if (msg.sender == address(_prps)) {\n            return true;\n        }\n\n        return super._callerIsDeployTimeKnownContract();\n    }\n\n    //---------------------------------------------------------------\n    // Fuel\n    //---------------------------------------------------------------\n\n    /**\n     * @dev Burns `fuel` from `from`. Can only be called by one of the deploy-time known contracts.\n     */\n    function burnFuel(address from, TokenFuel memory fuel) public override {\n        require(_callerIsDeployTimeKnownContract(), \"DUBI-1\");\n        _burnFuel(from, fuel);\n    }\n\n    function _burnFuel(address from, TokenFuel memory fuel) private {\n        require(fuel.amount <= MAX_BOOSTER_FUEL, \"DUBI-5\");\n        require(from != address(0) && from != msg.sender, \"DUBI-6\");\n\n        if (fuel.tokenAlias == TOKEN_FUEL_ALIAS_DUBI) {\n            // Burn fuel from DUBI\n            UnpackedData memory unpacked = _unpackPackedData(_packedData[from]);\n            require(unpacked.balance >= fuel.amount, \"DUBI-7\");\n            unpacked.balance -= fuel.amount;\n            _packedData[from] = _packUnpackedData(unpacked);\n            return;\n        }\n\n        revert(\"DUBI-8\");\n    }\n\n    /**\n     *@dev Burn the fuel of a `boostedSend`\n     */\n    function _burnBoostedSendFuel(\n        address from,\n        BoosterFuel memory fuel,\n        UnpackedData memory unpacked\n    ) internal override returns (FuelBurn memory) {\n        FuelBurn memory fuelBurn;\n\n        if (fuel.dubi > 0) {\n            require(fuel.dubi <= MAX_BOOSTER_FUEL, \"DUBI-5\");\n\n            // From uses his own DUBI to fuel the boost\n            require(unpacked.balance >= fuelBurn.amount, \"DUBI-7\");\n            unpacked.balance -= fuel.dubi;\n\n            fuelBurn.amount = fuel.dubi;\n            fuelBurn.fuelType = FuelType.DUBI;\n\n            return fuelBurn;\n        }\n\n        // If the fuel is PRPS, then we have to reach out to the PRPS contract.\n        if (fuel.unlockedPrps > 0) {\n            // Reverts if the requested amount cannot be burned\n            _prps.burnFuel(\n                from,\n                TokenFuel({\n                    tokenAlias: TOKEN_FUEL_ALIAS_UNLOCKED_PRPS,\n                    amount: fuel.unlockedPrps\n                })\n            );\n\n            fuelBurn.amount = fuel.unlockedPrps;\n            fuelBurn.fuelType = FuelType.UNLOCKED_PRPS;\n            return fuelBurn;\n        }\n\n        if (fuel.lockedPrps > 0) {\n            // Reverts if the requested amount cannot be burned\n            _prps.burnFuel(\n                from,\n                TokenFuel({\n                    tokenAlias: TOKEN_FUEL_ALIAS_LOCKED_PRPS,\n                    amount: fuel.lockedPrps\n                })\n            );\n\n            fuelBurn.amount = fuel.lockedPrps;\n            fuelBurn.fuelType = FuelType.LOCKED_PRPS;\n            return fuelBurn;\n        }\n\n        // No fuel at all\n        return fuelBurn;\n    }\n\n    /**\n     *@dev Burn the fuel of a `boostedBurn`\n     */\n    function _burnBoostedBurnFuel(\n        address from,\n        BoosterFuel memory fuel,\n        UnpackedData memory unpacked\n    ) internal override returns (FuelBurn memory) {\n        FuelBurn memory fuelBurn;\n\n        // If the fuel is DUBI, then we can remove it directly\n        if (fuel.dubi > 0) {\n            require(fuel.dubi <= MAX_BOOSTER_FUEL, \"DUBI-5\");\n\n            require(unpacked.balance >= fuel.dubi, \"DUBI-7\");\n            unpacked.balance -= fuel.dubi;\n\n            fuelBurn.amount = fuel.dubi;\n            fuelBurn.fuelType = FuelType.DUBI;\n\n            return fuelBurn;\n        }\n\n        // If the fuel is PRPS, then we have to reach out to the PRPS contract.\n        if (fuel.unlockedPrps > 0) {\n            // Reverts if the requested amount cannot be burned\n            _prps.burnFuel(\n                from,\n                TokenFuel({\n                    tokenAlias: TOKEN_FUEL_ALIAS_UNLOCKED_PRPS,\n                    amount: fuel.unlockedPrps\n                })\n            );\n\n            fuelBurn.amount = fuel.unlockedPrps;\n            fuelBurn.fuelType = FuelType.UNLOCKED_PRPS;\n\n            return fuelBurn;\n        }\n\n        if (fuel.lockedPrps > 0) {\n            // Reverts if the requested amount cannot be burned\n            _prps.burnFuel(\n                from,\n                TokenFuel({\n                    tokenAlias: TOKEN_FUEL_ALIAS_LOCKED_PRPS,\n                    amount: fuel.lockedPrps\n                })\n            );\n\n            // No direct fuel, but we still return a indirect fuel so that it can be added\n            // to the burn event.\n            fuelBurn.amount = fuel.lockedPrps;\n            fuelBurn.fuelType = FuelType.LOCKED_PRPS;\n            return fuelBurn;\n        }\n\n        // DUBI has no intrinsic fuel\n        if (fuel.intrinsicFuel > 0) {\n            revert(\"DUBI-8\");\n        }\n\n        // No fuel at all\n        return fuelBurn;\n    }\n\n    //---------------------------------------------------------------\n    // Pending ops\n    //---------------------------------------------------------------\n    function _getHasherContracts()\n        internal\n        override\n        returns (address[] memory)\n    {\n        address[] memory hashers = new address[](5);\n        hashers[0] = address(this);\n        hashers[1] = address(_prps);\n        hashers[2] = _hodlAddress;\n        hashers[3] = _externalAddress1;\n        hashers[4] = _externalAddress2;\n\n        return hashers;\n    }\n}\n"
6     },
7     "contracts/ERC20.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/introspection/IERC1820Registry.sol\";\nimport \"./IBoostableERC20.sol\";\nimport \"./BoostableERC20.sol\";\n\n/**\n * @dev This is a heavily modified fork of @openzeppelin/contracts/token/ERC20/ERC20.sol (3.1.0)\n */\nabstract contract ERC20 is IERC20, IBoostableERC20, BoostableERC20, Ownable {\n    using SafeMath for uint256;\n\n    // NOTE: In contrary to the Transfer event, the Burned event always\n    // emits the amount including the burned fuel if any.\n    // The amount is stored in the lower 96 bits of `amountAndFuel`,\n    // followed by 3 bits to encode the type of fuel used and finally\n    // another 96 bits for the fuel amount.\n    //\n    // 0         96        99                 195             256\n    //   amount    fuelType      fuelAmount         padding\n    //\n    event Burned(uint256 amountAndFuel, bytes data);\n\n    enum FuelType {NONE, UNLOCKED_PRPS, LOCKED_PRPS, DUBI, AUTO_MINTED_DUBI}\n\n    struct FuelBurn {\n        FuelType fuelType;\n        uint96 amount;\n    }\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    address internal immutable _hodlAddress;\n\n    address internal immutable _externalAddress1;\n    address internal immutable _externalAddress2;\n    address internal immutable _externalAddress3;\n\n    IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(\n        0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24\n    );\n\n    // Mapping of address to packed data.\n    // For efficiency reasons the token balance is a packed uint96 alongside\n    // other data. The packed data has the following layout:\n    //\n    //   MSB                      uint256                      LSB\n    //      uint64 nonce | uint96 hodlBalance | uint96 balance\n    //\n    // balance: the balance of a token holder that can be transferred freely\n    // hodlBalance: the balance of a token holder that is hodled\n    // nonce: a sequential number used for booster replay protection\n    //\n    // Only PRPS utilizes `hodlBalance`. For DUBI it is always 0.\n    //\n    mapping(address => uint256) internal _packedData;\n\n    struct UnpackedData {\n        uint96 balance;\n        uint96 hodlBalance;\n        uint64 nonce;\n    }\n\n    function _unpackPackedData(uint256 packedData)\n        internal\n        pure\n        returns (UnpackedData memory)\n    {\n        UnpackedData memory unpacked;\n\n        // 1) Read balance from the first 96 bits\n        unpacked.balance = uint96(packedData);\n\n        // 2) Read hodlBalance from the next 96 bits\n        unpacked.hodlBalance = uint96(packedData >> 96);\n\n        // 3) Read nonce from the next 64 bits\n        unpacked.nonce = uint64(packedData >> (96 + 96));\n\n        return unpacked;\n    }\n\n    function _packUnpackedData(UnpackedData memory unpacked)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 packedData;\n\n        // 1) Write balance to the first 96 bits\n        packedData |= unpacked.balance;\n\n        // 2) Write hodlBalance to the the next 96 bits\n        packedData |= uint256(unpacked.hodlBalance) << 96;\n\n        // 3) Write nonce to the next 64 bits\n        packedData |= uint256(unpacked.nonce) << (96 + 96);\n\n        return packedData;\n    }\n\n    // ERC20-allowances\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    //---------------------------------------------------------------\n    // Pending state for non-boosted operations while opted-in\n    //---------------------------------------------------------------\n    uint8 internal constant OP_TYPE_SEND = BOOST_TAG_SEND;\n    uint8 internal constant OP_TYPE_BURN = BOOST_TAG_BURN;\n\n    struct PendingTransfer {\n        // NOTE: For efficiency reasons balances are stored in a uint96 which is sufficient\n        // since we only use 18 decimals.\n        //\n        // Two amounts are associated with a pending transfer, to allow deriving contracts\n        // to store extra information.\n        //\n        // E.g. PRPS makes use of this by encoding the pending locked PRPS in the\n        // `occupiedAmount` field.\n        //\n        address spender;\n        uint96 transferAmount;\n        address to;\n        uint96 occupiedAmount;\n        bytes data;\n    }\n\n    // A mapping of hash(user, opId) to pending transfers. Pending burns are also considered regular transfers.\n    mapping(bytes32 => PendingTransfer) private _pendingTransfers;\n\n    //---------------------------------------------------------------\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        address optIn,\n        address hodl,\n        address externalAddress1,\n        address externalAddress2,\n        address externalAddress3\n    ) public Ownable() BoostableERC20(optIn) {\n        _name = name;\n        _symbol = symbol;\n\n        _hodlAddress = hodl;\n        _externalAddress1 = externalAddress1;\n        _externalAddress2 = externalAddress2;\n        _externalAddress3 = externalAddress3;\n\n        // register interfaces\n        _ERC1820_REGISTRY.setInterfaceImplementer(\n            address(this),\n            keccak256(\"BoostableERC20Token\"),\n            address(this)\n        );\n        _ERC1820_REGISTRY.setInterfaceImplementer(\n            address(this),\n            keccak256(\"ERC20Token\"),\n            address(this)\n        );\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals.\n     */\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev Returns the current nonce of `account`\n     */\n    function getNonce(address account) external override view returns (uint64) {\n        UnpackedData memory unpacked = _unpackPackedData(_packedData[account]);\n        return unpacked.nonce;\n    }\n\n    /**\n     * @dev Returns the total supply\n     */\n    function totalSupply()\n        external\n        override(IBoostableERC20, IERC20)\n        view\n        returns (uint256)\n    {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\n     */\n    function balanceOf(address tokenHolder)\n        public\n        override(IBoostableERC20, IERC20)\n        view\n        returns (uint256)\n    {\n        // Return the balance of the holder that is not hodled (i.e. first 96 bits of the packeData)\n        return uint96(_packedData[tokenHolder]);\n    }\n\n    /**\n     * @dev Returns the unpacked data struct of `tokenHolder`\n     */\n    function unpackedDataOf(address tokenHolder)\n        public\n        view\n        returns (UnpackedData memory)\n    {\n        return _unpackPackedData(_packedData[tokenHolder]);\n    }\n\n    /**\n     * @dev Mints `amount` new tokens for `to`.\n     *\n     * To make things more efficient, the total supply is optionally packed into the passed\n     * amount where the first 96 bits are used for the actual amount and the following 96 bits\n     * for the total supply.\n     *\n     */\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n\n    function _mintInitialSupply(address to, uint256 amount) internal {\n        // _mint does not update the totalSupply by default, unless the second 96 bits\n        // passed are non-zero - in which case the non-zero value becomes the new total supply.\n        // So in order to get the correct initial supply, we have to mirror the lower 96 bits\n        // to the following 96 bits.\n        amount = amount | (amount << 96);\n        _mint(to, amount);\n    }\n\n    function _mint(address to, uint256 amount) internal {\n        require(to != address(0), \"ERC20-1\");\n\n        // The actual amount to mint (=lower 96 bits)\n        uint96 amountToMint = uint96(amount);\n\n        // The new total supply, which may be 0 in which case no update is performed.\n        uint96 updatedTotalSupply = uint96(amount >> 96);\n\n        // Update state variables\n        if (updatedTotalSupply > 0) {\n            _totalSupply = updatedTotalSupply;\n        }\n\n        // Update packed data and check for uint96 overflow\n        UnpackedData memory unpacked = _unpackPackedData(_packedData[to]);\n        uint96 updatedBalance = unpacked.balance + amountToMint;\n\n        // The overflow check also takes the hodlBalance into account\n        require(\n            updatedBalance + unpacked.hodlBalance >= unpacked.balance,\n            \"ERC20-2\"\n        );\n\n        unpacked.balance = updatedBalance;\n        _packedData[to] = _packUnpackedData(unpacked);\n\n        emit Transfer(address(0), to, amountToMint);\n    }\n\n    /**\n     * @dev Transfer `amount` from msg.sender to `recipient`\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        override(IBoostableERC20, IERC20)\n        returns (bool)\n    {\n        _assertSenderRecipient(msg.sender, recipient);\n\n        // Never create a pending transfer if msg.sender is a deploy-time known contract\n        if (!_callerIsDeployTimeKnownContract()) {\n            // Create pending transfer if sender is opted-in and the permaboost is active\n            address from = msg.sender;\n            IOptIn.OptInStatus memory optInStatus = getOptInStatus(from);\n            if (optInStatus.isOptedIn && optInStatus.permaBoostActive) {\n                _createPendingTransfer({\n                    opType: OP_TYPE_SEND,\n                    spender: msg.sender,\n                    from: msg.sender,\n                    to: recipient,\n                    amount: amount,\n                    data: \"\",\n                    optInStatus: optInStatus\n                });\n\n                return true;\n            }\n        }\n\n        _move({from: msg.sender, to: recipient, amount: amount});\n\n        return true;\n    }\n\n    /**\n     * @dev Burns `amount` of msg.sender.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function burn(uint256 amount, bytes memory data) public {\n        // Create pending burn if sender is opted-in and the permaboost is active\n        IOptIn.OptInStatus memory optInStatus = getOptInStatus(msg.sender);\n        if (optInStatus.isOptedIn && optInStatus.permaBoostActive) {\n            _createPendingTransfer({\n                opType: OP_TYPE_BURN,\n                spender: msg.sender,\n                from: msg.sender,\n                to: address(0),\n                amount: amount,\n                data: data,\n                optInStatus: optInStatus\n            });\n\n            return;\n        }\n\n        _burn({\n            from: msg.sender,\n            amount: amount,\n            data: data,\n            incrementNonce: false\n        });\n    }\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`.\n     *\n     * Can only be used by deploy-time known contracts.\n     *\n     * IBoostableERC20 extension\n     */\n    function boostedTransferFrom(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data\n    ) public override returns (bool) {\n        _assertSenderRecipient(sender, recipient);\n\n        IOptIn.OptInStatus memory optInStatus = getOptInStatus(sender);\n\n        // Only transfer if `sender` is a deploy-time known contract, otherwise\n        // revert.\n        require(\n            _isDeployTimeKnownContractAndCanTransfer(\n                sender,\n                recipient,\n                amount,\n                optInStatus,\n                data\n            ),\n            \"ERC20-17\"\n        );\n\n        _move({from: sender, to: recipient, amount: amount});\n        return true;\n    }\n\n    function _isDeployTimeKnownContractAndCanTransfer(\n        address sender,\n        address recipient,\n        uint256 amount,\n        IOptIn.OptInStatus memory optInStatus,\n        bytes memory data\n    ) private view returns (bool) {\n        // If the caller not a deploy-time known contract, the transfer is not allowed\n        if (!_callerIsDeployTimeKnownContract()) {\n            return false;\n        }\n\n        if (msg.sender != _externalAddress3) {\n            return true;\n        }\n\n        // _externalAddress3 passes a flag via `data` that indicates whether it is a boosted transaction\n        // or not.\n        uint8 isBoostedBits;\n        assembly {\n            // Load flag using a 1-byte offset, because `mload` always reads\n            // 32-bytes at once and the first 32 bytes of `data` contain it's length.\n            isBoostedBits := mload(add(data, 0x01))\n        }\n\n        // Reading into a 'bool' directly doesn't work for some reason\n        if (isBoostedBits & 1 == 1) {\n            return true;\n        }\n\n        //  If the latter, then _externalAddress3 can only transfer the funds if either:\n        // - the permaboost is not active\n        // - `sender` is not opted-in to begin with\n        //\n        // If `sender` is opted-in and the permaboost is active, _externalAddress3 cannot\n        // take funds, except when boosted. Here the booster trusts _externalAddress3, since it already\n        // verifies that `sender` provided a valid signature.\n        //\n        // This is special to _externalAddress3, other deploy-time known contracts do not make use of `data`.\n        if (optInStatus.permaBoostActive && optInStatus.isOptedIn) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Verify the booster payload against the nonce that is stored in the packed data of an account.\n     * The increment happens outside of this function, when the balance is updated.\n     */\n    function _verifyNonce(BoosterPayload memory payload, uint64 currentNonce)\n        internal\n        pure\n    {\n        require(currentNonce == payload.nonce - 1, \"ERC20-5\");\n    }\n\n    //---------------------------------------------------------------\n    // Boosted functions\n    //---------------------------------------------------------------\n\n    /**\n     * @dev Perform multiple `boostedSend` calls in a single transaction.\n     *\n     * NOTE: Booster extension\n     */\n    function boostedSendBatch(\n        BoostedSend[] memory sends,\n        Signature[] memory signatures\n    ) external {\n        require(\n            sends.length > 0 && sends.length == signatures.length,\n            \"ERC20-6\"\n        );\n\n        for (uint256 i = 0; i < sends.length; i++) {\n            boostedSend(sends[i], signatures[i]);\n        }\n    }\n\n    /**\n     * @dev Perform multiple `boostedBurn` calls in a single transaction.\n     *\n     * NOTE: Booster extension\n     */\n    function boostedBurnBatch(\n        BoostedBurn[] memory burns,\n        Signature[] memory signatures\n    ) external {\n        require(\n            burns.length > 0 && burns.length == signatures.length,\n            \"ERC20-6\"\n        );\n\n        for (uint256 i = 0; i < burns.length; i++) {\n            boostedBurn(burns[i], signatures[i]);\n        }\n    }\n\n    /**\n     * @dev Send `amount` tokens from `sender` to recipient`.\n     * The `sender` must be opted-in and the `msg.sender` must be a trusted booster.\n     *\n     * NOTE: Booster extension\n     */\n    function boostedSend(BoostedSend memory send, Signature memory signature)\n        public\n    {\n        address from = send.sender;\n        address to = send.recipient;\n\n        UnpackedData memory unpackedFrom = _unpackPackedData(_packedData[from]);\n        UnpackedData memory unpackedTo = _unpackPackedData(_packedData[to]);\n\n        // We verify the nonce separately, since it's stored next to the balance\n        _verifyNonce(send.boosterPayload, unpackedFrom.nonce);\n\n        _verifyBoostWithoutNonce(\n            send.sender,\n            hashBoostedSend(send, msg.sender),\n            send.boosterPayload,\n            signature\n        );\n\n        FuelBurn memory fuelBurn = _burnBoostedSendFuel(\n            from,\n            send.fuel,\n            unpackedFrom\n        );\n\n        _moveUnpacked({\n            from: send.sender,\n            unpackedFrom: unpackedFrom,\n            to: send.recipient,\n            unpackedTo: unpackedTo,\n            amount: send.amount,\n            fuelBurn: fuelBurn,\n            incrementNonce: true\n        });\n    }\n\n    /**\n     * @dev Burn the fuel of a `boostedSend`. Returns a `FuelBurn` struct containing information about the burn.\n     */\n    function _burnBoostedSendFuel(\n        address from,\n        BoosterFuel memory fuel,\n        UnpackedData memory unpacked\n    ) internal virtual returns (FuelBurn memory);\n\n    /**\n     * @dev Burn `amount` tokens from `account`.\n     * The `account` must be opted-in and the `msg.sender` must be a trusted booster.\n     *\n     * NOTE: Booster extension\n     */\n    function boostedBurn(\n        BoostedBurn memory message,\n        // A signature, that is compared against the function payload and only accepted if signed by 'sender'\n        Signature memory signature\n    ) public {\n        address from = message.account;\n        UnpackedData memory unpacked = _unpackPackedData(_packedData[from]);\n\n        // We verify the nonce separately, since it's stored next to the balance\n        _verifyNonce(message.boosterPayload, unpacked.nonce);\n\n        _verifyBoostWithoutNonce(\n            message.account,\n            hashBoostedBurn(message, msg.sender),\n            message.boosterPayload,\n            signature\n        );\n\n        FuelBurn memory fuelBurn = _burnBoostedBurnFuel(\n            from,\n            message.fuel,\n            unpacked\n        );\n\n        _burnUnpacked({\n            from: message.account,\n            unpacked: unpacked,\n            amount: message.amount,\n            data: message.data,\n            incrementNonce: true,\n            fuelBurn: fuelBurn\n        });\n    }\n\n    /**\n     * @dev Burn the fuel of a `boostedSend`. Returns a `FuelBurn` struct containing information about the burn.\n     */\n    function _burnBoostedBurnFuel(\n        address from,\n        BoosterFuel memory fuel,\n        UnpackedData memory unpacked\n    ) internal virtual returns (FuelBurn memory);\n\n    function burnFuel(address from, TokenFuel memory fuel)\n        external\n        virtual\n        override\n    {}\n\n    //---------------------------------------------------------------\n\n    /**\n     * @dev Get the allowance of `spender` for `holder`\n     */\n    function allowance(address holder, address spender)\n        public\n        override(IBoostableERC20, IERC20)\n        view\n        returns (uint256)\n    {\n        return _allowances[holder][spender];\n    }\n\n    /**\n     * @dev Increase the allowance of `spender` by `value` for msg.sender\n     */\n    function approve(address spender, uint256 value)\n        public\n        override(IBoostableERC20, IERC20)\n        returns (bool)\n    {\n        address holder = msg.sender;\n        _assertSenderRecipient(holder, spender);\n        _approve(holder, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _assertSenderRecipient(msg.sender, spender);\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].add(addedValue)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _assertSenderRecipient(msg.sender, spender);\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20-18\")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Transfer `amount` from `holder` to `recipient`.\n     *\n     * `msg.sender` requires an allowance >= `amount` of `holder`.\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) public override(IBoostableERC20, IERC20) returns (bool) {\n        _assertSenderRecipient(holder, recipient);\n\n        address spender = msg.sender;\n\n        // Create pending transfer if the token holder is opted-in and the permaboost is active\n        IOptIn.OptInStatus memory optInStatus = getOptInStatus(holder);\n        if (optInStatus.isOptedIn && optInStatus.permaBoostActive) {\n            // Ignore allowances if holder is opted-in\n            require(holder == spender, \"ERC20-7\");\n\n            _createPendingTransfer({\n                opType: OP_TYPE_SEND,\n                spender: spender,\n                from: holder,\n                to: recipient,\n                amount: amount,\n                data: \"\",\n                optInStatus: optInStatus\n            });\n\n            return true;\n        }\n\n        // Not opted-in, but we still need to check approval of the given spender\n\n        _approve(\n            holder,\n            spender,\n            _allowances[holder][spender].sub(amount, \"ERC20-4\")\n        );\n\n        _move({from: holder, to: recipient, amount: amount});\n\n        return true;\n    }\n\n    /**\n     * @dev Burn tokens\n     * @param from address token holder address\n     * @param amount uint256 amount of tokens to burn\n     * @param data bytes extra information provided by the token holder\n     * @param incrementNonce whether to increment the nonce or not - only true for boosted burns\n     */\n    function _burn(\n        address from,\n        uint256 amount,\n        bytes memory data,\n        bool incrementNonce\n    ) internal virtual {\n        require(from != address(0), \"ERC20-8\");\n\n        UnpackedData memory unpacked = _unpackPackedData(_packedData[from]);\n\n        // Empty fuel burn\n        FuelBurn memory fuelBurn;\n\n        _burnUnpacked({\n            from: from,\n            unpacked: unpacked,\n            amount: amount,\n            data: data,\n            incrementNonce: incrementNonce,\n            fuelBurn: fuelBurn\n        });\n    }\n\n    function _burnUnpacked(\n        address from,\n        UnpackedData memory unpacked,\n        uint256 amount,\n        bytes memory data,\n        bool incrementNonce,\n        FuelBurn memory fuelBurn\n    ) internal {\n        // _beforeBurn allows deriving contracts to run additional logic and affect the amount\n        // that is actually getting burned. E.g. when burning PRPS, a portion of it might be taken\n        // from the `hodlBalance`. Thus the returned `burnAmount` overrides `amount` and will be\n        // subtracted from the actual `balance`.\n\n        uint96 actualBurnAmount = _beforeBurn({\n            from: from,\n            unpacked: unpacked,\n            transferAmount: uint96(amount),\n            occupiedAmount: 0,\n            createdAt: uint32(block.timestamp),\n            fuelBurn: fuelBurn,\n            finalizing: false\n        });\n\n        // Update to new balance\n\n        if (incrementNonce) {\n            // The nonce uses 64 bits, so a overflow is pretty much impossible\n            // via increments of 1.\n            unpacked.nonce++;\n        }\n\n        if (actualBurnAmount > 0) {\n            require(unpacked.balance >= actualBurnAmount, \"ERC20-9\");\n            unpacked.balance -= actualBurnAmount;\n        }\n\n        // Update packed data by writing to storage\n        _packedData[from] = _packUnpackedData(unpacked);\n\n        // Total supply can be updated in batches elsewhere, shaving off another >5k gas.\n        // _totalSupply = _totalSupply.sub(amount);\n\n        // The `Burned` event is emitted with the total amount that got burned.\n        // Furthermore, the fuel used is encoded in the upper bits.\n        uint256 amountAndFuel;\n\n        // Set first 96 bits to amount\n        amountAndFuel |= uint96(amount);\n\n        // Set next 3 bits to fuel type\n        uint8 fuelType = uint8(fuelBurn.fuelType);\n        amountAndFuel |= uint256(fuelType) << 96;\n\n        // Set next 96 bits to fuel amount\n        amountAndFuel |= uint256(fuelBurn.amount) << (96 + 3);\n\n        emit Burned(amountAndFuel, data);\n\n        // We emit a transfer event with the actual burn amount excluding burned `hodlBalance`.\n        emit Transfer(from, address(0), actualBurnAmount);\n    }\n\n    /**\n     * @dev Allow deriving contracts to prepare a burn. By default it behaves like an identity function\n     * and just returns the amount passed in.\n     */\n    function _beforeBurn(\n        address from,\n        UnpackedData memory unpacked,\n        uint96 transferAmount,\n        uint96 occupiedAmount,\n        uint32 createdAt,\n        FuelBurn memory fuelBurn,\n        bool finalizing\n    ) internal virtual returns (uint96) {\n        return transferAmount;\n    }\n\n    function _move(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        UnpackedData memory unpackedFrom = _unpackPackedData(_packedData[from]);\n        UnpackedData memory unpackedTo = _unpackPackedData(_packedData[to]);\n\n        // Empty fuel burn\n        FuelBurn memory fuelBurn;\n\n        _moveUnpacked({\n            from: from,\n            unpackedFrom: unpackedFrom,\n            to: to,\n            unpackedTo: unpackedTo,\n            amount: amount,\n            incrementNonce: false,\n            fuelBurn: fuelBurn\n        });\n    }\n\n    function _moveUnpacked(\n        address from,\n        UnpackedData memory unpackedFrom,\n        address to,\n        UnpackedData memory unpackedTo,\n        uint256 amount,\n        bool incrementNonce,\n        FuelBurn memory fuelBurn\n    ) internal {\n        require(from != to, \"ERC20-19\");\n\n        // Increment nonce of sender if it's a boosted send\n        if (incrementNonce) {\n            // The nonce uses 64 bits, so a overflow is pretty much impossible\n            // via increments of 1.\n            unpackedFrom.nonce++;\n        }\n\n        // Check if sender has enough tokens\n        uint96 transferAmount = uint96(amount);\n        require(unpackedFrom.balance >= transferAmount, \"ERC20-10\");\n\n        // Subtract transfer amount from sender balance\n        unpackedFrom.balance -= transferAmount;\n\n        // Check that recipient balance doesn't overflow\n        uint96 updatedRecipientBalance = unpackedTo.balance + transferAmount;\n        require(updatedRecipientBalance >= unpackedTo.balance, \"ERC20-12\");\n        unpackedTo.balance = updatedRecipientBalance;\n\n        _packedData[from] = _packUnpackedData(unpackedFrom);\n        _packedData[to] = _packUnpackedData(unpackedTo);\n\n        // The transfer amount does not include any used fuel\n        emit Transfer(from, to, transferAmount);\n    }\n\n    /**\n     * @dev See {ERC20-_approve}.\n     */\n    function _approve(\n        address holder,\n        address spender,\n        uint256 value\n    ) internal {\n        _allowances[holder][spender] = value;\n        emit Approval(holder, spender, value);\n    }\n\n    function _assertSenderRecipient(address sender, address recipient)\n        private\n        pure\n    {\n        require(sender != address(0) && recipient != address(0), \"ERC20-13\");\n    }\n\n    /**\n     * @dev Checks whether msg.sender is a deploy-time known contract or not.\n     */\n    function _callerIsDeployTimeKnownContract()\n        internal\n        virtual\n        view\n        returns (bool)\n    {\n        if (msg.sender == _hodlAddress) {\n            return true;\n        }\n\n        if (msg.sender == _externalAddress1) {\n            return true;\n        }\n\n        if (msg.sender == _externalAddress2) {\n            return true;\n        }\n\n        if (msg.sender == _externalAddress3) {\n            return true;\n        }\n\n        return false;\n    }\n\n    //---------------------------------------------------------------\n    // Pending ops\n    //---------------------------------------------------------------\n\n    /**\n     * @dev Create a pending transfer\n     */\n    function _createPendingTransfer(\n        uint8 opType,\n        address spender,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data,\n        IOptIn.OptInStatus memory optInStatus\n    ) private {\n        OpHandle memory opHandle = _createNewOpHandle(\n            optInStatus,\n            from,\n            opType\n        );\n\n        PendingTransfer memory pendingTransfer = _createPendingTransferInternal(\n            opHandle,\n            spender,\n            from,\n            to,\n            amount,\n            data\n        );\n\n        _pendingTransfers[_getOpKey(from, opHandle.opId)] = pendingTransfer;\n\n        // Emit PendingOp event\n        emit PendingOp(from, opHandle.opId, opHandle.opType);\n    }\n\n    /**\n     * @dev Create a pending transfer by moving the funds of `spender` to this contract.\n     * Deriving contracts may override this function.\n     */\n    function _createPendingTransferInternal(\n        OpHandle memory opHandle,\n        address spender,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual returns (PendingTransfer memory) {\n        // Move funds into this contract\n\n        // Reverts if `from` has less than `amount` tokens.\n        _move({from: from, to: address(this), amount: amount});\n\n        // Create op\n        PendingTransfer memory pendingTransfer = PendingTransfer({\n            transferAmount: uint96(amount),\n            spender: spender,\n            occupiedAmount: 0,\n            to: to,\n            data: data\n        });\n\n        return pendingTransfer;\n    }\n\n    /**\n     * @dev Finalize a pending op\n     */\n    function finalizePendingOp(address user, OpHandle memory opHandle) public {\n        uint8 opType = opHandle.opType;\n\n        // Assert that the caller (msg.sender) is allowed to finalize the given op\n        uint32 createdAt = uint32(_assertCanFinalize(user, opHandle));\n\n        // Reverts if opId doesn't exist\n        PendingTransfer storage pendingTransfer = _safeGetPendingTransfer(\n            user,\n            opHandle.opId\n        );\n\n        // Cleanup\n        // NOTE: We do not delete the pending transfer struct, because it only makes it\n        // more expensive since we already hit the gas refund limit.\n        //\n        // delete _pendingTransfers[_getOpKey(user, opHandle.opId)];\n        //\n        // The difference is ~13k gas.\n        //\n        // Deleting the op handle is enough to invalidate an opId forever:\n        _deleteOpHandle(user, opHandle);\n\n        // Call op type specific finalize\n        if (opType == OP_TYPE_SEND) {\n            _finalizeTransferOp(pendingTransfer, user, createdAt);\n        } else if (opType == OP_TYPE_BURN) {\n            _finalizePendingBurn(pendingTransfer, user, createdAt);\n        } else {\n            revert(\"ERC20-15\");\n        }\n\n        // Emit event\n        emit FinalizedOp(user, opHandle.opId, opType);\n    }\n\n    /**\n     * @dev Finalize a pending transfer\n     */\n    function _finalizeTransferOp(\n        PendingTransfer storage pendingTransfer,\n        address from,\n        uint32 createdAt\n    ) private {\n        address to = pendingTransfer.to;\n\n        uint96 transferAmount = pendingTransfer.transferAmount;\n\n        address _this = address(this);\n        UnpackedData memory unpackedThis = _unpackPackedData(\n            _packedData[_this]\n        );\n        UnpackedData memory unpackedTo = _unpackPackedData(_packedData[to]);\n\n        // Check that sender balance does not overflow\n        require(unpackedThis.balance >= transferAmount, \"ERC20-2\");\n        unpackedThis.balance -= transferAmount;\n\n        // Check that recipient doesn't overflow\n        uint96 updatedBalanceRecipient = unpackedTo.balance + transferAmount;\n        require(updatedBalanceRecipient >= unpackedTo.balance, \"ERC20-2\");\n\n        unpackedTo.balance = updatedBalanceRecipient;\n\n        _packedData[_this] = _packUnpackedData(unpackedThis);\n        _packedData[to] = _packUnpackedData(unpackedTo);\n\n        // Transfer event is emitted with original sender\n        emit Transfer(from, to, transferAmount);\n    }\n\n    /**\n     * @dev Finalize a pending burn\n     */\n    function _finalizePendingBurn(\n        PendingTransfer storage pendingTransfer,\n        address from,\n        uint32 createdAt\n    ) private {\n        uint96 transferAmount = pendingTransfer.transferAmount;\n\n        // We pass the packedData of `from` to `_beforeBurn`, because it PRPS needs to update\n        // the `hodlBalance` which is NOT on the contract's own packedData.\n        UnpackedData memory unpackedFrom = _unpackPackedData(_packedData[from]);\n\n        // Empty fuel burn\n        FuelBurn memory fuelBurn;\n\n        uint96 burnAmountExcludingLockedPrps = _beforeBurn({\n            from: from,\n            unpacked: unpackedFrom,\n            transferAmount: transferAmount,\n            occupiedAmount: pendingTransfer.occupiedAmount,\n            createdAt: createdAt,\n            fuelBurn: fuelBurn,\n            finalizing: true\n        });\n\n        // Update to new balance\n        // NOTE: We change the balance of this contract, because that's where\n        // the pending PRPS went to.\n        address _this = address(this);\n        UnpackedData memory unpackedOfContract = _unpackPackedData(\n            _packedData[_this]\n        );\n        require(\n            unpackedOfContract.balance >= burnAmountExcludingLockedPrps,\n            \"ERC20-2\"\n        );\n\n        unpackedOfContract.balance -= burnAmountExcludingLockedPrps;\n        _packedData[_this] = _packUnpackedData(unpackedOfContract);\n        _packedData[from] = _packUnpackedData(unpackedFrom);\n\n        // Furthermore, total supply can be updated elsewhere, shaving off another >5k gas.\n        // _totalSupply = _totalSupply.sub(amount);\n\n        // Emit events using the same `transferAmount` instead of what `_beforeBurn`\n        // returned which is only used for updating the balance correctly.\n        emit Burned(transferAmount, pendingTransfer.data);\n        emit Transfer(from, address(0), transferAmount);\n    }\n\n    /**\n     * @dev Revert a pending operation.\n     *\n     * Only the opted-in booster can revert a transaction if it provides a signed and still valid booster message\n     * from the original sender.\n     */\n    function revertPendingOp(\n        address user,\n        OpHandle memory opHandle,\n        bytes memory boosterMessage,\n        Signature memory signature\n    ) public {\n        // Prepare revert, including permission check and prevents reentrancy for same opHandle.\n        _prepareOpRevert({\n            user: user,\n            opHandle: opHandle,\n            boosterMessage: boosterMessage,\n            signature: signature\n        });\n\n        // Now perform the actual revert of the pending op\n        _revertPendingOp(user, opHandle.opType, opHandle.opId);\n    }\n\n    /**\n     * @dev Revert a pending transfer\n     */\n    function _revertPendingOp(\n        address user,\n        uint8 opType,\n        uint64 opId\n    ) private {\n        PendingTransfer storage pendingTransfer = _safeGetPendingTransfer(\n            user,\n            opId\n        );\n\n        uint96 transferAmount = pendingTransfer.transferAmount;\n        uint96 occupiedAmount = pendingTransfer.occupiedAmount;\n\n        // Move funds from this contract back to the original sender. Transfers and burns\n        // are reverted the same way. We only transfer back the `transferAmount` - that is the amount\n        // that actually got moved into this contract. The occupied amount is released during `onRevertPendingOp`\n        // by the deriving contract.\n        _move({from: address(this), to: user, amount: transferAmount});\n\n        // Call hook to allow deriving contracts to perform additional cleanup\n        _onRevertPendingOp(user, opType, opId, transferAmount, occupiedAmount);\n\n        // NOTE: we do not clean up the ops mapping, because we already hit the\n        // gas refund limit.\n        // delete _pendingTransfers[_getOpKey(user, opHandle.opId)];\n\n        // Emit event\n        emit RevertedOp(user, opId, opType);\n    }\n\n    /**\n     * @dev Hook that is called during revert of a pending transfer.\n     * Allows deriving contracts to perform additional cleanup.\n     */\n    function _onRevertPendingOp(\n        address user,\n        uint8 opType,\n        uint64 opId,\n        uint96 transferAmount,\n        uint96 occupiedAmount\n    ) internal virtual {}\n\n    /**\n     * @dev Safely get a pending transfer. Reverts if it doesn't exist.\n     */\n    function _safeGetPendingTransfer(address user, uint64 opId)\n        private\n        view\n        returns (PendingTransfer storage)\n    {\n        PendingTransfer storage pendingTransfer = _pendingTransfers[_getOpKey(\n            user,\n            opId\n        )];\n\n        require(pendingTransfer.spender != address(0), \"ERC20-16\");\n\n        return pendingTransfer;\n    }\n}\n"
9     },
10     "contracts/Purpose.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./ERC20.sol\";\nimport \"./Dubi.sol\";\nimport \"./IHodl.sol\";\nimport \"./MintMath.sol\";\n\ncontract Purpose is ERC20 {\n    // The DUBI contract, required for auto-minting DUBI on burn.\n    Dubi private immutable _dubi;\n\n    // The HODL contract, required for burning locked PRPS.\n    IHodl private immutable _hodl;\n\n    modifier onlyHodl() {\n        require(msg.sender == _hodlAddress, \"PRPS-1\");\n        _;\n    }\n\n    constructor(\n        uint256 initialSupply,\n        address optIn,\n        address dubi,\n        address hodl,\n        address externalAddress1,\n        address externalAddress2,\n        address externalAddress3\n    )\n        public\n        ERC20(\n            \"Purpose\",\n            \"PRPS\",\n            optIn,\n            hodl,\n            externalAddress1,\n            externalAddress2,\n            externalAddress3\n        )\n    {\n        _dubi = Dubi(dubi);\n        _hodl = IHodl(hodl);\n\n        _mintInitialSupply(msg.sender, initialSupply);\n    }\n\n    /**\n     * @dev Returns the address of the {HODL} contract used for burning locked PRPS.\n     */\n    function hodl() external view returns (address) {\n        return address(_hodl);\n    }\n\n    /**\n     * @dev Returns the hodl balance of the given `tokenHolder`\n     */\n    function hodlBalanceOf(address tokenHolder) public view returns (uint256) {\n        // The hodl balance follows after the first 96 bits in the packed data.\n        return uint96(_packedData[tokenHolder] >> 96);\n    }\n\n    /**\n     * @dev Transfer `amount` PRPS from `from` to the Hodl contract.\n     *\n     * This can only be called by the Hodl contract.\n     */\n    function hodlTransfer(address from, uint96 amount) external onlyHodl {\n        _move(from, address(_hodl), amount);\n    }\n\n    /**\n     * @dev Increase the hodl balance of `account` by `hodlAmount`. This is\n     * only used as part of the migration.\n     */\n    function migrateHodlBalance(address account, uint96 hodlAmount)\n        external\n        onlyHodl\n    {\n        UnpackedData memory unpacked = _unpackPackedData(_packedData[account]);\n\n        unpacked.hodlBalance += hodlAmount;\n        _packedData[account] = _packUnpackedData(unpacked);\n    }\n\n    /**\n     * @dev Increase the hodl balance of `to` by moving `amount` PRPS from `from`'s balance.\n     *\n     * This can only be called by the Hodl contract.\n     */\n    function increaseHodlBalance(\n        address from,\n        address to,\n        uint96 amount\n    ) external onlyHodl {\n        UnpackedData memory unpackedDataFrom = _unpackPackedData(\n            _packedData[from]\n        );\n        UnpackedData memory unpackedDataTo;\n\n        // We only need to unpack twice if from != to\n        if (from != to) {\n            unpackedDataTo = _unpackPackedData(_packedData[to]);\n        } else {\n            unpackedDataTo = unpackedDataFrom;\n        }\n\n        // `from` must have enough balance\n        require(unpackedDataFrom.balance >= amount, \"PRPS-3\");\n\n        // Subtract balance from `from`\n        unpackedDataFrom.balance -= amount;\n        // Add to `hodlBalance` from `to`\n        unpackedDataTo.hodlBalance += amount;\n\n        // We only need to pack twice if from != to\n        if (from != to) {\n            _packedData[to] = _packUnpackedData(unpackedDataTo);\n        }\n\n        _packedData[from] = _packUnpackedData(unpackedDataFrom);\n    }\n\n    /**\n     * @dev Decrease the hodl balance of `from` by `hodlAmount` and increase\n     * the regular balance by `refundAmount.\n     *\n     * `refundAmount` might be less than `hodlAmount`.\n     *\n     * E.g. when burning fuel in locked PRPS\n     *\n     * This can only be called by the Hodl contract.\n     */\n    function decreaseHodlBalance(\n        address from,\n        uint96 hodlAmount,\n        uint96 refundAmount\n    ) external onlyHodl {\n        require(hodlAmount >= refundAmount, \"PRPS-4\");\n\n        UnpackedData memory unpackedDataFrom = _unpackPackedData(\n            _packedData[from]\n        );\n\n        // `from` must have enough balance\n        require(unpackedDataFrom.hodlBalance >= hodlAmount, \"PRPS-5\");\n\n        // Subtract amount from hodl balance\n        unpackedDataFrom.hodlBalance -= hodlAmount;\n\n        if (refundAmount > 0) {\n            // Add amount to balance\n            unpackedDataFrom.balance += refundAmount;\n        }\n\n        // Write to storage\n        _packedData[from] = _packUnpackedData(unpackedDataFrom);\n    }\n\n    /**\n     * @dev Revert the hodl balance change caused by `from` on `to`.\n     *\n     * E.g. when reverting a pending hodl.\n     *\n     * This can only be called by the Hodl contract.\n     */\n    function revertHodlBalance(\n        address from,\n        address to,\n        uint96 amount\n    ) external onlyHodl {\n        UnpackedData memory unpackedDataFrom = _unpackPackedData(\n            _packedData[from]\n        );\n        UnpackedData memory unpackedDataTo;\n\n        // We only need to unpack twice if from != to\n        if (from != to) {\n            unpackedDataTo = _unpackPackedData(_packedData[to]);\n        } else {\n            unpackedDataTo = unpackedDataFrom;\n        }\n\n        // `to` must have enough hodl balance\n        require(unpackedDataTo.hodlBalance >= amount, \"PRPS-5\");\n\n        // Subtract hodl balance from `to`\n        unpackedDataTo.hodlBalance -= amount;\n        // Add to `balance` from `from`\n        unpackedDataFrom.balance += amount;\n\n        // We only need to pack twice if from != to\n        if (from != to) {\n            _packedData[to] = _packUnpackedData(unpackedDataTo);\n        }\n\n        _packedData[from] = _packUnpackedData(unpackedDataFrom);\n    }\n\n    /**\n     * @dev Mint DUBI when burning PRPS\n     * @param from address token holder address\n     * @param transferAmount amount of tokens to burn\n     * @param occupiedAmount amount of tokens that are occupied\n     * @param createdAt equal to block.timestamp if not finalizing a pending op, otherwise\n     * it corresponds to op.createdAt\n     * @param finalizing boolean indicating whether this is a finalizing transaction or not. Changes\n     * how the `amount` is interpreted.\n     *\n     * When burning PRPS, we first try to burn unlocked PRPS.\n     * If burning an amount that exceeds the unlocked PRPS of `from`, we attempt to burn the\n     * difference from locked PRPS.\n     *\n     * If the desired `amount` cannot be filled by taking locked and unlocked PRPS into account,\n     * this function reverts.\n     *\n     * Burning locked PRPS means reducing the `hodlBalance` while burning unlocked PRPS means reducing\n     * the regular `balance`.\n     *\n     * This function returns the actual unlocked PRPS that needs to be removed from `balance`.\n     *\n     */\n    function _beforeBurn(\n        address from,\n        UnpackedData memory unpacked,\n        uint96 transferAmount,\n        uint96 occupiedAmount,\n        uint32 createdAt,\n        FuelBurn memory fuelBurn,\n        bool finalizing\n    ) internal override returns (uint96) {\n        uint96 totalDubiToMint;\n        uint96 lockedPrpsToBurn;\n        uint96 burnableUnlockedPrps;\n\n        // Depending on whether this is a finalizing burn or not,\n        // the amount of locked/unlocked PRPS is determined differently.\n        if (finalizing) {\n            // For a finalizing burn, we use the occupied amount, since we already know how much\n            // locked PRPS we are going to burn. This amount represents the `pendingLockedPrps`\n            // on the hodl items.\n            lockedPrpsToBurn = occupiedAmount;\n\n            // Since `transferAmount` is the total amount of PRPS getting burned, we need to subtract\n            // the `occupiedAmount` to get the actual amount of unlocked PRPS.\n\n            // Sanity check\n            assert(transferAmount >= occupiedAmount);\n            transferAmount -= occupiedAmount;\n\n            // Set the unlocked PRPS to burn to the updated `transferAmount`\n            burnableUnlockedPrps = transferAmount;\n        } else {\n            // For a direct burn, we start off with the full amounts, since we don't know the exact\n            // amounts initially.\n\n            lockedPrpsToBurn = transferAmount;\n            burnableUnlockedPrps = unpacked.balance;\n        }\n\n        // 1) Try to burn unlocked PRPS\n        if (burnableUnlockedPrps > 0) {\n            // Nice, we can burn unlocked PRPS\n\n            // Catch underflow i.e. don't burn more than we need to\n            if (burnableUnlockedPrps > transferAmount) {\n                burnableUnlockedPrps = transferAmount;\n            }\n\n            // Calculate DUBI to mint based on unlocked PRPS we can burn\n            totalDubiToMint = MintMath.calculateDubiToMintMax(\n                burnableUnlockedPrps\n            );\n\n            // Subtract the amount of burned unlocked PRPS from the locked PRPS we\n            // need to burn if this is NOT a finalizing burn, because in that case we\n            // already have the exact amount locked PRPS we want to burn.\n            if (!finalizing) {\n                lockedPrpsToBurn -= burnableUnlockedPrps;\n            }\n        }\n\n        // 2) Burn locked PRPS if there's not enough unlocked PRPS\n\n        // Burn an additional amount of locked PRPS equal to the fuel if any\n        if (fuelBurn.fuelType == FuelType.LOCKED_PRPS) {\n            // The `burnFromLockedPrps` call will fail, if not enough PRPS can be burned.\n            lockedPrpsToBurn += fuelBurn.amount;\n        }\n\n        if (lockedPrpsToBurn > 0) {\n            uint96 dubiToMintFromLockedPrps = _burnFromLockedPrps({\n                from: from,\n                unpacked: unpacked,\n                lockedPrpsToBurn: lockedPrpsToBurn,\n                createdAt: createdAt,\n                finalizing: finalizing\n            });\n\n            // We check 'greater than or equal' because it's possible to mint 0 new DUBI\n            // e.g. when called right after a hodl where not enough time passed to generate new DUBI.\n            uint96 dubiToMint = totalDubiToMint + dubiToMintFromLockedPrps;\n            require(dubiToMint >= totalDubiToMint, \"PRPS-6\");\n\n            totalDubiToMint = dubiToMint;\n        } else {\n            // Sanity check for finalizes that don't touch locked PRPS\n            assert(occupiedAmount == 0);\n        }\n\n        // Burn minted DUBI equal to the fuel if any\n        if (fuelBurn.fuelType == FuelType.AUTO_MINTED_DUBI) {\n            require(totalDubiToMint >= fuelBurn.amount, \"PRPS-7\");\n            totalDubiToMint -= fuelBurn.amount;\n        }\n\n        // Mint DUBI taking differences between burned locked/unlocked into account\n        if (totalDubiToMint > 0) {\n            _dubi.purposeMint(from, totalDubiToMint);\n        }\n\n        return burnableUnlockedPrps;\n    }\n\n    function _burnFromLockedPrps(\n        address from,\n        UnpackedData memory unpacked,\n        uint96 lockedPrpsToBurn,\n        uint32 createdAt,\n        bool finalizing\n    ) private returns (uint96) {\n        // Reverts if the exact amount needed cannot be burned\n        uint96 dubiToMintFromLockedPrps = _hodl.burnLockedPrps({\n            from: from,\n            amount: lockedPrpsToBurn,\n            dubiMintTimestamp: createdAt,\n            burnPendingLockedPrps: finalizing\n        });\n\n        require(unpacked.hodlBalance >= lockedPrpsToBurn, \"PRPS-8\");\n\n        unpacked.hodlBalance -= lockedPrpsToBurn;\n\n        return dubiToMintFromLockedPrps;\n    }\n\n    function _callerIsDeployTimeKnownContract()\n        internal\n        override\n        view\n        returns (bool)\n    {\n        if (msg.sender == address(_dubi)) {\n            return true;\n        }\n\n        return super._callerIsDeployTimeKnownContract();\n    }\n\n    //---------------------------------------------------------------\n    // Fuel\n    //---------------------------------------------------------------\n\n    /**\n     * @dev Burns `fuel` from `from`. Can only be called by one of the deploy-time known contracts.\n     */\n    function burnFuel(address from, TokenFuel memory fuel) public override {\n        require(_callerIsDeployTimeKnownContract(), \"PRPS-2\");\n        _burnFuel(from, fuel);\n    }\n\n    function _burnFuel(address from, TokenFuel memory fuel) private {\n        require(fuel.amount <= MAX_BOOSTER_FUEL, \"PRPS-10\");\n        require(from != address(0) && from != msg.sender, \"PRPS-11\");\n\n        if (fuel.tokenAlias == TOKEN_FUEL_ALIAS_UNLOCKED_PRPS) {\n            // Burn fuel from unlocked PRPS\n            UnpackedData memory unpacked = _unpackPackedData(_packedData[from]);\n            require(unpacked.balance >= fuel.amount, \"PRPS-7\");\n            unpacked.balance -= fuel.amount;\n            _packedData[from] = _packUnpackedData(unpacked);\n            return;\n        }\n\n        if (fuel.tokenAlias == TOKEN_FUEL_ALIAS_LOCKED_PRPS) {\n            // Burn fuel from locked PRPS\n            UnpackedData memory unpacked = _unpackPackedData(_packedData[from]);\n            require(unpacked.hodlBalance >= fuel.amount, \"PRPS-7\");\n            unpacked.hodlBalance -= fuel.amount;\n\n            // We pass a mint timestamp, but that doesn't mean that DUBI is minted.\n            // The returned DUBI that should be minted is ignored.\n            // Reverts if not enough locked PRPS can be burned.\n            _hodl.burnLockedPrps({\n                from: from,\n                amount: fuel.amount,\n                dubiMintTimestamp: uint32(block.timestamp),\n                burnPendingLockedPrps: false\n            });\n\n            _packedData[from] = _packUnpackedData(unpacked);\n            return;\n        }\n\n        revert(\"PRPS-12\");\n    }\n\n    /**\n     *@dev Burn the fuel of a `boostedSend`\n     */\n    function _burnBoostedSendFuel(\n        address from,\n        BoosterFuel memory fuel,\n        UnpackedData memory unpacked\n    ) internal override returns (FuelBurn memory) {\n        FuelBurn memory fuelBurn;\n\n        if (fuel.unlockedPrps > 0) {\n            require(fuel.unlockedPrps <= MAX_BOOSTER_FUEL, \"PRPS-10\");\n\n            require(unpacked.balance >= fuel.unlockedPrps, \"PRPS-7\");\n            unpacked.balance -= fuel.unlockedPrps;\n\n            fuelBurn.amount = fuel.unlockedPrps;\n            fuelBurn.fuelType = FuelType.UNLOCKED_PRPS;\n            return fuelBurn;\n        }\n\n        if (fuel.lockedPrps > 0) {\n            require(fuel.lockedPrps <= MAX_BOOSTER_FUEL, \"PRPS-10\");\n\n            // We pass a mint timestamp, but that doesn't mean that DUBI is minted.\n            // The returned DUBI that should be minted is ignored.\n            // Reverts if not enough locked PRPS can be burned.\n            _hodl.burnLockedPrps({\n                from: from,\n                amount: fuel.lockedPrps,\n                dubiMintTimestamp: uint32(block.timestamp),\n                burnPendingLockedPrps: false\n            });\n\n            require(unpacked.hodlBalance >= fuel.lockedPrps, \"PRPS-7\");\n            unpacked.hodlBalance -= fuel.lockedPrps;\n\n            fuelBurn.amount = fuel.lockedPrps;\n            fuelBurn.fuelType = FuelType.LOCKED_PRPS;\n            return fuelBurn;\n        }\n\n        // If the fuel is DUBI, then we have to reach out to the DUBI contract.\n        if (fuel.dubi > 0) {\n            // Reverts if the requested amount cannot be burned\n            _dubi.burnFuel(\n                from,\n                TokenFuel({\n                    tokenAlias: TOKEN_FUEL_ALIAS_DUBI,\n                    amount: fuel.dubi\n                })\n            );\n\n            fuelBurn.amount = fuel.dubi;\n            fuelBurn.fuelType = FuelType.DUBI;\n            return fuelBurn;\n        }\n\n        return fuelBurn;\n    }\n\n    /**\n     *@dev Burn the fuel of a `boostedBurn`\n     */\n    function _burnBoostedBurnFuel(\n        address from,\n        BoosterFuel memory fuel,\n        UnpackedData memory unpacked\n    ) internal override returns (FuelBurn memory) {\n        FuelBurn memory fuelBurn;\n\n        if (fuel.unlockedPrps > 0) {\n            require(fuel.unlockedPrps <= MAX_BOOSTER_FUEL, \"PRPS-10\");\n\n            require(unpacked.balance >= fuel.unlockedPrps, \"PRPS-7\");\n            unpacked.balance -= fuel.unlockedPrps;\n\n            fuelBurn.amount = fuel.unlockedPrps;\n            fuelBurn.fuelType = FuelType.UNLOCKED_PRPS;\n            return fuelBurn;\n        }\n\n        if (fuel.lockedPrps > 0) {\n            require(fuel.lockedPrps <= MAX_BOOSTER_FUEL, \"PRPS-10\");\n\n            require(unpacked.hodlBalance >= fuel.lockedPrps, \"PRPS-7\");\n            // Fuel is taken from hodl balance in _beforeBurn\n            // unpacked.hodlBalance -= fuel.lockedPrps;\n\n            fuelBurn.amount = fuel.lockedPrps;\n            fuelBurn.fuelType = FuelType.LOCKED_PRPS;\n\n            return fuelBurn;\n        }\n\n        if (fuel.intrinsicFuel > 0) {\n            require(fuel.intrinsicFuel <= MAX_BOOSTER_FUEL, \"PRPS-10\");\n\n            fuelBurn.amount = fuel.intrinsicFuel;\n            fuelBurn.fuelType = FuelType.AUTO_MINTED_DUBI;\n\n            return fuelBurn;\n        }\n\n        // If the fuel is DUBI, then we have to reach out to the DUBI contract.\n        if (fuel.dubi > 0) {\n            // Reverts if the requested amount cannot be burned\n            _dubi.burnFuel(\n                from,\n                TokenFuel({\n                    tokenAlias: TOKEN_FUEL_ALIAS_DUBI,\n                    amount: fuel.dubi\n                })\n            );\n\n            fuelBurn.amount = fuel.dubi;\n            fuelBurn.fuelType = FuelType.DUBI;\n            return fuelBurn;\n        }\n\n        // No fuel at all\n        return fuelBurn;\n    }\n\n    //---------------------------------------------------------------\n    // Pending ops\n    //---------------------------------------------------------------\n\n    function _getHasherContracts()\n        internal\n        override\n        returns (address[] memory)\n    {\n        address[] memory hashers = new address[](5);\n        hashers[0] = address(this);\n        hashers[1] = address(_dubi);\n        hashers[2] = _hodlAddress;\n        hashers[3] = _externalAddress1;\n        hashers[4] = _externalAddress2;\n\n        return hashers;\n    }\n\n    /**\n     * @dev Create a pending transfer by moving the funds of `spender` to this contract.\n     * Special behavior applies to pending burns to account for locked PRPS.\n     */\n    function _createPendingTransferInternal(\n        OpHandle memory opHandle,\n        address spender,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data\n    ) internal override returns (PendingTransfer memory) {\n        if (opHandle.opType != OP_TYPE_BURN) {\n            return\n                // Nothing special to do for non-burns so just call parent implementation\n                super._createPendingTransferInternal(\n                    opHandle,\n                    spender,\n                    from,\n                    to,\n                    amount,\n                    data\n                );\n        }\n\n        // When burning, we first use unlocked PRPS and match the remaining amount with locked PRPS from the Hodl contract.\n\n        // Sanity check\n        assert(amount < 2**96);\n        uint96 transferAmount = uint96(amount);\n        uint96 lockedPrpsAmount = transferAmount;\n\n        UnpackedData memory unpacked = _unpackPackedData(_packedData[from]);\n        // First try to move as much unlocked PRPS as possible to the PRPS address\n        uint96 unlockedPrpsToMove = transferAmount;\n        if (unlockedPrpsToMove > unpacked.balance) {\n            unlockedPrpsToMove = unpacked.balance;\n        }\n\n        // Update the locked PRPS we have to use\n        lockedPrpsAmount -= unlockedPrpsToMove;\n\n        if (unlockedPrpsToMove > 0) {\n            _move({from: from, to: address(this), amount: unlockedPrpsToMove});\n        }\n\n        // If we still need locked PRPS, call into the Hodl contract.\n        // This will also take pending hodls into account, if `from` has\n        // some.\n        if (lockedPrpsAmount > 0) {\n            // Reverts if not the exact amount can be set to pending\n            _hodl.setLockedPrpsToPending(from, lockedPrpsAmount);\n        }\n\n        // Create pending transfer\n        return\n            PendingTransfer({\n                spender: spender,\n                transferAmount: transferAmount,\n                to: to,\n                occupiedAmount: lockedPrpsAmount,\n                data: data\n            });\n    }\n\n    /**\n     * @dev Hook that is called during revert of a pending op.\n     * Reverts any changes to locked PRPS when 'opType' is burn.\n     */\n    function _onRevertPendingOp(\n        address user,\n        uint8 opType,\n        uint64 opId,\n        uint96 transferAmount,\n        uint96 occupiedAmount\n    ) internal override {\n        if (opType != OP_TYPE_BURN) {\n            return;\n        }\n\n        // Extract the pending locked PRPS from the amount.\n        if (occupiedAmount > 0) {\n            _hodl.revertLockedPrpsSetToPending(user, occupiedAmount);\n        }\n    }\n\n    //---------------------------------------------------------------\n    // Shared pending ops for Hodl\n    //---------------------------------------------------------------\n\n    /**\n     * @dev Creates a new opHandle with the given type for `user`. Hodl and Prps share the same\n     * opCounter to enforce a consistent order in which pending ops are finalized/reverted\n     * across contracts. This function can only be called by Hodl.\n     */\n    function createNewOpHandleShared(\n        IOptIn.OptInStatus memory optInStatus,\n        address user,\n        uint8 opType\n    ) public onlyHodl returns (OpHandle memory) {\n        return _createNewOpHandle(optInStatus, user, opType);\n    }\n\n    /**\n     * @dev Delete the op handle with the given `opId` from `user`. Hodl and Prps share the same\n     * opCounter to enforce a consistent order in which pending ops are finalized/reverted\n     * across contracts. This function can only be called by Hodl.\n     */\n    function deleteOpHandleShared(address user, OpHandle memory opHandle)\n        public\n        onlyHodl\n        returns (bool)\n    {\n        _deleteOpHandle(user, opHandle);\n        return true;\n    }\n\n    /**\n     * @dev Get the next op id for `user`. Hodl and Prps share the same\n     * opCounter to enforce a consistent order in which pending ops are finalized/reverted\n     * across contracts. This function can only be called by Hodl.\n     */\n    function assertFinalizeFIFOShared(address user, uint64 opId)\n        public\n        onlyHodl\n        returns (bool)\n    {\n        _assertFinalizeFIFO(user, opId);\n        return true;\n    }\n\n    /**\n     * @dev Get the next op id for `user`. Hodl and Prps share the same\n     * opCounter to enforce a consistent order in which pending ops are finalized/reverted\n     * across contracts. This function can only be called by Hodl.\n     */\n    function assertRevertLIFOShared(address user, uint64 opId)\n        public\n        onlyHodl\n        returns (bool)\n    {\n        _assertRevertLIFO(user, opId);\n        return true;\n    }\n}\n"
12     },
13     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
15     },
16     "@openzeppelin/contracts/math/SafeMath.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
18     },
19     "@openzeppelin/contracts/access/Ownable.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
21     },
22     "@openzeppelin/contracts/introspection/IERC1820Registry.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
24     },
25     "contracts/IBoostableERC20.sol": {
26       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n// Token agnostic fuel struct that is passed around when the fuel is burned by a different (token) contract.\n// The contract has to explicitely support the desired token that should be burned.\nstruct TokenFuel {\n    // A token alias that must be understood by the target contract\n    uint8 tokenAlias;\n    uint96 amount;\n}\n\n/**\n * @dev Extends the interface of the ERC20 standard as defined in the EIP with\n * `boostedTransferFrom` to perform transfers without having to rely on an allowance.\n */\ninterface IBoostableERC20 {\n    // ERC20\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    // Extension\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`.\n     *\n     * If the caller is known by the callee, then the implementation should skip approval checks.\n     * Also accepts a data payload, similar to ERC721's `safeTransferFrom` to pass arbitrary data.\n     *\n     */\n    function boostedTransferFrom(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n\n    /**\n     * @dev Burns `fuel` from `from`.\n     */\n    function burnFuel(address from, TokenFuel memory fuel) external;\n}\n"
27     },
28     "contracts/BoostableERC20.sol": {
29       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./Boostable.sol\";\nimport \"./BoostableLib.sol\";\n\n/**\n * @dev EIP712 boostable primitives related to ERC20 for the Purpose domain\n */\nabstract contract BoostableERC20 is Boostable {\n    /**\n     * @dev A struct representing the payload of the ERC20 `boostedSend` function.\n     */\n    struct BoostedSend {\n        uint8 tag;\n        address sender;\n        address recipient;\n        uint256 amount;\n        bytes data;\n        BoosterFuel fuel;\n        BoosterPayload boosterPayload;\n    }\n\n    /**\n     * @dev A struct representing the payload of the ERC20 `boostedBurn` function.\n     */\n    struct BoostedBurn {\n        uint8 tag;\n        address account;\n        uint256 amount;\n        bytes data;\n        BoosterFuel fuel;\n        BoosterPayload boosterPayload;\n    }\n\n    uint8 internal constant BOOST_TAG_SEND = 0;\n    uint8 internal constant BOOST_TAG_BURN = 1;\n\n    bytes32 internal constant BOOSTED_SEND_TYPEHASH = keccak256(\n        \"BoostedSend(uint8 tag,address sender,address recipient,uint256 amount,bytes data,BoosterFuel fuel,BoosterPayload boosterPayload)BoosterFuel(uint96 dubi,uint96 unlockedPrps,uint96 lockedPrps,uint96 intrinsicFuel)BoosterPayload(address booster,uint64 timestamp,uint64 nonce,bool isLegacySignature)\"\n    );\n\n    bytes32 internal constant BOOSTED_BURN_TYPEHASH = keccak256(\n        \"BoostedBurn(uint8 tag,address account,uint256 amount,bytes data,BoosterFuel fuel,BoosterPayload boosterPayload)BoosterFuel(uint96 dubi,uint96 unlockedPrps,uint96 lockedPrps,uint96 intrinsicFuel)BoosterPayload(address booster,uint64 timestamp,uint64 nonce,bool isLegacySignature)\"\n    );\n\n    constructor(address optIn) public Boostable(optIn) {}\n\n    /**\n     * @dev Returns the hash of `boostedSend`.\n     */\n    function hashBoostedSend(BoostedSend memory send, address booster)\n        internal\n        view\n        returns (bytes32)\n    {\n        return\n            BoostableLib.hashWithDomainSeparator(\n                _DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        BOOSTED_SEND_TYPEHASH,\n                        BOOST_TAG_SEND,\n                        send.sender,\n                        send.recipient,\n                        send.amount,\n                        keccak256(send.data),\n                        BoostableLib.hashBoosterFuel(send.fuel),\n                        BoostableLib.hashBoosterPayload(\n                            send.boosterPayload,\n                            booster\n                        )\n                    )\n                )\n            );\n    }\n\n    /**\n     * @dev Returns the hash of `boostedBurn`.\n     */\n    function hashBoostedBurn(BoostedBurn memory burn, address booster)\n        internal\n        view\n        returns (bytes32)\n    {\n        return\n            BoostableLib.hashWithDomainSeparator(\n                _DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        BOOSTED_BURN_TYPEHASH,\n                        BOOST_TAG_BURN,\n                        burn.account,\n                        burn.amount,\n                        keccak256(burn.data),\n                        BoostableLib.hashBoosterFuel(burn.fuel),\n                        BoostableLib.hashBoosterPayload(\n                            burn.boosterPayload,\n                            booster\n                        )\n                    )\n                )\n            );\n    }\n\n    /**\n     * @dev Tries to interpret the given boosterMessage and\n     * return it's hash plus creation timestamp.\n     */\n    function decodeAndHashBoosterMessage(\n        address targetBooster,\n        bytes memory boosterMessage\n    ) external override view returns (bytes32, uint64) {\n        require(boosterMessage.length > 0, \"PB-7\");\n\n        uint8 tag = _readBoosterTag(boosterMessage);\n        if (tag == BOOST_TAG_SEND) {\n            BoostedSend memory send = abi.decode(boosterMessage, (BoostedSend));\n            return (\n                hashBoostedSend(send, targetBooster),\n                send.boosterPayload.timestamp\n            );\n        }\n\n        if (tag == BOOST_TAG_BURN) {\n            BoostedBurn memory burn = abi.decode(boosterMessage, (BoostedBurn));\n            return (\n                hashBoostedBurn(burn, targetBooster),\n                burn.boosterPayload.timestamp\n            );\n        }\n\n        // Unknown tag, so just return an empty result\n        return (\"\", 0);\n    }\n}\n"
30     },
31     "@openzeppelin/contracts/GSN/Context.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
33     },
34     "contracts/Boostable.sol": {
35       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./ProtectedBoostable.sol\";\n\n/**\n * @dev Purpose Boostable primitives using the EIP712 standard\n */\nabstract contract Boostable is ProtectedBoostable {\n    // \"Purpose\", \"Dubi\" and \"Hodl\" are all under the \"Purpose\" umbrella\n    constructor(address optIn)\n        public\n        ProtectedBoostable(\n            optIn,\n            keccak256(\n                abi.encode(\n                    EIP712_DOMAIN_TYPEHASH,\n                    keccak256(\"Purpose\"),\n                    keccak256(\"1\"),\n                    _getChainId(),\n                    address(this)\n                )\n            )\n        )\n    {}\n\n    // Fuel alias constants - used when fuel is burned from external contract calls\n    uint8 internal constant TOKEN_FUEL_ALIAS_UNLOCKED_PRPS = 0;\n    uint8 internal constant TOKEN_FUEL_ALIAS_LOCKED_PRPS = 1;\n    uint8 internal constant TOKEN_FUEL_ALIAS_DUBI = 2;\n}\n"
36     },
37     "contracts/BoostableLib.sol": {
38       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nstruct BoosterFuel {\n    uint96 dubi;\n    uint96 unlockedPrps;\n    uint96 lockedPrps;\n    uint96 intrinsicFuel;\n}\n\nstruct BoosterPayload {\n    address booster;\n    uint64 timestamp;\n    uint64 nonce;\n    // Fallback for 'personal_sign' when e.g. using hardware wallets that don't support\n    // EIP712 signing (yet).\n    bool isLegacySignature;\n}\n\n// Library for Boostable hash functions that are completely inlined.\nlibrary BoostableLib {\n    bytes32 private constant BOOSTER_PAYLOAD_TYPEHASH = keccak256(\n        \"BoosterPayload(address booster,uint64 timestamp,uint64 nonce,bool isLegacySignature)\"\n    );\n\n    bytes32 internal constant BOOSTER_FUEL_TYPEHASH = keccak256(\n        \"BoosterFuel(uint96 dubi,uint96 unlockedPrps,uint96 lockedPrps,uint96 intrinsicFuel)\"\n    );\n\n    /**\n     * @dev Returns the hash of the packed DOMAIN_SEPARATOR and `messageHash` and is used for verifying\n     * a signature.\n     */\n    function hashWithDomainSeparator(\n        bytes32 domainSeparator,\n        bytes32 messageHash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", domainSeparator, messageHash)\n            );\n    }\n\n    /**\n     * @dev Returns the hash of `payload` using the provided booster (i.e. `msg.sender`).\n     */\n    function hashBoosterPayload(BoosterPayload memory payload, address booster)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    BOOSTER_PAYLOAD_TYPEHASH,\n                    booster,\n                    payload.timestamp,\n                    payload.nonce,\n                    payload.isLegacySignature\n                )\n            );\n    }\n\n    function hashBoosterFuel(BoosterFuel memory fuel)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    BOOSTER_FUEL_TYPEHASH,\n                    fuel.dubi,\n                    fuel.unlockedPrps,\n                    fuel.lockedPrps,\n                    fuel.intrinsicFuel\n                )\n            );\n    }\n\n    /**\n     * @dev Returns the tag found in the given `boosterMessage`.\n     */\n    function _readBoosterTag(bytes memory boosterMessage)\n        internal\n        pure\n        returns (uint8)\n    {\n        // The tag is either the 32th byte or the 64th byte depending on whether\n        // the booster message contains dynamic bytes or not.\n        //\n        // If it contains a dynamic byte array, then the first word points to the first\n        // data location.\n        //\n        // Therefore, we read the 32th byte and check if it's >= 32 and if so,\n        // simply read the (32 + first word)th byte to get the tag.\n        //\n        // This imposes a limit on the number of tags we can support (<32), but\n        // given that it is very unlikely for so many tags to exist it is fine.\n        //\n        // Read the 32th byte to get the tag, because it is a uint8 padded to 32 bytes.\n        // i.e.\n        // -----------------------------------------------------------------v\n        // 0x0000000000000000000000000000000000000000000000000000000000000001\n        //   ...\n        //\n        uint8 tag = uint8(boosterMessage[31]);\n        if (tag >= 32) {\n            // Read the (32 + tag) byte. E.g. if tag is 32, then we read the 64th:\n            // --------------------------------------------------------------------\n            // 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            //   0000000000000000000000000000000000000000000000000000000000000001 <\n            //   ...\n            //\n            tag = uint8(boosterMessage[31 + tag]);\n        }\n\n        return tag;\n    }\n}\n"
39     },
40     "contracts/ProtectedBoostable.sol": {
41       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./EIP712Boostable.sol\";\nimport \"./IOptIn.sol\";\nimport \"./ProtectedBoostableLib.sol\";\n\nabstract contract ProtectedBoostable is EIP712Boostable {\n    //---------------------------------------------------------------\n    // State for non-boosted operations while opted-in and the OPT_IN permaboost is active\n    //---------------------------------------------------------------\n\n    uint256 private constant MAX_PENDING_OPS = 25;\n\n    // A mapping of account to an opCounter.\n    mapping(address => OpCounter) internal _opCounters;\n\n    // A mapping of account to an array containing all it's pending ops.\n    mapping(address => OpHandle[]) internal _pendingOpsByAddress;\n\n    // A mapping of keccak256(address,opId) to a struct holding metadata like the associated user account and creation timestamp.\n    mapping(bytes32 => OpMetadata) internal _opMetadata;\n\n    // Event that is emitted whenever a pending op is created\n    // NOTE: returning an OpHandle in the event flattens it into an array for some reason\n    // i.e. emit PendingOp(0x123.., OpHandle(1, 0)) => { from: 0x123, opHandle: ['1', '0']}\n    event PendingOp(address from, uint64 opId, uint8 opType);\n    // Event that is emitted whenever a pending op is finalized\n    event FinalizedOp(address from, uint64 opId, uint8 opType);\n    // Event that is emitted whenever a pending op is reverted\n    event RevertedOp(address from, uint64 opId, uint8 opType);\n\n    constructor(address optIn, bytes32 domainSeparator)\n        public\n        EIP712Boostable(optIn, domainSeparator)\n    {}\n\n    //---------------------------------------------------------------\n    // Pending ops\n    //---------------------------------------------------------------\n\n    /**\n     * @dev Returns the metadata of an op. Returns a zero struct if it doesn't exist.\n     */\n    function getOpMetadata(address user, uint64 opId)\n        public\n        virtual\n        view\n        returns (OpMetadata memory)\n    {\n        return _opMetadata[_getOpKey(user, opId)];\n    }\n\n    /**\n     * @dev Returns the metadata of an op. Returns a zero struct if it doesn't exist.\n     */\n    function getOpCounter(address user)\n        public\n        virtual\n        view\n        returns (OpCounter memory)\n    {\n        return _opCounters[user];\n    }\n\n    /**\n     * @dev Returns the metadata of an op. Reverts if it doesn't exist or\n     * the opType mismatches.\n     */\n    function safeGetOpMetadata(address user, OpHandle memory opHandle)\n        public\n        virtual\n        view\n        returns (OpMetadata memory)\n    {\n        OpMetadata storage metadata = _opMetadata[_getOpKey(\n            user,\n            opHandle.opId\n        )];\n\n        // If 'createdAt' is zero, then it's non-existent for us\n        require(metadata.createdAt > 0, \"PB-1\");\n        require(metadata.opType == opHandle.opType, \"PB-2\");\n\n        return metadata;\n    }\n\n    /**\n     * @dev Get the next op id for `user`\n     */\n    function _getNextOpId(address user) internal returns (uint64) {\n        OpCounter storage counter = _opCounters[user];\n        // NOTE: we always increase by 1, so it cannot overflow as long as this\n        // is the only place increasing the counter.\n        uint64 nextOpId = counter.value + 1;\n\n        // This also updates the nextFinalize/Revert values\n        if (counter.nextFinalize == 0) {\n            // Only gets updated if currently pointing to \"nothing\", because FIFO\n            counter.nextFinalize = nextOpId;\n        }\n\n        // nextRevert is always updated to the new opId, because LIFO\n        counter.nextRevert = nextOpId;\n        counter.value = nextOpId;\n\n        // NOTE: It is safe to downcast to uint64 since it's practically impossible to overflow.\n        return nextOpId;\n    }\n\n    /**\n     * @dev Creates a new opHandle with the given type for `user`.\n     */\n    function _createNewOpHandle(\n        IOptIn.OptInStatus memory optInStatus,\n        address user,\n        uint8 opType\n    ) internal virtual returns (OpHandle memory) {\n        uint64 nextOpId = _getNextOpId(user);\n        OpHandle memory opHandle = OpHandle({opId: nextOpId, opType: opType});\n\n        // NOTE: we have a hard limit of 25 pending OPs and revert if that\n        // limit is exceeded.\n        require(_pendingOpsByAddress[user].length < MAX_PENDING_OPS, \"PB-3\");\n\n        address booster = optInStatus.optedInTo;\n\n        _pendingOpsByAddress[user].push(opHandle);\n        _opMetadata[_getOpKey(user, nextOpId)] = OpMetadata({\n            createdAt: uint64(block.timestamp),\n            booster: booster,\n            opType: opType\n        });\n\n        return opHandle;\n    }\n\n    /**\n     * @dev Delete the given `opHandle` from `user`.\n     */\n    function _deleteOpHandle(address user, OpHandle memory opHandle)\n        internal\n        virtual\n    {\n        OpHandle[] storage _opHandles = _pendingOpsByAddress[user];\n        OpCounter storage opCounter = _opCounters[user];\n\n        ProtectedBoostableLib.deleteOpHandle(\n            user,\n            opHandle,\n            _opHandles,\n            opCounter,\n            _opMetadata\n        );\n    }\n\n    /**\n     * @dev Assert that the caller is allowed to finalize a pending op.\n     *\n     * Returns the user and createdAt timestamp of the op on success in order to\n     * save some gas by minimizing redundant look-ups.\n     */\n    function _assertCanFinalize(address user, OpHandle memory opHandle)\n        internal\n        returns (uint64)\n    {\n        OpMetadata memory metadata = safeGetOpMetadata(user, opHandle);\n\n        uint64 createdAt = metadata.createdAt;\n\n        // First check if the user is still opted-in. If not, then anyone\n        // can finalize since it is no longer associated with the original booster.\n        IOptIn.OptInStatus memory optInStatus = getOptInStatus(user);\n        if (!optInStatus.isOptedIn) {\n            return createdAt;\n        }\n\n        // Revert if not FIFO order\n        _assertFinalizeFIFO(user, opHandle.opId);\n\n        return ProtectedBoostableLib.assertCanFinalize(metadata, optInStatus);\n    }\n\n    /**\n     * @dev Asserts that the caller (msg.sender) is allowed to revert a pending operation.\n     * The caller must be opted-in by user and provide a valid signature from the user\n     * that hasn't expired yet.\n     */\n    function _assertCanRevert(\n        address user,\n        OpHandle memory opHandle,\n        uint64 opTimestamp,\n        bytes memory boosterMessage,\n        Signature memory signature\n    ) internal {\n        // Revert if not LIFO order\n        _assertRevertLIFO(user, opHandle.opId);\n\n        IOptIn.OptInStatus memory optInStatus = getOptInStatus(user);\n\n        require(\n            optInStatus.isOptedIn && msg.sender == optInStatus.optedInTo,\n            \"PB-6\"\n        );\n\n        // In order to verify the boosterMessage, we need the hash and timestamp of when it\n        // was signed. To interpret the boosterMessage, consult all available hasher contracts and\n        // take the first non-zero result.\n        address[] memory hasherContracts = _getHasherContracts();\n\n        // Call external library function, which performs the actual assertion. The reason\n        // why it is not inlined, is that the need to reduce bytecode size.\n        ProtectedBoostableLib.verifySignatureForRevert(\n            user,\n            opTimestamp,\n            optInStatus,\n            boosterMessage,\n            hasherContracts,\n            signature\n        );\n    }\n\n    function _getHasherContracts() internal virtual returns (address[] memory);\n\n    /**\n     * @dev Asserts that the given opId is the next to be finalized for `user`.\n     */\n    function _assertFinalizeFIFO(address user, uint64 opId) internal virtual {\n        OpCounter storage counter = _opCounters[user];\n        require(counter.nextFinalize == opId, \"PB-9\");\n    }\n\n    /**\n     * @dev Asserts that the given opId is the next to be reverted for `user`.\n     */\n    function _assertRevertLIFO(address user, uint64 opId) internal virtual {\n        OpCounter storage counter = _opCounters[user];\n        require(counter.nextRevert == opId, \"PB-10\");\n    }\n\n    /**\n     * @dev Prepare an op revert.\n     * - Asserts that the caller is allowed to revert the given op\n     * - Deletes the op handle to minimize risks of reentrancy\n     */\n    function _prepareOpRevert(\n        address user,\n        OpHandle memory opHandle,\n        bytes memory boosterMessage,\n        Signature memory signature\n    ) internal {\n        OpMetadata memory metadata = safeGetOpMetadata(user, opHandle);\n\n        _assertCanRevert(\n            user,\n            opHandle,\n            metadata.createdAt,\n            boosterMessage,\n            signature\n        );\n\n        // Delete opHandle, which prevents reentrancy since `safeGetOpMetadata`\n        // will fail afterwards.\n        _deleteOpHandle(user, opHandle);\n    }\n\n    /**\n     * @dev Returns the hash of (user, opId) which is used as a look-up\n     * key in the `_opMetadata` mapping.\n     */\n    function _getOpKey(address user, uint64 opId)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(user, opId));\n    }\n\n    /**\n     * @dev Deriving contracts can override this function to accept a boosterMessage for a given booster and\n     * interpret it into a hash and timestamp.\n     */\n    function decodeAndHashBoosterMessage(\n        address targetBooster,\n        bytes memory boosterMessage\n    ) external virtual view returns (bytes32, uint64) {}\n\n    /**\n     * @dev Returns the tag found in the given `boosterMesasge`.\n     */\n    function _readBoosterTag(bytes memory boosterMessage)\n        internal\n        pure\n        returns (uint8)\n    {\n        // The tag is either the 32th byte or the 64th byte depending on whether\n        // the booster message contains dynamic bytes or not.\n        //\n        // If it contains a dynamic byte array, then the first word points to the first\n        // data location.\n        //\n        // Therefore, we read the 32th byte and check if it's >= 32 and if so,\n        // simply read the (32 + first word)th byte to get the tag.\n        //\n        // This imposes a limit on the number of tags we can support (<32), but\n        // given that it is very unlikely for so many tags to exist it is fine.\n        //\n        // Read the 32th byte to get the tag, because it is a uint8 padded to 32 bytes.\n        // i.e.\n        // -----------------------------------------------------------------v\n        // 0x0000000000000000000000000000000000000000000000000000000000000001\n        //   ...\n        //\n        uint8 tag = uint8(boosterMessage[31]);\n        if (tag >= 32) {\n            // Read the (32 + tag) byte. E.g. if tag is 32, then we read the 64th:\n            // --------------------------------------------------------------------\n            // 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            //   0000000000000000000000000000000000000000000000000000000000000001 <\n            //   ...\n            //\n            tag = uint8(boosterMessage[31 + tag]);\n        }\n\n        return tag;\n    }\n}\n"
42     },
43     "contracts/EIP712Boostable.sol": {
44       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\nimport \"./IOptIn.sol\";\nimport \"./BoostableLib.sol\";\nimport \"./IBoostableERC20.sol\";\n\n/**\n * @dev Boostable base contract\n *\n * All deriving contracts are expected to implement EIP712 for the message signing.\n *\n */\nabstract contract EIP712Boostable {\n    using ECDSA for bytes32;\n\n    // solhint-disable-next-line var-name-mixedcase\n    IOptIn internal immutable _OPT_IN;\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n    );\n\n    bytes32 private constant BOOSTER_PAYLOAD_TYPEHASH = keccak256(\n        \"BoosterPayload(address booster,uint64 timestamp,uint64 nonce,bool isLegacySignature)\"\n    );\n\n    bytes32 internal constant BOOSTER_FUEL_TYPEHASH = keccak256(\n        \"BoosterFuel(uint96 dubi,uint96 unlockedPrps,uint96 lockedPrps,uint96 intrinsicFuel)\"\n    );\n\n    // The boost fuel is capped to 10 of the respective token that will be used for payment.\n    uint96 internal constant MAX_BOOSTER_FUEL = 10 ether;\n\n    // A magic booster permission prefix\n    bytes6 private constant MAGIC_BOOSTER_PERMISSION_PREFIX = \"BOOST-\";\n\n    constructor(address optIn, bytes32 domainSeparator) public {\n        _OPT_IN = IOptIn(optIn);\n        _DOMAIN_SEPARATOR = domainSeparator;\n    }\n\n    // A mapping of mappings to keep track of used nonces by address to\n    // protect against replays. Each 'Boostable' contract maintains it's own\n    // state for nonces.\n    mapping(address => uint64) private _nonces;\n\n    //---------------------------------------------------------------\n\n    function getNonce(address account) external virtual view returns (uint64) {\n        return _nonces[account];\n    }\n\n    function getOptInStatus(address account)\n        internal\n        view\n        returns (IOptIn.OptInStatus memory)\n    {\n        return _OPT_IN.getOptInStatus(account);\n    }\n\n    /**\n     * @dev Called by every 'boosted'-function to ensure that `msg.sender` (i.e. a booster) is\n     * allowed to perform the call for `from` (the origin) by verifying that `messageHash`\n     * has been signed by `from`. Additionally, `from` provides a nonce to prevent\n     * replays. Boosts cannot be verified out of order.\n     *\n     * @param from the address that the boost is made for\n     * @param messageHash the reconstructed message hash based on the function input\n     * @param payload the booster payload\n     * @param signature the signature of `from`\n     */\n    function verifyBoost(\n        address from,\n        bytes32 messageHash,\n        BoosterPayload memory payload,\n        Signature memory signature\n    ) internal {\n        uint64 currentNonce = _nonces[from];\n        require(currentNonce == payload.nonce - 1, \"AB-1\");\n\n        _nonces[from] = currentNonce + 1;\n\n        _verifyBoostWithoutNonce(from, messageHash, payload, signature);\n    }\n\n    /**\n     * @dev Verify a boost without verifying the nonce.\n     */\n    function _verifyBoostWithoutNonce(\n        address from,\n        bytes32 messageHash,\n        BoosterPayload memory payload,\n        Signature memory signature\n    ) internal view {\n        // The sender must be the booster specified in the payload\n        require(msg.sender == payload.booster, \"AB-2\");\n\n        (bool isOptedInToSender, uint256 optOutPeriod) = _OPT_IN.isOptedInBy(\n            msg.sender,\n            from\n        );\n\n        // `from` must be opted-in to booster\n        require(isOptedInToSender, \"AB-3\");\n\n        // The given timestamp must not be greater than `block.timestamp + 1 hour`\n        // and at most `optOutPeriod(booster)` seconds old.\n        uint64 _now = uint64(block.timestamp);\n        uint64 _optOutPeriod = uint64(optOutPeriod);\n\n        bool notTooFarInFuture = payload.timestamp <= _now + 1 hours;\n        bool belowMaxAge = true;\n\n        // Calculate the absolute difference. Because of the small tolerance, `payload.timestamp`\n        // may be greater than `_now`:\n        if (payload.timestamp <= _now) {\n            belowMaxAge = _now - payload.timestamp <= _optOutPeriod;\n        }\n\n        // Signature must not be expired\n        require(notTooFarInFuture && belowMaxAge, \"AB-4\");\n\n        // NOTE: Currently, hardware wallets (e.g. Ledger, Trezor) do not support EIP712 signing (specifically `signTypedData_v4`).\n        // However, a user can still sign the EIP712 hash with the caveat that it's signed using `personal_sign` which prepends\n        // the prefix '\"\\x19Ethereum Signed Message:\\n\" + len(message)'.\n        //\n        // To still support that, we add the prefix to the hash if `isLegacySignature` is true.\n        if (payload.isLegacySignature) {\n            messageHash = messageHash.toEthSignedMessageHash();\n        }\n\n        // Valid, if the recovered address from `messageHash` with the given `signature` matches `from`.\n\n        address signer = ecrecover(\n            messageHash,\n            signature.v,\n            signature.r,\n            signature.s\n        );\n\n        if (!payload.isLegacySignature && signer != from) {\n            // As a last resort we try anyway, in case the caller simply forgot the `isLegacySignature` flag.\n            signer = ecrecover(\n                messageHash.toEthSignedMessageHash(),\n                signature.v,\n                signature.r,\n                signature.s\n            );\n        }\n\n        require(from == signer, \"AB-5\");\n    }\n\n    /**\n     * @dev Returns the hash of `payload` using the provided booster (i.e. `msg.sender`).\n     */\n    function hashBoosterPayload(BoosterPayload memory payload, address booster)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    BOOSTER_PAYLOAD_TYPEHASH,\n                    booster,\n                    payload.timestamp,\n                    payload.nonce\n                )\n            );\n    }\n\n    function _getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"
45     },
46     "contracts/IOptIn.sol": {
47       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nstruct Signature {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n}\n\ninterface IOptIn {\n    struct OptInStatus {\n        bool isOptedIn;\n        bool permaBoostActive;\n        address optedInTo;\n        uint32 optOutPeriod;\n    }\n\n    function getOptInStatusPair(address accountA, address accountB)\n        external\n        view\n        returns (OptInStatus memory, OptInStatus memory);\n\n    function getOptInStatus(address account)\n        external\n        view\n        returns (OptInStatus memory);\n\n    function isOptedInBy(address _sender, address _account)\n        external\n        view\n        returns (bool, uint256);\n}\n"
48     },
49     "contracts/ProtectedBoostableLib.sol": {
50       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\nimport \"./IOptIn.sol\";\n\nstruct OpHandle {\n    uint8 opType;\n    uint64 opId;\n}\n\nstruct OpMetadata {\n    uint8 opType; // the operation type\n    uint64 createdAt; // the creation timestamp of an op\n    address booster; // the booster at the time of when the op has been created\n}\n\nstruct OpCounter {\n    // The current value of the counter\n    uint64 value;\n    // Contains the opId that is to be finalized next - i.e. FIFO order\n    uint64 nextFinalize;\n    // Contains the opId that is to be reverted next - i.e. LIFO order\n    uint64 nextRevert;\n}\n\n// Library containing public functions for pending ops - those will never be inlined\n// to reduce the bytecode size of individual contracts.\nlibrary ProtectedBoostableLib {\n    using ECDSA for bytes32;\n\n    function deleteOpHandle(\n        address user,\n        OpHandle memory opHandle,\n        OpHandle[] storage opHandles,\n        OpCounter storage opCounter,\n        mapping(bytes32 => OpMetadata) storage opMetadata\n    ) public {\n        uint256 length = opHandles.length;\n        assert(length > 0);\n\n        uint64 minOpId; // becomes next LIFO\n        uint64 maxOpId; // becomes next FIFO\n\n        // Pending ops are capped to MAX_PENDING_OPS. We always perform\n        // MIN(length, MAX_PENDING_OPS) look-ups to do a \"swap-and-pop\" and\n        // for updating the opCounter LIFO/FIFO pointers.\n        for (uint256 i = 0; i < length; i++) {\n            uint64 currOpId = opHandles[i].opId;\n            if (currOpId == opHandle.opId) {\n                // Overwrite item at i with last\n                opHandles[i] = opHandles[length - 1];\n\n                // Continue, to ignore this opId when updating\n                // minOpId and maxOpId.\n                continue;\n            }\n\n            // Update minOpId\n            if (minOpId == 0 || currOpId < minOpId) {\n                minOpId = currOpId;\n            }\n\n            // Update maxOpId\n            if (currOpId > maxOpId) {\n                maxOpId = currOpId;\n            }\n        }\n\n        // Might be 0 when everything got finalized/reverted\n        opCounter.nextFinalize = minOpId;\n        // Might be 0 when everything got finalized/reverted\n        opCounter.nextRevert = maxOpId;\n\n        // Remove the last item\n        opHandles.pop();\n\n        // Remove metadata\n        delete opMetadata[_getOpKey(user, opHandle.opId)];\n    }\n\n    function assertCanFinalize(\n        OpMetadata memory metadata,\n        IOptIn.OptInStatus memory optInStatus\n    ) public view returns (uint64) {\n        // Now there are three valid scenarios remaining:\n        //\n        // - msg.sender is the original booster\n        // - op is expired\n        // - getBoosterAddress returns a different booster than the original booster\n        //\n        // In the second and third case, anyone can call finalize.\n        address originalBooster = metadata.booster;\n\n        if (originalBooster == msg.sender) {\n            return metadata.createdAt; // First case\n        }\n\n        address currentBooster = optInStatus.optedInTo;\n        uint256 optOutPeriod = optInStatus.optOutPeriod;\n\n        bool isExpired = block.timestamp >= metadata.createdAt + optOutPeriod;\n        if (isExpired) {\n            return metadata.createdAt; // Second case\n        }\n\n        if (currentBooster != originalBooster) {\n            return metadata.createdAt; // Third case\n        }\n\n        revert(\"PB-4\");\n    }\n\n    function verifySignatureForRevert(\n        address user,\n        uint64 opTimestamp,\n        IOptIn.OptInStatus memory optInStatus,\n        bytes memory boosterMessage,\n        address[] memory hasherContracts,\n        Signature memory signature\n    ) public {\n        require(hasherContracts.length > 0, \"PB-12\");\n\n        // Result of hasher contract call\n        uint64 signedAt;\n        bytes32 boosterHash;\n        bool signatureVerified;\n\n        for (uint256 i = 0; i < hasherContracts.length; i++) {\n            // Call into the hasher contract and take the first non-zero result.\n            // The contract must implement the following function:\n            //\n            // decodeAndHashBoosterMessage(\n            //     address targetBooster,\n            //     bytes memory boosterMessage\n            // )\n            //\n            // If it doesn't, then the call will fail (success=false) and we try the next one.\n            // If it succeeds (success = true), then we try to decode the result.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory result) = address(hasherContracts[i])\n                .call(\n                // keccak256(\"decodeAndHashBoosterMessage(address,bytes)\")\n                abi.encodeWithSelector(\n                    0xaf6eec54,\n                    msg.sender, /* msg.sender becomes the target booster */\n                    boosterMessage\n                )\n            );\n\n            if (!success) {\n                continue;\n            }\n\n            // The result is exactly 2 words long = 512 bits = 64 bytes\n            // 32 bytes for the expected message hash\n            // 8 bytes (padded to 32 bytes) for the expected timestamp\n            if (result.length != 64) {\n                continue;\n            }\n\n            // NOTE: A contract with malintent could return any hash that we would\n            // try to recover against. But there is no harm done in doing so since\n            // the user must have signed it.\n            //\n            // However, it might return an unrelated timestamp, that the user hasn't\n            // signed - so it could prolong the expiry of a signature which is a valid\n            // concern whose risk we minimize by using also the op timestamp which guarantees\n            // that a signature eventually expires.\n\n            // Decode and recover signer\n            (boosterHash, signedAt) = abi.decode(result, (bytes32, uint64));\n            address signer = ecrecover(\n                boosterHash,\n                signature.v,\n                signature.r,\n                signature.s\n            );\n\n            if (user != signer) {\n                // NOTE: Currently, hardware wallets (e.g. Ledger, Trezor) do not support EIP712 signing (specifically `signTypedData_v4`).\n                // However, a user can still sign the EIP712 hash with the caveat that it's signed using `personal_sign` which prepends\n                // the prefix '\"\\x19Ethereum Signed Message:\\n\" + len(message)'.\n                //\n                // To still support that, we also add the prefix and try to use the recovered address instead:\n                signer = ecrecover(\n                    boosterHash.toEthSignedMessageHash(),\n                    signature.v,\n                    signature.r,\n                    signature.s\n                );\n            }\n\n            // If we recovered `user` from the signature, then we have a valid signature.\n            if (user == signer) {\n                signatureVerified = true;\n                break;\n            }\n\n            // Keep trying\n        }\n\n        // Revert if signature couldn't be verified with any of the returned hashes\n        require(signatureVerified, \"PB-8\");\n\n        // Lastly, the current time must not be older than:\n        // MIN(opTimestamp, signedAt) + optOutPeriod * 3\n        uint64 _now = uint64(block.timestamp);\n        // The maximum age is equal to whichever is lowest:\n        //      opTimestamp + optOutPeriod * 3\n        //      signedAt + optOutPeriod * 3\n        uint64 maximumAge;\n        if (opTimestamp > signedAt) {\n            maximumAge = signedAt + uint64(optInStatus.optOutPeriod * 3);\n        } else {\n            maximumAge = opTimestamp + uint64(optInStatus.optOutPeriod * 3);\n        }\n\n        require(_now <= maximumAge, \"PB-11\");\n    }\n\n    function _getOpKey(address user, uint64 opId)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(user, opId));\n    }\n}\n"
51     },
52     "@openzeppelin/contracts/cryptography/ECDSA.sol": {
53       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n\n        if (v != 27 && v != 28) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
54     },
55     "contracts/IHodl.sol": {
56       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IHodl {\n    /**\n     * @dev Lock the given amount of PRPS for the specified period (or infinitely)\n     * for DUBI.\n     */\n    function hodl(\n        uint24 id,\n        uint96 amountPrps,\n        uint16 duration,\n        address dubiBeneficiary,\n        address prpsBeneficiary\n    ) external;\n\n    /**\n     * @dev Release a hodl of `prpsBeneficiary` with the given `creator` and `id`.\n     */\n    function release(\n        uint24 id,\n        address prpsBeneficiary,\n        address creator\n    ) external;\n\n    /**\n     * @dev Withdraw can be used to withdraw DUBI from infinitely locked PRPS.\n     * The amount of DUBI withdrawn depends on the time passed since the last withdrawal.\n     */\n    function withdraw(\n        uint24 id,\n        address prpsBeneficiary,\n        address creator\n    ) external;\n\n    /**\n     * @dev Burn `amount` of `from`'s locked and/or pending PRPS.\n     *\n     * This function is supposed to be only called by the PRPS contract.\n     *\n     * Returns the amount of DUBI that needs to be minted.\n     */\n    function burnLockedPrps(\n        address from,\n        uint96 amount,\n        uint32 dubiMintTimestamp,\n        bool burnPendingLockedPrps\n    ) external returns (uint96);\n\n    /**\n     * @dev Set `amount` of `from`'s locked PRPS to pending.\n     *\n     * This function is supposed to be only called by the PRPS contract.\n     *\n     * Returns the amount of locked PRPS that could be set to pending.\n     */\n    function setLockedPrpsToPending(address from, uint96 amount) external;\n\n    /**\n     * @dev Revert `amount` of `from`'s pending locked PRPS to not pending.\n     *\n     * This function is supposed to be only called by the PRPS contract and returns\n     */\n    function revertLockedPrpsSetToPending(address account, uint96 amount)\n        external;\n}\n"
57     },
58     "contracts/MintMath.sol": {
59       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n// NOTE: we ignore leap-seconds etc.\nlibrary MintMath {\n    // The maximum number of seconds per month (365 * 24 * 60 * 60 / 12)\n    uint32 public constant SECONDS_PER_MONTH = 2628000;\n    // The maximum number of days PRPS can be finitely locked for\n    uint16 public constant MAX_FINITE_LOCK_DURATION_DAYS = 365;\n    // The maximum number of seconds PRPS can be finitely locked for\n    uint32 public constant MAX_FINITE_LOCK_DURATION_SECONDS = uint32(\n        MAX_FINITE_LOCK_DURATION_DAYS\n    ) *\n        24 *\n        60 *\n        60;\n\n    /**\n     * @dev Calculates the DUBI to mint based on the given amount of PRPS and duration in days.\n     * NOTE: We trust the caller to ensure that the duration between 1 and 365.\n     */\n    function calculateDubiToMintByDays(\n        uint256 amountPrps,\n        uint16 durationInDays\n    ) internal pure returns (uint96) {\n        uint32 durationInSeconds = uint32(durationInDays) * 24 * 60 * 60;\n        return calculateDubiToMintBySeconds(amountPrps, durationInSeconds);\n    }\n\n    /**\n     * @dev Calculates the DUBI to mint based on the given amount of PRPS and duration in seconds.\n     */\n    function calculateDubiToMintBySeconds(\n        uint256 amountPrps,\n        uint32 durationInSeconds\n    ) internal pure returns (uint96) {\n        // NOTE: We do not use safe math for efficiency reasons\n\n        uint256 _percentage = percentage(\n            durationInSeconds,\n            MAX_FINITE_LOCK_DURATION_SECONDS,\n            18 // precision in WEI, 10^18\n        ) * 4; // A full lock grants 4%, so multiply by 4.\n\n        // Multiply PRPS by the percentage and then divide by the precision (=10^8)\n        // from the previous step\n        uint256 _dubiToMint = (amountPrps * _percentage) / (1 ether * 100); // multiply by 100, because we deal with percentages\n\n        // Assert that the calculated DUBI never overflows uint96\n        assert(_dubiToMint < 2**96);\n\n        return uint96(_dubiToMint);\n    }\n\n    function calculateDubiToMintMax(uint96 amount)\n        internal\n        pure\n        returns (uint96)\n    {\n        return\n            calculateDubiToMintBySeconds(\n                amount,\n                MAX_FINITE_LOCK_DURATION_SECONDS\n            );\n    }\n\n    function calculateMintDuration(uint32 _now, uint32 lastWithdrawal)\n        internal\n        pure\n        returns (uint32)\n    {\n        require(lastWithdrawal > 0 && lastWithdrawal <= _now, \"MINT-1\");\n\n        // NOTE: we don't use any safe math here for efficiency reasons. The assert above\n        // is already a pretty good guarantee that nothing goes wrong. Also, all numbers involved\n        // are very well smaller than uint256 in the first place.\n        uint256 _elapsedTotal = _now - lastWithdrawal;\n        uint256 _proRatedYears = _elapsedTotal / SECONDS_PER_MONTH / 12;\n        uint256 _elapsedInYear = _elapsedTotal %\n            MAX_FINITE_LOCK_DURATION_SECONDS;\n\n        //\n        // Examples (using months instead of seconds):\n        // calculation formula: (monthsSinceWithdrawal % 12) + (_proRatedYears * 12)\n\n        // 1) Burn after 11 months since last withdrawal (number of years = 11 / 12 + 1 = 1)\n        // => (11 % 12) + (years * 12) => 23 months worth of DUBI\n        // => 23 months\n\n        // 1) Burn after 4 months since last withdrawal (number of years = 4 / 12 + 1 = 1)\n        // => (4 % 12) + (years * 12) => 16 months worth of DUBI\n        // => 16 months\n\n        // 2) Burn 0 months after withdrawal after 4 months (number of years = 0 / 12 + 1 = 1):\n        // => (0 % 12) + (years * 12) => 12 months worth of DUBI (+ 4 months worth of withdrawn DUBI)\n        // => 16 months\n\n        // 3) Burn after 36 months since last withdrawal (number of years = 36 / 12 + 1 = 4)\n        // => (36 % 12) + (years * 12) => 48 months worth of DUBI\n        // => 48 months\n\n        // 4) Burn 1 month after withdrawal after 35 months (number of years = 1 / 12 + 1 = 1):\n        // => (1 % 12) + (years * 12) => 12 month worth of DUBI (+ 35 months worth of withdrawn DUBI)\n        // => 47 months\n        uint32 _mintDuration = uint32(\n            _elapsedInYear + _proRatedYears * MAX_FINITE_LOCK_DURATION_SECONDS\n        );\n\n        return _mintDuration;\n    }\n\n    function percentage(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 precision\n    ) internal pure returns (uint256) {\n        return\n            ((numerator * (uint256(10)**(precision + 1))) / denominator + 5) /\n            uint256(10);\n    }\n}\n"
60     }
61   },
62   "settings": {
63     "optimizer": {
64       "enabled": true,
65       "runs": 200
66     },
67     "outputSelection": {
68       "*": {
69         "*": [
70           "evm.bytecode",
71           "evm.deployedBytecode",
72           "abi"
73         ]
74       }
75     },
76     "libraries": {
77       "contracts/ProtectedBoostableLib.sol": {
78         "ProtectedBoostableLib": "0x85ae45a05971170b70744292e2f051c0c49cf909"
79       }
80     }
81   }
82 }}