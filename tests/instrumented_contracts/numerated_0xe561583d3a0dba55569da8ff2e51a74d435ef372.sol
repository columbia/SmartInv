1 {{
2   "language": "Solidity",
3   "sources": {
4     "src.sol/ChannelFactory.sol": {
5       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\n\nimport \"./interfaces/IChannelFactory.sol\";\nimport \"./interfaces/IVectorChannel.sol\";\nimport \"./lib/LibAsset.sol\";\nimport \"./lib/LibERC20.sol\";\n\n/// @title ChannelFactory\n/// @author Connext <support@connext.network>\n/// @notice Creates and sets up a new channel proxy contract\ncontract ChannelFactory is IChannelFactory {\n    // Creation code constants taken from EIP1167\n    bytes private constant proxyCreationCodePrefix =\n        hex\"3d602d80600a3d3981f3_363d3d373d3d3d363d73\";\n    bytes private constant proxyCreationCodeSuffix =\n        hex\"5af43d82803e903d91602b57fd5bf3\";\n\n    bytes32 private creationCodeHash;\n    address private immutable mastercopy;\n    uint256 private immutable chainId;\n\n    /// @dev Creates a new `ChannelFactory`\n    /// @param _mastercopy the address of the `ChannelMastercopy` (channel logic)\n    /// @param _chainId the chain identifier when generating the CREATE2 salt. If zero, the chain identifier used in the proxy salt will be the result of the opcode\n    constructor(address _mastercopy, uint256 _chainId) {\n        mastercopy = _mastercopy;\n        chainId = _chainId;\n        creationCodeHash = keccak256(_getProxyCreationCode(_mastercopy));\n    }\n\n    ////////////////////////////////////////\n    // Public Methods\n\n    /// @dev Allows us to get the mastercopy that this factory will deploy channels against\n    function getMastercopy() external view override returns (address) {\n        return mastercopy;\n    }\n\n    /// @dev Allows us to get the chainId that this factory will use in the create2 salt\n    function getChainId() public view override returns (uint256 _chainId) {\n        // Hold in memory to reduce sload calls\n        uint256 chain = chainId;\n        if (chain == 0) {\n            assembly {\n                _chainId := chainid()\n            }\n        } else {\n            _chainId = chain;\n        }\n    }\n\n    /// @dev Allows us to get the chainId that this factory has stored\n    function getStoredChainId() external view override returns (uint256) {\n        return chainId;\n    }\n\n    /// @dev Returns the proxy code used to both calculate the CREATE2 address and deploy the channel proxy pointed to the `ChannelMastercopy`\n    function getProxyCreationCode()\n        public\n        view\n        override\n        returns (bytes memory)\n    {\n        return _getProxyCreationCode(mastercopy);\n    }\n\n    /// @dev Allows us to get the address for a new channel contract created via `createChannel`\n    /// @param alice address of the igh fidelity channel participant\n    /// @param bob address of the other channel participant\n    function getChannelAddress(address alice, address bob)\n        external\n        view\n        override\n        returns (address)\n    {\n        return\n            Create2.computeAddress(\n                generateSalt(alice, bob),\n                creationCodeHash\n            );\n    }\n\n    /// @dev Allows us to create new channel contract and get it all set up in one transaction\n    /// @param alice address of the high fidelity channel participant\n    /// @param bob address of the other channel participant\n    function createChannel(address alice, address bob)\n        public\n        override\n        returns (address channel)\n    {\n        channel = deployChannelProxy(alice, bob);\n        IVectorChannel(channel).setup(alice, bob);\n        emit ChannelCreation(channel);\n    }\n\n    /// @dev Allows us to create a new channel contract and fund it in one transaction\n    /// @param bob address of the other channel participant\n    function createChannelAndDepositAlice(\n        address alice,\n        address bob,\n        address assetId,\n        uint256 amount\n    ) external payable override returns (address channel) {\n        channel = createChannel(alice, bob);\n        // Deposit funds (if a token) must be approved for the\n        // `ChannelFactory`, which then claims the funds and transfers\n        // to the channel address. While this is inefficient, this is\n        // the safest/clearest way to transfer funds\n        if (!LibAsset.isEther(assetId)) {\n            require(\n                LibERC20.transferFrom(\n                    assetId,\n                    msg.sender,\n                    address(this),\n                    amount\n                ),\n                \"ChannelFactory: ERC20_TRANSFER_FAILED\"\n            );\n            require(\n                LibERC20.approve(assetId, address(channel), amount),\n                \"ChannelFactory: ERC20_APPROVE_FAILED\"\n            );\n        }\n        IVectorChannel(channel).depositAlice{value: msg.value}(assetId, amount);\n    }\n\n    ////////////////////////////////////////\n    // Internal Methods\n\n    function _getProxyCreationCode(address _mastercopy) internal pure returns (bytes memory) {\n      return abi.encodePacked(\n                proxyCreationCodePrefix,\n                _mastercopy,\n                proxyCreationCodeSuffix\n            );\n    }\n\n    /// @dev Allows us to create new channel contact using CREATE2\n    /// @param alice address of the high fidelity participant in the channel\n    /// @param bob address of the other channel participant\n    function deployChannelProxy(address alice, address bob)\n        internal\n        returns (address)\n    {\n        bytes32 salt = generateSalt(alice, bob);\n        return Create2.deploy(0, salt, getProxyCreationCode());\n    }\n\n    /// @dev Generates the unique salt for calculating the CREATE2 address of the channel proxy\n    function generateSalt(address alice, address bob)\n        internal\n        view\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(alice, bob, getChainId()));\n    }\n}\n"
6     },
7     "@openzeppelin/contracts/utils/Create2.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\n        bytes32 _data = keccak256(\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\n        );\n        return address(uint256(_data));\n    }\n}\n"
9     },
10     "src.sol/interfaces/IChannelFactory.sol": {
11       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\ninterface IChannelFactory {\n    event ChannelCreation(address channel);\n\n    function getMastercopy() external view returns (address);\n\n    function getChainId() external view returns (uint256);\n\n    function getStoredChainId() external view returns (uint256);\n\n    function getProxyCreationCode() external view returns (bytes memory);\n\n    function getChannelAddress(address alice, address bob)\n        external\n        view\n        returns (address);\n\n    function createChannel(address alice, address bob)\n        external\n        returns (address);\n\n    function createChannelAndDepositAlice(\n        address alice,\n        address bob,\n        address assetId,\n        uint256 amount\n    ) external payable returns (address);\n}\n"
12     },
13     "src.sol/interfaces/IVectorChannel.sol": {
14       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"./ICMCCore.sol\";\nimport \"./ICMCAsset.sol\";\nimport \"./ICMCDeposit.sol\";\nimport \"./ICMCWithdraw.sol\";\nimport \"./ICMCAdjudicator.sol\";\n\ninterface IVectorChannel is\n    ICMCCore,\n    ICMCAsset,\n    ICMCDeposit,\n    ICMCWithdraw,\n    ICMCAdjudicator\n{}\n"
15     },
16     "src.sol/lib/LibAsset.sol": {
17       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"./LibERC20.sol\";\nimport \"./LibUtils.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\n/// @title LibAsset\n/// @author Connext <support@connext.network>\n/// @notice This library contains helpers for dealing with onchain transfers\n///         of in-channel assets. It is designed to safely handle all asset\n///         transfers out of channel in the event of an onchain dispute. Also\n///         safely handles ERC20 transfers that may be non-compliant\nlibrary LibAsset {\n    address constant ETHER_ASSETID = address(0);\n\n    function isEther(address assetId) internal pure returns (bool) {\n        return assetId == ETHER_ASSETID;\n    }\n\n    function getOwnBalance(address assetId) internal view returns (uint256) {\n        return\n            isEther(assetId)\n                ? address(this).balance\n                : IERC20(assetId).balanceOf(address(this));\n    }\n\n    function transferEther(address payable recipient, uint256 amount)\n        internal\n        returns (bool)\n    {\n        (bool success, bytes memory returnData) =\n            recipient.call{value: amount}(\"\");\n        LibUtils.revertIfCallFailed(success, returnData);\n        return true;\n    }\n\n    function transferERC20(\n        address assetId,\n        address recipient,\n        uint256 amount\n    ) internal returns (bool) {\n        return LibERC20.transfer(assetId, recipient, amount);\n    }\n\n    // This function is a wrapper for transfers of Ether or ERC20 tokens,\n    // both standard-compliant ones as well as tokens that exhibit the\n    // missing-return-value bug.\n    // Although it behaves very much like Solidity's `transfer` function\n    // or the ERC20 `transfer` and is, in fact, designed to replace direct\n    // usage of those, it is deliberately named `unregisteredTransfer`,\n    // because we need to register every transfer out of the channel.\n    // Therefore, it should normally not be used directly, with the single\n    // exception of the `transferAsset` function in `CMCAsset.sol`,\n    // which combines the \"naked\" unregistered transfer given below\n    // with a registration.\n    // USING THIS FUNCTION SOMEWHERE ELSE IS PROBABLY WRONG!\n    function unregisteredTransfer(\n        address assetId,\n        address payable recipient,\n        uint256 amount\n    ) internal returns (bool) {\n        return\n            isEther(assetId)\n                ? transferEther(recipient, amount)\n                : transferERC20(assetId, recipient, amount);\n    }\n}\n"
18     },
19     "src.sol/lib/LibERC20.sol": {
20       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"./LibUtils.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/// @title LibERC20\n/// @author Connext <support@connext.network>\n/// @notice This library provides several functions to safely handle\n///         noncompliant tokens (i.e. does not return a boolean from\n///         the transfer function)\n\nlibrary LibERC20 {\n    function wrapCall(address assetId, bytes memory callData)\n        internal\n        returns (bool)\n    {\n        require(Address.isContract(assetId), \"LibERC20: NO_CODE\");\n        (bool success, bytes memory returnData) = assetId.call(callData);\n        LibUtils.revertIfCallFailed(success, returnData);\n        return returnData.length == 0 || abi.decode(returnData, (bool));\n    }\n\n    function approve(\n        address assetId,\n        address spender,\n        uint256 amount\n    ) internal returns (bool) {\n        return\n            wrapCall(\n                assetId,\n                abi.encodeWithSignature(\n                    \"approve(address,uint256)\",\n                    spender,\n                    amount\n                )\n            );\n    }\n\n    function transferFrom(\n        address assetId,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal returns (bool) {\n        return\n            wrapCall(\n                assetId,\n                abi.encodeWithSignature(\n                    \"transferFrom(address,address,uint256)\",\n                    sender,\n                    recipient,\n                    amount\n                )\n            );\n    }\n\n    function transfer(\n        address assetId,\n        address recipient,\n        uint256 amount\n    ) internal returns (bool) {\n        return\n            wrapCall(\n                assetId,\n                abi.encodeWithSignature(\n                    \"transfer(address,uint256)\",\n                    recipient,\n                    amount\n                )\n            );\n    }\n}\n"
21     },
22     "src.sol/interfaces/ICMCCore.sol": {
23       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\ninterface ICMCCore {\n    function setup(address _alice, address _bob) external;\n\n    function getAlice() external view returns (address);\n\n    function getBob() external view returns (address);\n}\n"
24     },
25     "src.sol/interfaces/ICMCAsset.sol": {
26       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\ninterface ICMCAsset {\n    function getTotalTransferred(address assetId)\n        external\n        view\n        returns (uint256);\n\n    function getExitableAmount(address assetId, address owner)\n        external\n        view\n        returns (uint256);\n\n    function exit(\n        address assetId,\n        address owner,\n        address payable recipient\n    ) external;\n}\n"
27     },
28     "src.sol/interfaces/ICMCDeposit.sol": {
29       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\ninterface ICMCDeposit {\n    event AliceDeposited(address assetId, uint256 amount);\n    \n    function getTotalDepositsAlice(address assetId)\n        external\n        view\n        returns (uint256);\n\n    function getTotalDepositsBob(address assetId)\n        external\n        view\n        returns (uint256);\n\n    function depositAlice(address assetId, uint256 amount) external payable;\n}\n"
30     },
31     "src.sol/interfaces/ICMCWithdraw.sol": {
32       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nstruct WithdrawData {\n    address channelAddress;\n    address assetId;\n    address payable recipient;\n    uint256 amount;\n    uint256 nonce;\n    address callTo;\n    bytes callData;\n}\n\ninterface ICMCWithdraw {\n    function getWithdrawalTransactionRecord(WithdrawData calldata wd)\n        external\n        view\n        returns (bool);\n\n    function withdraw(\n        WithdrawData calldata wd,\n        bytes calldata aliceSignature,\n        bytes calldata bobSignature\n    ) external;\n}\n"
33     },
34     "src.sol/interfaces/ICMCAdjudicator.sol": {
35       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"./Types.sol\";\n\ninterface ICMCAdjudicator {\n    struct CoreChannelState {\n        address channelAddress;\n        address alice;\n        address bob;\n        address[] assetIds;\n        Balance[] balances;\n        uint256[] processedDepositsA;\n        uint256[] processedDepositsB;\n        uint256[] defundNonces;\n        uint256 timeout;\n        uint256 nonce;\n        bytes32 merkleRoot;\n    }\n\n    struct CoreTransferState {\n        address channelAddress;\n        bytes32 transferId;\n        address transferDefinition;\n        address initiator;\n        address responder;\n        address assetId;\n        Balance balance;\n        uint256 transferTimeout;\n        bytes32 initialStateHash;\n    }\n\n    struct ChannelDispute {\n        bytes32 channelStateHash;\n        uint256 nonce;\n        bytes32 merkleRoot;\n        uint256 consensusExpiry;\n        uint256 defundExpiry;\n    }\n\n    struct TransferDispute {\n        bytes32 transferStateHash;\n        uint256 transferDisputeExpiry;\n        bool isDefunded;\n    }\n\n    event ChannelDisputed(\n        address disputer,\n        CoreChannelState state,\n        ChannelDispute dispute\n    );\n\n    event ChannelDefunded(\n        address defunder,\n        CoreChannelState state,\n        ChannelDispute dispute,\n        address[] assetIds\n    );\n\n    event TransferDisputed(\n        address disputer,\n        CoreTransferState state,\n        TransferDispute dispute\n    );\n\n    event TransferDefunded(\n        address defunder,\n        CoreTransferState state,\n        TransferDispute dispute,\n        bytes encodedInitialState,\n        bytes encodedResolver,\n        Balance balance\n    );\n\n    function getChannelDispute() external view returns (ChannelDispute memory);\n\n    function getDefundNonce(address assetId) external view returns (uint256);\n\n    function getTransferDispute(bytes32 transferId)\n        external\n        view\n        returns (TransferDispute memory);\n\n    function disputeChannel(\n        CoreChannelState calldata ccs,\n        bytes calldata aliceSignature,\n        bytes calldata bobSignature\n    ) external;\n\n    function defundChannel(\n        CoreChannelState calldata ccs,\n        address[] calldata assetIds,\n        uint256[] calldata indices\n    ) external;\n\n    function disputeTransfer(\n        CoreTransferState calldata cts,\n        bytes32[] calldata merkleProofData\n    ) external;\n\n    function defundTransfer(\n        CoreTransferState calldata cts,\n        bytes calldata encodedInitialTransferState,\n        bytes calldata encodedTransferResolver,\n        bytes calldata responderSignature\n    ) external;\n}\n"
36     },
37     "src.sol/interfaces/Types.sol": {
38       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nstruct Balance {\n    uint256[2] amount; // [alice, bob] in channel, [initiator, responder] in transfer\n    address payable[2] to; // [alice, bob] in channel, [initiator, responder] in transfer\n}\n"
39     },
40     "src.sol/lib/LibUtils.sol": {
41       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\n/// @title LibUtils\n/// @author Connext <support@connext.network>\n/// @notice Contains a helper to revert if a call was not successfully\n///         made\nlibrary LibUtils {\n    // If success is false, reverts and passes on the revert string.\n    function revertIfCallFailed(bool success, bytes memory returnData)\n        internal\n        pure\n    {\n        if (!success) {\n            assembly {\n                revert(add(returnData, 0x20), mload(returnData))\n            }\n        }\n    }\n}\n"
42     },
43     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
45     },
46     "@openzeppelin/contracts/utils/Address.sol": {
47       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
48     }
49   },
50   "settings": {
51     "optimizer": {
52       "enabled": true,
53       "runs": 200
54     },
55     "outputSelection": {
56       "*": {
57         "*": [
58           "evm.bytecode",
59           "evm.deployedBytecode",
60           "abi"
61         ]
62       }
63     },
64     "metadata": {
65       "useLiteralContent": true
66     }
67   }
68 }}