1 {"ERC20Interface.sol":{"content":"pragma solidity ^0.5.10;\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() \r\n\t\tpublic \r\n\t\tview \r\n\t\treturns (uint256);\r\n\r\n    function balanceOf(address tokenOwner) \r\n\t\tpublic \r\n\t\tview \r\n\t\treturns (uint256 balance);\r\n    \r\n\tfunction allowance\r\n\t\t(address tokenOwner, address spender) \r\n\t\tpublic \r\n\t\tview \r\n\t\treturns (uint256 remaining);\r\n\r\n    function transfer(address to, uint256 tokens) \t\t\t\tpublic \r\n\t\treturns (bool success);\r\n    \r\n\tfunction approve(address spender, uint256 tokens) \t\tpublic \r\n\t\treturns (bool success);\r\n\r\n    function transferFrom \r\n\t\t(address from, address to, uint256 tokens) \t\t\t\tpublic \r\n\t\treturns (bool success);\r\n\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n}"},"MoonFomo.sol":{"content":"pragma solidity ^0.5.10;\r\n\r\nimport \"./ERC20Interface.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract MoonFomo {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    ERC20Interface MoondayToken;\r\n    uint256 public roundCount;\r\n    bool public killSwitch;\r\n    uint256 public increment = 128100000;\r\n    uint256 public initialPrice = 256200000000000;\r\n    address payable public _owner;\r\n\r\n    address payable public moonGoldHodlWallet = 0xd0caEeD5534C4f6DE09416060Cfac7f93d4e2478;\r\n    address payable public moonCapitalHodlWallet = 0x2fe54E61a2AF6275d54e04B8952234Ee2F87d9fD;\r\n\r\n    address payable public _dev1 = 0x4EFD33509c894A4D628a940cdcE10aBb4E2e1b94;\r\n    address payable public _dev2 = 0x394c4CfB55B2638B8dC5A9521f755e38A499607a;\r\n\r\n    struct RoundData{\r\n      uint256 timer;\r\n      uint256 ticketCount;\r\n      uint256 userCount;\r\n      uint256 jackpot;\r\n      uint256 holderPool;\r\n      mapping(address =\u003e uint256) ticketsOwned;\r\n      mapping(address =\u003e uint256) claimList;\r\n      mapping(address =\u003e uint256) reclaimed;\r\n      mapping(uint256 =\u003e address) userRanks;\r\n      bool ended;\r\n    }\r\n\r\n    mapping(uint256 =\u003e RoundData) public rounds;\r\n    mapping(uint256 =\u003e uint256) public jackpotClaimed;\r\n\r\n    event RoundStarted(uint256 round, uint256 endingTime);\r\n    event TicketBought(address buyer, uint256 rankNumber, uint256 ticketAmount);\r\n    event RoundEnded(uint256 round, uint256 jackpot, uint256 tickets);\r\n    event TicketClaimed(uint256 round, address buyer, uint256 claimAmount);\r\n    event DividendClaimed(uint256 round, address claimant, uint256 dividendAmount);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner, \"Not Owner\");\r\n        _;\r\n    }\r\n\r\n    constructor(address payable owner_, address payable _moonday) public {\r\n      _owner = owner_;\r\n      MoondayToken = ERC20Interface(_moonday);\r\n    }\r\n\r\n    /// Starts a round and adds transaction to jackpot\r\n    /// @dev increments round count, initiates timer and loads jackpot\r\n    function initRound(uint _amount) external payable onlyOwner {\r\n      require(roundCount == 0 || rounds[roundCount].ended, \"Previous Round Not Ended!\");\r\n\r\n      roundCount++;\r\n      MoondayToken.transferFrom(msg.sender, address(this), _amount);\r\n      rounds[roundCount].jackpot += _amount.mul(99).div(100);\r\n      rounds[roundCount].timer = now + 10 hours;\r\n\r\n      emit RoundStarted(roundCount, rounds[roundCount].timer);\r\n    }\r\n\r\n    /// Starts a round and adds transaction to jackpot\r\n    /// @dev increments round count, initiates timer and loads jackpot\r\n    function setPricing(uint256 _initialPrice, uint256 _increment) external onlyOwner {\r\n      require(rounds[roundCount].timer \u003c now, \"Previous Round Not Ended!\");\r\n\r\n      initialPrice = _initialPrice;\r\n      increment = _increment;\r\n    }\r\n\r\n    /// Calculate who is in which rank\r\n    /// @dev calculates ticket owner\r\n    /// @param _round the round to query\r\n    /// @param _userIndex the ticket to query\r\n    /// @return owner of ticket\r\n    function getUserRank(uint256 _round, uint256 _userIndex) public view returns(address) {\r\n      return rounds[_round].userRanks[_userIndex];\r\n    }\r\n\r\n    /// Calculate tickets owned by user\r\n    /// @dev calculates tickets owned by user\r\n    /// @param _round the round to query\r\n    /// @param _user the user to query\r\n    /// @return total tickets owned by user\r\n    function getTicketsOwned(uint256 _round, address _user) public view returns(uint256) {\r\n      return rounds[_round].ticketsOwned[_user];\r\n    }\r\n\r\n    /// Get ticket reimbursment amount by user\r\n    /// @dev calculates returnable ticket cost to user\r\n    /// @param _round the round to query\r\n    /// @param _user the user to query\r\n    /// @return ticket reimbursment amount for user\r\n    function getClaimList(uint256 _round, address _user) public view returns(uint256) {\r\n      return rounds[_round].claimList[_user];\r\n    }\r\n\r\n    /// Get dividends claimed user\r\n    /// @dev calculates returnable ticket cost to user\r\n    /// @param _round the round to query\r\n    /// @param _user the user to query\r\n    /// @return dividend claimed by user\r\n    function getReclaim(uint256 _round, address _user) public view returns(uint256) {\r\n      return rounds[_round].reclaimed[_user];\r\n    }\r\n\r\n    /// Calculate ticket cost\r\n    /// @dev calculates ticket price based on current holder pool\r\n    /// @return sumCost current cost of ticket\r\n    function calcTicketCost(uint256 _amount) public view returns(uint256 sumCost) {\r\n      uint256 a = (rounds[roundCount].ticketCount * increment);\r\n      uint256 b = ((rounds[roundCount].ticketCount + _amount) * increment);\r\n\r\n      sumCost = (initialPrice * _amount) + (a * _amount) + ((b - a) * _amount / 2);\r\n    }\r\n\r\n    /// Buy a ticket\r\n    /// @dev purchases a ticket and distributes funds\r\n    /// @return ticket index\r\n    function buyTicket(uint256 _amount) external payable returns(uint256){\r\n      require(rounds[roundCount].timer \u003e now, \"Round Ended!\");\r\n\r\n      uint256 ticketPrice = calcTicketCost(_amount);\r\n      MoondayToken.transferFrom(msg.sender, address(this), ticketPrice);\r\n\r\n      rounds[roundCount].jackpot += ticketPrice.div(10);\r\n      rounds[roundCount].holderPool += ticketPrice.div(10);\r\n      MoondayToken.transfer(moonGoldHodlWallet, ticketPrice.mul(9).div(100));\r\n      MoondayToken.transfer(_owner, ticketPrice.mul(9).div(100));\r\n      MoondayToken.transfer(_dev1, ticketPrice.div(100));\r\n      MoondayToken.transfer(_dev2, ticketPrice.div(100));\r\n\r\n      rounds[roundCount].ticketsOwned[msg.sender] += _amount;\r\n      rounds[roundCount].claimList[msg.sender] += ticketPrice.sub(ticketPrice.mul(41).div(100));\r\n      rounds[roundCount].userRanks[rounds[roundCount].userCount] = msg.sender;\r\n      rounds[roundCount].userCount++;\r\n      rounds[roundCount].ticketCount += _amount;\r\n\r\n      if(!killSwitch){\r\n        rounds[roundCount].timer += 4 * _amount;\r\n      }\r\n      emit TicketBought(msg.sender, rounds[roundCount].userCount, _amount);\r\n      return rounds[roundCount].ticketCount;\r\n    }\r\n\r\n    /// Enable/Disable kill switch\r\n    /// @dev toggles the kill switch, preventing additional time\r\n    function toggleKill() external onlyOwner {\r\n      killSwitch = !killSwitch;\r\n    }\r\n\r\n    /// End the current round\r\n    /// @dev concludes round and pays owner\r\n    function endRound() external {\r\n      require(rounds[roundCount].timer \u003c now, \"Round Not Finished!\");\r\n      require(!rounds[roundCount].ended, \"Round Already Ended!\");\r\n\r\n      uint256 totalClaim = rounds[roundCount].jackpot.mul(9).div(100);\r\n      uint256 ticketLength = 51;\r\n      if(rounds[roundCount].userCount \u003c 51){\r\n        ticketLength = rounds[roundCount].userCount;\r\n      }\r\n\r\n      totalClaim += rounds[roundCount].jackpot.mul(uint256(51).sub(ticketLength)).div(100);\r\n      jackpotClaimed[roundCount] += totalClaim;\r\n      MoondayToken.transfer(moonGoldHodlWallet, rounds[roundCount].jackpot.mul(2).div(10));\r\n      MoondayToken.transfer(moonCapitalHodlWallet, rounds[roundCount].jackpot.mul(2).div(10));\r\n      MoondayToken.transfer(_owner, totalClaim);\r\n\r\n      rounds[roundCount].ended = true;\r\n      emit RoundEnded(roundCount, rounds[roundCount].jackpot, rounds[roundCount].ticketCount);\r\n    }\r\n\r\n    /// Calculate total dividends for a round\r\n    /// @param _round the round to query\r\n    /// @param _ticketHolder the user to query\r\n    /// @dev calculates dividends minus reinvested funds\r\n    /// @return totalDividends total dividends\r\n    function calcDividends(uint256 _round, address _ticketHolder) public view returns(uint256 totalDividends) {\r\n      if(rounds[_round].ticketCount == 0){\r\n        return 0;\r\n      }\r\n      totalDividends = rounds[_round].ticketsOwned[_ticketHolder].mul(rounds[_round].holderPool).div(rounds[_round].ticketCount);\r\n      totalDividends = totalDividends.sub(rounds[_round].reclaimed[_ticketHolder]);\r\n      return totalDividends;\r\n    }\r\n\r\n    /// Calculate total payout for a round\r\n    /// @param _round the round to claim\r\n    /// @param _ticketHolder the user to query\r\n    /// @dev calculates jackpot earnings, dividends and ticket reimbursment\r\n    /// @return totalClaim total claim\r\n    function calcPayout(uint256 _round, address _ticketHolder) public view returns(uint256 totalClaim, uint256 jackpot) {\r\n      if(rounds[_round].claimList[_ticketHolder] == 0){\r\n        return (0, 0);\r\n      }\r\n      totalClaim = calcDividends(_round, _ticketHolder);\r\n      uint256 percentageCount;\r\n      uint256 ticketLength = 51;\r\n      if(rounds[_round].userCount \u003c 51){\r\n        ticketLength = rounds[_round].userCount;\r\n      }\r\n      for(uint256 x = rounds[_round].userCount - ticketLength; x \u003c rounds[_round].userCount; x++){\r\n        if(rounds[_round].userRanks[x] == _ticketHolder){\r\n          percentageCount++;\r\n        }\r\n      }\r\n      jackpot = rounds[_round].jackpot.mul(percentageCount).div(100);\r\n      totalClaim += jackpot;\r\n      totalClaim += rounds[_round].claimList[_ticketHolder];\r\n      return (totalClaim, jackpot);\r\n    }\r\n\r\n    /// Claim total dividends and winnings earned for a round\r\n    /// @param _round the round to claim\r\n    /// @dev calculates payout and pays user\r\n    function claimPayout(uint256 _round) external {\r\n      require(rounds[_round].timer \u003c now, \"Round Not Ended!\");\r\n      require(rounds[_round].claimList[msg.sender] \u003e 0, \"You Have Already Claimed!\");\r\n\r\n      (uint256 payout, uint256 jackpot) = calcPayout(_round, msg.sender);\r\n\r\n      jackpotClaimed[_round] += jackpot;\r\n      MoondayToken.transfer(msg.sender, payout);\r\n\r\n      rounds[_round].claimList[msg.sender] = 0;\r\n\r\n      emit TicketClaimed(_round, msg.sender, payout);\r\n    }\r\n\r\n    /// Claim total dividends in the current round\r\n    /// @param _amount the amount to claim\r\n    /// @dev calculates payout and pays user\r\n    function claimDividends(uint256 _amount) external{\r\n      require(calcDividends(roundCount, msg.sender) \u003e= _amount, \"Insufficient Dividends Available!\");\r\n\r\n      rounds[roundCount].reclaimed[msg.sender] += _amount;\r\n      MoondayToken.transfer(msg.sender, _amount);\r\n\r\n      emit DividendClaimed(roundCount, msg.sender, _amount);\r\n    }\r\n\r\n    /// Buy a ticket with dividends\r\n    /// @dev purchases a ticket with dividends and distributes funds\r\n    /// @return ticket index\r\n    function reinvestDividends(uint256 _amount) external returns(uint256){\r\n      uint256 ticketPrice = calcTicketCost(_amount);\r\n      require(calcDividends(roundCount, msg.sender) \u003e= ticketPrice, \"Insufficient Dividends Available!\");\r\n      require(rounds[roundCount].timer \u003e now, \"Round Ended!\");\r\n\r\n      rounds[roundCount].jackpot += ticketPrice.div(10);\r\n      rounds[roundCount].holderPool += ticketPrice.div(10);\r\n      MoondayToken.transfer(moonGoldHodlWallet, ticketPrice.mul(9).div(100));\r\n      MoondayToken.transfer(_owner, ticketPrice.mul(9).div(100));\r\n      MoondayToken.transfer(_dev1, ticketPrice.div(100));\r\n      MoondayToken.transfer(_dev2, ticketPrice.div(100));\r\n\r\n      rounds[roundCount].reclaimed[msg.sender] += ticketPrice;\r\n      rounds[roundCount].ticketsOwned[msg.sender] += _amount;\r\n      rounds[roundCount].claimList[msg.sender] += ticketPrice.sub(ticketPrice.mul(41).div(100));\r\n      rounds[roundCount].userRanks[rounds[roundCount].userCount] = msg.sender;\r\n      rounds[roundCount].userCount++;\r\n      rounds[roundCount].ticketCount += _amount;\r\n\r\n      if(!killSwitch){\r\n        rounds[roundCount].timer += 4 * _amount;\r\n      }\r\n      emit TicketBought(msg.sender, rounds[roundCount].userCount, _amount);\r\n      return(rounds[roundCount].ticketCount);\r\n    }\r\n\r\n}\r\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.10;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003e 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}"}}