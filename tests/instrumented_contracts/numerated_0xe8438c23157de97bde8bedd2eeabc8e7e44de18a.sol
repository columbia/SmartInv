1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/Lunatics.sol": {
5       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.19;\r\n// by three they come\r\n// by three they go\r\n// and in between in fiery row\r\n// burn the white-robed ranks of woe\r\n// o/\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            _totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\ninterface IFactory{\r\n        function createPair(address tokenA, address tokenB) external returns (address pair);\r\n        function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\ninterface IRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    \r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;   \r\n}\r\ncontract RewardsTracker is Ownable {\r\n\r\n    mapping(address => uint256) public userShares;\r\n    mapping(address => int256) internal magnifiedDividendCorrections;\r\n    mapping(address => uint256) internal withdrawnDividends;\r\n    mapping(address => bool) public excludedFromDividends;\r\n    mapping(address => uint256) public lastClaimTime;\r\n    mapping(address => uint256) public elegibleUsersIndex;\r\n    mapping(address => bool ) public isElegible;\r\n\r\n    address[] elegibleUsers;\r\n\r\n    IRouter public rewardRouter;\r\n    address public rewardToken;\r\n\r\n    uint256 constant internal magnitude = 2**128;\r\n\r\n    uint256 internal magnifiedDividendPerShare;\r\n    uint256 public totalDividends;\r\n    uint256 public totalDividendsWithdrawn;\r\n    uint256 public totalShares;\r\n    uint256 public minBalanceForRewards;\r\n    uint256 public claimDelay;\r\n    uint256 public currentIndex;\r\n\r\n    event ExcludeFromDividends(address indexed account, bool value);\r\n    event Claim(address indexed account, uint256 amount);\r\n    event DividendWithdrawn(address indexed to, uint256 weiAmount);\r\n\r\n    constructor(address _router, address _rewardToken) {\r\n      rewardRouter = IRouter(_router);\r\n      rewardToken = _rewardToken;\r\n    }\r\n\r\n    function excludeFromDividends(address account, bool value) external onlyOwner {\r\n        require(excludedFromDividends[account] != value);\r\n        excludedFromDividends[account] = value;\r\n        if(value == true){\r\n          _setBalance(account, 0);\r\n        }\r\n        else{\r\n          _setBalance(account, userShares[account]);\r\n        }\r\n        emit ExcludeFromDividends(account, value);\r\n\r\n    }\r\n    \r\n    function _setRewardToken(address newToken) internal{\r\n      rewardToken = newToken;\r\n    }\r\n\r\n    function getAccount(address account) public view returns (uint256 withdrawableUserDividends, uint256 totalUserDividends, uint256 lastUserClaimTime, uint256 withdrawnUserDividends) {\r\n        withdrawableUserDividends = withdrawableDividendOf(account);\r\n        totalUserDividends = accumulativeDividendOf(account);\r\n        lastUserClaimTime = lastClaimTime[account];\r\n        withdrawnUserDividends = withdrawnDividends[account]; \r\n    }\r\n\r\n    function setBalance(address account, uint256 newBalance) internal {\r\n        if(excludedFromDividends[account]) {\r\n            return;\r\n        }   \r\n        _setBalance(account, newBalance);\r\n    }\r\n\r\n    function _setMinBalanceForRewards(uint256 newMinBalance) internal {\r\n        minBalanceForRewards = newMinBalance;\r\n    }\r\n\r\n    function autoDistribute(uint256 gasAvailable) public {\r\n      uint256 size = elegibleUsers.length;\r\n      if(size == 0) return;\r\n\r\n      uint256 gasSpent = 0;\r\n      uint256 gasLeft = gasleft();\r\n      uint256 lastIndex = currentIndex;\r\n      uint256 iterations = 0;\r\n\r\n      while(gasSpent < gasAvailable && iterations < size){\r\n        if(lastIndex >= size){\r\n          lastIndex = 0;\r\n        }\r\n        address account = elegibleUsers[lastIndex];\r\n        if(lastClaimTime[account] + claimDelay < block.timestamp){\r\n          _processAccount(account);\r\n        }\r\n        lastIndex++;\r\n        iterations++;\r\n        gasSpent += gasLeft - gasleft();\r\n        gasLeft = gasleft();\r\n      }\r\n\r\n      currentIndex = lastIndex;\r\n\r\n    }\r\n\r\n    function _processAccount(address account) internal returns(bool){\r\n        uint256 amount = _withdrawDividendOfUser(account);\r\n\r\n          if(amount > 0) {\r\n              lastClaimTime[account] = block.timestamp;\r\n              emit Claim(account, amount);\r\n              return true;\r\n          }\r\n          return false;\r\n    }\r\n\r\n    /* function distributeDividends() external payable {\r\n      if (msg.value > 0) {\r\n      _distributeDividends(msg.value);\r\n      }\r\n    } no need for erc20 tokens */\r\n\r\n    function _distributeDividends(uint256 amount) internal {\r\n      require(totalShares > 0,\"there are no shares\");\r\n      magnifiedDividendPerShare = magnifiedDividendPerShare + (amount * magnitude / totalShares);\r\n      totalDividends= totalDividends + amount;\r\n    }\r\n    \r\n    function _withdrawDividendOfUser(address user) internal returns (uint256) {\r\n      uint256 _withdrawableDividend = withdrawableDividendOf(user);\r\n      if (_withdrawableDividend > 0) {\r\n        withdrawnDividends[user] += _withdrawableDividend;\r\n        totalDividendsWithdrawn += _withdrawableDividend;\r\n        emit DividendWithdrawn(user, _withdrawableDividend);\r\n        (bool success) = swapEthForCustomToken(user, _withdrawableDividend);\r\n        if(!success) {\r\n          (bool secondSuccess,) = payable(user).call{value: _withdrawableDividend, gas: 3000}(\"\");\r\n          if(!secondSuccess) {\r\n            withdrawnDividends[user] -= _withdrawableDividend;\r\n            totalDividendsWithdrawn -= _withdrawableDividend;\r\n            return 0;\r\n          }       \r\n        }\r\n        return _withdrawableDividend;\r\n      }\r\n      return 0;\r\n    }\r\n\r\n    function swapEthForCustomToken(address user, uint256 amt) internal returns (bool) {\r\n      address[] memory path = new address[](2);\r\n      path[0] = rewardRouter.WETH();\r\n      path[1] = rewardToken;\r\n      \r\n      try rewardRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amt}(0, path, user, block.timestamp) {\r\n        return true;\r\n      } catch {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function dividendOf(address _owner) public view returns(uint256) {\r\n      return withdrawableDividendOf(_owner);\r\n    }\r\n\r\n    function withdrawableDividendOf(address _owner) public view returns(uint256) {\r\n      return accumulativeDividendOf(_owner) - withdrawnDividends[_owner];\r\n    }\r\n\r\n    function withdrawnDividendOf(address _owner) public view returns(uint256) {\r\n      return withdrawnDividends[_owner];\r\n    }\r\n\r\n    function accumulativeDividendOf(address _owner) public view returns(uint256) {\r\n      return uint256(int256(magnifiedDividendPerShare * userShares[_owner]) + magnifiedDividendCorrections[_owner]) / magnitude;\r\n    }\r\n\r\n    function addShares(address account, uint256 value) internal {\r\n      userShares[account] += value;\r\n      totalShares += value;\r\n\r\n      magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account] - int256(magnifiedDividendPerShare * value);\r\n    }\r\n\r\n    function removeShares(address account, uint256 value) internal {\r\n      userShares[account] -= value;\r\n      totalShares -= value;\r\n\r\n      magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account] + int256(magnifiedDividendPerShare * value);\r\n    }\r\n\r\n    function _setBalance(address account, uint256 newBalance) internal {\r\n      uint256 currentBalance = userShares[account];\r\n      if(currentBalance > 0) {\r\n        _processAccount(account);\r\n      }\r\n      if(newBalance < minBalanceForRewards && isElegible[account]){\r\n        isElegible[account] = false;\r\n        elegibleUsers[elegibleUsersIndex[account]] = elegibleUsers[elegibleUsers.length - 1];\r\n        elegibleUsersIndex[elegibleUsers[elegibleUsers.length - 1]] = elegibleUsersIndex[account];\r\n        elegibleUsers.pop();\r\n        removeShares(account, currentBalance);\r\n      }\r\n      else{\r\n        if(userShares[account] == 0){\r\n          isElegible[account] = true;\r\n          elegibleUsersIndex[account] = elegibleUsers.length;\r\n          elegibleUsers.push(account);\r\n        }\r\n        if(newBalance > currentBalance) {\r\n          uint256 mintAmount = newBalance - currentBalance;\r\n          addShares(account, mintAmount);\r\n        } else if(newBalance < currentBalance) {\r\n          uint256 burnAmount = currentBalance - newBalance;\r\n          removeShares(account, burnAmount);\r\n        }\r\n      }\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, 'Address: insufficient balance');\r\n\r\n        (bool success, ) = recipient.call{value: amount}('');\r\n        require(success, 'Address: unable to send value, recipient may have reverted');\r\n    }\r\n}\r\n\r\ncontract Lunatics is ERC20, Ownable, RewardsTracker {\r\n    using Address for address payable;\r\n    //custom\r\n    IRouter public router;\r\n    //address\r\n    address public pair;\r\n    //bool\r\n    bool public swapAndLiquifyEnabled = true;\r\n    bool public limitSells = true;\r\n    bool public limitBuys = true;\r\n    bool public feeStatus = true;\r\n    bool public buyFeeStatus = true;\r\n    bool public sellFeeStatus = true;\r\n    bool public blockMultiBuys = true;\r\n    bool public marketActive;\r\n    bool private isInternalTransaction;\r\n    //uint\r\n    uint public gasLimit = 300_000;\r\n    uint public minimumTokensBeforeSwap;\r\n    uint public tokensToSwap;\r\n    uint public intervalSecondsForSwap = 30;\r\n    uint public minimumWeiForTokenomics = 1 * 10**17; // 0.1 ETH\r\n    uint public maxBuyTxAmount;\r\n    uint public maxSellTxAmount;\r\n    uint private startTimeForSwap;\r\n    uint private marketActiveAt;\r\n\r\n    //struct\r\n    struct userData {\r\n        uint lastBuyTime;\r\n    }\r\n    struct Fees {\r\n        uint64 rewards;\r\n        uint64 marketing;\r\n        uint64 buyback;\r\n    }\r\n    struct FeesAddress {\r\n        address marketing;\r\n        address buyback;\r\n    }\r\n    FeesAddress public feesAddress = FeesAddress(\r\n        0x2d00FB5E5890EBF1B270fa4009E19052305F8074,\r\n        0x8A52164f5612f0Cd075b8d5eA4a6b22d67335734\r\n    );\r\n    Fees public buyFees = Fees(3, 3, 2);\r\n    Fees public sellFees = Fees(3, 3, 2);\r\n\r\n    uint256 public totalBuyFee = 8;\r\n    uint256 public totalSellFee = 8;\r\n\r\n    //mapping\r\n    mapping (address => bool) public premarketUser;\r\n    mapping (address => bool) public excludedFromFees;\r\n    mapping (address => userData) public userLastTradeData;\r\n    mapping(address => bool) public isPair;\r\n    event ContractSwap(uint256 date, uint256 amount);\r\n\r\n    event PremarketUserChanged(bool status, address indexed user);\r\n    event ExcludeFromFeesChanged(bool status, address indexed user);\r\n    event MarketingFeeCollected(uint amount);\r\n    event BuybackFeeCollected(uint amount);\r\n\r\n    event FeesStatusChanged(bool feesActive, bool buy, bool sell);\r\n    event SwapSystemChanged(bool status, uint256 intervalSecondsToWait, uint256 minimumToSwap, uint256 tokensToSwap);\r\n\r\n    event MaxSellChanged(uint256 amount);\r\n    event MaxBuyChanged(uint256 amount);\r\n    event BlockMultiBuysChange(bool status);\r\n    event LimitSellChanged(bool status);\r\n    event LimitBuyChanged(bool status);\r\n    event MarketStatusChanged(bool status, uint256 date);\r\n    event TokenRemovedFromContract(address indexed tokenAddress, uint256 amount);\r\n    event PairUpdated(address indexed pair);\r\n    event RouterUpdated(address indexed router);\r\n    event ExcludeFromFees(address indexed account, bool isExcluded);\r\n    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\r\n    event GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);\r\n    event SendDividends(uint256 tokensSwapped, uint256 amount);\r\n    event ProcessedDividendTracker(\r\n        uint256 iterations,\r\n        uint256 claims,\r\n        uint256 lastProcessedIndex,\r\n        bool indexed automatic,\r\n        uint256 gas,\r\n        address indexed processor\r\n    );\r\n\r\n    constructor(address _router, address _rewardToken) ERC20('Lunatics', 'LunaT') RewardsTracker(_router, _rewardToken) {\r\n        router = IRouter(_router);\r\n        pair = IFactory(router.factory()).createPair(address(this), router.WETH());\r\n        uint _totalSupply = 100_000_000_000 * (10**9);\r\n\r\n        maxSellTxAmount = _totalSupply / 100; // 1% supply\r\n        maxBuyTxAmount = _totalSupply / 100; // 1% supply\r\n        minimumTokensBeforeSwap = _totalSupply / 10000; //0.01% supply\r\n        tokensToSwap = _totalSupply / 10000; //0.01% supply\r\n        minBalanceForRewards = 500_000 * 10 ** 9; // 500k\r\n        claimDelay = 60*60; // 1 hour\r\n\r\n        // exclude from receiving dividends\r\n        excludedFromDividends[address(this)] = true;\r\n        excludedFromDividends[owner()] = true;\r\n        excludedFromDividends[address(0xdead)] = true;\r\n        excludedFromDividends[address(_router)] = true;\r\n        excludedFromDividends[address(pair)] = true;\r\n\r\n        // exclude from paying fees or having max transaction amount\r\n        excludedFromFees[owner()] = true;\r\n        excludedFromFees[address(this)] = true;\r\n        excludedFromFees[feesAddress.marketing] = true;\r\n        excludedFromFees[feesAddress.buyback] = true;\r\n\r\n        premarketUser[owner()] = true;\r\n        isPair[pair] = true;\r\n\r\n        // _mint is an internal function in ERC20.sol that is only called here,\r\n        // and CANNOT be called ever again\r\n        _mint(owner(), _totalSupply);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function decimals() public pure override returns(uint8) {\r\n        return 9;\r\n    }\r\n\r\n    /// @notice Manual claim the dividends\r\n    function claim() external {\r\n        super._processAccount(payable(msg.sender));\r\n    }\r\n\r\n    // to take leftover(tokens) from contract\r\n    function transferToken(address _token, address _to, uint _value) external onlyOwner returns(bool _sent){\r\n        if(_value == 0) {\r\n            _value = IERC20(_token).balanceOf(address(this));\r\n        } \r\n        _sent = IERC20(_token).transfer(_to, _value);\r\n        emit TokenRemovedFromContract(_token, _value);\r\n    }\r\n\r\n    function transferETH() external onlyOwner {\r\n        uint256 ETHbalance = address(this).balance;\r\n        payable(owner()).sendValue(ETHbalance);\r\n    }\r\n    //switch functions\r\n    function switchMarketActive(bool _state) external onlyOwner {\r\n        //once marketActive is set to true, cannot be set back to false\r\n        require(marketActive == false, \"Cannot stop trade once is open\");\r\n        marketActive = _state;\r\n        if(_state) {\r\n            marketActiveAt = block.timestamp;\r\n        }\r\n        emit MarketStatusChanged(_state, block.timestamp);\r\n    }\r\n    function switchLimitSells(bool _state) external onlyOwner {\r\n        limitSells = _state;\r\n        emit LimitSellChanged(_state);\r\n    }\r\n    function updateRouter(address newRouter, bool _createPair) external onlyOwner {\r\n        router = IRouter(newRouter);\r\n        if(_createPair) {\r\n            address _pair = IFactory(router.factory())\r\n                .createPair(address(this), router.WETH());\r\n            pair = _pair;\r\n            emit PairUpdated(pair);\r\n        } else {\r\n            router = IRouter(newRouter);\r\n        }\r\n        emit RouterUpdated(newRouter);\r\n    }\r\n\r\n    function setBlockMultiBuys(bool _status) external onlyOwner {\r\n        blockMultiBuys = _status;\r\n        emit BlockMultiBuysChange(_status);\r\n    }\r\n\r\n    function switchLimitBuys(bool _state) external onlyOwner {\r\n        limitBuys = _state;\r\n        emit LimitBuyChanged(_state);\r\n    }\r\n\r\n    function setMaxSellTxAmount(uint _value) external onlyOwner {\r\n        maxSellTxAmount = _value*10**decimals();\r\n        require(maxSellTxAmount >= totalSupply() / 1000,\"maxSellTxAmount should be at least 0.1% of total supply.\");\r\n        emit MaxSellChanged(_value);\r\n    }\r\n\r\n    function setMaxBuyTxAmount(uint _value) external onlyOwner {\r\n        maxBuyTxAmount = _value*10**decimals();\r\n        require(maxBuyTxAmount >= totalSupply() / 1000,\"maxBuyTxAmount should be at least 0.1% of total supply.\");\r\n        emit MaxBuyChanged(maxBuyTxAmount);\r\n    }\r\n    \r\n    function setFeeStatus(bool buy, bool sell, bool _state) external onlyOwner {\r\n        feeStatus = _state;\r\n        buyFeeStatus = buy;\r\n        sellFeeStatus = sell;\r\n        emit FeesStatusChanged(_state,buy,sell);\r\n    }\r\n    \r\n    function setSwapAndLiquify(bool _state, uint _intervalSecondsForSwap, uint _minimumTokensBeforeSwap, uint _tokensToSwap) external onlyOwner {\r\n        swapAndLiquifyEnabled = _state;\r\n        intervalSecondsForSwap = _intervalSecondsForSwap;\r\n        minimumTokensBeforeSwap = _minimumTokensBeforeSwap*10**decimals();\r\n        tokensToSwap = _tokensToSwap*10**decimals();\r\n        require(minimumTokensBeforeSwap > 1000000000, \"More than one token required\"); \r\n        require(tokensToSwap > 1000000000, \"More than one token required\");\r\n        require(tokensToSwap <= minimumTokensBeforeSwap,\"You cannot swap more then the minimum amount\");\r\n        require(tokensToSwap <= totalSupply() / 1000,\"token to swap limited to 0.1% supply\");\r\n        emit SwapSystemChanged(_state,_intervalSecondsForSwap,_minimumTokensBeforeSwap,_tokensToSwap);\r\n    }\r\n    // mappings functions\r\n    function setPremarketUser(address _target, bool _status) external onlyOwner {\r\n        premarketUser[_target] = _status;\r\n        emit PremarketUserChanged(_status,_target);\r\n    }\r\n    function KKMigration(address[] memory _address, uint256[] memory _amount) external onlyOwner {\r\n        for(uint i=0; i< _amount.length; i++){\r\n            address adr = _address[i];\r\n            uint amnt = _amount[i] *10**decimals();\r\n            super._transfer(owner(), adr, amnt);\r\n        }\r\n        // events from ERC20\r\n    }\r\n\r\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\r\n        excludedFromFees[account] = excluded;\r\n\r\n        emit ExcludeFromFees(account, excluded);\r\n    }\r\n\r\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {\r\n        for (uint256 i = 0; i < accounts.length; i++) {\r\n            excludedFromFees[accounts[i]] = excluded;\r\n        }\r\n        emit ExcludeMultipleAccountsFromFees(accounts, excluded);\r\n    }\r\n\r\n    function setRewardToken(address newToken) external onlyOwner {\r\n        super._setRewardToken(newToken);\r\n    }\r\n\r\n    function setMarketingWallet(address newWallet) external onlyOwner {\r\n        feesAddress.marketing = newWallet;\r\n    }\r\n\r\n    function setBuybackWallet(address newWallet) external onlyOwner {\r\n        feesAddress.buyback = newWallet;\r\n    }\r\n\r\n    function setClaimDelay(uint256 amountInSeconds) external onlyOwner {\r\n        claimDelay = amountInSeconds;\r\n    }\r\n\r\n    function setBuyTaxes(\r\n        uint64 _rewards,\r\n        uint64 _marketing,\r\n        uint64 _buyback\r\n    ) external onlyOwner {\r\n        totalBuyFee = _rewards + _marketing + _buyback;\r\n        require(totalBuyFee <= 15, \"Total buy fees cannot be more than 15%\");\r\n        buyFees = Fees(_rewards, _marketing, _buyback);\r\n    }\r\n\r\n    function setSellTaxes(\r\n        uint64 _rewards,\r\n        uint64 _marketing,\r\n        uint64 _buyback\r\n    ) external onlyOwner {\r\n        totalSellFee = _rewards + _marketing + _buyback;\r\n        require(totalSellFee <= 15, \"Total sell fees cannot be more than 15%\");\r\n        sellFees = Fees(_rewards, _marketing, _buyback);\r\n    }\r\n\r\n    function setGasLimit(uint256 newGasLimit) external onlyOwner {\r\n        gasLimit = newGasLimit;\r\n    }\r\n\r\n    function setMinBalanceForRewards(uint256 minBalance) external onlyOwner {\r\n        minBalanceForRewards = minBalance;\r\n    }\r\n\r\n    function setPair(address newPair, bool value) external onlyOwner {\r\n        isPair[newPair] = value;\r\n\r\n        if (value) {\r\n            excludedFromDividends[newPair] = true;\r\n        }\r\n    }\r\n\r\n    function swapTokensForEth(uint256 tokenAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n        _approve(address(this), address(router), tokenAmount);\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        emit ContractSwap(block.timestamp, tokenAmount);\r\n    }\r\n    function swapTokens(uint256 contractTokenBalance) private {\r\n        isInternalTransaction = true;\r\n        swapTokensForEth(contractTokenBalance);\r\n        isInternalTransaction = false;\r\n    }\r\n    ////////////////////////\r\n    // Transfer Functions //\r\n    ////////////////////////\r\n\r\n    function _transfer(address from, address to, uint256 amount) internal override {\r\n        uint trade_type = 0;\r\n    // market status flag\r\n        if(!marketActive) {\r\n            require(premarketUser[from],\"cannot trade before the market opening\");\r\n        }\r\n    // normal transaction\r\n        if(!isInternalTransaction) {\r\n        // tx limits\r\n            //buy\r\n            if(isPair[from]) {\r\n                trade_type = 1;\r\n                // limits\r\n                if(!excludedFromFees[to]) {\r\n                    // tx limit\r\n                    if(limitBuys) {\r\n                        require(amount <= maxBuyTxAmount, \"maxBuyTxAmount Limit Exceeded\");\r\n                        // multi-buy limit\r\n                        if(blockMultiBuys) {\r\n                            require(marketActiveAt + 7 < block.timestamp,\"You cannot buy at launch.\");\r\n                            require(userLastTradeData[tx.origin].lastBuyTime + 3 <= block.timestamp,\"You cannot do multi-buy orders.\");\r\n                            userLastTradeData[tx.origin].lastBuyTime = block.timestamp;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            //sell\r\n            else if(isPair[to]) {\r\n                trade_type = 2;\r\n                bool overMinimumTokenBalance = balanceOf(address(this)) >= minimumTokensBeforeSwap;\r\n                // marketing auto-eth // if the swap is enabled and there are tokens in pool\r\n                if (swapAndLiquifyEnabled && balanceOf(pair) > 0 && overMinimumTokenBalance &&\r\n                    startTimeForSwap + intervalSecondsForSwap <= block.timestamp) {\r\n                    // if contract has X tokens, not sold since Y time, sell Z tokens\r\n                    startTimeForSwap = block.timestamp;\r\n                    // sell to eth\r\n                    swapTokens(tokensToSwap);\r\n                }\r\n                \r\n                // limits\r\n                if(!excludedFromFees[from]) {\r\n                    // tx limit\r\n                    if(limitSells) {\r\n                    require(amount <= maxSellTxAmount, \"maxSellTxAmount Limit Exceeded\");\r\n                    }\r\n                }\r\n            }\r\n            // fees redistribution\r\n            if(address(this).balance > minimumWeiForTokenomics) {\r\n                //marketing\r\n                uint256 caBalance = address(this).balance;\r\n                uint256 marketingTokens = caBalance * sellFees.marketing / totalSellFee;\r\n                (bool success,) = address(feesAddress.marketing).call{value: marketingTokens}(\"\");\r\n                if(success) {\r\n                    emit MarketingFeeCollected(marketingTokens);\r\n                }\r\n                \r\n                //buyback\r\n                uint256 buybackTokens = caBalance * sellFees.buyback / totalSellFee;\r\n                (bool success1,) = address(feesAddress.buyback).call{value: buybackTokens}(\"\");\r\n                if(success1) {\r\n                    emit BuybackFeeCollected(buybackTokens);\r\n                }\r\n                //rewards\r\n                uint256 dividends = caBalance * sellFees.rewards / totalSellFee;\r\n                super._distributeDividends(dividends);\r\n                super.autoDistribute(gasLimit);\r\n            }\r\n        // fees management\r\n            if(feeStatus) {\r\n                // buy\r\n                if(trade_type == 1 && buyFeeStatus && !excludedFromFees[to]) {\r\n                \tuint txFees = amount * totalBuyFee / 100;\r\n                \tamount -= txFees;\r\n                    super._transfer(from, address(this), txFees);\r\n                }\r\n                //sell\r\n                if(trade_type == 2 && sellFeeStatus && !excludedFromFees[from]) {\r\n                \tuint txFees = amount * totalSellFee / 100;\r\n                \tamount -= txFees;\r\n                    super._transfer(from, address(this), txFees);\r\n                }\r\n                // no wallet to wallet tax\r\n            }\r\n        }\r\n        // transfer tokens\r\n        super._transfer(from, to, amount);\r\n        super.setBalance(from, balanceOf(from));\r\n        super.setBalance(to, balanceOf(to));\r\n        \r\n    }\r\n}"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": true,
11       "runs": 200
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "devdoc",
19           "userdoc",
20           "metadata",
21           "abi"
22         ]
23       }
24     },
25     "libraries": {}
26   }
27 }}