1 {"StakingforNFT.sol":{"content":"pragma solidity ^0.5.16;\n\nimport \"./StakingHelpersNFT.sol\";\n\n\ncontract StakingForNFT is IStakingForNFT, RewardsDistributionRecipient, ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC20 public rewardsToken1;\n    IERC20 public rewardsToken2;\n    IERC20 public rewardsToken3;\n\n    IERC20 public stakingToken;\n    IERC20 public stakingTokenMultiplier;\n\n    uint256 public periodFinish = 0;\n    uint256 public locktime = 2 days;\n    \n    uint256 public rewardRate1 = 0;\n    uint256 public rewardRate2 = 0;\n    uint256 public rewardRate3 = 0;\n\n    uint256 public rewardsDuration = 30 days;//2 weeks\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerToken1Stored;\n    uint256 public rewardPerToken2Stored;\n    uint256 public rewardPerToken3Stored;\n\n    mapping(address =\u003e uint256) public userRewardPerToken1Paid;\n    mapping(address =\u003e uint256) public userRewardPerToken2Paid;\n    mapping(address =\u003e uint256) public userRewardPerToken3Paid;\n\n    mapping(address =\u003e uint256) public rewards1;\n    mapping(address =\u003e uint256) public rewards2;\n    mapping(address =\u003e uint256) public rewards3;\n\n    uint256 private _totalSupply;\n    uint256 private _totalSupplyMultiplier;\n    mapping(address =\u003e uint256) private _balances;\n    mapping(address =\u003e uint256) private _balancesMultiplier;\n    \n    mapping(address =\u003e uint256) public lockingPeriodMultiplier;\n    mapping(address =\u003e uint256) public multiplierFactor;\n\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        address _rewardsDistribution,\n        address _rewardsToken1,\n        address _rewardsToken2,\n        address _rewardsToken3,\n        address _stakingToken,\n        address _stakingTokenMultiplier\n    ) public Owned(_owner) {\n        rewardsToken1 = IERC20(_rewardsToken1);\n        rewardsToken2 = IERC20(_rewardsToken2);\n        rewardsToken3 = IERC20(_rewardsToken3);\n        stakingToken = IERC20(_stakingToken);\n        stakingTokenMultiplier = IERC20(_stakingTokenMultiplier);\n        rewardsDistribution = _rewardsDistribution;\n    }\n\n    /* ========== VIEWS ========== */\n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function totalSupplyMultiplier() external view returns (uint256) {\n        return _totalSupplyMultiplier;\n    }\n\n    function balanceOfMultiplier(address account) external view returns (uint256) {\n        return _balancesMultiplier[account];\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken1() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerToken1Stored;\n        }\n        return\n            rewardPerToken1Stored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate1).mul(1e18).div(_totalSupply)\n            );\n    }\n    \n    function rewardPerToken2() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerToken2Stored;\n        }\n        return\n            rewardPerToken2Stored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate2).mul(1e18).div(_totalSupply)\n            );\n    }\n    \n    function rewardPerToken3() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerToken3Stored;\n        }\n        return\n            rewardPerToken3Stored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate3).mul(1e18).div(_totalSupply)\n            );\n    }\n    \n    function getMultiplyingFactor(address account) public view returns (uint256) {\n        if (multiplierFactor[account] == 0) {\n            return 1e18;\n        }\n        return\n            multiplierFactor[account];\n    }\n\n    function earnedtoken1(address account) public view returns (uint256) {\n        return _balances[account].mul(rewardPerToken1().sub(userRewardPerToken1Paid[account])).mul(getMultiplyingFactor(account))\n        .div(1e18).div(1e18).add(rewards1[account]);\n    }\n    \n    function earnedtoken2(address account) public view returns (uint256) {\n        return _balances[account].mul(rewardPerToken2().sub(userRewardPerToken2Paid[account])).mul(getMultiplyingFactor(account))\n        .div(1e18).div(1e18).add(rewards2[account]);\n    }\n    \n    function earnedtoken3(address account) public view returns (uint256) {\n        return _balances[account].mul(rewardPerToken3().sub(userRewardPerToken3Paid[account])).mul(getMultiplyingFactor(account))\n        .div(1e18).div(1e18).add(rewards3[account]);\n    }\n\n    function getReward1ForDuration() external view returns (uint256) {\n        return rewardRate1.mul(rewardsDuration);\n    }\n\n    function getReward2ForDuration() external view returns (uint256) {\n        return rewardRate2.mul(rewardsDuration);\n    }\n\n    function getReward3ForDuration() external view returns (uint256) {\n        return rewardRate3.mul(rewardsDuration);\n    }\n\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function stake(uint256 amount) external nonReentrant notPaused updateReward(msg.sender) {\n        require(amount \u003e 0, \"Cannot stake 0\");\n        \n        //NOTE: SERGS contract has 2.5% fees....\n        uint256 feeamount=amount.div(40);\n        uint256 remamount=amount.sub(feeamount);\n\n        _totalSupply = _totalSupply.add(remamount);\n        _balances[msg.sender] = _balances[msg.sender].add(remamount);\n        \n        // SERGS contract will send balance cutting 2.5% fees\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function stakeMultiplier(uint256 amount) external nonReentrant notPaused getTotalMultiplier(msg.sender, amount){\n        require(amount \u003e 0, \"Cannot stake 0\");\n        lockingPeriodMultiplier[msg.sender]= block.timestamp.add(locktime);\n\n        _totalSupplyMultiplier = _totalSupplyMultiplier.add(amount);\n        _balancesMultiplier[msg.sender] = _balancesMultiplier[msg.sender].add(amount);\n        stakingTokenMultiplier.safeTransferFrom(msg.sender, address(this), amount);\n        emit StakedMultiplier(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) public nonReentrant updateReward(msg.sender) {\n        require(amount \u003e 0, \"Cannot withdraw 0\");\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function withdrawMultiplier(uint256 amount) public nonReentrant {\n        require(amount \u003e 0, \"Cannot withdraw 0\");\n        require(block.timestamp \u003e= lockingPeriodMultiplier[msg.sender], \"Transaction hasn\u0027t surpassed time lock.\");\n\n        _totalSupplyMultiplier = _totalSupplyMultiplier.sub(amount);\n        _balancesMultiplier[msg.sender] = _balancesMultiplier[msg.sender].sub(amount);\n        stakingTokenMultiplier.safeTransfer(msg.sender, amount);\n        emit WithdrawnMultiplier(msg.sender, amount);\n    }\n\n    function getReward() public payable nonReentrant updateReward(msg.sender) {\n        uint256 reward1 = rewards1[msg.sender];\n        uint256 reward2 = rewards2[msg.sender];\n        uint256 reward3 = rewards3[msg.sender];\n        \n        if (reward1 \u003e 0) {\n            // mint tokens to be used for farming\n            rewardsToken1.mintToFarm(reward1);\n            rewards1[msg.sender] = 0;\n            rewardsToken1.safeTransfer(msg.sender, reward1);\n        }\n        if (reward2 \u003e 0) {\n            // mint tokens to be used for farming\n            rewardsToken2.mintToFarm(reward2);\n            rewards2[msg.sender] = 0;\n            rewardsToken2.safeTransfer(msg.sender, reward2);\n        }\n        if (reward3 \u003e 0) {\n            // mint tokens to be used for farming\n            rewardsToken3.mintToFarm(reward3);\n            rewards3[msg.sender] = 0;\n            rewardsToken3.safeTransfer(msg.sender, reward3);\n        }\n        emit RewardPaid(msg.sender, reward1, reward2, reward3);\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        withdrawMultiplier(_balancesMultiplier[msg.sender]);\n        getReward();\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    //YOU\u003eJUST\u003eWIN\n    function notifyRewardAmount(uint256 reward1, uint256 reward2, uint256 reward3) external onlyRewardsDistribution updateReward(address(0)) {\n        if (block.timestamp \u003e= periodFinish) {\n            rewardRate1 = reward1.div(rewardsDuration);\n            rewardRate2 = reward2.div(rewardsDuration);\n            rewardRate3 = reward3.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover1 = remaining.mul(rewardRate1);\n            rewardRate1 = reward1.add(leftover1).div(rewardsDuration);\n            uint256 leftover2 = remaining.mul(rewardRate2);\n            rewardRate2 = reward2.add(leftover2).div(rewardsDuration);\n            uint256 leftover3 = remaining.mul(rewardRate3);\n            rewardRate3 = reward3.add(leftover3).div(rewardsDuration);\n        }\n        \n        \n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        // uint balance1 = reward1;//rewardsToken.balanceOf(address(this));\n        // require(rewardRate1 \u003c= reward1.div(rewardsDuration), \"Provided reward too high\");\n\n        // // uint balance2 = reward2;//rewardsToken.balanceOf(address(this));\n        // require(rewardRate2 \u003c= reward2.div(rewardsDuration), \"Provided reward too high\");\n\n        // // uint balance3 = reward3;//rewardsToken.balanceOf(address(this));\n        // require(rewardRate3 \u003c= reward3.div(rewardsDuration), \"Provided reward too high\");\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(rewardsDuration);\n    }\n\n    // // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        // // If it\u0027s SNX we have to query the token symbol to ensure its not a proxy or underlying\n        // bool isSNX = (keccak256(bytes(\"SNX\")) == keccak256(bytes(ERC20Detailed(tokenAddress).symbol())));\n        // // Cannot recover the staking token or the rewards token\n        // require(\n        //     tokenAddress != address(stakingToken) \u0026\u0026 tokenAddress != address(rewardsToken) \u0026\u0026 !isSNX,\n        //     \"Cannot withdraw the staking or rewards tokens\"\n        // );\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(block.timestamp \u003e periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n    \n        /* ========== MODIFIERS ========== */\n\n\n     modifier getTotalMultiplier(address account, uint256 balance) {\n        uint256 multiplier=0;\n        if(balance\u003e0 \u0026\u0026 balance \u003c= 5*10 ** 18) {\n            multiplier = balance.mul(10).div(100);\n        }\n        else if(balance\u003e5*10 ** 18){\n            multiplier = 5*10**17;\n        }\n         uint256 multiplyFactor = multiplier.add(1*10**18);\n         multiplierFactor[msg.sender]=multiplyFactor;\n        _;\n    }\n\n    \n\n    modifier updateReward(address account) {\n        rewardPerToken1Stored = rewardPerToken1();\n        rewardPerToken2Stored = rewardPerToken2();\n        rewardPerToken3Stored = rewardPerToken3();\n\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards1[account] = earnedtoken1(account);\n            userRewardPerToken1Paid[account] = rewardPerToken1Stored;\n            rewards2[account] = earnedtoken2(account);\n            userRewardPerToken2Paid[account] = rewardPerToken2Stored;\n            rewards3[account] = earnedtoken3(account);\n            userRewardPerToken3Paid[account] = rewardPerToken3Stored;\n        }\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event StakedMultiplier(address indexed user, uint256 amount);\n    \n    event Withdrawn(address indexed user, uint256 amount);\n    event WithdrawnMultiplier(address indexed user, uint256 amount);\n\n    event RewardPaid(address indexed user, uint256 reward1, uint256 reward2, uint256 reward3);\n\n    event RewardsDurationUpdated(uint256 newDuration);\n    event Recovered(address token, uint256 amount);\n}\n\n\n\n"},"StakingHelpersNFT.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2020-07-18\n*/\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: YFIRewards.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\n// File: @openzeppelin/contracts/math/Math.sol\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\n \nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: @openzeppelin/contracts/GSN/Context.sol\n\npragma solidity ^0.5.16;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\n     /**\n     * @dev added to mint YOU tokens directly from staking contract\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n  \n    function mintToFarm(uint256 amount) external payable returns (bool);\n    \n     /**\n     to burn YOU, JUST or WIN tokens by this contract\n     */\n    \n    function burnToFarm(address account, uint256 amount)external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    \n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract\u0027s constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 \u0026\u0026 codehash != accountHash);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * \u003e Note that this information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * `IERC20.balanceOf` and `IERC20.transfer`.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\n\npragma solidity ^0.5.16;\n\n\n\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length \u003e 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n\npragma solidity ^0.5.16;\n\n\n// https://docs.synthetix.io/contracts/Owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\npragma solidity ^0.5.16;\n\n// https://docs.synthetix.io/contracts/Pausable\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    constructor() internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we\u0027re actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\n * available, which can be aplied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n\n// File: contracts/IRewardDistributionRecipient.sol\n\npragma solidity ^0.5.16;\n\n\n\ncontract IRewardDistributionRecipient is Ownable {\n    address rewardDistribution;\n\n    function notifyRewardAmount(uint256 reward) external;\n\n    modifier onlyRewardDistribution() {\n        require(_msgSender() == rewardDistribution, \"Caller is not reward distribution\");\n        _;\n    }\n\n    function setRewardDistribution(address _rewardDistribution)\n        external\n        onlyOwner\n    {\n        rewardDistribution = _rewardDistribution;\n    }\n}\n\n\npragma solidity ^0.5.16;\n\n\n// https://docs.synthetix.io/contracts/RewardsDistributionRecipient\ncontract RewardsDistributionRecipient is Owned {\n    address public rewardsDistribution;\n\n    function notifyRewardAmount(uint256 reward1,uint256 reward2,uint256 reward3) external;\n\n    modifier onlyRewardsDistribution() {\n        require(msg.sender == rewardsDistribution, \"Caller is not RewardsDistribution contract\");\n        _;\n    }\n\n    function setRewardsDistribution(address _rewardsDistribution) external onlyOwner {\n        rewardsDistribution = _rewardsDistribution;\n    }\n}\n\n\n\n\n\npragma solidity ^0.5.16;\n\n\ninterface IStakingForNFT {\n    // Views\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function rewardPerToken1() external view returns (uint256);\n\n    function rewardPerToken2() external view returns (uint256);\n\n    function rewardPerToken3() external view returns (uint256);\n\n    function earnedtoken1(address account) external view returns (uint256);\n\n    function earnedtoken2(address account) external view returns (uint256);\n\n    function earnedtoken3(address account) external view returns (uint256);\n\n    function getReward1ForDuration() external view returns (uint256);\n\n    function getReward2ForDuration() external view returns (uint256);\n\n    function getReward3ForDuration() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function totalSupplyMultiplier() external view returns (uint256);\n\n    function balanceOfMultiplier(address account) external view returns (uint256);\n\n    // Mutative\n\n    function stake(uint256 amount) external;\n\n    function stakeMultiplier(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n\n    function withdrawMultiplier(uint256 amount) external;\n\n    function getReward() payable external;\n\n    function exit() external;\n    \n    function notifyRewardAmount(uint256 reward1, uint256 reward2, uint256 reward3) external;\n\n}\n\n// \n\n"}}