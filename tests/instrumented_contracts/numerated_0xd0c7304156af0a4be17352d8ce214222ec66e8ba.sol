1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/VaultHandlerV7a.sol": {
5       "content": "/**\n *Submitted for verification at Etherscan.io on 2021-07-14\n*/\n\n// ___________      ___.   .__                                          \n// \\_   _____/ _____\\_ |__ |  |   ____   _____                          \n//  |    __)_ /     \\| __ \\|  | _/ __ \\ /     \\                         \n//  |        \\  Y Y  \\ \\_\\ \\  |_\\  ___/|  Y Y  \\                        \n// /_______  /__|_|  /___  /____/\\___  >__|_|  /                        \n//         \\/      \\/    \\/          \\/      \\/                         \n//     ____   ____            .__   __                                  \n//     \\   \\ /   /____   __ __|  |_/  |_                                \n//      \\   Y   /\\__  \\ |  |  \\  |\\   __\\                               \n//       \\     /  / __ \\|  |  /  |_|  |                                 \n//       \\___/  (____  /____/|____/__|                                 \n//                   \\/                                                \n//   ___ ___                    .___.__                          _________ a\n//  /   |   \\_____    ____    __| _/|  |   ___________  ___  __ |  ____  /\n// /    ~    \\__  \\  /    \\  / __ | |  | _/ __ \\_  __ \\ \\  \\/   /    / /\n// \\    Y    // __ \\|   |  \\/ /_/ | |  |_\\  ___/|  | \\/  \\    /    / /\n//  \\___|_  /(____  /___|  /\\____ | |____/\\___  >__|      \\_/    /_/\n//       \\/      \\/     \\/      \\/           \\/                     \n\n  \n// File: browser/ReentrancyGuard.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n// File: browser/IERC20Token.sol\n\npragma solidity ^0.8.4;\ninterface IERC20Token {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n// File: browser/SafeMath.sol\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n// File: browser/VaultHandler_v4.sol\npragma solidity ^0.8.4;\n\ninterface IClaimed {\n    function isClaimed(address nftAddress, uint tokenId, bytes32[] calldata proof) external returns(bool);\n    function claim(address nftAddress, uint tokenId, address _claimedBy) external;\n}\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.4;\n\n\ninterface IERC721 {\n    function burn(uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function mint( address _to, uint256 _tokenId, string calldata _uri, string calldata _payload) external;\n    function changeName(string calldata name, string calldata symbol) external;\n    function updateTokenUri(uint256 _tokenId,string memory _uri) external;\n    function tokenPayload(uint256 _tokenId) external view returns (string memory);\n    function ownerOf(uint256 _tokenId) external returns (address _owner);\n    function getApproved(uint256 _tokenId) external returns (address);\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n}\n\ninterface Ownable {\n    function transferOwnership(address newOwner) external;\n}\n\ninterface BasicERC20 {\n    function burn(uint256 value) external;\n    function mint(address account, uint256 amount) external;\n    function decimals() external view returns (uint8);\n}\n\ncontract Context {\n    constructor() {}\n\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return payable(msg.sender);\n    }\n}\n\n\ncontract Bridged is Context {\n    using SafeMath for uint256;\n    using SafeMath for uint8;\n    using SafeMath for uint;\n\n    address public paymentAddress;\n    \n    mapping(uint => bool) public chainIds;\n    mapping(uint => uint256) public chainBalances;\n    \n    constructor () {\n        chainIds[1] = true;\n        chainBalances[1] = 200000000000000000;\n        chainIds[137] = true;\n        chainBalances[137] = 200000000000000000;\n        chainIds[80001] = true;\n        chainBalances[80001] = 200000000000000000;\n        chainIds[100] = true;\n        chainBalances[100] = 200000000000000000;\n        chainIds[56] = true;\n        chainBalances[56] = 200000000000000000;\n        chainIds[250] = true;\n        chainBalances[250] = 200000000000000000;\n    }\n    \n    function transferToChain(uint chainId, uint256 amount) public returns (bool) {\n        require(chainIds[chainId], 'Invalid Chain ID');\n        IERC20Token paymentToken = IERC20Token(paymentAddress);\n        require(paymentToken.allowance(_msgSender(), address(this)) >= amount, 'Handler unable to spend ');\n        require(paymentToken.transferFrom(_msgSender(), address(this), amount), 'Transfer ERROR');\n        BasicERC20(paymentAddress).burn(amount);\n        chainBalances[chainId] = chainBalances[chainId].add(amount);\n        emit BridgeDeposit(_msgSender(), amount, chainId);\n        \n        return true;\n    }\n    \n    function _transferFromChain(address _to, uint chainId, uint256 amount) internal returns (bool) {\n        require(chainBalances[chainId] >= amount, 'Can not transfer more than deposited');\n        require(chainIds[chainId], 'Invalid Chain ID');\n        BasicERC20 paymentToken = BasicERC20(paymentAddress);\n        paymentToken.mint(_to, amount);\n        chainBalances[chainId] = chainBalances[chainId].sub(amount);\n        emit BridgeWithdrawal(_msgSender(), amount, chainId);\n        \n        return true;\n    }\n    \n    event BridgeDeposit(address indexed sender, uint256 indexed amount, uint chainId);\n    event BridgeWithdrawal(address indexed sender, uint256 indexed amount, uint chainId);\n    \n    function _addChainId(uint chainId) internal returns (bool) {\n        chainIds[chainId] = true;\n        return true;\n    }\n    \n    function _removeChainId(uint chainId) internal returns (bool) {\n        chainIds[chainId] = false;\n        return true;\n    }\n    \n}\n\ncontract VaultHandlerV7a is ReentrancyGuard, Bridged { \n    \n    using SafeMath for uint256;\n    using SafeMath for uint8;\n    address payable private owner;\n    string public metadataBaseUri;\n    bool public initialized;\n    address public nftAddress;\n    address public recipientAddress;\n    address public claimAddress;\n    uint256 public price;\n    bool public shouldBurn = false;\n    uint internal blockWindow = 3;\n    \n    struct PreMint {\n        string payload;\n        bytes32 preImage;\n    }\n    \n    struct PreTransfer {\n        string payload;\n        bytes32 preImage;\n        address _from;\n    }\n    \n    struct Offer {\n        uint tokenId;\n        address _from;\n    }\n\n    mapping(address => mapping(uint => PreMint)) preMints;\n    mapping(address => mapping(uint => PreMint)) preMintsByIndex;\n    mapping(address => uint) preMintCounts;\n    \n    mapping(uint => PreTransfer) preTransfers;\n    mapping(uint => mapping(uint => PreTransfer)) preTransfersByIndex;\n    mapping(uint => uint) preTransferCounts;\n    \n    mapping(uint => Offer[]) offers;\n    mapping(uint => Offer[]) rejected;\n    mapping(address => mapping(uint => Offer)) offered;\n    \n    mapping(address => bool) public blacklisted;\n    mapping(address => bool) public witnesses;\n    mapping(uint256 => bool) usedNonces;\n    mapping(uint256 => bool) public usedTokenIds;\n    \n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    // modifier to check if caller is owner\n    modifier isOwner() {\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use 'require' to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    // modifier to check if caller blacklisted\n    modifier notBlacklisted() {\n        require(!blacklisted[msg.sender], \"Caller is blacklisted\");\n        _;\n    }\n    \n    /**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     */\n    function transferOwnership(address payable newOwner) public isOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n    \n    /**\n     * @dev Return owner address \n     * @return address of owner\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n    \n    constructor(address _nftAddress, address _paymentAddress, address _recipientAddress, uint256 _price) {\n        owner = _msgSender(); // 'msg.sender' is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n        addWitness(owner);\n        metadataBaseUri = \"https://api.emblemvault.io/s:evmetadata/meta/\";\n        nftAddress = _nftAddress;\n        paymentAddress = _paymentAddress;\n        recipientAddress = _recipientAddress;\n        initialized = true;\n        uint decimals = BasicERC20(paymentAddress).decimals();\n        price = _price * 10 ** decimals;\n    }\n    \n    function claim(uint256 tokenId) public isOwner {\n        bytes32[] memory proof;\n        IClaimed claimer = IClaimed(claimAddress);\n        require(!claimer.isClaimed(nftAddress, tokenId, proof), \"Already Claimed\");\n        \n        IERC721 token = IERC721(nftAddress);\n        token.burn(tokenId);\n    }\n\n    function claimOnChain(uint256 tokenId) public nonReentrant notBlacklisted {\n        bytes32[] memory proof;\n        IClaimed claimer = IClaimed(claimAddress);\n        require(!claimer.isClaimed(nftAddress, tokenId, proof), \"Already Claimed\");\n        IERC721 token = IERC721(nftAddress);\n        require(token.ownerOf(tokenId) == _msgSender(), \"Not Token Owner\");\n        token.burn(tokenId);\n        claimer.claim(nftAddress, tokenId, _msgSender());\n    }\n\n    function addClaimAddress(address _address) public isOwner {\n        claimAddress = _address;\n    }\n\n    function toggleBlacklist(address _address) public isOwner {\n        blacklisted[_address] = !blacklisted[_address];\n    }\n\n    function adjustBlockWindow(uint size) public isOwner {\n        blockWindow = size;\n    }\n\n    function buyWithSignature2(address _to, uint256 _tokenId, string calldata _payload, uint256 _nonce, uint signedBlock, bytes calldata _signature) public payable notBlacklisted {\n        bytes32[] memory proof;\n        require(signedBlock.add(blockWindow) > block.number, 'Signature expired');\n        require(!IClaimed(claimAddress).isClaimed(nftAddress, _tokenId, proof) && !usedTokenIds[_tokenId], \"Already claimed\");\n        IERC721 nftToken = IERC721(nftAddress);\n        if (shouldBurn) {\n            require(IERC20Token(paymentAddress).transferFrom(msg.sender, address(this), price), 'Transfer ERROR'); // Payment sent to recipient\n            BasicERC20(paymentAddress).burn(price);\n        } else {\n            require(IERC20Token(paymentAddress).transferFrom(msg.sender, address(recipientAddress), price), 'Transfer ERROR'); // Payment sent to recipient\n        }\n        \n        address signer = getAddressFromSignature(_tokenId, _nonce, _payload, signedBlock, _signature);\n        require(witnesses[signer], 'Not Witnessed');\n        usedNonces[_nonce] = true;\n        string memory _uri = concat(metadataBaseUri, uintToStr(_tokenId));\n        nftToken.mint(_to, _tokenId, _uri, _payload);\n        usedTokenIds[_tokenId] = true;\n    }\n\n    \n    \n    function buyWithSignature(address _to, uint256 _tokenId, string calldata _payload, uint256 _nonce, bytes calldata _signature) public isOwner payable {\n        IERC20Token paymentToken = IERC20Token(paymentAddress);\n        IERC721 nftToken = IERC721(nftAddress);\n        if (shouldBurn) {\n            require(paymentToken.transferFrom(msg.sender, address(this), price), 'Transfer ERROR'); // Payment sent to recipient\n            BasicERC20(paymentAddress).burn(price);\n        } else {\n            require(paymentToken.transferFrom(msg.sender, address(recipientAddress), price), 'Transfer ERROR'); // Payment sent to recipient\n        }        \n        address signer = getAddressFromSignature(_tokenId, _nonce, _payload, _signature);\n        require(witnesses[signer], 'Not Witnessed');\n        usedNonces[_nonce] = true;\n        string memory _uri = concat(metadataBaseUri, uintToStr(_tokenId));\n        nftToken.mint(_to, _tokenId, _uri, _payload);\n    }\n    \n    \n    function addPreMint(address _for, string calldata _payload, uint256 _tokenId, bytes32 preImage) public isOwner {\n        try IERC721(nftAddress).tokenPayload(_tokenId) returns (string memory) {\n            revert('NFT Exists with this ID');\n        } catch {\n            require(!_duplicatePremint(_for, _tokenId), 'Duplicate PreMint');\n            preMintCounts[_for] = preMintCounts[_for].add(1);\n            preMints[_for][_tokenId] = PreMint(_payload, preImage);\n            preMintsByIndex[_for][preMintCounts[_for]] = preMints[_for][_tokenId];\n        }\n    }\n    \n    function _duplicatePremint(address _for, uint256 _tokenId) internal view returns (bool) {\n        string memory data = preMints[_for][_tokenId].payload;\n        bytes32 NULL = keccak256(bytes(''));\n        return keccak256(bytes(data)) != NULL;\n    }\n    \n    function deletePreMint(address _for, uint256 _tokenId) public isOwner {\n        delete preMintsByIndex[_for][preMintCounts[_for]];\n        preMintCounts[_for] = preMintCounts[_for].sub(1);\n        delete preMints[_for][_tokenId];\n    }\n    \n    function getPreMint(address _for, uint256 _tokenId) public view returns (PreMint memory) {\n        return preMints[_for][_tokenId];\n    }\n    \n    function checkPreMintImage(string memory image, bytes32 preImage) public pure returns (bytes32, bytes32, bool) {\n        bytes32 calculated = sha256(abi.encodePacked(image));\n        bytes32 preBytes = preImage;\n        return (calculated, preBytes, calculated == preBytes);\n    }\n    \n    function getPreMintCount(address _for) public view returns (uint length) {\n        return preMintCounts[_for];\n    }\n    \n    function getPreMintByIndex(address _for, uint index) public view returns (PreMint memory) {\n        return preMintsByIndex[_for][index];\n    }\n    \n    function toggleShouldBurn() public isOwner {\n        shouldBurn = !shouldBurn;\n    }\n    \n    /* Transfer with code */\n    function addWitness(address _witness) public isOwner {\n        witnesses[_witness] = true;\n    }\n\n    function removeWitness(address _witness) public isOwner {\n        witnesses[_witness] = false;\n    }\n    \n    function getAddressFromSignature(uint256 _tokenId, uint256 _nonce, bytes memory signature) public view returns (address) {\n        require(!usedNonces[_nonce]);\n        bytes32 hash = keccak256(abi.encodePacked(concat(uintToStr(_tokenId), uintToStr(_nonce))));\n        address addressFromSig = recoverSigner(hash, signature);\n        return addressFromSig;\n    }\n    \n    function getAddressFromSignature(uint256 _tokenId, uint256 _nonce, string calldata payload, bytes memory signature) public view returns (address) {\n        require(!usedNonces[_nonce]);\n        string memory combined = concat(uintToStr(_tokenId), payload);\n        bytes32 hash = keccak256(abi.encodePacked(concat(combined, uintToStr(_nonce))));\n        address addressFromSig = recoverSigner(hash, signature);\n        return addressFromSig;\n    }\n\n    function getAddressFromSignature(uint256 _tokenId, uint256 _nonce, string calldata payload, uint blockNumber, bytes memory signature) public view returns (address) {\n        require(!usedNonces[_nonce]);\n        string memory combined = concat(concat(uintToStr(_tokenId), payload), uintToStr(blockNumber));\n        bytes32 hash = keccak256(abi.encodePacked(concat(combined, uintToStr(_nonce))));\n        address addressFromSig = recoverSigner(hash, signature);\n        return addressFromSig;\n    }\n    \n    function getAddressFromSignature(bytes32 _hash, bytes calldata signature) public pure returns (address) {\n        address addressFromSig = recoverSigner(_hash, signature);\n        return addressFromSig;\n    }\n    \n    function getHash(string calldata _payload) public pure returns (bytes32) {\n        bytes32 hash = keccak256(abi.encodePacked(_payload));\n        return hash;\n    }\n    \n    function transferWithCode(uint256 _tokenId, string calldata code, address _to, uint256 _nonce,  bytes memory signature) public payable notBlacklisted {\n        require(witnesses[getAddressFromSignature(_tokenId, _nonce, signature)], 'Not Witnessed');\n        IERC721 nftToken = IERC721(nftAddress);\n        PreTransfer memory preTransfer = preTransfers[_tokenId];\n        require(preTransfer.preImage == sha256(abi.encodePacked(code)), 'Code does not match'); // Payload should match\n        nftToken.transferFrom(preTransfer._from, _to,  _tokenId);\n        delete preTransfers[_tokenId];\n        delete preTransfersByIndex[_tokenId][preTransferCounts[_tokenId]];\n        preTransferCounts[_tokenId] = preTransferCounts[_tokenId].sub(1);\n        usedNonces[_nonce] = true;\n    }\n    \n    function addPreTransfer(uint256 _tokenId, bytes32 preImage) public {\n        require(!_duplicatePretransfer(_tokenId), 'Duplicate PreTransfer');\n        preTransferCounts[_tokenId] = preTransferCounts[_tokenId].add(1);\n        preTransfers[_tokenId] = PreTransfer(\"payload\", preImage, msg.sender);\n        preTransfersByIndex[_tokenId][preTransferCounts[_tokenId]] = preTransfers[_tokenId];\n    }\n    \n    function _duplicatePretransfer(uint256 _tokenId) internal view returns (bool) {\n        string memory data = preTransfers[_tokenId].payload;\n        bytes32 NULL = keccak256(bytes(''));\n        return keccak256(bytes(data)) != NULL;\n    }\n    \n    function deletePreTransfer(uint256 _tokenId) public {\n        require(preTransfers[_tokenId]._from == msg.sender, 'PreTransfer does not belong to sender');\n        delete preTransfersByIndex[_tokenId][preTransferCounts[_tokenId]];\n        preTransferCounts[_tokenId] = preTransferCounts[_tokenId].sub(1);\n        delete preTransfers[_tokenId];\n    }\n    \n    function getPreTransfer(uint256 _tokenId) public view returns (PreTransfer memory) {\n        return preTransfers[_tokenId];\n    }\n    \n    function checkPreTransferImage(string memory image, bytes32 preImage) public pure returns (bytes32, bytes32, bool) {\n        bytes32 calculated = sha256(abi.encodePacked(image));\n        bytes32 preBytes = preImage;\n        return (calculated, preBytes, calculated == preBytes);\n    }\n    \n    function getPreTransferCount(uint256 _tokenId) public view returns (uint length) {\n        return preTransferCounts[_tokenId];\n    }\n    \n    function getPreTransferByIndex(uint256 _tokenId, uint index) public view returns (PreTransfer memory) {\n        return preTransfersByIndex[_tokenId][index];\n    }\n    \n    function changeMetadataBaseUri(string calldata _uri) public isOwner {\n        metadataBaseUri = _uri;\n    }\n    \n    function transferPaymentOwnership(address newOwner) external isOwner {\n        Ownable paymentToken = Ownable(paymentAddress);\n        paymentToken.transferOwnership(newOwner);\n    }\n    \n    function transferNftOwnership(address newOwner) external isOwner {\n        Ownable nftToken = Ownable(nftAddress);\n        nftToken.transferOwnership(newOwner);\n    }\n    \n    function mint( address _to, uint256 _tokenId, string calldata _uri, string calldata _payload) external isOwner {\n        IERC721 nftToken = IERC721(nftAddress);\n        nftToken.mint(_to, _tokenId, _uri, _payload);\n    }\n    \n    function changeName(string calldata name, string calldata symbol) external isOwner {\n        IERC721 nftToken = IERC721(nftAddress);\n        nftToken.changeName(name, symbol);\n    }\n    \n    function updateTokenUri(uint256 _tokenId,string memory _uri) external isOwner {\n        IERC721 nftToken = IERC721(nftAddress);\n        nftToken.updateTokenUri(_tokenId, _uri);\n    }\n    \n    function getPaymentDecimals() public view returns (uint8){\n        BasicERC20 token = BasicERC20(paymentAddress);\n        return token.decimals();\n    }\n    \n    function changePayment(address payment) public isOwner {\n       paymentAddress = payment;\n    }\n    \n    // function changeCoupon(address coupon) public isOwner {\n    //   couponAddress = coupon;\n    // }\n    \n    function changeRecipient(address _recipient) public isOwner {\n       recipientAddress = _recipient;\n    }\n    \n    function changeNft(address token) public isOwner {\n        nftAddress = token;\n    }\n    \n    function changePrice(uint256 _price) public isOwner {\n        uint decimals = BasicERC20(paymentAddress).decimals();\n        price = _price * 10 ** decimals;\n    }\n    \n    // function changeOfferPrice(uint256 _price) public isOwner {\n    //     uint decimals = BasicERC20(couponAddress).decimals();\n    //     offerPrice = _price * 10 ** decimals;\n    // }\n    \n    function addChainId(uint chainId) public isOwner returns (bool) {\n        return (_addChainId(chainId));\n    }\n    \n    function removeChainId(uint chainId) public isOwner returns (bool) {\n        return (_removeChainId(chainId));\n    }\n    \n    function transferFromChain(address _to, uint chainId, uint256 amount) public isOwner returns (bool) {\n        return _transferFromChain(_to, chainId, amount);\n    }\n    \n    function concat(string memory a, string memory b) internal pure returns (string memory) {\n        return string(abi.encodePacked(a, b));\n    }\n    /**\n    * @dev Recover signer address from a message by using their signature\n    * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n    * @param sig bytes signature, the signature is generated using web3.eth.sign(). Inclusive \"0x...\"\n    */\n    function recoverSigner(bytes32 hash, bytes memory sig) internal pure returns (address) {\n        require(sig.length == 65, \"Require correct length\");\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // Divide the signature in r, s and v variables\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n\n        require(v == 27 || v == 28, \"Signature version not match\");\n\n        return recoverSigner2(hash, v, r, s);\n    }\n\n    function recoverSigner2(bytes32 h, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, h));\n        address addr = ecrecover(prefixedHash, v, r, s);\n\n        return addr;\n    }\n    \n    function uintToStr(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n    \n    function stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n        bytes memory tempEmptyStringTest = bytes(source);\n        if (tempEmptyStringTest.length == 0) {\n            return 0x0;\n        }\n    \n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n    function bytes32ToStr(bytes32 _bytes32) internal pure returns (string memory) {\n\n        // string memory str = string(_bytes32);\n        // TypeError: Explicit type conversion not allowed from \"bytes32\" to \"string storage pointer\"\n        // thus we should fist convert bytes32 to bytes (to dynamically-sized byte array)\n    \n        bytes memory bytesArray = new bytes(32);\n        for (uint256 i; i < 32; i++) {\n            bytesArray[i] = _bytes32[i];\n            }\n        return string(bytesArray);\n    }\n    function asciiToInteger(bytes32 x) public pure returns (uint256) {\n        uint256 y;\n        for (uint256 i = 0; i < 32; i++) {\n            uint256 c = (uint256(x) >> (i * 8)) & 0xff;\n            if (48 <= c && c <= 57)\n                y += (c - 48) * 10 ** i;\n            else\n                break;\n        }\n        return y;\n    }\n    function toString(address account) public pure returns(string memory) {\n        return toString(abi.encodePacked(account));\n    }\n    \n    function toString(uint256 value) public pure returns(string memory) {\n        return toString(abi.encodePacked(value));\n    }\n    \n    function toString(bytes32 value) public pure returns(string memory) {\n        return toString(abi.encodePacked(value));\n    }\n    \n    function toString(bytes memory data) public pure returns(string memory) {\n        bytes memory alphabet = \"0123456789abcdef\";\n    \n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint i = 0; i < data.length; i++) {\n            str[2+i*2] = alphabet[uint(uint8(data[i] >> 4))];\n            str[3+i*2] = alphabet[uint(uint8(data[i] & 0x0f))];\n        }\n        return string(str);\n    }\n}"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": true,
11       "runs": 1
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "devdoc",
19           "userdoc",
20           "metadata",
21           "abi"
22         ]
23       }
24     },
25     "libraries": {}
26   }
27 }}