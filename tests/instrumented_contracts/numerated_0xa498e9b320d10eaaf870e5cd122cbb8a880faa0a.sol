1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/oracle/YieldOracle.sol": {
5       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./IYieldOraclelizable.sol\";\nimport \"./IYieldOracle.sol\";\n\n// a modified version of https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSlidingWindowOracle.sol\n// sliding window oracle that uses observations collected over a window to provide moving yield averages in the past\n// `windowSize` with a precision of `windowSize / granularity`\ncontract YieldOracle is IYieldOracle {\n    using SafeMath for uint256;\n\n    IYieldOraclelizable public cumulator;\n\n    struct Observation {\n        uint256 timestamp;\n        uint256 yieldCumulative;\n    }\n\n    // the desired amount of time over which the moving average should be computed, e.g. 24 hours\n    uint256 public immutable windowSize;\n\n    // the number of observations stored for each pair, i.e. how many price observations are stored for the window.\n    // as granularity increases from 1, more frequent updates are needed, but moving averages become more precise.\n    // averages are computed over intervals with sizes in the range:\n    //   [windowSize - (windowSize / granularity) * 2, windowSize]\n    // e.g. if the window size is 24 hours, and the granularity is 24, the oracle will return the average price for\n    //   the period:\n    //   [now - [22 hours, 24 hours], now]\n    uint8 public immutable granularity;\n\n    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\n    uint256 public immutable periodSize;\n\n    // list of yield observations\n    Observation[] public yieldObservations;\n\n    constructor(\n        address cumulator_,\n        uint256 windowSize_,\n        uint8 granularity_\n    ) {\n        require(granularity_ > 1, \"YO: GRANULARITY\");\n        require(\n            (periodSize = windowSize_ / granularity_) * granularity_ ==\n                windowSize_,\n            \"YO: WINDOW_NOT_EVENLY_DIVISIBLE\"\n        );\n        windowSize = windowSize_;\n        granularity = granularity_;\n        cumulator = IYieldOraclelizable(cumulator_);\n\n        for (uint256 i = yieldObservations.length; i < granularity_; i++) {\n            yieldObservations.push();\n        }\n    }\n\n    // returns the index of the observation corresponding to the given timestamp\n    function observationIndexOf(uint256 timestamp_)\n        public\n        view\n        returns (uint8 index)\n    {\n        uint256 epochPeriod = timestamp_ / periodSize;\n        return uint8(epochPeriod % granularity);\n    }\n\n    // returns the observation from the oldest epoch (at the beginning of the window) relative to the current time\n    function getFirstObservationInWindow()\n        private\n        view\n        returns (Observation storage firstObservation)\n    {\n        uint8 observationIndex = observationIndexOf(block.timestamp);\n        // no overflow issue. if observationIndex + 1 overflows, result is still zero.\n        uint8 firstObservationIndex = (observationIndex + 1) % granularity;\n        firstObservation = yieldObservations[firstObservationIndex];\n    }\n\n    // update the cumulative price for the observation at the current timestamp. each observation is updated at most\n    // once per epoch period.\n    function update() external virtual override {\n        // get the observation for the current period\n        uint8 observationIndex = observationIndexOf(block.timestamp);\n        Observation storage observation = yieldObservations[observationIndex];\n\n        // we only want to commit updates once per period (i.e. windowSize / granularity)\n        uint256 timeElapsed = block.timestamp - observation.timestamp;\n        if (timeElapsed > periodSize) {\n            (uint256 yieldCumulative) = cumulator.cumulatives();\n            observation.timestamp = block.timestamp;\n            observation.yieldCumulative = yieldCumulative;\n        }\n    }\n\n    // given the cumulative yields of the start and end of a period, and the length of the period (timeElapsed in seconds), compute the average\n    // yield and extrapolate it for forInterval (seconds) in terms of how much amount out is received for the amount in\n    function computeAmountOut(\n        uint256 yieldCumulativeStart_,\n        uint256 yieldCumulativeEnd_,\n        uint256 timeElapsed_,\n        uint256 forInterval_\n    ) private pure returns (uint256 yieldAverage) {\n        // ((yieldCumulativeEnd_ - yieldCumulativeStart_) * forInterval_) / timeElapsed_;\n        return yieldCumulativeEnd_.sub(yieldCumulativeStart_).mul(forInterval_).div(timeElapsed_);\n    }\n\n    // returns the amount out corresponding to the amount in for a given token using the moving average over the time\n    // range [now - [windowSize, windowSize - periodSize * 2], now]\n    // update must have been called for the bucket corresponding to timestamp `now - windowSize`\n    function consult(uint256 forInterval)\n        external\n        override\n        virtual\n        returns (uint256 yieldForInterval)\n    {\n        Observation storage firstObservation = getFirstObservationInWindow();\n\n        uint256 timeElapsed = block.timestamp - firstObservation.timestamp;\n\n        if (!(timeElapsed <= windowSize)) {\n            // originally:\n            // require(\n            //     timeElapsed <= windowSize,\n            //     \"YO: MISSING_HISTORICAL_OBSERVATION\"\n            // );\n            // if the oracle is falling behind, it reports 0 yield => there's no incentive to buy sBOND\n            return 0;\n        }\n\n        if (!(timeElapsed >= windowSize - periodSize * 2)) {\n            // originally:\n            // should never happen.\n            // require(\n            //     timeElapsed >= windowSize - periodSize * 2,\n            //     \"YO: UNEXPECTED_TIME_ELAPSED\"\n            // );\n            // if the oracle is in an odd state, it reports 0 yield => there's no incentive to buy sBOND\n            return 0;\n        }\n\n        (uint256 yieldCumulative) = cumulator.cumulatives();\n\n        return\n            computeAmountOut(\n                firstObservation.yieldCumulative,\n                yieldCumulative,\n                timeElapsed,\n                forInterval\n            );\n    }\n}\n"
6     },
7     "@openzeppelin/contracts/math/SafeMath.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
9     },
10     "contracts/oracle/IYieldOraclelizable.sol": {
11       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\npragma abicoder v2;\n\ninterface IYieldOraclelizable {\n    // accumulates/updates internal state and returns cumulatives \n    // oracle should call this when updating\n    function cumulatives()\n      external\n    returns(uint256 cumulativeYield);\n\n}\n"
12     },
13     "contracts/oracle/IYieldOracle.sol": {
14       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\npragma abicoder v2;\n\ninterface IYieldOracle {\n    function update() external;\n\n    function consult(uint256 forInterval) external returns (uint256 amountOut);\n}\n"
15     }
16   },
17   "settings": {
18     "optimizer": {
19       "enabled": true,
20       "runs": 9999
21     },
22     "outputSelection": {
23       "*": {
24         "*": [
25           "evm.bytecode",
26           "evm.deployedBytecode",
27           "abi"
28         ]
29       }
30     },
31     "libraries": {}
32   }
33 }}