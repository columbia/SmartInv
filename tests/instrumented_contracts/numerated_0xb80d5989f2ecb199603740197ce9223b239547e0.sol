1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "istanbul",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "enabled": true,
12       "runs": 20000
13     },
14     "remappings": [],
15     "outputSelection": {
16       "*": {
17         "*": [
18           "evm.bytecode",
19           "evm.deployedBytecode",
20           "abi"
21         ]
22       }
23     }
24   },
25   "sources": {
26     "@openzeppelin/contracts/access/Ownable.sol": {
27       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
28     },
29     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
30       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
31     },
32     "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
33       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
34     },
35     "@openzeppelin/contracts/utils/Address.sol": {
36       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
37     },
38     "@openzeppelin/contracts/utils/Context.sol": {
39       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
40     },
41     "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
42       "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
43     },
44     "contracts/Admin.sol": {
45       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./RoleAware.sol\";\nimport \"./Fund.sol\";\nimport \"./CrossMarginTrading.sol\";\nimport \"../libraries/IncentiveReporter.sol\";\n\n/** \n@title Here we support staking for MFI incentives as well as\nstaking to perform the maintenance role.\n*/\ncontract Admin is RoleAware {\n    /// Margenswap (MFI) token address\n    address public immutable MFI;\n    mapping(address => uint256) public stakes;\n    uint256 public totalStakes;\n\n    uint256 public constant mfiStakeTranche = 1;\n\n    uint256 public maintenanceStakePerBlock = 15 ether;\n    mapping(address => address) public nextMaintenanceStaker;\n    mapping(address => mapping(address => bool)) public maintenanceDelegateTo;\n    address public currentMaintenanceStaker;\n    address public prevMaintenanceStaker;\n    uint256 public currentMaintenanceStakerStartBlock;\n    address public immutable lockedMFI;\n\n    constructor(\n        address _MFI,\n        address _lockedMFI,\n        address lockedMFIDelegate,\n        address _roles\n    ) RoleAware(_roles) {\n        MFI = _MFI;\n        lockedMFI = _lockedMFI;\n\n        // for initialization purposes and to ensure availability of service\n        // the team's locked MFI participate in maintenance staking only\n        // (not in the incentive staking part)\n        // this implies some trust of the team to execute, which we deem reasonable\n        // since the locked stake is temporary and diminishing as well as the fact\n        // that the team is heavily invested in the protocol and incentivized\n        // by fees like any other maintainer\n        // furthermore others could step in to liquidate via the attacker route\n        // and take away the team fees if they were delinquent\n        nextMaintenanceStaker[_lockedMFI] = _lockedMFI;\n        currentMaintenanceStaker = _lockedMFI;\n        prevMaintenanceStaker = _lockedMFI;\n        maintenanceDelegateTo[_lockedMFI][lockedMFIDelegate];\n        currentMaintenanceStakerStartBlock = block.number;\n    }\n\n    /// Maintence stake setter\n    function setMaintenanceStakePerBlock(uint256 amount)\n        external\n        onlyOwnerExec\n    {\n        maintenanceStakePerBlock = amount;\n    }\n\n    function _stake(address holder, uint256 amount) internal {\n        Fund(fund()).depositFor(holder, MFI, amount);\n\n        stakes[holder] += amount;\n        totalStakes += amount;\n\n        IncentiveReporter.addToClaimAmount(MFI, holder, amount);\n    }\n\n    /// Deposit a stake for sender\n    function depositStake(uint256 amount) external {\n        _stake(msg.sender, amount);\n    }\n\n    function _withdrawStake(\n        address holder,\n        uint256 amount,\n        address recipient\n    ) internal {\n        // overflow failure desirable\n        stakes[holder] -= amount;\n        totalStakes -= amount;\n        Fund(fund()).withdraw(MFI, recipient, amount);\n\n        IncentiveReporter.subtractFromClaimAmount(MFI, holder, amount);\n    }\n\n    /// Withdraw stake for sender\n    function withdrawStake(uint256 amount) external {\n        require(\n            !isAuthorizedStaker(msg.sender),\n            \"You can't withdraw while you're authorized staker\"\n        );\n        _withdrawStake(msg.sender, amount, msg.sender);\n    }\n\n    /// Deposit maintenance stake\n    function depositMaintenanceStake(uint256 amount) external {\n        require(\n            amount + stakes[msg.sender] >= maintenanceStakePerBlock,\n            \"Insufficient stake to call even one block\"\n        );\n        _stake(msg.sender, amount);\n        if (nextMaintenanceStaker[msg.sender] == address(0)) {\n            nextMaintenanceStaker[msg.sender] = getUpdatedCurrentStaker();\n            nextMaintenanceStaker[prevMaintenanceStaker] = msg.sender;\n        }\n    }\n\n    function getMaintenanceStakerStake(address staker)\n        public\n        view\n        returns (uint256)\n    {\n        if (staker == lockedMFI) {\n            return IERC20(MFI).balanceOf(lockedMFI) / 2;\n        } else {\n            return stakes[staker];\n        }\n    }\n\n    function getUpdatedCurrentStaker() public returns (address) {\n        uint256 currentStake =\n            getMaintenanceStakerStake(currentMaintenanceStaker);\n        if (\n            (block.number - currentMaintenanceStakerStartBlock) *\n                maintenanceStakePerBlock >=\n            currentStake\n        ) {\n            currentMaintenanceStakerStartBlock = block.number;\n\n            prevMaintenanceStaker = currentMaintenanceStaker;\n            currentMaintenanceStaker = nextMaintenanceStaker[\n                currentMaintenanceStaker\n            ];\n            currentStake = getMaintenanceStakerStake(currentMaintenanceStaker);\n\n            if (maintenanceStakePerBlock > currentStake) {\n                // delete current from daisy chain\n                address nextOne =\n                    nextMaintenanceStaker[currentMaintenanceStaker];\n                nextMaintenanceStaker[prevMaintenanceStaker] = nextOne;\n                nextMaintenanceStaker[currentMaintenanceStaker] = address(0);\n\n                currentMaintenanceStaker = nextOne;\n                currentStake = getMaintenanceStakerStake(\n                    currentMaintenanceStaker\n                );\n            }\n        }\n\n        return currentMaintenanceStaker;\n    }\n\n    function viewCurrentMaintenanceStaker()\n        public\n        view\n        returns (address staker, uint256 startBlock)\n    {\n        staker = currentMaintenanceStaker;\n        uint256 currentStake = getMaintenanceStakerStake(staker);\n        startBlock = currentMaintenanceStakerStartBlock;\n        if (\n            (block.number - startBlock) * maintenanceStakePerBlock >=\n            currentStake\n        ) {\n            staker = nextMaintenanceStaker[staker];\n            currentStake = getMaintenanceStakerStake(staker);\n            startBlock = block.number;\n\n            if (maintenanceStakePerBlock > currentStake) {\n                staker = nextMaintenanceStaker[staker];\n            }\n        }\n    }\n\n    /// Add a delegate for staker\n    function addDelegate(address forStaker, address delegate) external {\n        require(\n            msg.sender == forStaker ||\n                maintenanceDelegateTo[forStaker][msg.sender],\n            \"msg.sender not authorized to delegate for staker\"\n        );\n        maintenanceDelegateTo[forStaker][delegate] = true;\n    }\n\n    /// Remove a delegate for staker\n    function removeDelegate(address forStaker, address delegate) external {\n        require(\n            msg.sender == forStaker ||\n                maintenanceDelegateTo[forStaker][msg.sender],\n            \"msg.sender not authorized to delegate for staker\"\n        );\n        maintenanceDelegateTo[forStaker][delegate] = false;\n    }\n\n    function isAuthorizedStaker(address caller)\n        public\n        returns (bool isAuthorized)\n    {\n        address currentStaker = getUpdatedCurrentStaker();\n        isAuthorized =\n            currentStaker == caller ||\n            maintenanceDelegateTo[currentStaker][caller];\n    }\n\n    /// Penalize a staker\n    function penalizeMaintenanceStake(\n        address maintainer,\n        uint256 penalty,\n        address recipient\n    ) external returns (uint256 stakeTaken) {\n        require(\n            isStakePenalizer(msg.sender),\n            \"msg.sender not authorized to penalize stakers\"\n        );\n        if (penalty > stakes[maintainer]) {\n            stakeTaken = stakes[maintainer];\n        } else {\n            stakeTaken = penalty;\n        }\n        _withdrawStake(maintainer, stakeTaken, recipient);\n    }\n}\n"
46     },
47     "contracts/BaseLending.sol": {
48       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./RoleAware.sol\";\n\n/// @title Base lending behavior\nabstract contract BaseLending {\n    uint256 constant FP48 = 2**48;\n    uint256 constant ACCUMULATOR_INIT = 10**18;\n\n    uint256 constant hoursPerYear = 365 days / (1 hours);\n    uint256 constant CHANGE_POINT = 79;\n    uint256 public normalRatePerPercent =\n        (FP48 * 15) / hoursPerYear / CHANGE_POINT / 100;\n    uint256 public highRatePerPercent =\n        (FP48 * (194 - 15)) / hoursPerYear / (100 - CHANGE_POINT) / 100;\n\n    struct YieldAccumulator {\n        uint256 accumulatorFP;\n        uint256 lastUpdated;\n        uint256 hourlyYieldFP;\n    }\n\n    struct LendingMetadata {\n        uint256 totalLending;\n        uint256 totalBorrowed;\n        uint256 lendingCap;\n    }\n    mapping(address => LendingMetadata) public lendingMeta;\n\n    /// @dev accumulate interest per issuer (like compound indices)\n    mapping(address => YieldAccumulator) public borrowYieldAccumulators;\n\n    /// @dev simple formula for calculating interest relative to accumulator\n    function applyInterest(\n        uint256 balance,\n        uint256 accumulatorFP,\n        uint256 yieldQuotientFP\n    ) internal pure returns (uint256) {\n        // 1 * FP / FP = 1\n        return (balance * accumulatorFP) / yieldQuotientFP;\n    }\n\n    function currentLendingRateFP(uint256 totalLending, uint256 totalBorrowing)\n        internal\n        view\n        returns (uint256 rate)\n    {\n        rate = FP48;\n        uint256 utilizationPercent = (100 * totalBorrowing) / totalLending;\n        if (utilizationPercent < CHANGE_POINT) {\n            rate += utilizationPercent * normalRatePerPercent;\n        } else {\n            rate +=\n                CHANGE_POINT *\n                normalRatePerPercent +\n                (utilizationPercent - CHANGE_POINT) *\n                highRatePerPercent;\n        }\n    }\n\n    /// @dev minimum\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a > b) {\n            return b;\n        } else {\n            return a;\n        }\n    }\n\n    /// @dev maximum\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a > b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    /// Available tokens to this issuance\n    function issuanceBalance(address issuance)\n        internal\n        view\n        virtual\n        returns (uint256);\n}\n"
49     },
50     "contracts/BaseRouter.sol": {
51       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Fund.sol\";\nimport \"../libraries/UniswapStyleLib.sol\";\n\nabstract contract BaseRouter {\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"Trade has expired\");\n        _;\n    }\n\n    // **** SWAP ****\n    /// @dev requires the initial amount to have already been sent to the first pair\n    /// and for pairs to be vetted (which getAmountsIn / getAmountsOut do)\n    function _swap(\n        uint256[] memory amounts,\n        address[] memory pairs,\n        address[] memory tokens,\n        address _to\n    ) internal {\n        for (uint256 i; i < pairs.length; i++) {\n            (address input, address output) = (tokens[i], tokens[i + 1]);\n            (address token0, ) = UniswapStyleLib.sortTokens(input, output);\n\n            uint256 amountOut = amounts[i + 1];\n\n            (uint256 amount0Out, uint256 amount1Out) =\n                input == token0\n                    ? (uint256(0), amountOut)\n                    : (amountOut, uint256(0));\n\n            address to = i < pairs.length - 1 ? pairs[i + 1] : _to;\n            IUniswapV2Pair pair = IUniswapV2Pair(pairs[i]);\n\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n}\n"
52     },
53     "contracts/CrossMarginAccounts.sol": {
54       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./Fund.sol\";\nimport \"./Lending.sol\";\nimport \"./RoleAware.sol\";\nimport \"./PriceAware.sol\";\n\n// Goal: all external functions only accessible to margintrader role\n// except for view functions of course\n\nstruct CrossMarginAccount {\n    uint256 lastDepositBlock;\n    address[] borrowTokens;\n    // borrowed token address => amount\n    mapping(address => uint256) borrowed;\n    // borrowed token => yield quotient\n    mapping(address => uint256) borrowedYieldQuotientsFP;\n    address[] holdingTokens;\n    // token held in portfolio => amount\n    mapping(address => uint256) holdings;\n    // boolean value of whether an account holds a token\n    mapping(address => bool) holdsToken;\n}\n\nabstract contract CrossMarginAccounts is RoleAware, PriceAware {\n    /// @dev gets used in calculating how much accounts can borrow\n    uint256 public leveragePercent = 300;\n\n    /// @dev percentage of assets held per assets borrowed at which to liquidate\n    uint256 public liquidationThresholdPercent = 115;\n\n    /// @dev record of all cross margin accounts\n    mapping(address => CrossMarginAccount) internal marginAccounts;\n    /// @dev total token caps\n    mapping(address => uint256) public tokenCaps;\n    /// @dev tracks total of short positions per token\n    mapping(address => uint256) public totalShort;\n    /// @dev tracks total of long positions per token\n    mapping(address => uint256) public totalLong;\n    uint256 public coolingOffPeriod = 10;\n\n    /// @dev add an asset to be held by account\n    function addHolding(\n        CrossMarginAccount storage account,\n        address token,\n        uint256 depositAmount\n    ) internal {\n        if (!hasHoldingToken(account, token)) {\n            account.holdingTokens.push(token);\n            account.holdsToken[token] = true;\n        }\n\n        account.holdings[token] += depositAmount;\n    }\n\n    /// @dev adjust account to reflect borrowing of token amount\n    function borrow(\n        CrossMarginAccount storage account,\n        address borrowToken,\n        uint256 borrowAmount\n    ) internal {\n        if (!hasBorrowedToken(account, borrowToken)) {\n            account.borrowTokens.push(borrowToken);\n            account.borrowedYieldQuotientsFP[borrowToken] = Lending(lending())\n                .getUpdatedBorrowYieldAccuFP(borrowToken);\n\n            account.borrowed[borrowToken] = borrowAmount;\n        } else {\n            (uint256 oldBorrowed, uint256 accumulatorFP) =\n                Lending(lending()).applyBorrowInterest(\n                    account.borrowed[borrowToken],\n                    borrowToken,\n                    account.borrowedYieldQuotientsFP[borrowToken]\n                );\n            account.borrowedYieldQuotientsFP[borrowToken] = accumulatorFP;\n\n            account.borrowed[borrowToken] = oldBorrowed + borrowAmount;\n        }\n\n        require(positiveBalance(account), \"Insufficient balance\");\n    }\n\n    /// @dev checks whether account is in the black, deposit + earnings relative to borrowed\n    function positiveBalance(CrossMarginAccount storage account)\n        internal\n        returns (bool)\n    {\n        uint256 loan = loanInPeg(account);\n        uint256 holdings = holdingsInPeg(account);\n        // The following condition should hold:\n        // holdings / loan >= leveragePercent / (leveragePercent - 100)\n        // =>\n        return holdings * (leveragePercent - 100) >= loan * leveragePercent;\n    }\n\n    /// @dev internal function adjusting holding and borrow balances when debt extinguished\n    function extinguishDebt(\n        CrossMarginAccount storage account,\n        address debtToken,\n        uint256 extinguishAmount\n    ) internal {\n        // will throw if insufficient funds\n        (uint256 borrowAmount, uint256 newYieldQuot) =\n            Lending(lending()).applyBorrowInterest(\n                account.borrowed[debtToken],\n                debtToken,\n                account.borrowedYieldQuotientsFP[debtToken]\n            );\n\n        uint256 newBorrowAmount = borrowAmount - extinguishAmount;\n        account.borrowed[debtToken] = newBorrowAmount;\n\n        if (newBorrowAmount > 0) {\n            account.borrowedYieldQuotientsFP[debtToken] = newYieldQuot;\n        } else {\n            delete account.borrowedYieldQuotientsFP[debtToken];\n\n            bool decrement = false;\n            uint256 len = account.borrowTokens.length;\n            for (uint256 i; len > i; i++) {\n                address currToken = account.borrowTokens[i];\n                if (currToken == debtToken) {\n                    decrement = true;\n                } else if (decrement) {\n                    account.borrowTokens[i - 1] = currToken;\n                }\n            }\n            account.borrowTokens.pop();\n        }\n    }\n\n    /// @dev checks whether an account holds a token\n    function hasHoldingToken(CrossMarginAccount storage account, address token)\n        internal\n        view\n        returns (bool)\n    {\n        return account.holdsToken[token];\n    }\n\n    /// @dev checks whether an account has borrowed a token\n    function hasBorrowedToken(CrossMarginAccount storage account, address token)\n        internal\n        view\n        returns (bool)\n    {\n        return account.borrowedYieldQuotientsFP[token] > 0;\n    }\n\n    /// @dev calculate total loan in reference currency, including compound interest\n    function loanInPeg(CrossMarginAccount storage account)\n        internal\n        returns (uint256)\n    {\n        return\n            sumTokensInPegWithYield(\n                account.borrowTokens,\n                account.borrowed,\n                account.borrowedYieldQuotientsFP\n            );\n    }\n\n    /// @dev total of assets of account, expressed in reference currency\n    function holdingsInPeg(CrossMarginAccount storage account)\n        internal\n        returns (uint256)\n    {\n        return sumTokensInPeg(account.holdingTokens, account.holdings);\n    }\n\n    /// @dev check whether an account can/should be liquidated\n    function belowMaintenanceThreshold(CrossMarginAccount storage account)\n        internal\n        returns (bool)\n    {\n        uint256 loan = loanInPeg(account);\n        uint256 holdings = holdingsInPeg(account);\n        // The following should hold:\n        // holdings / loan >= 1.1\n        // => holdings >= loan * 1.1\n        return 100 * holdings < liquidationThresholdPercent * loan;\n    }\n\n    /// @dev go through list of tokens and their amounts, summing up\n    function sumTokensInPeg(\n        address[] storage tokens,\n        mapping(address => uint256) storage amounts\n    ) internal returns (uint256 totalPeg) {\n        uint256 len = tokens.length;\n        for (uint256 tokenId; tokenId < len; tokenId++) {\n            address token = tokens[tokenId];\n            totalPeg += PriceAware.getCurrentPriceInPeg(token, amounts[token]);\n        }\n    }\n\n    /// @dev go through list of tokens and their amounts, summing up\n    function viewTokensInPeg(\n        address[] storage tokens,\n        mapping(address => uint256) storage amounts\n    ) internal view returns (uint256 totalPeg) {\n        uint256 len = tokens.length;\n        for (uint256 tokenId; tokenId < len; tokenId++) {\n            address token = tokens[tokenId];\n            totalPeg += PriceAware.viewCurrentPriceInPeg(token, amounts[token]);\n        }\n    }\n\n    /// @dev go through list of tokens and ammounts, summing up with interest\n    function sumTokensInPegWithYield(\n        address[] storage tokens,\n        mapping(address => uint256) storage amounts,\n        mapping(address => uint256) storage yieldQuotientsFP\n    ) internal returns (uint256 totalPeg) {\n        uint256 len = tokens.length;\n        for (uint256 tokenId; tokenId < len; tokenId++) {\n            address token = tokens[tokenId];\n            totalPeg += yieldTokenInPeg(\n                token,\n                amounts[token],\n                yieldQuotientsFP\n            );\n        }\n    }\n\n    /// @dev go through list of tokens and ammounts, summing up with interest\n    function viewTokensInPegWithYield(\n        address[] storage tokens,\n        mapping(address => uint256) storage amounts,\n        mapping(address => uint256) storage yieldQuotientsFP\n    ) internal view returns (uint256 totalPeg) {\n        uint256 len = tokens.length;\n        for (uint256 tokenId; tokenId < len; tokenId++) {\n            address token = tokens[tokenId];\n            totalPeg += viewYieldTokenInPeg(\n                token,\n                amounts[token],\n                yieldQuotientsFP\n            );\n        }\n    }\n\n    /// @dev calculate yield for token amount and convert to reference currency\n    function yieldTokenInPeg(\n        address token,\n        uint256 amount,\n        mapping(address => uint256) storage yieldQuotientsFP\n    ) internal returns (uint256) {\n        uint256 yieldFP =\n            Lending(lending()).viewAccumulatedBorrowingYieldFP(token);\n        // 1 * FP / FP = 1\n        uint256 amountInToken = (amount * yieldFP) / yieldQuotientsFP[token];\n        return PriceAware.getCurrentPriceInPeg(token, amountInToken);\n    }\n\n    /// @dev calculate yield for token amount and convert to reference currency\n    function viewYieldTokenInPeg(\n        address token,\n        uint256 amount,\n        mapping(address => uint256) storage yieldQuotientsFP\n    ) internal view returns (uint256) {\n        uint256 yieldFP =\n            Lending(lending()).viewAccumulatedBorrowingYieldFP(token);\n        // 1 * FP / FP = 1\n        uint256 amountInToken = (amount * yieldFP) / yieldQuotientsFP[token];\n        return PriceAware.viewCurrentPriceInPeg(token, amountInToken);\n    }\n\n    /// @dev move tokens from one holding to another\n    function adjustAmounts(\n        CrossMarginAccount storage account,\n        address fromToken,\n        address toToken,\n        uint256 soldAmount,\n        uint256 boughtAmount\n    ) internal {\n        account.holdings[fromToken] = account.holdings[fromToken] - soldAmount;\n        addHolding(account, toToken, boughtAmount);\n    }\n\n    /// sets borrow and holding to zero\n    function deleteAccount(CrossMarginAccount storage account) internal {\n        uint256 len = account.borrowTokens.length;\n        for (uint256 borrowIdx; len > borrowIdx; borrowIdx++) {\n            address borrowToken = account.borrowTokens[borrowIdx];\n            totalShort[borrowToken] -= account.borrowed[borrowToken];\n            account.borrowed[borrowToken] = 0;\n            account.borrowedYieldQuotientsFP[borrowToken] = 0;\n        }\n        len = account.holdingTokens.length;\n        for (uint256 holdingIdx; len > holdingIdx; holdingIdx++) {\n            address holdingToken = account.holdingTokens[holdingIdx];\n            totalLong[holdingToken] -= account.holdings[holdingToken];\n            account.holdings[holdingToken] = 0;\n            account.holdsToken[holdingToken] = false;\n        }\n        delete account.borrowTokens;\n        delete account.holdingTokens;\n    }\n\n    /// @dev minimum\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a > b) {\n            return b;\n        } else {\n            return a;\n        }\n    }\n}\n"
55     },
56     "contracts/CrossMarginLiquidation.sol": {
57       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./CrossMarginAccounts.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/** \n@title Handles liquidation of accounts below maintenance threshold\n@notice Liquidation can be called by the authorized staker, \nas determined in the Admin contract.\nIf the authorized staker is delinquent, other participants can jump\nin and attack, taking their fees and potentially even their stake,\ndepending how delinquent the responsible authorized staker is.\n*/\nabstract contract CrossMarginLiquidation is CrossMarginAccounts {\n    event LiquidationShortfall(uint256 amount);\n    event AccountLiquidated(address account);\n\n    struct Liquidation {\n        uint256 buy;\n        uint256 sell;\n        uint256 blockNum;\n    }\n\n    /// record kept around until a stake attacker can claim their reward\n    struct AccountLiqRecord {\n        uint256 blockNum;\n        address loser;\n        uint256 amount;\n        address stakeAttacker;\n    }\n\n    mapping(address => Liquidation) liquidationAmounts;\n    address[] internal liquidationTokens;\n    address[] internal tradersToLiquidate;\n\n    mapping(address => uint256) public maintenanceFailures;\n    mapping(address => AccountLiqRecord) public stakeAttackRecords;\n    uint256 public avgLiquidationPerCall = 10;\n\n    uint256 public liqStakeAttackWindow = 5;\n    uint256 public MAINTAINER_CUT_PERCENT = 5;\n\n    uint256 public failureThreshold = 10;\n\n    /// Set failure threshold\n    function setFailureThreshold(uint256 threshFactor) external onlyOwnerExec {\n        failureThreshold = threshFactor;\n    }\n\n    /// Set liquidity stake attack window\n    function setLiqStakeAttackWindow(uint256 window) external onlyOwnerExec {\n        liqStakeAttackWindow = window;\n    }\n\n    /// Set maintainer's percent cut\n    function setMaintainerCutPercent(uint256 cut) external onlyOwnerExec {\n        MAINTAINER_CUT_PERCENT = cut;\n    }\n\n    /// @dev calcLiquidationAmounts does a number of tasks in this contract\n    /// and some of them are not straightforward.\n    /// First of all it aggregates liquidation amounts,\n    /// as well as which traders are ripe for liquidation, in storage (not in memory)\n    /// owing to the fact that arrays can't be pushed to and hash maps don't\n    /// exist in memory.\n    /// Then it also returns any stake attack funds if the stake was unsuccessful\n    /// (i.e. current caller is authorized). Also see context below.\n    function calcLiquidationAmounts(\n        address[] memory liquidationCandidates,\n        bool isAuthorized\n    ) internal returns (uint256 attackReturns) {\n        liquidationTokens = new address[](0);\n        tradersToLiquidate = new address[](0);\n\n        for (\n            uint256 traderIndex = 0;\n            liquidationCandidates.length > traderIndex;\n            traderIndex++\n        ) {\n            address traderAddress = liquidationCandidates[traderIndex];\n            CrossMarginAccount storage account = marginAccounts[traderAddress];\n\n            if (belowMaintenanceThreshold(account)) {\n                tradersToLiquidate.push(traderAddress);\n                uint256 len = account.holdingTokens.length;\n                for (uint256 sellIdx = 0; len > sellIdx; sellIdx++) {\n                    address token = account.holdingTokens[sellIdx];\n                    Liquidation storage liquidation = liquidationAmounts[token];\n\n                    if (liquidation.blockNum != block.number) {\n                        liquidation.sell = account.holdings[token];\n                        liquidation.buy = 0;\n                        liquidation.blockNum = block.number;\n                        liquidationTokens.push(token);\n                    } else {\n                        liquidation.sell += account.holdings[token];\n                    }\n                }\n\n                len = account.borrowTokens.length;\n                for (uint256 buyIdx = 0; len > buyIdx; buyIdx++) {\n                    address token = account.borrowTokens[buyIdx];\n                    Liquidation storage liquidation = liquidationAmounts[token];\n\n                    (uint256 loanAmount, ) =\n                        Lending(lending()).applyBorrowInterest(\n                            account.borrowed[token],\n                            token,\n                            account.borrowedYieldQuotientsFP[token]\n                        );\n\n                    Lending(lending()).payOff(token, loanAmount);\n\n                    if (liquidation.blockNum != block.number) {\n                        liquidation.sell = 0;\n                        liquidation.buy = loanAmount;\n                        liquidation.blockNum = block.number;\n                        liquidationTokens.push(token);\n                    } else {\n                        liquidation.buy += loanAmount;\n                    }\n                }\n            }\n\n            AccountLiqRecord storage liqAttackRecord =\n                stakeAttackRecords[traderAddress];\n            if (isAuthorized) {\n                attackReturns += _disburseLiqAttack(liqAttackRecord);\n            }\n        }\n    }\n\n    function _disburseLiqAttack(AccountLiqRecord storage liqAttackRecord)\n        internal\n        returns (uint256 returnAmount)\n    {\n        if (liqAttackRecord.amount > 0) {\n            // validate attack records, if any\n            uint256 blockDiff =\n                min(\n                    block.number - liqAttackRecord.blockNum,\n                    liqStakeAttackWindow\n                );\n\n            uint256 attackerCut =\n                (liqAttackRecord.amount * blockDiff) / liqStakeAttackWindow;\n\n            Fund(fund()).withdraw(\n                PriceAware.peg,\n                liqAttackRecord.stakeAttacker,\n                attackerCut\n            );\n\n            Admin a = Admin(admin());\n            uint256 penalty =\n                (a.maintenanceStakePerBlock() * attackerCut) /\n                    avgLiquidationPerCall;\n            a.penalizeMaintenanceStake(\n                liqAttackRecord.loser,\n                penalty,\n                liqAttackRecord.stakeAttacker\n            );\n\n            // return remainder, after cut was taken to authorized stakekr\n            returnAmount = liqAttackRecord.amount - attackerCut;\n        }\n    }\n\n    /// Disburse liquidity stake attacks\n    function disburseLiqStakeAttacks(address[] memory liquidatedAccounts)\n        external\n    {\n        for (uint256 i = 0; liquidatedAccounts.length > i; i++) {\n            address liqAccount = liquidatedAccounts[i];\n            AccountLiqRecord storage liqAttackRecord =\n                stakeAttackRecords[liqAccount];\n            if (\n                block.number > liqAttackRecord.blockNum + liqStakeAttackWindow\n            ) {\n                _disburseLiqAttack(liqAttackRecord);\n                delete stakeAttackRecords[liqAccount];\n            }\n        }\n    }\n\n    function liquidateFromPeg() internal returns (uint256 pegAmount) {\n        uint256 len = liquidationTokens.length;\n        for (uint256 tokenIdx = 0; len > tokenIdx; tokenIdx++) {\n            address buyToken = liquidationTokens[tokenIdx];\n            Liquidation storage liq = liquidationAmounts[buyToken];\n            if (liq.buy > liq.sell) {\n                pegAmount += PriceAware.liquidateFromPeg(\n                    buyToken,\n                    liq.buy - liq.sell\n                );\n                delete liquidationAmounts[buyToken];\n            }\n        }\n    }\n\n    function liquidateToPeg() internal returns (uint256 pegAmount) {\n        uint256 len = liquidationTokens.length;\n        for (uint256 tokenIndex = 0; len > tokenIndex; tokenIndex++) {\n            address token = liquidationTokens[tokenIndex];\n            Liquidation storage liq = liquidationAmounts[token];\n            if (liq.sell > liq.buy) {\n                uint256 sellAmount = liq.sell - liq.buy;\n                pegAmount += PriceAware.liquidateToPeg(token, sellAmount);\n                delete liquidationAmounts[token];\n            }\n        }\n    }\n\n    function maintainerIsFailing() internal view returns (bool) {\n        (address currentMaintainer, ) =\n            Admin(admin()).viewCurrentMaintenanceStaker();\n        return\n            maintenanceFailures[currentMaintainer] >\n            failureThreshold * avgLiquidationPerCall;\n    }\n\n    /// called by maintenance stakers to liquidate accounts below liquidation threshold\n    function liquidate(address[] memory liquidationCandidates)\n        external\n        noIntermediary\n        returns (uint256 maintainerCut)\n    {\n        bool isAuthorized = Admin(admin()).isAuthorizedStaker(msg.sender);\n        bool canTakeNow = isAuthorized || maintainerIsFailing();\n\n        // calcLiquidationAmounts does a lot of the work here\n        // * aggregates both sell and buy side targets to be liquidated\n        // * returns attacker cuts to them\n        // * aggregates any returned fees from unauthorized (attacking) attempts\n        maintainerCut = calcLiquidationAmounts(\n            liquidationCandidates,\n            isAuthorized\n        );\n\n        uint256 sale2pegAmount = liquidateToPeg();\n        uint256 peg2targetCost = liquidateFromPeg();\n        delete liquidationTokens;\n\n        // this may be a bit imprecise, since individual shortfalls may be obscured\n        // by overall returns and the maintainer cut is taken out of the net total,\n        // but it gives us the general picture\n        uint256 costWithCut =\n            (peg2targetCost * (100 + MAINTAINER_CUT_PERCENT)) / 100;\n        if (costWithCut > sale2pegAmount) {\n            emit LiquidationShortfall(costWithCut - sale2pegAmount);\n            canTakeNow =\n                canTakeNow &&\n                IERC20(peg).balanceOf(fund()) > costWithCut;\n        }\n\n        address loser = address(0);\n        if (!canTakeNow) {\n            // whoever is the current responsible maintenance staker\n            // and liable to lose their stake\n            loser = Admin(admin()).getUpdatedCurrentStaker();\n        }\n\n        // iterate over traders and send back their money\n        // as well as giving attackers their due, in case caller isn't authorized\n        for (\n            uint256 traderIdx = 0;\n            tradersToLiquidate.length > traderIdx;\n            traderIdx++\n        ) {\n            address traderAddress = tradersToLiquidate[traderIdx];\n            CrossMarginAccount storage account = marginAccounts[traderAddress];\n\n            uint256 holdingsValue = holdingsInPeg(account);\n            uint256 borrowValue = loanInPeg(account);\n\n            // 5% of value borrowed\n            uint256 maintainerCut4Account =\n                (borrowValue * MAINTAINER_CUT_PERCENT) / 100;\n            maintainerCut += maintainerCut4Account;\n\n            if (!canTakeNow) {\n                // This could theoretically lead to a previous attackers\n                // record being overwritten, but only if the trader restarts\n                // their account and goes back into the red within the short time window\n                // which would be a costly attack requiring collusion without upside\n                AccountLiqRecord storage liqAttackRecord =\n                    stakeAttackRecords[traderAddress];\n                liqAttackRecord.amount = maintainerCut4Account;\n                liqAttackRecord.stakeAttacker = msg.sender;\n                liqAttackRecord.blockNum = block.number;\n                liqAttackRecord.loser = loser;\n            }\n\n            // send back trader money\n\n            // include 1% for protocol\n            uint256 forfeited =\n                maintainerCut4Account + (borrowValue * 101) / 100;\n            if (holdingsValue > forfeited) {\n                // send remaining funds back to trader\n                Fund(fund()).withdraw(\n                    PriceAware.peg,\n                    traderAddress,\n                    holdingsValue - forfeited\n                );\n            }\n\n            emit AccountLiquidated(traderAddress);\n            deleteAccount(account);\n        }\n\n        avgLiquidationPerCall =\n            (avgLiquidationPerCall * 99 + maintainerCut) /\n            100;\n\n        if (canTakeNow) {\n            Fund(fund()).withdraw(PriceAware.peg, msg.sender, maintainerCut);\n        }\n\n        address currentMaintainer = Admin(admin()).getUpdatedCurrentStaker();\n        if (isAuthorized) {\n            if (maintenanceFailures[currentMaintainer] > maintainerCut) {\n                maintenanceFailures[currentMaintainer] -= maintainerCut;\n            } else {\n                maintenanceFailures[currentMaintainer] = 0;\n            }\n        } else {\n            maintenanceFailures[currentMaintainer] += maintainerCut;\n        }\n    }\n}\n"
58     },
59     "contracts/CrossMarginTrading.sol": {
60       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./Fund.sol\";\nimport \"./Lending.sol\";\nimport \"./RoleAware.sol\";\nimport \"./CrossMarginLiquidation.sol\";\n\n// Goal: all external functions only accessible to margintrader role\n// except for view functions of course\n\ncontract CrossMarginTrading is CrossMarginLiquidation, IMarginTrading {\n    constructor(address _peg, address _roles)\n        RoleAware(_roles)\n        PriceAware(_peg)\n    {}\n\n    /// @dev admin function to set the token cap\n    function setTokenCap(address token, uint256 cap)\n        external\n        onlyOwnerExecActivator\n    {\n        tokenCaps[token] = cap;\n    }\n\n    /// @dev setter for cooling off period for withdrawing funds after deposit\n    function setCoolingOffPeriod(uint256 blocks) external onlyOwnerExec {\n        coolingOffPeriod = blocks;\n    }\n\n    /// @dev admin function to set leverage\n    function setLeveragePercent(uint256 _leveragePercent)\n        external\n        onlyOwnerExec\n    {\n        leveragePercent = _leveragePercent;\n    }\n\n    /// @dev admin function to set liquidation threshold\n    function setLiquidationThresholdPercent(uint256 threshold)\n        external\n        onlyOwnerExec\n    {\n        liquidationThresholdPercent = threshold;\n    }\n\n    /// @dev gets called by router to affirm a deposit to an account\n    function registerDeposit(\n        address trader,\n        address token,\n        uint256 depositAmount\n    ) external override returns (uint256 extinguishableDebt) {\n        require(isMarginTrader(msg.sender), \"Calling contr. not authorized\");\n\n        CrossMarginAccount storage account = marginAccounts[trader];\n        account.lastDepositBlock = block.number;\n\n        if (account.borrowed[token] > 0) {\n            extinguishableDebt = min(depositAmount, account.borrowed[token]);\n            extinguishDebt(account, token, extinguishableDebt);\n            totalShort[token] -= extinguishableDebt;\n        }\n\n        // no overflow because depositAmount >= extinguishableDebt\n        uint256 addedHolding = depositAmount - extinguishableDebt;\n        _registerDeposit(account, token, addedHolding);\n    }\n\n    function _registerDeposit(\n        CrossMarginAccount storage account,\n        address token,\n        uint256 addedHolding\n    ) internal {\n        addHolding(account, token, addedHolding);\n\n        totalLong[token] += addedHolding;\n        require(\n            tokenCaps[token] >= totalLong[token],\n            \"Exceeds global token cap\"\n        );\n    }\n\n    /// @dev gets called by router to affirm borrowing event\n    function registerBorrow(\n        address trader,\n        address borrowToken,\n        uint256 borrowAmount\n    ) external override {\n        require(isMarginTrader(msg.sender), \"Calling contr. not authorized\");\n        CrossMarginAccount storage account = marginAccounts[trader];\n        addHolding(account, borrowToken, borrowAmount);\n        _registerBorrow(account, borrowToken, borrowAmount);\n    }\n\n    function _registerBorrow(\n        CrossMarginAccount storage account,\n        address borrowToken,\n        uint256 borrowAmount\n    ) internal {\n        totalShort[borrowToken] += borrowAmount;\n        totalLong[borrowToken] += borrowAmount;\n        require(\n            tokenCaps[borrowToken] >= totalShort[borrowToken] &&\n                tokenCaps[borrowToken] >= totalLong[borrowToken],\n            \"Exceeds global token cap\"\n        );\n\n        borrow(account, borrowToken, borrowAmount);\n    }\n\n    /// @dev gets called by router to affirm withdrawal of tokens from account\n    function registerWithdrawal(\n        address trader,\n        address withdrawToken,\n        uint256 withdrawAmount\n    ) external override {\n        require(isMarginTrader(msg.sender), \"Calling contr not authorized\");\n        CrossMarginAccount storage account = marginAccounts[trader];\n        _registerWithdrawal(account, withdrawToken, withdrawAmount);\n    }\n\n    function _registerWithdrawal(\n        CrossMarginAccount storage account,\n        address withdrawToken,\n        uint256 withdrawAmount\n    ) internal {\n        require(\n            block.number > account.lastDepositBlock + coolingOffPeriod,\n            \"No withdrawal soon after deposit\"\n        );\n\n        totalLong[withdrawToken] -= withdrawAmount;\n        // throws on underflow\n        account.holdings[withdrawToken] =\n            account.holdings[withdrawToken] -\n            withdrawAmount;\n        require(positiveBalance(account), \"Insufficient balance\");\n    }\n\n    /// @dev overcollateralized borrowing on a cross margin account, called by router\n    function registerOvercollateralizedBorrow(\n        address trader,\n        address depositToken,\n        uint256 depositAmount,\n        address borrowToken,\n        uint256 withdrawAmount\n    ) external override {\n        require(isMarginTrader(msg.sender), \"Calling contr. not authorized\");\n\n        CrossMarginAccount storage account = marginAccounts[trader];\n\n        _registerDeposit(account, depositToken, depositAmount);\n        _registerBorrow(account, borrowToken, withdrawAmount);\n        _registerWithdrawal(account, borrowToken, withdrawAmount);\n\n        account.lastDepositBlock = block.number;\n    }\n\n    /// @dev gets called by router to register a trade and borrow and extinguish as necessary\n    function registerTradeAndBorrow(\n        address trader,\n        address tokenFrom,\n        address tokenTo,\n        uint256 inAmount,\n        uint256 outAmount\n    )\n        external\n        override\n        returns (uint256 extinguishableDebt, uint256 borrowAmount)\n    {\n        require(isMarginTrader(msg.sender), \"Calling contr. not an authorized\");\n\n        CrossMarginAccount storage account = marginAccounts[trader];\n\n        if (account.borrowed[tokenTo] > 0) {\n            extinguishableDebt = min(outAmount, account.borrowed[tokenTo]);\n            extinguishDebt(account, tokenTo, extinguishableDebt);\n            totalShort[tokenTo] -= extinguishableDebt;\n        }\n\n        uint256 sellAmount = inAmount;\n        uint256 fromHoldings = account.holdings[tokenFrom];\n        if (inAmount > fromHoldings) {\n            sellAmount = fromHoldings;\n            /// won't overflow\n            borrowAmount = inAmount - sellAmount;\n        }\n\n        if (inAmount > borrowAmount) {\n            totalLong[tokenFrom] -= inAmount - borrowAmount;\n        }\n        if (outAmount > extinguishableDebt) {\n            totalLong[tokenTo] += outAmount - extinguishableDebt;\n        }\n        require(\n            tokenCaps[tokenTo] >= totalLong[tokenTo],\n            \"Exceeds global token cap\"\n        );\n\n        adjustAmounts(\n            account,\n            tokenFrom,\n            tokenTo,\n            sellAmount,\n            outAmount - extinguishableDebt\n        );\n\n        if (borrowAmount > 0) {\n            totalShort[tokenFrom] += borrowAmount;\n            require(\n                tokenCaps[tokenFrom] >= totalShort[tokenFrom],\n                \"Exceeds global token cap\"\n            );\n            borrow(account, tokenFrom, borrowAmount);\n        }\n    }\n\n    /// @dev can get called by router to register the dissolution of an account\n    function registerLiquidation(address trader) external override {\n        require(isMarginTrader(msg.sender), \"Calling contr. not authorized\");\n        CrossMarginAccount storage account = marginAccounts[trader];\n        require(loanInPeg(account) == 0, \"Can't liquidate: borrowing\");\n\n        deleteAccount(account);\n    }\n\n    /// @dev currently holding in this token\n    function viewBalanceInToken(address trader, address token)\n        external\n        view\n        returns (uint256)\n    {\n        CrossMarginAccount storage account = marginAccounts[trader];\n        return account.holdings[token];\n    }\n\n    /// @dev view function to display account held assets state\n    function getHoldingAmounts(address trader)\n        external\n        view\n        override\n        returns (\n            address[] memory holdingTokens,\n            uint256[] memory holdingAmounts\n        )\n    {\n        CrossMarginAccount storage account = marginAccounts[trader];\n        holdingTokens = account.holdingTokens;\n\n        holdingAmounts = new uint256[](account.holdingTokens.length);\n        for (uint256 idx = 0; holdingTokens.length > idx; idx++) {\n            address tokenAddress = holdingTokens[idx];\n            holdingAmounts[idx] = account.holdings[tokenAddress];\n        }\n    }\n\n    /// @dev view function to display account borrowing state\n    function getBorrowAmounts(address trader)\n        external\n        view\n        override\n        returns (address[] memory borrowTokens, uint256[] memory borrowAmounts)\n    {\n        CrossMarginAccount storage account = marginAccounts[trader];\n        borrowTokens = account.borrowTokens;\n\n        borrowAmounts = new uint256[](account.borrowTokens.length);\n        for (uint256 idx = 0; borrowTokens.length > idx; idx++) {\n            address tokenAddress = borrowTokens[idx];\n            borrowAmounts[idx] = Lending(lending()).viewWithBorrowInterest(\n                account.borrowed[tokenAddress],\n                tokenAddress,\n                account.borrowedYieldQuotientsFP[tokenAddress]\n            );\n        }\n    }\n\n    /// @dev view function to get loan amount in peg\n    function viewLoanInPeg(address trader)\n        external\n        view\n        returns (uint256 amount)\n    {\n        CrossMarginAccount storage account = marginAccounts[trader];\n        return\n            viewTokensInPegWithYield(\n                account.borrowTokens,\n                account.borrowed,\n                account.borrowedYieldQuotientsFP\n            );\n    }\n\n    /// @dev total of assets of account, expressed in reference currency\n    function viewHoldingsInPeg(address trader) external view returns (uint256) {\n        CrossMarginAccount storage account = marginAccounts[trader];\n        return viewTokensInPeg(account.holdingTokens, account.holdings);\n    }\n\n    /// @dev can this trader be liquidated?\n    function canBeLiquidated(address trader) external view returns (bool) {\n        CrossMarginAccount storage account = marginAccounts[trader];\n        uint256 loan =\n            viewTokensInPegWithYield(\n                account.borrowTokens,\n                account.borrowed,\n                account.borrowedYieldQuotientsFP\n            );\n\n        uint256 holdings =\n            viewTokensInPeg(account.holdingTokens, account.holdings);\n\n        return liquidationThresholdPercent * loan >= 100 * holdings;\n    }\n}\n"
61     },
62     "contracts/Fund.sol": {
63       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"./RoleAware.sol\";\n\n/// @title Manage funding\ncontract Fund is RoleAware {\n    using SafeERC20 for IERC20;\n    /// wrapped ether\n    address public immutable WETH;\n\n    constructor(address _WETH, address _roles) RoleAware(_roles) {\n        WETH = _WETH;\n    }\n\n    /// Deposit an active token\n    function deposit(address depositToken, uint256 depositAmount) external {\n        IERC20(depositToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            depositAmount\n        );\n    }\n\n    /// Deposit token on behalf of `sender`\n    function depositFor(\n        address sender,\n        address depositToken,\n        uint256 depositAmount\n    ) external {\n        require(isFundTransferer(msg.sender), \"Unauthorized deposit\");\n        IERC20(depositToken).safeTransferFrom(\n            sender,\n            address(this),\n            depositAmount\n        );\n    }\n\n    /// Deposit to wrapped ether\n    function depositToWETH() external payable {\n        IWETH(WETH).deposit{value: msg.value}();\n    }\n\n    // withdrawers role\n    function withdraw(\n        address withdrawalToken,\n        address recipient,\n        uint256 withdrawalAmount\n    ) external {\n        require(isFundTransferer(msg.sender), \"Unauthorized withdraw\");\n        IERC20(withdrawalToken).safeTransfer(recipient, withdrawalAmount);\n    }\n\n    // withdrawers role\n    function withdrawETH(address recipient, uint256 withdrawalAmount) external {\n        require(isFundTransferer(msg.sender), \"Unauthorized withdraw\");\n        IWETH(WETH).withdraw(withdrawalAmount);\n        Address.sendValue(payable(recipient), withdrawalAmount);\n    }\n}\n"
64     },
65     "contracts/HourlyBondSubscriptionLending.sol": {
66       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./BaseLending.sol\";\n\nstruct HourlyBond {\n    uint256 amount;\n    uint256 yieldQuotientFP;\n    uint256 moduloHour;\n}\n\n/// @title Here we offer subscriptions to auto-renewing hourly bonds\n/// Funds are locked in for an 50 minutes per hour, while interest rates float\nabstract contract HourlyBondSubscriptionLending is BaseLending {\n    mapping(address => YieldAccumulator) hourlyBondYieldAccumulators;\n\n    uint256 constant RATE_UPDATE_WINDOW = 10 minutes;\n    uint256 public withdrawalWindow = 20 minutes;\n    uint256 constant MAX_HOUR_UPDATE = 4;\n    // issuer => holder => bond record\n    mapping(address => mapping(address => HourlyBond))\n        public hourlyBondAccounts;\n\n    uint256 public borrowingFactorPercent = 200;\n\n    uint256 constant borrowMinAPR = 6;\n    uint256 constant borrowMinHourlyYield =\n        FP48 + (borrowMinAPR * FP48) / 100 / hoursPerYear;\n\n    function _makeHourlyBond(\n        address issuer,\n        address holder,\n        uint256 amount\n    ) internal {\n        HourlyBond storage bond = hourlyBondAccounts[issuer][holder];\n        updateHourlyBondAmount(issuer, bond);\n\n        YieldAccumulator storage yieldAccumulator =\n            hourlyBondYieldAccumulators[issuer];\n        bond.yieldQuotientFP = yieldAccumulator.accumulatorFP;\n        if (bond.amount == 0) {\n            bond.moduloHour = block.timestamp % (1 hours);\n        }\n        bond.amount += amount;\n        lendingMeta[issuer].totalLending += amount;\n    }\n\n    function updateHourlyBondAmount(address issuer, HourlyBond storage bond)\n        internal\n    {\n        uint256 yieldQuotientFP = bond.yieldQuotientFP;\n        if (yieldQuotientFP > 0) {\n            YieldAccumulator storage yA =\n                getUpdatedHourlyYield(\n                    issuer,\n                    hourlyBondYieldAccumulators[issuer],\n                    RATE_UPDATE_WINDOW\n                );\n\n            uint256 oldAmount = bond.amount;\n\n            bond.amount = applyInterest(\n                bond.amount,\n                yA.accumulatorFP,\n                yieldQuotientFP\n            );\n\n            uint256 deltaAmount = bond.amount - oldAmount;\n            lendingMeta[issuer].totalLending += deltaAmount;\n        }\n    }\n\n    // Retrieves bond balance for issuer and holder\n    function viewHourlyBondAmount(address issuer, address holder)\n        public\n        view\n        returns (uint256)\n    {\n        HourlyBond storage bond = hourlyBondAccounts[issuer][holder];\n        uint256 yieldQuotientFP = bond.yieldQuotientFP;\n\n        uint256 cumulativeYield =\n            viewCumulativeYieldFP(\n                hourlyBondYieldAccumulators[issuer],\n                block.timestamp\n            );\n\n        if (yieldQuotientFP > 0) {\n            return applyInterest(bond.amount, cumulativeYield, yieldQuotientFP);\n        } else {\n            return bond.amount;\n        }\n    }\n\n    function _withdrawHourlyBond(\n        address issuer,\n        HourlyBond storage bond,\n        uint256 amount\n    ) internal {\n        // how far the current hour has advanced (relative to acccount hourly clock)\n        uint256 currentOffset = (block.timestamp - bond.moduloHour) % (1 hours);\n\n        require(\n            withdrawalWindow >= currentOffset,\n            \"Tried withdrawing outside subscription cancellation time window\"\n        );\n\n        bond.amount -= amount;\n        lendingMeta[issuer].totalLending -= amount;\n    }\n\n    function calcCumulativeYieldFP(\n        YieldAccumulator storage yieldAccumulator,\n        uint256 timeDelta\n    ) internal view returns (uint256 accumulatorFP) {\n        uint256 secondsDelta = timeDelta % (1 hours);\n        // linearly interpolate interest for seconds\n        // FP * FP * 1 / (FP * 1) = FP\n        accumulatorFP =\n            yieldAccumulator.accumulatorFP +\n            (yieldAccumulator.accumulatorFP *\n                (yieldAccumulator.hourlyYieldFP - FP48) *\n                secondsDelta) /\n            (FP48 * 1 hours);\n\n        uint256 hoursDelta = timeDelta / (1 hours);\n        if (hoursDelta > 0) {\n            uint256 accumulatorBeforeFP = accumulatorFP;\n            for (uint256 i = 0; hoursDelta > i && MAX_HOUR_UPDATE > i; i++) {\n                // FP48 * FP48 / FP48 = FP48\n                accumulatorFP =\n                    (accumulatorFP * yieldAccumulator.hourlyYieldFP) /\n                    FP48;\n            }\n\n            // a lot of time has passed\n            if (hoursDelta > MAX_HOUR_UPDATE) {\n                // apply interest in non-compounding way\n                accumulatorFP +=\n                    ((accumulatorFP - accumulatorBeforeFP) *\n                        (hoursDelta - MAX_HOUR_UPDATE)) /\n                    MAX_HOUR_UPDATE;\n            }\n        }\n    }\n\n    /// @dev updates yield accumulators for both borrowing and lending\n    /// issuer address represents a token\n    function updateHourlyYield(address issuer)\n        public\n        returns (uint256 hourlyYield)\n    {\n        return\n            getUpdatedHourlyYield(\n                issuer,\n                hourlyBondYieldAccumulators[issuer],\n                RATE_UPDATE_WINDOW\n            )\n                .hourlyYieldFP;\n    }\n\n    /// @dev updates yield accumulators for both borrowing and lending\n    function getUpdatedHourlyYield(\n        address issuer,\n        YieldAccumulator storage accumulator,\n        uint256 window\n    ) internal returns (YieldAccumulator storage) {\n        uint256 lastUpdated = accumulator.lastUpdated;\n        uint256 timeDelta = (block.timestamp - lastUpdated);\n\n        if (timeDelta > window) {\n            YieldAccumulator storage borrowAccumulator =\n                borrowYieldAccumulators[issuer];\n\n            accumulator.accumulatorFP = calcCumulativeYieldFP(\n                accumulator,\n                timeDelta\n            );\n\n            LendingMetadata storage meta = lendingMeta[issuer];\n\n            accumulator.hourlyYieldFP = currentLendingRateFP(\n                meta.totalLending,\n                meta.totalBorrowed\n            );\n            accumulator.lastUpdated = block.timestamp;\n\n            updateBorrowYieldAccu(borrowAccumulator);\n\n            borrowAccumulator.hourlyYieldFP = max(\n                borrowMinHourlyYield,\n                FP48 +\n                    (borrowingFactorPercent *\n                        (accumulator.hourlyYieldFP - FP48)) /\n                    100\n            );\n        }\n\n        return accumulator;\n    }\n\n    function updateBorrowYieldAccu(YieldAccumulator storage borrowAccumulator)\n        internal\n    {\n        uint256 timeDelta = block.timestamp - borrowAccumulator.lastUpdated;\n\n        if (timeDelta > RATE_UPDATE_WINDOW) {\n            borrowAccumulator.accumulatorFP = calcCumulativeYieldFP(\n                borrowAccumulator,\n                timeDelta\n            );\n\n            borrowAccumulator.lastUpdated = block.timestamp;\n        }\n    }\n\n    function getUpdatedBorrowYieldAccuFP(address issuer)\n        external\n        returns (uint256)\n    {\n        YieldAccumulator storage yA = borrowYieldAccumulators[issuer];\n        updateBorrowYieldAccu(yA);\n        return yA.accumulatorFP;\n    }\n\n    function viewCumulativeYieldFP(\n        YieldAccumulator storage yA,\n        uint256 timestamp\n    ) internal view returns (uint256) {\n        uint256 timeDelta = (timestamp - yA.lastUpdated);\n        if (timeDelta > RATE_UPDATE_WINDOW) {\n            return calcCumulativeYieldFP(yA, timeDelta);\n        } else {\n            return yA.accumulatorFP;\n        }\n    }\n}\n"
67     },
68     "contracts/Lending.sol": {
69       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Fund.sol\";\nimport \"./HourlyBondSubscriptionLending.sol\";\nimport \"../libraries/IncentiveReporter.sol\";\n\n// TODO activate bonds for lending\n\n/// @title Manage lending for a variety of bond issuers\ncontract Lending is RoleAware, HourlyBondSubscriptionLending {\n    /// mapping issuers to tokens\n    /// (in crossmargin, the issuers are tokens  themselves)\n    mapping(address => address) public issuerTokens;\n\n    /// In case of shortfall, adjust debt\n    mapping(address => uint256) public haircuts;\n\n    /// map of available issuers\n    mapping(address => bool) public activeIssuers;\n\n    uint256 constant BORROW_RATE_UPDATE_WINDOW = 60 minutes;\n\n    constructor(address _roles) RoleAware(_roles) {}\n\n    /// Make a issuer available for protocol\n    function activateIssuer(address issuer) external {\n        activateIssuer(issuer, issuer);\n    }\n\n    /// Make issuer != token available for protocol (isol. margin)\n    function activateIssuer(address issuer, address token)\n        public\n        onlyOwnerExecActivator\n    {\n        activeIssuers[issuer] = true;\n        issuerTokens[issuer] = token;\n    }\n\n    /// Remove a issuer from trading availability\n    function deactivateIssuer(address issuer) external onlyOwnerExecActivator {\n        activeIssuers[issuer] = false;\n    }\n\n    /// Set lending cap\n    function setLendingCap(address issuer, uint256 cap)\n        external\n        onlyOwnerExecActivator\n    {\n        lendingMeta[issuer].lendingCap = cap;\n    }\n\n    /// Set withdrawal window\n    function setWithdrawalWindow(uint256 window) external onlyOwnerExec {\n        withdrawalWindow = window;\n    }\n\n    function setNormalRatePerPercent(uint256 rate) external onlyOwnerExec {\n        normalRatePerPercent = rate;\n    }\n\n    function setHighRatePerPercent(uint256 rate) external onlyOwnerExec {\n        highRatePerPercent = rate;\n    }\n\n    /// Set hourly yield APR for issuer\n    function setHourlyYieldAPR(address issuer, uint256 aprPercent)\n        external\n        onlyOwnerExecActivator\n    {\n        YieldAccumulator storage yieldAccumulator =\n            hourlyBondYieldAccumulators[issuer];\n\n        if (yieldAccumulator.accumulatorFP == 0) {\n            uint256 yieldFP = FP48 + (FP48 * aprPercent) / 100 / (24 * 365);\n            hourlyBondYieldAccumulators[issuer] = YieldAccumulator({\n                accumulatorFP: FP48,\n                lastUpdated: block.timestamp,\n                hourlyYieldFP: yieldFP\n            });\n        } else {\n            YieldAccumulator storage yA =\n                getUpdatedHourlyYield(\n                    issuer,\n                    yieldAccumulator,\n                    RATE_UPDATE_WINDOW\n                );\n            yA.hourlyYieldFP = (FP48 * (100 + aprPercent)) / 100 / (24 * 365);\n        }\n    }\n\n    /// @dev how much interest has accrued to a borrowed balance over time\n    function applyBorrowInterest(\n        uint256 balance,\n        address issuer,\n        uint256 yieldQuotientFP\n    ) external returns (uint256 balanceWithInterest, uint256 accumulatorFP) {\n        require(isBorrower(msg.sender), \"Not approved call\");\n\n        YieldAccumulator storage yA = borrowYieldAccumulators[issuer];\n        updateBorrowYieldAccu(yA);\n        accumulatorFP = yA.accumulatorFP;\n\n        balanceWithInterest = applyInterest(\n            balance,\n            accumulatorFP,\n            yieldQuotientFP\n        );\n\n        uint256 deltaAmount = balanceWithInterest - balance;\n        LendingMetadata storage meta = lendingMeta[issuer];\n        meta.totalBorrowed += deltaAmount;\n    }\n\n    /// @dev view function to get balance with borrowing interest applied\n    function viewWithBorrowInterest(\n        uint256 balance,\n        address issuer,\n        uint256 yieldQuotientFP\n    ) external view returns (uint256) {\n        uint256 accumulatorFP =\n            viewCumulativeYieldFP(\n                borrowYieldAccumulators[issuer],\n                block.timestamp\n            );\n        return applyInterest(balance, accumulatorFP, yieldQuotientFP);\n    }\n\n    /// @dev gets called by router to register if a trader borrows issuers\n    function registerBorrow(address issuer, uint256 amount) external {\n        require(isBorrower(msg.sender), \"Not approved borrower\");\n        require(activeIssuers[issuer], \"Not approved issuer\");\n\n        LendingMetadata storage meta = lendingMeta[issuer];\n        meta.totalBorrowed += amount;\n\n        getUpdatedHourlyYield(\n            issuer,\n            hourlyBondYieldAccumulators[issuer],\n            BORROW_RATE_UPDATE_WINDOW\n        );\n\n        require(\n            meta.totalLending >= meta.totalBorrowed,\n            \"Insufficient lending\"\n        );\n    }\n\n    /// @dev gets called when external sources provide lending\n    function registerLend(address issuer, uint256 amount) external {\n        require(isLender(msg.sender), \"Not an approved lender\");\n        require(activeIssuers[issuer], \"Not approved issuer\");\n        LendingMetadata storage meta = lendingMeta[issuer];\n        meta.totalLending += amount;\n\n        getUpdatedHourlyYield(\n            issuer,\n            hourlyBondYieldAccumulators[issuer],\n            RATE_UPDATE_WINDOW\n        );\n    }\n\n    /// @dev gets called when external sources pay withdraw their bobnd\n    function registerWithdrawal(address issuer, uint256 amount) external {\n        require(isLender(msg.sender), \"Not an approved lender\");\n        require(activeIssuers[issuer], \"Not approved issuer\");\n        LendingMetadata storage meta = lendingMeta[issuer];\n        meta.totalLending -= amount;\n\n        getUpdatedHourlyYield(\n            issuer,\n            hourlyBondYieldAccumulators[issuer],\n            RATE_UPDATE_WINDOW\n        );\n    }\n\n    /// @dev gets called by router if loan is extinguished\n    function payOff(address issuer, uint256 amount) external {\n        require(isBorrower(msg.sender), \"Not approved borrower\");\n        lendingMeta[issuer].totalBorrowed -= amount;\n    }\n\n    /// @dev get the borrow yield for a specific issuer/token\n    function viewAccumulatedBorrowingYieldFP(address issuer)\n        external\n        view\n        returns (uint256)\n    {\n        YieldAccumulator storage yA = borrowYieldAccumulators[issuer];\n        return viewCumulativeYieldFP(yA, block.timestamp);\n    }\n\n    function viewAPRPer10k(YieldAccumulator storage yA)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 hourlyYieldFP = yA.hourlyYieldFP;\n\n        uint256 aprFP =\n            ((hourlyYieldFP * 10_000 - FP48 * 10_000) * 365 days) / (1 hours);\n\n        return aprFP / FP48;\n    }\n\n    /// @dev get current borrowing interest per 10k for a token / issuer\n    function viewBorrowAPRPer10k(address issuer)\n        external\n        view\n        returns (uint256)\n    {\n        return viewAPRPer10k(borrowYieldAccumulators[issuer]);\n    }\n\n    /// @dev get current lending APR per 10k for a token / issuer\n    function viewHourlyBondAPRPer10k(address issuer)\n        external\n        view\n        returns (uint256)\n    {\n        return viewAPRPer10k(hourlyBondYieldAccumulators[issuer]);\n    }\n\n    /// @dev In a liquidity crunch make a fallback bond until liquidity is good again\n    function makeFallbackBond(\n        address issuer,\n        address holder,\n        uint256 amount\n    ) external {\n        require(isLender(msg.sender), \"Not an approved lender\");\n        _makeHourlyBond(issuer, holder, amount);\n    }\n\n    /// @dev withdraw an hour bond\n    function withdrawHourlyBond(address issuer, uint256 amount) external {\n        HourlyBond storage bond = hourlyBondAccounts[issuer][msg.sender];\n        // apply all interest\n        updateHourlyBondAmount(issuer, bond);\n        super._withdrawHourlyBond(issuer, bond, amount);\n\n        if (bond.amount == 0) {\n            delete hourlyBondAccounts[issuer][msg.sender];\n        }\n\n        disburse(issuer, msg.sender, amount);\n\n        IncentiveReporter.subtractFromClaimAmount(issuer, msg.sender, amount);\n    }\n\n    /// Shut down hourly bond account for `issuer`\n    function closeHourlyBondAccount(address issuer) external {\n        HourlyBond storage bond = hourlyBondAccounts[issuer][msg.sender];\n        // apply all interest\n        updateHourlyBondAmount(issuer, bond);\n\n        uint256 amount = bond.amount;\n        super._withdrawHourlyBond(issuer, bond, amount);\n\n        disburse(issuer, msg.sender, amount);\n\n        delete hourlyBondAccounts[issuer][msg.sender];\n\n        IncentiveReporter.subtractFromClaimAmount(issuer, msg.sender, amount);\n    }\n\n    /// @dev buy hourly bond subscription\n    function buyHourlyBondSubscription(address issuer, uint256 amount)\n        external\n    {\n        require(activeIssuers[issuer], \"Not approved issuer\");\n\n        collectToken(issuer, msg.sender, amount);\n\n        super._makeHourlyBond(issuer, msg.sender, amount);\n\n        IncentiveReporter.addToClaimAmount(issuer, msg.sender, amount);\n    }\n\n    function initBorrowYieldAccumulator(address issuer)\n        external\n        onlyOwnerExecActivator\n    {\n        YieldAccumulator storage yA = borrowYieldAccumulators[issuer];\n        require(yA.accumulatorFP == 0, \"don't re-initialize\");\n\n        yA.accumulatorFP = FP48;\n        yA.lastUpdated = block.timestamp;\n        yA.hourlyYieldFP = FP48 + (FP48 * borrowMinAPR) / 100 / (365 * 24);\n    }\n\n    function setBorrowingFactorPercent(uint256 borrowingFactor)\n        external\n        onlyOwnerExec\n    {\n        borrowingFactorPercent = borrowingFactor;\n    }\n\n    function issuanceBalance(address issuer)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        address token = issuerTokens[issuer];\n        if (token == issuer) {\n            // cross margin\n            return IERC20(token).balanceOf(fund());\n        } else {\n            return lendingMeta[issuer].totalLending - haircuts[issuer];\n        }\n    }\n\n    function disburse(\n        address issuer,\n        address recipient,\n        uint256 amount\n    ) internal {\n        uint256 haircutAmount = haircuts[issuer];\n        if (haircutAmount > 0 && amount > 0) {\n            uint256 totalLending = lendingMeta[issuer].totalLending;\n            uint256 adjustment =\n                (amount * min(totalLending, haircutAmount)) / totalLending;\n            amount = amount - adjustment;\n            haircuts[issuer] -= adjustment;\n        }\n\n        address token = issuerTokens[issuer];\n        Fund(fund()).withdraw(token, recipient, amount);\n    }\n\n    function collectToken(\n        address issuer,\n        address source,\n        uint256 amount\n    ) internal {\n        Fund(fund()).depositFor(source, issuer, amount);\n    }\n\n    function haircut(uint256 amount) external {\n        haircuts[msg.sender] += amount;\n    }\n}\n"
70     },
71     "contracts/MarginRouter.sol": {
72       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./RoleAware.sol\";\nimport \"../interfaces/IMarginTrading.sol\";\nimport \"./Lending.sol\";\nimport \"./Admin.sol\";\nimport \"./BaseRouter.sol\";\nimport \"../libraries/IncentiveReporter.sol\";\n\n/// @title Top level transaction controller\ncontract MarginRouter is RoleAware, BaseRouter {\n    event AccountUpdated(address indexed trader);\n\n    uint256 public constant mswapFeesPer10k = 10;\n    address public immutable WETH;\n\n    constructor(address _WETH, address _roles) RoleAware(_roles) {\n        WETH = _WETH;\n    }\n\n    ///////////////////////////\n    // Cross margin endpoints\n    ///////////////////////////\n\n    /// @notice traders call this to deposit funds on cross margin\n    function crossDeposit(address depositToken, uint256 depositAmount)\n        external\n    {\n        Fund(fund()).depositFor(msg.sender, depositToken, depositAmount);\n\n        uint256 extinguishAmount =\n            IMarginTrading(crossMarginTrading()).registerDeposit(\n                msg.sender,\n                depositToken,\n                depositAmount\n            );\n        if (extinguishAmount > 0) {\n            Lending(lending()).payOff(depositToken, extinguishAmount);\n            IncentiveReporter.subtractFromClaimAmount(\n                depositToken,\n                msg.sender,\n                extinguishAmount\n            );\n        }\n        emit AccountUpdated(msg.sender);\n    }\n\n    /// @notice deposit wrapped ehtereum into cross margin account\n    function crossDepositETH() external payable {\n        Fund(fund()).depositToWETH{value: msg.value}();\n        uint256 extinguishAmount =\n            IMarginTrading(crossMarginTrading()).registerDeposit(\n                msg.sender,\n                WETH,\n                msg.value\n            );\n        if (extinguishAmount > 0) {\n            Lending(lending()).payOff(WETH, extinguishAmount);\n            IncentiveReporter.subtractFromClaimAmount(\n                WETH,\n                msg.sender,\n                extinguishAmount\n            );\n        }\n        emit AccountUpdated(msg.sender);\n    }\n\n    /// @notice withdraw deposits/earnings from cross margin account\n    function crossWithdraw(address withdrawToken, uint256 withdrawAmount)\n        external\n    {\n        IMarginTrading(crossMarginTrading()).registerWithdrawal(\n            msg.sender,\n            withdrawToken,\n            withdrawAmount\n        );\n        Fund(fund()).withdraw(withdrawToken, msg.sender, withdrawAmount);\n        emit AccountUpdated(msg.sender);\n    }\n\n    /// @notice withdraw ethereum from cross margin account\n    function crossWithdrawETH(uint256 withdrawAmount) external {\n        IMarginTrading(crossMarginTrading()).registerWithdrawal(\n            msg.sender,\n            WETH,\n            withdrawAmount\n        );\n        Fund(fund()).withdrawETH(msg.sender, withdrawAmount);\n        emit AccountUpdated(msg.sender);\n    }\n\n    /// @notice borrow into cross margin trading account\n    function crossBorrow(address borrowToken, uint256 borrowAmount) external {\n        Lending(lending()).registerBorrow(borrowToken, borrowAmount);\n        IMarginTrading(crossMarginTrading()).registerBorrow(\n            msg.sender,\n            borrowToken,\n            borrowAmount\n        );\n\n        IncentiveReporter.addToClaimAmount(\n            borrowToken,\n            msg.sender,\n            borrowAmount\n        );\n        emit AccountUpdated(msg.sender);\n    }\n\n    /// @notice convenience function to perform overcollateralized borrowing\n    /// against a cross margin account.\n    /// @dev caution: the account still has to have a positive balaance at the end\n    /// of the withdraw. So an underwater account may not be able to withdraw\n    function crossOvercollateralizedBorrow(\n        address depositToken,\n        uint256 depositAmount,\n        address borrowToken,\n        uint256 withdrawAmount\n    ) external {\n        Fund(fund()).depositFor(msg.sender, depositToken, depositAmount);\n\n        Lending(lending()).registerBorrow(borrowToken, withdrawAmount);\n        IMarginTrading(crossMarginTrading()).registerOvercollateralizedBorrow(\n            msg.sender,\n            depositToken,\n            depositAmount,\n            borrowToken,\n            withdrawAmount\n        );\n\n        Fund(fund()).withdraw(borrowToken, msg.sender, withdrawAmount);\n        IncentiveReporter.addToClaimAmount(\n            borrowToken,\n            msg.sender,\n            withdrawAmount\n        );\n        emit AccountUpdated(msg.sender);\n    }\n\n    /// @notice close an account that is no longer borrowing and return gains\n    function crossCloseAccount() external {\n        (address[] memory holdingTokens, uint256[] memory holdingAmounts) =\n            IMarginTrading(crossMarginTrading()).getHoldingAmounts(msg.sender);\n\n        // requires all debts paid off\n        IMarginTrading(crossMarginTrading()).registerLiquidation(msg.sender);\n\n        for (uint256 i; holdingTokens.length > i; i++) {\n            Fund(fund()).withdraw(\n                holdingTokens[i],\n                msg.sender,\n                holdingAmounts[i]\n            );\n        }\n\n        emit AccountUpdated(msg.sender);\n    }\n\n    /// @notice entry point for swapping tokens held in cross margin account\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        bytes32 amms,\n        address[] calldata tokens,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        // calc fees\n        uint256 fees = takeFeesFromInput(amountIn);\n\n        address[] memory pairs;\n        (amounts, pairs) = UniswapStyleLib.getAmountsOut(\n            amountIn - fees,\n            amms,\n            tokens\n        );\n\n        // checks that trader is within allowed lending bounds\n        registerTrade(\n            msg.sender,\n            tokens[0],\n            tokens[tokens.length - 1],\n            amountIn,\n            amounts[amounts.length - 1]\n        );\n\n        _fundSwapExactT4T(amounts, amountOutMin, pairs, tokens);\n    }\n\n    /// @notice entry point for swapping tokens held in cross margin account\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        bytes32 amms,\n        address[] calldata tokens,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        address[] memory pairs;\n        (amounts, pairs) = UniswapStyleLib.getAmountsIn(\n            amountOut + takeFeesFromOutput(amountOut),\n            amms,\n            tokens\n        );\n\n        // checks that trader is within allowed lending bounds\n        registerTrade(\n            msg.sender,\n            tokens[0],\n            tokens[tokens.length - 1],\n            amounts[0],\n            amountOut\n        );\n\n        _fundSwapT4ExactT(amounts, amountInMax, pairs, tokens);\n    }\n\n    /// @dev helper function does all the work of telling other contracts\n    /// about a cross margin trade\n    function registerTrade(\n        address trader,\n        address inToken,\n        address outToken,\n        uint256 inAmount,\n        uint256 outAmount\n    ) internal {\n        (uint256 extinguishAmount, uint256 borrowAmount) =\n            IMarginTrading(crossMarginTrading()).registerTradeAndBorrow(\n                trader,\n                inToken,\n                outToken,\n                inAmount,\n                outAmount\n            );\n        if (extinguishAmount > 0) {\n            Lending(lending()).payOff(outToken, extinguishAmount);\n            IncentiveReporter.subtractFromClaimAmount(\n                outToken,\n                trader,\n                extinguishAmount\n            );\n        }\n        if (borrowAmount > 0) {\n            Lending(lending()).registerBorrow(inToken, borrowAmount);\n            IncentiveReporter.addToClaimAmount(inToken, trader, borrowAmount);\n        }\n\n        emit AccountUpdated(trader);\n    }\n\n    /////////////\n    // Helpers\n    /////////////\n\n    /// @dev internal helper swapping exact token for token on AMM\n    function _fundSwapExactT4T(\n        uint256[] memory amounts,\n        uint256 amountOutMin,\n        address[] memory pairs,\n        address[] calldata tokens\n    ) internal {\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"MarginRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        Fund(fund()).withdraw(tokens[0], pairs[0], amounts[0]);\n        _swap(amounts, pairs, tokens, fund());\n    }\n\n    /// @notice make swaps on AMM using protocol funds, only for authorized contracts\n    function authorizedSwapExactT4T(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        bytes32 amms,\n        address[] calldata tokens\n    ) external returns (uint256[] memory amounts) {\n        require(\n            isAuthorizedFundTrader(msg.sender),\n            \"Calling contract is not authorized to trade with protocl funds\"\n        );\n        address[] memory pairs;\n        (amounts, pairs) = UniswapStyleLib.getAmountsOut(\n            amountIn,\n            amms,\n            tokens\n        );\n        _fundSwapExactT4T(amounts, amountOutMin, pairs, tokens);\n    }\n\n    // @dev internal helper swapping exact token for token on on AMM\n    function _fundSwapT4ExactT(\n        uint256[] memory amounts,\n        uint256 amountInMax,\n        address[] memory pairs,\n        address[] calldata tokens\n    ) internal {\n        require(\n            amounts[0] <= amountInMax,\n            \"MarginRouter: EXCESSIVE_INPUT_AMOUNT\"\n        );\n        Fund(fund()).withdraw(tokens[0], pairs[0], amounts[0]);\n        _swap(amounts, pairs, tokens, fund());\n    }\n\n    //// @notice swap protocol funds on AMM, only for authorized\n    function authorizedSwapT4ExactT(\n        uint256 amountOut,\n        uint256 amountInMax,\n        bytes32 amms,\n        address[] calldata tokens\n    ) external returns (uint256[] memory amounts) {\n        require(\n            isAuthorizedFundTrader(msg.sender),\n            \"Calling contract is not authorized to trade with protocl funds\"\n        );\n\n        address[] memory pairs;\n        (amounts, pairs) = UniswapStyleLib.getAmountsIn(\n            amountOut,\n            amms,\n            tokens\n        );\n        _fundSwapT4ExactT(amounts, amountInMax, pairs, tokens);\n    }\n\n    function takeFeesFromOutput(uint256 amount)\n        internal\n        pure\n        returns (uint256 fees)\n    {\n        fees = (mswapFeesPer10k * amount) / 10_000;\n    }\n\n    function takeFeesFromInput(uint256 amount)\n        internal\n        pure\n        returns (uint256 fees)\n    {\n        fees = (mswapFeesPer10k * amount) / (10_000 + mswapFeesPer10k);\n    }\n\n    function getAmountsOut(\n        uint256 inAmount,\n        bytes32 amms,\n        address[] calldata tokens\n    ) external view returns (uint256[] memory amounts) {\n        (amounts, ) = UniswapStyleLib.getAmountsOut(inAmount, amms, tokens);\n    }\n\n    function getAmountsIn(\n        uint256 outAmount,\n        bytes32 amms,\n        address[] calldata tokens\n    ) external view returns (uint256[] memory amounts) {\n        (amounts, ) = UniswapStyleLib.getAmountsIn(outAmount, amms, tokens);\n    }\n}\n"
73     },
74     "contracts/PriceAware.sol": {
75       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./RoleAware.sol\";\nimport \"./MarginRouter.sol\";\nimport \"../libraries/UniswapStyleLib.sol\";\n\n/// Stores how many of token you could get for 1k of peg\nstruct TokenPrice {\n    uint256 lastUpdated;\n    uint256 priceFP;\n    address[] liquidationTokens;\n    bytes32 amms;\n    address[] inverseLiquidationTokens;\n    bytes32 inverseAmms;\n}\n\nstruct VolatilitySetting {\n    uint256 priceUpdateWindow;\n    uint256 updateRatePermil;\n    uint256 voluntaryUpdateWindow;\n}\n\nstruct PairPrice {\n    uint256 cumulative;\n    uint256 lastUpdated;\n    uint256 priceFP;\n}\n\n/// @title The protocol features several mechanisms to prevent vulnerability to\n/// price manipulation:\n/// 1) global exposure caps on all tokens which need to be raised gradually\n///    during the process of introducing a new token, making attacks unprofitable\n///    due to lack  of scale\n/// 2) Exponential moving average with cautious price update. Prices for estimating\n///    how much a trader can borrow need not be extremely current and precise, mainly\n///    they must be resilient against extreme manipulation\n/// 3) Liquidators may not call from a contract address, to prevent extreme forms of\n///    of front-running and other price manipulation.\nabstract contract PriceAware is RoleAware {\n    uint256 constant FP112 = 2**112;\n\n    address public immutable peg;\n\n    mapping(address => TokenPrice) public tokenPrices;\n    mapping(address => mapping(address => PairPrice)) public pairPrices;\n    /// update window in blocks\n\n    // TODO\n    uint256 public priceUpdateWindow = 20 minutes;\n    uint256 public voluntaryUpdateWindow = 5 minutes;\n\n    uint256 public UPDATE_RATE_PERMIL = 400;\n    VolatilitySetting[] public volatilitySettings;\n\n    constructor(address _peg) {\n        peg = _peg;\n    }\n\n    /// Set window for price updates\n    function setPriceUpdateWindow(uint16 window, uint256 voluntaryWindow)\n        external\n        onlyOwnerExec\n    {\n        priceUpdateWindow = window;\n        voluntaryUpdateWindow = voluntaryWindow;\n    }\n\n    /// Add a new volatility setting\n    function addVolatilitySetting(\n        uint256 _priceUpdateWindow,\n        uint256 _updateRatePermil,\n        uint256 _voluntaryUpdateWindow\n    ) external onlyOwnerExec {\n        volatilitySettings.push(\n            VolatilitySetting({\n                priceUpdateWindow: _priceUpdateWindow,\n                updateRatePermil: _updateRatePermil,\n                voluntaryUpdateWindow: _voluntaryUpdateWindow\n            })\n        );\n    }\n\n    /// Choose a volatitlity setting\n    function chooseVolatilitySetting(uint256 index)\n        external\n        onlyOwnerExecDisabler\n    {\n        VolatilitySetting storage vs = volatilitySettings[index];\n        if (vs.updateRatePermil > 0) {\n            UPDATE_RATE_PERMIL = vs.updateRatePermil;\n            priceUpdateWindow = vs.priceUpdateWindow;\n            voluntaryUpdateWindow = vs.voluntaryUpdateWindow;\n        }\n    }\n\n    /// Set rate for updates\n    function setUpdateRate(uint256 rate) external onlyOwnerExec {\n        UPDATE_RATE_PERMIL = rate;\n    }\n\n    function getCurrentPriceInPeg(address token, uint256 inAmount)\n        internal\n        returns (uint256)\n    {\n        return getCurrentPriceInPeg(token, inAmount, false);\n    }\n\n    function getCurrentPriceInPeg(\n        address token,\n        uint256 inAmount,\n        bool voluntary\n    ) public returns (uint256 priceInPeg) {\n        if (token == peg) {\n            return inAmount;\n        } else {\n            TokenPrice storage tokenPrice = tokenPrices[token];\n\n            uint256 timeDelta = block.timestamp - tokenPrice.lastUpdated;\n            if (\n                timeDelta > priceUpdateWindow ||\n                tokenPrice.priceFP == 0 ||\n                (voluntary && timeDelta > voluntaryUpdateWindow)\n            ) {\n                // update the currently cached price\n                uint256 priceUpdateFP;\n                priceUpdateFP = getPriceByPairs(\n                    tokenPrice.liquidationTokens,\n                    tokenPrice.amms\n                );\n                _setPriceVal(tokenPrice, priceUpdateFP, UPDATE_RATE_PERMIL);\n            }\n\n            priceInPeg = (inAmount * tokenPrice.priceFP) / FP112;\n        }\n    }\n\n    /// Get view of current price of token in peg\n    function viewCurrentPriceInPeg(address token, uint256 inAmount)\n        public\n        view\n        returns (uint256 priceInPeg)\n    {\n        if (token == peg) {\n            return inAmount;\n        } else {\n            TokenPrice storage tokenPrice = tokenPrices[token];\n            uint256 priceFP = tokenPrice.priceFP;\n\n            priceInPeg = (inAmount * priceFP) / FP112;\n        }\n    }\n\n    function _setPriceVal(\n        TokenPrice storage tokenPrice,\n        uint256 updateFP,\n        uint256 weightPerMil\n    ) internal {\n        tokenPrice.priceFP =\n            (tokenPrice.priceFP *\n                (1000 - weightPerMil) +\n                updateFP *\n                weightPerMil) /\n            1000;\n\n        tokenPrice.lastUpdated = block.timestamp;\n    }\n\n    /// add path from token to current liquidation peg\n    function setLiquidationPath(bytes32 amms, address[] memory tokens)\n        external\n        onlyOwnerExecActivator\n    {\n        address token = tokens[0];\n\n        if (token != peg) {\n            TokenPrice storage tokenPrice = tokenPrices[token];\n\n            tokenPrice.amms = amms;\n\n            tokenPrice.liquidationTokens = tokens;\n            tokenPrice.inverseLiquidationTokens = new address[](tokens.length);\n\n            bytes32 inverseAmms;\n\n            for (uint256 i = 0; tokens.length - 1 > i; i++) {\n                initPairPrice(tokens[i], tokens[i + 1], amms[i]);\n\n                bytes32 shifted =\n                    bytes32(amms[i]) >> ((tokens.length - 2 - i) * 8);\n\n                inverseAmms = inverseAmms | shifted;\n            }\n\n            tokenPrice.inverseAmms = inverseAmms;\n\n            for (uint256 i = 0; tokens.length > i; i++) {\n                tokenPrice.inverseLiquidationTokens[i] = tokens[\n                    tokens.length - i - 1\n                ];\n            }\n\n            tokenPrice.priceFP = getPriceByPairs(tokens, amms);\n            tokenPrice.lastUpdated = block.timestamp;\n        }\n    }\n\n    function liquidateToPeg(address token, uint256 amount)\n        internal\n        returns (uint256)\n    {\n        if (token == peg) {\n            return amount;\n        } else {\n            TokenPrice storage tP = tokenPrices[token];\n            uint256[] memory amounts =\n                MarginRouter(marginRouter()).authorizedSwapExactT4T(\n                    amount,\n                    0,\n                    tP.amms,\n                    tP.liquidationTokens\n                );\n\n            uint256 outAmount = amounts[amounts.length - 1];\n\n            return outAmount;\n        }\n    }\n\n    function liquidateFromPeg(address token, uint256 targetAmount)\n        internal\n        returns (uint256)\n    {\n        if (token == peg) {\n            return targetAmount;\n        } else {\n            TokenPrice storage tP = tokenPrices[token];\n            uint256[] memory amounts =\n                MarginRouter(marginRouter()).authorizedSwapT4ExactT(\n                    targetAmount,\n                    type(uint256).max,\n                    tP.amms,\n                    tP.inverseLiquidationTokens\n                );\n\n            return amounts[0];\n        }\n    }\n\n    function getPriceByPairs(address[] memory tokens, bytes32 amms)\n        internal\n        returns (uint256 priceFP)\n    {\n        priceFP = FP112;\n        for (uint256 i; i < tokens.length - 1; i++) {\n            address inToken = tokens[i];\n            address outToken = tokens[i + 1];\n\n            address pair =\n                amms[i] == 0\n                    ? UniswapStyleLib.pairForUni(inToken, outToken)\n                    : UniswapStyleLib.pairForSushi(inToken, outToken);\n\n            PairPrice storage pairPrice = pairPrices[pair][inToken];\n\n            (, , uint256 pairLastUpdated) = IUniswapV2Pair(pair).getReserves();\n            uint256 timeDelta = pairLastUpdated - pairPrice.lastUpdated;\n\n            if (timeDelta > voluntaryUpdateWindow) {\n                // we are in business\n                (address token0, ) =\n                    UniswapStyleLib.sortTokens(inToken, outToken);\n\n                uint256 cumulative =\n                    inToken == token0\n                        ? IUniswapV2Pair(pair).price0CumulativeLast()\n                        : IUniswapV2Pair(pair).price1CumulativeLast();\n\n                uint256 pairPriceFP =\n                    (cumulative - pairPrice.cumulative) / timeDelta;\n                priceFP = (priceFP * pairPriceFP) / FP112;\n\n                pairPrice.priceFP = pairPriceFP;\n                pairPrice.cumulative = cumulative;\n                pairPrice.lastUpdated = pairLastUpdated;\n            } else {\n                priceFP = (priceFP * pairPrice.priceFP) / FP112;\n            }\n        }\n    }\n\n    function initPairPrice(\n        address inToken,\n        address outToken,\n        bytes1 amm\n    ) internal {\n        address pair =\n            amm == 0\n                ? UniswapStyleLib.pairForUni(inToken, outToken)\n                : UniswapStyleLib.pairForSushi(inToken, outToken);\n\n        PairPrice storage pairPrice = pairPrices[pair][inToken];\n\n        if (pairPrice.lastUpdated == 0) {\n            (uint112 reserve0, uint112 reserve1, uint256 pairLastUpdated) =\n                IUniswapV2Pair(pair).getReserves();\n\n            (address token0, ) = UniswapStyleLib.sortTokens(inToken, outToken);\n\n            if (inToken == token0) {\n                pairPrice.priceFP = (FP112 * reserve1) / reserve0;\n                pairPrice.cumulative = IUniswapV2Pair(pair)\n                    .price0CumulativeLast();\n            } else {\n                pairPrice.priceFP = (FP112 * reserve0) / reserve1;\n                pairPrice.cumulative = IUniswapV2Pair(pair)\n                    .price1CumulativeLast();\n            }\n\n            pairPrice.lastUpdated = block.timestamp;\n\n            pairPrice.lastUpdated = pairLastUpdated;\n        }\n    }\n}\n"
76     },
77     "contracts/RoleAware.sol": {
78       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Roles.sol\";\n\n/// @title Role management behavior\n/// Main characters are for service discovery\n/// Whereas roles are for access control\ncontract RoleAware {\n    Roles public immutable roles;\n    mapping(uint256 => address) public mainCharacterCache;\n    mapping(address => mapping(uint256 => bool)) public roleCache;\n\n    constructor(address _roles) {\n        require(_roles != address(0), \"Please provide valid roles address\");\n        roles = Roles(_roles);\n    }\n\n    modifier noIntermediary() {\n        require(\n            msg.sender == tx.origin,\n            \"Currently no intermediaries allowed for this function call\"\n        );\n        _;\n    }\n\n    // @dev Throws if called by any account other than the owner or executor\n    modifier onlyOwnerExec() {\n        require(\n            owner() == msg.sender || executor() == msg.sender,\n            \"Roles: caller is not the owner\"\n        );\n        _;\n    }\n\n    modifier onlyOwnerExecDisabler() {\n        require(\n            owner() == msg.sender ||\n                executor() == msg.sender ||\n                disabler() == msg.sender,\n            \"Caller is not the owner, executor or authorized disabler\"\n        );\n        _;\n    }\n\n    modifier onlyOwnerExecActivator() {\n        require(\n            owner() == msg.sender ||\n                executor() == msg.sender ||\n                isTokenActivator(msg.sender),\n            \"Caller is not the owner, executor or authorized activator\"\n        );\n        _;\n    }\n\n    function updateRoleCache(uint256 role, address contr) public virtual {\n        roleCache[contr][role] = roles.getRole(role, contr);\n    }\n\n    function updateMainCharacterCache(uint256 role) public virtual {\n        mainCharacterCache[role] = roles.mainCharacters(role);\n    }\n\n    function owner() internal view returns (address) {\n        return roles.owner();\n    }\n\n    function executor() internal returns (address) {\n        return roles.executor();\n    }\n\n    function disabler() internal view returns (address) {\n        return mainCharacterCache[DISABLER];\n    }\n\n    function fund() internal view returns (address) {\n        return mainCharacterCache[FUND];\n    }\n\n    function lending() internal view returns (address) {\n        return mainCharacterCache[LENDING];\n    }\n\n    function marginRouter() internal view returns (address) {\n        return mainCharacterCache[MARGIN_ROUTER];\n    }\n\n    function crossMarginTrading() internal view returns (address) {\n        return mainCharacterCache[CROSS_MARGIN_TRADING];\n    }\n\n    function feeController() internal view returns (address) {\n        return mainCharacterCache[FEE_CONTROLLER];\n    }\n\n    function price() internal view returns (address) {\n        return mainCharacterCache[PRICE_CONTROLLER];\n    }\n\n    function admin() internal view returns (address) {\n        return mainCharacterCache[ADMIN];\n    }\n\n    function incentiveDistributor() internal view returns (address) {\n        return mainCharacterCache[INCENTIVE_DISTRIBUTION];\n    }\n\n    function tokenAdmin() internal view returns (address) {\n        return mainCharacterCache[TOKEN_ADMIN];\n    }\n\n    function isBorrower(address contr) internal view returns (bool) {\n        return roleCache[contr][BORROWER];\n    }\n\n    function isFundTransferer(address contr) internal view returns (bool) {\n        return roleCache[contr][FUND_TRANSFERER];\n    }\n\n    function isMarginTrader(address contr) internal view returns (bool) {\n        return roleCache[contr][MARGIN_TRADER];\n    }\n\n    function isFeeSource(address contr) internal view returns (bool) {\n        return roleCache[contr][FEE_SOURCE];\n    }\n\n    function isMarginCaller(address contr) internal view returns (bool) {\n        return roleCache[contr][MARGIN_CALLER];\n    }\n\n    function isLiquidator(address contr) internal view returns (bool) {\n        return roleCache[contr][LIQUIDATOR];\n    }\n\n    function isAuthorizedFundTrader(address contr)\n        internal\n        view\n        returns (bool)\n    {\n        return roleCache[contr][AUTHORIZED_FUND_TRADER];\n    }\n\n    function isIncentiveReporter(address contr) internal view returns (bool) {\n        return roleCache[contr][INCENTIVE_REPORTER];\n    }\n\n    function isTokenActivator(address contr) internal view returns (bool) {\n        return roleCache[contr][TOKEN_ACTIVATOR];\n    }\n\n    function isStakePenalizer(address contr) internal view returns (bool) {\n        return roleCache[contr][STAKE_PENALIZER];\n    }\n\n    function isLender(address contr) internal view returns (bool) {\n        return roleCache[contr][LENDER];\n    }\n}\n"
79     },
80     "contracts/Roles.sol": {
81       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IDependencyController.sol\";\n\n// we chose not to go with an enum\n// to make this list easy to extend\nuint256 constant FUND_TRANSFERER = 1;\nuint256 constant MARGIN_CALLER = 2;\nuint256 constant BORROWER = 3;\nuint256 constant MARGIN_TRADER = 4;\nuint256 constant FEE_SOURCE = 5;\nuint256 constant LIQUIDATOR = 6;\nuint256 constant AUTHORIZED_FUND_TRADER = 7;\nuint256 constant INCENTIVE_REPORTER = 8;\nuint256 constant TOKEN_ACTIVATOR = 9;\nuint256 constant STAKE_PENALIZER = 10;\nuint256 constant LENDER = 11;\n\nuint256 constant FUND = 101;\nuint256 constant LENDING = 102;\nuint256 constant MARGIN_ROUTER = 103;\nuint256 constant CROSS_MARGIN_TRADING = 104;\nuint256 constant FEE_CONTROLLER = 105;\nuint256 constant PRICE_CONTROLLER = 106;\nuint256 constant ADMIN = 107;\nuint256 constant INCENTIVE_DISTRIBUTION = 108;\nuint256 constant TOKEN_ADMIN = 109;\n\nuint256 constant DISABLER = 1001;\nuint256 constant DEPENDENCY_CONTROLLER = 1002;\n\n/// @title Manage permissions of contracts and ownership of everything\n/// owned by a multisig wallet (0xEED9D1c6B4cdEcB3af070D85bfd394E7aF179CBd) during\n/// beta and will then be transfered to governance\n/// https://github.com/marginswap/governance\ncontract Roles is Ownable {\n    mapping(address => mapping(uint256 => bool)) public roles;\n    mapping(uint256 => address) public mainCharacters;\n\n    constructor() Ownable() {\n        // token activation from the get-go\n        roles[msg.sender][TOKEN_ACTIVATOR] = true;\n    }\n\n    /// @dev Throws if called by any account other than the owner.\n    modifier onlyOwnerExecDepController() {\n        require(\n            owner() == msg.sender ||\n                executor() == msg.sender ||\n                mainCharacters[DEPENDENCY_CONTROLLER] == msg.sender,\n            \"Roles: caller is not the owner\"\n        );\n        _;\n    }\n\n    function giveRole(uint256 role, address actor)\n        external\n        onlyOwnerExecDepController\n    {\n        roles[actor][role] = true;\n    }\n\n    function removeRole(uint256 role, address actor)\n        external\n        onlyOwnerExecDepController\n    {\n        roles[actor][role] = false;\n    }\n\n    function setMainCharacter(uint256 role, address actor)\n        external\n        onlyOwnerExecDepController\n    {\n        mainCharacters[role] = actor;\n    }\n\n    function getRole(uint256 role, address contr) external view returns (bool) {\n        return roles[contr][role];\n    }\n\n    /// @dev current executor\n    function executor() public returns (address exec) {\n        address depController = mainCharacters[DEPENDENCY_CONTROLLER];\n        if (depController != address(0)) {\n            exec = IDependencyController(depController).currentExecutor();\n        }\n    }\n}\n"
82     },
83     "interfaces/IDependencyController.sol": {
84       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IDependencyController {\n    function currentExecutor() external returns (address);\n}\n"
85     },
86     "interfaces/IMarginTrading.sol": {
87       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IMarginTrading {\n    function registerDeposit(\n        address trader,\n        address token,\n        uint256 amount\n    ) external returns (uint256 extinguishAmount);\n\n    function registerWithdrawal(\n        address trader,\n        address token,\n        uint256 amount\n    ) external;\n\n    function registerBorrow(\n        address trader,\n        address token,\n        uint256 amount\n    ) external;\n\n    function registerTradeAndBorrow(\n        address trader,\n        address inToken,\n        address outToken,\n        uint256 inAmount,\n        uint256 outAmount\n    ) external returns (uint256 extinguishAmount, uint256 borrowAmount);\n\n    function registerOvercollateralizedBorrow(\n        address trader,\n        address depositToken,\n        uint256 depositAmount,\n        address borrowToken,\n        uint256 withdrawAmount\n    ) external;\n\n    function registerLiquidation(address trader) external;\n\n    function getHoldingAmounts(address trader)\n        external\n        view\n        returns (\n            address[] memory holdingTokens,\n            uint256[] memory holdingAmounts\n        );\n\n    function getBorrowAmounts(address trader)\n        external\n        view\n        returns (address[] memory borrowTokens, uint256[] memory borrowAmounts);\n}\n"
88     },
89     "interfaces/IWETH.sol": {
90       "content": "pragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
91     },
92     "libraries/IncentiveReporter.sol": {
93       "content": "library IncentiveReporter {\n    event AddToClaim(address topic, address indexed claimant, uint256 amount);\n    event SubtractFromClaim(\n        address topic,\n        address indexed claimant,\n        uint256 amount\n    );\n\n    /// Start / increase amount of claim\n    function addToClaimAmount(\n        address topic,\n        address recipient,\n        uint256 claimAmount\n    ) internal {\n        emit AddToClaim(topic, recipient, claimAmount);\n    }\n\n    /// Decrease amount of claim\n    function subtractFromClaimAmount(\n        address topic,\n        address recipient,\n        uint256 subtractAmount\n    ) internal {\n        emit SubtractFromClaim(topic, recipient, subtractAmount);\n    }\n}\n"
94     },
95     "libraries/UniswapStyleLib.sol": {
96       "content": "pragma solidity >=0.5.0;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\nlibrary UniswapStyleLib {\n    address constant UNISWAP_FACTORY =\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address constant SUSHI_FACTORY = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"Identical address!\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"Zero address!\");\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address pair,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) =\n            IUniswapV2Pair(pair).getReserves();\n\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"INSUFFICIENT_INPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1_000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 numerator = reserveIn * amountOut * 1_000;\n\n        uint256 denominator = (reserveOut - amountOut) * 997;\n        amountIn = (numerator / denominator) + 1;\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        uint256 amountIn,\n        bytes32 amms,\n        address[] memory tokens\n    ) internal view returns (uint256[] memory amounts, address[] memory pairs) {\n        require(tokens.length >= 2, \"token path too short\");\n\n        amounts = new uint256[](tokens.length);\n        amounts[0] = amountIn;\n\n        pairs = new address[](tokens.length - 1);\n\n        for (uint256 i; i < tokens.length - 1; i++) {\n            address inToken = tokens[i];\n            address outToken = tokens[i + 1];\n\n            address pair =\n                amms[i] == 0\n                    ? pairForUni(inToken, outToken)\n                    : pairForSushi(inToken, outToken);\n            pairs[i] = pair;\n\n            (uint256 reserveIn, uint256 reserveOut) =\n                getReserves(pair, inToken, outToken);\n\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        uint256 amountOut,\n        bytes32 amms,\n        address[] memory tokens\n    ) internal view returns (uint256[] memory amounts, address[] memory pairs) {\n        require(tokens.length >= 2, \"token path too short\");\n\n        amounts = new uint256[](tokens.length);\n        amounts[amounts.length - 1] = amountOut;\n\n        pairs = new address[](tokens.length - 1);\n\n        for (uint256 i = tokens.length - 1; i > 0; i--) {\n            address inToken = tokens[i - 1];\n            address outToken = tokens[i];\n\n            address pair =\n                amms[i - 1] == 0\n                    ? pairForUni(inToken, outToken)\n                    : pairForSushi(inToken, outToken);\n            pairs[i - 1] = pair;\n\n            (uint256 reserveIn, uint256 reserveOut) =\n                getReserves(pair, inToken, outToken);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairForUni(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            UNISWAP_FACTORY,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    function pairForSushi(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            SUSHI_FACTORY,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            hex\"e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303\" // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n"
97     }
98   }
99 }}