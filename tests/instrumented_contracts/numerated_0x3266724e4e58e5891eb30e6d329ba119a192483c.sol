1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/MerkleClaim.sol": {
5       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// ============ Imports ============\n\n//import { MerkleProof } from \"@openzeppelin/utils/cryptography/MerkleProof.sol\"; // OZ: MerkleProof\nimport { Owned } from \"./Owned.sol\";\nimport { TransferHelper } from \"./TransferHelper.sol\";\nimport { MerkleProof } from \"./MerkleProof.sol\"; // OZ: MerkleProof\n\ninterface IERC20 {\n  function approve(address spender, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address to, uint256 amount) external returns (bool);\n  function transferFrom(address from, address to, uint256 amount ) external returns (bool);\n}\n\n/// @title MerkleClaim\n/// @notice Allows a held ERC20 to be claimable by members of a merkle tree\n/// @author Anish Agnihotri <contact@anishagnihotri.com>\n/// @author Jack Corddry https://github.com/corddry\ncontract MerkleClaim is Owned{\n\n  /// ============ Immutable storage ============\n\n  /// @notice ERC20-claimee inclusion root\n  bytes32 public immutable merkleRoot;\n\n  /// @notice Contract address of airdropped token\n  IERC20 public immutable token;\n\n  address public timelock_address;\n\n  /// ============ Mutable storage ============\n\n  /// @notice Mapping of addresses who have claimed tokens\n  mapping(address => bool) public hasClaimed;\n\n  /// ============ Errors ============\n\n  /// @notice Thrown if address has already claimed\n  error AlreadyClaimed();\n  /// @notice Thrown if address/amount are not part of Merkle tree\n  error NotInMerkle();\n  /// @notice Thrown if claim contract doesn't have enough tokens to payout\n  error notEnoughRewards();\n\n  /// ============ Modifiers ============\n\n  modifier onlyByOwnGov() {\n    require(msg.sender == owner || msg.sender == timelock_address, \"Not owner or timelock\");\n    _;\n  }\n\n  /// ============ Constructor ============\n\n  /// @notice Creates a new MerkleClaimERC20 contract\n  /// @param _erc20Address of token to be airdropped\n  /// @param _merkleRoot of claimees\n  constructor(\n    address _erc20Address,\n    bytes32 _merkleRoot,\n    address _owner_address,\n    address _timelock_address\n  ) Owned(_owner_address)\n  {\n    merkleRoot = _merkleRoot;\n    token = IERC20(_erc20Address);\n    timelock_address = _timelock_address;\n  }\n\n  /// ============ Events ============\n\n  /// @notice Emitted after a successful token claim\n  /// @param to recipient of claim\n  /// @param amount of tokens claimed\n  event Claim(address indexed to, uint256 amount);\n\n  /// @notice Emitted after a successful token recovery\n  /// @param token address being recovered\n  /// @param amount of tokens recoverd\n  event Recovered(address token, uint256 amount);\n\n  /// ============ Functions ============\n\n  /// @notice Allows claiming tokens if address is part of merkle tree\n  /// @param to address of claimee\n  /// @param amount of tokens owed to claimee\n  /// @param proof merkle proof to prove address and amount are in tree\n  function claim(address to, uint256 amount, bytes32[] calldata proof) external {\n    // Throw if address has already claimed tokens\n    if (hasClaimed[to]) revert AlreadyClaimed();\n\n    // Verify merkle proof, or revert if not in tree\n    bytes32 leaf = keccak256(abi.encodePacked(to, amount));\n    bool isValidLeaf = MerkleProof.verify(proof, merkleRoot, leaf);\n    if (!isValidLeaf) revert NotInMerkle();\n\n    // Throw if the contract doesn't hold enough tokens for claimee\n    if (amount > token.balanceOf(address(this))) revert notEnoughRewards();\n\n    // Set address to claimed\n    hasClaimed[to] = true;\n\n    // Award tokens to address\n    token.transfer(to, amount);\n\n    // Emit claim event\n    emit Claim(to, amount);\n  }\n\n    /// ============ Permissioned Functions ============\n  \n    function setTimelock(address _new_timelock_address) external onlyByOwnGov {\n      timelock_address = _new_timelock_address;\n    }\n    \n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyByOwnGov {\n        // Can only be triggered by owner or governance\n        TransferHelper.safeTransfer(tokenAddress, owner, tokenAmount);\n        \n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    // Generic proxy\n    function execute(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external onlyByOwnGov returns (bool, bytes memory) {\n        (bool success, bytes memory result) = _to.call{value:_value}(_data);\n        return (success, result);\n    }\n}\n\n"
6     },
7     "contracts/MerkleProof.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
9     },
10     "contracts/TransferHelper.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.11;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}"
12     },
13     "contracts/Owned.sol": {
14       "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.11;\n\n// https://docs.synthetix.io/contracts/Owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor (address _owner) {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}"
15     }
16   },
17   "settings": {
18     "optimizer": {
19       "enabled": true,
20       "runs": 200
21     },
22     "outputSelection": {
23       "*": {
24         "*": [
25           "evm.bytecode",
26           "evm.deployedBytecode",
27           "devdoc",
28           "userdoc",
29           "metadata",
30           "abi"
31         ]
32       }
33     }
34   }
35 }}