1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/balancer-core/BConst.sol": {
5       "content": "// SPDX-License-Identifier: GPL-3.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.6.12;\n\ncontract BConst {\n    uint public constant BONE              = 10**18;\n\n    uint public constant MIN_BOUND_TOKENS  = 2;\n    uint public constant MAX_BOUND_TOKENS  = 9;\n\n    uint public constant MIN_FEE           = BONE / 10**6;\n    uint public constant MAX_FEE           = BONE / 10;\n\n    uint public constant MIN_WEIGHT        = 1000000000;\n    uint public constant MAX_WEIGHT        = BONE * 50;\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\n    uint public constant MIN_BALANCE       = BONE / 10**12;\n\n    uint public constant INIT_POOL_SUPPLY  = BONE * 100;\n\n    uint public constant MIN_BPOW_BASE     = 1 wei;\n    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;\n    uint public constant BPOW_PRECISION    = BONE / 10**10;\n\n    uint public constant MAX_IN_RATIO      = BONE / 2;\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\n}\n"
6     },
7     "contracts/balancer-core/BNum.sol": {
8       "content": "// SPDX-License-Identifier: GPL-3.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.6.12;\n\nimport \"./BConst.sol\";\n\ncontract BNum is BConst {\n\n    function btoi(uint a)\n        internal pure\n        returns (uint)\n    {\n        return a / BONE;\n    }\n\n    function bfloor(uint a)\n        internal pure\n        returns (uint)\n    {\n        return btoi(a) * BONE;\n    }\n\n    function badd(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        uint c = a + b;\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\n        return c;\n    }\n\n    function bsub(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        (uint c, bool flag) = bsubSign(a, b);\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\n        return c;\n    }\n\n    function bsubSign(uint a, uint b)\n        internal pure\n        returns (uint, bool)\n    {\n        if (a >= b) {\n            return (a - b, false);\n        } else {\n            return (b - a, true);\n        }\n    }\n\n    function bmul(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        uint c0 = a * b;\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n        uint c1 = c0 + (BONE / 2);\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n        uint c2 = c1 / BONE;\n        return c2;\n    }\n\n    function bdiv(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        require(b != 0, \"ERR_DIV_ZERO\");\n        uint c0 = a * BONE;\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n        uint c1 = c0 + (b / 2);\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n        uint c2 = c1 / b;\n        return c2;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n      require(b > 0, \"ERR_DIV_ZERO\");\n      return a / b;\n    }\n\n    // DSMath.wpow\n    function bpowi(uint a, uint n)\n        internal pure\n        returns (uint)\n    {\n        uint z = n % 2 != 0 ? a : BONE;\n\n        for (n /= 2; n != 0; n /= 2) {\n            a = bmul(a, a);\n\n            if (n % 2 != 0) {\n                z = bmul(z, a);\n            }\n        }\n        return z;\n    }\n\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\n    // of approximation of b^0.w\n    function bpow(uint base, uint exp)\n        internal pure\n        returns (uint)\n    {\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n        uint whole  = bfloor(exp);\n        uint remain = bsub(exp, whole);\n\n        uint wholePow = bpowi(base, btoi(whole));\n\n        if (remain == 0) {\n            return wholePow;\n        }\n\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n        return bmul(wholePow, partialResult);\n    }\n\n    function bpowApprox(uint base, uint exp, uint precision)\n        internal pure\n        returns (uint)\n    {\n        // term 0:\n        uint a     = exp;\n        (uint x, bool xneg)  = bsubSign(base, BONE);\n        uint term = BONE;\n        uint sum   = term;\n        bool negative = false;\n\n\n        // term(k) = numer / denom\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\n        // continue until term is less than precision\n        for (uint i = 1; term >= precision; i++) {\n            uint bigK = i * BONE;\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n            term = bmul(term, bmul(c, x));\n            term = bdiv(term, bigK);\n            if (term == 0) break;\n\n            if (xneg) negative = !negative;\n            if (cneg) negative = !negative;\n            if (negative) {\n                sum = bsub(sum, term);\n            } else {\n                sum = badd(sum, term);\n            }\n        }\n\n        return sum;\n    }\n\n}\n"
9     },
10     "contracts/balancer-core/BToken.sol": {
11       "content": "// SPDX-License-Identifier: GPL-3.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./BNum.sol\";\n\ncontract BTokenBase is BNum {\n\n    mapping(address => uint)                   internal _balance;\n    mapping(address => mapping(address=>uint)) internal _allowance;\n    uint internal _totalSupply;\n\n    event Approval(address indexed src, address indexed dst, uint amt);\n    event Transfer(address indexed src, address indexed dst, uint amt);\n\n    function _mint(uint amt) internal {\n        _balance[address(this)] = badd(_balance[address(this)], amt);\n        _totalSupply = badd(_totalSupply, amt);\n        emit Transfer(address(0), address(this), amt);\n    }\n\n    function _burn(uint amt) internal {\n        require(_balance[address(this)] >= amt, \"ERR_INSUFFICIENT_BAL\");\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\n        _totalSupply = bsub(_totalSupply, amt);\n        emit Transfer(address(this), address(0), amt);\n    }\n\n    function _move(address src, address dst, uint amt) internal {\n        require(_balance[src] >= amt, \"ERR_INSUFFICIENT_BAL\");\n        _validateAddress(src);\n        _validateAddress(dst);\n        _balance[src] = bsub(_balance[src], amt);\n        _balance[dst] = badd(_balance[dst], amt);\n        emit Transfer(src, dst, amt);\n    }\n\n    function _push(address to, uint amt) internal {\n        _move(address(this), to, amt);\n    }\n\n    function _pull(address from, uint amt) internal {\n        _move(from, address(this), amt);\n    }\n\n    function _validateAddress(address addr) internal {\n        require(addr != address(0), \"ERR_NULL_ADDRESS\");\n    }\n}\n\ncontract BToken is BTokenBase, IERC20 {\n\n    string  internal _name;\n    string  internal _symbol;\n    uint8   private _decimals = 18;\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns(uint8) {\n        return _decimals;\n    }\n\n    function allowance(address src, address dst) external override view returns (uint) {\n        return _allowance[src][dst];\n    }\n\n    function balanceOf(address whom) external override view returns (uint) {\n        return _balance[whom];\n    }\n\n    function totalSupply() public override view returns (uint) {\n        return _totalSupply;\n    }\n\n    function approve(address dst, uint amt) external override returns (bool) {\n        _validateAddress(dst);\n        _allowance[msg.sender][dst] = amt;\n        emit Approval(msg.sender, dst, amt);\n        return true;\n    }\n\n    function increaseApproval(address dst, uint amt) external returns (bool) {\n        _validateAddress(dst);\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n        return true;\n    }\n\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\n        _validateAddress(dst);\n        uint oldValue = _allowance[msg.sender][dst];\n        if (amt > oldValue) {\n            _allowance[msg.sender][dst] = 0;\n        } else {\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\n        }\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n        return true;\n    }\n\n    function transfer(address dst, uint amt) external override returns (bool) {\n        _move(msg.sender, dst, amt);\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint amt) external override returns (bool) {\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \"ERR_BTOKEN_BAD_CALLER\");\n        _move(src, dst, amt);\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\n            emit Approval(src, msg.sender, _allowance[src][msg.sender]);\n        }\n        return true;\n    }\n}\n"
12     },
13     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
15     },
16     "contracts/interfaces/BPoolInterface.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./BMathInterface.sol\";\n\ninterface BPoolInterface is IERC20, BMathInterface {\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n\n  function swapExactAmountIn(\n    address,\n    uint256,\n    address,\n    uint256,\n    uint256\n  ) external returns (uint256, uint256);\n\n  function swapExactAmountOut(\n    address,\n    uint256,\n    address,\n    uint256,\n    uint256\n  ) external returns (uint256, uint256);\n\n  function joinswapExternAmountIn(\n    address,\n    uint256,\n    uint256\n  ) external returns (uint256);\n\n  function joinswapPoolAmountOut(\n    address,\n    uint256,\n    uint256\n  ) external returns (uint256);\n\n  function exitswapPoolAmountIn(\n    address,\n    uint256,\n    uint256\n  ) external returns (uint256);\n\n  function exitswapExternAmountOut(\n    address,\n    uint256,\n    uint256\n  ) external returns (uint256);\n\n  function getDenormalizedWeight(address) external view returns (uint256);\n\n  function getBalance(address) external view returns (uint256);\n\n  function getSwapFee() external view returns (uint256);\n\n  function getTotalDenormalizedWeight() external view returns (uint256);\n\n  function getCommunityFee()\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      address\n    );\n\n  function calcAmountWithCommunityFee(\n    uint256,\n    uint256,\n    address\n  ) external view returns (uint256, uint256);\n\n  function getRestrictions() external view returns (address);\n\n  function isPublicSwap() external view returns (bool);\n\n  function isFinalized() external view returns (bool);\n\n  function isBound(address t) external view returns (bool);\n\n  function getCurrentTokens() external view returns (address[] memory tokens);\n\n  function getFinalTokens() external view returns (address[] memory tokens);\n\n  function setSwapFee(uint256) external;\n\n  function setCommunityFeeAndReceiver(\n    uint256,\n    uint256,\n    uint256,\n    address\n  ) external;\n\n  function setController(address) external;\n\n  function setPublicSwap(bool) external;\n\n  function finalize() external;\n\n  function bind(\n    address,\n    uint256,\n    uint256\n  ) external;\n\n  function rebind(\n    address,\n    uint256,\n    uint256\n  ) external;\n\n  function unbind(address) external;\n\n  function callVoting(\n    address voting,\n    bytes4 signature,\n    bytes calldata args,\n    uint256 value\n  ) external;\n\n  function getMinWeight() external view returns (uint256);\n\n  function getMaxBoundTokens() external view returns (uint256);\n}\n"
18     },
19     "contracts/interfaces/BMathInterface.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface BMathInterface {\n  function calcInGivenOut(\n    uint256 tokenBalanceIn,\n    uint256 tokenWeightIn,\n    uint256 tokenBalanceOut,\n    uint256 tokenWeightOut,\n    uint256 tokenAmountOut,\n    uint256 swapFee\n  ) external pure returns (uint256 tokenAmountIn);\n}\n"
21     },
22     "contracts/interfaces/PowerIndexPoolInterface.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./BPoolInterface.sol\";\n\ninterface PowerIndexPoolInterface is BPoolInterface {\n  function bind(\n    address,\n    uint256,\n    uint256,\n    uint256,\n    uint256\n  ) external;\n\n  function setDynamicWeight(\n    address token,\n    uint256 targetDenorm,\n    uint256 fromTimestamp,\n    uint256 targetTimestamp\n  ) external;\n\n  function getDynamicWeightSettings(address token)\n    external\n    view\n    returns (\n      uint256 fromTimestamp,\n      uint256 targetTimestamp,\n      uint256 fromDenorm,\n      uint256 targetDenorm\n    );\n\n  function getMinWeight() external view override returns (uint256);\n}\n"
24     },
25     "contracts/PowerIndexPool.sol": {
26       "content": "/*\nhttps://powerpool.finance/\n\n          wrrrw r wrr\n         ppwr rrr wppr0       prwwwrp                                 prwwwrp                   wr0\n        rr 0rrrwrrprpwp0      pp   pr  prrrr0 pp   0r  prrrr0  0rwrrr pp   pr  prrrr0  prrrr0    r0\n        rrp pr   wr00rrp      prwww0  pp   wr pp w00r prwwwpr  0rw    prwww0  pp   wr pp   wr    r0\n        r0rprprwrrrp pr0      pp      wr   pr pp rwwr wr       0r     pp      wr   pr wr   pr    r0\n         prwr wrr0wpwr        00        www0   0w0ww    www0   0w     00        www0    www0   0www0\n          wrr ww0rrrr\n\n*/\n\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\n\nimport \"./balancer-core/BPool.sol\";\nimport \"./interfaces/PowerIndexPoolInterface.sol\";\n\ncontract PowerIndexPool is BPool {\n  /// @notice The event emitted when a dynamic weight set to token\n  event SetDynamicWeight(\n    address indexed token,\n    uint256 fromDenorm,\n    uint256 targetDenorm,\n    uint256 fromTimestamp,\n    uint256 targetTimestamp\n  );\n\n  /// @notice The event emitted when weight per second bounds set\n  event SetWeightPerSecondBounds(uint256 minWeightPerSecond, uint256 maxWeightPerSecond);\n\n  struct DynamicWeight {\n    uint256 fromTimestamp;\n    uint256 targetTimestamp;\n    uint256 targetDenorm;\n  }\n\n  /// @dev Mapping for storing dynamic weights settings. fromDenorm stored in _records mapping as denorm variable\n  mapping(address => DynamicWeight) private _dynamicWeights;\n\n  /// @dev Min weight per second limit\n  uint256 private _minWeightPerSecond;\n  /// @dev Max weight per second limit\n  uint256 private _maxWeightPerSecond;\n\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 minWeightPerSecond,\n    uint256 maxWeightPerSecond\n  ) public BPool(name, symbol) {\n    _minWeightPerSecond = minWeightPerSecond;\n    _maxWeightPerSecond = maxWeightPerSecond;\n  }\n\n  /*** Controller Interface ***/\n\n  /**\n   * @notice Set weight per second bounds by controller\n   * @param minWeightPerSecond Min weight per second\n   * @param maxWeightPerSecond Max weight per second\n   */\n  function setWeightPerSecondBounds(uint256 minWeightPerSecond, uint256 maxWeightPerSecond) public _logs_ _lock_ {\n    _onlyController();\n    _minWeightPerSecond = minWeightPerSecond;\n    _maxWeightPerSecond = maxWeightPerSecond;\n\n    emit SetWeightPerSecondBounds(minWeightPerSecond, maxWeightPerSecond);\n  }\n\n  /**\n   * @notice Set dynamic weight for token by controller\n   * @param token Token for change settings\n   * @param targetDenorm Target weight. fromDenorm will be fetch by current value of _getDenormWeight\n   * @param fromTimestamp From timestamp of dynamic weight\n   * @param targetTimestamp Target timestamp of dynamic weight\n   */\n  function setDynamicWeight(\n    address token,\n    uint256 targetDenorm,\n    uint256 fromTimestamp,\n    uint256 targetTimestamp\n  ) public _logs_ _lock_ {\n    _onlyController();\n    _requireTokenIsBound(token);\n\n    require(fromTimestamp > block.timestamp, \"CANT_SET_PAST_TIMESTAMP\");\n    require(targetTimestamp > fromTimestamp, \"TIMESTAMP_INCORRECT_DELTA\");\n    require(targetDenorm >= MIN_WEIGHT && targetDenorm <= MAX_WEIGHT, \"TARGET_WEIGHT_BOUNDS\");\n\n    uint256 fromDenorm = _getDenormWeight(token);\n    uint256 weightPerSecond = _getWeightPerSecond(fromDenorm, targetDenorm, fromTimestamp, targetTimestamp);\n    require(weightPerSecond <= _maxWeightPerSecond, \"MAX_WEIGHT_PER_SECOND\");\n    require(weightPerSecond >= _minWeightPerSecond, \"MIN_WEIGHT_PER_SECOND\");\n\n    _records[token].denorm = fromDenorm;\n\n    _dynamicWeights[token] = DynamicWeight({\n      fromTimestamp: fromTimestamp,\n      targetTimestamp: targetTimestamp,\n      targetDenorm: targetDenorm\n    });\n\n    uint256 denormSum = 0;\n    uint256 len = _tokens.length;\n    for (uint256 i = 0; i < len; i++) {\n      denormSum = badd(denormSum, _dynamicWeights[_tokens[i]].targetDenorm);\n    }\n\n    require(denormSum <= MAX_TOTAL_WEIGHT, \"MAX_TARGET_TOTAL_WEIGHT\");\n\n    emit SetDynamicWeight(token, fromDenorm, targetDenorm, fromTimestamp, targetTimestamp);\n  }\n\n  /**\n   * @notice Bind and setDynamicWeight at the same time\n   * @param token Token for bind\n   * @param balance Initial balance\n   * @param targetDenorm Target weight\n   * @param fromTimestamp From timestamp of dynamic weight\n   * @param targetTimestamp Target timestamp of dynamic weight\n   */\n  function bind(\n    address token,\n    uint256 balance,\n    uint256 targetDenorm,\n    uint256 fromTimestamp,\n    uint256 targetTimestamp\n  )\n    external\n    _logs_ // _lock_  Bind does not lock because it jumps to `rebind` and `setDynamicWeight`, which does\n  {\n    super.bind(token, balance, MIN_WEIGHT);\n\n    setDynamicWeight(token, targetDenorm, fromTimestamp, targetTimestamp);\n  }\n\n  /**\n   * @notice Override parent unbind function\n   * @param token Token for unbind\n   */\n  function unbind(address token) public override {\n    super.unbind(token);\n\n    _dynamicWeights[token] = DynamicWeight(0, 0, 0);\n  }\n\n  /**\n   * @notice Override parent bind function and disable.\n   */\n  function bind(\n    address,\n    uint256,\n    uint256\n  ) public override {\n    revert(\"DISABLED\"); // Only new bind function is allowed\n  }\n\n  /**\n   * @notice Override parent rebind function. Allowed only for calling from bind function\n   * @param token Token for rebind\n   * @param balance Balance for rebind\n   * @param denorm Weight for rebind\n   */\n  function rebind(\n    address token,\n    uint256 balance,\n    uint256 denorm\n  ) public override {\n    require(denorm == MIN_WEIGHT && _dynamicWeights[token].fromTimestamp == 0, \"ONLY_NEW_TOKENS_ALLOWED\");\n    super.rebind(token, balance, denorm);\n  }\n\n  /*** View Functions ***/\n\n  function getDynamicWeightSettings(address token)\n    external\n    view\n    returns (\n      uint256 fromTimestamp,\n      uint256 targetTimestamp,\n      uint256 fromDenorm,\n      uint256 targetDenorm\n    )\n  {\n    DynamicWeight storage dw = _dynamicWeights[token];\n    return (dw.fromTimestamp, dw.targetTimestamp, _records[token].denorm, dw.targetDenorm);\n  }\n\n  function getWeightPerSecondBounds() external view returns (uint256 minWeightPerSecond, uint256 maxWeightPerSecond) {\n    return (_minWeightPerSecond, _maxWeightPerSecond);\n  }\n\n  /*** Internal Functions ***/\n\n  function _getDenormWeight(address token) internal view override returns (uint256) {\n    DynamicWeight memory dw = _dynamicWeights[token];\n    uint256 fromDenorm = _records[token].denorm;\n\n    if (dw.fromTimestamp == 0 || dw.targetDenorm == fromDenorm || block.timestamp <= dw.fromTimestamp) {\n      return fromDenorm;\n    }\n    if (block.timestamp >= dw.targetTimestamp) {\n      return dw.targetDenorm;\n    }\n\n    uint256 weightPerSecond = _getWeightPerSecond(fromDenorm, dw.targetDenorm, dw.fromTimestamp, dw.targetTimestamp);\n    uint256 deltaCurrentTime = bsub(block.timestamp, dw.fromTimestamp);\n    if (dw.targetDenorm > fromDenorm) {\n      return badd(fromDenorm, deltaCurrentTime * weightPerSecond);\n    } else {\n      return bsub(fromDenorm, deltaCurrentTime * weightPerSecond);\n    }\n  }\n\n  function _getWeightPerSecond(\n    uint256 fromDenorm,\n    uint256 targetDenorm,\n    uint256 fromTimestamp,\n    uint256 targetTimestamp\n  ) internal pure returns (uint256) {\n    uint256 delta = targetDenorm > fromDenorm ? bsub(targetDenorm, fromDenorm) : bsub(fromDenorm, targetDenorm);\n    return div(delta, bsub(targetTimestamp, fromTimestamp));\n  }\n\n  function _getTotalWeight() internal view override returns (uint256) {\n    uint256 sum = 0;\n    uint256 len = _tokens.length;\n    for (uint256 i = 0; i < len; i++) {\n      sum = badd(sum, _getDenormWeight(_tokens[i]));\n    }\n    return sum;\n  }\n\n  function _addTotalWeight(uint256 _amount) internal virtual override {\n    // storage total weight don't change, it's calculated only by _getTotalWeight()\n  }\n\n  function _subTotalWeight(uint256 _amount) internal virtual override {\n    // storage total weight don't change, it's calculated only by _getTotalWeight()\n  }\n}\n"
27     },
28     "contracts/balancer-core/BPool.sol": {
29       "content": "// SPDX-License-Identifier: GPL-3.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.6.12;\n\nimport \"./BToken.sol\";\nimport \"./BMath.sol\";\nimport \"../interfaces/IPoolRestrictions.sol\";\nimport \"../interfaces/BPoolInterface.sol\";\n\ncontract BPool is BToken, BMath, BPoolInterface {\n\n    struct Record {\n        bool bound;   // is token bound to pool\n        uint index;   // private\n        uint denorm;  // denormalized weight\n        uint balance;\n    }\n\n    event LOG_SWAP(\n        address indexed caller,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256         tokenAmountIn,\n        uint256         tokenAmountOut\n    );\n\n    event LOG_JOIN(\n        address indexed caller,\n        address indexed tokenIn,\n        uint256         tokenAmountIn\n    );\n\n    event LOG_EXIT(\n        address indexed caller,\n        address indexed tokenOut,\n        uint256         tokenAmountOut\n    );\n\n    event LOG_CALL(\n        bytes4  indexed sig,\n        address indexed caller,\n        bytes           data\n    ) anonymous;\n\n    event LOG_CALL_VOTING(\n        address indexed voting,\n        bool    indexed success,\n        bytes4  indexed inputSig,\n        bytes           inputData,\n        bytes           outputData\n    );\n\n    event LOG_COMMUNITY_FEE(\n        address indexed caller,\n        address indexed receiver,\n        address indexed token,\n        uint256         tokenAmount\n    );\n\n    modifier _logs_() {\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\n        _;\n    }\n\n    modifier _lock_() {\n        _preventReentrancy();\n        _mutex = true;\n        _;\n        _mutex = false;\n    }\n\n    modifier _viewlock_() {\n        _preventReentrancy();\n        _;\n    }\n\n    bool private _mutex;\n\n    address private _controller; // has CONTROL role\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\n\n    address private _wrapper; // can join, exit and swaps when _wrapperMode is true\n    bool private _wrapperMode;\n\n    IPoolRestrictions private _restrictions;\n\n    // `setSwapFee` and `finalize` require CONTROL\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\n    uint private _swapFee;\n    uint private _communitySwapFee;\n    uint private _communityJoinFee;\n    uint private _communityExitFee;\n    address private _communityFeeReceiver;\n    bool private _finalized;\n\n    address[] internal _tokens;\n    mapping(address => Record) internal _records;\n    uint internal _totalWeight;\n\n    mapping(address => uint256) internal _lastSwapBlock;\n\n    constructor(string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _controller = msg.sender;\n        _swapFee = MIN_FEE;\n        _communitySwapFee = 0;\n        _communityJoinFee = 0;\n        _communityExitFee = 0;\n        _publicSwap = false;\n        _finalized = false;\n    }\n\n    function isPublicSwap()\n        external view override\n        returns (bool)\n    {\n        return _publicSwap;\n    }\n\n    function isFinalized()\n        external view override\n        returns (bool)\n    {\n        return _finalized;\n    }\n\n    function isBound(address t)\n        external view override\n        returns (bool)\n    {\n        return _records[t].bound;\n    }\n\n    function getNumTokens()\n        external view\n        returns (uint)\n    {\n        return _tokens.length;\n    }\n\n    function getCurrentTokens()\n        external view override\n        _viewlock_\n        returns (address[] memory tokens)\n    {\n        return _tokens;\n    }\n\n    function getFinalTokens()\n        external view override\n        _viewlock_\n        returns (address[] memory tokens)\n    {\n        _requireContractIsFinalized();\n        return _tokens;\n    }\n\n    function getDenormalizedWeight(address token)\n        external view override\n        _viewlock_\n        returns (uint)\n    {\n\n        _requireTokenIsBound(token);\n        return _getDenormWeight(token);\n    }\n\n    function getTotalDenormalizedWeight()\n        external view override\n        _viewlock_\n        returns (uint)\n    {\n        return _getTotalWeight();\n    }\n\n    function getNormalizedWeight(address token)\n        external view\n        _viewlock_\n        returns (uint)\n    {\n\n        _requireTokenIsBound(token);\n        return bdiv(_getDenormWeight(token), _getTotalWeight());\n    }\n\n    function getBalance(address token)\n        external view override\n        _viewlock_\n        returns (uint)\n    {\n\n        _requireTokenIsBound(token);\n        return _records[token].balance;\n    }\n\n    function getSwapFee()\n        external view override\n        _viewlock_\n        returns (uint)\n    {\n        return _swapFee;\n    }\n\n    function getCommunityFee()\n        external view override\n        _viewlock_\n        returns (uint communitySwapFee, uint communityJoinFee, uint communityExitFee, address communityFeeReceiver)\n    {\n        return (_communitySwapFee, _communityJoinFee, _communityExitFee, _communityFeeReceiver);\n    }\n\n    function getController()\n        external view\n        _viewlock_\n        returns (address)\n    {\n        return _controller;\n    }\n\n    function getWrapper()\n        external view\n        _viewlock_\n        returns (address)\n    {\n        return _wrapper;\n    }\n\n    function getWrapperMode()\n        external view\n        _viewlock_\n        returns (bool)\n    {\n        return _wrapperMode;\n    }\n\n    function getRestrictions()\n        external view override\n        _viewlock_\n        returns (address)\n    {\n        return address(_restrictions);\n    }\n\n    function setSwapFee(uint swapFee)\n        external override\n        _logs_\n        _lock_\n    {\n        _onlyController();\n        _requireFeeInBounds(swapFee);\n        _swapFee = swapFee;\n    }\n\n    function setCommunityFeeAndReceiver(\n        uint communitySwapFee,\n        uint communityJoinFee,\n        uint communityExitFee,\n        address communityFeeReceiver\n    )\n        external override\n        _logs_\n        _lock_\n    {\n        _onlyController();\n        _requireFeeInBounds(communitySwapFee);\n        _requireFeeInBounds(communityJoinFee);\n        _requireFeeInBounds(communityExitFee);\n        _communitySwapFee = communitySwapFee;\n        _communityJoinFee = communityJoinFee;\n        _communityExitFee = communityExitFee;\n        _communityFeeReceiver = communityFeeReceiver;\n    }\n\n    function setRestrictions(IPoolRestrictions restrictions)\n        external\n        _logs_\n        _lock_\n    {\n        _onlyController();\n        _restrictions = restrictions;\n    }\n\n    function setController(address manager)\n        external override\n        _logs_\n        _lock_\n    {\n        _onlyController();\n        _controller = manager;\n    }\n\n    function setPublicSwap(bool public_)\n        external override\n        _logs_\n        _lock_\n    {\n        _requireContractIsNotFinalized();\n        _onlyController();\n        _publicSwap = public_;\n    }\n\n    function setWrapper(address wrapper, bool wrapperMode)\n        external\n        _logs_\n        _lock_\n    {\n        _onlyController();\n        _wrapper = wrapper;\n        _wrapperMode = wrapperMode;\n    }\n\n    function finalize()\n        external override\n        _logs_\n        _lock_\n    {\n        _onlyController();\n        _requireContractIsNotFinalized();\n        require(_tokens.length >= MIN_BOUND_TOKENS, \"MIN_TOKENS\");\n\n        _finalized = true;\n        _publicSwap = true;\n\n        _mintPoolShare(INIT_POOL_SUPPLY);\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\n    }\n\n    function callVoting(address voting, bytes4 signature, bytes calldata args, uint256 value)\n        external override\n        _logs_\n        _lock_\n    {\n        require(_restrictions.isVotingSignatureAllowed(voting, signature), \"NOT_ALLOWED_SIG\");\n        _onlyController();\n\n        (bool success, bytes memory data) = voting.call{ value: value }(abi.encodePacked(signature, args));\n        require(success, \"NOT_SUCCESS\");\n        emit LOG_CALL_VOTING(voting, success, signature, args, data);\n    }\n\n    function bind(address token, uint balance, uint denorm)\n        public override\n        virtual\n        _logs_\n        // _lock_  Bind does not lock because it jumps to `rebind`, which does\n    {\n        _onlyController();\n        require(!_records[token].bound, \"IS_BOUND\");\n\n        require(_tokens.length < MAX_BOUND_TOKENS, \"MAX_TOKENS\");\n\n        _records[token] = Record({\n            bound: true,\n            index: _tokens.length,\n            denorm: 0,    // balance and denorm will be validated\n            balance: 0   // and set by `rebind`\n        });\n        _tokens.push(token);\n        rebind(token, balance, denorm);\n    }\n\n    function rebind(address token, uint balance, uint denorm)\n        public override\n        virtual\n        _logs_\n        _lock_\n    {\n        _onlyController();\n        _requireTokenIsBound(token);\n\n        require(denorm >= MIN_WEIGHT && denorm <= MAX_WEIGHT, \"WEIGHT_BOUNDS\");\n        require(balance >= MIN_BALANCE, \"MIN_BALANCE\");\n\n        // Adjust the denorm and totalWeight\n        uint oldWeight = _records[token].denorm;\n        if (denorm > oldWeight) {\n            _addTotalWeight(bsub(denorm, oldWeight));\n        } else if (denorm < oldWeight) {\n            _subTotalWeight(bsub(oldWeight, denorm));\n        }\n        _records[token].denorm = denorm;\n\n        // Adjust the balance record and actual token balance\n        uint oldBalance = _records[token].balance;\n        _records[token].balance = balance;\n        if (balance > oldBalance) {\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\n        } else if (balance < oldBalance) {\n            uint tokenBalanceWithdrawn = bsub(oldBalance, balance);\n            _pushUnderlying(token, msg.sender, tokenBalanceWithdrawn);\n        }\n    }\n\n    function unbind(address token)\n        public override\n        virtual\n        _logs_\n        _lock_\n    {\n        _onlyController();\n        _requireTokenIsBound(token);\n\n        uint tokenBalance = _records[token].balance;\n\n        _subTotalWeight(_records[token].denorm);\n\n        // Swap the token-to-unbind with the last token,\n        // then delete the last token\n        uint index = _records[token].index;\n        uint last = _tokens.length - 1;\n        _tokens[index] = _tokens[last];\n        _records[_tokens[index]].index = index;\n        _tokens.pop();\n        _records[token] = Record({\n            bound: false,\n            index: 0,\n            denorm: 0,\n            balance: 0\n        });\n\n        _pushUnderlying(token, msg.sender, tokenBalance);\n    }\n\n    // Absorb any tokens that have been sent to this contract into the pool\n    function gulp(address token)\n        external\n        _logs_\n        _lock_\n    {\n        _requireTokenIsBound(token);\n        _records[token].balance = IERC20(token).balanceOf(address(this));\n    }\n\n    function getSpotPrice(address tokenIn, address tokenOut)\n        external view\n        _viewlock_\n        returns (uint spotPrice)\n    {\n        require(_records[tokenIn].bound && _records[tokenOut].bound, \"NOT_BOUND\");\n        Record storage inRecord = _records[tokenIn];\n        Record storage outRecord = _records[tokenOut];\n        return calcSpotPrice(inRecord.balance, _getDenormWeight(tokenIn), outRecord.balance, _getDenormWeight(tokenOut), _swapFee);\n    }\n\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\n        external view\n        _viewlock_\n        returns (uint spotPrice)\n    {\n        _requireTokenIsBound(tokenIn);\n        _requireTokenIsBound(tokenOut);\n        Record storage inRecord = _records[tokenIn];\n        Record storage outRecord = _records[tokenOut];\n        return calcSpotPrice(inRecord.balance, _getDenormWeight(tokenIn), outRecord.balance, _getDenormWeight(tokenOut), 0);\n    }\n\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)\n        external override\n        _logs_\n        _lock_\n    {\n        _preventSameTxOrigin();\n        _onlyWrapperOrNotWrapperMode();\n        _requireContractIsFinalized();\n\n        uint poolTotal = totalSupply();\n        uint ratio = bdiv(poolAmountOut, poolTotal);\n        _requireMathApprox(ratio);\n\n        for (uint i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint bal = _records[t].balance;\n            uint tokenAmountIn = bmul(ratio, bal);\n            _requireMathApprox(tokenAmountIn);\n            require(tokenAmountIn <= maxAmountsIn[i], \"LIMIT_IN\");\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\n        }\n\n        (uint poolAmountOutAfterFee, uint poolAmountOutFee) = calcAmountWithCommunityFee(\n            poolAmountOut,\n            _communityJoinFee,\n            msg.sender\n        );\n\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOutAfterFee);\n        _pushPoolShare(_communityFeeReceiver, poolAmountOutFee);\n\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, address(this), poolAmountOutFee);\n    }\n\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\n        external override\n        _logs_\n        _lock_\n    {\n        _preventSameTxOrigin();\n        _onlyWrapperOrNotWrapperMode();\n        _requireContractIsFinalized();\n\n        (uint poolAmountInAfterFee, uint poolAmountInFee) = calcAmountWithCommunityFee(\n            poolAmountIn,\n            _communityExitFee,\n            msg.sender\n        );\n\n        uint poolTotal = totalSupply();\n        uint ratio = bdiv(poolAmountInAfterFee, poolTotal);\n        _requireMathApprox(ratio);\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _pushPoolShare(_communityFeeReceiver, poolAmountInFee);\n        _burnPoolShare(poolAmountInAfterFee);\n\n        for (uint i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint bal = _records[t].balance;\n            uint tokenAmountOut = bmul(ratio, bal);\n            _requireMathApprox(tokenAmountOut);\n            require(tokenAmountOut >= minAmountsOut[i], \"LIMIT_OUT\");\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\n        }\n\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, address(this), poolAmountInFee);\n    }\n\n\n    function swapExactAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        address tokenOut,\n        uint minAmountOut,\n        uint maxPrice\n    )\n        external override\n        _logs_\n        _lock_\n        returns (uint tokenAmountOut, uint spotPriceAfter)\n    {\n        _preventSameTxOrigin();\n        _onlyWrapperOrNotWrapperMode();\n        _requireTokenIsBound(tokenIn);\n        _requireTokenIsBound(tokenOut);\n        require(_publicSwap, \"NOT_PUBLIC\");\n\n        Record storage inRecord = _records[address(tokenIn)];\n        Record storage outRecord = _records[address(tokenOut)];\n\n        uint spotPriceBefore = calcSpotPrice(\n                                    inRecord.balance,\n                                    _getDenormWeight(tokenIn),\n                                    outRecord.balance,\n                                    _getDenormWeight(tokenOut),\n                                    _swapFee\n                                );\n        require(spotPriceBefore <= maxPrice, \"LIMIT_PRICE\");\n\n        (uint tokenAmountInAfterFee, uint tokenAmountInFee) = calcAmountWithCommunityFee(\n                                                                tokenAmountIn,\n                                                                _communitySwapFee,\n                                                                msg.sender\n                                                            );\n\n        require(tokenAmountInAfterFee <= bmul(inRecord.balance, MAX_IN_RATIO), \"MAX_IN_RATIO\");\n\n        tokenAmountOut = calcOutGivenIn(\n                            inRecord.balance,\n                            _getDenormWeight(tokenIn),\n                            outRecord.balance,\n                            _getDenormWeight(tokenOut),\n                            tokenAmountInAfterFee,\n                            _swapFee\n                        );\n        require(tokenAmountOut >= minAmountOut, \"LIMIT_OUT\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountInAfterFee);\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        spotPriceAfter = calcSpotPrice(\n                                inRecord.balance,\n                                _getDenormWeight(tokenIn),\n                                outRecord.balance,\n                                _getDenormWeight(tokenOut),\n                                _swapFee\n                            );\n        require(\n            spotPriceAfter >= spotPriceBefore &&\n            spotPriceBefore <= bdiv(tokenAmountInAfterFee, tokenAmountOut),\n            \"MATH_APPROX\"\n        );\n        require(spotPriceAfter <= maxPrice, \"LIMIT_PRICE\");\n\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountInAfterFee, tokenAmountOut);\n\n        _pullCommunityFeeUnderlying(tokenIn, msg.sender, tokenAmountInFee);\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountInAfterFee);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, tokenIn, tokenAmountInFee);\n\n        return (tokenAmountOut, spotPriceAfter);\n    }\n\n    function swapExactAmountOut(\n        address tokenIn,\n        uint maxAmountIn,\n        address tokenOut,\n        uint tokenAmountOut,\n        uint maxPrice\n    )\n        external override\n        _logs_\n        _lock_\n        returns (uint tokenAmountIn, uint spotPriceAfter)\n    {\n        _preventSameTxOrigin();\n        _onlyWrapperOrNotWrapperMode();\n        _requireTokenIsBound(tokenIn);\n        _requireTokenIsBound(tokenOut);\n        require(_publicSwap, \"NOT_PUBLIC\");\n\n        Record storage inRecord = _records[address(tokenIn)];\n        Record storage outRecord = _records[address(tokenOut)];\n\n        require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), \"OUT_RATIO\");\n\n        uint spotPriceBefore = calcSpotPrice(\n                                    inRecord.balance,\n                                    _getDenormWeight(tokenIn),\n                                    outRecord.balance,\n                                    _getDenormWeight(tokenOut),\n                                    _swapFee\n                                );\n        require(spotPriceBefore <= maxPrice, \"LIMIT_PRICE\");\n\n        (uint tokenAmountOutAfterFee, uint tokenAmountOutFee) = calcAmountWithCommunityFee(\n            tokenAmountOut,\n            _communitySwapFee,\n            msg.sender\n        );\n\n        tokenAmountIn = calcInGivenOut(\n                            inRecord.balance,\n                            _getDenormWeight(tokenIn),\n                            outRecord.balance,\n                            _getDenormWeight(tokenOut),\n                            tokenAmountOut,\n                            _swapFee\n                        );\n        require(tokenAmountIn <= maxAmountIn, \"LIMIT_IN\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        spotPriceAfter = calcSpotPrice(\n                                inRecord.balance,\n                                _getDenormWeight(tokenIn),\n                                outRecord.balance,\n                                _getDenormWeight(tokenOut),\n                                _swapFee\n                            );\n        require(\n            spotPriceAfter >= spotPriceBefore &&\n            spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOutAfterFee),\n            \"MATH_APPROX\"\n        );\n        require(spotPriceAfter <= maxPrice, \"LIMIT_PRICE\");\n\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOutAfterFee);\n\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOutAfterFee);\n        _pushUnderlying(tokenOut, _communityFeeReceiver, tokenAmountOutFee);\n\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, tokenOut, tokenAmountOutFee);\n\n        return (tokenAmountIn, spotPriceAfter);\n    }\n\n\n    function joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\n        external override\n        _logs_\n        _lock_\n        returns (uint poolAmountOut)\n\n    {\n        _preventSameTxOrigin();\n        _requireContractIsFinalized();\n        _onlyWrapperOrNotWrapperMode();\n        _requireTokenIsBound(tokenIn);\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \"MAX_IN_RATIO\");\n\n        (uint tokenAmountInAfterFee, uint tokenAmountInFee) = calcAmountWithCommunityFee(\n            tokenAmountIn,\n            _communityJoinFee,\n            msg.sender\n        );\n\n        Record storage inRecord = _records[tokenIn];\n\n        poolAmountOut = calcPoolOutGivenSingleIn(\n                            inRecord.balance,\n                            _getDenormWeight(tokenIn),\n                            _totalSupply,\n                            _getTotalWeight(),\n                            tokenAmountInAfterFee,\n                            _swapFee\n                        );\n\n        require(poolAmountOut >= minPoolAmountOut, \"LIMIT_OUT\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountInAfterFee);\n\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountInAfterFee);\n\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n        _pullCommunityFeeUnderlying(tokenIn, msg.sender, tokenAmountInFee);\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountInAfterFee);\n\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, tokenIn, tokenAmountInFee);\n\n        return poolAmountOut;\n    }\n\n    function joinswapPoolAmountOut(address tokenIn, uint poolAmountOut, uint maxAmountIn)\n        external override\n        _logs_\n        _lock_\n        returns (uint tokenAmountIn)\n    {\n        _preventSameTxOrigin();\n        _requireContractIsFinalized();\n        _onlyWrapperOrNotWrapperMode();\n        _requireTokenIsBound(tokenIn);\n\n        Record storage inRecord = _records[tokenIn];\n\n        (uint poolAmountOutAfterFee, uint poolAmountOutFee) = calcAmountWithCommunityFee(\n            poolAmountOut,\n            _communityJoinFee,\n            msg.sender\n        );\n\n        tokenAmountIn = calcSingleInGivenPoolOut(\n                            inRecord.balance,\n                            _getDenormWeight(tokenIn),\n                            _totalSupply,\n                            _getTotalWeight(),\n                            poolAmountOut,\n                            _swapFee\n                        );\n\n        _requireMathApprox(tokenAmountIn);\n        require(tokenAmountIn <= maxAmountIn, \"LIMIT_IN\");\n\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \"MAX_IN_RATIO\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOutAfterFee);\n        _pushPoolShare(_communityFeeReceiver, poolAmountOutFee);\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, address(this), poolAmountOutFee);\n\n        return tokenAmountIn;\n    }\n\n    function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut)\n        external override\n        _logs_\n        _lock_\n        returns (uint tokenAmountOut)\n    {\n        _preventSameTxOrigin();\n        _requireContractIsFinalized();\n        _onlyWrapperOrNotWrapperMode();\n        _requireTokenIsBound(tokenOut);\n\n        Record storage outRecord = _records[tokenOut];\n\n        tokenAmountOut = calcSingleOutGivenPoolIn(\n                            outRecord.balance,\n                            _getDenormWeight(tokenOut),\n                            _totalSupply,\n                            _getTotalWeight(),\n                            poolAmountIn,\n                            _swapFee\n                        );\n\n        require(tokenAmountOut >= minAmountOut, \"LIMIT_OUT\");\n\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \"OUT_RATIO\");\n\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        (uint tokenAmountOutAfterFee, uint tokenAmountOutFee) = calcAmountWithCommunityFee(\n            tokenAmountOut,\n            _communityExitFee,\n            msg.sender\n        );\n\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOutAfterFee);\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _burnPoolShare(poolAmountIn);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOutAfterFee);\n        _pushUnderlying(tokenOut, _communityFeeReceiver, tokenAmountOutFee);\n\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, tokenOut, tokenAmountOutFee);\n\n        return tokenAmountOutAfterFee;\n    }\n\n    function exitswapExternAmountOut(address tokenOut, uint tokenAmountOut, uint maxPoolAmountIn)\n        external override\n        _logs_\n        _lock_\n        returns (uint poolAmountIn)\n    {\n        _preventSameTxOrigin();\n        _requireContractIsFinalized();\n        _onlyWrapperOrNotWrapperMode();\n        _requireTokenIsBound(tokenOut);\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \"OUT_RATIO\");\n\n        Record storage outRecord = _records[tokenOut];\n\n        (uint tokenAmountOutAfterFee, uint tokenAmountOutFee) = calcAmountWithCommunityFee(\n            tokenAmountOut,\n            _communityExitFee,\n            msg.sender\n        );\n\n        poolAmountIn = calcPoolInGivenSingleOut(\n                            outRecord.balance,\n                            _getDenormWeight(tokenOut),\n                            _totalSupply,\n                            _getTotalWeight(),\n                            tokenAmountOut,\n                            _swapFee\n                        );\n\n        _requireMathApprox(poolAmountIn);\n        require(poolAmountIn <= maxPoolAmountIn, \"LIMIT_IN\");\n\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOutAfterFee);\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _burnPoolShare(poolAmountIn);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOutAfterFee);\n        _pushUnderlying(tokenOut, _communityFeeReceiver, tokenAmountOutFee);\n\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, tokenOut, tokenAmountOutFee);\n\n        return poolAmountIn;\n    }\n\n\n    // ==\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\n    // You must `_lock_` or otherwise ensure reentry-safety\n\n    function _pullUnderlying(address erc20, address from, uint amount)\n        internal\n    {\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\n        require(xfer, \"ERC20_FALSE\");\n    }\n\n    function _pushUnderlying(address erc20, address to, uint amount)\n        internal\n    {\n        bool xfer = IERC20(erc20).transfer(to, amount);\n        require(xfer, \"ERC20_FALSE\");\n    }\n\n    function _pullCommunityFeeUnderlying(address erc20, address from, uint amount)\n        internal\n    {\n        bool xfer = IERC20(erc20).transferFrom(from, _communityFeeReceiver, amount);\n        require(xfer, \"ERC20_FALSE\");\n    }\n\n    function _pullPoolShare(address from, uint amount)\n        internal\n    {\n        _pull(from, amount);\n    }\n\n    function _pushPoolShare(address to, uint amount)\n        internal\n    {\n        _push(to, amount);\n    }\n\n    function _mintPoolShare(uint amount)\n        internal\n    {\n        if(address(_restrictions) != address(0)) {\n            uint maxTotalSupply = _restrictions.getMaxTotalSupply(address(this));\n            require(badd(_totalSupply, amount) <= maxTotalSupply, \"MAX_SUPPLY\");\n        }\n        _mint(amount);\n    }\n\n    function _burnPoolShare(uint amount)\n        internal\n    {\n        _burn(amount);\n    }\n\n    function _requireTokenIsBound(address token)\n        internal view\n    {\n        require(_records[token].bound, \"NOT_BOUND\");\n    }\n\n    function _onlyController()\n        internal view\n    {\n        require(msg.sender == _controller, \"NOT_CONTROLLER\");\n    }\n\n    function _requireContractIsNotFinalized()\n        internal view\n    {\n        require(!_finalized, \"IS_FINALIZED\");\n    }\n\n    function _requireContractIsFinalized()\n        internal view\n    {\n        require(_finalized, \"NOT_FINALIZED\");\n    }\n\n    function _requireFeeInBounds(uint256 _fee)\n        internal pure\n    {\n        require(_fee >= MIN_FEE && _fee <= MAX_FEE, \"FEE_BOUNDS\");\n    }\n\n    function _requireMathApprox(uint256 _value)\n        internal pure\n    {\n        require(_value != 0, \"MATH_APPROX\");\n    }\n\n    function _preventReentrancy()\n        internal view\n    {\n        require(!_mutex, \"REENTRY\");\n    }\n\n    function _onlyWrapperOrNotWrapperMode()\n        internal view\n    {\n        require(!_wrapperMode || msg.sender == _wrapper, \"ONLY_WRAPPER\");\n    }\n\n    function _preventSameTxOrigin()\n      internal\n    {\n      require(block.number > _lastSwapBlock[tx.origin], \"SAME_TX_ORIGIN\");\n      _lastSwapBlock[tx.origin] = block.number;\n    }\n\n    function _getDenormWeight(address token)\n        internal view virtual\n        returns (uint)\n    {\n        return _records[token].denorm;\n    }\n\n    function _getTotalWeight()\n        internal view virtual\n        returns (uint)\n    {\n        return _totalWeight;\n    }\n\n    function _addTotalWeight(uint _amount) internal virtual {\n        _totalWeight = badd(_totalWeight, _amount);\n        require(_totalWeight <= MAX_TOTAL_WEIGHT, \"MAX_TOTAL_WEIGHT\");\n    }\n\n    function _subTotalWeight(uint _amount) internal virtual {\n        _totalWeight = bsub(_totalWeight, _amount);\n    }\n\n    function calcAmountWithCommunityFee(\n        uint tokenAmountIn,\n        uint communityFee,\n        address operator\n    )\n        public view override\n        returns (uint tokenAmountInAfterFee, uint tokenAmountFee)\n    {\n        if (address(_restrictions) != address(0) && _restrictions.isWithoutFee(operator)) {\n            return (tokenAmountIn, 0);\n        }\n        uint adjustedIn = bsub(BONE, communityFee);\n        tokenAmountInAfterFee = bmul(tokenAmountIn, adjustedIn);\n        tokenAmountFee = bsub(tokenAmountIn, tokenAmountInAfterFee);\n        return (tokenAmountInAfterFee, tokenAmountFee);\n    }\n\n    function getMinWeight()\n        external view override\n        returns (uint)\n    {\n        return MIN_WEIGHT;\n    }\n\n    function getMaxBoundTokens()\n        external view override\n        returns (uint)\n    {\n      return MAX_BOUND_TOKENS;\n    }\n}\n"
30     },
31     "contracts/balancer-core/BMath.sol": {
32       "content": "// SPDX-License-Identifier: GPL-3.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.6.12;\n\nimport \"./BNum.sol\";\nimport \"../interfaces/BMathInterface.sol\";\n\ncontract BMath is BConst, BNum, BMathInterface {\n    /**********************************************************************************************\n    // calcSpotPrice                                                                             //\n    // sP = spotPrice                                                                            //\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcSpotPrice(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint swapFee\n    )\n        public pure\n        returns (uint spotPrice)\n    {\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\n        uint ratio = bdiv(numer, denom);\n        uint scale = bdiv(BONE, bsub(BONE, swapFee));\n        return  (spotPrice = bmul(ratio, scale));\n    }\n\n    /**********************************************************************************************\n    // calcOutGivenIn                                                                            //\n    // aO = tokenAmountOut                                                                       //\n    // bO = tokenBalanceOut                                                                      //\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcOutGivenIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint tokenAmountIn,\n        uint swapFee\n    )\n        public pure\n        returns (uint tokenAmountOut)\n    {\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n        uint adjustedIn = bsub(BONE, swapFee);\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\n        uint foo = bpow(y, weightRatio);\n        uint bar = bsub(BONE, foo);\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcInGivenOut                                                                            //\n    // aI = tokenAmountIn                                                                        //\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\n    // wI = tokenWeightIn           --------------------------------------------                 //\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcInGivenOut(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint tokenAmountOut,\n        uint swapFee\n    )\n        public pure override\n        returns (uint tokenAmountIn)\n    {\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\n        uint y = bdiv(tokenBalanceOut, diff);\n        uint foo = bpow(y, weightRatio);\n        foo = bsub(foo, BONE);\n        tokenAmountIn = bsub(BONE, swapFee);\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcPoolOutGivenSingleIn                                                                  //\n    // pAo = poolAmountOut         /                                              \\              //\n    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\n    // pS = poolSupply            \\\\                    tBi               /        /             //\n    // sF = swapFee                \\                                              /              //\n    **********************************************************************************************/\n    function calcPoolOutGivenSingleIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountIn,\n        uint swapFee\n    )\n        public pure\n        returns (uint poolAmountOut)\n    {\n        // Charge the trading fee for the proportion of tokenAi\n        ///  which is implicitly traded to the other pool tokens.\n        // That proportion is (1- weightTokenIn)\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\n\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\n        return poolAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcSingleInGivenPoolOut                                                                  //\n    // tAi = tokenAmountIn              //(pS + pAo)\\     /    1    \\\\                           //\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\n    // pAo = poolAmountOut              \\\\    pS    /     \\(wI / tW)//                           //\n    // bI = balanceIn          tAi =  --------------------------------------------               //\n    // wI = weightIn                              /      wI  \\                                   //\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\n    // sF = swapFee                               \\      tW  /                                   //\n    **********************************************************************************************/\n    function calcSingleInGivenPoolOut(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountOut,\n        uint swapFee\n    )\n        public pure\n        returns (uint tokenAmountIn)\n    {\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\n\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\n        uint boo = bdiv(BONE, normalizedWeight);\n        uint tokenInRatio = bpow(poolRatio, boo);\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\n        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\n        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcSingleOutGivenPoolIn                                                                  //\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\n    // bO = tokenBalanceOut           /      //       pS - pAi        \\     /    1    \\      \\\\  //\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\n    // tW = totalWeight                    /     /      wO \\       \\                             //\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\n    // eF = exitFee                        \\     \\      tW /       /                             //\n    **********************************************************************************************/\n    function calcSingleOutGivenPoolIn(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountIn,\n        uint swapFee\n    )\n        public pure\n        returns (uint tokenAmountOut)\n    {\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        uint newPoolSupply = bsub(poolSupply, poolAmountIn);\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\n\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\n\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\n\n        // charge swap fee on the output token side\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcPoolInGivenSingleOut                                                                  //\n    // pAi = poolAmountIn               // /               tAo             \\\\     / wO \\     \\   //\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\   | ---- |     \\  //\n    // tAo = tokenAmountOut      pS - ||   \\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\ tW /  * pS | //\n    // ps = poolSupply                 \\\\ -----------------------------------/                /  //\n    // wO = tokenWeightOut  pAi =       \\\\               bO                 /                /   //\n    // tW = totalWeight                                                                          //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcPoolInGivenSingleOut(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountOut,\n        uint swapFee\n    )\n        public pure\n        returns (uint poolAmountIn)\n    {\n\n        // charge swap fee on the output token side\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\n        uint zoo = bsub(BONE, normalizedWeight);\n        uint zar = bmul(zoo, swapFee);\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\n\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\n\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\n        uint poolAmountIn = bsub(poolSupply, newPoolSupply);\n        return poolAmountIn;\n    }\n}\n"
33     },
34     "contracts/interfaces/IPoolRestrictions.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IPoolRestrictions {\n  function getMaxTotalSupply(address _pool) external view returns (uint256);\n\n  function isVotingSignatureAllowed(address _votingAddress, bytes4 _signature) external view returns (bool);\n\n  function isVotingSenderAllowed(address _votingAddress, address _sender) external view returns (bool);\n\n  function isWithoutFee(address _addr) external view returns (bool);\n}\n"
36     }
37   },
38   "settings": {
39     "optimizer": {
40       "enabled": true,
41       "runs": 2
42     },
43     "outputSelection": {
44       "*": {
45         "*": [
46           "evm.bytecode",
47           "evm.deployedBytecode",
48           "abi"
49         ]
50       }
51     },
52     "libraries": {}
53   }
54 }}