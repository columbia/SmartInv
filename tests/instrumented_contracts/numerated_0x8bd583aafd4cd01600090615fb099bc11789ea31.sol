1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "london",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "details": {
12         "constantOptimizer": true,
13         "cse": true,
14         "deduplicate": true,
15         "inliner": true,
16         "jumpdestRemover": true,
17         "orderLiterals": true,
18         "peephole": true,
19         "yul": true,
20         "yulDetails": {
21           "optimizerSteps": "dhfoDgvulfnTUtnIf",
22           "stackAllocation": true
23         }
24       },
25       "runs": 2000
26     },
27     "remappings": [],
28     "outputSelection": {
29       "*": {
30         "*": [
31           "evm.bytecode",
32           "evm.deployedBytecode",
33           "devdoc",
34           "userdoc",
35           "metadata",
36           "abi"
37         ]
38       }
39     }
40   },
41   "sources": {
42     "@openzeppelin/contracts/security/Pausable.sol": {
43       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
44     },
45     "@openzeppelin/contracts/utils/Context.sol": {
46       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
47     },
48     "contracts/PirateGames.sol": {
49       "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"./interfaces/IPirateGames.sol\";\r\nimport \"./interfaces/IPytheas.sol\";\r\nimport \"./interfaces/IOrbitalBlockade.sol\";\r\nimport \"./interfaces/ITPirates.sol\";\r\nimport \"./interfaces/IRAW.sol\";\r\nimport \"./interfaces/IPirates.sol\";\r\nimport \"./interfaces/IColonist.sol\";\r\nimport \"./interfaces/IImperialGuild.sol\";\r\nimport \"./interfaces/IRandomizer.sol\";\r\n\r\ncontract PirateGames is IPirateGames, Pausable {\r\n    uint8[][6] public rarities;\r\n    uint8[][6] public aliases;\r\n\r\n    uint256 public OnosiaLiquorId;\r\n\r\n    uint256 private maxRawEonCost;\r\n\r\n    uint256 public imperialFee;\r\n\r\n    // address => can call\r\n    mapping(address => bool) private admins;\r\n\r\n    address public auth;\r\n\r\n    // reference to Pytheas for checking that a colonist has mined enough\r\n    //rEON to make an attempt as well as pay from this amount, either the  current mint cost on\r\n    //a successful pirate mint, or pirate tax on a failed attempt.\r\n    IPytheas public pytheas;\r\n    //reference to the OrbitalBlockade, where pirates are staked out, awaiting weak colonist miners.\r\n    IOrbitalBlockade public orbital;\r\n    // reference to raw Eon for attempts\r\n    IRAW public raw;\r\n    // reference to pirate collection\r\n    IPirates public pirateNFT;\r\n    // reference to the colonist NFT collection\r\n    IColonist public colonistNFT;\r\n    // reference to the galactic imperialGuild collection\r\n    IImperialGuild public imperialGuild;\r\n    //randy the randomizer\r\n    IRandomizer private randomizer;\r\n\r\n    //ratio chance\r\n\r\n    constructor() {\r\n        _pause();\r\n        auth = msg.sender;\r\n        admins[msg.sender] = true;\r\n\r\n        //RatioChance 90\r\n        rarities[0] = [27, 230];\r\n        aliases[0] = [1, 0];\r\n        //RatioChance 80\r\n        rarities[1] = [51, 204];\r\n        aliases[1] = [1, 0];\r\n        //RatioChance 60\r\n        rarities[2] = [90, 175];\r\n        aliases[2] = [1, 0];\r\n        //RatioChance 40\r\n        rarities[3] = [155, 132];\r\n        aliases[3] = [1, 0];\r\n        //RatioChance 10\r\n        rarities[4] = [200, 60];\r\n        aliases[4] = [1, 0];\r\n        //RatioChance 0\r\n        rarities[5] = [255];\r\n        aliases[5] = [0];\r\n    }\r\n\r\n    modifier noCheaters() {\r\n        uint256 size = 0;\r\n        address acc = msg.sender;\r\n        assembly {\r\n            size := extcodesize(acc)\r\n        }\r\n\r\n        require(\r\n            admins[msg.sender] || (msg.sender == tx.origin && size == 0),\r\n            \"you're trying to cheat!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == auth);\r\n        _;\r\n    }\r\n\r\n    /** CRITICAL TO SETUP */\r\n    modifier requireContractsSet() {\r\n        require(\r\n            address(raw) != address(0) &&\r\n                address(pirateNFT) != address(0) &&\r\n                address(colonistNFT) != address(0) &&\r\n                address(pytheas) != address(0) &&\r\n                address(orbital) != address(0) &&\r\n                address(imperialGuild) != address(0) &&\r\n                address(randomizer) != address(0),\r\n            \"Contracts not set\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setContracts(\r\n        address _rEON,\r\n        address _pirateNFT,\r\n        address _colonistNFT,\r\n        address _pytheas,\r\n        address _orbital,\r\n        address _imperialGuild,\r\n        address _randomizer\r\n    ) external onlyOwner {\r\n        raw = IRAW(_rEON);\r\n        pirateNFT = IPirates(_pirateNFT);\r\n        colonistNFT = IColonist(_colonistNFT);\r\n        pytheas = IPytheas(_pytheas);\r\n        orbital = IOrbitalBlockade(_orbital);\r\n        imperialGuild = IImperialGuild(_imperialGuild);\r\n        randomizer = IRandomizer(_randomizer);\r\n    }\r\n\r\n    function pirateAttempt(uint16 tokenId, bool stake) external noCheaters whenNotPaused {\r\n        uint16 piratesMinted = pirateNFT.piratesMinted();\r\n        uint256 totalCir = colonistNFT.totalCir();\r\n        uint256 minted = colonistNFT.minted();\r\n        uint256 seed = random(minted);\r\n        uint256 maxTokens = colonistNFT.getMaxTokens();\r\n        uint256 rawCost = rawMintCost(minted, maxTokens);\r\n        uint256 mined = pytheas.getColonistMined(msg.sender, tokenId);\r\n        require(\r\n            mined >= rawCost,\r\n            \"You have not mined enough to attempt this action\"\r\n        );\r\n        uint8 chanceTable = getRatioChance(piratesMinted, totalCir);\r\n        uint8 yayNay = getPirateResults(seed, chanceTable);\r\n        // if the attempt fails, pay pirate tax and claim remaining\r\n        if (yayNay == 0) {\r\n            pytheas.payUp(tokenId, mined, msg.sender);\r\n        } else {\r\n            pytheas.handleJoinPirates(msg.sender, tokenId);\r\n            uint256 outStanding = mined - rawCost;\r\n            raw.updateMintBurns(1, mined, rawCost);\r\n            raw.mint(1, outStanding, msg.sender);\r\n            piratesMinted++;\r\n            uint16[] memory pirateId = new uint16[](1);\r\n            pirateId[0] = piratesMinted;\r\n            address recipient = selectRecipient(seed);\r\n            if (\r\n                recipient != msg.sender &&\r\n                imperialGuild.getBalance(msg.sender, OnosiaLiquorId) > 0\r\n            ) {\r\n                // If the mint is going to be stolen, there's a 50% chance\r\n                //  a pirate will prefer a fine crafted EON liquor over it\r\n                if (seed & 1 == 1) {\r\n                    imperialGuild.safeTransferFrom(\r\n                        msg.sender,\r\n                        recipient,\r\n                        OnosiaLiquorId,\r\n                        1,\r\n                        \"\"\r\n                    );\r\n                    recipient = msg.sender;\r\n                }\r\n            }\r\n            if (!stake || recipient != msg.sender) {\r\n                pirateNFT._mintPirate(recipient, seed);\r\n            } else {\r\n                pirateNFT._mintPirate(address(orbital), seed);\r\n                \r\n            }\r\n            pirateNFT.updateOriginAccess(pirateId);\r\n            if (stake) {\r\n                orbital.addPiratesToCrew(msg.sender, pirateId);\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n    /**\r\n     * @param tokenId the ID to check the cost of to mint\r\n     * @return the cost of the given token ID\r\n     */\r\n    function rawMintCost(uint256 tokenId, uint256 maxTokens)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (tokenId <= (maxTokens * 8) / 24) return 4000; //10k-20k\r\n        if (tokenId <= (maxTokens * 12) / 24) return 16000; //20k-30k\r\n        if (tokenId <= (maxTokens * 16) / 24) return 48000; //30k-40k\r\n        if (tokenId <= (maxTokens * 20) / 24) return 122500; //40k-50k\r\n        if (tokenId <= (maxTokens * 22) / 24) return 250000; //50k-55k\r\n        return maxRawEonCost;\r\n    }\r\n\r\n    function getRatioChance(uint256 pirates, uint256 circulation)\r\n        public\r\n        pure\r\n        returns (uint8)\r\n    {\r\n        uint256 ratio = (pirates * 10000) / circulation;\r\n\r\n        if (ratio <= 100) {\r\n            return 0;\r\n        } else if (ratio <= 300 && ratio >= 100) {\r\n            return 1;\r\n        } else if (ratio <= 500 && ratio >= 300) {\r\n            return 2;\r\n        } else if (ratio <= 800 && ratio >= 500) {\r\n            return 3;\r\n        } else if (ratio <= 999 && ratio >= 800) {\r\n            return 4;\r\n        } else {\r\n            return 5;\r\n        }\r\n    }\r\n\r\n    /**\r\n  Determines if an attempt to join the pirates is successful or not \r\n  granting a higher chance of success when the pirate to colonist ratio is\r\n  low, as the ratio gets closer to 10% the harder a chance at joining the pirates\r\n  becomes until ultimately they will not accept anyone else if the ratio is += 10%\r\n */\r\n\r\n    function getPirateResults(uint256 seed, uint8 chanceTable)\r\n        internal\r\n        view\r\n        returns (uint8)\r\n    {\r\n        seed >>= 16;\r\n        uint8 yayNay = getResult(uint16(seed & 0xFFFF), chanceTable);\r\n        return yayNay;\r\n    }\r\n\r\n    function getResult(uint256 seed, uint8 chanceTable)\r\n        internal\r\n        view\r\n        returns (uint8)\r\n    {\r\n        uint8 result = uint8(seed) % uint8(rarities[chanceTable].length);\r\n        // If the selected chance talbles rareity is selected (biased coin) return that\r\n        if (seed >> 8 < rarities[chanceTable][result]) return result;\r\n        // else return the aliases\r\n        return aliases[chanceTable][result];\r\n    }\r\n\r\n    /** INTERNAL */\r\n\r\n    /**\r\n     * the first 10k colonist mints go to the minter\r\n     * the remaining 80% have a 10% chance to be given to a random staked pirate\r\n     * @param seed a random value to select a recipient from\r\n     * @return the address of the recipient (either the minter or the pirate thief's owner)\r\n     */\r\n    function selectRecipient(uint256 seed) internal view returns (address) {\r\n        if (((seed >> 245) % 10) != 0) return msg.sender; // top 10 bits\r\n        address thief = orbital.randomPirateOwner(seed >> 144); // 144 bits reserved for trait selection\r\n        if (thief == address(0x0)) return msg.sender;\r\n        return thief;\r\n    }\r\n\r\n    /**\r\n     * enables owner to pause / unpause contract\r\n     */\r\n    function setPaused(bool _paused) external requireContractsSet onlyOwner {\r\n        if (_paused) _pause();\r\n        else _unpause();\r\n    }\r\n\r\n\r\n    function setOnosiaLiquorId(uint256 typeId) external onlyOwner {\r\n        OnosiaLiquorId = typeId;\r\n    }\r\n\r\n    /**\r\n     * enables an address to mint / burn\r\n     * @param addr the address to enable\r\n     */\r\n    function addAdmin(address addr) external onlyOwner {\r\n        admins[addr] = true;\r\n    }\r\n\r\n    /**\r\n     * disables an address from minting / burning\r\n     * @param addr the address to disable\r\n     */\r\n    function removeAdmin(address addr) external onlyOwner {\r\n        admins[addr] = false;\r\n    }\r\n\r\n    function random(uint256 seed) internal view returns (uint256) {\r\n        return\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        tx.origin,\r\n                        blockhash(block.number - 1),\r\n                        block.timestamp,\r\n                        seed\r\n                    )\r\n                )\r\n            );\r\n    }\r\n}\r\n"
50     },
51     "contracts/interfaces/IColonist.sol": {
52       "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface IColonist {\r\n    // struct to store each Colonist's traits\r\n    struct Colonist {\r\n        bool isColonist;\r\n        uint8 background;\r\n        uint8 body;\r\n        uint8 shirt;\r\n        uint8 jacket;\r\n        uint8 jaw;\r\n        uint8 eyes;\r\n        uint8 hair;\r\n        uint8 held;\r\n        uint8 gen;\r\n    }\r\n\r\n    struct HColonist {\r\n        uint8 Legendary;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function isOwner(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function minted() external returns (uint16);\r\n\r\n    function totalCir() external returns (uint256);\r\n\r\n    function _mintColonist(address recipient, uint256 seed) external;\r\n\r\n    function _mintToHonors(address recipient, uint256 seed) external;\r\n\r\n    function _mintHonors(address recipient, uint8 id) external;\r\n\r\n    function burn(uint256 tokenId) external;\r\n\r\n    function getMaxTokens() external view returns (uint256);\r\n\r\n    function getPaidTokens() external view returns (uint256);\r\n\r\n    function getTokenTraitsColonist(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (Colonist memory);\r\n\r\n    function getTokenTraitsHonors(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (HColonist memory);\r\n\r\n    function tokenNameByIndex(uint256 index)\r\n        external\r\n        view\r\n        returns (string memory);\r\n\r\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\r\n\r\n    function nameColonist(uint256 tokenId, string memory newName) external;\r\n}\r\n"
53     },
54     "contracts/interfaces/IImperialGuild.sol": {
55       "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface IImperialGuild {\r\n\r\n    function getBalance(\r\n        address account,\r\n        uint256 id\r\n    ) external returns(uint256);\r\n\r\n    function mint(\r\n        uint256 typeId,\r\n        uint256 paymentId,\r\n        uint16 qty,\r\n        address recipient\r\n    ) external;\r\n\r\n    function burn(\r\n        uint256 typeId,\r\n        uint16 qty,\r\n        address burnFrom\r\n    ) external;\r\n\r\n    function handlePayment(uint256 amount) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external;\r\n}\r\n"
56     },
57     "contracts/interfaces/IOrbitalBlockade.sol": {
58       "content": "// SPDX-License-Identifier: MIT LICENSE\n\npragma solidity ^0.8.0;\n\ninterface IOrbitalBlockade {\n    function addPiratesToCrew(address account, uint16[] calldata tokenIds)\n        external;\n    \n    function claimPiratesFromCrew(address account, uint16[] calldata tokenIds, bool unstake)\n        external;\n\n    function payPirateTax(uint256 amount) external;\n\n    function randomPirateOwner(uint256 seed) external view returns (address);\n}\n"
59     },
60     "contracts/interfaces/IPirateGames.sol": {
61       "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPirateGames {}\r\n"
62     },
63     "contracts/interfaces/IPirates.sol": {
64       "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPirates {\r\n    // struct to store each Colonist's traits\r\n    struct Pirate {\r\n        bool isPirate;\r\n        uint8 sky;\r\n        uint8 cockpit;\r\n        uint8 base;\r\n        uint8 engine;\r\n        uint8 nose;\r\n        uint8 wing;\r\n        uint8 weapon1;\r\n        uint8 weapon2;\r\n        uint8 rank;\r\n    }\r\n\r\n    struct HPirates {\r\n        uint8 Legendary;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) external;\r\n\r\n    function minted() external returns (uint16);\r\n\r\n    function piratesMinted() external returns (uint16);\r\n\r\n    function isOwner(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function _mintPirate(address recipient, uint256 seed) external;\r\n\r\n    function burn(uint256 tokenId) external;\r\n\r\n    function getTokenTraitsPirate(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (Pirate memory);\r\n\r\n    function getTokenTraitsHonors(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (HPirates memory);\r\n\r\n    function tokenNameByIndex(uint256 index)\r\n        external\r\n        view\r\n        returns (string memory);\r\n    \r\n    function isHonors(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function updateOriginAccess(uint16[] memory tokenIds) external;\r\n\r\n    function getTokenWriteBlock(uint256 tokenId) \r\n    external \r\n    view  \r\n    returns(uint64);\r\n\r\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\r\n\r\n    function namePirate(uint256 tokenId, string memory newName) external;\r\n}\r\n"
65     },
66     "contracts/interfaces/IPytheas.sol": {
67       "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPytheas {\r\n    function addColonistToPytheas(address account, uint16[] calldata tokenIds)\r\n        external;\r\n\r\n    function claimColonistFromPytheas(address account, uint16[] calldata tokenIds, bool unstake)\r\n        external;\r\n\r\n    function getColonistMined(address account, uint16 tokenId)\r\n        external\r\n        returns (uint256);\r\n\r\n    function handleJoinPirates(address addr, uint16 tokenId) external;\r\n\r\n    function payUp(\r\n        uint16 tokenId,\r\n        uint256 amtMined,\r\n        address addr\r\n    ) external;\r\n}\r\n"
68     },
69     "contracts/interfaces/IRAW.sol": {
70       "content": "// SPDX-License-Identifier: MIT LICENSE\npragma solidity ^0.8.0;\n\ninterface IRAW {\n\n    function updateOriginAccess(address user) external;\n\n\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external returns(uint256);\n\n    function mint(\n        uint256 typeId,\n        uint256 qty,\n        address recipient\n    ) external;\n\n    function burn(\n        uint256 typeId,\n        uint256 qty,\n        address burnFrom\n    ) external;\n\n    function updateMintBurns(\n        uint256 typeId,\n        uint256 mintQty,\n        uint256 burnQty\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external;\n\n}\n"
71     },
72     "contracts/interfaces/IRandomizer.sol": {
73       "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRandomizer {\r\n    function random(uint256) external returns (uint256);\r\n}\r\n"
74     },
75     "contracts/interfaces/ITPirates.sol": {
76       "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface ITPirates {\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n"
77     }
78   }
79 }}