1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "london",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "enabled": true,
12       "runs": 100
13     },
14     "remappings": [],
15     "outputSelection": {
16       "*": {
17         "*": [
18           "evm.bytecode",
19           "evm.deployedBytecode",
20           "devdoc",
21           "userdoc",
22           "metadata",
23           "abi"
24         ]
25       }
26     }
27   },
28   "sources": {
29     "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
30       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
31     },
32     "@openzeppelin/contracts-upgradeable/interfaces/IERC165Upgradeable.sol": {
33       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165Upgradeable.sol\";\n"
34     },
35     "@openzeppelin/contracts-upgradeable/interfaces/IERC2981Upgradeable.sol": {
36       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard\n */\ninterface IERC2981Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Called with the sale price to determine how much royalty is owed and to whom.\n     * @param tokenId - the NFT asset queried for royalty information\n     * @param salePrice - the sale price of the NFT asset specified by `tokenId`\n     * @return receiver - address of who should be sent the royalty payment\n     * @return royaltyAmount - the royalty payment amount for `salePrice`\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
37     },
38     "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
39       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
40     },
41     "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
42       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n    uint256[44] private __gap;\n}\n"
43     },
44     "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
45       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
46     },
47     "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
48       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
49     },
50     "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
51       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
52     },
53     "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
54       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
55     },
56     "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
57       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
58     },
59     "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
60       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
61     },
62     "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
63       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
64     },
65     "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
66       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
67     },
68     "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
69       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
70     },
71     "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
72       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
73     },
74     "base64-sol/base64.sol": {
75       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
76     },
77     "contracts/Gm.sol": {
78       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\nimport {IBaseERC721Interface, ConfigSettings} from \"gwei-slim-nft-contracts/contracts/base/ERC721Base.sol\";\nimport {ERC721Delegated} from \"gwei-slim-nft-contracts/contracts/base/ERC721Delegated.sol\";\nimport {StringsUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport {CountersUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {GmRenderer} from \"./GmRenderer.sol\";\nimport {Base64} from \"base64-sol/base64.sol\";\n\n/**\n                                                    \n        GGGGGGGGGGGGGMMMMMMMM               MMMMMMMM\n     GGG::::::::::::GM:::::::M             M:::::::M\n   GG:::::::::::::::GM::::::::M           M::::::::M\n  G:::::GGGGGGGG::::GM:::::::::M         M:::::::::M\n G:::::G       GGGGGGM::::::::::M       M::::::::::M\nG:::::G              M:::::::::::M     M:::::::::::M\nG:::::G              M:::::::M::::M   M::::M:::::::M\nG:::::G    GGGGGGGGGGM::::::M M::::M M::::M M::::::M\nG:::::G    G::::::::GM::::::M  M::::M::::M  M::::::M\nG:::::G    GGGGG::::GM::::::M   M:::::::M   M::::::M\nG:::::G        G::::GM::::::M    M:::::M    M::::::M\n G:::::G       G::::GM::::::M     MMMMM     M::::::M\n  G:::::GGGGGGGG::::GM::::::M               M::::::M\n   GG:::::::::::::::GM::::::M               M::::::M\n     GGG::::::GGG:::GM::::::M               M::::::M\n        GGGGGG   GGGGMMMMMMMM               MMMMMMMM\n                                                    \n */\n\n/// @author twitter.com/brxckinridge\n/// @author twitter.com/isiain\n/// @notice gm\ncontract Gm is ERC721Delegated {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    CountersUpgradeable.Counter private currentTokenId;\n    uint256 public immutable maxSupply;\n    uint256 public salePrice;\n    GmRenderer public renderer;\n    mapping(uint256 => bytes32) private mintSeeds;\n    mapping(uint256 => bool) private hasHadCoffee;\n    event DrankCoffee(uint256 indexed tokenId, address indexed actor);\n\n    constructor(\n        address baseFactory,\n        address _rendererAddress,\n        uint256 _maxSupply\n    )\n        ERC721Delegated(\n            baseFactory,\n            \"gm\",\n            \"gm\",\n            ConfigSettings({\n                royaltyBps: 1000,\n                uriBase: \"\",\n                uriExtension: \"\",\n                hasTransferHook: false\n            })\n        )\n    {\n        renderer = GmRenderer(_rendererAddress);\n        maxSupply = _maxSupply;\n    }\n\n    /// @notice drinks coffee and updates the seed, only able to be called once\n    /// @param tokenId The token ID for the token\n    function drinkCoffee(uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"Needs to own\");\n        require(!hasHadCoffee[tokenId], \"Already had coffee\");\n        hasHadCoffee[tokenId] = true;\n        mintSeeds[tokenId] = _generateSeed(tokenId);\n        emit DrankCoffee(tokenId, msg.sender);\n    }\n\n    /// @notice sets the sale price for Gm\n    /// @param newPrice, the new price to mint new gms\n    function setSalePrice(uint256 newPrice) public onlyOwner {\n        salePrice = newPrice;\n    }\n\n    /// @notice returns number of mints left before sell out\n    function mintsLeft() external view returns (uint256) {\n        return maxSupply - currentTokenId.current();\n    }\n\n    /// @notice mints (count) new gms\n    /// @param count, the number of gms to mint\n    function mint(uint256 count) public payable {\n        require(currentTokenId.current() + count <= maxSupply, \"Gm: mint would exceed max supply\");\n        require(salePrice != 0, \"Gm: sale not started\");\n        require(count <= 10, \"Gm: cannot mint more than 10 in one transaction\");\n        require(msg.value == salePrice * count, \"Gm: wrong sale price\");\n\n        for (uint256 i = 0; i < count; i++) {\n            mintSeeds[currentTokenId.current()] = _generateSeed(\n                currentTokenId.current()\n            );\n            _mint(msg.sender, currentTokenId.current());\n            currentTokenId.increment();\n        }\n    }\n\n    /// @notice burns the gm\n    /// @param tokenId, the token id of be burned\n    function burn(uint256 tokenId) public {\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId),\n            \"Gm: only approved or owner can burn\"\n        );\n        _burn(tokenId);\n    }\n\n    /// @notice withdraws the eth funds from the contract to the owner\n    function withdraw() external onlyOwner {\n        // No need for gas limit to trusted address.\n        AddressUpgradeable.sendValue(payable(_owner()), address(this).balance);\n    }\n\n    /// @notice returns the base64 encoded svg\n    /// @param data, bytes representing the svg\n    function svgBase64Data(bytes memory data)\n        internal\n        pure\n        returns (string memory)\n    {\n        return\n            string(\n                abi.encodePacked(\n                    \"data:image/svg+xml;base64,\",\n                    Base64.encode(data)\n                )\n            );\n    }\n\n    /// @notice returns the base64 data uri metadata json\n    /// @param tokenId, the token id of the gm\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        string memory json;\n        (bytes memory tokenData, bytes memory name, bytes memory bgColor, bytes memory fontColor, bytes memory filter) = renderer.svgRaw(\n            mintSeeds[tokenId]\n        );\n\n        bytes memory caff;\n        if (hasHadCoffee[tokenId]) {\n            caff = \"Yes\";\n        } else {\n            caff = \"No\";\n        }\n\n        bytes memory attributes = abi.encodePacked('\"attributes\": [',\n            '{\"trait_type\":\"style\",\"value\":\"',\n            name,\n            '\"},{\"trait_type\":\"background color\",\"value\":\"',\n            bgColor,\n            '\"},{\"trait_type\":\"font color\",\"value\":\"',\n            fontColor,\n            '\"},{\"trait_type\":\"caffeinated\",\"value\":\"',\n            caff,\n            '\"},{\"trait_type\":\"effect\",\"value\":\"',\n            filter,\n            '\"}]');\n\n        json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"description\": \"gm-onchain is a collection of 6969 randomly generated, onchain renderings of our favorite crypto phrase. enjoy.\",',\n                        '\"title\": \"gm ',\n                        StringsUpgradeable.toString(tokenId),\n                        '\", \"image\": \"',\n                        svgBase64Data(tokenData),\n                        '\",',\n                        attributes,\n                        '}'\n                    )\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice returns the seed for the tokenId\n    /// @param tokenId, the token id of the gm\n    function seed(uint256 tokenId) external view returns (bytes32) {\n        return mintSeeds[tokenId];\n    }\n\n    /// @notice generates a pseudo random seed\n    /// @param tokenId, the token id of the gm\n    function _generateSeed(uint256 tokenId) private view returns (bytes32) {\n        return\n            keccak256(abi.encodePacked(\n                            msg.sender,\n                            tx.gasprice,\n                            tokenId,\n                            block.number,\n                            block.timestamp,\n                            blockhash(block.number - 1)\n                    )\n            );\n    }\n}\n"
79     },
80     "contracts/GmDataInterface.sol": {
81       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface GmDataInterface {\n    struct GmDataSet {\n        bytes imageName;\n        bytes compressedImage;\n        uint256 compressedSize;\n    }\n\n    function getSvg(uint256 index) external pure returns (GmDataSet memory);\n}\n"
82     },
83     "contracts/GmRenderer.sol": {
84       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {InflateLib} from \"./InflateLib.sol\";\nimport {GmDataInterface} from \"./GmDataInterface.sol\";\nimport {StringsUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\n\ninterface ICourierFont {\n    function font() external view returns (string memory);\n}\n\ncontract GmRenderer {\n    ICourierFont private immutable font;\n    GmDataInterface private immutable gmData1;\n    GmDataInterface private immutable gmData2;\n\n    struct Color {\n        bytes hexNum;\n        bytes name;\n    }\n\n    constructor(\n        ICourierFont fontAddress,\n        GmDataInterface gmData1Address,\n        GmDataInterface gmData2Address\n    ) {\n        font = fontAddress;\n        gmData1 = gmData1Address;\n        gmData2 = gmData2Address;\n    }\n\n    /// @notice decompresses the GmDataSet\n    /// @param gmData, compressed ascii svg data\n    function decompress(GmDataInterface.GmDataSet memory gmData)\n        public\n        pure\n        returns (bytes memory, bytes memory)\n    {\n        (, bytes memory inflated) = InflateLib.puff(\n            gmData.compressedImage,\n            gmData.compressedSize\n        );\n        return (gmData.imageName, inflated);\n    }\n\n    /// @notice returns an svg filter\n    /// @param index, a random number derived from the seed\n    function _getFilter(uint256 index) internal pure returns (bytes memory) {\n\n        // 1 || 2 || 3 || 4 || 5 -> noise 5%\n        if (\n            (index == 1) ||\n            (index == 2) ||\n            (index == 3) ||\n            (index == 4) ||\n            (index == 5)\n        ) {\n            return \"noise\";\n        }\n\n        // 7 || 8 || 98 -> scribble 3%\n        if ((index == 7) || (index == 8) || (index == 9)) {\n            return \"scribble\";\n        }\n\n        // 10 - 29 -> morph 20%\n        if (((100 - index) > 70) && ((100 - index) <= 90)) {\n            return \"morph\";\n        }\n\n        // 30 - 39 -> glow 10%\n        if (((100 - index) > 60) && ((100 - index) <= 70)) {\n            return \"glow\";\n        }\n\n        // 69 -> fractal 1%\n        if (index == 69) {\n            return \"fractal\";\n        }\n\n        return \"none\";\n    }\n\n    /// @notice returns a background color and font color\n    /// @param seed, pseudo random seed\n    function _getColors(bytes32 seed)\n        internal\n        pure\n        returns (Color memory bgColor, Color memory fontColor)\n    {\n        uint32 bgRand = uint32(bytes4(seed)) % 111;\n        uint32 fontJitter = uint32(bytes4(seed << 32)) % 5;\n        uint32 fontOperation = uint8(bytes1(seed << 64)) % 2;\n        uint32 fontRand;\n        if (fontOperation == 0) {\n            fontRand = (bgRand + (55 + fontJitter)) % 111;\n        } else {\n            fontRand = (bgRand + (55 - fontJitter)) % 111;\n        }\n\n        return (_getColor(bgRand), _getColor(fontRand));\n    }\n\n    /// @notice executes string comparison against two strings\n    /// @param a, first string\n    /// @param b, second string\n    function strCompare(string memory a, string memory b) internal pure returns (bool) {\n        if(bytes(a).length != bytes(b).length) {\n            return false;\n        } else {\n            return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n        }\n    }\n\n    /// @notice returns the raw svg yielded by seed\n    /// @param seed, pseudo random seed\n    function svgRaw(bytes32 seed)\n        external\n        view\n        returns (\n            bytes memory,\n            bytes memory,\n            bytes memory,\n            bytes memory,\n            bytes memory\n        )\n    {\n        uint32 style = uint32(bytes4(seed << 65)) % 69;\n        uint32 filterRand = uint32(bytes4(seed << 97)) % 100;\n        bytes memory filter = _getFilter(filterRand);\n\n        (Color memory bgColor, Color memory fontColor) = _getColors(seed);\n\n        bytes memory inner;\n        bytes memory name;\n        if (style < 50) {\n            (name, inner) = decompress(gmData1.getSvg(style));\n        } else {\n            (name, inner) = decompress(gmData2.getSvg(style));\n        }\n\n        if ((strCompare(string(name), \"Hex\")) || (strCompare(string(name), \"Binary\")) || (strCompare(string(name), \"Morse\")) || (strCompare(string(name), \"Mnemonic\"))){\n            filter = \"none\";\n        }\n\n        return (\n            abi.encodePacked(\n                svgPreambleString(bgColor.hexNum, fontColor.hexNum, filter),\n                inner,\n                \"</svg>\"\n            ),\n            name,\n            bgColor.name,\n            fontColor.name,\n            filter\n        );\n    }\n\n    /// @notice returns the svg filters\n    function svgFilterDefs() private view returns (bytes memory) {\n        return\n            abi.encodePacked(\n                '<defs><filter id=\"fractal\" filterUnits=\"objectBoundingBox\" x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\" ><feTurbulence id=\"turbulence\" type=\"fractalNoise\" baseFrequency=\"0.03\" numOctaves=\"1\" ><animate attributeName=\"baseFrequency\" values=\"0.01;0.4;0.01\" dur=\"100s\" repeatCount=\"indefinite\" /></feTurbulence><feDisplacementMap in=\"SourceGraphic\" scale=\"50\"></feDisplacementMap></filter><filter id=\"morph\"><feMorphology operator=\"dilate\" radius=\"0\"><animate attributeName=\"radius\" values=\"0;5;0\" dur=\"8s\" repeatCount=\"indefinite\" /></feMorphology></filter><filter id=\"glow\" filterUnits=\"objectBoundingBox\" x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\" ><feGaussianBlur stdDeviation=\"5\" result=\"blur2\" in=\"SourceGraphic\" /><feMerge><feMergeNode in=\"blur2\" /><feMergeNode in=\"SourceGraphic\" /></feMerge></filter><filter id=\"noise\"><feTurbulence baseFrequency=\"0.05\"/><feColorMatrix type=\"hueRotate\" values=\"0\"><animate attributeName=\"values\" from=\"0\" to=\"360\" dur=\"1s\" repeatCount=\"indefinite\"/></feColorMatrix><feColorMatrix type=\"matrix\" values=\"0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0\"/><feDisplacementMap in=\"SourceGraphic\" scale=\"10\"/></filter><filter id=\"none\"><feOffset></feOffset></filter><filter id=\"scribble\"><feTurbulence type=\"turbulence\" baseFrequency=\"0.05\" numOctaves=\"2\" result=\"turbulence\"/><feDisplacementMap in2=\"turbulence\" in=\"SourceGraphic\" scale=\"50\" xChannelSelector=\"R\" yChannelSelector=\"G\"/></filter><filter id=\"tile\" x=\"10\" y=\"10\" width=\"10%\" height=\"10%\"><feTile in=\"SourceGraphic\" x=\"10\" y=\"10\" width=\"10\" height=\"10\" /><feTile/></filter></defs>'\n            );\n    }\n\n    /// @notice returns the svg preamble\n    /// @param bgColor, color of the background as hex string\n    /// @param fontColor, color of the font as hex string\n    /// @param filter, filter for the svg\n    function svgPreambleString(\n        bytes memory bgColor,\n        bytes memory fontColor,\n        bytes memory filter\n    ) private view returns (bytes memory) {\n        return\n            abi.encodePacked(\n                \"<svg viewBox='0 0 640 640' width='100%' height='100%' xmlns='http://www.w3.org/2000/svg'><style> @font-face { font-family: CourierFont; src: url('\",\n                font.font(),\n                \"') format('opentype'); }\",\n                \".base{filter:url(#\",\n                filter,\n                \");fill:\",\n                fontColor,\n                \";font-family:CourierFont;font-size: 16px;}</style>\",\n                svgFilterDefs(),\n                '<rect width=\"100%\" height=\"100%\" fill=\"',\n                bgColor,\n                '\" /> '\n            );\n    }\n\n    /// @notice returns the Color yielded by index\n    /// @param index, random number determined by seed\n    function _getColor(uint32 index)\n        internal\n        pure\n        returns (Color memory color)\n    {\n        // AUTOGEN:START\n\n        if (index == 0) {\n            color.hexNum = \"#000000\";\n            color.name = \"Black\";\n        }\n\n        if (index == 1) {\n            color.hexNum = \"#004c6a\";\n            color.name = \"Navy Dark Blue\";\n        }\n\n        if (index == 2) {\n            color.hexNum = \"#0098d4\";\n            color.name = \"Bayern Blue\";\n        }\n\n        if (index == 3) {\n            color.hexNum = \"#00e436\";\n            color.name = \"Lexaloffle Green\";\n        }\n\n        if (index == 4) {\n            color.hexNum = \"#1034a6\";\n            color.name = \"Egyptian Blue\";\n        }\n\n        if (index == 5) {\n            color.hexNum = \"#008811\";\n            color.name = \"Lush Garden\";\n        }\n\n        if (index == 6) {\n            color.hexNum = \"#06d078\";\n            color.name = \"Underwater Fern\";\n        }\n\n        if (index == 7) {\n            color.hexNum = \"#1c1cf0\";\n            color.name = \"Bluebonnet\";\n        }\n\n        if (index == 8) {\n            color.hexNum = \"#127453\";\n            color.name = \"Green Velvet\";\n        }\n\n        if (index == 9) {\n            color.hexNum = \"#14bab4\";\n            color.name = \"Super Rare Jade\";\n        }\n\n        if (index == 10) {\n            color.hexNum = \"#111122\";\n            color.name = \"Corbeau\";\n        }\n\n        if (index == 11) {\n            color.hexNum = \"#165d95\";\n            color.name = \"Lapis Jewel\";\n        }\n\n        if (index == 12) {\n            color.hexNum = \"#16b8f3\";\n            color.name = \"Zima Blue\";\n        }\n\n        if (index == 13) {\n            color.hexNum = \"#1ef876\";\n            color.name = \"Synthetic Spearmint\";\n        }\n\n        if (index == 14) {\n            color.hexNum = \"#214fc6\";\n            color.name = \"New Car\";\n        }\n\n        if (index == 15) {\n            color.hexNum = \"#249148\";\n            color.name = \"Paperboy's Lawn\";\n        }\n\n        if (index == 16) {\n            color.hexNum = \"#24da91\";\n            color.name = \"Reptile Green\";\n        }\n\n        if (index == 17) {\n            color.hexNum = \"#223311\";\n            color.name = \"Darkest Forest\";\n        }\n\n        if (index == 18) {\n            color.hexNum = \"#297f6d\";\n            color.name = \"Mermaid Sea\";\n        }\n\n        if (index == 19) {\n            color.hexNum = \"#22cccc\";\n            color.name = \"Mermaid Net\";\n        }\n\n        if (index == 20) {\n            color.hexNum = \"#2e2249\";\n            color.name = \"Elderberry\";\n        }\n\n        if (index == 21) {\n            color.hexNum = \"#326ab1\";\n            color.name = \"Dover Straits\";\n        }\n\n        if (index == 22) {\n            color.hexNum = \"#2bc51b\";\n            color.name = \"Felwood Leaves\";\n        }\n\n        if (index == 23) {\n            color.hexNum = \"#391285\";\n            color.name = \"Pixie Powder\";\n        }\n\n        if (index == 24) {\n            color.hexNum = \"#2e58e8\";\n            color.name = \"Veteran's Day Blue\";\n        }\n\n        if (index == 25) {\n            color.hexNum = \"#419f59\";\n            color.name = \"Chateau Green\";\n        }\n\n        if (index == 26) {\n            color.hexNum = \"#45e9c1\";\n            color.name = \"Aphrodite Aqua\";\n        }\n\n        if (index == 27) {\n            color.hexNum = \"#424330\";\n            color.name = \"Garden Path\";\n        }\n\n        if (index == 28) {\n            color.hexNum = \"#429395\";\n            color.name = \"Catalan\";\n        }\n\n        if (index == 29) {\n            color.hexNum = \"#44dd00\";\n            color.name = \"Magic Blade\";\n        }\n\n        if (index == 30) {\n            color.hexNum = \"#432e6f\";\n            color.name = \"Her Highness\";\n        }\n\n        if (index == 31) {\n            color.hexNum = \"#4477dd\";\n            color.name = \"Andrea Blue\";\n        }\n\n        if (index == 32) {\n            color.hexNum = \"#5ad33e\";\n            color.name = \"Verdant Fields\";\n        }\n\n        if (index == 33) {\n            color.hexNum = \"#3a18b1\";\n            color.name = \"Indigo Blue\";\n        }\n\n        if (index == 34) {\n            color.hexNum = \"#556611\";\n            color.name = \"Forestial Outpost\";\n        }\n\n        if (index == 35) {\n            color.hexNum = \"#55bb88\";\n            color.name = \"Bleached Olive\";\n        }\n\n        if (index == 36) {\n            color.hexNum = \"#5500ee\";\n            color.name = \"Tezcatlipoca Blue\";\n        }\n\n        if (index == 37) {\n            color.hexNum = \"#545554\";\n            color.name = \"Carbon Copy\";\n        }\n\n        if (index == 38) {\n            color.hexNum = \"#58a0bc\";\n            color.name = \"Dupain\";\n        }\n\n        if (index == 39) {\n            color.hexNum = \"#55ff22\";\n            color.name = \"Traffic Green\";\n        }\n\n        if (index == 40) {\n            color.hexNum = \"#5b3e90\";\n            color.name = \"Daisy Bush\";\n        }\n\n        if (index == 41) {\n            color.hexNum = \"#6688ff\";\n            color.name = \"Deep Denim\";\n        }\n\n        if (index == 42) {\n            color.hexNum = \"#61e160\";\n            color.name = \"Lightish Green\";\n        }\n\n        if (index == 43) {\n            color.hexNum = \"#6a31ca\";\n            color.name = \"Sagat Purple\";\n        }\n\n        if (index == 44) {\n            color.hexNum = \"#667c3e\";\n            color.name = \"Military Green\";\n        }\n\n        if (index == 45) {\n            color.hexNum = \"#68c89d\";\n            color.name = \"Intense Jade\";\n        }\n\n        if (index == 46) {\n            color.hexNum = \"#6d1008\";\n            color.name = \"Chestnut Brown\";\n        }\n\n        if (index == 47) {\n            color.hexNum = \"#696374\";\n            color.name = \"Purple Punch\";\n        }\n\n        if (index == 48) {\n            color.hexNum = \"#6fb7e0\";\n            color.name = \"Life Force\";\n        }\n\n        if (index == 49) {\n            color.hexNum = \"#770044\";\n            color.name = \"Dawn of the Fairies\";\n        }\n\n        if (index == 50) {\n            color.hexNum = \"#7851a9\";\n            color.name = \"Royal Lavender\";\n        }\n\n        if (index == 51) {\n            color.hexNum = \"#769c18\";\n            color.name = \"Luminescent Green\";\n        }\n\n        if (index == 52) {\n            color.hexNum = \"#7be892\";\n            color.name = \"Ragweed\";\n        }\n\n        if (index == 53) {\n            color.hexNum = \"#703be7\";\n            color.name = \"Bluish Purple\";\n        }\n\n        if (index == 54) {\n            color.hexNum = \"#7b8b5d\";\n            color.name = \"Sage Leaves\";\n        }\n\n        if (index == 55) {\n            color.hexNum = \"#82d9c5\";\n            color.name = \"Tender Turquoise\";\n        }\n\n        if (index == 56) {\n            color.hexNum = \"#7e2530\";\n            color.name = \"Scarlet Shade\";\n        }\n\n        if (index == 57) {\n            color.hexNum = \"#83769c\";\n            color.name = \"Voxatron Purple\";\n        }\n\n        if (index == 58) {\n            color.hexNum = \"#88cc00\";\n            color.name = \"Fabulous Frog\";\n        }\n\n        if (index == 59) {\n            color.hexNum = \"#881166\";\n            color.name = \"Possessed Purple\";\n        }\n\n        if (index == 60) {\n            color.hexNum = \"#8756e4\";\n            color.name = \"Gloomy Purple\";\n        }\n\n        if (index == 61) {\n            color.hexNum = \"#93b13d\";\n            color.name = \"Green Tea Ice Cream\";\n        }\n\n        if (index == 62) {\n            color.hexNum = \"#90fda9\";\n            color.name = \"Foam Green\";\n        }\n\n        if (index == 63) {\n            color.hexNum = \"#914b13\";\n            color.name = \"Parasite Brown\";\n        }\n\n        if (index == 64) {\n            color.hexNum = \"#919c81\";\n            color.name = \"Whispering Willow\";\n        }\n\n        if (index == 65) {\n            color.hexNum = \"#99eeee\";\n            color.name = \"Freezy Breezy\";\n        }\n\n        if (index == 66) {\n            color.hexNum = \"#983d53\";\n            color.name = \"Algae Red\";\n        }\n\n        if (index == 67) {\n            color.hexNum = \"#9c87c1\";\n            color.name = \"Petrified Purple\";\n        }\n\n        if (index == 68) {\n            color.hexNum = \"#98da2c\";\n            color.name = \"Effervescent Lime\";\n        }\n\n        if (index == 69) {\n            color.hexNum = \"#942193\";\n            color.name = \"Acai Juice\";\n        }\n\n        if (index == 70) {\n            color.hexNum = \"#a675fe\";\n            color.name = \"Purple Illusionist\";\n        }\n\n        if (index == 71) {\n            color.hexNum = \"#a4c161\";\n            color.name = \"Jungle Juice\";\n        }\n\n        if (index == 72) {\n            color.hexNum = \"#aa00cc\";\n            color.name = \"Ferocious Fuchsia\";\n        }\n\n        if (index == 73) {\n            color.hexNum = \"#a85e39\";\n            color.name = \"Earthen Jug\";\n        }\n\n        if (index == 74) {\n            color.hexNum = \"#aaa9a4\";\n            color.name = \"Ellie Grey\";\n        }\n\n        if (index == 75) {\n            color.hexNum = \"#aaee11\";\n            color.name = \"Glorious Green Glitter\";\n        }\n\n        if (index == 76) {\n            color.hexNum = \"#ad4379\";\n            color.name = \"Mystic Maroon\";\n        }\n\n        if (index == 77) {\n            color.hexNum = \"#b195e4\";\n            color.name = \"Dreamy Candy Forest\";\n        }\n\n        if (index == 78) {\n            color.hexNum = \"#b1dd52\";\n            color.name = \"Conifer\";\n        }\n\n        if (index == 79) {\n            color.hexNum = \"#c034af\";\n            color.name = \"Pink Perennial\";\n        }\n\n        if (index == 80) {\n            color.hexNum = \"#b78727\";\n            color.name = \"University of California Gold\";\n        }\n\n        if (index == 81) {\n            color.hexNum = \"#b9d08b\";\n            color.name = \"Young Leaves\";\n        }\n\n        if (index == 82) {\n            color.hexNum = \"#bb11ee\";\n            color.name = \"Promiscuous Pink\";\n        }\n\n        if (index == 83) {\n            color.hexNum = \"#c06960\";\n            color.name = \"Tapestry Red\";\n        }\n\n        if (index == 84) {\n            color.hexNum = \"#bebbc9\";\n            color.name = \"Silverberry\";\n        }\n\n        if (index == 85) {\n            color.hexNum = \"#bf0a30\";\n            color.name = \"Old Glory Red\";\n        }\n\n        if (index == 86) {\n            color.hexNum = \"#c35b99\";\n            color.name = \"Llilacquered\";\n        }\n\n        if (index == 87) {\n            color.hexNum = \"#caa906\";\n            color.name = \"Christmas Gold\";\n        }\n\n        if (index == 88) {\n            color.hexNum = \"#c2f177\";\n            color.name = \"Cucumber Milk\";\n        }\n\n        if (index == 89) {\n            color.hexNum = \"#d648d7\";\n            color.name = \"Pinkish Purple\";\n        }\n\n        if (index == 90) {\n            color.hexNum = \"#cf9346\";\n            color.name = \"Fleshtone Shade Wash\";\n        }\n\n        if (index == 91) {\n            color.hexNum = \"#d3e0b1\";\n            color.name = \"Rockmelon Rind\";\n        }\n\n        if (index == 92) {\n            color.hexNum = \"#d22d1d\";\n            color.name = \"Pure Red\";\n        }\n\n        if (index == 93) {\n            color.hexNum = \"#d28083\";\n            color.name = \"Galah\";\n        }\n\n        if (index == 94) {\n            color.hexNum = \"#d5c7e8\";\n            color.name = \"Foggy Love\";\n        }\n\n        if (index == 95) {\n            color.hexNum = \"#db1459\";\n            color.name = \"Rubylicious\";\n        }\n\n        if (index == 96) {\n            color.hexNum = \"#dd66bb\";\n            color.name = \"Pink Charge\";\n        }\n\n        if (index == 97) {\n            color.hexNum = \"#e2b227\";\n            color.name = \"Gold Tips\";\n        }\n\n        if (index == 98) {\n            color.hexNum = \"#ee0099\";\n            color.name = \"Love Vessel\";\n        }\n\n        if (index == 99) {\n            color.hexNum = \"#dd55ff\";\n            color.name = \"Flaming Flamingo\";\n        }\n\n        if (index == 100) {\n            color.hexNum = \"#eda367\";\n            color.name = \"Adventure Orange\";\n        }\n\n        if (index == 101) {\n            color.hexNum = \"#e9f1d0\";\n            color.name = \"Yellowish White\";\n        }\n\n        if (index == 102) {\n            color.hexNum = \"#ef3939\";\n            color.name = \"Vivaldi Red\";\n        }\n\n        if (index == 103) {\n            color.hexNum = \"#e78ea5\";\n            color.name = \"Underwater Flare\";\n        }\n\n        if (index == 104) {\n            color.hexNum = \"#eedd11\";\n            color.name = \"Yellow Buzzing\";\n        }\n\n        if (index == 105) {\n            color.hexNum = \"#ee2277\";\n            color.name = \"Furious Fuchsia\";\n        }\n\n        if (index == 106) {\n            color.hexNum = \"#f075e6\";\n            color.name = \"Lian Hong Lotus Pink\";\n        }\n\n        if (index == 107) {\n            color.hexNum = \"#f7c34c\";\n            color.name = \"Creamy Sweet Corn\";\n        }\n\n        if (index == 108) {\n            color.hexNum = \"#fc0fc0\";\n            color.name = \"CGA Pink\";\n        }\n\n        if (index == 109) {\n            color.hexNum = \"#ff6622\";\n            color.name = \"Sparrows Fire\";\n        }\n\n        if (index == 110) {\n            color.hexNum = \"#fbaf8d\";\n            color.name = \"Orange Grove\";\n        }\n\n        // AUTOGEN:END\n    }\n}\n"
85     },
86     "contracts/InflateLib.sol": {
87       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.9.0;\n\n//\n// inflate content script:\n// var pako = require('pako')\n// var deflate = (str) => [str.length,Buffer.from(pako.deflateRaw(Buffer.from(str, 'utf-8'), {level: 9})).toString('hex')]\n//\n\n/// @notice Based on https://github.com/madler/zlib/blob/master/contrib/puff\nlibrary InflateLib {\n    // Maximum bits in a code\n    uint256 constant MAXBITS = 15;\n    // Maximum number of literal/length codes\n    uint256 constant MAXLCODES = 286;\n    // Maximum number of distance codes\n    uint256 constant MAXDCODES = 30;\n    // Maximum codes lengths to read\n    uint256 constant MAXCODES = (MAXLCODES + MAXDCODES);\n    // Number of fixed literal/length codes\n    uint256 constant FIXLCODES = 288;\n\n    // Error codes\n    enum ErrorCode {\n        ERR_NONE, // 0 successful inflate\n        ERR_NOT_TERMINATED, // 1 available inflate data did not terminate\n        ERR_OUTPUT_EXHAUSTED, // 2 output space exhausted before completing inflate\n        ERR_INVALID_BLOCK_TYPE, // 3 invalid block type (type == 3)\n        ERR_STORED_LENGTH_NO_MATCH, // 4 stored block length did not match one's complement\n        ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES, // 5 dynamic block code description: too many length or distance codes\n        ERR_CODE_LENGTHS_CODES_INCOMPLETE, // 6 dynamic block code description: code lengths codes incomplete\n        ERR_REPEAT_NO_FIRST_LENGTH, // 7 dynamic block code description: repeat lengths with no first length\n        ERR_REPEAT_MORE, // 8 dynamic block code description: repeat more than specified lengths\n        ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS, // 9 dynamic block code description: invalid literal/length code lengths\n        ERR_INVALID_DISTANCE_CODE_LENGTHS, // 10 dynamic block code description: invalid distance code lengths\n        ERR_MISSING_END_OF_BLOCK, // 11 dynamic block code description: missing end-of-block code\n        ERR_INVALID_LENGTH_OR_DISTANCE_CODE, // 12 invalid literal/length or distance code in fixed or dynamic block\n        ERR_DISTANCE_TOO_FAR, // 13 distance is too far back in fixed or dynamic block\n        ERR_CONSTRUCT // 14 internal: error in construct()\n    }\n\n    // Input and output state\n    struct State {\n        //////////////////\n        // Output state //\n        //////////////////\n        // Output buffer\n        bytes output;\n        // Bytes written to out so far\n        uint256 outcnt;\n        /////////////////\n        // Input state //\n        /////////////////\n        // Input buffer\n        bytes input;\n        // Bytes read so far\n        uint256 incnt;\n        ////////////////\n        // Temp state //\n        ////////////////\n        // Bit buffer\n        uint256 bitbuf;\n        // Number of bits in bit buffer\n        uint256 bitcnt;\n        //////////////////////////\n        // Static Huffman codes //\n        //////////////////////////\n        Huffman lencode;\n        Huffman distcode;\n    }\n\n    // Huffman code decoding tables\n    struct Huffman {\n        uint256[] counts;\n        uint256[] symbols;\n    }\n\n    function bits(State memory s, uint256 need)\n        private\n        pure\n        returns (ErrorCode, uint256)\n    {\n        // Bit accumulator (can use up to 20 bits)\n        uint256 val;\n\n        // Load at least need bits into val\n        val = s.bitbuf;\n        while (s.bitcnt < need) {\n            if (s.incnt == s.input.length) {\n                // Out of input\n                return (ErrorCode.ERR_NOT_TERMINATED, 0);\n            }\n\n            // Load eight bits\n            val |= uint256(uint8(s.input[s.incnt++])) << s.bitcnt;\n            s.bitcnt += 8;\n        }\n\n        // Drop need bits and update buffer, always zero to seven bits left\n        s.bitbuf = val >> need;\n        s.bitcnt -= need;\n\n        // Return need bits, zeroing the bits above that\n        uint256 ret = (val & ((1 << need) - 1));\n        return (ErrorCode.ERR_NONE, ret);\n    }\n\n    function _stored(State memory s) private pure returns (ErrorCode) {\n        // Length of stored block\n        uint256 len;\n\n        // Discard leftover bits from current byte (assumes s.bitcnt < 8)\n        s.bitbuf = 0;\n        s.bitcnt = 0;\n\n        // Get length and check against its one's complement\n        if (s.incnt + 4 > s.input.length) {\n            // Not enough input\n            return ErrorCode.ERR_NOT_TERMINATED;\n        }\n        len = uint256(uint8(s.input[s.incnt++]));\n        len |= uint256(uint8(s.input[s.incnt++])) << 8;\n\n        if (\n            uint8(s.input[s.incnt++]) != (~len & 0xFF) ||\n            uint8(s.input[s.incnt++]) != ((~len >> 8) & 0xFF)\n        ) {\n            // Didn't match complement!\n            return ErrorCode.ERR_STORED_LENGTH_NO_MATCH;\n        }\n\n        // Copy len bytes from in to out\n        if (s.incnt + len > s.input.length) {\n            // Not enough input\n            return ErrorCode.ERR_NOT_TERMINATED;\n        }\n        if (s.outcnt + len > s.output.length) {\n            // Not enough output space\n            return ErrorCode.ERR_OUTPUT_EXHAUSTED;\n        }\n        while (len != 0) {\n            // Note: Solidity reverts on underflow, so we decrement here\n            len -= 1;\n            s.output[s.outcnt++] = s.input[s.incnt++];\n        }\n\n        // Done with a valid stored block\n        return ErrorCode.ERR_NONE;\n    }\n\n    function _decode(State memory s, Huffman memory h)\n        private\n        pure\n        returns (ErrorCode, uint256)\n    {\n        // Current number of bits in code\n        uint256 len;\n        // Len bits being decoded\n        uint256 code = 0;\n        // First code of length len\n        uint256 first = 0;\n        // Number of codes of length len\n        uint256 count;\n        // Index of first code of length len in symbol table\n        uint256 index = 0;\n        // Error code\n        ErrorCode err;\n\n        for (len = 1; len <= MAXBITS; len++) {\n            // Get next bit\n            uint256 tempCode;\n            (err, tempCode) = bits(s, 1);\n            if (err != ErrorCode.ERR_NONE) {\n                return (err, 0);\n            }\n            code |= tempCode;\n            count = h.counts[len];\n\n            // If length len, return symbol\n            if (code < first + count) {\n                return (ErrorCode.ERR_NONE, h.symbols[index + (code - first)]);\n            }\n            // Else update for next length\n            index += count;\n            first += count;\n            first <<= 1;\n            code <<= 1;\n        }\n\n        // Ran out of codes\n        return (ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE, 0);\n    }\n\n    function _construct(\n        Huffman memory h,\n        uint256[] memory lengths,\n        uint256 n,\n        uint256 start\n    ) private pure returns (ErrorCode) {\n        // Current symbol when stepping through lengths[]\n        uint256 symbol;\n        // Current length when stepping through h.counts[]\n        uint256 len;\n        // Number of possible codes left of current length\n        uint256 left;\n        // Offsets in symbol table for each length\n        uint256[MAXBITS + 1] memory offs;\n\n        // Count number of codes of each length\n        for (len = 0; len <= MAXBITS; len++) {\n            h.counts[len] = 0;\n        }\n        for (symbol = 0; symbol < n; symbol++) {\n            // Assumes lengths are within bounds\n            h.counts[lengths[start + symbol]]++;\n        }\n        // No codes!\n        if (h.counts[0] == n) {\n            // Complete, but decode() will fail\n            return (ErrorCode.ERR_NONE);\n        }\n\n        // Check for an over-subscribed or incomplete set of lengths\n\n        // One possible code of zero length\n        left = 1;\n\n        for (len = 1; len <= MAXBITS; len++) {\n            // One more bit, double codes left\n            left <<= 1;\n            if (left < h.counts[len]) {\n                // Over-subscribed--return error\n                return ErrorCode.ERR_CONSTRUCT;\n            }\n            // Deduct count from possible codes\n\n            left -= h.counts[len];\n        }\n\n        // Generate offsets into symbol table for each length for sorting\n        offs[1] = 0;\n        for (len = 1; len < MAXBITS; len++) {\n            offs[len + 1] = offs[len] + h.counts[len];\n        }\n\n        // Put symbols in table sorted by length, by symbol order within each length\n        for (symbol = 0; symbol < n; symbol++) {\n            if (lengths[start + symbol] != 0) {\n                h.symbols[offs[lengths[start + symbol]]++] = symbol;\n            }\n        }\n\n        // Left > 0 means incomplete\n        return left > 0 ? ErrorCode.ERR_CONSTRUCT : ErrorCode.ERR_NONE;\n    }\n\n    function _codes(\n        State memory s,\n        Huffman memory lencode,\n        Huffman memory distcode\n    ) private pure returns (ErrorCode) {\n        // Decoded symbol\n        uint256 symbol;\n        // Length for copy\n        uint256 len;\n        // Distance for copy\n        uint256 dist;\n        // TODO Solidity doesn't support constant arrays, but these are fixed at compile-time\n        // Size base for length codes 257..285\n        uint16[29] memory lens =\n            [\n                3,\n                4,\n                5,\n                6,\n                7,\n                8,\n                9,\n                10,\n                11,\n                13,\n                15,\n                17,\n                19,\n                23,\n                27,\n                31,\n                35,\n                43,\n                51,\n                59,\n                67,\n                83,\n                99,\n                115,\n                131,\n                163,\n                195,\n                227,\n                258\n            ];\n        // Extra bits for length codes 257..285\n        uint8[29] memory lext =\n            [\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                1,\n                1,\n                1,\n                2,\n                2,\n                2,\n                2,\n                3,\n                3,\n                3,\n                3,\n                4,\n                4,\n                4,\n                4,\n                5,\n                5,\n                5,\n                5,\n                0\n            ];\n        // Offset base for distance codes 0..29\n        uint16[30] memory dists =\n            [\n                1,\n                2,\n                3,\n                4,\n                5,\n                7,\n                9,\n                13,\n                17,\n                25,\n                33,\n                49,\n                65,\n                97,\n                129,\n                193,\n                257,\n                385,\n                513,\n                769,\n                1025,\n                1537,\n                2049,\n                3073,\n                4097,\n                6145,\n                8193,\n                12289,\n                16385,\n                24577\n            ];\n        // Extra bits for distance codes 0..29\n        uint8[30] memory dext =\n            [\n                0,\n                0,\n                0,\n                0,\n                1,\n                1,\n                2,\n                2,\n                3,\n                3,\n                4,\n                4,\n                5,\n                5,\n                6,\n                6,\n                7,\n                7,\n                8,\n                8,\n                9,\n                9,\n                10,\n                10,\n                11,\n                11,\n                12,\n                12,\n                13,\n                13\n            ];\n        // Error code\n        ErrorCode err;\n\n        // Decode literals and length/distance pairs\n        while (symbol != 256) {\n            (err, symbol) = _decode(s, lencode);\n            if (err != ErrorCode.ERR_NONE) {\n                // Invalid symbol\n                return err;\n            }\n\n            if (symbol < 256) {\n                // Literal: symbol is the byte\n                // Write out the literal\n                if (s.outcnt == s.output.length) {\n                    return ErrorCode.ERR_OUTPUT_EXHAUSTED;\n                }\n                s.output[s.outcnt] = bytes1(uint8(symbol));\n                s.outcnt++;\n            } else if (symbol > 256) {\n                uint256 tempBits;\n                // Length\n                // Get and compute length\n                symbol -= 257;\n                if (symbol >= 29) {\n                    // Invalid fixed code\n                    return ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE;\n                }\n\n                (err, tempBits) = bits(s, lext[symbol]);\n                if (err != ErrorCode.ERR_NONE) {\n                    return err;\n                }\n                len = lens[symbol] + tempBits;\n\n                // Get and check distance\n                (err, symbol) = _decode(s, distcode);\n                if (err != ErrorCode.ERR_NONE) {\n                    // Invalid symbol\n                    return err;\n                }\n                (err, tempBits) = bits(s, dext[symbol]);\n                if (err != ErrorCode.ERR_NONE) {\n                    return err;\n                }\n                dist = dists[symbol] + tempBits;\n                if (dist > s.outcnt) {\n                    // Distance too far back\n                    return ErrorCode.ERR_DISTANCE_TOO_FAR;\n                }\n\n                // Copy length bytes from distance bytes back\n                if (s.outcnt + len > s.output.length) {\n                    return ErrorCode.ERR_OUTPUT_EXHAUSTED;\n                }\n                while (len != 0) {\n                    // Note: Solidity reverts on underflow, so we decrement here\n                    len -= 1;\n                    s.output[s.outcnt] = s.output[s.outcnt - dist];\n                    s.outcnt++;\n                }\n            } else {\n                s.outcnt += len;\n            }\n        }\n\n        // Done with a valid fixed or dynamic block\n        return ErrorCode.ERR_NONE;\n    }\n\n    function _build_fixed(State memory s) private pure returns (ErrorCode) {\n        // Build fixed Huffman tables\n        // TODO this is all a compile-time constant\n        uint256 symbol;\n        uint256[] memory lengths = new uint256[](FIXLCODES);\n\n        // Literal/length table\n        for (symbol = 0; symbol < 144; symbol++) {\n            lengths[symbol] = 8;\n        }\n        for (; symbol < 256; symbol++) {\n            lengths[symbol] = 9;\n        }\n        for (; symbol < 280; symbol++) {\n            lengths[symbol] = 7;\n        }\n        for (; symbol < FIXLCODES; symbol++) {\n            lengths[symbol] = 8;\n        }\n\n        _construct(s.lencode, lengths, FIXLCODES, 0);\n\n        // Distance table\n        for (symbol = 0; symbol < MAXDCODES; symbol++) {\n            lengths[symbol] = 5;\n        }\n\n        _construct(s.distcode, lengths, MAXDCODES, 0);\n\n        return ErrorCode.ERR_NONE;\n    }\n\n    function _fixed(State memory s) private pure returns (ErrorCode) {\n        // Decode data until end-of-block code\n        return _codes(s, s.lencode, s.distcode);\n    }\n\n    function _build_dynamic_lengths(State memory s)\n        private\n        pure\n        returns (ErrorCode, uint256[] memory)\n    {\n        uint256 ncode;\n        // Index of lengths[]\n        uint256 index;\n        // Descriptor code lengths\n        uint256[] memory lengths = new uint256[](MAXCODES);\n        // Error code\n        ErrorCode err;\n        // Permutation of code length codes\n        uint8[19] memory order =\n            [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\n        (err, ncode) = bits(s, 4);\n        if (err != ErrorCode.ERR_NONE) {\n            return (err, lengths);\n        }\n        ncode += 4;\n\n        // Read code length code lengths (really), missing lengths are zero\n        for (index = 0; index < ncode; index++) {\n            (err, lengths[order[index]]) = bits(s, 3);\n            if (err != ErrorCode.ERR_NONE) {\n                return (err, lengths);\n            }\n        }\n        for (; index < 19; index++) {\n            lengths[order[index]] = 0;\n        }\n\n        return (ErrorCode.ERR_NONE, lengths);\n    }\n\n    function _build_dynamic(State memory s)\n        private\n        pure\n        returns (\n            ErrorCode,\n            Huffman memory,\n            Huffman memory\n        )\n    {\n        // Number of lengths in descriptor\n        uint256 nlen;\n        uint256 ndist;\n        // Index of lengths[]\n        uint256 index;\n        // Error code\n        ErrorCode err;\n        // Descriptor code lengths\n        uint256[] memory lengths = new uint256[](MAXCODES);\n        // Length and distance codes\n        Huffman memory lencode =\n            Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXLCODES));\n        Huffman memory distcode =\n            Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES));\n        uint256 tempBits;\n\n        // Get number of lengths in each table, check lengths\n        (err, nlen) = bits(s, 5);\n        if (err != ErrorCode.ERR_NONE) {\n            return (err, lencode, distcode);\n        }\n        nlen += 257;\n        (err, ndist) = bits(s, 5);\n        if (err != ErrorCode.ERR_NONE) {\n            return (err, lencode, distcode);\n        }\n        ndist += 1;\n\n        if (nlen > MAXLCODES || ndist > MAXDCODES) {\n            // Bad counts\n            return (\n                ErrorCode.ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES,\n                lencode,\n                distcode\n            );\n        }\n\n        (err, lengths) = _build_dynamic_lengths(s);\n        if (err != ErrorCode.ERR_NONE) {\n            return (err, lencode, distcode);\n        }\n\n        // Build huffman table for code lengths codes (use lencode temporarily)\n        err = _construct(lencode, lengths, 19, 0);\n        if (err != ErrorCode.ERR_NONE) {\n            // Require complete code set here\n            return (\n                ErrorCode.ERR_CODE_LENGTHS_CODES_INCOMPLETE,\n                lencode,\n                distcode\n            );\n        }\n\n        // Read length/literal and distance code length tables\n        index = 0;\n        while (index < nlen + ndist) {\n            // Decoded value\n            uint256 symbol;\n            // Last length to repeat\n            uint256 len;\n\n            (err, symbol) = _decode(s, lencode);\n            if (err != ErrorCode.ERR_NONE) {\n                // Invalid symbol\n                return (err, lencode, distcode);\n            }\n\n            if (symbol < 16) {\n                // Length in 0..15\n                lengths[index++] = symbol;\n            } else {\n                // Repeat instruction\n                // Assume repeating zeros\n                len = 0;\n                if (symbol == 16) {\n                    // Repeat last length 3..6 times\n                    if (index == 0) {\n                        // No last length!\n                        return (\n                            ErrorCode.ERR_REPEAT_NO_FIRST_LENGTH,\n                            lencode,\n                            distcode\n                        );\n                    }\n                    // Last length\n                    len = lengths[index - 1];\n                    (err, tempBits) = bits(s, 2);\n                    if (err != ErrorCode.ERR_NONE) {\n                        return (err, lencode, distcode);\n                    }\n                    symbol = 3 + tempBits;\n                } else if (symbol == 17) {\n                    // Repeat zero 3..10 times\n                    (err, tempBits) = bits(s, 3);\n                    if (err != ErrorCode.ERR_NONE) {\n                        return (err, lencode, distcode);\n                    }\n                    symbol = 3 + tempBits;\n                } else {\n                    // == 18, repeat zero 11..138 times\n                    (err, tempBits) = bits(s, 7);\n                    if (err != ErrorCode.ERR_NONE) {\n                        return (err, lencode, distcode);\n                    }\n                    symbol = 11 + tempBits;\n                }\n\n                if (index + symbol > nlen + ndist) {\n                    // Too many lengths!\n                    return (ErrorCode.ERR_REPEAT_MORE, lencode, distcode);\n                }\n                while (symbol != 0) {\n                    // Note: Solidity reverts on underflow, so we decrement here\n                    symbol -= 1;\n\n                    // Repeat last or zero symbol times\n                    lengths[index++] = len;\n                }\n            }\n        }\n\n        // Check for end-of-block code -- there better be one!\n        if (lengths[256] == 0) {\n            return (ErrorCode.ERR_MISSING_END_OF_BLOCK, lencode, distcode);\n        }\n\n        // Build huffman table for literal/length codes\n        err = _construct(lencode, lengths, nlen, 0);\n        if (\n            err != ErrorCode.ERR_NONE &&\n            (err == ErrorCode.ERR_NOT_TERMINATED ||\n                err == ErrorCode.ERR_OUTPUT_EXHAUSTED ||\n                nlen != lencode.counts[0] + lencode.counts[1])\n        ) {\n            // Incomplete code ok only for single length 1 code\n            return (\n                ErrorCode.ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS,\n                lencode,\n                distcode\n            );\n        }\n\n        // Build huffman table for distance codes\n        err = _construct(distcode, lengths, ndist, nlen);\n        if (\n            err != ErrorCode.ERR_NONE &&\n            (err == ErrorCode.ERR_NOT_TERMINATED ||\n                err == ErrorCode.ERR_OUTPUT_EXHAUSTED ||\n                ndist != distcode.counts[0] + distcode.counts[1])\n        ) {\n            // Incomplete code ok only for single length 1 code\n            return (\n                ErrorCode.ERR_INVALID_DISTANCE_CODE_LENGTHS,\n                lencode,\n                distcode\n            );\n        }\n\n        return (ErrorCode.ERR_NONE, lencode, distcode);\n    }\n\n    function _dynamic(State memory s) private pure returns (ErrorCode) {\n        // Length and distance codes\n        Huffman memory lencode;\n        Huffman memory distcode;\n        // Error code\n        ErrorCode err;\n\n        (err, lencode, distcode) = _build_dynamic(s);\n        if (err != ErrorCode.ERR_NONE) {\n            return err;\n        }\n\n        // Decode data until end-of-block code\n        return _codes(s, lencode, distcode);\n    }\n\n    function puff(bytes memory source, uint256 destlen)\n        internal\n        pure\n        returns (ErrorCode, bytes memory)\n    {\n        // Input/output state\n        State memory s =\n            State(\n                new bytes(destlen),\n                0,\n                source,\n                0,\n                0,\n                0,\n                Huffman(new uint256[](MAXBITS + 1), new uint256[](FIXLCODES)),\n                Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES))\n            );\n        // Temp: last bit\n        uint256 last;\n        // Temp: block type bit\n        uint256 t;\n        // Error code\n        ErrorCode err;\n\n        // Build fixed Huffman tables\n        err = _build_fixed(s);\n        if (err != ErrorCode.ERR_NONE) {\n            return (err, s.output);\n        }\n\n        // Process blocks until last block or error\n        while (last == 0) {\n            // One if last block\n            (err, last) = bits(s, 1);\n            if (err != ErrorCode.ERR_NONE) {\n                return (err, s.output);\n            }\n\n            // Block type 0..3\n            (err, t) = bits(s, 2);\n            if (err != ErrorCode.ERR_NONE) {\n                return (err, s.output);\n            }\n\n            err = (\n                t == 0\n                    ? _stored(s)\n                    : (\n                        t == 1\n                            ? _fixed(s)\n                            : (\n                                t == 2\n                                    ? _dynamic(s)\n                                    : ErrorCode.ERR_INVALID_BLOCK_TYPE\n                            )\n                    )\n            );\n            // type == 3, invalid\n\n            if (err != ErrorCode.ERR_NONE) {\n                // Return with error\n                break;\n            }\n        }\n\n        return (err, s.output);\n    }\n}\n"
88     },
89     "gwei-slim-nft-contracts/contracts/base/ERC721Base.sol": {
90       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\nimport {ERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport {IERC2981Upgradeable, IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/interfaces/IERC2981Upgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {StringsUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport {CountersUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport {IBaseERC721Interface} from \"./IBaseERC721Interface.sol\";\n\nstruct ConfigSettings {\n    uint16 royaltyBps;\n    string uriBase;\n    string uriExtension;\n    bool hasTransferHook;\n}\n\n/**\n    This smart contract adds features and allows for a ownership only by another smart contract as fallback behavior\n    while also implementing all normal ERC721 functions as expected\n*/\ncontract ERC721Base is\n    ERC721Upgradeable,\n    IBaseERC721Interface,\n    IERC2981Upgradeable,\n    OwnableUpgradeable\n{\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    // Minted counter for totalSupply()\n    CountersUpgradeable.Counter private mintedCounter;\n\n    modifier onlyInternal() {\n        require(msg.sender == address(this), \"Only internal\");\n        _;\n    }\n\n    /// on-chain record of when this contract was deployed\n    uint256 public immutable deployedBlock;\n\n    ConfigSettings public advancedConfig;\n\n    /// Constructor called once when the base contract is deployed\n    constructor() {\n        // Can be used to verify contract implementation is correct at address\n        deployedBlock = block.number;\n    }\n\n    /// Initializer that's called when a new child nft is setup\n    /// @param newOwner Owner for the new derived nft\n    /// @param _name name of NFT contract\n    /// @param _symbol symbol of NFT contract\n    /// @param settings configuration settings for uri, royalty, and hooks features\n    function initialize(\n        address newOwner,\n        string memory _name,\n        string memory _symbol,\n        ConfigSettings memory settings\n    ) public initializer {\n        __ERC721_init(_name, _symbol);\n        __Ownable_init();\n\n        advancedConfig = settings;\n\n        transferOwnership(newOwner);\n    }\n\n    /// Getter to expose appoval status to root contract\n    function isApprovedForAll(address _owner, address operator)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            ERC721Upgradeable.isApprovedForAll(_owner, operator) ||\n            operator == address(this);\n    }\n\n    /// internal getter for approval by all\n    /// When isApprovedForAll is overridden, this can be used to call original impl\n    function __isApprovedForAll(address _owner, address operator)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return isApprovedForAll(_owner, operator);\n    }\n\n    /// Hook that when enabled manually calls _beforeTokenTransfer on\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        if (advancedConfig.hasTransferHook) {\n            (bool success, ) = address(this).delegatecall(\n                abi.encodeWithSignature(\n                    \"_beforeTokenTransfer(address,address,uint256)\",\n                    from,\n                    to,\n                    tokenId\n                )\n            );\n            // Raise error again from result if error exists\n            assembly {\n                switch success\n                // delegatecall returns 0 on error.\n                case 0 {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n\n    /// Internal-only function to update the base uri\n    function __setBaseURI(string memory uriBase, string memory uriExtension)\n        public\n        override\n        onlyInternal\n    {\n        advancedConfig.uriBase = uriBase;\n        advancedConfig.uriExtension = uriExtension;\n    }\n\n    /// @dev returns the number of minted tokens\n    /// uses some extra gas but makes etherscan and users happy so :shrug:\n    /// partial erc721enumerable implemntation\n    function totalSupply() public view returns (uint256) {\n        return mintedCounter.current();\n    }\n\n    /**\n      Internal-only\n      @param to address to send the newly minted NFT to\n      @dev This mints one edition to the given address by an allowed minter on the edition instance.\n     */\n    function __mint(address to, uint256 tokenId)\n        external\n        override\n        onlyInternal\n    {\n        _mint(to, tokenId);\n        mintedCounter.increment();\n    }\n\n    /**\n        @param tokenId Token ID to burn\n        User burn function for token id \n     */\n    function burn(uint256 tokenId) public {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not allowed\");\n        _burn(tokenId);\n        mintedCounter.decrement();\n    }\n\n    /// Internal only\n    function __burn(uint256 tokenId) public onlyInternal {\n        _burn(tokenId);\n        mintedCounter.decrement();\n    }\n\n    /**\n        Simple override for owner interface.\n     */\n    function owner()\n        public\n        view\n        override(OwnableUpgradeable)\n        returns (address)\n    {\n        return super.owner();\n    }\n\n    /// internal alias for overrides\n    function __owner()\n        public\n        view\n        override(IBaseERC721Interface)\n        returns (address)\n    {\n        return owner();\n    }\n\n    /// Get royalty information for token\n    /// ignored token id to get royalty info. able to override and set per-token royalties\n    /// @param _salePrice sales price for token to determine royalty split\n    function royaltyInfo(uint256, uint256 _salePrice)\n        external\n        view\n        override\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        // If ownership is revoked, don't set royalties.\n        if (owner() == address(0x0)) {\n            return (owner(), 0);\n        }\n        return (owner(), (_salePrice * advancedConfig.royaltyBps) / 10_000);\n    }\n\n    /// Default simple token-uri implementation. works for ipfs folders too\n    /// @param tokenId token id ot get uri for\n    /// @return default uri getter functionality\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        require(_exists(tokenId), \"No token\");\n\n        return\n            string(\n                abi.encodePacked(\n                    advancedConfig.uriBase,\n                    StringsUpgradeable.toString(tokenId),\n                    advancedConfig.uriExtension\n                )\n            );\n    }\n\n    /// internal base override\n    function __tokenURI(uint256 tokenId)\n        public\n        view\n        onlyInternal\n        returns (string memory)\n    {\n        return tokenURI(tokenId);\n    }\n\n    /// Exposing token exists check for base contract\n    function __exists(uint256 tokenId) external view override returns (bool) {\n        return _exists(tokenId);\n    }\n\n    /// Getter for approved or owner\n    function __isApprovedOrOwner(address spender, uint256 tokenId)\n        external\n        view\n        override\n        onlyInternal\n        returns (bool)\n    {\n        return _isApprovedOrOwner(spender, tokenId);\n    }\n\n    /// IERC165 getter\n    /// @param interfaceId interfaceId bytes4 to check support for\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return\n            type(IERC2981Upgradeable).interfaceId == interfaceId ||\n            type(IBaseERC721Interface).interfaceId == interfaceId ||\n            ERC721Upgradeable.supportsInterface(interfaceId);\n    }\n}\n"
91     },
92     "gwei-slim-nft-contracts/contracts/base/ERC721Delegated.sol": {
93       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\nimport {StorageSlotUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\";\n\nimport {IBaseERC721Interface, ConfigSettings} from \"./ERC721Base.sol\";\n\ncontract ERC721Delegated {\n    uint256[100000] gap;\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    // Reference to base NFT implementation\n    function implementation() public view returns (address) {\n        return\n            StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    function _initImplementation(address _nftImplementation) private {\n        StorageSlotUpgradeable\n            .getAddressSlot(_IMPLEMENTATION_SLOT)\n            .value = _nftImplementation;\n    }\n\n    /// Constructor that sets up the\n    constructor(\n        address _nftImplementation,\n        string memory name,\n        string memory symbol,\n        ConfigSettings memory settings\n    ) {\n        /// Removed for gas saving reasons, the check below implictly accomplishes this\n        // require(\n        //     _nftImplementation.supportsInterface(\n        //         type(IBaseERC721Interface).interfaceId\n        //     )\n        // );\n        _initImplementation(_nftImplementation);\n        (bool success, ) = _nftImplementation.delegatecall(\n            abi.encodeWithSignature(\n                \"initialize(address,string,string,(uint16,string,string,bool))\",\n                msg.sender,\n                name,\n                symbol,\n                settings\n            )\n        );\n        require(success);\n    }\n\n    /// OnlyOwner implemntation that proxies to base ownable contract for info\n    modifier onlyOwner() {\n        require(msg.sender == base().__owner(), \"Not owner\");\n        _;\n    }\n\n    /// Getter to return the base implementation contract to call methods from\n    /// Don't expose base contract to parent due to need to call private internal base functions\n    function base() private view returns (IBaseERC721Interface) {\n        return IBaseERC721Interface(address(this));\n    }\n\n    // helpers to mimic Openzeppelin internal functions\n\n    /// Getter for the contract owner\n    /// @return address owner address\n    function _owner() internal view returns (address) {\n        return base().__owner();\n    }\n\n    /// Internal burn function, only accessible from within contract\n    /// @param id nft id to burn\n    function _burn(uint256 id) internal {\n        base().__burn(id);\n    }\n\n    /// Internal mint function, only accessible from within contract\n    /// @param to address to mint NFT to\n    /// @param id nft id to mint\n    function _mint(address to, uint256 id) internal {\n        base().__mint(to, id);\n    }\n\n    /// Internal exists function to determine if fn exists\n    /// @param id nft id to check if exists\n    function _exists(uint256 id) internal view returns (bool) {\n        return base().__exists(id);\n    }\n\n    /// Internal getter for tokenURI\n    /// @param tokenId id of token to get tokenURI for\n    function _tokenURI(uint256 tokenId) internal view returns (string memory) {\n        return base().__tokenURI(tokenId);\n    }\n\n    /// is approved for all getter underlying getter\n    /// @param owner to check\n    /// @param operator to check\n    function _isApprovedForAll(address owner, address operator)\n        internal\n        view\n        returns (bool)\n    {\n        return base().__isApprovedForAll(owner, operator);\n    }\n\n    /// Internal getter for approved or owner for a given operator\n    /// @param operator address of operator to check\n    /// @param id id of nft to check for\n    function _isApprovedOrOwner(address operator, uint256 id)\n        internal\n        view\n        returns (bool)\n    {\n        return base().__isApprovedOrOwner(operator, id);\n    }\n\n    /// Sets the base URI of the contract. Allowed only by parent contract\n    /// @param newUri new uri base (http://URI) followed by number string of nft followed by extension string\n    /// @param newExtension optional uri extension\n    function _setBaseURI(string memory newUri, string memory newExtension)\n        internal\n    {\n        base().__setBaseURI(newUri, newExtension);\n    }\n\n    /**\n     * @dev Delegates the current call to nftImplementation.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        address impl = implementation();\n\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev No base NFT functions receive any value\n     */\n    receive() external payable {\n        revert();\n    }\n}\n"
94     },
95     "gwei-slim-nft-contracts/contracts/base/IBaseERC721Interface.sol": {
96       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\n/// Additional features and functions assigned to the\n/// Base721 contract for hooks and overrides\ninterface IBaseERC721Interface {\n    /*\n     Exposing common NFT internal functionality for base contract overrides\n     To save gas and make API cleaner this is only for new functionality not exposed in\n     the core ERC721 contract\n    */\n\n    /// Mint an NFT. Allowed to mint by owner, approval or by the parent contract\n    /// @param tokenId id to burn\n    function __burn(uint256 tokenId) external;\n\n    /// Mint an NFT. Allowed only by the parent contract\n    /// @param to address to mint to\n    /// @param tokenId token id to mint\n    function __mint(address to, uint256 tokenId) external;\n\n    /// Set the base URI of the contract. Allowed only by parent contract\n    /// @param base base uri\n    /// @param extension extension\n    function __setBaseURI(string memory base, string memory extension) external;\n\n    /* Exposes common internal read features for public use */\n\n    /// Token exists\n    /// @param tokenId token id to see if it exists\n    function __exists(uint256 tokenId) external view returns (bool);\n\n    /// Simple approval for operation check on token for address\n    /// @param spender address spending/changing token\n    /// @param tokenId tokenID to change / operate on\n    function __isApprovedOrOwner(address spender, uint256 tokenId)\n        external\n        view\n        returns (bool);\n\n    function __isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n\n    function __tokenURI(uint256 tokenId) external view returns (string memory);\n\n    function __owner() external view returns (address);\n}\n"
97     }
98   }
99 }}