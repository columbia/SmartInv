1 {{
2   "language": "Solidity",
3   "sources": {
4     "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
6     },
7     "@openzeppelin/contracts/utils/Create2.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address addr) {\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | â†“ ptr ...  â†“ ptr + 0x0B (start) ...  â†“ ptr + 0x20 ...  â†“ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"
9     },
10     "contracts/Lawless/Lawless.sol": {
11       "content": "// SPDX-License-Identifier: AGPL-3.0\n// Â©2023 Ponderware Ltd\n\npragma solidity ^0.8.17;\n\nimport \"./lib/LawlessGIF.sol\";\nimport \"../lib/TokenizedContract.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\ninterface IDelegationRegistry {\n    function checkDelegateForContract(address delegate, address vault, address contract_) external view returns(bool);\n    function checkDelegateForToken(address delegate, address vault, address contract_, uint256 tokenId) external view returns (bool);\n\n}\n\ninterface ICustomAttributes {\n    function getCustomAttributes () external view returns (bytes memory);\n}\n\ninterface ILawlessMetadata {\n    function generateTokenURI (LawlessData memory) external view returns (string memory);\n    function setB64EncodeURI (bool value) external;\n    function addMetadataMod (address addr) external;\n}\n\ntype Ex is uint256;\n\nstruct Record {\n    address owner;\n    uint16 index;\n    uint16 version;\n    uint16 style;\n    uint48 details;\n}\n\nstruct LawlessData {\n    uint id;\n    uint modelId;\n    uint paletteId;\n    address owner;\n    uint16 version;\n    uint48 details;\n}\n\n/*\n * @title Lawless\n * @author Ponderware Ltd\n * @notice chain-complete ERC-721 character contract\n */\ncontract Lawless is TokenizedContract, LawlessGIF {\n\n    string public name = \"lawless\";\n    string public symbol = unicode\"ðŸ´\";\n\n    constructor (uint256 tokenId) TokenizedContract(tokenId) {\n        addRole(owner(), Role.Uploader);\n        addRole(owner(), Role.Curator);\n        addRole(owner(), Role.Pauser);\n        addRole(0xEBFEFB02CaD474D35CabADEbddF0b32D287BE1bd, Role.CodeLawless);\n    }\n\n    /* Events */\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /* Supply */\n\n    uint256 internal constant maxSupply = 8192;\n    uint256 internal constant maxSupplyMod = 8191;\n    uint256 public totalSupply = 0;\n\n    /* Bookkeeping Data */\n\n    Record[maxSupply] internal Records;\n    mapping (address => uint16[maxSupply+1]) internal TokensByOwner; // index 0 is \"length\"\n\n    modifier validLawlessId (uint id) {\n        require(id < totalSupply, \"unrecognized lawless\");\n        _;\n    }\n\n    /* Delegation */\n\n    IDelegationRegistry constant dc = IDelegationRegistry(0x00000000000076A84feF008CDAbe6409d2FE638B);\n\n    bool public delegationEnabled = true;\n\n    function smashFlask () public onlyBy(Role.Ponderware) {\n        delegationEnabled = false;\n    }\n\n    /* Data */\n\n    function uploadModels (uint48 count, bytes memory data) public onlyBy(Role.Uploader) {\n        _uploadModels(count, data);\n    }\n\n    function uploadPalettes (uint48 count, bytes memory data) public onlyBy(Role.Uploader) {\n        _uploadPalettes(count, data);\n    }\n\n    /* Metadata */\n\n    ILawlessMetadata Metadata;\n\n    function setMetadata (bytes calldata metadata) public onlyBy(Role.Curator) {\n        removeRole(address(Metadata), Role.Metadata);\n        Metadata = ILawlessMetadata(Create2.deploy(0, 0, abi.encodePacked(metadata, abi.encode(address(this), CodexAddress))));\n        addRole(address(Metadata), Role.Metadata);\n    }\n\n    function setB64EncodeURI (bool value) public onlyBy(Role.Curator) {\n        Metadata.setB64EncodeURI(value);\n    }\n\n    function addMetadataMod (address addr) public onlyBy(Role.Curator) {\n        Metadata.addMetadataMod(addr);\n    }\n\n    function getModel (uint id) public view onlyBy(Role.Metadata) returns (Model memory) {\n        return _getModel(id);\n    }\n\n    function getPalette (uint id) public view onlyBy(Role.Metadata) returns (bytes memory) {\n        return _getPalette(id);\n    }\n\n    function staticGIF (Model memory model, bytes memory palette) public view onlyBy(Role.Metadata) returns (string memory) {\n        return _staticGIF(model, palette);\n    }\n\n    function animatedGIF (Model memory model, bytes memory palette) public view onlyBy(Role.Metadata) returns (string memory) {\n        return _animatedGIF(model, palette);\n    }\n\n    function getModelAndPaletteIds (uint style) internal pure returns (uint, uint) {\n        return (style >> 5, style & 31);\n    }\n\n    function getData (uint id) public view validLawlessId(id) returns (LawlessData memory) {\n        Record storage record = Records[id];\n        (uint modelId, uint paletteId) = getModelAndPaletteIds(record.style);\n        return LawlessData(id, modelId, paletteId, record.owner, record.version, record.details);\n    }\n\n    /* Token URI */\n\n    function tokenURI (Ex tokenId) public view returns (string memory) {\n        uint id = Ex.unwrap(tokenId) & maxSupplyMod;\n        require (Ex.unwrap(tokenId) == (id + Records[id].version * maxSupply), \"invalid tokenId\");\n        return Metadata.generateTokenURI(getData(id));\n    }\n\n    /* View Helpers */\n\n    function getTokenId (uint256 id) external view validLawlessId(id) returns (uint) {\n        return id + Records[id].version * maxSupply;\n    }\n\n    function getLawlessId (Ex tokenId) external view returns (uint id) {\n        id = Ex.unwrap(tokenId) & maxSupplyMod;\n        require (id < totalSupply && Ex.unwrap(tokenId) == (id + Records[id].version * maxSupply), \"invalid tokenId\");\n    }\n\n    /* Immutable lawless GIF lookups */\n\n    function lawlessGIF (uint256 id, bool base) public view validLawlessId(id) returns (string memory) {\n        Record storage record = Records[id];\n        (uint modelId, uint paletteId) = getModelAndPaletteIds(record.style);\n        uint details = record.details;\n        if (!base) {\n            uint morph = details >> 24;\n            if ((morph & 1024) > 0) {\n                modelId = 256 + (morph & 1023);\n            }\n            uint shift = details >> 12;\n            if ((shift & 1024) > 0) {\n                paletteId = 32 + (shift & 1023);\n            }\n        }\n        if (details >= 211106232532992 || modelId > 255) {\n            return _animatedGIF(_getModel(modelId), _getPalette(paletteId));\n        } else {\n            return _staticGIF(_getModel(modelId), _getPalette(paletteId));\n        }\n    }\n\n    function tokenGIF (Ex tokenId, bool base) external view returns (string memory) {\n        uint id = Ex.unwrap(tokenId) & maxSupplyMod;\n        require (Ex.unwrap(tokenId) == (id + Records[id].version * maxSupply), \"invalid tokenId\");\n        return lawlessGIF(id, base);\n    }\n\n    /* Details */\n\n    function _updateId (uint id, address owner) internal {\n        uint currentVersion = Records[id].version++;\n        uint currentExternalId = id + (currentVersion * totalSupply);\n        uint nextExternalId = currentExternalId + maxSupply;\n        emit Transfer(owner, address(0), currentExternalId);\n        emit Transfer(address(0), owner, nextExternalId);\n    }\n\n    function _authorized (uint id, address owner, address operator) internal view returns (bool) {\n        return (operator == CodexAddress\n                || operator == owner\n                || TokenApprovals[id] == operator\n                || isApprovedForAll(owner, operator)\n                || (delegationEnabled\n                    && (dc.checkDelegateForContract(operator, owner, address(this))\n                        || dc.checkDelegateForToken(operator, owner, address(this), id))));\n\n    }\n\n    function getDetails (Ex tokenId) external view returns (uint, address, uint48) {\n        uint id = Ex.unwrap(tokenId) & maxSupplyMod;\n        Record storage record = Records[id];\n        require (id < totalSupply && Ex.unwrap(tokenId) == (id + record.version * maxSupply), \"invalid tokenId\");\n        return (id, record.owner, record.details);\n    }\n\n    function authorized (address operator, Ex tokenId) external view returns (bool) {\n        uint id = Ex.unwrap(tokenId) & maxSupplyMod;\n        Record storage record = Records[id];\n        require (id < totalSupply && Ex.unwrap(tokenId) == (id + record.version * maxSupply), \"invalid tokenId\");\n        return _authorized(id, record.owner, operator);\n    }\n\n    function incrementVersion (address operator, uint id) external validLawlessId(id) onlyBy(Role.Surgeon) {\n        Record storage record = Records[id];\n        require(_authorized(id, record.owner, operator), \"unauthorized\");\n        _updateId(id, record.owner);\n    }\n\n    function updateDetails (address operator, uint id, uint48 details, bool incVersion) external validLawlessId(id) onlyBy(Role.Surgeon) {\n        Record storage record = Records[id];\n        require(_authorized(id, record.owner, operator), \"unauthorized\");\n        record.details = details;\n        if (incVersion) _updateId(id, record.owner);\n    }\n\n    /* Minting */\n\n    function handleMint (bytes32 seed, address to, uint48 details) internal {\n        uint index = (uint256(seed) % (maxSupply - totalSupply)) + totalSupply;\n        Record storage atCursor = Records[totalSupply];\n        Record storage atIndex = Records[index];\n        uint16 atIndexStyle = atIndex.style;\n        if (atCursor.owner == address(0)) {\n            atIndex.style = uint16(totalSupply);\n        } else {\n            atIndex.style = atCursor.style;\n        }\n        if (atIndex.owner == address(0)) {\n            atCursor.style = uint16(index);\n        } else {\n            atCursor.style = atIndexStyle;\n        }\n\n        atIndex.owner = to; // used to check if value has been seen\n        atCursor.owner = to;\n        atCursor.details = details;\n\n        uint16 setIndex = TokensByOwner[to][0]++;\n        atCursor.index = setIndex;\n        TokensByOwner[to][setIndex + 1] = uint16(totalSupply);\n        emit Transfer(address(0), to, totalSupply);\n        totalSupply++;\n    }\n\n    function mint (uint256 seed, address to, uint48 details) public onlyBy(Role.Minter) {\n        require (totalSupply < maxSupply, \"rescue complete\");\n        handleMint(keccak256(abi.encodePacked(to, seed, totalSupply)), to, details);\n    }\n\n    function batchMint (uint256 seed, address[] calldata to, uint48[] calldata details) public onlyBy(Role.Minter) {\n        require ((totalSupply + to.length) <= maxSupply, \"insufficient supply\");\n        for (uint i = 0; i < to.length; i++) {\n            handleMint(keccak256(abi.encodePacked(to[i], seed, totalSupply, i)), to[i], details[i]);\n        }\n    }\n\n    /* ERC-165 */\n\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n\n        if (msg.sender == CodexAddress) { // workaround for ERC721 custom metadata\n            return\n                interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n                interfaceId == type(ICustomAttributes).interfaceId;\n        } else {\n            return\n                interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n                interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n                interfaceId == 0x780E9D63 || // ERC165 Interface ID for ERC721Enumerable\n                interfaceId == 0x5b5e139f || // ERC165 Interface ID for ERC721Metadata\n                interfaceId == 0x2A55205A || // ERC165 Interface ID for ERC2981\n                interfaceId == type(ICustomAttributes).interfaceId;\n        }\n    }\n\n    /* Custom Attributes */\n\n    function getCustomAttributes () external view returns (bytes memory) {\n        string memory mintedPct = toPctString1000x(totalSupply * 1000 / maxSupply);\n        return abi.encodePacked(ICodex(CodexAddress).encodeStringAttribute(\"token type\", \"ERC-721\"),\n                                \",\",\n                                ICodex(CodexAddress).encodeNumericAttribute(\"total supply\", totalSupply),\n                                \",\",\n                                ICodex(CodexAddress).encodeStringAttribute(\"minted\", mintedPct));\n    }\n\n    /* ERC-721 Base */\n\n    // Mapping from token ID to approved address\n    address[maxSupply] private TokenApprovals;\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private OperatorApprovals;\n\n    function _transfer (address from, address to, Ex tokenId) private whenNotPaused {\n        uint id = Ex.unwrap(tokenId) & maxSupplyMod;  // don't need to check if id < totalSupply because Records lookup will fail\n        TokenApprovals[id] = address(0); // Clear approvals from the previous owner\n        Record storage record = Records[id];\n        require(record.owner == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n        require(Ex.unwrap(tokenId) == (id + (record.version * maxSupply)), \"ERC721: Nonexistent token\");\n        uint16 valueIndex = record.index + 1;\n        uint16 lastIndex = TokensByOwner[from][0]--;\n        if (lastIndex != valueIndex) {\n            uint16 lastId = TokensByOwner[from][lastIndex];\n            TokensByOwner[from][valueIndex] = lastId;\n            Records[lastId].index = valueIndex - 1;\n        }\n        TokensByOwner[from][lastIndex] = 0;\n        uint16 newOwnerIndex = ++TokensByOwner[to][0];\n        record.index = newOwnerIndex - 1;\n        TokensByOwner[to][newOwnerIndex] = uint16(id);\n        record.owner = to;\n        emit Transfer(from, to, Ex.unwrap(tokenId));\n    }\n\n    function tokenExists (Ex tokenId) external view returns (bool exists) {\n        uint id = Ex.unwrap(tokenId) & maxSupplyMod;\n        Record storage record = Records[id];\n        return (id < totalSupply && Ex.unwrap(tokenId) == (id + record.version * maxSupply));\n    }\n\n    function _ownerOf (Ex tokenId) internal view returns (address, uint) {\n        uint id = Ex.unwrap(tokenId) & maxSupplyMod;\n        Record storage record = Records[id];\n        require (id < totalSupply && Ex.unwrap(tokenId) == (id + record.version * maxSupply), \"invalid tokenId\");\n        return (record.owner, id);\n    }\n\n    function ownerOf (Ex tokenId) external view returns (address owner) {\n        (owner,) = _ownerOf(tokenId);\n    }\n\n    function balanceOf (address owner) public view returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return TokensByOwner[owner][0];\n    }\n\n    function approve (address to, Ex tokenId) external  {\n        (address owner, uint id) = _ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),\n                \"ERC721: approve caller is not owner nor approved for all\");\n        TokenApprovals[id] = to;\n        emit Approval(owner, to, Ex.unwrap(tokenId));\n    }\n\n    function getApproved (Ex tokenId) external view returns (address) {\n        uint id = Ex.unwrap(tokenId) & maxSupplyMod;\n        require(id < totalSupply\n                &&\n                (Ex.unwrap(tokenId) == id + maxSupply * Records[id].version),\n                \"No such token\");\n        return TokenApprovals[id];\n    }\n\n    function isApprovedForAll (address owner, address operator) public view returns (bool) {\n        return OperatorApprovals[owner][operator];\n    }\n\n    function setApprovalForAll (address operator, bool approved) external {\n        require(msg.sender != operator, \"ERC721: approve to caller\");\n        OperatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function _isApprovedOrOwner (address spender, Ex tokenId) internal view returns (bool) {\n        (address owner, uint id) = _ownerOf(tokenId);\n        return (spender == owner || TokenApprovals[id] == spender || isApprovedForAll(owner, spender));\n    }\n\n    function _checkOnERC721Received(address from, address to, Ex tokenId, bytes memory _data) private returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(to) }\n        if (size > 0) { // checking for contract\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, Ex.unwrap(tokenId), _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly { revert(add(32, reason), mload(reason)) }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    function _safeTransfer (address from, address to, Ex tokenId, bytes memory _data) private {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    function transferFrom (address from, address to, Ex tokenId) external {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom (address from, address to, Ex tokenId) external {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom (address from, address to, Ex tokenId, bytes memory _data) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /* ERC-721 Enumerable */\n\n    function tokenByIndex (uint256 index) external view returns (uint256) {\n        require (index < totalSupply, \"ERC721Enumerable: ?? LOOKUP\");\n        return(index + Records[index].version * maxSupply);\n    }\n\n    function tokenOfOwnerByIndex (address owner, uint256 index) external view returns (uint256) {\n        require(index < balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        uint id = TokensByOwner[owner][index + 1];\n        return(id + Records[id].version * maxSupply);\n    }\n\n    /* Royalty Bullshit */\n\n    function royaltyInfo (uint256 /*tokenId*/, uint256 /*salePrice8*/) external view returns (address, uint256) {\n        return (owner(), 0);\n    }\n\n    /* Util */\n\n    bytes10 private constant _SYMBOLS = \"0123456789\";\n    function toPctString1000x (uint256 value) public pure returns (string memory pct) {\n        //Adapted From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\n        uint256 length = 1;\n        uint256 v = value;\n        bytes memory buffer;\n        unchecked {\n            if (v >= 100) {\n                v /= 100;\n                length += 2;\n            }\n            if (v >= 10) {\n                length += 1;\n            }\n            buffer = new bytes(length);\n            uint256 ptr;\n            assembly {\n            ptr := add(buffer, add(32, length))\n                    }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                        }\n                value /= 10;\n                if (value == 0) break;\n            }\n        }\n        if (length == 1) {\n            pct = string(abi.encodePacked(\"0.\", buffer, \"%\"));\n        } else if (length == 2) {\n            pct = string(abi.encodePacked(buffer[0], \".\", buffer[1], \"%\"));\n        } else if (length == 3) {\n            pct = string(abi.encodePacked(buffer[0], buffer[1], \".\", buffer[2], \"%\"));\n        } else {\n            pct = \"100%\";\n        }\n    }\n}\n"
12     },
13     "contracts/Lawless/lib/LawlessGIF.sol": {
14       "content": "// SPDX-License-Identifier: AGPL-3.0\n// Â©2023 Ponderware Ltd\n\npragma solidity ^0.8.17;\n\nimport \"../../lib/Base64.sol\";\nimport \"../../lib/ItemStorage.sol\";\nimport \"../../lib/image/GIF32.sol\";\nimport \"solmate/src/utils/SSTORE2.sol\";\n\nstruct Model {\n    uint8 width;\n    uint8 height;\n    uint8 aniX;\n    uint8 aniY;\n    uint8 aniWidth;\n    uint8 aniHeight;\n    uint8 aniDelay1;\n    uint8 aniDelay2;\n    uint8 aniDelay3;\n    uint8 staticWidth;\n    uint8 staticHeight;\n    uint8 staticOffsetX;\n    uint8 staticOffsetY;\n    uint8 maxScale;\n    bytes f1;\n    bytes f2;\n    bytes f3;\n    bytes f4;\n}\n\ncontract LawlessGIF {\n\n    /* Data Stores */\n\n    ItemStorage.Store internal ModelData;\n    ItemStorage.Store internal PaletteData;\n\n    /* Unpack Models */\n\n    function slice(uint begin, uint len, bytes memory arr) internal pure returns (bytes memory) {\n        bytes memory res = new bytes(len);\n        for (uint i = 0; i < len; i++) {\n            res[i] = arr[i+begin];\n        }\n        return res;\n    }\n\n    function slice2(uint loc, bytes memory arr) internal pure returns (uint) {\n        uint res = uint(uint8(arr[loc])) << 8;\n        return (res + uint8(arr[loc + 1]));\n    }\n\n    function unpackModel (bytes memory input) internal pure returns (Model memory) {\n\n        uint pointer = 14;\n        uint len = slice2(pointer, input);\n        pointer += 2;\n        bytes memory f1 = slice(pointer, len, input);\n\n        pointer += len;\n        len = slice2(pointer, input);\n        pointer += 2;\n        bytes memory f2 = slice(pointer, len, input);\n\n        pointer += len;\n        len = slice2(pointer, input);\n        pointer += 2;\n        bytes memory f3 = slice(pointer, len, input);\n\n        pointer += len;\n        len = slice2(pointer, input);\n        pointer += 2;\n        bytes memory f4 = slice(pointer, len, input);\n\n        return Model(uint8(bytes1(input[0])),\n                     uint8(bytes1(input[1])),\n                     uint8(bytes1(input[2])),\n                     uint8(bytes1(input[3])),\n                     uint8(bytes1(input[4])),\n                     uint8(bytes1(input[5])),\n                     uint8(bytes1(input[6])),\n                     uint8(bytes1(input[7])),\n                     uint8(bytes1(input[8])),\n                     uint8(bytes1(input[9])),\n                     uint8(bytes1(input[10])),\n                     uint8(bytes1(input[11])),\n                     uint8(bytes1(input[12])),\n                     uint8(bytes1(input[13])),\n                     f1,\n                     f2,\n                     f3,\n                     f4);\n    }\n\n    /* Model Data Storage */\n\n    function _uploadModels (uint48 count, bytes memory data) internal {\n        ItemStorage.upload(ModelData, count, data);\n    }\n\n    function _getModel (uint id) internal view returns (Model memory) {\n        return unpackModel(ItemStorage.bget(ModelData, id));\n    }\n\n    /* Palettes Data Storage */\n\n    function _uploadPalettes (uint48 count, bytes memory data) internal {\n        ItemStorage.upload(PaletteData, count, data);\n    }\n\n    function _getPalette (uint id) internal view returns (bytes memory) {\n        bytes memory loaded = ItemStorage.bget(PaletteData, id);\n        bytes memory palette = new bytes(96);\n        for (uint i = 0; i < loaded.length; i++) {\n            palette[i] = loaded[i];\n        }\n        return palette;\n    }\n\n    /* Assemble Images */\n\n    uint8 constant MCS = 5;\n\n    function _staticGIF (Model memory m, bytes memory palette) internal pure returns (string memory) {\n        bytes memory gif = GIF32.assembleStatic(m.width, m.height, true,\n                                                GIF32.frame(0, 0, m.width, m.height, MCS, m.f1),\n                                                MCS, palette);\n\n        return string(abi.encodePacked(\"data:image/gif;base64,\",Base64.encode(gif)));\n\n    }\n\n    function _animatedGIF (Model memory m, bytes memory palette) internal pure returns (string memory) {\n        bytes memory framedata = abi.encodePacked(\n                                                  abi.encodePacked(\n                                                                   GIF32.gce10x(false, m.aniDelay1, 0),\n                                                                   GIF32.frame(0, 0, m.width, m.height, MCS, m.f1)),\n\n                                                  GIF32.gce10x(true, 0, 0),\n                                                  GIF32.frame(m.aniX, m.aniY, m.aniWidth, m.aniHeight, MCS, m.f2),\n\n                                                  GIF32.gce10x(true, m.aniDelay2, 0),\n                                                  GIF32.frame(m.aniX, m.aniY, m.aniWidth, m.aniHeight, MCS, m.f3),\n\n                                                  GIF32.gce10x(true, m.aniDelay3, 0),\n                                                  GIF32.frame(m.aniX, m.aniY, m.aniWidth, m.aniHeight, MCS, m.f4));\n\n\n        bytes memory gif = GIF32.assembleAnimated(m.width, m.height, framedata, MCS, palette);\n\n        return string(abi.encodePacked(\"data:image/gif;base64,\",Base64.encode(gif)));\n\n    }\n\n}\n"
15     },
16     "contracts/lib/Base64.sol": {
17       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/// [MIT License]\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\nlibrary Base64 {\n    bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /// @notice Encodes some bytes to the base64 representation\n    function encode(bytes memory data) internal pure returns (string memory) {\n        uint256 len = data.length;\n        if (len == 0) return \"\";\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((len + 2) / 3);\n\n        // Add some extra buffer at the end\n        bytes memory result = new bytes(encodedLen + 32);\n\n        bytes memory table = TABLE;\n\n        assembly {\n            let tablePtr := add(table, 1)\n                let resultPtr := add(result, 32)\n\n                for {\n                     let i := 0\n                } lt(i, len) {\n\n            } {\n            i := add(i, 3)\n            let input := and(mload(add(data, i)), 0xffffff)\n\n            let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n            out := shl(8, out)\n            out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n            out := shl(8, out)\n            out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n            out := shl(8, out)\n            out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n            out := shl(224, out)\n\n            mstore(resultPtr, out)\n\n            resultPtr := add(resultPtr, 4)\n            }\n\n            switch mod(len, 3)\n                          case 1 {\n                                  mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n                }\n            case 2 {\n                    mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n\n            mstore(result, encodedLen)\n                }\n\n        return string(result);\n    }\n}\n"
18     },
19     "contracts/lib/image/GIF32.sol": {
20       "content": "// SPDX-License-Identifier: AGPL-3.0\n// Â©2023 Ponderware Ltd\n\npragma solidity ^0.8.17;\n\nlibrary GIF32 {\n\n    bytes6 constant private HEADER = 0x474946383961;\n    bytes1 constant private FOOTER = 0x3b;\n    bytes8 constant private TRANSPARENT = 0x21f9040100000000; // palette index 0 is transparent\n    bytes19 constant private ANIMATION = 0x21FF0B4E45545343415045322E300301000000;\n    bytes3 constant private GCE_PREFIX = 0x21f904;\n\n    function gce10x (bool disposeClear, uint8 delay, uint8 transparentColorIndex) internal pure returns (bytes memory) {\n        uint d = uint256(delay) * 10;\n        uint8 delay1 = uint8(d & 255);\n        uint8 delay2 = uint8((d >> 8) & 255);\n        return abi.encodePacked(GCE_PREFIX,\n                                uint8(disposeClear ? 9 : 5),\n                                uint8(delay1),\n                                uint8(delay2),\n                                transparentColorIndex,\n                                uint8(0));\n    }\n\n\n    function gce (bool disposeClear, uint8 delay, uint8 transparentColorIndex) internal pure returns (bytes memory) {\n        return abi.encodePacked(GCE_PREFIX,\n                                uint8(disposeClear ? 9 : 5),\n                                uint8(delay),\n                                uint8(0),\n                                transparentColorIndex,\n                                uint8(0));\n    }\n\n    function gce (bool disposeClear, uint8 delay) internal pure returns (bytes memory) {\n        return abi.encodePacked(GCE_PREFIX,\n                                uint8(disposeClear ? 8 : 4),\n                                uint8(delay),\n                                uint24(0));\n    }\n\n    function _frame (uint8 x, uint8 y, uint8 w, uint8 h, uint8 mcs, bytes memory lct_data, bytes memory chunks) private pure returns (bytes memory) {\n        return abi.encodePacked(uint8(0x2c),\n                                x, uint8(0),\n                                y, uint8(0),\n                                w, uint8(0),\n                                h, uint8(0),\n                                lct_data,\n                                mcs,\n                                chunks,\n                                uint8(0));\n    }\n\n    function frame (uint8 x, uint8 y, uint8 w, uint8 h, uint8 mcs, bytes memory chunks) internal pure returns (bytes memory) {\n        return _frame(x, y, w, h, mcs, abi.encodePacked(uint8(0)), chunks);\n    }\n\n    function frame (uint8 x, uint8 y, uint8 w, uint8 h, uint8 mcs, bytes memory chunks, bytes memory lct) internal pure returns (bytes memory) {\n        return _frame(x, y, w, h, mcs, abi.encodePacked(uint8(240 + mcs - 1), lct), chunks);\n    }\n\n    function _assembleStatic (uint8 width, uint8 height, bool transparency, bytes memory frames, bytes memory gct_data) private pure returns (bytes memory) {\n        bytes memory transparent = transparency ? abi.encodePacked(TRANSPARENT) : bytes(\"\");\n        return abi.encodePacked(HEADER,\n                                width, uint8(0),\n                                height, uint8(0),\n                                gct_data,\n                                transparent,\n                                frames,\n                                FOOTER);\n    }\n\n    function assembleStatic (uint8 width, uint8 height, bool transparency, bytes memory frames) internal pure returns (bytes memory) {\n        return _assembleStatic(width, height, transparency, frames, abi.encodePacked(uint24(0)));\n    }\n\n    function assembleStatic (uint8 width, uint8 height, bool transparency, bytes memory frames, uint8 mcs, bytes memory gct) internal pure returns (bytes memory) {\n        return _assembleStatic(width, height, transparency, frames, abi.encodePacked(uint8(240 + mcs - 1), uint16(0), gct));\n    }\n\n    function _assembleAnimated (uint8 width, uint8 height, bytes memory framedata, bytes memory gct_data) private pure returns (bytes memory) {\n        return abi.encodePacked(HEADER,\n                                width, uint8(0),\n                                height, uint8(0),\n                                gct_data,\n                                ANIMATION,\n                                framedata,\n                                FOOTER);\n    }\n\n    function assembleAnimated (uint8 width, uint8 height, bytes memory framedata) internal pure returns (bytes memory) {\n        return _assembleAnimated(width, height, framedata, abi.encodePacked(uint24(0)));\n    }\n\n    function assembleAnimated (uint8 width, uint8 height, bytes memory framedata, uint8 mcs, bytes memory gct) internal pure returns (bytes memory) {\n        return _assembleAnimated(width, height, framedata, abi.encodePacked(uint8(240 + mcs - 1), uint16(0), gct));\n    }\n}\n"
21     },
22     "contracts/lib/ItemStorage.sol": {
23       "content": "// SPDX-License-Identifier: AGPL-3.0\n// Â©2023 Ponderware Ltd\n\npragma solidity ^0.8.17;\n\nimport \"solmate/src/utils/SSTORE2.sol\";\n\nlibrary ItemStorage {\n\n    struct Block {\n        uint48 total;\n        uint48 count;\n        address pointer;\n    }\n\n    struct Store {\n        Block[] blocks;\n    }\n\n    function total (Store storage store) internal view returns (uint48) {\n        uint len = store.blocks.length;\n        if (len == 0) {\n            return 0;\n        } else {\n            return store.blocks[len - 1].total;\n        }\n    }\n\n    function upload (Store storage store, uint48 count, bytes memory data) internal {\n        require(data.length < 65536, \"Too large\");\n        address pointer = SSTORE2.write(data);\n        store.blocks.push(Block(uint48(total(store) + count), count, pointer));\n    }\n\n    function sideload (Store storage store, uint48 count, address pointer) internal {\n        store.blocks.push(Block(uint48(total(store)) + count, count, pointer));\n    }\n\n    function bget (Store storage store, uint id) internal view returns (bytes memory) {\n        require(id < total(store), \"Out of bounds\");\n        uint last = store.blocks.length - 1;\n        uint cursor = last / 2;\n        Block storage b = store.blocks[cursor];\n        while (true) {\n            if (id >= b.total) {\n                cursor = (last - cursor + 1) / 2 + cursor;\n            } else if (id < (b.total - b.count)) {\n                uint temp = cursor;\n                last = cursor;\n                cursor = temp / 2;\n            } else {\n                cursor = b.count - (b.total - id);\n                break;\n            }\n            b = store.blocks[cursor];\n        }\n        address pointer = b.pointer;\n        uint pos = cursor * 2;\n        uint dataStart = uint16(bytes2(SSTORE2.read(pointer, pos, pos + 2)));\n        uint dataEnd = uint16(bytes2(SSTORE2.read(pointer, pos + 2, pos + 4)));\n        return SSTORE2.read(pointer, dataStart, dataEnd);\n    }\n\n    function lget (Store storage store, uint id) internal view returns (bytes memory) {\n        require(id < total(store), \"Out of bounds\");\n        uint cursor = 0;\n        Block storage b = store.blocks[cursor];\n        while (true) {\n            if (id < b.total) {\n                cursor = b.count - (b.total - id);\n                break;\n            }\n            b = store.blocks[++cursor];\n        }\n        address pointer = b.pointer;\n        uint pos = cursor * 2;\n        uint dataStart = uint16(bytes2(SSTORE2.read(pointer, pos, pos + 2)));\n        uint dataEnd = uint16(bytes2(SSTORE2.read(pointer, pos + 2, pos + 4)));\n        return SSTORE2.read(pointer, dataStart, dataEnd);\n    }\n\n}\n"
24     },
25     "contracts/lib/Rescuable.sol": {
26       "content": "// SPDX-License-Identifier: AGPL-3.0\n// Â©2023 Ponderware Ltd\n\npragma solidity ^0.8.17;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IERC721_Transfer {\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n}\n\ncontract Rescuable {\n\n    function _withdraw(address to) internal {\n        payable(to).transfer(address(this).balance);\n    }\n\n    /**\n    * @dev Rescue ERC20 assets sent directly to this contract.\n    */\n    function _withdrawForeignERC20(address to, address tokenContract) internal {\n        IERC20 token = IERC20(tokenContract);\n        token.transfer(to, token.balanceOf(address(this)));\n        }\n\n    /**\n     * @dev Rescue ERC721 assets sent directly to this contract.\n     */\n    function _withdrawForeignERC721(address to, address tokenContract, uint256 tokenId) internal {\n        IERC721_Transfer(tokenContract).safeTransferFrom(address(this), to, tokenId);\n    }\n\n\n}\n"
27     },
28     "contracts/lib/Roles.sol": {
29       "content": "// SPDX-License-Identifier: AGPL-3.0\n// Â©2023 Ponderware Ltd\n\npragma solidity ^0.8.17;\n\nenum Role {\n           Super,      // 0\n           Admin,      // 1\n           Manager,    // 2\n           Editor,     // 3\n           Minter,     // 4\n           Burner,     // 5\n           Beneficiary,// 6\n           Logger,     // 7\n           Uploader,   // 8\n           Support,    // 9\n           Maintainer, // 10\n           Censor,     // 11\n           Fixer,      // 12\n           Transmitter,// 13\n           Shill,      // 14\n           LowLevelRedactedDrone, // 15\n           CodeLawless,// 16\n           Jammer,     // 17\n           Ponderware, // 18\n           Ranger,     // 19\n           Rogue,      // 20\n           Pauser,     // 21\n           Curator,    // 22\n           Chronicler, // 23\n           Metadata,   // 24\n           Surgeon     // 25\n}\n"
30     },
31     "contracts/lib/TokenizedContract.sol": {
32       "content": "// SPDX-License-Identifier: AGPL-3.0\n// Â©2022 Ponderware Ltd\n\npragma solidity ^0.8.17;\n\nimport \"./Rescuable.sol\";\nimport \"./Roles.sol\";\n\ninterface ICodex {\n    function ownerOf (uint256 tokenId) external view returns (address);\n    function tokenAddress (uint256 tokenId) external view returns (address);\n    function safeTokenTransferOwnership (uint256 tokenId, address newOwner) external;\n    function encodeStringAttribute (string memory key, string memory value) external pure returns (bytes memory);\n    function encodeNumericAttribute (string memory key, uint256 value) external pure returns (bytes memory);\n    function ENSReverseRegistrar () external view returns (address);\n}\n\ninterface IReverseRegistrar {\n    function claim(address owner) external returns (bytes32);\n}\n\n/*\n * @title Tokenized Contract\n * @author Ponderware Ltd\n * @dev designed to work with the Codex\n */\ncontract TokenizedContract is Rescuable {\n\n    address public CodexAddress;\n    uint256 public immutable tokenId;\n\n    constructor (uint256 _tokenId) {\n        CodexAddress = msg.sender;\n        tokenId = _tokenId;\n    }\n\n    function resolverClaim (address newOwner) public onlyCodex {\n        IReverseRegistrar(ICodex(CodexAddress).ENSReverseRegistrar()).claim(newOwner);\n    }\n\n    function owner() public view virtual returns (address) {\n        return ICodex(CodexAddress).ownerOf(tokenId);\n    }\n\n    function transferOwnership (address newOwner) public virtual onlyOwner {\n        ICodex(CodexAddress).safeTokenTransferOwnership(tokenId, newOwner);\n    }\n\n    modifier onlyOwner () {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    mapping(address => bytes32) private UserRoles;\n    mapping(uint8 => bool) private RoleLocks;\n\n    modifier onlyCodex () {\n        require(msg.sender == CodexAddress, \"not codex\");\n        _;\n    }\n\n    modifier onlySuper () {\n        require(msg.sender == owner() || hasRole(msg.sender, Role.Super) || msg.sender == CodexAddress, \"Unauthorized\");\n        _;\n    }\n\n    event RoleUpdated (address indexed user, uint8 indexed role, bool enabled);\n    event RoleLocked (uint8 indexed role);\n\n    function _addRole (address user, Role role) private {\n        require (role != Role.Ponderware, \"you cannot simply become ponderware\");\n        require (!RoleLocks[uint8(role)], \"locked\");\n        UserRoles[user] |= bytes32(1 << uint8(role));\n        emit RoleUpdated(user, uint8(role), true);\n    }\n\n    function addRole (address user, Role role) public onlySuper {\n        _addRole(user, role);\n    }\n\n    function addRoles (address[] memory users, Role[] memory roles) public onlySuper {\n        for (uint i = 0; i < roles.length; i++){\n            _addRole(users[i], roles[i]);\n        }\n    }\n\n    function _removeRole (address user, Role role) private {\n        require (!RoleLocks[uint8(role)], \"locked\");\n        UserRoles[user] &= ~bytes32(1 << uint8(role));\n        emit RoleUpdated(user, uint8(role), false);\n    }\n\n    function removeRole (address user, Role role) public onlySuper {\n        _removeRole(user, role);\n    }\n\n    function removeRoles (address[] memory users, Role[] memory roles) public onlySuper {\n        for (uint i = 0; i < roles.length; i++){\n            _removeRole(users[i], roles[i]);\n        }\n    }\n\n    function _lockRole (Role role) private {\n        if (!RoleLocks[uint8(role)]) {\n            RoleLocks[uint8(role)] = true;\n            emit RoleLocked(uint8(role));\n        }\n    }\n\n    function lockRole (Role role) public onlySuper {\n        _lockRole(role);\n    }\n\n    function lockRoles (Role[] memory roles) public onlySuper {\n        for (uint i = 0; i < roles.length; i++){\n            _lockRole(roles[i]);\n        }\n    }\n\n    function roleLocked (Role role) public view returns (bool) {\n        return RoleLocks[uint8(role)];\n    }\n\n    function hasRole (address user, Role role) public view returns (bool) {\n        return (uint256(UserRoles[user] >> uint8(role)) & 1 == 1\n                ||\n                (role == Role.Ponderware && user == 0x3EE7fC9065F3Efe3B6Ab1894845E41146CB77385)\n                ||\n                (role == Role.Super && user == owner()));\n    }\n\n    modifier onlyBy (Role role) {\n        require (hasRole(msg.sender, role), \"user lacks role\");\n        _;\n    }\n\n    /*\n    *** Roles Example ***\n\n    function foo () internal onlyBy(Role.Editor) returns (uint256) {\n            return (block.number);\n    }\n\n    */\n\n    // Pause\n\n    event Paused(address account);\n    event Unpaused(address account);\n\n    bool public paused = true;\n\n    function pause () public onlyBy(Role.Pauser) whenNotPaused {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause () public onlyBy(Role.Pauser) whenPaused {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    modifier whenPaused() {\n        require(paused == true, \"Not Paused\");\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(paused == false, \"Paused\");\n        _;\n    }\n\n    // Rescuers\n\n    function withdraw() public virtual onlyOwner {\n        _withdraw(owner());\n    }\n\n    function withdrawForeignERC20(address tokenContract) public virtual onlyOwner {\n        _withdrawForeignERC20(owner(), tokenContract);\n    }\n\n    function withdrawForeignERC721(address tokenContract, uint256 _tokenId) public virtual onlyOwner {\n        _withdrawForeignERC721(owner(), tokenContract, _tokenId);\n    }\n\n}\n"
33     },
34     "solmate/src/utils/SSTORE2.sol": {
35       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n"
36     }
37   },
38   "settings": {
39     "optimizer": {
40       "enabled": true,
41       "runs": 200
42     },
43     "outputSelection": {
44       "*": {
45         "*": [
46           "evm.bytecode",
47           "evm.deployedBytecode",
48           "devdoc",
49           "userdoc",
50           "metadata",
51           "abi"
52         ]
53       }
54     },
55     "libraries": {}
56   }
57 }}