1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "istanbul",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "enabled": true,
12       "runs": 2000
13     },
14     "remappings": [],
15     "outputSelection": {
16       "*": {
17         "*": [
18           "evm.bytecode",
19           "evm.deployedBytecode",
20           "abi"
21         ]
22       }
23     }
24   },
25   "sources": {
26     "@openzeppelin/contracts/introspection/IERC165.sol": {
27       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
28     },
29     "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
30       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"
31     },
32     "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
33       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n"
34     },
35     "src/solc_0.7/AssetGiveaway/AssetGiveaway.sol": {
36       "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"./ClaimERC1155.sol\";\nimport \"../common/BaseWithStorage/WithAdmin.sol\";\n\n/// @title AssetGiveaway contract\n/// @notice This contract manages ERC1155 claims\ncontract AssetGiveaway is WithAdmin, ClaimERC1155 {\n    bytes4 private constant ERC1155_RECEIVED = 0xf23a6e61;\n    bytes4 private constant ERC1155_BATCH_RECEIVED = 0xbc197c81;\n    uint256 internal immutable _expiryTime;\n    mapping(address => bool) public claimed;\n\n    constructor(\n        address asset,\n        address admin,\n        bytes32 merkleRoot,\n        address assetsHolder,\n        uint256 expiryTime\n    ) ClaimERC1155(IERC1155(asset), assetsHolder) {\n        _admin = admin;\n        _merkleRoot = merkleRoot;\n        _expiryTime = expiryTime;\n    }\n\n    /// @notice Function to set the merkle root hash for the asset data, if it is 0\n    /// @param merkleRoot The merkle root hash of the asset data\n    function setMerkleRoot(bytes32 merkleRoot) external onlyAdmin {\n        require(_merkleRoot == 0, \"MERKLE_ROOT_ALREADY_SET\");\n        _merkleRoot = merkleRoot;\n    }\n\n    /// @notice Function to permit the claiming of an asset to a reserved address\n    /// @param to The intended recipient (reserved address) of the ERC1155 tokens\n    /// @param assetIds The array of IDs of the asset tokens\n    /// @param assetValues The amounts of each token ID to transfer\n    /// @param proof The proof submitted for verification\n    /// @param salt The salt submitted for verification\n    function claimAssets(\n        address to,\n        uint256[] calldata assetIds,\n        uint256[] calldata assetValues,\n        bytes32[] calldata proof,\n        bytes32 salt\n    ) external {\n        require(block.timestamp < _expiryTime, \"CLAIM_PERIOD_IS_OVER\");\n        require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        require(claimed[to] == false, \"DESTINATION_ALREADY_CLAIMED\");\n        claimed[to] = true;\n        _claimERC1155(to, assetIds, assetValues, proof, salt);\n    }\n\n    function onERC1155Received(\n        address, /*operator*/\n        address, /*from*/\n        uint256, /*id*/\n        uint256, /*value*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return ERC1155_RECEIVED;\n    }\n\n    function onERC1155BatchReceived(\n        address, /*operator*/\n        address, /*from*/\n        uint256[] calldata, /*ids*/\n        uint256[] calldata, /*values*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return ERC1155_BATCH_RECEIVED;\n    }\n}\n"
37     },
38     "src/solc_0.7/AssetGiveaway/ClaimERC1155.sol": {
39       "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\ncontract ClaimERC1155 {\n    bytes32 internal _merkleRoot;\n    IERC1155 internal immutable _asset;\n    address internal immutable _assetsHolder;\n    event ClaimedAssets(address to, uint256[] assetIds, uint256[] assetValues);\n\n    constructor(IERC1155 asset, address assetsHolder) {\n        _asset = asset;\n        if (assetsHolder == address(0)) {\n            assetsHolder = address(this);\n        }\n        _assetsHolder = assetsHolder;\n    }\n\n    function _claimERC1155(\n        address to,\n        uint256[] calldata assetIds,\n        uint256[] calldata assetValues,\n        bytes32[] calldata proof,\n        bytes32 salt\n    ) internal {\n        _checkValidity(to, assetIds, assetValues, proof, salt);\n        _sendAssets(to, assetIds, assetValues);\n        emit ClaimedAssets(to, assetIds, assetValues);\n    }\n\n    function _checkValidity(\n        address to,\n        uint256[] memory assetIds,\n        uint256[] memory assetValues,\n        bytes32[] memory proof,\n        bytes32 salt\n    ) internal view {\n        require(assetIds.length == assetValues.length, \"INVALID_INPUT\");\n        bytes32 leaf = _generateClaimHash(to, assetIds, assetValues, salt);\n        require(_verify(proof, leaf), \"INVALID_CLAIM\");\n    }\n\n    function _generateClaimHash(\n        address to,\n        uint256[] memory assetIds,\n        uint256[] memory assetValues,\n        bytes32 salt\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(to, assetIds, assetValues, salt));\n    }\n\n    function _verify(bytes32[] memory proof, bytes32 leaf) internal view returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash < proofElement) {\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        return computedHash == _merkleRoot;\n    }\n\n    function _sendAssets(\n        address to,\n        uint256[] memory assetIds,\n        uint256[] memory assetValues\n    ) internal {\n        _asset.safeBatchTransferFrom(_assetsHolder, to, assetIds, assetValues, \"\");\n    }\n}\n"
40     },
41     "src/solc_0.7/common/BaseWithStorage/WithAdmin.sol": {
42       "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.7.5;\n\ncontract WithAdmin {\n    address internal _admin;\n\n    /// @dev Emits when the contract administrator is changed.\n    /// @param oldAdmin The address of the previous administrator.\n    /// @param newAdmin The address of the new administrator.\n    event AdminChanged(address oldAdmin, address newAdmin);\n\n    modifier onlyAdmin() {\n        require(msg.sender == _admin, \"ADMIN_ONLY\");\n        _;\n    }\n\n    /// @dev Get the current administrator of this contract.\n    /// @return The current administrator of this contract.\n    function getAdmin() external view returns (address) {\n        return _admin;\n    }\n\n    /// @dev Change the administrator to be `newAdmin`.\n    /// @param newAdmin The address of the new administrator.\n    function changeAdmin(address newAdmin) external {\n        require(msg.sender == _admin, \"ADMIN_ACCESS_DENIED\");\n        emit AdminChanged(_admin, newAdmin);\n        _admin = newAdmin;\n    }\n}\n"
43     }
44   }
45 }}