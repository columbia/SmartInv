1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "london",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "enabled": true,
12       "runs": 200
13     },
14     "remappings": [],
15     "outputSelection": {
16       "*": {
17         "*": [
18           "evm.bytecode",
19           "evm.deployedBytecode",
20           "devdoc",
21           "userdoc",
22           "metadata",
23           "abi"
24         ]
25       }
26     }
27   },
28   "sources": {
29     "contracts/messaging/connectors/Connector.sol": {
30       "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {ProposedOwnable} from \"../../shared/ProposedOwnable.sol\";\nimport {IConnector} from \"../interfaces/IConnector.sol\";\n\n/**\n * @title Connector\n * @author Connext Labs, Inc.\n * @notice This contract has the messaging interface functions used by all connectors.\n *\n * @dev This contract stores information about mirror connectors, but can be used as a\n * base for contracts that do not have a mirror (i.e. the connector handling messaging on\n * mainnet). In this case, the `mirrorConnector` and `MIRROR_DOMAIN`\n * will be empty\n *\n * @dev If ownership is renounced, this contract will be unable to update its `mirrorConnector`\n * or `mirrorGas`\n */\nabstract contract Connector is ProposedOwnable, IConnector {\n  // ========== Custom Errors ===========\n\n  error Connector__processMessage_notUsed();\n\n  // ============ Events ============\n\n  event NewConnector(\n    uint32 indexed domain,\n    uint32 indexed mirrorDomain,\n    address amb,\n    address rootManager,\n    address mirrorConnector\n  );\n\n  event MirrorConnectorUpdated(address previous, address current);\n\n  // ============ Public Storage ============\n\n  /**\n   * @notice The domain of this Messaging (i.e. Connector) contract.\n   */\n  uint32 public immutable DOMAIN;\n\n  /**\n   * @notice Address of the AMB on this domain.\n   */\n  address public immutable AMB;\n\n  /**\n   * @notice RootManager contract address.\n   */\n  address public immutable ROOT_MANAGER;\n\n  /**\n   * @notice The domain of the corresponding messaging (i.e. Connector) contract.\n   */\n  uint32 public immutable MIRROR_DOMAIN;\n\n  /**\n   * @notice Connector on L2 for L1 connectors, and vice versa.\n   */\n  address public mirrorConnector;\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Errors if the msg.sender is not the registered AMB\n   */\n  modifier onlyAMB() {\n    require(msg.sender == AMB, \"!AMB\");\n    _;\n  }\n\n  /**\n   * @notice Errors if the msg.sender is not the registered ROOT_MANAGER\n   */\n  modifier onlyRootManager() {\n    // NOTE: RootManager will be zero address for spoke connectors.\n    // Only root manager can dispatch a message to spokes/L2s via the hub connector.\n    require(msg.sender == ROOT_MANAGER, \"!rootManager\");\n    _;\n  }\n\n  // ============ Constructor ============\n\n  /**\n   * @notice Creates a new HubConnector instance\n   * @dev The connectors are deployed such that there is one on each side of an AMB (i.e.\n   * for optimism, there is one connector on optimism and one connector on mainnet)\n   * @param _domain The domain this connector lives on\n   * @param _mirrorDomain The spoke domain\n   * @param _amb The address of the amb on the domain this connector lives on\n   * @param _rootManager The address of the RootManager on mainnet\n   * @param _mirrorConnector The address of the spoke connector\n   */\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector\n  ) ProposedOwnable() {\n    // set the owner\n    _setOwner(msg.sender);\n\n    // sanity checks on values\n    require(_domain != 0, \"empty domain\");\n    require(_rootManager != address(0), \"empty rootManager\");\n    // see note at top of contract on why the mirror values are not sanity checked\n\n    // set immutables\n    DOMAIN = _domain;\n    AMB = _amb;\n    ROOT_MANAGER = _rootManager;\n    MIRROR_DOMAIN = _mirrorDomain;\n    // set mutables if defined\n    if (_mirrorConnector != address(0)) {\n      _setMirrorConnector(_mirrorConnector);\n    }\n\n    emit NewConnector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector);\n  }\n\n  // ============ Receivable ============\n  /**\n   * @notice Connectors may need to receive native asset to handle fees when sending a\n   * message\n   */\n  receive() external payable {}\n\n  // ============ Admin Functions ============\n\n  /**\n   * @notice Sets the address of the l2Connector for this domain\n   */\n  function setMirrorConnector(address _mirrorConnector) public onlyOwner {\n    _setMirrorConnector(_mirrorConnector);\n  }\n\n  // ============ Public Functions ============\n\n  /**\n   * @notice Processes a message received by an AMB\n   * @dev This is called by AMBs to process messages originating from mirror connector\n   */\n  function processMessage(bytes memory _data) external virtual onlyAMB {\n    _processMessage(_data);\n    emit MessageProcessed(_data, msg.sender);\n  }\n\n  /**\n   * @notice Checks the cross domain sender for a given address\n   */\n  function verifySender(address _expected) external returns (bool) {\n    return _verifySender(_expected);\n  }\n\n  // ============ Virtual Functions ============\n\n  /**\n   * @notice This function is used by the Connext contract on the l2 domain to send a message to the\n   * l1 domain (i.e. called by Connext on optimism to send a message to mainnet with roots)\n   * @param _data The contents of the message\n   * @param _encodedData Data used to send the message; specific to connector\n   */\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal virtual;\n\n  /**\n   * @notice This function is used by the AMBs to handle incoming messages. Should store the latest\n   * root generated on the l2 domain.\n   */\n  function _processMessage(\n    bytes memory /* _data */\n  ) internal virtual {\n    // By default, reverts. This is to ensure the call path is not used unless this function is\n    // overridden by the inheriting class\n    revert Connector__processMessage_notUsed();\n  }\n\n  /**\n   * @notice Verify that the msg.sender is the correct AMB contract, and that the message's origin sender\n   * is the expected address.\n   * @dev Should be overridden by the implementing Connector contract.\n   */\n  function _verifySender(address _expected) internal virtual returns (bool);\n\n  // ============ Private Functions ============\n\n  function _setMirrorConnector(address _mirrorConnector) internal virtual {\n    emit MirrorConnectorUpdated(mirrorConnector, _mirrorConnector);\n    mirrorConnector = _mirrorConnector;\n  }\n}\n"
31     },
32     "contracts/messaging/connectors/GasCap.sol": {
33       "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {ProposedOwnable} from \"../../shared/ProposedOwnable.sol\";\n\nabstract contract GasCap is ProposedOwnable {\n  // ============ Storage ============\n  /**\n   * @notice The gnosis amb requires destination gas to be specified on the origin.\n   * The gas used will be passed in by the relayer to allow for real-time estimates,\n   * but will be capped at the admin-set cap.\n   */\n  uint256 gasCap;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when admin updates the gas cap\n   * @param _previous The starting value\n   * @param _updated The final value\n   */\n  event GasCapUpdated(uint256 _previous, uint256 _updated);\n\n  // ============ Constructor ============\n  constructor(uint256 _gasCap) {\n    _setGasCap(_gasCap);\n  }\n\n  // ============ Admin Fns ============\n  function setGasCap(uint256 _gasCap) public onlyOwner {\n    _setGasCap(_gasCap);\n  }\n\n  // ============ Internal Fns ============\n\n  /**\n   * @notice Used (by admin) to update the gas cap\n   * @param _gasCap The new value\n   */\n  function _setGasCap(uint256 _gasCap) internal {\n    emit GasCapUpdated(gasCap, _gasCap);\n    gasCap = _gasCap;\n  }\n\n  /**\n   * @notice Used to get the gas to use. Will be the original value IFF it\n   * is less than the cap\n   * @param _gas The proposed gas value\n   */\n  function _getGas(uint256 _gas) internal view returns (uint256) {\n    if (_gas > gasCap) {\n      _gas = gasCap;\n    }\n    return _gas;\n  }\n}\n"
34     },
35     "contracts/messaging/connectors/HubConnector.sol": {
36       "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {Connector} from \"./Connector.sol\";\n\n/**\n * @title HubConnector\n * @author Connext Labs, Inc.\n * @notice This contract implements the messaging functions needed on the hub-side of a given AMB.\n * The HubConnector has a limited set of functionality compared to the SpokeConnector, namely that\n * it contains no logic to store or prove messages.\n *\n * @dev This contract should be deployed on the hub-side of an AMB (i.e. on L1), and contracts\n * which extend this should implement the virtual functions defined in the BaseConnector class\n */\nabstract contract HubConnector is Connector {\n  /**\n   * @notice Creates a new HubConnector instance\n   * @dev The connectors are deployed such that there is one on each side of an AMB (i.e.\n   * for optimism, there is one connector on optimism and one connector on mainnet)\n   * @param _domain The domain this connector lives on\n   * @param _mirrorDomain The spoke domain\n   * @param _amb The address of the amb on the domain this connector lives on\n   * @param _rootManager The address of the RootManager on mainnet\n   * @param _mirrorConnector The address of the spoke connector\n   */\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector\n  ) Connector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector) {}\n\n  // ============ Public fns ============\n  /**\n   * @notice Sends a message over the amb\n   * @dev This is called by the root manager *only* on mainnet to propagate the aggregate root\n   */\n  function sendMessage(bytes memory _data, bytes memory _encodedData) external payable onlyRootManager {\n    _sendMessage(_data, _encodedData);\n    emit MessageSent(_data, _encodedData, msg.sender);\n  }\n}\n"
37     },
38     "contracts/messaging/connectors/optimism/BaseOptimism.sol": {
39       "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {OptimismAmb} from \"../../interfaces/ambs/optimism/OptimismAmb.sol\";\n\nimport {GasCap} from \"../GasCap.sol\";\n\nabstract contract BaseOptimism is GasCap {\n  // ============ Constructor ============\n  constructor(uint256 _gasCap) GasCap(_gasCap) {}\n\n  // ============ Override Fns ============\n  function _verifySender(address _amb, address _expected) internal view returns (bool) {\n    require(msg.sender == _amb, \"!bridge\");\n    return OptimismAmb(_amb).xDomainMessageSender() == _expected;\n  }\n\n  /**\n   * @notice Using Optimism AMB, the gas is provided to `sendMessage` as an encoded uint\n   */\n  function _getGasFromEncoded(bytes memory _encodedData) internal view returns (uint256 _gas) {\n    // Should include gas info in specialized calldata\n    require(_encodedData.length == 32, \"!data length\");\n\n    // Get the gas, if it is more than the cap use the cap\n    _gas = _getGas(abi.decode(_encodedData, (uint256)));\n  }\n}\n"
40     },
41     "contracts/messaging/connectors/optimism/OptimismHubConnector.sol": {
42       "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IRootManager} from \"../../interfaces/IRootManager.sol\";\nimport {OptimismAmb} from \"../../interfaces/ambs/optimism/OptimismAmb.sol\";\nimport {IStateCommitmentChain, L2MessageInclusionProof} from \"../../interfaces/ambs/optimism/IStateCommitmentChain.sol\";\n\nimport {TypedMemView} from \"../../../shared/libraries/TypedMemView.sol\";\n\nimport {HubConnector} from \"../HubConnector.sol\";\nimport {Connector} from \"../Connector.sol\";\n\nimport {PredeployAddresses} from \"./lib/PredeployAddresses.sol\";\nimport {OVMCodec} from \"./lib/OVMCodec.sol\";\nimport {SecureMerkleTrie} from \"./lib/SecureMerkleTrie.sol\";\n\nimport {BaseOptimism} from \"./BaseOptimism.sol\";\n\ncontract OptimismHubConnector is HubConnector, BaseOptimism {\n  // ============ Libraries ============\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n\n  // ============ Storage ============\n  IStateCommitmentChain public immutable stateCommitmentChain;\n\n  // NOTE: This is needed because we need to track the roots we've\n  // already sent across chains. When sending an optimism message, we send calldata\n  // for Connector.processMessage. At any point these messages could be processed\n  // before the timeout using `processFromRoot` or after the timeout using `process`\n  // we track the roots sent here to ensure we process each root once\n  mapping(bytes32 => bool) public processed;\n\n  // ============ Constructor ============\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector,\n    address _stateCommitmentChain,\n    uint256 _gasCap\n  ) HubConnector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector) BaseOptimism(_gasCap) {\n    stateCommitmentChain = IStateCommitmentChain(_stateCommitmentChain);\n  }\n\n  // ============ Override Fns ============\n  function _verifySender(address _expected) internal view override returns (bool) {\n    return _verifySender(AMB, _expected);\n  }\n\n  /**\n   * @dev Sends `aggregateRoot` to messaging on l2\n   */\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\n    // Should always be dispatching the aggregate root\n    require(_data.length == 32, \"!length\");\n    // Get the calldata\n    bytes memory _calldata = abi.encodeWithSelector(Connector.processMessage.selector, _data);\n    // Dispatch message\n    OptimismAmb(AMB).sendMessage(mirrorConnector, _calldata, uint32(gasCap));\n  }\n\n  // DO NOT override _processMessage, should revert from `Connector` class. All messages must use the\n  // `processMessageFromRoot` flow.\n\n  /**\n   * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/9973c1da3211e094a180a8a96ba9f8bb1ab1b389/packages/contracts/contracts/L1/messaging/L1CrossDomainMessenger.sol#L165\n   */\n  function processMessageFromRoot(\n    address _target,\n    address _sender,\n    bytes memory _message,\n    uint256 _messageNonce,\n    L2MessageInclusionProof memory _proof\n  ) external {\n    // verify the sender is the l2 contract\n    require(_sender == mirrorConnector, \"!mirrorConnector\");\n\n    // verify the target is this contract\n    require(_target == address(this), \"!this\");\n\n    // Get the encoded data\n    bytes memory xDomainData = _encodeXDomainCalldata(_target, _sender, _message, _messageNonce);\n\n    require(_verifyXDomainMessage(xDomainData, _proof), \"!proof\");\n\n    // NOTE: optimism seems to pad the calldata sent in to include more than the expected\n    // 36 bytes, i.e. in this transaction:\n    // https://blockscout.com/optimism/goerli/tx/0x440fda036d28eb547394a8689af90c5342a00a8ca2ab5117f2b85f54d1416ddd/logs\n    // the corresponding _message is:\n    // 0x4ff746f60000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002027ae5ba08d7291c96c8cbddcc148bf48a6d68c7974b94356f53754ef6171d757\n    //\n    // this means the length check and byte parsing used in the `ArbitrumHubConnector` would\n    // not work here. Instead, take the back 32 bytes of the string\n\n    // NOTE: TypedMemView only loads 32-byte chunks onto stack, which is fine in this case\n    bytes29 _view = _message.ref(0);\n    bytes32 root = _view.index(_view.len() - 32, 32);\n\n    if (!processed[root]) {\n      // set root to processed\n      processed[root] = true;\n      // update the root on the root manager\n      IRootManager(ROOT_MANAGER).aggregate(MIRROR_DOMAIN, root);\n\n      emit MessageProcessed(abi.encode(root), msg.sender);\n    } // otherwise root was already sent to root manager\n  }\n\n  /**\n   * Verifies that the given message is valid.\n   * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/9973c1da3211e094a180a8a96ba9f8bb1ab1b389/packages/contracts/contracts/L1/messaging/L1CrossDomainMessenger.sol#L283-L288\n   * @param _xDomainCalldata Calldata to verify.\n   * @param _proof Inclusion proof for the message.\n   * @return Whether or not the provided message is valid.\n   */\n  function _verifyXDomainMessage(bytes memory _xDomainCalldata, L2MessageInclusionProof memory _proof)\n    internal\n    view\n    returns (bool)\n  {\n    return (_verifyStateRootProof(_proof) && _verifyStorageProof(_xDomainCalldata, _proof));\n  }\n\n  /**\n   * Verifies that the state root within an inclusion proof is valid.\n   * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/9973c1da3211e094a180a8a96ba9f8bb1ab1b389/packages/contracts/contracts/L1/messaging/L1CrossDomainMessenger.sol#L295-L311\n   * @param _proof Message inclusion proof.\n   * @return Whether or not the provided proof is valid.\n   */\n  function _verifyStateRootProof(L2MessageInclusionProof memory _proof) internal view returns (bool) {\n    return\n      stateCommitmentChain.verifyStateCommitment(_proof.stateRoot, _proof.stateRootBatchHeader, _proof.stateRootProof);\n  }\n\n  /**\n   * Verifies that the storage proof within an inclusion proof is valid.\n   * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/9973c1da3211e094a180a8a96ba9f8bb1ab1b389/packages/contracts/contracts/L1/messaging/L1CrossDomainMessenger.sol#L313-L357\n   * @param _xDomainCalldata Encoded message calldata.\n   * @param _proof Message inclusion proof.\n   * @return Whether or not the provided proof is valid.\n   */\n  function _verifyStorageProof(bytes memory _xDomainCalldata, L2MessageInclusionProof memory _proof)\n    internal\n    pure\n    returns (bool)\n  {\n    bytes32 storageKey = keccak256(\n      abi.encodePacked(\n        keccak256(abi.encodePacked(_xDomainCalldata, PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER)),\n        uint256(0)\n      )\n    );\n\n    (bool exists, bytes memory encodedMessagePassingAccount) = SecureMerkleTrie.get(\n      abi.encodePacked(PredeployAddresses.L2_TO_L1_MESSAGE_PASSER),\n      _proof.stateTrieWitness,\n      _proof.stateRoot\n    );\n\n    require(exists == true, \"Message passing predeploy has not been initialized or invalid proof provided.\");\n\n    OVMCodec.EVMAccount memory account = OVMCodec.decodeEVMAccount(encodedMessagePassingAccount);\n\n    return\n      SecureMerkleTrie.verifyInclusionProof(\n        abi.encodePacked(storageKey),\n        abi.encodePacked(uint8(1)),\n        _proof.storageTrieWitness,\n        account.storageRoot\n      );\n  }\n\n  /**\n   * Generates the correct cross domain calldata for a message.\n   * @dev taken from: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/libraries/bridge/Lib_CrossDomainUtils.sol\n   * @param _target Target contract address.\n   * @param _sender Message sender address.\n   * @param _message Message to send to the target.\n   * @param _messageNonce Nonce for the provided message.\n   * @return ABI encoded cross domain calldata.\n   */\n  function _encodeXDomainCalldata(\n    address _target,\n    address _sender,\n    bytes memory _message,\n    uint256 _messageNonce\n  ) internal pure returns (bytes memory) {\n    return\n      abi.encodeWithSignature(\"relayMessage(address,address,bytes,uint256)\", _target, _sender, _message, _messageNonce);\n  }\n}\n"
43     },
44     "contracts/messaging/connectors/optimism/lib/BytesUtils.sol": {
45       "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @title BytesUtils\n *\n * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/libraries/utils/Lib_BytesUtils.sol\n */\nlibrary BytesUtils {\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  function slice(\n    bytes memory _bytes,\n    uint256 _start,\n    uint256 _length\n  ) internal pure returns (bytes memory) {\n    require(_length + 31 >= _length, \"slice_overflow\");\n    require(_start + _length >= _start, \"slice_overflow\");\n    require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n    bytes memory tempBytes;\n\n    assembly {\n      switch iszero(_length)\n      case 0 {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n        tempBytes := mload(0x40)\n\n        // The first word of the slice result is potentially a partial\n        // word read from the original array. To read it, we calculate\n        // the length of that partial word and start copying that many\n        // bytes into the array. The first word we copy will start with\n        // data we don't care about, but the last `lengthmod` bytes will\n        // land at the beginning of the contents of the new array. When\n        // we're done copying, we overwrite the full first word with\n        // the actual length of the slice.\n        let lengthmod := and(_length, 31)\n\n        // The multiplication in the next line is necessary\n        // because when slicing multiples of 32 bytes (lengthmod == 0)\n        // the following copy loop was copying the origin's length\n        // and then ending prematurely not copying everything it should.\n        let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n        let end := add(mc, _length)\n\n        for {\n          // The multiplication in the next line has the same exact purpose\n          // as the one above.\n          let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n        } lt(mc, end) {\n          mc := add(mc, 0x20)\n          cc := add(cc, 0x20)\n        } {\n          mstore(mc, mload(cc))\n        }\n\n        mstore(tempBytes, _length)\n\n        //update free-memory pointer\n        //allocating the array padded to 32 bytes like the compiler does now\n        mstore(0x40, and(add(mc, 31), not(31)))\n      }\n      //if we want a zero-length slice let's just return a zero-length array\n      default {\n        tempBytes := mload(0x40)\n\n        //zero out the 32 bytes slice we are about to return\n        //we need to do it because Solidity does not garbage collect\n        mstore(tempBytes, 0)\n\n        mstore(0x40, add(tempBytes, 0x20))\n      }\n    }\n\n    return tempBytes;\n  }\n\n  function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\n    if (_start >= _bytes.length) {\n      return bytes(\"\");\n    }\n\n    return slice(_bytes, _start, _bytes.length - _start);\n  }\n\n  function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {\n    if (_bytes.length < 32) {\n      bytes32 ret;\n      assembly {\n        ret := mload(add(_bytes, 32))\n      }\n      return ret;\n    }\n\n    return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes\n  }\n\n  function toUint256(bytes memory _bytes) internal pure returns (uint256) {\n    return uint256(toBytes32(_bytes));\n  }\n\n  function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\n    bytes memory nibbles = new bytes(_bytes.length * 2);\n\n    uint256 len = _bytes.length;\n    for (uint256 i = 0; i < len; ) {\n      nibbles[i * 2] = _bytes[i] >> 4;\n      nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    return nibbles;\n  }\n\n  function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\n    bytes memory ret = new bytes(_bytes.length / 2);\n\n    uint256 len = ret.length;\n    for (uint256 i = 0; i < len; ) {\n      ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    return ret;\n  }\n\n  function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\n    return keccak256(_bytes) == keccak256(_other);\n  }\n}\n"
46     },
47     "contracts/messaging/connectors/optimism/lib/MerkleTrie.sol": {
48       "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/* Library Imports */\nimport {BytesUtils} from \"./BytesUtils.sol\";\nimport {RLPReader} from \"./RLPReader.sol\";\n\n/**\n * @title MerkleTrie\n *\n * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/libraries/trie/Lib_MerkleTrie.sol\n */\nlibrary MerkleTrie {\n  /*******************\n   * Data Structures *\n   *******************/\n\n  enum NodeType {\n    BranchNode,\n    ExtensionNode,\n    LeafNode\n  }\n\n  struct TrieNode {\n    bytes encoded;\n    RLPReader.RLPItem[] decoded;\n  }\n\n  /**********************\n   * Contract Constants *\n   **********************/\n\n  // TREE_RADIX determines the number of elements per branch node.\n  uint256 constant TREE_RADIX = 16;\n  // Branch nodes have TREE_RADIX elements plus an additional `value` slot.\n  uint256 constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\n  // Leaf nodes and extension nodes always have two elements, a `path` and a `value`.\n  uint256 constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\n\n  // Prefixes are prepended to the `path` within a leaf or extension node and\n  // allow us to differentiate between the two node types. `ODD` or `EVEN` is\n  // determined by the number of nibbles within the unprefixed `path`. If the\n  // number of nibbles if even, we need to insert an extra padding nibble so\n  // the resulting prefixed `path` has an even number of nibbles.\n  uint8 constant PREFIX_EXTENSION_EVEN = 0;\n  uint8 constant PREFIX_EXTENSION_ODD = 1;\n  uint8 constant PREFIX_LEAF_EVEN = 2;\n  uint8 constant PREFIX_LEAF_ODD = 3;\n\n  // Just a utility constant. RLP represents `NULL` as 0x80.\n  bytes1 constant RLP_NULL = bytes1(0x80);\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /**\n   * @notice Verifies a proof that a given key/value pair is present in the\n   * Merkle trie.\n   * @param _key Key of the node to search for, as a hex string.\n   * @param _value Value of the node to search for, as a hex string.\n   * @param _proof Merkle trie inclusion proof for the desired node. Unlike\n   * traditional Merkle trees, this proof is executed top-down and consists\n   * of a list of RLP-encoded nodes that make a path down to the target node.\n   * @param _root Known root of the Merkle trie. Used to verify that the\n   * included proof is correctly constructed.\n   * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\n   */\n  function verifyInclusionProof(\n    bytes memory _key,\n    bytes memory _value,\n    bytes memory _proof,\n    bytes32 _root\n  ) internal pure returns (bool _verified) {\n    (bool exists, bytes memory value) = get(_key, _proof, _root);\n\n    return (exists && BytesUtils.equal(_value, value));\n  }\n\n  /**\n   * @notice Retrieves the value associated with a given key.\n   * @param _key Key to search for, as hex bytes.\n   * @param _proof Merkle trie inclusion proof for the key.\n   * @param _root Known root of the Merkle trie.\n   * @return _exists Whether or not the key exists.\n   * @return _value Value of the key if it exists.\n   */\n  function get(\n    bytes memory _key,\n    bytes memory _proof,\n    bytes32 _root\n  ) internal pure returns (bool _exists, bytes memory _value) {\n    TrieNode[] memory proof = _parseProof(_proof);\n    (uint256 pathLength, bytes memory keyRemainder, bool isFinalNode) = _walkNodePath(proof, _key, _root);\n\n    bool exists = keyRemainder.length == 0;\n\n    require(exists || isFinalNode, \"Provided proof is invalid.\");\n\n    bytes memory value = exists ? _getNodeValue(proof[pathLength - 1]) : bytes(\"\");\n\n    return (exists, value);\n  }\n\n  /*********************\n   * Private Functions *\n   *********************/\n\n  /**\n   * @notice Walks through a proof using a provided key.\n   * @param _proof Inclusion proof to walk through.\n   * @param _key Key to use for the walk.\n   * @param _root Known root of the trie.\n   * @return _pathLength Length of the final path\n   * @return _keyRemainder Portion of the key remaining after the walk.\n   * @return _isFinalNode Whether or not we've hit a dead end.\n   */\n  function _walkNodePath(\n    TrieNode[] memory _proof,\n    bytes memory _key,\n    bytes32 _root\n  )\n    private\n    pure\n    returns (\n      uint256 _pathLength,\n      bytes memory _keyRemainder,\n      bool _isFinalNode\n    )\n  {\n    uint256 pathLength = 0;\n    bytes memory key = BytesUtils.toNibbles(_key);\n\n    bytes32 currentNodeID = _root;\n    uint256 currentKeyIndex = 0;\n    uint256 currentKeyIncrement = 0;\n    TrieNode memory currentNode;\n\n    // Proof is top-down, so we start at the first element (root).\n    uint256 len = _proof.length;\n    for (uint256 i = 0; i < len; ) {\n      currentNode = _proof[i];\n      currentKeyIndex += currentKeyIncrement;\n\n      // Keep track of the proof elements we actually need.\n      // It's expensive to resize arrays, so this simply reduces gas costs.\n      pathLength += 1;\n\n      if (currentKeyIndex == 0) {\n        // First proof element is always the root node.\n        require(keccak256(currentNode.encoded) == currentNodeID, \"Invalid root hash\");\n      } else if (currentNode.encoded.length > 32 - 1) {\n        // Nodes 32 bytes or larger are hashed inside branch nodes.\n        require(keccak256(currentNode.encoded) == currentNodeID, \"Invalid large internal hash\");\n      } else {\n        // Nodes smaller than 31 bytes aren't hashed.\n        require(BytesUtils.toBytes32(currentNode.encoded) == currentNodeID, \"Invalid internal node hash\");\n      }\n\n      // unreachable code if it's below the if statement under this\n      unchecked {\n        ++i;\n      }\n\n      if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\n        if (currentKeyIndex == key.length) {\n          // We've hit the end of the key\n          // meaning the value should be within this branch node.\n          break;\n        } else {\n          // We're not at the end of the key yet.\n          // Figure out what the next node ID should be and continue.\n          uint8 branchKey = uint8(key[currentKeyIndex]);\n          RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\n          currentNodeID = _getNodeID(nextNode);\n          currentKeyIncrement = 1;\n          continue;\n        }\n      } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\n        bytes memory path = _getNodePath(currentNode);\n        uint8 prefix = uint8(path[0]);\n        uint8 offset = 2 - (prefix % 2);\n        bytes memory pathRemainder = BytesUtils.slice(path, offset);\n        bytes memory keyRemainder = BytesUtils.slice(key, currentKeyIndex);\n        uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\n\n        if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\n          if (pathRemainder.length == sharedNibbleLength && keyRemainder.length == sharedNibbleLength) {\n            // The key within this leaf matches our key exactly.\n            // Increment the key index to reflect that we have no remainder.\n            currentKeyIndex += sharedNibbleLength;\n          }\n\n          // We've hit a leaf node, so our next node should be NULL.\n          currentNodeID = bytes32(RLP_NULL);\n          break;\n        } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\n          if (sharedNibbleLength != pathRemainder.length) {\n            // Our extension node is not identical to the remainder.\n            // We've hit the end of this path\n            // updates will need to modify this extension.\n            currentNodeID = bytes32(RLP_NULL);\n            break;\n          } else {\n            // Our extension shares some nibbles.\n            // Carry on to the next node.\n            currentNodeID = _getNodeID(currentNode.decoded[1]);\n            currentKeyIncrement = sharedNibbleLength;\n            continue;\n          }\n        } else {\n          revert(\"Received a node with an unknown prefix\");\n        }\n      } else {\n        revert(\"Received an unparseable node.\");\n      }\n    }\n\n    // If our node ID is NULL, then we're at a dead end.\n    bool isFinalNode = currentNodeID == bytes32(RLP_NULL);\n    return (pathLength, BytesUtils.slice(key, currentKeyIndex), isFinalNode);\n  }\n\n  /**\n   * @notice Parses an RLP-encoded proof into something more useful.\n   * @param _proof RLP-encoded proof to parse.\n   * @return _parsed Proof parsed into easily accessible structs.\n   */\n  function _parseProof(bytes memory _proof) private pure returns (TrieNode[] memory _parsed) {\n    RLPReader.RLPItem[] memory nodes = RLPReader.readList(_proof);\n    TrieNode[] memory proof = new TrieNode[](nodes.length);\n\n    uint256 len = nodes.length;\n    for (uint256 i = 0; i < len; ) {\n      bytes memory encoded = RLPReader.readBytes(nodes[i]);\n      proof[i] = TrieNode({encoded: encoded, decoded: RLPReader.readList(encoded)});\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    return proof;\n  }\n\n  /**\n   * @notice Picks out the ID for a node. Node ID is referred to as the\n   * \"hash\" within the specification, but nodes < 32 bytes are not actually\n   * hashed.\n   * @param _node Node to pull an ID for.\n   * @return _nodeID ID for the node, depending on the size of its contents.\n   */\n  function _getNodeID(RLPReader.RLPItem memory _node) private pure returns (bytes32 _nodeID) {\n    bytes memory nodeID;\n\n    if (_node.length < 32) {\n      // Nodes smaller than 32 bytes are RLP encoded.\n      nodeID = RLPReader.readRawBytes(_node);\n    } else {\n      // Nodes 32 bytes or larger are hashed.\n      nodeID = RLPReader.readBytes(_node);\n    }\n\n    return BytesUtils.toBytes32(nodeID);\n  }\n\n  /**\n   * @notice Gets the path for a leaf or extension node.\n   * @param _node Node to get a path for.\n   * @return _path Node path, converted to an array of nibbles.\n   */\n  function _getNodePath(TrieNode memory _node) private pure returns (bytes memory _path) {\n    return BytesUtils.toNibbles(RLPReader.readBytes(_node.decoded[0]));\n  }\n\n  /**\n   * @notice Gets the path for a node.\n   * @param _node Node to get a value for.\n   * @return _value Node value, as hex bytes.\n   */\n  function _getNodeValue(TrieNode memory _node) private pure returns (bytes memory _value) {\n    return RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);\n  }\n\n  /**\n   * @notice Utility; determines the number of nibbles shared between two\n   * nibble arrays.\n   * @param _a First nibble array.\n   * @param _b Second nibble array.\n   * @return _shared Number of shared nibbles.\n   */\n  function _getSharedNibbleLength(bytes memory _a, bytes memory _b) private pure returns (uint256 _shared) {\n    uint256 i = 0;\n    while (_a.length > i && _b.length > i && _a[i] == _b[i]) {\n      i++;\n    }\n    return i;\n  }\n}\n"
49     },
50     "contracts/messaging/connectors/optimism/lib/OVMCodec.sol": {
51       "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/* Library Imports */\nimport {RLPReader} from \"./RLPReader.sol\";\n\n/**\n * @title OVMCodec\n *\n * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/libraries/codec/Lib_OVMCodec.sol\n */\nlibrary OVMCodec {\n  /***********\n   * Structs *\n   ***********/\n\n  struct EVMAccount {\n    uint256 nonce;\n    uint256 balance;\n    bytes32 storageRoot;\n    bytes32 codeHash;\n  }\n\n  /**\n   * @notice Decodes an RLP-encoded account state into a useful struct.\n   * @param _encoded RLP-encoded account state.\n   * @return Account state struct.\n   */\n  function decodeEVMAccount(bytes memory _encoded) internal pure returns (EVMAccount memory) {\n    RLPReader.RLPItem[] memory accountState = RLPReader.readList(_encoded);\n\n    return\n      EVMAccount({\n        nonce: RLPReader.readUint256(accountState[0]),\n        balance: RLPReader.readUint256(accountState[1]),\n        storageRoot: RLPReader.readBytes32(accountState[2]),\n        codeHash: RLPReader.readBytes32(accountState[3])\n      });\n  }\n}\n"
52     },
53     "contracts/messaging/connectors/optimism/lib/PredeployAddresses.sol": {
54       "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @title PredeployAddresses\n *\n * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/libraries/constants/Lib_PredeployAddresses.sol\n */\nlibrary PredeployAddresses {\n  address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\n  address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\n  address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\n  address payable internal constant OVM_ETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);\n  address internal constant L2_CROSS_DOMAIN_MESSENGER = 0x4200000000000000000000000000000000000007;\n  address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\n  address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\n  address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\n  address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\n  address internal constant L2_STANDARD_TOKEN_FACTORY = 0x4200000000000000000000000000000000000012;\n  address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\n}\n"
55     },
56     "contracts/messaging/connectors/optimism/lib/RLPReader.sol": {
57       "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @title RLPReader\n * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/libraries/rlp/Lib_RLPReader.sol\n */\nlibrary RLPReader {\n  /*************\n   * Constants *\n   *************/\n\n  uint256 internal constant MAX_LIST_LENGTH = 32;\n\n  /*********\n   * Enums *\n   *********/\n\n  enum RLPItemType {\n    DATA_ITEM,\n    LIST_ITEM\n  }\n\n  /***********\n   * Structs *\n   ***********/\n\n  struct RLPItem {\n    uint256 length;\n    uint256 ptr;\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /**\n   * Converts bytes to a reference to memory position and length.\n   * @param _in Input bytes to convert.\n   * @return Output memory reference.\n   */\n  function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\n    uint256 ptr;\n    assembly {\n      ptr := add(_in, 32)\n    }\n\n    return RLPItem({length: _in.length, ptr: ptr});\n  }\n\n  /**\n   * Reads an RLP list value into a list of RLP items.\n   * @param _in RLP list value.\n   * @return Decoded RLP list items.\n   */\n  function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\n    (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\n\n    require(itemType == RLPItemType.LIST_ITEM, \"Invalid RLP list value.\");\n\n    // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\n    // writing to the length. Since we can't know the number of RLP items without looping over\n    // the entire input, we'd have to loop twice to accurately size this array. It's easier to\n    // simply set a reasonable maximum list length and decrease the size before we finish.\n    RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\n\n    uint256 itemCount = 0;\n    uint256 offset = listOffset;\n    while (offset < _in.length) {\n      require(itemCount < MAX_LIST_LENGTH, \"Provided RLP list exceeds max list length.\");\n\n      (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\n        RLPItem({length: _in.length - offset, ptr: _in.ptr + offset})\n      );\n\n      out[itemCount] = RLPItem({length: itemLength + itemOffset, ptr: _in.ptr + offset});\n\n      itemCount += 1;\n      offset += itemOffset + itemLength;\n    }\n\n    // Decrease the array size to match the actual item count.\n    assembly {\n      mstore(out, itemCount)\n    }\n\n    return out;\n  }\n\n  /**\n   * Reads an RLP list value into a list of RLP items.\n   * @param _in RLP list value.\n   * @return Decoded RLP list items.\n   */\n  function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\n    return readList(toRLPItem(_in));\n  }\n\n  /**\n   * Reads an RLP bytes value into bytes.\n   * @param _in RLP bytes value.\n   * @return Decoded bytes.\n   */\n  function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n    (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n    require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes value.\");\n\n    return _copy(_in.ptr, itemOffset, itemLength);\n  }\n\n  /**\n   * Reads an RLP bytes value into bytes.\n   * @param _in RLP bytes value.\n   * @return Decoded bytes.\n   */\n  function readBytes(bytes memory _in) internal pure returns (bytes memory) {\n    return readBytes(toRLPItem(_in));\n  }\n\n  /**\n   * Reads an RLP string value into a string.\n   * @param _in RLP string value.\n   * @return Decoded string.\n   */\n  function readString(RLPItem memory _in) internal pure returns (string memory) {\n    return string(readBytes(_in));\n  }\n\n  /**\n   * Reads an RLP string value into a string.\n   * @param _in RLP string value.\n   * @return Decoded string.\n   */\n  function readString(bytes memory _in) internal pure returns (string memory) {\n    return readString(toRLPItem(_in));\n  }\n\n  /**\n   * Reads an RLP bytes32 value into a bytes32.\n   * @param _in RLP bytes32 value.\n   * @return Decoded bytes32.\n   */\n  function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {\n    // instead of <= 33\n    require(_in.length < 33 + 1, \"Invalid RLP bytes32 value.\");\n\n    (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n    require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes32 value.\");\n\n    uint256 ptr = _in.ptr + itemOffset;\n    bytes32 out;\n    assembly {\n      out := mload(ptr)\n\n      // Shift the bytes over to match the item size.\n      if lt(itemLength, 32) {\n        out := div(out, exp(256, sub(32, itemLength)))\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Reads an RLP bytes32 value into a bytes32.\n   * @param _in RLP bytes32 value.\n   * @return Decoded bytes32.\n   */\n  function readBytes32(bytes memory _in) internal pure returns (bytes32) {\n    return readBytes32(toRLPItem(_in));\n  }\n\n  /**\n   * Reads an RLP uint256 value into a uint256.\n   * @param _in RLP uint256 value.\n   * @return Decoded uint256.\n   */\n  function readUint256(RLPItem memory _in) internal pure returns (uint256) {\n    return uint256(readBytes32(_in));\n  }\n\n  /**\n   * Reads an RLP uint256 value into a uint256.\n   * @param _in RLP uint256 value.\n   * @return Decoded uint256.\n   */\n  function readUint256(bytes memory _in) internal pure returns (uint256) {\n    return readUint256(toRLPItem(_in));\n  }\n\n  /**\n   * Reads an RLP bool value into a bool.\n   * @param _in RLP bool value.\n   * @return Decoded bool.\n   */\n  function readBool(RLPItem memory _in) internal pure returns (bool) {\n    require(_in.length == 1, \"Invalid RLP boolean value.\");\n\n    uint256 ptr = _in.ptr;\n    uint256 out;\n    assembly {\n      out := byte(0, mload(ptr))\n    }\n\n    require(out == 0 || out == 1, \"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\");\n\n    return out != 0;\n  }\n\n  /**\n   * Reads an RLP bool value into a bool.\n   * @param _in RLP bool value.\n   * @return Decoded bool.\n   */\n  function readBool(bytes memory _in) internal pure returns (bool) {\n    return readBool(toRLPItem(_in));\n  }\n\n  /**\n   * Reads an RLP address value into a address.\n   * @param _in RLP address value.\n   * @return Decoded address.\n   */\n  function readAddress(RLPItem memory _in) internal pure returns (address) {\n    if (_in.length == 1) {\n      return address(0);\n    }\n\n    require(_in.length == 21, \"Invalid RLP address value.\");\n\n    return address(uint160(readUint256(_in)));\n  }\n\n  /**\n   * Reads an RLP address value into a address.\n   * @param _in RLP address value.\n   * @return Decoded address.\n   */\n  function readAddress(bytes memory _in) internal pure returns (address) {\n    return readAddress(toRLPItem(_in));\n  }\n\n  /**\n   * Reads the raw bytes of an RLP item.\n   * @param _in RLP item to read.\n   * @return Raw RLP bytes.\n   */\n  function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n    return _copy(_in);\n  }\n\n  /*********************\n   * Private Functions *\n   *********************/\n\n  /**\n   * Decodes the length of an RLP item.\n   * @param _in RLP item to decode.\n   * @return Offset of the encoded data.\n   * @return Length of the encoded data.\n   * @return RLP item type (LIST_ITEM or DATA_ITEM).\n   */\n  function _decodeLength(RLPItem memory _in)\n    private\n    pure\n    returns (\n      uint256,\n      uint256,\n      RLPItemType\n    )\n  {\n    require(_in.length > 0, \"RLP item cannot be null.\");\n\n    uint256 ptr = _in.ptr;\n    uint256 prefix;\n    assembly {\n      prefix := byte(0, mload(ptr))\n    }\n\n    if (prefix < 0x7f + 1) {\n      // Single byte.\n\n      return (0, 1, RLPItemType.DATA_ITEM);\n    } else if (prefix < 0xb7 + 1) {\n      // Short string.\n\n      // slither-disable-next-line variable-scope\n      uint256 strLen = prefix - 0x80;\n\n      require(_in.length > strLen, \"Invalid RLP short string.\");\n\n      return (1, strLen, RLPItemType.DATA_ITEM);\n    } else if (prefix < 0xbf + 1) {\n      // Long string.\n      uint256 lenOfStrLen = prefix - 0xb7;\n\n      require(_in.length > lenOfStrLen, \"Invalid RLP long string length.\");\n\n      uint256 strLen;\n      assembly {\n        // Pick out the string length.\n        strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\n      }\n\n      require(_in.length > lenOfStrLen + strLen, \"Invalid RLP long string.\");\n\n      return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\n    } else if (prefix < 0xf7 + 1) {\n      // Short list.\n      // slither-disable-next-line variable-scope\n      uint256 listLen = prefix - 0xc0;\n\n      require(_in.length > listLen, \"Invalid RLP short list.\");\n\n      return (1, listLen, RLPItemType.LIST_ITEM);\n    } else {\n      // Long list.\n      uint256 lenOfListLen = prefix - 0xf7;\n\n      require(_in.length > lenOfListLen, \"Invalid RLP long list length.\");\n\n      uint256 listLen;\n      assembly {\n        // Pick out the list length.\n        listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\n      }\n\n      require(_in.length > lenOfListLen + listLen, \"Invalid RLP long list.\");\n\n      return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\n    }\n  }\n\n  /**\n   * Copies the bytes from a memory location.\n   * @param _src Pointer to the location to read from.\n   * @param _offset Offset to start reading from.\n   * @param _length Number of bytes to read.\n   * @return Copied bytes.\n   */\n  function _copy(\n    uint256 _src,\n    uint256 _offset,\n    uint256 _length\n  ) private pure returns (bytes memory) {\n    bytes memory out = new bytes(_length);\n    if (out.length == 0) {\n      return out;\n    }\n\n    uint256 src = _src + _offset;\n    uint256 dest;\n    assembly {\n      dest := add(out, 32)\n    }\n\n    // Copy over as many complete words as we can.\n    for (uint256 i = 0; i < _length / 32; ) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n\n      src += 32;\n      dest += 32;\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    // Pick out the remaining bytes.\n    uint256 mask;\n    unchecked {\n      mask = 256**(32 - (_length % 32)) - 1;\n    }\n\n    assembly {\n      mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\n    }\n    return out;\n  }\n\n  /**\n   * Copies an RLP item into bytes.\n   * @param _in RLP item to copy.\n   * @return Copied bytes.\n   */\n  function _copy(RLPItem memory _in) private pure returns (bytes memory) {\n    return _copy(_in.ptr, 0, _in.length);\n  }\n}\n"
58     },
59     "contracts/messaging/connectors/optimism/lib/SecureMerkleTrie.sol": {
60       "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/* Library Imports */\nimport {MerkleTrie} from \"./MerkleTrie.sol\";\n\n/**\n * @title SecureMerkleTrie\n *\n * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/libraries/trie/Lib_SecureMerkleTrie.sol\n */\nlibrary SecureMerkleTrie {\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /**\n   * @notice Verifies a proof that a given key/value pair is present in the\n   * Merkle trie.\n   * @param _key Key of the node to search for, as a hex string.\n   * @param _value Value of the node to search for, as a hex string.\n   * @param _proof Merkle trie inclusion proof for the desired node. Unlike\n   * traditional Merkle trees, this proof is executed top-down and consists\n   * of a list of RLP-encoded nodes that make a path down to the target node.\n   * @param _root Known root of the Merkle trie. Used to verify that the\n   * included proof is correctly constructed.\n   * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\n   */\n  function verifyInclusionProof(\n    bytes memory _key,\n    bytes memory _value,\n    bytes memory _proof,\n    bytes32 _root\n  ) internal pure returns (bool _verified) {\n    bytes memory key = _getSecureKey(_key);\n    return MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\n  }\n\n  /**\n   * @notice Retrieves the value associated with a given key.\n   * @param _key Key to search for, as hex bytes.\n   * @param _proof Merkle trie inclusion proof for the key.\n   * @param _root Known root of the Merkle trie.\n   * @return _exists Whether or not the key exists.\n   * @return _value Value of the key if it exists.\n   */\n  function get(\n    bytes memory _key,\n    bytes memory _proof,\n    bytes32 _root\n  ) internal pure returns (bool _exists, bytes memory _value) {\n    bytes memory key = _getSecureKey(_key);\n    return MerkleTrie.get(key, _proof, _root);\n  }\n\n  /*********************\n   * Private Functions *\n   *********************/\n\n  /**\n   * Computes the secure counterpart to a key.\n   * @param _key Key to get a secure key from.\n   * @return _secureKey Secure version of the key.\n   */\n  function _getSecureKey(bytes memory _key) private pure returns (bytes memory _secureKey) {\n    return abi.encodePacked(keccak256(_key));\n  }\n}\n"
61     },
62     "contracts/messaging/interfaces/IConnector.sol": {
63       "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IProposedOwnable} from \"../../shared/interfaces/IProposedOwnable.sol\";\n\n/**\n * @notice This interface is what the Connext contract will send and receive messages through.\n * The messaging layer should conform to this interface, and should be interchangeable (i.e.\n * could be Nomad or a generic AMB under the hood).\n *\n * @dev This uses the nomad format to ensure nomad can be added in as it comes back online.\n *\n * Flow from transfer from polygon to optimism:\n * 1. User calls `xcall` with destination specified\n * 2. This will swap in to the bridge assets\n * 3. The swapped assets will get burned\n * 4. The Connext contract will call `dispatch` on the messaging contract to add the transfer\n *    to the root\n * 5. [At some time interval] Relayers call `send` to send the current root from polygon to\n *    mainnet. This is done on all \"spoke\" domains.\n * 6. [At some time interval] Relayers call `propagate` [better name] on mainnet, this generates a new merkle\n *    root from all of the AMBs\n *    - This function must be able to read root data from all AMBs and aggregate them into a single merkle\n *      tree root\n *    - Will send the mixed root from all chains back through the respective AMBs to all other chains\n * 7. AMB will call `update` to update the latest root on the messaging contract on spoke domains\n * 8. [At any point] Relayers can call `proveAndProcess` to prove inclusion of dispatched message, and call\n *    process on the `Connext` contract\n * 9. Takes minted bridge tokens and credits the LP\n *\n * AMB requirements:\n * - Access `msg.sender` both from mainnet -> spoke and vice versa\n * - Ability to read *our root* from the AMB\n *\n * AMBs:\n * - PoS bridge from polygon\n * - arbitrum bridge\n * - optimism bridge\n * - gnosis chain\n * - bsc (use multichain for messaging)\n */\ninterface IConnector is IProposedOwnable {\n  // ============ Events ============\n  /**\n   * @notice Emitted whenever a message is successfully sent over an AMB\n   * @param data The contents of the message\n   * @param encodedData Data used to send the message; specific to connector\n   * @param caller Who called the function (sent the message)\n   */\n  event MessageSent(bytes data, bytes encodedData, address caller);\n\n  /**\n   * @notice Emitted whenever a message is successfully received over an AMB\n   * @param data The contents of the message\n   * @param caller Who called the function\n   */\n  event MessageProcessed(bytes data, address caller);\n\n  // ============ Public fns ============\n\n  function processMessage(bytes memory _data) external;\n\n  function verifySender(address _expected) external returns (bool);\n}\n"
64     },
65     "contracts/messaging/interfaces/IRootManager.sol": {
66       "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\ninterface IRootManager {\n  /**\n   * @notice This is called by relayers to generate + send the mixed root from mainnet via AMB to\n   * spoke domains.\n   * @dev This must read information for the root from the registered AMBs.\n   */\n  function propagate(\n    address[] calldata _connectors,\n    uint256[] calldata _fees,\n    bytes[] memory _encodedData\n  ) external payable;\n\n  /**\n   * @notice Called by the connectors for various domains on the hub to aggregate their latest\n   * inbound root.\n   * @dev This must read information for the root from the registered AMBs\n   */\n  function aggregate(uint32 _domain, bytes32 _outbound) external;\n}\n"
67     },
68     "contracts/messaging/interfaces/ambs/optimism/IStateCommitmentChain.sol": {
69       "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n// modified from: https://github.com/ethereum-optimism/optimism/blob/fcfcf6e7e69801e63904ec53815db01a8d45dcac/packages/contracts/contracts/libraries/codec/Lib_OVMCodec.sol#L34-L40\nstruct ChainBatchHeader {\n  uint256 batchIndex;\n  bytes32 batchRoot;\n  uint256 batchSize;\n  uint256 prevTotalElements;\n  bytes extraData;\n}\n\n// modified from: https://github.com/ethereum-optimism/optimism/blob/fcfcf6e7e69801e63904ec53815db01a8d45dcac/packages/contracts/contracts/libraries/codec/Lib_OVMCodec.sol#L42-L45\nstruct ChainInclusionProof {\n  uint256 index;\n  bytes32[] siblings;\n}\n\n// modified from: https://github.com/ethereum-optimism/optimism/blob/fcfcf6e7e69801e63904ec53815db01a8d45dcac/packages/contracts/contracts/L1/messaging/IL1CrossDomainMessenger.sol#L18-L24\nstruct L2MessageInclusionProof {\n  bytes32 stateRoot;\n  ChainBatchHeader stateRootBatchHeader;\n  ChainInclusionProof stateRootProof;\n  bytes stateTrieWitness;\n  bytes storageTrieWitness;\n}\n\n/**\n * @title IStateCommitmentChain\n *\n * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/L1/rollup/IStateCommitmentChain.sol\n */\ninterface IStateCommitmentChain {\n  /**********\n   * Events *\n   **********/\n\n  event StateBatchAppended(\n    uint256 indexed _batchIndex,\n    bytes32 _batchRoot,\n    uint256 _batchSize,\n    uint256 _prevTotalElements,\n    bytes _extraData\n  );\n\n  event StateBatchDeleted(uint256 indexed _batchIndex, bytes32 _batchRoot);\n\n  /********************\n   * Public Functions *\n   ********************/\n\n  /**\n   * Retrieves the total number of elements submitted.\n   * @return _totalElements Total submitted elements.\n   */\n  function getTotalElements() external view returns (uint256 _totalElements);\n\n  /**\n   * Retrieves the total number of batches submitted.\n   * @return _totalBatches Total submitted batches.\n   */\n  function getTotalBatches() external view returns (uint256 _totalBatches);\n\n  /**\n   * Retrieves the timestamp of the last batch submitted by the sequencer.\n   * @return _lastSequencerTimestamp Last sequencer batch timestamp.\n   */\n  function getLastSequencerTimestamp() external view returns (uint256 _lastSequencerTimestamp);\n\n  /**\n   * Appends a batch of state roots to the chain.\n   * @param _batch Batch of state roots.\n   * @param _shouldStartAtElement Index of the element at which this batch should start.\n   */\n  function appendStateBatch(bytes32[] calldata _batch, uint256 _shouldStartAtElement) external;\n\n  /**\n   * Deletes all state roots after (and including) a given batch.\n   * @param _batchHeader Header of the batch to start deleting from.\n   */\n  function deleteStateBatch(ChainBatchHeader memory _batchHeader) external;\n\n  /**\n   * Verifies a batch inclusion proof.\n   * @param _element Hash of the element to verify a proof for.\n   * @param _batchHeader Header of the batch in which the element was included.\n   * @param _proof Merkle inclusion proof for the element.\n   */\n  function verifyStateCommitment(\n    bytes32 _element,\n    ChainBatchHeader memory _batchHeader,\n    ChainInclusionProof memory _proof\n  ) external view returns (bool _verified);\n\n  /**\n   * Checks whether a given batch is still inside its fraud proof window.\n   * @param _batchHeader Header of the batch to check.\n   * @return _inside Whether or not the batch is inside the fraud proof window.\n   */\n  function insideFraudProofWindow(ChainBatchHeader memory _batchHeader) external view returns (bool _inside);\n}\n"
70     },
71     "contracts/messaging/interfaces/ambs/optimism/OptimismAmb.sol": {
72       "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @dev The optimism bridge shares both of these functions, but it is important\n * to note that when going from L2 -> L1, the message cannot be processed by the\n * AMB until the challenge period elapses.\n *\n * HOWEVER, before the challenge elapses, you can read the state of the L2 as it is\n * placed on mainnet. By processing data from the L2 state, we are able to \"circumvent\"\n * this delay to a reasonable degree.\n *\n * This means that for messages going L1 -> L2, you can call \"processMessage\" and expect\n * the call to be executed to pass up the aggregate root. When going from L2 -> L1, you\n * must read the root from the L2 state\n *\n * L2 messenger: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/L2/messaging/L2CrossDomainMessenger.sol\n * L1 messenger: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/L1/messaging/L1CrossDomainMessenger.sol\n */\ninterface OptimismAmb {\n  function sendMessage(\n    address _target,\n    bytes memory _message,\n    uint32 _gasLimit\n  ) external;\n\n  function xDomainMessageSender() external view returns (address);\n}\n"
73     },
74     "contracts/shared/ProposedOwnable.sol": {
75       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {IProposedOwnable} from \"./interfaces/IProposedOwnable.sol\";\n\n/**\n * @title ProposedOwnable\n * @notice Contract module which provides a basic access control mechanism,\n * where there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed via a two step process:\n * 1. Call `proposeOwner`\n * 2. Wait out the delay period\n * 3. Call `acceptOwner`\n *\n * @dev This module is used through inheritance. It will make available the\n * modifier `onlyOwner`, which can be applied to your functions to restrict\n * their use to the owner.\n *\n * @dev The majority of this code was taken from the openzeppelin Ownable\n * contract\n *\n */\nabstract contract ProposedOwnable is IProposedOwnable {\n  // ========== Custom Errors ===========\n\n  error ProposedOwnable__onlyOwner_notOwner();\n  error ProposedOwnable__onlyProposed_notProposedOwner();\n  error ProposedOwnable__ownershipDelayElapsed_delayNotElapsed();\n  error ProposedOwnable__proposeNewOwner_invalidProposal();\n  error ProposedOwnable__proposeNewOwner_noOwnershipChange();\n  error ProposedOwnable__renounceOwnership_noProposal();\n  error ProposedOwnable__renounceOwnership_invalidProposal();\n\n  // ============ Properties ============\n\n  address private _owner;\n\n  address private _proposed;\n  uint256 private _proposedOwnershipTimestamp;\n\n  uint256 private constant _delay = 7 days;\n\n  // ======== Getters =========\n\n  /**\n   * @notice Returns the address of the current owner.\n   */\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @notice Returns the address of the proposed owner.\n   */\n  function proposed() public view virtual returns (address) {\n    return _proposed;\n  }\n\n  /**\n   * @notice Returns the address of the proposed owner.\n   */\n  function proposedTimestamp() public view virtual returns (uint256) {\n    return _proposedOwnershipTimestamp;\n  }\n\n  /**\n   * @notice Returns the delay period before a new owner can be accepted.\n   */\n  function delay() public view virtual returns (uint256) {\n    return _delay;\n  }\n\n  /**\n   * @notice Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    if (_owner != msg.sender) revert ProposedOwnable__onlyOwner_notOwner();\n    _;\n  }\n\n  /**\n   * @notice Throws if called by any account other than the proposed owner.\n   */\n  modifier onlyProposed() {\n    if (_proposed != msg.sender) revert ProposedOwnable__onlyProposed_notProposedOwner();\n    _;\n  }\n\n  /**\n   * @notice Throws if the ownership delay has not elapsed\n   */\n  modifier ownershipDelayElapsed() {\n    // Ensure delay has elapsed\n    if ((block.timestamp - _proposedOwnershipTimestamp) <= _delay)\n      revert ProposedOwnable__ownershipDelayElapsed_delayNotElapsed();\n    _;\n  }\n\n  /**\n   * @notice Indicates if the ownership has been renounced() by\n   * checking if current owner is address(0)\n   */\n  function renounced() public view returns (bool) {\n    return _owner == address(0);\n  }\n\n  // ======== External =========\n\n  /**\n   * @notice Sets the timestamp for an owner to be proposed, and sets the\n   * newly proposed owner as step 1 in a 2-step process\n   */\n  function proposeNewOwner(address newlyProposed) public virtual onlyOwner {\n    // Contract as source of truth\n    if (_proposed == newlyProposed && _proposedOwnershipTimestamp != 0)\n      revert ProposedOwnable__proposeNewOwner_invalidProposal();\n\n    // Sanity check: reasonable proposal\n    if (_owner == newlyProposed) revert ProposedOwnable__proposeNewOwner_noOwnershipChange();\n\n    _setProposed(newlyProposed);\n  }\n\n  /**\n   * @notice Renounces ownership of the contract after a delay\n   */\n  function renounceOwnership() public virtual onlyOwner ownershipDelayElapsed {\n    // Ensure there has been a proposal cycle started\n    if (_proposedOwnershipTimestamp == 0) revert ProposedOwnable__renounceOwnership_noProposal();\n\n    // Require proposed is set to 0\n    if (_proposed != address(0)) revert ProposedOwnable__renounceOwnership_invalidProposal();\n\n    // Emit event, set new owner, reset timestamp\n    _setOwner(address(0));\n  }\n\n  /**\n   * @notice Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function acceptProposedOwner() public virtual onlyProposed ownershipDelayElapsed {\n    // NOTE: no need to check if _owner == _proposed, because the _proposed\n    // is 0-d out and this check is implicitly enforced by modifier\n\n    // NOTE: no need to check if _proposedOwnershipTimestamp > 0 because\n    // the only time this would happen is if the _proposed was never\n    // set (will fail from modifier) or if the owner == _proposed (checked\n    // above)\n\n    // Emit event, set new owner, reset timestamp\n    _setOwner(_proposed);\n  }\n\n  // ======== Internal =========\n\n  function _setOwner(address newOwner) internal {\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n    delete _proposedOwnershipTimestamp;\n    delete _proposed;\n  }\n\n  function _setProposed(address newlyProposed) private {\n    _proposedOwnershipTimestamp = block.timestamp;\n    _proposed = newlyProposed;\n    emit OwnershipProposed(newlyProposed);\n  }\n}\n"
76     },
77     "contracts/shared/interfaces/IProposedOwnable.sol": {
78       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @title IProposedOwnable\n * @notice Defines a minimal interface for ownership with a two step proposal and acceptance\n * process\n */\ninterface IProposedOwnable {\n  /**\n   * @dev This emits when change in ownership of a contract is proposed.\n   */\n  event OwnershipProposed(address indexed proposedOwner);\n\n  /**\n   * @dev This emits when ownership of a contract changes.\n   */\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @notice Get the address of the owner\n   * @return owner_ The address of the owner.\n   */\n  function owner() external view returns (address owner_);\n\n  /**\n   * @notice Get the address of the proposed owner\n   * @return proposed_ The address of the proposed.\n   */\n  function proposed() external view returns (address proposed_);\n\n  /**\n   * @notice Set the address of the proposed owner of the contract\n   * @param newlyProposed The proposed new owner of the contract\n   */\n  function proposeNewOwner(address newlyProposed) external;\n\n  /**\n   * @notice Set the address of the proposed owner of the contract\n   */\n  function acceptProposedOwner() external;\n}\n"
79     },
80     "contracts/shared/libraries/TypedMemView.sol": {
81       "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n  // Why does this exist?\n  // the solidity `bytes memory` type has a few weaknesses.\n  // 1. You can't index ranges effectively\n  // 2. You can't slice without copying\n  // 3. The underlying data may represent any type\n  // 4. Solidity never deallocates memory, and memory costs grow\n  //    superlinearly\n\n  // By using a memory view instead of a `bytes memory` we get the following\n  // advantages:\n  // 1. Slices are done on the stack, by manipulating the pointer\n  // 2. We can index arbitrary ranges and quickly convert them to stack types\n  // 3. We can insert type info into the pointer, and typecheck at runtime\n\n  // This makes `TypedMemView` a useful tool for efficient zero-copy\n  // algorithms.\n\n  // Why bytes29?\n  // We want to avoid confusion between views, digests, and other common\n  // types so we chose a large and uncommonly used odd number of bytes\n  //\n  // Note that while bytes are left-aligned in a word, integers and addresses\n  // are right-aligned. This means when working in assembly we have to\n  // account for the 3 unused bytes on the righthand side\n  //\n  // First 5 bytes are a type flag.\n  // - ff_ffff_fffe is reserved for unknown type.\n  // - ff_ffff_ffff is reserved for invalid types/errors.\n  // next 12 are memory address\n  // next 12 are len\n  // bottom 3 bytes are empty\n\n  // Assumptions:\n  // - non-modification of memory.\n  // - No Solidity updates\n  // - - wrt free mem point\n  // - - wrt bytes representation in memory\n  // - - wrt memory addressing in general\n\n  // Usage:\n  // - create type constants\n  // - use `assertType` for runtime type assertions\n  // - - unfortunately we can't do this at compile time yet :(\n  // - recommended: implement modifiers that perform type checking\n  // - - e.g.\n  // - - `uint40 constant MY_TYPE = 3;`\n  // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n  // - instantiate a typed view from a bytearray using `ref`\n  // - use `index` to inspect the contents of the view\n  // - use `slice` to create smaller views into the same memory\n  // - - `slice` can increase the offset\n  // - - `slice can decrease the length`\n  // - - must specify the output type of `slice`\n  // - - `slice` will return a null view if you try to overrun\n  // - - make sure to explicitly check for this with `notNull` or `assertType`\n  // - use `equal` for typed comparisons.\n\n  // The null view\n  bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n  uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n  uint256 constant TWENTY_SEVEN_BYTES = 8 * 27;\n  uint256 private constant _27_BYTES_IN_BITS = 8 * 27; // <--- also used this named constant where ever 216 is used.\n  uint256 private constant LOW_27_BYTES_MASK = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff; // (1 << _27_BYTES_IN_BITS) - 1;\n\n  // ========== Custom Errors ===========\n\n  error TypedMemView__assertType_typeAssertionFailed(uint256 actual, uint256 expected);\n  error TypedMemView__index_overrun(uint256 loc, uint256 len, uint256 index, uint256 slice);\n  error TypedMemView__index_indexMoreThan32Bytes();\n  error TypedMemView__unsafeCopyTo_nullPointer();\n  error TypedMemView__unsafeCopyTo_invalidPointer();\n  error TypedMemView__unsafeCopyTo_identityOOG();\n  error TypedMemView__assertValid_validityAssertionFailed();\n\n  /**\n   * @notice          Changes the endianness of a uint256.\n   * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n   * @param _b        The unsigned integer to reverse\n   * @return          v - The reversed value\n   */\n  function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n    v = _b;\n\n    // swap bytes\n    v =\n      ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n      ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n    // swap 2-byte long pairs\n    v =\n      ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n      ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n    // swap 4-byte long pairs\n    v =\n      ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n      ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n    // swap 8-byte long pairs\n    v =\n      ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n      ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n    // swap 16-byte long pairs\n    v = (v >> 128) | (v << 128);\n  }\n\n  /**\n   * @notice      Create a mask with the highest `_len` bits set.\n   * @param _len  The length\n   * @return      mask - The mask\n   */\n  function leftMask(uint8 _len) private pure returns (uint256 mask) {\n    // ugly. redo without assembly?\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      mask := sar(sub(_len, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n    }\n  }\n\n  /**\n   * @notice      Return the null view.\n   * @return      bytes29 - The null view\n   */\n  function nullView() internal pure returns (bytes29) {\n    return NULL;\n  }\n\n  /**\n   * @notice      Check if the view is null.\n   * @return      bool - True if the view is null\n   */\n  function isNull(bytes29 memView) internal pure returns (bool) {\n    return memView == NULL;\n  }\n\n  /**\n   * @notice      Check if the view is not null.\n   * @return      bool - True if the view is not null\n   */\n  function notNull(bytes29 memView) internal pure returns (bool) {\n    return !isNull(memView);\n  }\n\n  /**\n   * @notice          Check if the view is of a invalid type and points to a valid location\n   *                  in memory.\n   * @dev             We perform this check by examining solidity's unallocated memory\n   *                  pointer and ensuring that the view's upper bound is less than that.\n   * @param memView   The view\n   * @return          ret - True if the view is invalid\n   */\n  function isNotValid(bytes29 memView) internal pure returns (bool ret) {\n    if (typeOf(memView) == 0xffffffffff) {\n      return true;\n    }\n    uint256 _end = end(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ret := gt(_end, mload(0x40))\n    }\n  }\n\n  /**\n   * @notice          Require that a typed memory view be valid.\n   * @dev             Returns the view for easy chaining.\n   * @param memView   The view\n   * @return          bytes29 - The validated view\n   */\n  function assertValid(bytes29 memView) internal pure returns (bytes29) {\n    if (isNotValid(memView)) revert TypedMemView__assertValid_validityAssertionFailed();\n    return memView;\n  }\n\n  /**\n   * @notice          Return true if the memview is of the expected type. Otherwise false.\n   * @param memView   The view\n   * @param _expected The expected type\n   * @return          bool - True if the memview is of the expected type\n   */\n  function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n    return typeOf(memView) == _expected;\n  }\n\n  /**\n   * @notice          Require that a typed memory view has a specific type.\n   * @dev             Returns the view for easy chaining.\n   * @param memView   The view\n   * @param _expected The expected type\n   * @return          bytes29 - The view with validated type\n   */\n  function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n    if (!isType(memView, _expected)) {\n      revert TypedMemView__assertType_typeAssertionFailed(uint256(typeOf(memView)), uint256(_expected));\n    }\n    return memView;\n  }\n\n  /**\n   * @notice          Return an identical view with a different type.\n   * @param memView   The view\n   * @param _newType  The new type\n   * @return          newView - The new view with the specified type\n   */\n  function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n    // then | in the new type\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // shift off the top 5 bytes\n      newView := or(and(memView, LOW_27_BYTES_MASK), shl(_27_BYTES_IN_BITS, _newType))\n    }\n  }\n\n  /**\n   * @notice          Unsafe raw pointer construction. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @dev             Unsafe raw pointer construction. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @param _type     The type\n   * @param _loc      The memory address\n   * @param _len      The length\n   * @return          newView - The new view with the specified type, location and length\n   */\n  function unsafeBuildUnchecked(\n    uint256 _type,\n    uint256 _loc,\n    uint256 _len\n  ) private pure returns (bytes29 newView) {\n    uint256 _uint96Bits = 96;\n    uint256 _emptyBits = 24;\n\n    // Cast params to ensure input is of correct length\n    uint96 len_ = uint96(_len);\n    uint96 loc_ = uint96(_loc);\n    require(len_ == _len && loc_ == _loc, \"!truncated\");\n\n    assembly {\n      // solium-disable-previous-line security/no-inline-assembly\n      newView := shl(_uint96Bits, _type) // insert type\n      newView := shl(_uint96Bits, or(newView, loc_)) // insert loc\n      newView := shl(_emptyBits, or(newView, len_)) // empty bottom 3 bytes\n    }\n  }\n\n  /**\n   * @notice          Instantiate a new memory view. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @dev             Instantiate a new memory view. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @param _type     The type\n   * @param _loc      The memory address\n   * @param _len      The length\n   * @return          newView - The new view with the specified type, location and length\n   */\n  function build(\n    uint256 _type,\n    uint256 _loc,\n    uint256 _len\n  ) internal pure returns (bytes29 newView) {\n    uint256 _end = _loc + _len;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      if gt(_end, mload(0x40)) {\n        _end := 0\n      }\n    }\n    if (_end == 0) {\n      return NULL;\n    }\n    newView = unsafeBuildUnchecked(_type, _loc, _len);\n  }\n\n  /**\n   * @notice          Instantiate a memory view from a byte array.\n   * @dev             Note that due to Solidity memory representation, it is not possible to\n   *                  implement a deref, as the `bytes` type stores its len in memory.\n   * @param arr       The byte array\n   * @param newType   The type\n   * @return          bytes29 - The memory view\n   */\n  function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n    uint256 _len = arr.length;\n\n    uint256 _loc;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      _loc := add(arr, 0x20) // our view is of the data, not the struct\n    }\n\n    return build(newType, _loc, _len);\n  }\n\n  /**\n   * @notice          Return the associated type information.\n   * @param memView   The memory view\n   * @return          _type - The type associated with the view\n   */\n  function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // 216 == 256 - 40\n      _type := shr(_27_BYTES_IN_BITS, memView) // shift out lower 24 bytes\n    }\n  }\n\n  /**\n   * @notice          Return the memory address of the underlying bytes.\n   * @param memView   The view\n   * @return          _loc - The memory address\n   */\n  function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n    uint256 _mask = LOW_12_MASK; // assembly can't use globals\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n      _loc := and(shr(120, memView), _mask)\n    }\n  }\n\n  /**\n   * @notice          The number of memory words this memory view occupies, rounded up.\n   * @param memView   The view\n   * @return          uint256 - The number of memory words\n   */\n  function words(bytes29 memView) internal pure returns (uint256) {\n    return (uint256(len(memView)) + 31) / 32;\n  }\n\n  /**\n   * @notice          The in-memory footprint of a fresh copy of the view.\n   * @param memView   The view\n   * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n   */\n  function footprint(bytes29 memView) internal pure returns (uint256) {\n    return words(memView) * 32;\n  }\n\n  /**\n   * @notice          The number of bytes of the view.\n   * @param memView   The view\n   * @return          _len - The length of the view\n   */\n  function len(bytes29 memView) internal pure returns (uint96 _len) {\n    uint256 _mask = LOW_12_MASK; // assembly can't use globals\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      _len := and(shr(24, memView), _mask)\n    }\n  }\n\n  /**\n   * @notice          Returns the endpoint of `memView`.\n   * @param memView   The view\n   * @return          uint256 - The endpoint of `memView`\n   */\n  function end(bytes29 memView) internal pure returns (uint256) {\n    unchecked {\n      return loc(memView) + len(memView);\n    }\n  }\n\n  /**\n   * @notice          Safe slicing without memory modification.\n   * @param memView   The view\n   * @param _index    The start index\n   * @param _len      The length\n   * @param newType   The new type\n   * @return          bytes29 - The new view\n   */\n  function slice(\n    bytes29 memView,\n    uint256 _index,\n    uint256 _len,\n    uint40 newType\n  ) internal pure returns (bytes29) {\n    uint256 _loc = loc(memView);\n\n    // Ensure it doesn't overrun the view\n    if (_loc + _index + _len > end(memView)) {\n      return NULL;\n    }\n\n    _loc = _loc + _index;\n    return build(newType, _loc, _len);\n  }\n\n  /**\n   * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n   * @param memView   The view\n   * @param _len      The length\n   * @param newType   The new type\n   * @return          bytes29 - The new view\n   */\n  function prefix(\n    bytes29 memView,\n    uint256 _len,\n    uint40 newType\n  ) internal pure returns (bytes29) {\n    return slice(memView, 0, _len, newType);\n  }\n\n  /**\n   * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n   * @param memView   The view\n   * @param _len      The length\n   * @param newType   The new type\n   * @return          bytes29 - The new view\n   */\n  function postfix(\n    bytes29 memView,\n    uint256 _len,\n    uint40 newType\n  ) internal pure returns (bytes29) {\n    return slice(memView, uint256(len(memView)) - _len, _len, newType);\n  }\n\n  /**\n   * @notice          Load up to 32 bytes from the view onto the stack.\n   * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n   *                  This can be immediately cast to a smaller fixed-length byte array.\n   *                  To automatically cast to an integer, use `indexUint`.\n   * @param memView   The view\n   * @param _index    The index\n   * @param _bytes    The bytes\n   * @return          result - The 32 byte result\n   */\n  function index(\n    bytes29 memView,\n    uint256 _index,\n    uint8 _bytes\n  ) internal pure returns (bytes32 result) {\n    if (_bytes == 0) {\n      return bytes32(0);\n    }\n    if (_index + _bytes > len(memView)) {\n      // \"TypedMemView/index - Overran the view. Slice is at {loc} with length {len}. Attempted to index at offset {index} with length {slice},\n      revert TypedMemView__index_overrun(loc(memView), len(memView), _index, uint256(_bytes));\n    }\n    if (_bytes > 32) revert TypedMemView__index_indexMoreThan32Bytes();\n\n    uint8 bitLength;\n    unchecked {\n      bitLength = _bytes * 8;\n    }\n    uint256 _loc = loc(memView);\n    uint256 _mask = leftMask(bitLength);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      result := and(mload(add(_loc, _index)), _mask)\n    }\n  }\n\n  /**\n   * @notice          Parse an unsigned integer from the view at `_index`.\n   * @dev             Requires that the view have >= `_bytes` bytes following that index.\n   * @param memView   The view\n   * @param _index    The index\n   * @param _bytes    The bytes\n   * @return          result - The unsigned integer\n   */\n  function indexUint(\n    bytes29 memView,\n    uint256 _index,\n    uint8 _bytes\n  ) internal pure returns (uint256 result) {\n    return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\n  }\n\n  /**\n   * @notice          Parse an unsigned integer from LE bytes.\n   * @param memView   The view\n   * @param _index    The index\n   * @param _bytes    The bytes\n   * @return          result - The unsigned integer\n   */\n  function indexLEUint(\n    bytes29 memView,\n    uint256 _index,\n    uint8 _bytes\n  ) internal pure returns (uint256 result) {\n    return reverseUint256(uint256(index(memView, _index, _bytes)));\n  }\n\n  /**\n   * @notice          Parse an address from the view at `_index`. Requires that the view have >= 20 bytes\n   *                  following that index.\n   * @param memView   The view\n   * @param _index    The index\n   * @return          address - The address\n   */\n  function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n    return address(uint160(indexUint(memView, _index, 20)));\n  }\n\n  /**\n   * @notice          Return the keccak256 hash of the underlying memory\n   * @param memView   The view\n   * @return          digest - The keccak256 hash of the underlying memory\n   */\n  function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n    uint256 _loc = loc(memView);\n    uint256 _len = len(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      digest := keccak256(_loc, _len)\n    }\n  }\n\n  /**\n   * @notice          Return true if the underlying memory is equal. Else false.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - True if the underlying memory is equal\n   */\n  function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);\n  }\n\n  /**\n   * @notice          Return false if the underlying memory is equal. Else true.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - False if the underlying memory is equal\n   */\n  function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return !untypedEqual(left, right);\n  }\n\n  /**\n   * @notice          Compares type equality.\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - True if the types are the same\n   */\n  function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\n  }\n\n  /**\n   * @notice          Compares type inequality.\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - True if the types are not the same\n   */\n  function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return !equal(left, right);\n  }\n\n  /**\n   * @notice          Copy the view to a location, return an unsafe memory reference\n   * @dev             Super Dangerous direct memory access.\n   *\n   *                  This reference can be overwritten if anything else modifies memory (!!!).\n   *                  As such it MUST be consumed IMMEDIATELY.\n   *                  This function is private to prevent unsafe usage by callers.\n   * @param memView   The view\n   * @param _newLoc   The new location\n   * @return          written - the unsafe memory reference\n   */\n  function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n    if (isNull(memView)) revert TypedMemView__unsafeCopyTo_nullPointer();\n    if (isNotValid(memView)) revert TypedMemView__unsafeCopyTo_invalidPointer();\n\n    uint256 _len = len(memView);\n    uint256 _oldLoc = loc(memView);\n\n    uint256 ptr;\n    bool res;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40)\n      // revert if we're writing in occupied memory\n      if gt(ptr, _newLoc) {\n        revert(0x60, 0x20) // empty revert message\n      }\n\n      // use the identity precompile to copy\n      // guaranteed not to fail, so pop the success\n      res := staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len)\n    }\n    if (!res) revert TypedMemView__unsafeCopyTo_identityOOG();\n    written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n  }\n\n  /**\n   * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n   *                  the new memory\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n   * @param memView   The view\n   * @return          ret - The view pointing to the new memory\n   */\n  function clone(bytes29 memView) internal view returns (bytes memory ret) {\n    uint256 ptr;\n    uint256 _len = len(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40) // load unused memory pointer\n      ret := ptr\n    }\n    unchecked {\n      unsafeCopyTo(memView, ptr + 0x20);\n    }\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n      mstore(ptr, _len) // write len of new array (in bytes)\n    }\n  }\n\n  /**\n   * @notice          Join the views in memory, return an unsafe reference to the memory.\n   * @dev             Super Dangerous direct memory access.\n   *\n   *                  This reference can be overwritten if anything else modifies memory (!!!).\n   *                  As such it MUST be consumed IMMEDIATELY.\n   *                  This function is private to prevent unsafe usage by callers.\n   * @param memViews  The views\n   * @return          unsafeView - The conjoined view pointing to the new memory\n   */\n  function unsafeJoin(bytes29[] memory memViews, uint256 _location) private view returns (bytes29 unsafeView) {\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      let ptr := mload(0x40)\n      // revert if we're writing in occupied memory\n      if gt(ptr, _location) {\n        revert(0x60, 0x20) // empty revert message\n      }\n    }\n\n    uint256 _offset = 0;\n    uint256 _len = memViews.length;\n    for (uint256 i = 0; i < _len; ) {\n      bytes29 memView = memViews[i];\n      unchecked {\n        unsafeCopyTo(memView, _location + _offset);\n        _offset += len(memView);\n        ++i;\n      }\n    }\n    unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n  }\n\n  /**\n   * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n   * @param memViews  The views\n   * @return          bytes32 - The keccak256 digest\n   */\n  function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n    uint256 ptr;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40) // load unused memory pointer\n    }\n    return keccak(unsafeJoin(memViews, ptr));\n  }\n\n  /**\n   * @notice          copies all views, joins them into a new bytearray.\n   * @param memViews  The views\n   * @return          ret - The new byte array\n   */\n  function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n    uint256 ptr;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40) // load unused memory pointer\n    }\n\n    bytes29 _newView;\n    unchecked {\n      _newView = unsafeJoin(memViews, ptr + 0x20);\n    }\n    uint256 _written = len(_newView);\n    uint256 _footprint = footprint(_newView);\n\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // store the legnth\n      mstore(ptr, _written)\n      // new pointer is old + 0x20 + the footprint of the body\n      mstore(0x40, add(add(ptr, _footprint), 0x20))\n      ret := ptr\n    }\n  }\n}\n"
82     }
83   }
84 }}