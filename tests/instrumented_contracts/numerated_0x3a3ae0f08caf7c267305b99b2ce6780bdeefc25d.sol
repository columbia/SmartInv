1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/RulerZap.sol": {
5       "content": "// SPDX-License-Identifier: No License\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./ERC20/IERC20.sol\";\r\nimport \"./ERC20/IERC20Permit.sol\";\r\nimport \"./ERC20/SafeERC20.sol\";\r\nimport \"./interfaces/IRERC20.sol\";\r\nimport \"./interfaces/IRulerCore.sol\";\r\nimport \"./interfaces/IRouter.sol\";\r\nimport \"./interfaces/IRulerZap.sol\";\r\nimport \"./interfaces/IMetaPool.sol\";\r\nimport \"./utils/Ownable.sol\";\r\n\r\n/**\r\n * @title Ruler Protocol Zap\r\n * @author alan\r\n * Main logic is in _depositAndAddLiquidity & _depositAndSwapToPaired\r\n */\r\ncontract RulerZap is Ownable, IRulerZap {\r\n    using SafeERC20 for IERC20;\r\n    IRulerCore public override core;\r\n    IRouter public override router;\r\n\r\n    constructor (IRulerCore _core, IRouter _router) {\r\n        require(address(_core) != address(0), \"RulerZap: _core is 0\");\r\n        require(address(_router) != address(0), \"RulerZap: _router is 0\");\r\n        core = _core;\r\n        router = _router;\r\n        initializeOwner();\r\n    }\r\n\r\n    /**\r\n    * @notice Deposit collateral `_col` to receive paired token `_paired` and rrTokens\r\n    *  - deposits collateral to receive rcTokens and rrTokens\r\n    *  - rcTokens are swapped into paired token through router\r\n    *  - paired token and rrTokens are sent to sender\r\n    */\r\n    function depositAndSwapToPaired(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        uint256 _minPairedOut,\r\n        address[] calldata _path,\r\n        uint256 _deadline\r\n    ) external override {\r\n        _depositAndSwapToPaired(\r\n            _col, \r\n            _paired, \r\n            _expiry, \r\n            _mintRatio, \r\n            _colAmt, \r\n            _minPairedOut, \r\n            _path, \r\n            _deadline\r\n        );\r\n    }\r\n\r\n    function depositWithPermitAndSwapToPaired(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        uint256 _minPairedOut,\r\n        address[] calldata _path,\r\n        uint256 _deadline,\r\n        Permit calldata _colPermit\r\n    ) external override {\r\n        _permit(IERC20Permit(_col), _colPermit);\r\n        _depositAndSwapToPaired(\r\n            _col, \r\n            _paired, \r\n            _expiry, \r\n            _mintRatio, \r\n            _colAmt, \r\n            _minPairedOut, \r\n            _path, \r\n            _deadline\r\n        );\r\n    }\r\n\r\n    function depositAndSwapWithCurve(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        address _poolAddress,\r\n        int128 _outTokenIndex,\r\n        uint256 _minOut\r\n    ) external override {\r\n        _depositAndSwapWithCurve(\r\n            _col, \r\n            _paired, \r\n            _expiry, \r\n            _mintRatio, \r\n            _colAmt, \r\n            _poolAddress, \r\n            _outTokenIndex, \r\n            _minOut\r\n        );\r\n    }\r\n\r\n    function depositWithPermitAndSwapWithCurve(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        address _poolAddress,\r\n        int128 _outTokenIndex,\r\n        uint256 _minOut,\r\n        Permit calldata _colPermit\r\n    ) external override {\r\n        _permit(IERC20Permit(_col), _colPermit);\r\n        _depositAndSwapWithCurve(\r\n            _col, \r\n            _paired, \r\n            _expiry, \r\n            _mintRatio, \r\n            _colAmt, \r\n            _poolAddress, \r\n            _outTokenIndex, \r\n            _minOut\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Deposit collateral `_col` to receive LP tokens and rrTokens\r\n    *  - deposits collateral to receive rcTokens and rrTokens\r\n    *  - transfers paired token from sender\r\n    *  - rcTokens and `_paired` tokens are added as liquidity to receive LP tokens\r\n    *  - LP tokens and rrTokens are sent to sender\r\n    */\r\n    function depositAndAddLiquidity(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        uint256 _rcTokenDepositAmt,\r\n        uint256 _pairedDepositAmt,\r\n        uint256 _rcTokenDepositMin,\r\n        uint256 _pairedDepositMin,\r\n        uint256 _deadline\r\n    ) external override {\r\n        _depositAndAddLiquidity(\r\n            _col, \r\n            _paired, \r\n            _expiry, \r\n            _mintRatio, \r\n            _colAmt, \r\n            _rcTokenDepositAmt, \r\n            _pairedDepositAmt, \r\n            _rcTokenDepositMin, \r\n            _pairedDepositMin,\r\n            _deadline\r\n        );\r\n    }\r\n\r\n    function depositWithColPermitAndAddLiquidity(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        uint256 _rcTokenDepositAmt,\r\n        uint256 _pairedDepositAmt,\r\n        uint256 _rcTokenDepositMin,\r\n        uint256 _pairedDepositMin,\r\n        uint256 _deadline,\r\n        Permit calldata _colPermit\r\n    ) external override {\r\n        _permit(IERC20Permit(_col), _colPermit);\r\n        _depositAndAddLiquidity(\r\n            _col, \r\n            _paired, \r\n            _expiry, \r\n            _mintRatio, \r\n            _colAmt, \r\n            _rcTokenDepositAmt, \r\n            _pairedDepositAmt, \r\n            _rcTokenDepositMin, \r\n            _pairedDepositMin,\r\n            _deadline\r\n        );\r\n    }\r\n\r\n    function depositWithPairedPermitAndAddLiquidity(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        uint256 _rcTokenDepositAmt,\r\n        uint256 _pairedDepositAmt,\r\n        uint256 _rcTokenDepositMin,\r\n        uint256 _pairedDepositMin,\r\n        uint256 _deadline,\r\n        Permit calldata _pairedPermit\r\n    ) external override {\r\n        _permit(IERC20Permit(_paired), _pairedPermit);\r\n        _depositAndAddLiquidity(\r\n            _col, \r\n            _paired, \r\n            _expiry, \r\n            _mintRatio, \r\n            _colAmt, \r\n            _rcTokenDepositAmt, \r\n            _pairedDepositAmt, \r\n            _rcTokenDepositMin, \r\n            _pairedDepositMin,\r\n            _deadline\r\n        );\r\n    }\r\n\r\n    function depositWithBothPermitsAndAddLiquidity(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        uint256 _rcTokenDepositAmt,\r\n        uint256 _pairedDepositAmt,\r\n        uint256 _rcTokenDepositMin,\r\n        uint256 _pairedDepositMin,\r\n        uint256 _deadline,\r\n        Permit calldata _colPermit,\r\n        Permit calldata _pairedPermit\r\n    ) external override {\r\n        _permit(IERC20Permit(_col), _colPermit);\r\n        _permit(IERC20Permit(_paired), _pairedPermit);\r\n        _depositAndAddLiquidity(\r\n            _col, \r\n            _paired, \r\n            _expiry, \r\n            _mintRatio, \r\n            _colAmt, \r\n            _rcTokenDepositAmt, \r\n            _pairedDepositAmt, \r\n            _rcTokenDepositMin, \r\n            _pairedDepositMin,\r\n            _deadline\r\n        );\r\n    }\r\n\r\n    function mmDepositAndAddLiquidity(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _rcTokenDepositAmt,\r\n        uint256 _pairedDepositAmt,\r\n        uint256 _rcTokenDepositMin,\r\n        uint256 _pairedDepositMin,\r\n        uint256 _deadline\r\n    ) external override {\r\n        _mmDepositAndAddLiquidity(\r\n            _col, \r\n            _paired, \r\n            _expiry, \r\n            _mintRatio, \r\n            _rcTokenDepositAmt, \r\n            _pairedDepositAmt, \r\n            _rcTokenDepositMin, \r\n            _pairedDepositMin,\r\n            _deadline\r\n        );\r\n    }\r\n\r\n    function mmDepositWithPermitAndAddLiquidity(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _rcTokenDepositAmt,\r\n        uint256 _pairedDepositAmt,\r\n        uint256 _rcTokenDepositMin,\r\n        uint256 _pairedDepositMin,\r\n        uint256 _deadline,\r\n        Permit calldata _pairedPermit\r\n    ) external override {\r\n        _permit(IERC20Permit(_paired), _pairedPermit);\r\n        _mmDepositAndAddLiquidity(\r\n            _col, \r\n            _paired, \r\n            _expiry, \r\n            _mintRatio, \r\n            _rcTokenDepositAmt, \r\n            _pairedDepositAmt, \r\n            _rcTokenDepositMin, \r\n            _pairedDepositMin,\r\n            _deadline\r\n        );\r\n    }\r\n\r\n    /// @notice This contract should never hold any funds.\r\n    /// Any tokens sent here by accident can be retreived.\r\n    function collect(IERC20 _token) external override onlyOwner {\r\n        uint256 balance = _token.balanceOf(address(this));\r\n        require(balance > 0, \"RulerZap: balance is 0\");\r\n        _token.safeTransfer(msg.sender, balance);\r\n    }\r\n\r\n    function updateCore(IRulerCore _core) external override onlyOwner {\r\n        require(address(_core) != address(0), \"RulerZap: _core is 0\");\r\n        core = _core;\r\n    }\r\n\r\n    function updateRouter(IRouter _router) external override onlyOwner {\r\n        require(address(_router) != address(0), \"RulerZap: _router is 0\");\r\n        router = _router;\r\n    }\r\n\r\n    /// @notice check received amount from swap, tokenOut is always the last in array\r\n    function getAmountOut(\r\n        uint256 _tokenInAmt, \r\n        address[] calldata _path\r\n    ) external view override returns (uint256) {\r\n        return router.getAmountsOut(_tokenInAmt, _path)[_path.length - 1];\r\n    }\r\n\r\n    function _depositAndSwapToPaired(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        uint256 _minPairedOut,\r\n        address[] calldata _path,\r\n        uint256 _deadline\r\n    ) private {\r\n        require(_colAmt > 0, \"RulerZap: _colAmt is 0\");\r\n        require(_path.length >= 2, \"RulerZap: _path length < 2\");\r\n        require(_path[_path.length - 1] == _paired, \"RulerZap: output != _paired\");\r\n        require(_deadline >= block.timestamp, \"RulerZap: _deadline in past\");\r\n        (address _rcToken, uint256 _rcTokensReceived, ) = _deposit(_col, _paired, _expiry, _mintRatio, _colAmt);\r\n\r\n        require(_path[0] == _rcToken, \"RulerZap: input != rcToken\");\r\n        _approve(IERC20(_rcToken), address(router), _rcTokensReceived);\r\n        router.swapExactTokensForTokens(_rcTokensReceived, _minPairedOut, _path, msg.sender, _deadline);\r\n    }\r\n\r\n    function _depositAndSwapWithCurve(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        address _poolAddress,\r\n        int128 _outTokenIndex,\r\n        uint256 _minOut\r\n    ) private {\r\n        require(_colAmt > 0, \"RulerZap: _colAmt is 0\");\r\n        require(_outTokenIndex != 0, \"RulerZap: _outTokenIndex is 0\");\r\n        (address _rcToken, uint256 _rcTokensReceived, ) = _deposit(_col, _paired, _expiry, _mintRatio, _colAmt);\r\n        _approve(IERC20(_rcToken), _poolAddress, _rcTokensReceived);\r\n        IMetaPool(_poolAddress).exchange_underlying(0, _outTokenIndex, _rcTokensReceived, _minOut, msg.sender);\r\n    }\r\n\r\n    function _depositAndAddLiquidity(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        uint256 _rcTokenDepositAmt,\r\n        uint256 _pairedDepositAmt,\r\n        uint256 _rcTokenDepositMin,\r\n        uint256 _pairedDepositMin,\r\n        uint256 _deadline\r\n    ) private {\r\n        require(_colAmt > 0, \"RulerZap: _colAmt is 0\");\r\n        require(_deadline >= block.timestamp, \"RulerZap: _deadline in past\");\r\n        require(_rcTokenDepositAmt > 0, \"RulerZap: 0 rcTokenDepositAmt\");\r\n        require(_rcTokenDepositAmt >= _rcTokenDepositMin, \"RulerZap: rcToken Amt < min\");\r\n        require(_pairedDepositAmt > 0, \"RulerZap: 0 pairedDepositAmt\");\r\n        require(_pairedDepositAmt >= _pairedDepositMin, \"RulerZap: paired Amt < min\");\r\n\r\n        // deposit collateral to Ruler\r\n        IERC20 rcToken;\r\n        uint256 rcTokensBalBefore;\r\n        { // scope to avoid stack too deep errors\r\n            (address _rcToken, uint256 _rcTokensReceived, uint256 _rcTokensBalBefore) = _deposit(_col, _paired, _expiry, _mintRatio, _colAmt);\r\n            require(_rcTokenDepositAmt <= _rcTokensReceived, \"RulerZap: rcToken Amt > minted\");\r\n            rcToken = IERC20(_rcToken);\r\n            rcTokensBalBefore = _rcTokensBalBefore;\r\n        }\r\n\r\n        // received paired tokens from sender\r\n        IERC20 paired = IERC20(_paired);\r\n        uint256 pairedBalBefore = paired.balanceOf(address(this));\r\n        paired.safeTransferFrom(msg.sender, address(this), _pairedDepositAmt);\r\n        uint256 receivedPaired = paired.balanceOf(address(this)) - pairedBalBefore;\r\n        require(receivedPaired > 0, \"RulerZap: paired transfer failed\");\r\n\r\n        // add liquidity for sender\r\n        _approve(rcToken, address(router), _rcTokenDepositAmt);\r\n        _approve(paired, address(router), _pairedDepositAmt);\r\n        router.addLiquidity(\r\n            address(rcToken), \r\n            address(paired), \r\n            _rcTokenDepositAmt, \r\n            receivedPaired, \r\n            _rcTokenDepositMin,\r\n            _pairedDepositMin,\r\n            msg.sender,\r\n            _deadline\r\n        );\r\n\r\n        // sending leftover tokens back to sender\r\n        uint256 rcTokensLeftover = rcToken.balanceOf(address(this)) - rcTokensBalBefore;\r\n        if (rcTokensLeftover > 0) {\r\n            rcToken.safeTransfer(msg.sender, rcTokensLeftover);\r\n        }\r\n        uint256 pairedTokensLeftover = paired.balanceOf(address(this)) - pairedBalBefore;\r\n        if (pairedTokensLeftover > 0) {\r\n            paired.safeTransfer(msg.sender, pairedTokensLeftover);\r\n        }\r\n    }\r\n\r\n    function _mmDepositAndAddLiquidity(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _rcTokenDepositAmt,\r\n        uint256 _pairedDepositAmt,\r\n        uint256 _rcTokenDepositMin,\r\n        uint256 _pairedDepositMin,\r\n        uint256 _deadline\r\n    ) private {\r\n        require(_deadline >= block.timestamp, \"RulerZap: _deadline in past\");\r\n        require(_rcTokenDepositAmt > 0, \"RulerZap: 0 rcTokenDepositAmt\");\r\n        require(_rcTokenDepositAmt >= _rcTokenDepositMin, \"RulerZap: rcToken Amt < min\");\r\n        require(_pairedDepositAmt > 0, \"RulerZap: 0 pairedDepositAmt\");\r\n        require(_pairedDepositAmt >= _pairedDepositMin, \"RulerZap: paired Amt < min\");\r\n\r\n        // transfer all paired tokens from sender to this contract\r\n        IERC20 paired = IERC20(_paired);\r\n        uint256 pairedBalBefore = paired.balanceOf(address(this));\r\n        paired.safeTransferFrom(msg.sender, address(this), _rcTokenDepositAmt + _pairedDepositAmt);\r\n        require(paired.balanceOf(address(this)) - pairedBalBefore == _rcTokenDepositAmt + _pairedDepositAmt, \"RulerZap: paired transfer failed\");\r\n\r\n        // mmDeposit paired to Ruler to receive rcTokens\r\n        ( , , , IRERC20 rcToken, , , , ) = core.pairs(_col, _paired, _expiry, _mintRatio);\r\n        require(address(rcToken) != address(0), \"RulerZap: pair not exist\");\r\n        uint256 rcTokenBalBefore = rcToken.balanceOf(address(this));\r\n        _approve(paired, address(core), _rcTokenDepositAmt);\r\n        core.mmDeposit(_col, _paired, _expiry, _mintRatio, _rcTokenDepositAmt);\r\n        uint256 rcTokenReceived = rcToken.balanceOf(address(this)) - rcTokenBalBefore;\r\n        require(_rcTokenDepositAmt <= rcTokenReceived, \"RulerZap: rcToken Amt > minted\");\r\n\r\n        // add liquidity for sender\r\n        _approve(rcToken, address(router), _rcTokenDepositAmt);\r\n        _approve(paired, address(router), _pairedDepositAmt);\r\n        router.addLiquidity(\r\n            address(rcToken),\r\n            _paired,\r\n            _rcTokenDepositAmt, \r\n            _pairedDepositAmt, \r\n            _rcTokenDepositMin,\r\n            _pairedDepositMin,\r\n            msg.sender,\r\n            _deadline\r\n        );\r\n\r\n        // sending leftover tokens (since the beginning of user call) back to sender\r\n        _transferRem(rcToken, rcTokenBalBefore);\r\n        _transferRem(paired, pairedBalBefore);\r\n    }\r\n\r\n    function _deposit(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt\r\n    ) private returns (address rcTokenAddr, uint256 rcTokenReceived, uint256 rcTokenBalBefore) {\r\n        ( , , , IRERC20 rcToken, IRERC20 rrToken, , , ) = core.pairs(_col, _paired, _expiry, _mintRatio);\r\n        require(address(rcToken) != address(0) && address(rrToken) != address(0), \"RulerZap: pair not exist\");\r\n        // receive collateral from sender\r\n        IERC20 collateral = IERC20(_col);\r\n        uint256 colBalBefore = collateral.balanceOf(address(this));\r\n        collateral.safeTransferFrom(msg.sender, address(this), _colAmt);\r\n        uint256 received = collateral.balanceOf(address(this)) - colBalBefore;\r\n        require(received > 0, \"RulerZap: col transfer failed\");\r\n\r\n        // deposit collateral to Ruler\r\n        rcTokenBalBefore = rcToken.balanceOf(address(this));\r\n        uint256 rrTokenBalBefore = rrToken.balanceOf(address(this));\r\n        _approve(collateral, address(core), received);\r\n        core.deposit(_col, _paired, _expiry, _mintRatio, received);\r\n\r\n        // send rrToken back to sender, and record received rcTokens\r\n        _transferRem(rrToken, rrTokenBalBefore);\r\n        rcTokenReceived = rcToken.balanceOf(address(this)) - rcTokenBalBefore;\r\n        rcTokenAddr = address(rcToken);\r\n    }\r\n\r\n    function _approve(IERC20 _token, address _spender, uint256 _amount) private {\r\n        uint256 allowance = _token.allowance(address(this), _spender);\r\n        if (allowance < _amount) {\r\n            if (allowance != 0) {\r\n                _token.safeApprove(_spender, 0);\r\n            }\r\n            _token.safeApprove(_spender, type(uint256).max);\r\n        }\r\n    }\r\n\r\n    function _permit(IERC20Permit _token, Permit calldata permit) private {\r\n        _token.permit(\r\n            permit.owner,\r\n            permit.spender,\r\n            permit.amount,\r\n            permit.deadline,\r\n            permit.v,\r\n            permit.r,\r\n            permit.s\r\n        );\r\n    }\r\n\r\n    // transfer remaining amount (since the beginnning of action) back to sender\r\n    function _transferRem(IERC20 _token, uint256 _balBefore) private {\r\n        uint256 tokensLeftover = _token.balanceOf(address(this)) - _balBefore;\r\n        if (tokensLeftover > 0) {\r\n            _token.safeTransfer(msg.sender, tokensLeftover);\r\n        }\r\n    }\r\n}"
6     },
7     "contracts/ERC20/IERC20.sol": {
8       "content": "// SPDX-License-Identifier: No License\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n}"
9     },
10     "contracts/ERC20/IERC20Permit.sol": {
11       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\r\n     * given `owner`'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}"
12     },
13     "contracts/ERC20/SafeERC20.sol": {
14       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"../utils/Address.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) - value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}"
15     },
16     "contracts/interfaces/IRERC20.sol": {
17       "content": "// SPDX-License-Identifier: No License\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title RERC20 contract interface, implements {IERC20}. See {RERC20}.\r\n * @author crypto-pumpkin\r\n */\r\ninterface IRERC20 is IERC20 {\r\n    /// @notice access restriction - owner (R)\r\n    function mint(address _account, uint256 _amount) external returns (bool);\r\n    function burnByRuler(address _account, uint256 _amount) external returns (bool);\r\n}"
18     },
19     "contracts/interfaces/IRulerCore.sol": {
20       "content": "// SPDX-License-Identifier: No License\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IRERC20.sol\";\r\nimport \"./IOracle.sol\";\r\n\r\n/**\r\n * @title IRulerCore contract interface. See {RulerCore}.\r\n * @author crypto-pumpkin\r\n */\r\ninterface IRulerCore {\r\n  event RTokenCreated(address);\r\n  event CollateralUpdated(address col, uint256 old, uint256 _new);\r\n  event PairAdded(address indexed collateral, address indexed paired, uint48 expiry, uint256 mintRatio);\r\n  event MarketMakeDeposit(address indexed user, address indexed collateral, address indexed paired, uint48 expiry, uint256 mintRatio, uint256 amount);\r\n  event Deposit(address indexed user, address indexed collateral, address indexed paired, uint48 expiry, uint256 mintRatio, uint256 amount);\r\n  event Repay(address indexed user, address indexed collateral, address indexed paired, uint48 expiry, uint256 mintRatio, uint256 amount);\r\n  event Redeem(address indexed user, address indexed collateral, address indexed paired, uint48 expiry, uint256 mintRatio, uint256 amount);\r\n  event Collect(address indexed user, address indexed collateral, address indexed paired, uint48 expiry, uint256 mintRatio, uint256 amount);\r\n  event AddressUpdated(string _type, address old, address _new);\r\n  event PausedStatusUpdated(bool old, bool _new);\r\n  event RERC20ImplUpdated(address rERC20Impl, address newImpl);\r\n  event FlashLoanRateUpdated(uint256 old, uint256 _new);\r\n\r\n  struct Pair {\r\n    bool active;\r\n    uint48 expiry;\r\n    address pairedToken;\r\n    IRERC20 rcToken; // ruler capitol token, e.g. RC_Dai_wBTC_2_2021\r\n    IRERC20 rrToken; // ruler repayment token, e.g. RR_Dai_wBTC_2_2021\r\n    uint256 mintRatio; // 1e18, price of collateral / collateralization ratio\r\n    uint256 feeRate; // 1e18\r\n    uint256 colTotal;\r\n  }\r\n\r\n  struct Permit {\r\n    address owner;\r\n    address spender;\r\n    uint256 amount;\r\n    uint256 deadline;\r\n    uint8 v;\r\n    bytes32 r;\r\n    bytes32 s;\r\n  }\r\n\r\n  // state vars\r\n  function oracle() external view returns (IOracle);\r\n  function version() external pure returns (string memory);\r\n  function flashLoanRate() external view returns (uint256);\r\n  function paused() external view returns (bool);\r\n  function responder() external view returns (address);\r\n  function feeReceiver() external view returns (address);\r\n  function rERC20Impl() external view returns (address);\r\n  function collaterals(uint256 _index) external view returns (address);\r\n  function minColRatioMap(address _col) external view returns (uint256);\r\n  function feesMap(address _token) external view returns (uint256);\r\n  function pairs(address _col, address _paired, uint48 _expiry, uint256 _mintRatio) external view returns (\r\n    bool active, \r\n    uint48 expiry, \r\n    address pairedToken, \r\n    IRERC20 rcToken, \r\n    IRERC20 rrToken, \r\n    uint256 mintRatio, \r\n    uint256 feeRate, \r\n    uint256 colTotal\r\n  );\r\n\r\n  // extra view\r\n  function getCollaterals() external view returns (address[] memory);\r\n  function getPairList(address _col) external view returns (Pair[] memory);\r\n  function viewCollectible(\r\n    address _col,\r\n    address _paired,\r\n    uint48 _expiry,\r\n    uint256 _mintRatio,\r\n    uint256 _rcTokenAmt\r\n  ) external view returns (uint256 colAmtToCollect, uint256 pairedAmtToCollect);\r\n\r\n  // user action - only when not paused\r\n  function mmDeposit(\r\n    address _col,\r\n    address _paired,\r\n    uint48 _expiry,\r\n    uint256 _mintRatio,\r\n    uint256 _rcTokenAmt\r\n  ) external;\r\n  function mmDepositWithPermit(\r\n    address _col,\r\n    address _paired,\r\n    uint48 _expiry,\r\n    uint256 _mintRatio,\r\n    uint256 _rcTokenAmt,\r\n    Permit calldata _pairedPermit\r\n  ) external;\r\n  function deposit(\r\n    address _col,\r\n    address _paired,\r\n    uint48 _expiry,\r\n    uint256 _mintRatio,\r\n    uint256 _colAmt\r\n  ) external;\r\n  function depositWithPermit(\r\n    address _col,\r\n    address _paired,\r\n    uint48 _expiry,\r\n    uint256 _mintRatio,\r\n    uint256 _colAmt,\r\n    Permit calldata _colPermit\r\n  ) external;\r\n  function redeem(\r\n    address _col,\r\n    address _paired,\r\n    uint48 _expiry,\r\n    uint256 _mintRatio,\r\n    uint256 _rTokenAmt\r\n  ) external;\r\n  function repay(\r\n    address _col,\r\n    address _paired,\r\n    uint48 _expiry,\r\n    uint256 _mintRatio,\r\n    uint256 _rrTokenAmt\r\n  ) external;\r\n  function repayWithPermit(\r\n    address _col,\r\n    address _paired,\r\n    uint48 _expiry,\r\n    uint256 _mintRatio,\r\n    uint256 _rrTokenAmt,\r\n    Permit calldata _pairedPermit\r\n  ) external;\r\n  function collect(\r\n    address _col,\r\n    address _paired,\r\n    uint48 _expiry,\r\n    uint256 _mintRatio,\r\n    uint256 _rcTokenAmt\r\n  ) external;\r\n  function collectFees(IERC20[] calldata _tokens) external;\r\n\r\n  // access restriction - owner (dev) & responder\r\n  function setPaused(bool _paused) external;\r\n\r\n  // access restriction - owner (dev)\r\n  function addPair(\r\n    address _col,\r\n    address _paired,\r\n    uint48 _expiry,\r\n    string calldata _expiryStr,\r\n    uint256 _mintRatio,\r\n    string calldata _mintRatioStr,\r\n    uint256 _feeRate\r\n  ) external;\r\n  function setPairActive(\r\n    address _col,\r\n    address _paired,\r\n    uint48 _expiry,\r\n    uint256 _mintRatio,\r\n    bool _active\r\n  ) external;\r\n  function updateCollateral(address _col, uint256 _minColRatio) external;\r\n  function setFeeReceiver(address _addr) external;\r\n  function setResponder(address _addr) external;\r\n  function setRERC20Impl(address _addr) external;\r\n  function setOracle(address _addr) external;\r\n  function setFlashLoanRate(uint256 _newRate) external;\r\n}"
21     },
22     "contracts/interfaces/IRouter.sol": {
23       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRouter {\r\n  function getAmountsOut(uint256 amountIn, address[] memory path) external view returns (uint256[] memory amounts);\r\n\r\n  function addLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 amountADesired,\r\n    uint256 amountBDesired,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n  function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline)\r\n      external\r\n      returns (uint256[] memory amounts);\r\n}"
24     },
25     "contracts/interfaces/IRulerZap.sol": {
26       "content": "// SPDX-License-Identifier: No License\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IRulerCore.sol\";\r\nimport \"./IRouter.sol\";\r\nimport \"../ERC20/IERC20.sol\";\r\n\r\ninterface IRulerZap {\r\n    struct Permit {\r\n        address owner;\r\n        address spender;\r\n        uint256 amount;\r\n        uint256 deadline;\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    // state vars\r\n    function core() external view returns (IRulerCore);\r\n    function router() external view returns (IRouter);\r\n\r\n    // extra view\r\n    function getAmountOut(uint256 _tokenInAmt, address[] calldata _path) external view returns (uint256);\r\n\r\n    // user interactions\r\n    function depositAndSwapToPaired(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        uint256 _minPairedOut,\r\n        address[] calldata _path,\r\n        uint256 _deadline\r\n    ) external;\r\n\r\n    function depositWithPermitAndSwapToPaired(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        uint256 _minPairedOut,\r\n        address[] calldata _path,\r\n        uint256 _deadline,\r\n        Permit calldata _colPermit\r\n    ) external;\r\n\r\n    function depositAndSwapWithCurve(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        address _poolAddress,\r\n        int128 _outTokenIndex,\r\n        uint256 _minOut\r\n    ) external;\r\n\r\n    function depositWithPermitAndSwapWithCurve(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        address _poolAddress,\r\n        int128 _outTokenIndex,\r\n        uint256 _minOut,\r\n        Permit calldata _colPermit\r\n    ) external;\r\n\r\n    function depositAndAddLiquidity(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        uint256 _rcTokenDepositAmt,\r\n        uint256 _pairedDepositAmt,\r\n        uint256 _rcTokenDepositMin,\r\n        uint256 _pairedDepositMin,\r\n        uint256 _deadline\r\n    ) external;\r\n\r\n    function depositWithColPermitAndAddLiquidity(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        uint256 _rcTokenDepositAmt,\r\n        uint256 _pairedDepositAmt,\r\n        uint256 _rcTokenDepositMin,\r\n        uint256 _pairedDepositMin,\r\n        uint256 _deadline,\r\n        Permit calldata _colPermit\r\n    ) external;\r\n\r\n    function depositWithPairedPermitAndAddLiquidity(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        uint256 _rcTokenDepositAmt,\r\n        uint256 _pairedDepositAmt,\r\n        uint256 _rcTokenDepositMin,\r\n        uint256 _pairedDepositMin,\r\n        uint256 _deadline,\r\n        Permit calldata _pairedPermit\r\n    ) external;\r\n\r\n    function depositWithBothPermitsAndAddLiquidity(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _colAmt,\r\n        uint256 _rcTokenDepositAmt,\r\n        uint256 _pairedDepositAmt,\r\n        uint256 _rcTokenDepositMin,\r\n        uint256 _pairedDepositMin,\r\n        uint256 _deadline,\r\n        Permit calldata _colPermit,\r\n        Permit calldata _pairedPermit\r\n    ) external;\r\n\r\n    function mmDepositAndAddLiquidity(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _rcTokenDepositAmt,\r\n        uint256 _pairedDepositAmt,\r\n        uint256 _rcTokenDepositMin,\r\n        uint256 _pairedDepositMin,\r\n        uint256 _deadline\r\n    ) external;\r\n\r\n    function mmDepositWithPermitAndAddLiquidity(\r\n        address _col, \r\n        address _paired,\r\n        uint48 _expiry,\r\n        uint256 _mintRatio,\r\n        uint256 _rcTokenDepositAmt,\r\n        uint256 _pairedDepositAmt,\r\n        uint256 _rcTokenDepositMin,\r\n        uint256 _pairedDepositMin,\r\n        uint256 _deadline,\r\n        Permit calldata _pairedPermit\r\n    ) external;\r\n\r\n    // admin\r\n    function collect(IERC20 _token) external;\r\n    function updateCore(IRulerCore _core) external;\r\n    function updateRouter(IRouter _router) external;\r\n}"
27     },
28     "contracts/interfaces/IMetaPool.sol": {
29       "content": "// SPDX-License-Identifier: No License\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IMetaPool {\r\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address _receiver) external returns (uint256);\r\n}"
30     },
31     "contracts/utils/Ownable.sol": {
32       "content": "// SPDX-License-Identifier: No License\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Initializable.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n * @author crypto-pumpkin\r\n *\r\n * By initialization, the owner account will be the one that called initializeOwner. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Initializable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Ruler: Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function initializeOwner() internal initializer {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}"
33     },
34     "contracts/utils/Address.sol": {
35       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}"
36     },
37     "contracts/interfaces/IOracle.sol": {
38       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IOracle {\r\n    function getPriceUSD(address _asset) external view returns (uint256 price);\r\n    function getPricesUSD(address[] calldata _assets) external view returns (uint256[] memory prices);\r\n    \r\n    // admin functions\r\n    function updateFeedETH(address _asset, address _feed) external;\r\n    function updateFeedUSD(address _asset, address _feed) external;\r\n    function setSushiKeeperOracle(address _sushiOracle) external;\r\n    function setUniKeeperOracle(address _uniOracle) external;\r\n}"
39     },
40     "contracts/utils/Initializable.sol": {
41       "content": "// SPDX-License-Identifier: MIT\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n * \r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\r\n * \r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function _isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        address self = address(this);\r\n        uint256 cs;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { cs := extcodesize(self) }\r\n        return cs == 0;\r\n    }\r\n}"
42     }
43   },
44   "settings": {
45     "optimizer": {
46       "enabled": true,
47       "runs": 2000
48     },
49     "outputSelection": {
50       "*": {
51         "*": [
52           "evm.bytecode",
53           "evm.deployedBytecode",
54           "abi"
55         ]
56       }
57     },
58     "libraries": {}
59   }
60 }}