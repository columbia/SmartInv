1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/ElyGenesisCollection.sol": {
5       "content": "// SPDX-License-Identifier: APGL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"./Ownable.sol\";\nimport {ERC1155} from \"./solmate/tokens/ERC1155.sol\";\n\n/// @title ElyGenesisCollection\n/// @notice Minting contract for Ely's Genesis Collection (https://twitter.com/ratkingnft).\n/// @author 0xMetas (https://twitter.com/0xMetas)\ncontract ElyGenesisCollection is ERC1155, Ownable {\n    //////////////////////\n    /// External State ///\n    //////////////////////\n\n    /// @notice The name of the contract.\n    /// @dev EIP-1155 doesn't define `name()` so that the metadata JSON returned by `uri` is\n    /// the definitive name, but it's provided for compatibility with existing front-ends.\n    string public constant name = \"Ely Genesis Collection\"; // solhint-disable-line const-name-snakecase\n\n    /// @notice The symbol of the contract.\n    /// @dev EIP-1155 doesn't define `symbol()` because it isn't a \"globally useful piece of\n    /// data\", but, again, it's provided for compatibility with existing front-ends.\n    string public constant symbol = \"ELYGENESIS\"; // solhint-disable-line const-name-snakecase\n\n    /// @notice The price of each token.\n    uint256 public constant PRICE = 0.05 ether;\n\n    /// @notice The maximum supply of all tokens.\n    uint256 public constant MAX_SUPPLY = 500;\n\n    /// @notice The maximum supply of each token.\n    uint256 public constant MAX_SUPPLY_PER_ID = 100;\n\n    /// @notice True if the metadata (URI) can no longer be modified.\n    bool public metadataFrozen = false;\n\n    /// @notice The maximum number of tokens you can purchase in a single transaction.\n    uint256 public transactionLimit = 3;\n\n    /// @notice True if the sale is open.\n    bool public purchaseable = false;\n\n    /// @notice The total supply of all tokens.\n    /// @dev EIP-1155 requires enumeration off-chain, but the contract provides `totalSupplyAll`\n    /// for convenience, and compatibility with marketplaces and other front-ends.\n    uint256 public totalSupplyAll = 0;\n\n    /// @notice The total supply of an individual token.\n    /// @dev See `totalSupplyAll`.\n    uint8[5] public totalSupply;\n\n    //////////////////////\n    /// Internal State ///\n    //////////////////////\n\n    /// @dev The ids available to mint. This array is used when generating a random index for the mint.\n    /// Ids are removed from this array when their max amount has been minted.\n    uint8[] private availableIds = [0, 1, 2, 3, 4];\n\n    /// @dev The 'dynamic' length of the `availableIds` array. Since it's a static array, it's actual\n    /// length cannot be modified, so this variable is used instead.\n    uint8 private availableIdsLength = 5;\n\n    /// @dev The base of the generated URI returned by `uri(uint256)`.\n    string private baseUri;\n\n    //////////////\n    /// Errors ///\n    //////////////\n\n    error WithdrawFail();\n    error FrozenMetadata();\n    error NotPurchaseable();\n    error SoldOut();\n    error InsufficientValue();\n    error InvalidPurchaseAmount();\n    error ExternalAccountOnly();\n\n    //////////////\n    /// Events ///\n    //////////////\n\n    event PermanentURI(string uri, uint256 indexed id);\n    event Purchaseable(bool state);\n    event TransactionLimit(uint256 previousLimit, uint256 newLimit);\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor() {}\n\n    /// @notice Purchase `amount` number of tokens.\n    /// @param amount The number of tokens to purchase.\n    function purchase(uint256 amount) public payable {\n        if (!purchaseable) revert NotPurchaseable();\n        if (amount + totalSupplyAll > MAX_SUPPLY) revert SoldOut();\n        if (msg.value != amount * PRICE) revert InsufficientValue();\n        if (msg.sender.code.length != 0) revert ExternalAccountOnly();\n        if (amount > transactionLimit || amount < 1)\n            revert InvalidPurchaseAmount();\n\n        for (uint256 i; i < amount; ) {\n            uint256 idx = getPseudorandom() % availableIdsLength;\n            uint256 id = availableIds[idx];\n\n            _mint(msg.sender, id, 1, \"\");\n\n            // `totalSupplyAll` needs to be incremented in the loop to provide a unique nonce for\n            // each call to `getPseudorandom()`.\n            unchecked {\n                ++i;\n                ++totalSupplyAll;\n                ++totalSupply[id];\n            }\n\n            // Remove the token from `availableIds` if it's reached the supply limit\n            if (totalSupply[id] == MAX_SUPPLY_PER_ID) removeIndex(idx);\n        }\n    }\n\n    /// @notice Returns a deterministically generated URI for the given token ID.\n    /// @return string\n    function uri(uint256 id) public view override returns (string memory) {\n        return\n            bytes(baseUri).length > 0\n                ? string(abi.encodePacked(baseUri, toString(id), \".json\"))\n                : \"\";\n    }\n\n    //////////////////////\n    /// Administration ///\n    //////////////////////\n\n    /// @notice Prevents any future changes to the URI of any token ID.\n    /// @dev Emits a `PermanentURI(string, uint256 indexed)` event for each token ID with the permanent URI.\n    function freezeMetadata() public onlyOwner {\n        metadataFrozen = true;\n        for (uint256 i = 0; i < 5; ++i) {\n            emit PermanentURI(uri(i), i);\n        }\n    }\n\n    /// @notice Updates the base of the generated URI returned by `uri(uint256)`.\n    /// @dev The URI event isn't emitted because there is no applicable ID to emit the event for. The\n    /// baseURI given here applies to all token IDs.\n    function setBaseUri(string memory newBaseUri) public onlyOwner {\n        if (metadataFrozen == true) revert FrozenMetadata();\n        baseUri = newBaseUri;\n    }\n\n    /// @notice Sets the current state of the sale. `false` will disable sale, `true` will enable it.\n    function setPurchaseable(bool state) public onlyOwner {\n        purchaseable = state;\n        emit Purchaseable(purchaseable);\n    }\n\n    /// @notice Withdraws entire balance of this contract to the `owner` address.\n    function withdrawEth() public onlyOwner {\n        (bool success, ) = owner.call{value: address(this).balance}(\"\");\n        if (!success) revert WithdrawFail();\n    }\n\n    /// @notice Sets the maximum purchase amount per transaction.\n    function setTransactionLimit(uint256 newTransactionLimit) public onlyOwner {\n        emit TransactionLimit(transactionLimit, newTransactionLimit);\n        transactionLimit = newTransactionLimit;\n    }\n\n    ////////////////\n    /// Internal ///\n    ////////////////\n\n    /// @dev Generates a pseudorandom number to use when determining an ID for purchase. True randomness isn't\n    /// necessary because IDs have no rarity (no ID is inherently more valuable than another).\n    function getPseudorandom() internal view returns (uint256) {\n        // solhint-disable not-rely-on-time\n        unchecked {\n            return\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            block.timestamp,\n                            msg.sender,\n                            totalSupplyAll\n                        )\n                    )\n                );\n        }\n        // solhint-enable not-rely-on-time\n    }\n\n    /// @dev Removes the specified index from the `availableIds` array. This function is used when the max supply\n    /// of the token ID at `index` has already been purchased. The index isn't checked because useage is internal.\n    function removeIndex(uint256 index) internal {\n        availableIds[index] = availableIds[availableIdsLength - 1];\n        availableIdsLength--;\n    }\n\n    /// @dev Taken from OpenZeppelin's implementation\n    /// (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol)\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
6     },
7     "contracts/solmate/tokens/ERC1155.sol": {
8       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*///////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 ownersLength = owners.length; // Saves MLOADs.\n\n        require(ownersLength == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < ownersLength; i++) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\ninterface ERC1155TokenReceiver {\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
9     },
10     "contracts/Ownable.sol": {
11       "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\n/// @title Ownable\n/// @notice Provides a modifier to authenticate contract owner.\n/// @dev The default owner is the contract deployer, but this can be modified\n/// afterwards using `transferOwnership`. There is no check when transferring\n/// ownership so ensure you don't use `address(0)` unintentionally. The modifier\n/// to guard functions with is `onlyOwner`.\n/// @author 0xMetas\n/// @author Based on OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol)\nabstract contract Ownable {\n    /// @notice This emits when the owner changes.\n    /// @param previousOwner The address of the previous owner.\n    /// @param newOwner The address of the new owner.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @dev Error thrown when `onlyOwner` is called by an address other than `owner`.\n    error NotOwner();\n\n    /// @notice The address of the owner.\n    address public owner;\n\n    /// @dev Sets the value of `owner` to `msg.sender`.\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// @dev Reverts if `msg.sender` is not `owner`.\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert NotOwner();\n        _;\n    }\n\n    /// @notice Sets the `owner` address to a new one.\n    /// @dev Use `address(0)` to renounce ownership.\n    /// @param newOwner The address of the new owner of the contract.\n    function transferOwnership(address newOwner) external onlyOwner {\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}\n"
12     }
13   },
14   "settings": {
15     "optimizer": {
16       "enabled": true,
17       "runs": 200
18     },
19     "outputSelection": {
20       "*": {
21         "*": [
22           "evm.bytecode",
23           "evm.deployedBytecode",
24           "devdoc",
25           "userdoc",
26           "metadata",
27           "abi"
28         ]
29       }
30     }
31   }
32 }}