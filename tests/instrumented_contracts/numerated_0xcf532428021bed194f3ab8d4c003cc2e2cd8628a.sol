1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/token/ERC721/presets/UniftyGovernance.sol": {
5       "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"./IUniftyGovernanceConsumer.sol\";\r\nimport \"./IERC20Simple.sol\";\r\nimport \"./IERC20Mintable.sol\";\r\n\r\n/* ################################\r\n    #\r\n    # UniftyGovernance\r\n    #\r\n    # Contract to propose and vote on community decisions.\r\n    # Distributes proposed grants as UNT to accepted consumers.\r\n    #\r\n    ######################################## */\r\n\r\ncontract UniftyGovernance {\r\n\r\n    /* ################################\r\n    #\r\n    # SETUP (partially proposable)\r\n    #\r\n    ######################################## */\r\n    \r\n    // nif address\r\n    address public nifAddress = 0x7e291890B01E5181f7ecC98D79ffBe12Ad23df9e;\r\n\r\n    // unt address\r\n    address public untAddress = 0xF8fCC10506ae0734dfd2029959b93E6ACe5b2a70;\r\n    \r\n    // epoch duration as timestamp, consisting of epochDuration and epochDurationMult\r\n    uint256 public epochDuration = 86400 * 30;\r\n\r\n    // the initial reward at epoch 1\r\n    uint256 public genesisReward = 50000000 * 10**18;\r\n    \r\n    // the maximum duration of a proposal\r\n    uint256 public maxProposalDuration = 86400 * 7;\r\n\r\n    // proposal duration\r\n    // the duration a proposal will be kept open at minimum\r\n    uint256 public minProposalDuration = 86400 * 2;\r\n    \r\n    // the max. amount of time a proposal may be executed after the proposal period has been accepted and ended\r\n    uint256 public proposalExecutionLimit = 86400 * 7;\r\n    \r\n    // min amount of nif required for a proposal to conclude\r\n    uint256 public quorum = 150000 * 10**18;\r\n    \r\n    // minimum nif staking for the governance per user.\r\n    // if below, a staker cannot propose or vote but stake and allocate to peers\r\n    uint256 public minNifStake = 10 * 10**18;\r\n\r\n    // minimum nif staking for the governance\r\n    uint256 public minNifOverallStake = 150000 * 10**18;\r\n\r\n    // the min nif being staked in the governance required for consumers receiving UNT\r\n    uint256 public minNifConsumptionStake = 150000 * 10**18;\r\n\r\n    // the timelock that nif needs to stay locked at minimum\r\n    uint256 public nifStakeTimelock = 86400 * 14;\r\n    \r\n    // for selected timestamp relevant lookups, we use a general gracetime\r\n    uint public graceTime = 60 * 15;\r\n    \r\n    /* ################################\r\n    #\r\n    # RUNTIME MEMBERS\r\n    #\r\n    ######################################## */\r\n    \r\n    // all nif stakes of a user (user => stake)\r\n    mapping(address => LUniftyGovernance.NifStake) public userNifStakes;\r\n    \r\n    // counts the amount of proposals\r\n    uint256 public proposalCounter;\r\n\r\n    // proposalID => proposal\r\n    mapping(uint256 => LUniftyGovernance.Proposal) public proposals;\r\n\r\n    // proposalID => proposal\r\n    mapping(uint256 => LUniftyGovernance.Uint256Proposal) public uint256Proposal;\r\n\r\n    // proposalID => address\r\n    mapping(uint256 => LUniftyGovernance.AddressProposal) public addressProposal;\r\n\r\n    // proposalID => votes\r\n    mapping(uint256 => LUniftyGovernance.Vote[]) public votes;\r\n\r\n    // counts the amount of votes\r\n    // proposalID => vote count\r\n    mapping(uint256 => uint256) public votesCounter;\r\n    \r\n    // all nif stakes within this governance\r\n    uint256 public allNifStakes;\r\n\r\n    // allocations for the different consumers and their peers\r\n    mapping(IUniftyGovernanceConsumer => mapping( address => uint256 ) ) public consumerPeerNifAllocation;\r\n    \r\n    // the amount of allocators for the peer\r\n    mapping(IUniftyGovernanceConsumer => mapping( address => uint256 ) ) public nifAllocationLength;\r\n    \r\n    // allocations for consumers\r\n    mapping(IUniftyGovernanceConsumer => uint256) public consumerNifAllocation;\r\n    uint256 public nifAllocation;\r\n\r\n    // governance pause flag\r\n    bool public pausing = false;\r\n\r\n    // when the accrue started since contract creation\r\n    uint256 public accrueStart;\r\n\r\n    // consumers who may receive UNT for further processing\r\n    mapping(uint256 => LUniftyGovernance.Consumer) public consumers;\r\n    \r\n    // flat list of peers, each peer is supposed to be unique to the governance\r\n    mapping(address => bool) public peerExists;\r\n    \r\n    // counter to be used with consumers\r\n    // unlike the proposalCounter, we start with 1 here as we need 0 to determine an empty consumer situation.\r\n    uint256 public consumerCounter = 1;\r\n\r\n    // returns the consumer id or 0 if not set\r\n    mapping(IUniftyGovernanceConsumer => uint256) public consumerIdByType;\r\n    \r\n    // mapping consumer => peer for global use to check if those exist\r\n    mapping(IUniftyGovernanceConsumer => mapping( address => bool )) public consumerPeerExists;\r\n    \r\n    // the currently granted unt across all consumers\r\n    uint256 public grantedUnt;\r\n    \r\n    // the unt that has been minted so far across all consumers\r\n    uint256 public mintedUnt;\r\n\r\n    // how much UNT has a consumer minted so far\r\n    mapping(IUniftyGovernanceConsumer => uint256) public mintedUntConsumer;\r\n    \r\n    // list of executives for the governance contracts.\r\n    // execs may execute accepted proposals and pause the governance in case of emergencies.\r\n    // they are obliged to obey to governance decision and supposed to execute accepted proposals.\r\n    mapping(address => bool) public isExecutive;\r\n    \r\n    // the current credit after unlock requests per user\r\n    mapping(address => uint256) public credit;\r\n\r\n    /* ################################\r\n    #\r\n    # RE-ENTRANCY GUARD\r\n    #\r\n    ######################################## */\r\n\r\n    // re-entrancy protection\r\n    uint256 private unlocked = 1;\r\n\r\n    modifier lock() {\r\n        require(unlocked == 1, 'UniftyGovernance: LOCKED');\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    /* ################################\r\n    #\r\n    # EVENTS\r\n    #\r\n    ######################################## */\r\n\r\n    event Allocated(address indexed user, IUniftyGovernanceConsumer consumer, address peer, uint256 untEarned);\r\n    event Dellocated(address indexed user, IUniftyGovernanceConsumer consumer, address peer, uint256 untEarned);\r\n    event Staked(address indexed user, uint256 stake, bool peerAccepted, uint256 untEarned);\r\n    event Unstaked(address indexed user, uint256 unstake, bool peerAccepted, uint256 untEarned);\r\n    event Withdrawn(address indexed user, uint256 amount);\r\n    event Proposed(address indexed initiator, uint256 indexed proposalId, uint256 expires, uint256 actionId);\r\n    event Voted(address indexed voter, uint256 indexed proposalId, uint256 indexed voteId, bool supporting, uint256 power);\r\n    event Executed(address indexed executor, uint256 indexed proposalId);\r\n\r\n    /**\r\n     * Sets the accrueStart value, marking the begin of the first epoch.\r\n     * \r\n     * */\r\n    constructor(){\r\n\r\n        accrueStart = block.timestamp;\r\n        isExecutive[msg.sender] = true;\r\n    }\r\n    \r\n    /* ################################\r\n    #\r\n    # NIF STAKING\r\n    #\r\n    ######################################## */\r\n\r\n    /**\r\n     * Simple NIF staking.\r\n     *\r\n     * If not paused, frozen and the minNif is being sent or already available, staking is allowed.\r\n     *\r\n     * No further state changes to anyone's staked nif is performed other than individual unstaking.\r\n     *\r\n     * This is to make sure that nif funds can be unstaked at any time after the timelock expired, under any circumstance.\r\n     *\r\n     * Returns false if an allocation update to a peer silently failed and the earned unt.\r\n     * */\r\n    function stake(uint256 _stake) external lock returns(bool, uint256){\r\n\r\n        // here we ask for the pausing flag, not isPausing() as the latter is also true if overall nif stakes are too low\r\n        // so we couldn't stake in the first place.\r\n        require(!pausing, \"stake: pausing, sorry.\");\r\n        require(_stake > 0, \"stake: invalid staking amount.\");\r\n\r\n        bool accepted = true;\r\n        uint256 untEarned = 0;\r\n\r\n        uint256 prevAmount = userNifStakes[msg.sender].amount;\r\n        userNifStakes[msg.sender].amount += _stake;\r\n        userNifStakes[msg.sender].unstakableFrom = block.timestamp + nifStakeTimelock;\r\n        \r\n        allNifStakes += _stake;\r\n        \r\n        // adding new stakes will reset the allocation time if an allocation exists already\r\n        if(address(userNifStakes[msg.sender].peerConsumer) != address(0) && consumerIdByType[ userNifStakes[msg.sender].peerConsumer ] != 0){\r\n\r\n            uint256 prevAllocation = consumerPeerNifAllocation[ userNifStakes[msg.sender].peerConsumer ][ userNifStakes[msg.sender].peer ];\r\n            consumerPeerNifAllocation[ userNifStakes[msg.sender].peerConsumer ][ userNifStakes[msg.sender].peer ] += _stake;\r\n            consumerNifAllocation[ userNifStakes[msg.sender].peerConsumer ] += _stake;\r\n            nifAllocation += _stake;\r\n            userNifStakes[msg.sender].peerAllocationTime = block.timestamp;\r\n            \r\n            try userNifStakes[msg.sender].peerConsumer.allocationUpdate(\r\n                msg.sender, \r\n                prevAmount, \r\n                prevAllocation, \r\n                userNifStakes[msg.sender].peer\r\n            ) \r\n                returns(bool _accepted, uint256 _untEarned)\r\n            {\r\n                \r\n                accepted = _accepted;\r\n                untEarned = _untEarned;\r\n                \r\n            } catch {}\r\n            \r\n            require(accepted, \"stake: allocation update has been rejected.\");\r\n        }\r\n        \r\n        IERC20Simple(nifAddress).transferFrom(msg.sender, address(this), _stake);\r\n\r\n        emit Staked(msg.sender, _stake, accepted, untEarned);\r\n        \r\n        return (accepted, untEarned);\r\n    }\r\n    \r\n    /**\r\n     * Returns credited NIF after the cooldown period.\r\n     * \r\n     * */\r\n    function withdraw() external lock {\r\n        \r\n        require(pausing || block.timestamp >= userNifStakes[msg.sender].unstakableFrom + graceTime, \"withdraw: nif still locked.\");\r\n        \r\n        uint256 tmp = credit[msg.sender];\r\n        credit[msg.sender] = 0;\r\n        IERC20Simple(nifAddress).transfer(msg.sender, tmp);\r\n        emit Withdrawn(msg.sender, tmp);\r\n    }\r\n\r\n    /**\r\n     * Unstaking is allowed at any given time (after min period and if peers allow it signalled through frozen()).\r\n     *\r\n     * Unstaking removes voting power.\r\n     *\r\n     * returns potential unt earned and sends it to the account.\r\n     * \"potentially\" as it depends on the consumer's implementation.\r\n     * \r\n     * returns true or false if the allocationUpdate has been accepted by the peer and the earned unt from allocated peer.\r\n     * */\r\n    function unstake(uint256 _unstaking) external lock returns(bool, uint256){\r\n        \r\n        require(userNifStakes[msg.sender].amount > 0 && userNifStakes[msg.sender].amount >= _unstaking, \"unstakeInternal: insufficient funds.\");\r\n        \r\n        bool accepted = true;\r\n        uint256 untEarned = 0;\r\n        \r\n        userNifStakes[msg.sender].unstakableFrom = block.timestamp + nifStakeTimelock;\r\n        credit[msg.sender] += _unstaking;\r\n        \r\n        if(userNifStakes[msg.sender].amount - _unstaking == 0){\r\n            \r\n            untEarned = dellocateInternal(msg.sender);\r\n            \r\n            // dellocate above needs the current staking amounts prior removing them.\r\n            // since we use re-entrancy guarding, the below is not exploitable.\r\n            userNifStakes[msg.sender].amount -= _unstaking;\r\n            allNifStakes -= _unstaking;\r\n            \r\n        }\r\n        else if(\r\n            userNifStakes[msg.sender].amount - _unstaking != 0 && \r\n            address(userNifStakes[msg.sender].peerConsumer) != address(0) && \r\n            consumerIdByType[ userNifStakes[msg.sender].peerConsumer ] != 0\r\n        ) {\r\n            \r\n            uint256 prevAmount = userNifStakes[msg.sender].amount;\r\n            userNifStakes[msg.sender].amount -= _unstaking;\r\n            allNifStakes -= _unstaking;\r\n            \r\n            uint256 prevAllocation = consumerPeerNifAllocation[ userNifStakes[msg.sender].peerConsumer ][ userNifStakes[msg.sender].peer ];\r\n            consumerPeerNifAllocation[ userNifStakes[msg.sender].peerConsumer ][ userNifStakes[msg.sender].peer ] -= _unstaking;\r\n            consumerNifAllocation[ userNifStakes[msg.sender].peerConsumer ] -= _unstaking;\r\n            nifAllocation -= _unstaking;\r\n            \r\n            userNifStakes[msg.sender].peerAllocationTime = block.timestamp;\r\n            \r\n            try userNifStakes[msg.sender].peerConsumer.allocationUpdate(\r\n                msg.sender, \r\n                prevAmount, \r\n                prevAllocation, \r\n                userNifStakes[msg.sender].peer\r\n            ) \r\n                returns(bool _accepted, uint256 _untEarned)\r\n            {\r\n                accepted = _accepted;\r\n                untEarned = _untEarned;\r\n                \r\n            } catch {}\r\n        }\r\n        else\r\n        {\r\n            \r\n            userNifStakes[msg.sender].amount -= _unstaking;\r\n            allNifStakes -= _unstaking;\r\n        }\r\n        \r\n        emit Unstaked(msg.sender, _unstaking, accepted, untEarned);\r\n        return (accepted, untEarned);\r\n    }\r\n    \r\n    /**\r\n     * Allocates stakes to a consumer's peer.\r\n     * Fails if an allocated peer does not accept the allocation.\r\n     * \r\n     * returns the earned unt from the previous peer if any.\r\n     * */\r\n    function allocate(IUniftyGovernanceConsumer _consumer, address _peer) external lock returns(uint256) {\r\n        \r\n        require(!isPausing(), \"allocate: pausing, sorry.\");\r\n        require(userNifStakes[msg.sender].amount > 0, \"allocate: you must stake first.\");\r\n        require(_peer != address(0) && address(_consumer) != address(0), \"allocate: peer and consumer mustn't be null.\" );\r\n        require(consumerIdByType[ _consumer ] != 0, \"allocate: consumer doesn't exist.\");\r\n        require(consumerPeerExists[ _consumer ][ _peer ], \"allocate: peer doesn't exist.\");\r\n        require(userNifStakes[msg.sender].peer != _peer, \"allocate: you are allocating to this peer already.\");\r\n        require(!frozen(msg.sender), \"allocate: cannot dellocate, allocation still frozen by current consumer.\");\r\n        \r\n        uint256 untEarned = dellocateInternal(msg.sender); \r\n        \r\n        userNifStakes[msg.sender].peerConsumer = _consumer;\r\n        userNifStakes[msg.sender].peer = _peer;\r\n        userNifStakes[msg.sender].peerAllocationTime = block.timestamp;\r\n        \r\n        uint256 prevAllocation = consumerPeerNifAllocation[ _consumer ][ _peer ];\r\n        consumerPeerNifAllocation[ _consumer ][ _peer ] += userNifStakes[msg.sender].amount;\r\n        consumerNifAllocation[ _consumer ] += userNifStakes[msg.sender].amount;\r\n        nifAllocation += userNifStakes[msg.sender].amount;\r\n        nifAllocationLength[ userNifStakes[msg.sender].peerConsumer ][ userNifStakes[msg.sender].peer ] += 1;\r\n        \r\n        bool accepted = false;\r\n        try _consumer.allocate(msg.sender, prevAllocation, _peer) returns(bool _accepted) { \r\n            accepted = _accepted;\r\n        }\r\n        catch{ }\r\n        \r\n        // we do NOT use assert() here because there is no reason to panic.\r\n        require(accepted, \"allocate: allocation denied by consumer/peer or consumer is faulty.\");\r\n        \r\n        emit Allocated(msg.sender, _consumer, _peer, untEarned);\r\n        return untEarned;\r\n    }\r\n    \r\n    /**\r\n     * Dellocates a user's peer-allocation\r\n     * \r\n     * */\r\n    function dellocate() external lock returns(uint256) {\r\n        \r\n        require(address(userNifStakes[msg.sender].peerConsumer) != address(0), \"dellocatePeer: nothing to dellocate.\");\r\n        \r\n        return dellocateInternal(msg.sender);\r\n        \r\n    }\r\n    \r\n    /**\r\n     * dellocates from an account's peer.\r\n     * \r\n     * consumer.dellocate() in the end is \r\n     * a) a trusted contract\r\n     * b) never called outside of re-entrancy guard-protected function\r\n     * \r\n     * returns potential unt earnings being sent to the wallet alongside the dellocation.\r\n     * */\r\n    function dellocateInternal(address _sender) internal returns(uint256){\r\n        \r\n        if(address(userNifStakes[_sender].peerConsumer) == address(0)) { return 0; }\r\n        \r\n        // we allow dellocation upon pausing as it would indicate major trouble \r\n        // and unstaking NIF should be possible at all costs.\r\n        require(!frozen(_sender) || pausing, \"dellocateInternal: cannot dellocate, allocation still frozen by consumer.\");\r\n        \r\n        IUniftyGovernanceConsumer tmpConsumer = userNifStakes[_sender].peerConsumer;\r\n        address tmpPeer = userNifStakes[_sender].peer;\r\n        uint256 untEarned = 0;\r\n        \r\n        uint256 prevAllocation = consumerPeerNifAllocation[ tmpConsumer ][ tmpPeer ];\r\n        consumerPeerNifAllocation[ tmpConsumer ][ tmpPeer ] -= userNifStakes[_sender].amount;\r\n        consumerNifAllocation[ tmpConsumer ] -= userNifStakes[_sender].amount;\r\n        nifAllocation -= userNifStakes[_sender].amount;\r\n        nifAllocationLength[ tmpConsumer ][ tmpPeer ] -= 1;\r\n        \r\n        userNifStakes[_sender].peerConsumer = IUniftyGovernanceConsumer(address(0));\r\n        userNifStakes[_sender].peer = address(0);\r\n        userNifStakes[_sender].peerAllocationTime = block.timestamp;\r\n        \r\n        if(consumerIdByType[ tmpConsumer ] != 0){\r\n            try tmpConsumer.dellocate(_sender, prevAllocation, tmpPeer) returns(uint256 _untEarned){ \r\n                untEarned = _untEarned;\r\n            }catch{ }\r\n        }\r\n        \r\n        emit Dellocated(_sender, tmpConsumer, tmpPeer, untEarned);\r\n        return untEarned;\r\n    }\r\n    \r\n    /**\r\n     * Checks if the consumer and peer an account allocated funds are frozen or not.\r\n     * \r\n     * */\r\n    function frozen(address _account) public view returns(bool){\r\n        \r\n        bool exists = consumerPeerExists[ userNifStakes[_account].peerConsumer ][ userNifStakes[_account].peer ];\r\n        \r\n        if(exists){\r\n            \r\n            // this won't stop malicious consumers from not releasing allocations\r\n            // but it will at least help unfreezing allocations if consumers didn't implement peer handling properly\r\n            // or if a peer has been removed while the user is still allocating.\r\n            //\r\n            // malicious/broken consumers should be spotted prior acceptance through contract reviews or being removed through proposals if slipping through.\r\n            \r\n            bool existsInConsumer = false;\r\n            \r\n            try userNifStakes[_account].peerConsumer.peerWhitelisted( userNifStakes[_account].peer ) returns(bool result){\r\n                \r\n                existsInConsumer = result;\r\n                \r\n            }catch{}\r\n            \r\n            if(!existsInConsumer){\r\n                \r\n                return false;\r\n            }\r\n            \r\n            // in case of missing or faulty implementation of frozen() in the consumer, we want to catch that and signal nothing is being frozen\r\n            \r\n            try userNifStakes[_account].peerConsumer.frozen(_account) returns(bool result){\r\n                \r\n                return result;\r\n                \r\n            }catch{}\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * The userNifStakes struct as accountInfo as convenience function for external callers.\r\n     * \r\n     * Returns nulled peer allocations if the peer doesn't exist any longer, \r\n     * so this should be called externally to get proper information about the current peer state of an account.\r\n     * \r\n     * */\r\n    function accountInfo(address _account) external view returns(IUniftyGovernanceConsumer, address, uint256, uint256, uint256){\r\n        \r\n        bool exists = consumerPeerExists[ userNifStakes[_account].peerConsumer ][ userNifStakes[_account].peer ];\r\n        \r\n        IUniftyGovernanceConsumer consumer = userNifStakes[_account].peerConsumer;\r\n        address peer = userNifStakes[_account].peer;\r\n        uint256 allocationTime = userNifStakes[_account].peerAllocationTime;\r\n        \r\n        if(!exists){\r\n            \r\n            consumer = IUniftyGovernanceConsumer(address(0));\r\n            peer = address(0);\r\n            allocationTime = 0;\r\n        }\r\n        \r\n        return ( \r\n            consumer,\r\n            peer,  \r\n            allocationTime,\r\n            userNifStakes[_account].unstakableFrom,\r\n            userNifStakes[_account].amount\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * The consumer struct info as convenience function for external callers.\r\n     * \r\n     * */\r\n    function consumerInfo(IUniftyGovernanceConsumer _consumer) external view returns(uint256, uint256, uint256, address[] memory){\r\n        \r\n        LUniftyGovernance.Consumer memory con = consumers[ consumerIdByType[ _consumer ] ];\r\n        \r\n        return ( \r\n            con.grantStartTime,\r\n            con.grantRateSeconds,\r\n            con.grantSizeUnt,\r\n            con.peers\r\n        );\r\n    }\r\n\r\n    /* ################################\r\n    #\r\n    # PROPOSALS & VOTES\r\n    #\r\n    ######################################## */\r\n\r\n    /**\r\n     *\r\n     * Action ID = 1\r\n     *\r\n     * */\r\n    function proposeMinNifOverallStake(uint256 _minNifOverallStake, uint256 _duration, string calldata _url) external lock{\r\n\r\n        /**\r\n         * newProposal() is an internal call, not externally, so this does NOT cause risks.\r\n         * Also re-entrancy guards are consistently used.\r\n         * \r\n         * */\r\n        uint256 pid = newProposal(msg.sender, _duration, _url, 1);\r\n        uint256Proposal[pid].value = _minNifOverallStake;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Action ID = 2\r\n     *\r\n     * */\r\n    function proposeMinNifStake(uint256 _minNifStake, uint256 _duration, string calldata _url) external lock{\r\n\r\n        uint256 pid = newProposal(msg.sender, _duration, _url, 2);\r\n        uint256Proposal[pid].value = _minNifStake;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Action ID = 3\r\n     *\r\n     * _percentages must be current consumers length + 1.\r\n     *\r\n     * The last item in _percentages is the percentage for the currently proposed consumer.\r\n     *\r\n     * */\r\n    function proposeAddConsumer(IUniftyGovernanceConsumer _consumer, uint256 _sizeUnt, uint256 _rateSeconds, uint256 _startTime, uint256 _duration, string calldata _url) external lock{\r\n\r\n        require(address(_consumer) != address(0), \"proposeAddConsumer: consumer may not be the null address.\");\r\n        require(consumerIdByType[ _consumer ] == 0, \"proposeAddConsumer: consumer exists already.\");\r\n        require(_rateSeconds != 0, \"proposeAddConsumer: invalid rate\");\r\n        require(_sizeUnt != 0, \"proposeAddConsumer: invalid grant size.\");\r\n      \r\n        uint256 pid = newProposal(msg.sender, _duration, _url, 3);\r\n        addressProposal[pid].value = address(_consumer);\r\n        uint256Proposal[pid].value = _sizeUnt;\r\n        uint256Proposal[pid].value3 = _rateSeconds;\r\n        uint256Proposal[pid].value4 = _startTime;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Action ID = 4\r\n     *\r\n     * */\r\n    function proposeRemoveConsumer(IUniftyGovernanceConsumer _consumer, uint256 _duration, string calldata _url) external lock{\r\n\r\n        require(address(_consumer) != address(0), \"proposeRemoveConsumer: consumer may not be the null address.\");\r\n        require(consumers[ consumerIdByType[ _consumer ] ].consumer == _consumer , \"proposeRemoveConsumer: consumer not found.\");\r\n        uint256 pid = newProposal(msg.sender, _duration, _url, 4);\r\n        addressProposal[pid].value = address(_consumer);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Action ID = 5\r\n     *\r\n     * */\r\n    function proposeConsumerWhitelistPeer(IUniftyGovernanceConsumer _consumer, address _peer, uint256 _duration, string calldata _url) external lock{\r\n\r\n        require(_peer != address(0), \"proposeConsumerWhitelistPeer: peer may not be the null address.\");\r\n        require(!consumerPeerExists[ _consumer ][ _peer ], \"proposeConsumerWhitelistPeer: peer exists already.\");\r\n        require(!peerExists[_peer], \"proposeConsumerWhitelistPeer: peer exists already.\");\r\n        \r\n        uint256 pid = newProposal(msg.sender, _duration, _url, 5);\r\n        addressProposal[pid].value = _peer;\r\n        addressProposal[pid].value3 = address(_consumer);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Action ID = 6\r\n     *\r\n     * */\r\n    function proposeConsumerRemovePeerFromWhitelist(IUniftyGovernanceConsumer _consumer, address _peer, uint256 _duration, string calldata _url) external lock{\r\n\r\n        require(address(_consumer) != address(0), \"proposeConsumerRemovePeerFromWhitelist: consumer may not be the null address.\");\r\n        require(consumers[ consumerIdByType[ _consumer ] ].consumer == _consumer , \"proposeConsumerRemovePeerFromWhitelist: consumer not found.\");\r\n        require(consumerPeerExists[ _consumer ][ _peer ], \"proposeConsumerRemovePeerFromWhitelist: peer not found.\");\r\n        \r\n        uint256 pid = newProposal(msg.sender, _duration, _url, 6);\r\n        addressProposal[pid].value = _peer;\r\n        addressProposal[pid].value2.push(address(_consumer));\r\n    }\r\n    \r\n    /**\r\n     *\r\n     * Action ID = 7\r\n     *\r\n     * */\r\n    function proposeUpdateConsumerGrant(IUniftyGovernanceConsumer _consumer, uint256 _sizeUnt, uint256 _rateSeconds, uint256 _startTime, uint256 _duration, string calldata _url) external lock{\r\n\r\n        require(consumerIdByType[ _consumer ] != 0, \"updateConsumerGrant: consumer doesn't exist.\");\r\n        require(_rateSeconds != 0, \"updateConsumerGrant: invalid rate\");\r\n        require(_sizeUnt != 0, \"proposeUpdateConsumerGrant: invalid grant size.\");\r\n        \r\n        uint256 pid = newProposal(msg.sender, _duration, _url, 7);\r\n        addressProposal[pid].value = address(_consumer);\r\n        uint256Proposal[pid].value = _sizeUnt;\r\n        uint256Proposal[pid].value3 = _rateSeconds;\r\n        uint256Proposal[pid].value4 = _startTime;\r\n    }\r\n    \r\n    /**\r\n     *\r\n     * Action ID = 8\r\n     *\r\n     * */\r\n    function proposeMinNifConsumptionStake(uint256 _minNifConsumptionStake, uint256 _duration, string calldata _url) external lock{\r\n\r\n        uint256 pid = newProposal(msg.sender, _duration, _url, 8);\r\n        uint256Proposal[pid].value = _minNifConsumptionStake;\r\n    }\r\n    \r\n    /**\r\n     *\r\n     * Action ID = 9\r\n     *\r\n     * */\r\n    function proposeGeneral( uint256 _duration, string calldata _url) external lock{\r\n\r\n       newProposal(msg.sender, _duration, _url, 9);\r\n    }\r\n    \r\n    /**\r\n     *\r\n     * Action ID = 10\r\n     *\r\n     * */\r\n    function proposeMaxProposalDuration( uint256 _maxProposalDuration, uint256 _duration, string calldata _url) external lock{\r\n\r\n       uint256 pid = newProposal(msg.sender, _duration, _url, 10);\r\n       uint256Proposal[pid].value = _maxProposalDuration;\r\n    }\r\n    \r\n    /**\r\n     *\r\n     * Action ID = 11\r\n     *\r\n     * */\r\n    function proposeMinProposalDuration( uint256 _minProposalDuration, uint256 _duration, string calldata _url) external lock{\r\n\r\n       uint256 pid = newProposal(msg.sender, _duration, _url, 11);\r\n       uint256Proposal[pid].value = _minProposalDuration;\r\n    }\r\n    \r\n    /**\r\n     *\r\n     * Action ID = 12\r\n     *\r\n     * */\r\n    function proposeProposalExecutionLimit(uint256 _proposalExecutionLimit, uint256 _duration, string calldata _url) external lock{\r\n\r\n       uint256 pid = newProposal(msg.sender, _duration, _url, 12);\r\n       uint256Proposal[pid].value = _proposalExecutionLimit;\r\n    }\r\n    \r\n    /**\r\n     *\r\n     * Action ID = 13\r\n     *\r\n     * */\r\n    function proposeQuorum(uint256 _quorum, uint256 _duration, string calldata _url) external lock{\r\n\r\n       uint256 pid = newProposal(msg.sender, _duration, _url, 13);\r\n       uint256Proposal[pid].value = _quorum;\r\n    }\r\n    \r\n    /**\r\n     *\r\n     * Action ID = 14\r\n     *\r\n     * */\r\n    function proposeNifStakeTimelock(uint256 _nifStakeTimelock, uint256 _duration, string calldata _url) external lock{\r\n\r\n       uint256 pid = newProposal(msg.sender, _duration, _url, 14);\r\n       uint256Proposal[pid].value = _nifStakeTimelock;\r\n    }\r\n    \r\n\r\n    /**\r\n     * A new proposal implies the initiator is in support of proposal (counts as vote already).\r\n     * He does not, nor can't, vote once he placed a proposal.\r\n     *\r\n     * */\r\n    function newProposal(address _sender, uint256 _duration, string memory _url, uint256 _actionId) internal returns(uint256){\r\n\r\n        require(!isPausing(), \"newProposal: pausing, sorry.\");\r\n        require(_duration <= maxProposalDuration, \"newProposal: duration too long.\");\r\n        require(_duration >= minProposalDuration, \"newProposal: min. duration too short.\");\r\n        require(userNifStakes[_sender].amount >= minNifStake, \"newProposal: invalid stake.\");\r\n\r\n        // we assume the initiator is supporting the proposal when opening it\r\n        proposals[ proposalCounter ].initiator = _sender;\r\n        proposals[ proposalCounter ].url = _url;\r\n        proposals[ proposalCounter ].numVotes += 1;\r\n        proposals[ proposalCounter ].numSupporting += userNifStakes[_sender].amount;\r\n        proposals[ proposalCounter ].proposalId = proposalCounter;\r\n        proposals[ proposalCounter ].voted[_sender] = true;\r\n        proposals[ proposalCounter ].openUntil = block.timestamp + _duration;\r\n        proposals[ proposalCounter ].actionId = _actionId;\r\n\r\n        emit Proposed(_sender, proposalCounter, proposals[ proposalCounter ].openUntil, _actionId);\r\n\r\n        votes[ proposalCounter ].push(LUniftyGovernance.Vote({\r\n            voter: _sender,\r\n            supporting: true,\r\n            power: userNifStakes[_sender].amount,\r\n            proposalId: proposalCounter,\r\n            voteTime: block.timestamp\r\n        }));\r\n        \r\n        emit Voted(_sender, proposalCounter, votesCounter[ proposalCounter ] + 1, true, userNifStakes[_sender].amount);\r\n\r\n        uint256 ret = proposalCounter;\r\n\r\n        // starts at 0, not 1 as we can loop \"normally\" from 0 to n-1 with clients\r\n\r\n        votesCounter[ proposalCounter ] += 1;\r\n\r\n        // ...same for the proposal counter\r\n\r\n        proposalCounter += 1;\r\n\r\n        return ret;\r\n\r\n    }\r\n\r\n    /**\r\n     * A vote for a proposal uses the user nif earned points as voting power.\r\n     *\r\n     * */\r\n    function vote(uint256 _proposalId, bool _supporting) external lock {\r\n\r\n        require(!isPausing(), \"vote: pausing, sorry.\");\r\n        require(userNifStakes[msg.sender].amount >= minNifStake, \"vote: invalid stake.\");\r\n        require(proposals[ _proposalId ].initiator != address(0) && block.timestamp <= proposals[ _proposalId ].openUntil, \"vote: invalid or expired proposal.\");\r\n        require(!proposals[ _proposalId ].voted[msg.sender], \"vote: you voted already.\");\r\n\r\n        proposals[ _proposalId ].numVotes += 1;\r\n\r\n        if(_supporting){\r\n\r\n            proposals[ _proposalId ].numSupporting += userNifStakes[msg.sender].amount;\r\n\r\n        }else{\r\n\r\n            proposals[ _proposalId ].numNotSupporting += userNifStakes[msg.sender].amount;\r\n        }\r\n\r\n        proposals[ _proposalId ].voted[msg.sender] = true;\r\n\r\n        votes[ _proposalId ].push(LUniftyGovernance.Vote({\r\n            voter: msg.sender,\r\n            supporting: _supporting,\r\n            power: userNifStakes[msg.sender].amount,\r\n            proposalId: _proposalId,\r\n            voteTime: block.timestamp\r\n        }));\r\n\r\n        emit Voted(msg.sender, _proposalId, votesCounter[ _proposalId ], _supporting, userNifStakes[msg.sender].amount);\r\n\r\n        votesCounter[ _proposalId ] += 1;\r\n    }\r\n    \r\n    /**\r\n     * For clients with ABI v1 support\r\n     * \r\n     * */\r\n    function voted(uint256 _proposalId, address _account) external view returns(bool){\r\n        \r\n        return proposals[_proposalId].voted[_account];\r\n    }\r\n    \r\n    /**\r\n     * service function\r\n     * \r\n     * */\r\n    function uint256ProposalInfo(uint256 _proposalId) external view returns(uint256, uint256, uint256, uint256[] memory){\r\n      \r\n        return (\r\n            uint256Proposal[_proposalId].value,\r\n            uint256Proposal[_proposalId].value3,\r\n            uint256Proposal[_proposalId].value4,\r\n            uint256Proposal[_proposalId].value2\r\n        );\r\n    }\r\n    \r\n    function addressProposalInfo(uint256 _proposalId) external view returns(address, address, address[] memory){\r\n      \r\n        return (\r\n            addressProposal[_proposalId].value,\r\n            addressProposal[_proposalId].value3,\r\n            addressProposal[_proposalId].value2\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * Triggers the corresponding action if the vote is concluded in favor of support and expired.\r\n     *\r\n     * */\r\n    function execute(uint256 _proposalId) external lock{\r\n\r\n        require(!isPausing(), \"execute: pausing, sorry.\");\r\n        require(isExecutive[msg.sender], \"execute: not an executive.\");\r\n        require(proposals[ _proposalId ].initiator != address(0), \"execute: invalid proposal.\");\r\n        require(!proposals[ _proposalId ].executed, \"execute: proposal has been executed already.\");\r\n        require(proposals[ _proposalId ].numSupporting + proposals[ _proposalId ].numNotSupporting >= quorum, \"execute: quorum not reached.\");\r\n        require(proposals[ _proposalId ].numSupporting > proposals[ _proposalId ].numNotSupporting, \"execute: not enough support.\");\r\n        require(proposals[ _proposalId ].numVotes > 1, \"execute: need at least 2 votes.\");\r\n        require(block.timestamp > proposals[ _proposalId ].openUntil + graceTime, \"execute: voting and grace time not yet ended.\");\r\n        require(block.timestamp < proposals[ _proposalId ].openUntil + graceTime + proposalExecutionLimit, \"execute: execution window expired.\");\r\n        \r\n        proposals[ _proposalId ].executed = true;\r\n\r\n        // Action ID = 1\r\n        if(proposals[ _proposalId ].actionId == 1){\r\n\r\n            minNifOverallStake = uint256Proposal[_proposalId].value;\r\n\r\n            // Action ID = 2\r\n        } else if(proposals[ _proposalId ].actionId == 2){\r\n\r\n            minNifStake = uint256Proposal[_proposalId].value;\r\n\r\n            // Action ID = 8\r\n        } else if(proposals[ _proposalId ].actionId == 8){\r\n\r\n            minNifConsumptionStake = uint256Proposal[_proposalId].value;\r\n\r\n            // Action ID = 10\r\n        } else if(proposals[ _proposalId ].actionId == 10){\r\n\r\n            maxProposalDuration = uint256Proposal[_proposalId].value;\r\n\r\n            // Action ID = 11\r\n        } else if(proposals[ _proposalId ].actionId == 11){\r\n\r\n            minProposalDuration = uint256Proposal[_proposalId].value;\r\n\r\n            // Action ID = 12\r\n        } else if(proposals[ _proposalId ].actionId == 12){\r\n\r\n            proposalExecutionLimit = uint256Proposal[_proposalId].value;\r\n\r\n            // Action ID = 13\r\n        } else if(proposals[ _proposalId ].actionId == 13){\r\n\r\n            quorum = uint256Proposal[_proposalId].value;\r\n\r\n            // Action ID = 14\r\n        } else if(proposals[ _proposalId ].actionId == 14){\r\n\r\n            nifStakeTimelock = uint256Proposal[_proposalId].value;\r\n\r\n            // Action ID = 3\r\n        } else if(proposals[ _proposalId ].actionId == 3){\r\n\r\n            require(consumerIdByType[ IUniftyGovernanceConsumer( addressProposal[ _proposalId ].value ) ] == 0, \"execute: action id 3 => consumer exists already.\");\r\n            require(grantableUnt() >= uint256Proposal[_proposalId].value, \"exeute: action id 3 => not enough available UNT.\" );\r\n            require(uint256Proposal[_proposalId].value3 != 0, \"execute: action id 3 => invalid rate\");\r\n            \r\n            // setting the proposed startTime to now if it got in the past in the meanwhile \r\n            if(uint256Proposal[_proposalId].value4 < block.timestamp){\r\n                \r\n                uint256Proposal[_proposalId].value4 = block.timestamp;\r\n            }\r\n\r\n            grantedUnt += uint256Proposal[_proposalId].value;\r\n\r\n            consumers[ consumerCounter ].consumer = IUniftyGovernanceConsumer( addressProposal[ _proposalId ].value );\r\n            consumers[ consumerCounter ].grantSizeUnt = uint256Proposal[_proposalId].value;\r\n            consumers[ consumerCounter ].grantRateSeconds = uint256Proposal[_proposalId].value3;\r\n            consumers[ consumerCounter ].grantStartTime = uint256Proposal[_proposalId].value4;\r\n            \r\n            consumerIdByType[ consumers[ consumerCounter ].consumer ] = consumerCounter;\r\n            \r\n            consumerCounter += 1;\r\n\r\n            // Action ID = 4\r\n        } else if(proposals[ _proposalId ].actionId == 4){\r\n            \r\n            LUniftyGovernance.Consumer memory tmp = consumers[ consumerIdByType[ IUniftyGovernanceConsumer( addressProposal[_proposalId].value ) ] ];\r\n            \r\n            require( address( tmp.consumer ) != address(0), \"execute: action id 4 => consumer not found.\" );\r\n            \r\n            for(uint256 i = 0; i < tmp.peers.length; i++){\r\n                \r\n                consumerPeerExists[ tmp.consumer ][ tmp.peers[i] ] = false;\r\n                peerExists[ tmp.peers[i] ] = false;\r\n            }\r\n            \r\n            // upon consumer removal, the consumer has to give back the rest of his grant\r\n            grantedUnt -= tmp.grantSizeUnt;\r\n            \r\n            consumerIdByType[ consumers[ consumerCounter ].consumer ] = consumerIdByType[ tmp.consumer ];\r\n            \r\n            consumers[ consumerIdByType[ tmp.consumer ] ] = consumers[ consumerCounter ];\r\n            \r\n            consumerIdByType[ tmp.consumer ] = 0;\r\n            \r\n            consumers[ consumerCounter ].consumer = IUniftyGovernanceConsumer(address(0));\r\n            consumers[ consumerCounter ].grantSizeUnt = 0;\r\n            consumers[ consumerCounter ].grantRateSeconds = 0;\r\n            consumers[ consumerCounter ].grantStartTime = 0;\r\n            \r\n            delete consumers[ consumerCounter ].peers;\r\n\r\n            consumerCounter -= 1;\r\n            \r\n            for(uint256 i = 0; i < tmp.peers.length; i++){\r\n                \r\n                try tmp.consumer.removePeerFromWhitelist( tmp.peers[i] ){\r\n                    \r\n                }catch{}\r\n            }\r\n        \r\n            // Action ID = 5\r\n        } else if(proposals[ _proposalId ].actionId == 5){\r\n            \r\n            require( address( consumers[ consumerIdByType[ IUniftyGovernanceConsumer( addressProposal[_proposalId].value3 ) ] ].consumer ) != address(0), \"execute: action id 5 => consumer not found.\" );\r\n            require(!consumerPeerExists[ IUniftyGovernanceConsumer( addressProposal[_proposalId].value3 ) ][ addressProposal[ _proposalId ].value ], \"execute: action id 5 => peer exists already.\");\r\n            require(!peerExists[addressProposal[ _proposalId ].value], \"execute: action id 5 => peer exists already.\");\r\n\r\n            consumers[ consumerIdByType[ IUniftyGovernanceConsumer( addressProposal[_proposalId].value3 ) ] ].peers.push( addressProposal[ _proposalId ].value );\r\n            \r\n            consumerPeerExists[ IUniftyGovernanceConsumer( addressProposal[_proposalId].value3 ) ][ addressProposal[ _proposalId ].value ] = true;\r\n            peerExists[addressProposal[ _proposalId ].value] = true;\r\n            \r\n            consumers[ consumerIdByType[ IUniftyGovernanceConsumer( addressProposal[_proposalId].value3 ) ] ].consumer.whitelistPeer( addressProposal[ _proposalId ].value );\r\n            \r\n            // Action ID = 6\r\n        } else if(proposals[ _proposalId ].actionId == 6){\r\n\r\n            LUniftyGovernance.Consumer memory tmp = consumers[ consumerIdByType[ IUniftyGovernanceConsumer( addressProposal[_proposalId].value2[0] ) ] ];\r\n\r\n            require( address( tmp.consumer ) != address(0), \"execute: action id 6 => consumer not found.\" );\r\n            require(consumerPeerExists[ tmp.consumer ][ addressProposal[ _proposalId ].value ], \"execute: action id 6 => peer doesn't exist.\");\r\n            \r\n            consumerPeerExists[ tmp.consumer ][ addressProposal[ _proposalId ].value ] = false;\r\n            peerExists[addressProposal[ _proposalId ].value] = false;\r\n           \r\n            for(uint256 i = 0; i < tmp.peers.length; i++){\r\n                \r\n                if(addressProposal[ _proposalId ].value == tmp.peers[i]){\r\n                    \r\n                    consumers[ consumerIdByType[ tmp.consumer ] ].peers[i] = tmp.peers[ tmp.peers.length - 1 ];\r\n                    \r\n                    consumers[ consumerIdByType[ tmp.consumer ] ].peers.pop();\r\n                   \r\n                    try tmp.consumer.removePeerFromWhitelist( addressProposal[ _proposalId ].value ){\r\n                        \r\n                    }catch{}\r\n                    \r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Action ID = 7\r\n        } else if(proposals[ _proposalId ].actionId == 7){\r\n            \r\n            require(consumerIdByType[ IUniftyGovernanceConsumer( addressProposal[ _proposalId ].value ) ] != 0, \"execute: action id 7 => consumer doesn't exist.\");\r\n            \r\n            // before we re-calculate the grantable, we give back the rest of what we have\r\n            grantedUnt -= consumers[ consumerIdByType[ IUniftyGovernanceConsumer( addressProposal[ _proposalId ].value ) ] ].grantSizeUnt;\r\n            \r\n            // ...if then there is enough to grant...\r\n            require(grantableUnt() >= uint256Proposal[_proposalId].value, \"exeute: action id 7 => not enough available UNT.\");\r\n            \r\n            // ...we gonna allow to accept the new grant\r\n            grantedUnt += uint256Proposal[_proposalId].value;\r\n            \r\n            require(uint256Proposal[_proposalId].value3 != 0, \"execute: action id 7 => invalid rate\");\r\n            \r\n            // setting the proposed startTime to now if it got in the past in the meanwhile \r\n            if(uint256Proposal[_proposalId].value4 < block.timestamp){\r\n                \r\n                uint256Proposal[_proposalId].value4 = block.timestamp;\r\n            }\r\n            \r\n            consumers[ consumerIdByType[ IUniftyGovernanceConsumer( addressProposal[ _proposalId ].value ) ] ].grantSizeUnt = uint256Proposal[_proposalId].value;\r\n            consumers[ consumerIdByType[ IUniftyGovernanceConsumer( addressProposal[ _proposalId ].value ) ] ].grantRateSeconds = uint256Proposal[_proposalId].value3;\r\n            consumers[ consumerIdByType[ IUniftyGovernanceConsumer( addressProposal[ _proposalId ].value ) ] ].grantStartTime = uint256Proposal[_proposalId].value4;\r\n            \r\n        }\r\n        // proposal action id = 9 does not need to be executed, since it has no parameters. its execution is optional.\r\n        // instead the client should signal if the voting has ended and display the voting results.\r\n\r\n        emit Executed(msg.sender, _proposalId);\r\n\r\n    }\r\n\r\n    /* ################################\r\n    #\r\n    # EPOCHS & GRANTS\r\n    #\r\n    ######################################## */\r\n    \r\n    /**\r\n     * Calculating the current epoch\r\n     * \r\n     * */\r\n    function epoch() public view returns(uint256){\r\n        \r\n        // we actually want flooring here\r\n        return 1 + ( ( block.timestamp - accrueStart ) / epochDuration );\r\n    }\r\n    \r\n    /**\r\n     * Calculating the available UNT overall\r\n     * based on past and current epochs minus what has been reserved for grants.\r\n     * \r\n     * Amount of loops is expected to be small, taking hundreds of years before running into gas issues.\r\n     * */\r\n    function grantableUnt() public view returns(uint256){\r\n        \r\n        uint256 all = 0;\r\n        uint256 _epoch = epoch();\r\n        uint256 _prev = genesisReward;\r\n        \r\n        for(uint256 i = 0; i < _epoch; i++){\r\n            \r\n            all += _prev;\r\n            _prev -= ( ( ( _prev * 10**18 ) / 100 ) * 5 ) / 10**18;\r\n            \r\n        }\r\n        \r\n        return all - grantedUnt;\r\n    }\r\n    \r\n    function earnedUnt(IUniftyGovernanceConsumer _consumer) public view returns(uint256){\r\n        \r\n        if(consumerIdByType[ _consumer ] == 0) return 0;\r\n        \r\n        LUniftyGovernance.Consumer memory con = consumers[ consumerIdByType[ _consumer ] ];\r\n        \r\n        if(con.grantRateSeconds == 0) return 0;\r\n        \r\n        uint256 earned = ( ( ( ( block.timestamp - con.grantStartTime ) * 10 ** 18 ) / con.grantRateSeconds ) * con.grantSizeUnt ) / 10**18;\r\n        \r\n        // since the grants are capped, we need to make sure not to display earnings above the cap.\r\n        if(earned > con.grantSizeUnt){\r\n            \r\n            return con.grantSizeUnt;\r\n        }\r\n        \r\n        return earned;\r\n    }\r\n    \r\n    /**\r\n    * Not locked as it must be callable by authorized consumers at any time.\r\n    * This is ok as we do not call any untrusted contract's function \r\n    * and update all items prior the mint function in the end.\r\n    * \r\n    */\r\n    function mintUnt(uint256 _amount) external {\r\n        \r\n        require(!isPausing(), \"mintUnt: pausing, sorry.\");\r\n        require(consumerIdByType[ IUniftyGovernanceConsumer(msg.sender) ] != 0, \"mintUnt: access denied.\");\r\n        require(allNifStakes >= minNifConsumptionStake, \"mintUnt: not enough NIF staked in the governance yet.\");\r\n        \r\n        uint256 mint = earnedUnt( IUniftyGovernanceConsumer(msg.sender) );\r\n        \r\n        require(mint != 0 && mint >= _amount, \"mintUnt: nothing to mint.\");\r\n        \r\n        consumers[ consumerIdByType[ IUniftyGovernanceConsumer(msg.sender) ] ].grantSizeUnt -= _amount;\r\n        \r\n        mintedUnt += _amount;\r\n        mintedUntConsumer[IUniftyGovernanceConsumer(msg.sender)] += _amount;\r\n        \r\n        IERC20Mintable(untAddress).mint(msg.sender, _amount);\r\n    }\r\n    \r\n    /* ################################\r\n    #\r\n    # EXECUTIVES\r\n    # \r\n    # Executives are responsible for executing accepted proposals.\r\n    # Executives are responsible for pausing the governance (e.g. in case of emergencies).\r\n    #\r\n    ######################################## */\r\n\r\n    /**\r\n     * True if either manually paused or overall nif stakes below minNifOverallStake\r\n     *\r\n     * */\r\n    function isPausing() public view returns(bool){\r\n\r\n        return pausing || allNifStakes < minNifOverallStake;\r\n    }\r\n\r\n    /**\r\n     * Pausing the governance is the responsibility of the governance executives, not votable.\r\n     *\r\n     * */\r\n    function setPaused(bool _pausing) external{\r\n\r\n        require(isExecutive[msg.sender], \"setPaused: not an executive.\");\r\n\r\n        pausing = _pausing;\r\n    }\r\n\r\n    /**\r\n     * The current executives may add new executives.\r\n     *\r\n     * */\r\n    function setExecutive(address _executive, bool _add) external{\r\n\r\n        require(isExecutive[msg.sender], \"addExecutive: not an executive.\");\r\n        \r\n        if(_add){\r\n            require(!isExecutive[_executive], \"addExecutive: already an executive.\");\r\n        }else{\r\n            require(msg.sender != _executive, \"removeExecutive: you cannot remove yourself.\");\r\n        }\r\n        \r\n        isExecutive[_executive] = _add;\r\n    }\r\n}\r\n\r\n/* ################################\r\n    #\r\n    # STRUCTS\r\n    #\r\n    ######################################## */\r\n\r\nlibrary LUniftyGovernance{\r\n\r\n    struct Proposal{\r\n        address initiator;              // the initializing party\r\n        bool executed;                  // yet executed or not?\r\n        uint256 numVotes;               // overall votes\r\n        uint256 numSupporting;          // overall votes in support\r\n        uint256 numNotSupporting;       // overall votes not in support\r\n        uint256 openUntil;              // when will the proposal be expired? timestamp in the future\r\n        uint256 proposalId;             // the proposal ID, value taken from proposalCounter\r\n        uint256 actionId;               // the action id to be executed (resolves to use the right function, e.g. 1 is MinNifOverallStakeProposal)\r\n        string url;                     // the url that points to a json file (in opensea format), containing further information like description\r\n        mapping(address => bool) voted; // voter => bool (voting party has voted?)\r\n    }\r\n\r\n    struct Vote{\r\n        address voter;                 // the actual voting party\r\n        bool supporting;               // support yes/no\r\n        uint256 power;                 // the power of this vote\r\n        uint256 proposalId;            // referring proposalId\r\n        uint256 voteTime;              // time of the vote\r\n    }\r\n\r\n    // struct that holds uint256 and uint256[] parameters\r\n    // per proposal id for later execution\r\n    struct Uint256Proposal{\r\n        uint256 value;\r\n        uint256 value3;\r\n        uint256 value4;\r\n        uint256[] value2;\r\n    }\r\n\r\n    // struct that holds address and address[] parameters\r\n    // per proposal id for later execution\r\n    struct AddressProposal{\r\n        address value;\r\n        address value3;\r\n        address[] value2;\r\n    }\r\n\r\n    struct NifStake{\r\n\r\n        address user;                  // the user who is staking\r\n        IUniftyGovernanceConsumer peerConsumer; // the consumer of the peer below (optional but if, then both must be set)\r\n        address peer;                  // the peer that this stake allocated to (optional)\r\n        uint256 peerAllocationTime;    // the time when the allocation happened, else 0\r\n        uint256 unstakableFrom;        // timestamp from which the user is allowed to unstake\r\n        uint256 amount;                // the amount of nif that is being staked\r\n    }\r\n\r\n    struct Consumer{\r\n \r\n        IUniftyGovernanceConsumer consumer;   // the consumer object\r\n        uint256 grantStartTime;\r\n        uint256 grantRateSeconds;\r\n        uint256 grantSizeUnt;\r\n        address[] peers;               // array of allowed consumer's peers to receive emissions\r\n    }\r\n}\r\n\r\n"
6     },
7     "contracts/token/ERC721/presets/IERC20Mintable.sol": {
8       "content": "pragma solidity ^0.8.4;\n\ninterface IERC20Mintable{\n\n    function mint(address to, uint256 amount) external;\n}"
9     },
10     "contracts/token/ERC721/presets/IERC20Simple.sol": {
11       "content": "pragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev Simple Interface with a subset of the ERC20 standard as defined in the EIP needed by the DAO (and not more).\r\n */\r\ninterface IERC20Simple {\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}"
12     },
13     "contracts/token/ERC721/presets/IUniftyGovernanceConsumer.sol": {
14       "content": "pragma solidity ^0.8.4;\r\n\r\n/**\r\n * Mandatory interface for a UniftyGovernanceConsumer.\r\n * \r\n * */\r\ninterface IUniftyGovernanceConsumer{\r\n    \r\n    /**\r\n     * Must be emitted in withdraw() function.\r\n     * \r\n     * */\r\n    event Withdrawn(address indexed user, uint256 untEarned);\r\n\r\n    /**\r\n     * The name of this consumer must be requestable.\r\n     * \r\n     * This information is supposed to be used in clients.\r\n     * \r\n     * */\r\n    function name() external view returns(string calldata);\r\n    \r\n    /**\r\n     * The description for this consumer must be requestable.\r\n     * \r\n     * This information is supposed to be used in clients.\r\n     * \r\n     * */\r\n    function description() external view returns(string calldata);\r\n    \r\n    /**\r\n     * Peer whitelist required to be implemented.\r\n     * If no peers should be used, this can have an empty implementation.\r\n     * \r\n     * Example would be to vote for farms in the governance being included.\r\n     * Accepted peers can then be added to the consumer's internal whitelist and get further benefits like UNT.\r\n     * \r\n     * Must contain a check if the caller has been the governance.\r\n     * \r\n     * */\r\n    function whitelistPeer(address _peer) external;\r\n    \r\n    /**\r\n     * Peer whitelist removal required to be implemented.\r\n     * If no peers should be used, this can have an empty implementation.\r\n     * \r\n     * Example would be to vote for farms in the governance being removed and exluded.\r\n     * \r\n     * Must contain a check if the caller has been the governance.\r\n     * \r\n     * */\r\n    function removePeerFromWhitelist(address _peer) external;\r\n    \r\n    /**\r\n     * Called by the governance to signal an allocation event.\r\n     * \r\n     * The implementation must limit calls to the governance and should\r\n     * give the consumer a chance to handle allocations (like timestamp updates)\r\n     * \r\n     * Returns true if the allocation has been accepted, false if not.\r\n     * \r\n     * Must contain a check if the caller has been the governance.\r\n     * */\r\n    function allocate(address _account, uint256 prevAllocation, address _peer) external returns(bool);\r\n    \r\n    /**\r\n     * Called by the governance upon staking if the allocation for a user and a peer changes.\r\n     * The consumer has then the ability to check what has been changed and act accordingly.\r\n     *\r\n     * Must contain a check if the caller has been the governance.\r\n     * */\r\n    function allocationUpdate(address _account, uint256 prevAmount, uint256 prevAllocation, address _peer) external returns(bool, uint256);\r\n    \r\n    /**\r\n     * Called by the governance to signal an dellocation event.\r\n     * \r\n     * The implementation must limit calls to the governance and should\r\n     * give the consumer a chance to handle allocations (like timestamp updates)\r\n     * \r\n     * This functions is also called by the governance before it calls allocate.\r\n     * This must be akten into account to avoid side-effects.\r\n     * */\r\n    function dellocate(address _account, uint256 prevAllocation, address _peer) external returns(uint256);\r\n    \r\n    /**\r\n     * Called by the governance to determine if allocated stakes of an account in the governance should stay frozen.\r\n     * If this returns true, the governance won't release NIF upon unstaking.\r\n     * \r\n     * */\r\n    function frozen(address _account) external view returns(bool);\r\n    \r\n    /**\r\n     * Returns true if the peer is whitelisted, otherwise false.\r\n     * \r\n     * */\r\n    function peerWhitelisted(address _peer) external view returns(bool);\r\n    \r\n    /**\r\n     * Should return a URI, pointing to a json file in the format:\r\n     * \r\n     * {\r\n     *   name : '',\r\n     *   description : '',\r\n     *   external_link : '',\r\n     * }\r\n     * \r\n     * Can throw an error if the peer is not whitelisted or return an empty string if there is no further information.\r\n     * Since this is supposed to be called by clients, those have to catch errors and handle empty return values themselves.\r\n     * \r\n     * */\r\n    function peerUri(address _peer) external view returns(string calldata);\r\n    \r\n    /**\r\n     * Must return the time in seconds that is left until the allocation \r\n     * of a user to the peer he is allocating to expires.\r\n     * \r\n     * */\r\n    function timeToUnfreeze(address _account) external view returns(uint256);\r\n    \r\n    /**\r\n     * _peer parameter to apply the AP info for.\r\n     * \r\n     * Frontend function to help displaying apr/apy and similar strategies.\r\n     *\r\n     * The first index of the returned tuple should return \"r\" if APR or \"y\" if APY.\r\n     * \r\n     * The second index of the returned tuple should return the actual APR/Y value for the consumer.\r\n     * 18 decimals precision required.\r\n     *\r\n     * The 2nd uint256[] array should return a list of proposed services for price discovery on the client-side.\r\n     *\r\n     * 0 = uni-v2 unt/eth\r\n     * 1 = uni-v2 unt/usdt\r\n     * 2 = uni-v2 unt/usdc\r\n     * 3 = uni-v3 unt/eth\r\n     * 4 = uni-v3 unt/usdt\r\n     * 5 = uni-v3 unt/usdc\r\n     * 6 = kucoin unt/usdt\r\n     * 7 = binance unt/usdt\r\n     *\r\n     * The rate and list should be udpatable/extendible through an admin function due to possible updates on the client-side.\r\n     * (e.g. adding more exchanges)\r\n     *\r\n     * */\r\n    function apInfo(address _peer) external view returns(string memory, uint256, uint256[] memory);\r\n    \r\n    /**\r\n     * Withdraws UNT rewards for accounts that stake in the governance and allocated their funds to this consumer and peer.\r\n     * \r\n     * Must return the amount of withdrawn UNT.\r\n     * \r\n     * */\r\n    function withdraw() external returns(uint256);\r\n    \r\n    /**\r\n     * Must return the account's _current_ UNT earnings (as of current blockchain state).\r\n     * \r\n     * Used in the frontend.\r\n     * */\r\n    function earned(address _account) external view returns(uint256);\r\n    \r\n    /**\r\n     * Same as earned() except adding a live component that may be inaccurate due to not yet occurred state-changes.\r\n     * \r\n     * If unsure how to implement, call and return earned() inside.\r\n     * \r\n     * Used in the frontend.\r\n     * */\r\n    function earnedLive(address _account) external view returns(uint256);\r\n    \r\n    /**\r\n     * If there are any nif caps per peer, this function should return those.\r\n     * \r\n     * */\r\n    function peerNifCap(address _peer) external view returns(uint256);\r\n}"
15     }
16   },
17   "settings": {
18     "optimizer": {
19       "enabled": true,
20       "runs": 200
21     },
22     "outputSelection": {
23       "*": {
24         "*": [
25           "evm.bytecode",
26           "evm.deployedBytecode",
27           "abi"
28         ]
29       }
30     }
31   }
32 }}