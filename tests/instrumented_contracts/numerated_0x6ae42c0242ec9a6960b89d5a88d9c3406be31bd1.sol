1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "london",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "details": {
12         "constantOptimizer": true,
13         "cse": true,
14         "deduplicate": true,
15         "inliner": true,
16         "jumpdestRemover": true,
17         "orderLiterals": true,
18         "peephole": true,
19         "yul": true,
20         "yulDetails": {
21           "optimizerSteps": "dhfoDgvulfnTUtnIf",
22           "stackAllocation": true
23         }
24       },
25       "runs": 2000
26     },
27     "remappings": [],
28     "outputSelection": {
29       "*": {
30         "*": [
31           "evm.bytecode",
32           "evm.deployedBytecode",
33           "devdoc",
34           "userdoc",
35           "metadata",
36           "abi"
37         ]
38       }
39     }
40   },
41   "sources": {
42     "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol": {
43       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}\n"
44     },
45     "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol": {
46       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig()\n    external\n    view\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    );\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    );\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n}\n"
47     },
48     "@openzeppelin/contracts/security/Pausable.sol": {
49       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
50     },
51     "@openzeppelin/contracts/utils/Context.sol": {
52       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
53     },
54     "contracts/PirateGames.sol": {
55       "content": "// SPDX-License-Identifier: MIT LICENSE\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./interfaces/IPirateGames.sol\";\nimport \"./interfaces/IPytheas.sol\";\nimport \"./interfaces/IOrbitalBlockade.sol\";\nimport \"./interfaces/ITPirates.sol\";\nimport \"./interfaces/IRAW.sol\";\nimport \"./interfaces/IPirates.sol\";\nimport \"./interfaces/IColonist.sol\";\nimport \"./interfaces/IImperialGuild.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\n\n\ncontract PirateGames is IPirateGames, VRFConsumerBaseV2, Pausable {\n    struct MintCommit {\n        bool stake;\n        uint16 tokenId;\n    }\n\n    uint8[][6] public rarities;\n    uint8[][6] public aliases;\n\n    uint256 public OnosiaLiquorId;\n\n    uint256 private maxRawEonCost;\n\n\n    // address => can call\n    mapping(address => bool) private admins;\n\n    // address -> commit # -> commits\n    mapping(address => mapping(uint16 => MintCommit)) private _mintCommits;\n    // address -> commit num of commit need revealed for account\n    mapping(address => uint16) private _pendingCommitId;\n\n    // amout pending needed to toggle randomness\n    uint16 toggleLimit;\n    // counter for toggle randomness\n    uint16 toggleCounter;\n\n    uint16 private _commitId = 1;\n    uint16 private pendingMintAmt;\n    bool public allowCommits = false;\n\n    address public auth;\n\n    // reference to Pytheas for checking that a colonist has mined enough\n    //rEON to make an attempt as well as pay from this amount, either the  current mint cost on\n    //a successful pirate mint, or pirate tax on a failed attempt.\n    IPytheas public pytheas;\n    //reference to the OrbitalBlockade, where pirates are staked out, awaiting weak colonist miners.\n    IOrbitalBlockade public orbital;\n    // reference to raw Eon for attempts\n    IRAW public raw;\n    // reference to pirate collection\n    IPirates public pirateNFT;\n    // reference to the colonist NFT collection\n    IColonist public colonistNFT;\n    // reference to the galactic imperialGuild collection\n    IImperialGuild public imperialGuild;\n    // Chainlink references\n    VRFCoordinatorV2Interface COORDINATOR;\n\n    uint64 s_subscriptionId;\n    uint256 linkFee;\n    address vrfCoordinator = 0x271682DEB8C4E0901D1a1550aD2e64D568E69909;\n    bytes32 keyHash; \n    uint32 callbackGasLimit;\n    uint16 requestConfirmations;\n      //amount pending that toggles a randomness call\n    uint32 public numWords = 1;\n    uint256[] private randomness;\n    uint256 public s_requestId;\n    address s_owner;\n\n    event MintCommitted(address indexed owner, uint256 indexed tokenId);\n    event MintRevealed(address indexed owner, uint16[] indexed tokenId);\n\n    constructor() VRFConsumerBaseV2(vrfCoordinator) {\n        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\n        s_owner = msg.sender;\n        auth = msg.sender;\n        admins[msg.sender] = true;\n        admins[address(this)] = true;\n\n        //RatioChance 90\n        rarities[0] = [27, 230];\n        aliases[0] = [1, 0];\n        //RatioChance 80\n        rarities[1] = [51, 204];\n        aliases[1] = [1, 0];\n        //RatioChance 60\n        rarities[2] = [90, 175];\n        aliases[2] = [1, 0];\n        //RatioChance 40\n        rarities[3] = [155, 132];\n        aliases[3] = [1, 0];\n        //RatioChance 10\n        rarities[4] = [200, 60];\n        aliases[4] = [1, 0];\n        //RatioChance 0\n        rarities[5] = [255];\n        aliases[5] = [0];\n    }\n\n    modifier noCheaters() {\n        uint256 size = 0;\n        address acc = msg.sender;\n        assembly {\n            size := extcodesize(acc)\n        }\n\n        require(\n            admins[msg.sender] || (msg.sender == tx.origin && size == 0),\n            \"you're trying to cheat!\"\n        );\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == auth);\n        _;\n    }\n\n    /** CRITICAL TO SETUP */\n    modifier requireContractsSet() {\n        require(\n            address(raw) != address(0) &&\n                address(pirateNFT) != address(0) &&\n                address(colonistNFT) != address(0) &&\n                address(pytheas) != address(0) &&\n                address(orbital) != address(0) &&\n                address(imperialGuild) != address(0),\n            \"Contracts not set\"\n        );\n        _;\n    }\n\n    function setContracts(\n        address _rEON,\n        address _pirateNFT,\n        address _colonistNFT,\n        address _pytheas,\n        address _orbital,\n        address _imperialGuild\n    ) external onlyOwner {\n        raw = IRAW(_rEON);\n        pirateNFT = IPirates(_pirateNFT);\n        colonistNFT = IColonist(_colonistNFT);\n        pytheas = IPytheas(_pytheas);\n        orbital = IOrbitalBlockade(_orbital);\n        imperialGuild = IImperialGuild(_imperialGuild);\n    }\n\n    function getPendingMint(address addr)\n        external\n        view\n        returns (MintCommit memory)\n    {\n        require(_pendingCommitId[addr] != 0, \"no pending commits\");\n        return _mintCommits[addr][_pendingCommitId[addr]];\n    }\n\n    function hasMintPending(address addr) external view returns (bool) {\n        return _pendingCommitId[addr] != 0;\n    }\n\n    function canMint(address addr) external view returns (bool) {\n         uint16 commitIdCur = _pendingCommitId[addr];\n         if (randomness.length == 1) {\n            return \n            _pendingCommitId[addr] != 0;\n         } else {\n        return\n            _pendingCommitId[addr] != 0 &&\n            (randomness.length - 1) >= commitIdCur;\n         }\n    }\n\n     // Assumes the subscription is funded sufficiently.\n    function requestRandomWords() internal {\n        // Will revert if subscription is not set and funded.\n        s_requestId = COORDINATOR.requestRandomWords(\n            keyHash,\n            s_subscriptionId,\n            requestConfirmations,\n            callbackGasLimit,\n            numWords\n        );\n    }\n\n    function fulfillRandomWords(\n        uint256, /* requestId */\n        uint256[] memory randomWords\n    ) internal override {\n         randomness.push(randomWords[0]);\n    }\n\n\n    function deleteCommit(address addr) external {\n        require(\n            auth == msg.sender || admins[msg.sender],\n            \"Only admins can call this\"\n        );\n\n        uint16 commitIdCur = _pendingCommitId[addr];\n        require(commitIdCur > 0, \"No pending commit\");\n        delete _mintCommits[addr][commitIdCur];\n        delete _pendingCommitId[addr];\n    }\n\n    function forceRevealCommit(address addr) external {\n        require(\n            auth == msg.sender || admins[msg.sender],\n            \"Only admins can call this\"\n        );\n        pirateAttempt(addr);\n    }\n\n    function mintCommit(uint16 tokenId, bool stake)\n        external\n        whenNotPaused\n        noCheaters\n    {\n        require(allowCommits, \"adding commits disallowed\");\n        require(\n            _pendingCommitId[msg.sender] == 0,\n            \"Already have pending mints\"\n        );\n        uint16 piratesMinted = pirateNFT.piratesMinted();\n        require(\n            piratesMinted + pendingMintAmt + 1 <= 6000,\n            \"All tokens minted\"\n        );\n        uint256 minted = colonistNFT.minted();\n        uint256 maxTokens = colonistNFT.getMaxTokens();\n        uint256 rawCost = rawMintCost(minted, maxTokens);\n\n        raw.burn(1, rawCost, msg.sender);\n        raw.updateOriginAccess(msg.sender);\n\n        colonistNFT.transferFrom(msg.sender, address(this), tokenId);\n\n        _mintCommits[msg.sender][_commitId] = MintCommit(stake, tokenId);\n        _pendingCommitId[msg.sender] = _commitId;\n        pendingMintAmt += 1;\n        toggleCounter += 1;\n        if (toggleCounter == toggleLimit) {\n            requestRandomWords();\n            toggleCounter = 0;\n            _commitId += 1; \n        }\n        emit MintCommitted(msg.sender, tokenId);\n    }\n\n    function mintReveal() external whenNotPaused noCheaters {\n        pirateAttempt(msg.sender);\n    }\n\n    function pirateAttempt(address addr) internal {\n        uint16 commitIdCur = _pendingCommitId[addr];\n        require(commitIdCur >= 0, \"No pending commit\");\n        require(randomness.length >= commitIdCur, \"Random seed not set\");\n        MintCommit memory commit = _mintCommits[addr][commitIdCur];\n        pendingMintAmt -= 1;\n        uint16 colonistId = commit.tokenId;\n        uint16 piratesMinted = pirateNFT.piratesMinted();\n        uint256 seed = randomness[commitIdCur];\n        uint256 circulation = colonistNFT.totalCir();\n        uint8 chanceTable = getRatioChance(piratesMinted, circulation);\n        seed = uint256(keccak256(abi.encode(seed, addr)));\n        uint8 yayNay = getPirateResults(seed, chanceTable);\n        // if the attempt fails, pay pirate tax and claim remaining\n        if (yayNay == 0) {\n            colonistNFT.safeTransferFrom(address(this), addr, colonistId);\n        } else {\n            colonistNFT.burn(colonistId);\n            uint16[] memory pirateId = new uint16[](1);\n            uint16[] memory pirateIdToStake = new uint16[](1);\n            piratesMinted++;\n            address recipient = selectRecipient(seed);\n            if (\n                recipient != addr &&\n                imperialGuild.getBalance(addr, OnosiaLiquorId) > 0\n            ) {\n                // If the mint is going to be stolen, there's a 50% chance\n                //  a pirate will prefer a fine crafted EON liquor over it\n                if (seed & 1 == 1) {\n                    imperialGuild.safeTransferFrom(\n                        addr,\n                        recipient,\n                        OnosiaLiquorId,\n                        1,\n                        \"\"\n                    );\n                    recipient = addr;\n                }\n            }\n\n            pirateId[0] = piratesMinted;\n            if (!commit.stake || recipient != addr) {\n                pirateNFT._mintPirate(recipient, seed);\n            } else {\n                pirateNFT._mintPirate(address(orbital), seed);\n                pirateIdToStake[0] = piratesMinted;\n            }\n            pirateNFT.updateOriginAccess(pirateId);\n            if (commit.stake) {\n                orbital.addPiratesToCrew(addr, pirateIdToStake);\n            }\n            emit MintRevealed(addr, pirateId);\n        }\n        delete _mintCommits[addr][commitIdCur];\n        delete _pendingCommitId[addr];\n    }\n\n    /**\n     * @return the cost of the given token ID\n     */\n    function rawMintCost(uint256 tokenId, uint256 maxTokens)\n        internal\n        view\n        returns (uint256)\n    {\n        if (tokenId <= (maxTokens * 8) / 24) return 4000; //10k-20k\n        if (tokenId <= (maxTokens * 12) / 24) return 16000; //20k-30k\n        if (tokenId <= (maxTokens * 16) / 24) return 48000; //30k-40k\n        if (tokenId <= (maxTokens * 20) / 24) return 122500; //40k-50k\n        if (tokenId <= (maxTokens * 22) / 24) return 250000; //50k-55k\n        return maxRawEonCost;\n    }\n\n    function getRatioChance(uint256 pirates, uint256 circulation)\n        public\n        pure\n        returns (uint8)\n    {\n        uint256 ratio = (pirates * 10000) / circulation;\n\n        if (ratio <= 100) {\n            return 0;\n        } else if (ratio <= 300 && ratio >= 100) {\n            return 1;\n        } else if (ratio <= 500 && ratio >= 300) {\n            return 2;\n        } else if (ratio <= 800 && ratio >= 500) {\n            return 3;\n        } else if (ratio <= 999 && ratio >= 800) {\n            return 4;\n        } else {\n            return 5;\n        }\n    }\n\n    /**\n     * Determines if an attempt to join the pirates is successful or not\n     * granting a higher chance of success when the pirate to colonist ratio is\n     * low, as the ratio gets closer to 10% the harder a chance at joining the pirates\n     * becomes until ultimately they will not accept anyone else if the ratio is += 10%\n    */\n    function getPirateResults(uint256 seed, uint8 chanceTable)\n        internal\n        view\n        returns (uint8)\n    {\n        seed >>= 16;\n        uint8 yayNay = getResult(uint16(seed & 0xFFFF), chanceTable);\n        return yayNay;\n    }\n\n    function getResult(uint256 seed, uint8 chanceTable)\n        internal\n        view\n        returns (uint8)\n    {\n        uint8 result = uint8(seed) % uint8(rarities[chanceTable].length);\n        // If the selected chance talbles rareity is selected (biased coin) return that\n        if (seed >> 8 < rarities[chanceTable][result]) return result;\n        // else return the aliases\n        return aliases[chanceTable][result];\n    }\n    \n\n    /** INTERNAL */\n\n    /**\n     * the first 10k colonist mints go to the minter\n     * the remaining 80% have a 10% chance to be given to a random staked pirate\n     * @param seed a random value to select a recipient from\n     * @return the address of the recipient (either the minter or the pirate thief's owner)\n     */\n    function selectRecipient(uint256 seed) internal view returns (address) {\n        if (((seed >> 245) % 10) != 0) return msg.sender; // top 10 bits\n        address thief = orbital.randomPirateOwner(seed >> 144); // 144 bits reserved for trait selection\n        if (thief == address(0x0)) return msg.sender;\n        return thief;\n    }\n\n     // Assumes the subscription is funded sufficiently.\n    function adminRequestRandomWords() external {\n        require(admins[msg.sender], \"only admins can request randomness\");\n        // Will revert if subscription is not set and funded.\n        s_requestId = COORDINATOR.requestRandomWords(\n            keyHash,\n            s_subscriptionId,\n            requestConfirmations,\n            callbackGasLimit,\n            numWords\n        );\n    }\n\n\n\n    /**\n     * enables owner to pause / unpause contract\n     */\n    function setPaused(bool _paused) external requireContractsSet onlyOwner {\n        if (_paused) _pause();\n        else _unpause();\n    }\n\n    function setOnosiaLiquorId(uint256 typeId) external onlyOwner {\n        OnosiaLiquorId = typeId;\n    }\n\n    function setAllowCommits(bool allowed) external onlyOwner {\n        allowCommits = allowed;\n    }\n\n    function setToggleLimit(uint16 _toggleLimit) external onlyOwner {\n        toggleLimit = _toggleLimit;\n    }\n\n    function setPendingMintAmt(uint256 pendingAmt) external onlyOwner {\n        pendingMintAmt = uint16(pendingAmt);\n    }\n\n    function setVRFsub(bytes32 _keyHash, uint64 _s_subscriptionId, uint32 _callbackGasLimit, uint16 _requestConfirmations) external onlyOwner {\n        keyHash = _keyHash;\n        s_subscriptionId = _s_subscriptionId;\n        callbackGasLimit = _callbackGasLimit;\n        requestConfirmations = _requestConfirmations;\n    }\n\n    function resetToggleCounter (uint16 _toggleCounter) external onlyOwner {\n        toggleCounter = _toggleCounter;\n    }\n    \n    function resetCommitId (uint16 commitId) external onlyOwner {\n        _commitId = commitId;\n    }\n\n    function getCurrent() external view returns (uint16, uint256) {\n        return (_commitId, randomness.length);\n    }\n\n    /* enables an address to mint / burn\n     * @param addr the address to enable\n     */\n    function addAdmin(address addr) external onlyOwner {\n        admins[addr] = true;\n    }\n\n    /**\n     * disables an address from minting / burning\n     * @param addr the address to disable\n     */\n    function removeAdmin(address addr) external onlyOwner {\n        admins[addr] = false;\n    }\n\n\n    function emergencyExtraction(address recipient, uint256 tokenId) external onlyOwner {\n        colonistNFT.transferFrom(address(this), recipient, tokenId);\n    }\n}\n\n"
56     },
57     "contracts/interfaces/IColonist.sol": {
58       "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface IColonist {\r\n    // struct to store each Colonist's traits\r\n    struct Colonist {\r\n        bool isColonist;\r\n        uint8 background;\r\n        uint8 body;\r\n        uint8 shirt;\r\n        uint8 jacket;\r\n        uint8 jaw;\r\n        uint8 eyes;\r\n        uint8 hair;\r\n        uint8 held;\r\n        uint8 gen;\r\n    }\r\n\r\n    struct HColonist {\r\n        uint8 Legendary;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function isOwner(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function minted() external returns (uint16);\r\n\r\n    function totalCir() external returns (uint256);\r\n\r\n    function _mintColonist(address recipient, uint256 seed) external;\r\n\r\n    function _mintToHonors(address recipient, uint256 seed) external;\r\n\r\n    function _mintHonors(address recipient, uint8 id) external;\r\n\r\n    function burn(uint256 tokenId) external;\r\n\r\n    function getMaxTokens() external view returns (uint256);\r\n\r\n    function getPaidTokens() external view returns (uint256);\r\n\r\n    function getTokenTraitsColonist(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (Colonist memory);\r\n\r\n    function getTokenTraitsHonors(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (HColonist memory);\r\n\r\n    function tokenNameByIndex(uint256 index)\r\n        external\r\n        view\r\n        returns (string memory);\r\n\r\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\r\n\r\n    function nameColonist(uint256 tokenId, string memory newName) external;\r\n}\r\n"
59     },
60     "contracts/interfaces/IImperialGuild.sol": {
61       "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface IImperialGuild {\r\n\r\n    function getBalance(\r\n        address account,\r\n        uint256 id\r\n    ) external returns(uint256);\r\n\r\n    function mint(\r\n        uint256 typeId,\r\n        uint256 paymentId,\r\n        uint16 qty,\r\n        address recipient\r\n    ) external;\r\n\r\n    function burn(\r\n        uint256 typeId,\r\n        uint16 qty,\r\n        address burnFrom\r\n    ) external;\r\n\r\n    function handlePayment(uint256 amount) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external;\r\n}\r\n"
62     },
63     "contracts/interfaces/IOrbitalBlockade.sol": {
64       "content": "// SPDX-License-Identifier: MIT LICENSE\n\npragma solidity ^0.8.0;\n\ninterface IOrbitalBlockade {\n    function addPiratesToCrew(address account, uint16[] calldata tokenIds)\n        external;\n    \n    function claimPiratesFromCrew(address account, uint16[] calldata tokenIds, bool unstake)\n        external;\n\n    function payPirateTax(uint256 amount) external;\n\n    function randomPirateOwner(uint256 seed) external view returns (address);\n}\n"
65     },
66     "contracts/interfaces/IPirateGames.sol": {
67       "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPirateGames {}\r\n"
68     },
69     "contracts/interfaces/IPirates.sol": {
70       "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPirates {\r\n    // struct to store each Colonist's traits\r\n    struct Pirate {\r\n        bool isPirate;\r\n        uint8 sky;\r\n        uint8 cockpit;\r\n        uint8 base;\r\n        uint8 engine;\r\n        uint8 nose;\r\n        uint8 wing;\r\n        uint8 weapon1;\r\n        uint8 weapon2;\r\n        uint8 rank;\r\n    }\r\n\r\n    struct HPirates {\r\n        uint8 Legendary;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) external;\r\n\r\n    function minted() external returns (uint16);\r\n\r\n    function piratesMinted() external returns (uint16);\r\n\r\n    function isOwner(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function _mintPirate(address recipient, uint256 seed) external;\r\n\r\n    function burn(uint256 tokenId) external;\r\n\r\n    function getTokenTraitsPirate(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (Pirate memory);\r\n\r\n    function getTokenTraitsHonors(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (HPirates memory);\r\n\r\n    function tokenNameByIndex(uint256 index)\r\n        external\r\n        view\r\n        returns (string memory);\r\n    \r\n    function isHonors(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function updateOriginAccess(uint16[] memory tokenIds) external;\r\n\r\n    function getTokenWriteBlock(uint256 tokenId) \r\n    external \r\n    view  \r\n    returns(uint64);\r\n\r\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\r\n\r\n    function namePirate(uint256 tokenId, string memory newName) external;\r\n}\r\n"
71     },
72     "contracts/interfaces/IPytheas.sol": {
73       "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPytheas {\r\n    function addColonistToPytheas(address account, uint16[] calldata tokenIds)\r\n        external;\r\n\r\n    function claimColonistFromPytheas(address account, uint16[] calldata tokenIds, bool unstake)\r\n        external;\r\n\r\n    function getColonistMined(address account, uint16 tokenId)\r\n        external\r\n        returns (uint256);\r\n\r\n    function handleJoinPirates(address addr, uint16 tokenId) external;\r\n\r\n    function payUp(\r\n        uint16 tokenId,\r\n        uint256 amtMined,\r\n        address addr\r\n    ) external;\r\n}\r\n"
74     },
75     "contracts/interfaces/IRAW.sol": {
76       "content": "// SPDX-License-Identifier: MIT LICENSE\npragma solidity ^0.8.0;\n\ninterface IRAW {\n\n    function updateOriginAccess(address user) external;\n\n\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external returns(uint256);\n\n    function mint(\n        uint256 typeId,\n        uint256 qty,\n        address recipient\n    ) external;\n\n    function burn(\n        uint256 typeId,\n        uint256 qty,\n        address burnFrom\n    ) external;\n\n    function updateMintBurns(\n        uint256 typeId,\n        uint256 mintQty,\n        uint256 burnQty\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external;\n\n}\n"
77     },
78     "contracts/interfaces/ITPirates.sol": {
79       "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface ITPirates {\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n"
80     }
81   }
82 }}