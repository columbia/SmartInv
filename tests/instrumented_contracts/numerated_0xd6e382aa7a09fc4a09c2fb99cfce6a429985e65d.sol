1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/Doomsday.sol": {
5       "content": "//SPDX-License-Identifier: Cool kids only\r\n\r\npragma solidity ^0.8.0;\r\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\r\nimport \"./interfaces/IERC165.sol\";\r\nimport \"./interfaces/IERC721.sol\";\r\nimport \"./interfaces/IERC721Metadata.sol\";\r\nimport \"./interfaces/IERC721TokenReceiver.sol\";\r\n\r\ncontract Doomsday is IERC721, IERC165, IERC721Metadata{\r\n\r\n\r\n    constructor(bytes32 _cityRoot, address _earlyAccessHolders){\r\n        supportedInterfaces[0x80ac58cd] = true; //ERC721\r\n        supportedInterfaces[0x5b5e139f] = true; //ERC721Metadata\r\n        //        supportedInterfaces[0x780e9d63] = true; //ERC721Enumerable\r\n        supportedInterfaces[0x01ffc9a7] = true; //ERC165\r\n\r\n        owner = msg.sender;\r\n        cityRoot = _cityRoot;\r\n\r\n        earlyAccessHolders = _earlyAccessHolders;\r\n    }\r\n\r\n    address public owner;\r\n    address earlyAccessHolders;\r\n\r\n    //////===721 Implementation\r\n    mapping(address => uint256) internal balances;\r\n    mapping (uint256 => address) internal allowance;\r\n    mapping (address => mapping (address => bool)) internal authorised;\r\n\r\n    uint16[] tokenIndexToCity;  //Array of all tokens [cityId,cityId,...]\r\n    mapping(uint256 => address) owners;  //Mapping of owners\r\n    //  keep owners mapping\r\n    //  use tokenIndexToCity for isValidToken\r\n\r\n    //    METADATA VARS\r\n    string private __name = \"Doomsday NFT\";\r\n    string private __symbol = \"BUNKER\";\r\n    bytes private __uriBase = bytes(\"https://gateway.pinata.cloud/ipfs/QmUwPH9PmTQrT67M633AJRXACsecmRTihf4DUbJZb9y83M/\");\r\n    bytes private __uriSuffix = bytes(\".json\");\r\n\r\n    //  Game vars\r\n    uint constant MAX_CITIES = 38611;       //from table\r\n\r\n    int64 constant MAP_WIDTH         = 4320000;   //map units\r\n    int64 constant MAP_HEIGHT        = 2588795;   //map units\r\n    int64 constant BASE_BLAST_RADIUS = 100000;   //map units\r\n\r\n    uint constant MINT_COST = 0.04 ether;\r\n\r\n    uint constant MINT_PERCENT_WINNER       = 50;\r\n    uint constant MINT_PERCENT_CALLER       = 25;\r\n    uint constant MINT_PERCENT_CREATOR      = 25;\r\n\r\n    uint constant REINFORCE_PERCENT_WINNER  = 90;\r\n    uint constant REINFORCE_PERCENT_CREATOR = 10;\r\n\r\n\r\n    uint constant IMPACT_BLOCK_INTERVAL = 120;\r\n\r\n    mapping(uint16 => uint) public cityToToken;\r\n    mapping(uint16 => int64[2]) coordinates;\r\n    bytes32 cityRoot;\r\n\r\n    event Inhabit(uint16 indexed _cityId, uint256 indexed _tokenId);\r\n    event Reinforce(uint256 indexed _tokenId);\r\n    event Impact(uint256 indexed _tokenId);\r\n\r\n    mapping(uint => bytes32) structuralData;\r\n\r\n    function getStructuralData(uint _tokenId) public view returns (uint8 reinforcement, uint8 damage, bytes32 lastImpact){\r\n        bytes32 _data = structuralData[_tokenId];\r\n\r\n        reinforcement = uint8(uint(((_data << 248) >> 248)));\r\n        damage = uint8(uint(((_data << 240) >> 240) >> 8));\r\n        lastImpact = (_data >> 16);\r\n\r\n        return (reinforcement, damage, lastImpact);\r\n    }\r\n    function setStructuralData(uint _tokenId, uint8 reinforcement, uint8 damage, bytes32 lastImpact) internal{\r\n        bytes32 _reinforcement = bytes32(uint(reinforcement));\r\n        bytes32 _damage = bytes32(uint(damage)) << 8;\r\n        bytes32 _lastImpact = encodeImpact(lastImpact) << 16;\r\n\r\n        structuralData[_tokenId] = _reinforcement ^ _damage ^ _lastImpact;\r\n    }\r\n    function encodeImpact(bytes32 _impact) internal pure returns(bytes32){\r\n        return (_impact << 16) >> 16;\r\n    }\r\n\r\n\r\n    uint public reinforcements;\r\n    uint public destroyed;\r\n    uint public evacuatedFunds;\r\n\r\n    uint ownerWithdrawn;\r\n    bool winnerWithdrawn;\r\n\r\n    function tokenToCity(uint _tokenId) public view returns(uint16){\r\n        return tokenIndexToCity[_tokenId - 1];\r\n    }\r\n\r\n    uint public startTime;\r\n    uint SALE_TIME = 7 days;\r\n    uint EARLY_ACCESS_TIME = 1 days;\r\n\r\n    function startPreApocalypse() public{\r\n        require(msg.sender == owner,\"owner\");\r\n\r\n        require(startTime == 0,\"started\");\r\n        startTime = block.timestamp;\r\n    }\r\n    enum Stage {Initial,PreApocalypse,Apocalypse,PostApocalypse}\r\n    function stage() public view returns(Stage){\r\n        if(startTime == 0){\r\n            return Stage.Initial;\r\n        }else if(block.timestamp < startTime + SALE_TIME && tokenIndexToCity.length < MAX_CITIES){\r\n            return Stage.PreApocalypse;\r\n        }else if(destroyed < tokenIndexToCity.length - 1){\r\n            return Stage.Apocalypse;\r\n        }else{\r\n            return Stage.PostApocalypse;\r\n        }\r\n    }\r\n\r\n    function inhabit(uint16 _cityId, int64[2] calldata _coordinates, bytes32[] memory proof) public payable{\r\n        require(stage() == Stage.PreApocalypse,\"stage\");\r\n        if(block.timestamp < startTime + EARLY_ACCESS_TIME){\r\n            //First day is insiders list\r\n            require(IERC721(earlyAccessHolders).balanceOf(msg.sender) > 0,\"early\");\r\n        }\r\n\r\n\r\n        bytes32 leaf = keccak256(abi.encodePacked(_cityId,_coordinates[0],_coordinates[1]));\r\n\r\n        require(MerkleProof.verify(proof, cityRoot, leaf),\"proof\");\r\n\r\n        require(cityToToken[_cityId] == 0 && coordinates[_cityId][0] == 0 && coordinates[_cityId][1] == 0,\"inhabited\");\r\n\r\n        require(\r\n            _coordinates[0] >= -MAP_WIDTH/2 &&\r\n            _coordinates[0] <= MAP_WIDTH/2 &&\r\n\r\n            _coordinates[1] >= -MAP_HEIGHT/2 &&\r\n            _coordinates[1] <= MAP_HEIGHT/2,\r\n            \"off map\"\r\n        );  //Not strictly necessary but proves the whitelist hasnt been fucked with\r\n\r\n\r\n        require(msg.value == MINT_COST,\"cost\");\r\n\r\n        coordinates[_cityId] = _coordinates;\r\n\r\n        tokenIndexToCity.push(_cityId);\r\n\r\n        uint _tokenId = tokenIndexToCity.length;\r\n\r\n        balances[msg.sender]++;\r\n        owners[_tokenId] = msg.sender;\r\n        cityToToken[_cityId] = _tokenId;\r\n\r\n        emit Inhabit(_cityId, _tokenId);\r\n        emit Transfer(address(0),msg.sender,_tokenId);\r\n    }\r\n\r\n    function isUninhabited(uint16 _cityId) public view returns(bool){\r\n        return coordinates[_cityId][0] == 0 && coordinates[_cityId][1] == 0;\r\n    }\r\n\r\n    function reinforce(uint _tokenId) public payable{\r\n\r\n        Stage _stage = stage();\r\n\r\n        require(_stage == Stage.PreApocalypse || _stage == Stage.Apocalypse,\"stage\");\r\n\r\n        require(ownerOf(_tokenId) == msg.sender,\"owner\");\r\n\r\n        //Covered by ownerOf\r\n//        require(isValidToken(_tokenId),\"invalid\");\r\n\r\n        (uint8 _reinforcement, uint8 _damage, bytes32 _lastImpact) = getStructuralData(_tokenId);\r\n\r\n        if(_stage == Stage.Apocalypse){\r\n            require(!checkVulnerable(_tokenId,_lastImpact),\"vulnerable\");\r\n        }\r\n\r\n        //   covered by isValidToken\r\n            //require(_damage <= _reinforcement,\"eliminated\" );\r\n\r\n        require(msg.value == (2 ** _reinforcement) *  MINT_COST,\"cost\");\r\n\r\n\r\n        setStructuralData(_tokenId,_reinforcement+1,_damage,_lastImpact);\r\n\r\n        reinforcements += msg.value - (MINT_COST * MINT_PERCENT_CALLER / 100);\r\n\r\n        emit Reinforce(_tokenId);\r\n    }\r\n    function evacuate(uint _tokenId) public{\r\n        Stage _stage = stage();\r\n        require(_stage == Stage.PreApocalypse || _stage == Stage.Apocalypse,\"stage\");\r\n\r\n        require(ownerOf(_tokenId) == msg.sender,\"owner\");\r\n\r\n        // covered by isValidToken in ownerOf\r\n//        require(_damage <= _reinforcement,\"eliminated\" );\r\n\r\n        if(_stage == Stage.Apocalypse){\r\n            require(!isVulnerable(_tokenId),\"vulnerable\");\r\n        }\r\n\r\n        uint cityCount = tokenIndexToCity.length;\r\n\r\n\r\n        uint fromPool =\r\n            //Winner fee from mints less evacuated funds\r\n                ((MINT_COST * cityCount * MINT_PERCENT_WINNER / 100 - evacuatedFunds)\r\n            //Divided by remaining tokens\r\n                / totalSupply())\r\n            //Divided by two\r\n               / 2;\r\n\r\n\r\n        //Also give them the admin fee\r\n        uint toWithdraw = fromPool + getEvacuationRebate(_tokenId);\r\n\r\n        balances[owners[_tokenId]]--;\r\n        delete cityToToken[tokenToCity(_tokenId)];\r\n        destroyed++;\r\n\r\n        //Doesnt' include admin fees in evacedFunds\r\n        evacuatedFunds += fromPool;\r\n\r\n        emit Transfer(owners[_tokenId],address(0),_tokenId);\r\n\r\n\r\n        payable(msg.sender).send(\r\n            toWithdraw\r\n        );\r\n    }\r\n\r\n\r\n    function getEvacuationRebate(uint _tokenId) public view returns(uint) {\r\n        (uint8 _reinforcement, uint8 _damage, bytes32 _lastImpact) = getStructuralData(_tokenId);\r\n        _lastImpact;\r\n        return MINT_COST * (1 + _reinforcement - _damage) *  MINT_PERCENT_CALLER / 100;\r\n    }\r\n\r\n    function confirmHit(uint _tokenId) public{\r\n        require(stage() == Stage.Apocalypse,\"stage\");\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n\r\n        (uint8 _reinforcement, uint8 _damage, bytes32 _lastImpact) = getStructuralData(_tokenId);\r\n\r\n        //  covered by isValidToken\r\n        //      require(_damage <= _reinforcement,\"eliminated\" );\r\n\r\n        require(checkVulnerable(_tokenId,_lastImpact),\"vulnerable\");\r\n\r\n        (int64[2] memory _coordinates, int64 _radius, bytes32 _impactId) = currentImpact();\r\n        _coordinates;_radius;\r\n\r\n        _impactId = encodeImpact(_impactId);\r\n\r\n        emit Impact(_tokenId);\r\n\r\n\r\n        if(_damage < _reinforcement){\r\n            _damage++;\r\n            setStructuralData(_tokenId,_reinforcement,_damage,_impactId);\r\n        }else{\r\n            balances[owners[_tokenId]]--;\r\n            delete cityToToken[tokenToCity(_tokenId)];\r\n            destroyed++;\r\n\r\n            emit Transfer(owners[_tokenId],address(0),_tokenId);\r\n        }\r\n\r\n        payable(msg.sender).send(MINT_COST * MINT_PERCENT_CALLER / 100);\r\n    }\r\n\r\n\r\n    function winnerWithdraw(uint _winnerTokenId) public{\r\n        require(stage() == Stage.PostApocalypse,\"stage\");\r\n        require(isValidToken(_winnerTokenId),\"invalid\");\r\n\r\n        // Implicitly makes sure its the right token since all others don't exist\r\n        require(msg.sender == ownerOf(_winnerTokenId),\"ownerOf\");\r\n        require(!winnerWithdrawn,\"withdrawn\");\r\n\r\n        winnerWithdrawn = true;\r\n\r\n        uint toWithdraw = winnerPrize(_winnerTokenId);\r\n        if(toWithdraw > address(this).balance){\r\n            //Catch rounding errors\r\n            toWithdraw = address(this).balance;\r\n        }\r\n\r\n        payable(msg.sender).send(toWithdraw);\r\n\r\n    }\r\n\r\n    function ownerWithdraw() public{\r\n        require(msg.sender == owner,\"owner\");\r\n\r\n        uint cityCount = tokenIndexToCity.length;\r\n\r\n        // Dev and creator portion of all mint fees collected\r\n        uint toWithdraw = MINT_COST * cityCount * (MINT_PERCENT_CREATOR) / 100\r\n            //plus reinforcement for creator\r\n            + reinforcements * REINFORCE_PERCENT_CREATOR / 100\r\n            //less what has already been withdrawn;\r\n            - ownerWithdrawn;\r\n\r\n        require(toWithdraw > 0,\"empty\");\r\n\r\n        if(toWithdraw > address(this).balance){\r\n            //Catch rounding errors\r\n            toWithdraw = address(this).balance;\r\n        }\r\n        ownerWithdrawn += toWithdraw;\r\n\r\n        payable(msg.sender).send(toWithdraw);\r\n    }\r\n\r\n\r\n    function currentImpact() public view returns (int64[2] memory _coordinates, int64 _radius, bytes32 impactId){\r\n        uint eliminationBlock = block.number - (block.number % IMPACT_BLOCK_INTERVAL) - 5;\r\n        int hash = int(uint(blockhash(eliminationBlock))%uint(type(int).max) );\r\n\r\n\r\n        //Min radius is half map height divided by num\r\n        int o = MAP_HEIGHT/2/int(totalSupply()+1);\r\n\r\n        //Limited in smallness to about 8% of map height\r\n        if(o < BASE_BLAST_RADIUS){\r\n            o = BASE_BLAST_RADIUS;\r\n        }\r\n        //Max radius is twice this\r\n        _coordinates[0] = int64(hash%MAP_WIDTH - MAP_WIDTH/2);\r\n        _coordinates[1] = int64((hash/MAP_WIDTH)%MAP_HEIGHT - MAP_HEIGHT/2);\r\n        _radius = int64((hash/MAP_WIDTH/MAP_HEIGHT)%o + o);\r\n\r\n        return(_coordinates,_radius, keccak256(abi.encodePacked(_coordinates,_radius)));\r\n    }\r\n\r\n    function checkVulnerable(uint _tokenId, bytes32 _lastImpact) internal view returns(bool){\r\n        (int64[2] memory _coordinates, int64 _radius, bytes32 _impactId) = currentImpact();\r\n\r\n        if(_lastImpact == encodeImpact(_impactId)) return false;\r\n\r\n        uint16 _cityId = tokenToCity(_tokenId);\r\n\r\n        int64 dx = coordinates[_cityId][0] - _coordinates[0];\r\n        int64 dy = coordinates[_cityId][1] - _coordinates[1];\r\n\r\n        return (dx**2 + dy**2 < _radius**2) ||\r\n        ((dx + MAP_WIDTH )**2 + dy**2 < _radius**2) ||\r\n        ((dx - MAP_WIDTH )**2 + dy**2 < _radius**2);\r\n    }\r\n\r\n    function isVulnerable(uint _tokenId) public  view returns(bool){\r\n\r\n        (uint8 _reinforcement, uint8 _damage, bytes32 _lastImpact) = getStructuralData(_tokenId);\r\n        _reinforcement;_damage;\r\n\r\n        return checkVulnerable(_tokenId,_lastImpact);\r\n    }\r\n\r\n\r\n    function getFallen(uint _tokenId) public view returns(uint16 _cityId, address _owner){\r\n        _cityId = tokenToCity(_tokenId);\r\n        _owner = owners[_tokenId];\r\n        require(cityToToken[_cityId] == 0 && _owner != address(0),\"survives\");\r\n        return (_cityId,owners[_tokenId]);\r\n    }\r\n\r\n    function currentPrize() public view returns(uint){\r\n        uint cityCount = tokenIndexToCity.length;\r\n            // 50% of all mint fees collected\r\n            return MINT_COST * cityCount * MINT_PERCENT_WINNER / 100\r\n            //minus fees removed\r\n            - evacuatedFunds\r\n            //plus reinforcement * 90%\r\n            + reinforcements * REINFORCE_PERCENT_WINNER / 100;\r\n    }\r\n\r\n    function winnerPrize(uint _tokenId) public view returns(uint){\r\n        return currentPrize() + getEvacuationRebate(_tokenId);\r\n    }\r\n\r\n\r\n\r\n    ///ERC 721:\r\n    function isValidToken(uint256 _tokenId) internal view returns(bool){\r\n        if(_tokenId == 0) return false;\r\n        return cityToToken[tokenToCity(_tokenId)] != 0;\r\n    }\r\n\r\n\r\n    function balanceOf(address _owner) external override view returns (uint256){\r\n        return balances[_owner];\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public override view returns(address){\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return owners[_tokenId];\r\n    }\r\n\r\n\r\n    function approve(address _approved, uint256 _tokenId) external override {\r\n        address _owner = ownerOf(_tokenId);\r\n        require( _owner == msg.sender                    //Require Sender Owns Token\r\n            || authorised[_owner][msg.sender]                //  or is approved for all.\r\n        ,\"permission\");\r\n        emit Approval(_owner, _approved, _tokenId);\r\n        allowance[_tokenId] = _approved;\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) external override view returns (address) {\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return allowance[_tokenId];\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) external override view returns (bool) {\r\n        return authorised[_owner][_operator];\r\n    }\r\n\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external override {\r\n        emit ApprovalForAll(msg.sender,_operator, _approved);\r\n        authorised[msg.sender][_operator] = _approved;\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public override {\r\n\r\n        //Check Transferable\r\n        //There is a token validity check in ownerOf\r\n        address _owner = ownerOf(_tokenId);\r\n\r\n        require ( _owner == msg.sender             //Require sender owns token\r\n        //Doing the two below manually instead of referring to the external methods saves gas\r\n        || allowance[_tokenId] == msg.sender      //or is approved for this token\r\n            || authorised[_owner][msg.sender]          //or is approved for all\r\n        ,\"permission\");\r\n        require(_owner == _from,\"owner\");\r\n        require(_to != address(0),\"zero\");\r\n\r\n        require(!isVulnerable(_tokenId),\"vulnerable\");\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n\r\n\r\n        owners[_tokenId] =_to;\r\n\r\n        balances[_from]--;\r\n        balances[_to]++;\r\n\r\n        //Reset approved if there is one\r\n        if(allowance[_tokenId] != address(0)){\r\n            delete allowance[_tokenId];\r\n        }\r\n\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public override {\r\n        transferFrom(_from, _to, _tokenId);\r\n\r\n        //Get size of \"_to\" address, if 0 it's a wallet\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_to)\r\n        }\r\n        if(size > 0){\r\n            IERC721TokenReceiver receiver = IERC721TokenReceiver(_to);\r\n            require(receiver.onERC721Received(msg.sender,_from,_tokenId,data) == bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")),\"receiver\");\r\n        }\r\n\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external override {\r\n        safeTransferFrom(_from,_to,_tokenId,\"\");\r\n    }\r\n\r\n\r\n    // METADATA FUNCTIONS\r\n    function tokenURI(uint256 _tokenId) public override view returns (string memory){\r\n        //Note: changed visibility to public\r\n        require(isValidToken(_tokenId),'tokenId');\r\n\r\n        uint _cityId = tokenToCity(_tokenId);\r\n\r\n        uint _i = _cityId;\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k-1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n\r\n\r\n\r\n        return string(abi.encodePacked(__uriBase,bstr,__uriSuffix));\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    function name() external override view returns (string memory _name){\r\n        return __name;\r\n    }\r\n\r\n    function symbol() external override view returns (string memory _symbol){\r\n        return __symbol;\r\n    }\r\n\r\n\r\n    // ENUMERABLE FUNCTIONS\r\n    function totalSupply() public view returns (uint256){\r\n        return tokenIndexToCity.length - destroyed;\r\n    }\r\n    // End 721 Implementation\r\n\r\n    ///////===165 Implementation\r\n    mapping (bytes4 => bool) internal supportedInterfaces;\r\n    function supportsInterface(bytes4 interfaceID) external override view returns (bool){\r\n        return supportedInterfaces[interfaceID];\r\n    }\r\n    ///==End 165\r\n\r\n\r\n    //Admin\r\n    function setOwner(address newOwner) public{\r\n        require(msg.sender == owner,\"owner\");\r\n        owner = newOwner;\r\n    }\r\n    function setUriComponents(string calldata _newBase, string calldata _newSuffix) public{\r\n        require(msg.sender == owner,\"owner\");\r\n\r\n        __uriBase   = bytes(_newBase);\r\n        __uriSuffix = bytes(_newSuffix);\r\n    }\r\n}"
6     },
7     "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
9     },
10     "contracts/interfaces/IERC165.sol": {
11       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}"
12     },
13     "contracts/interfaces/IERC721.sol": {
14       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface IERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}"
15     },
16     "contracts/interfaces/IERC721Metadata.sol": {
17       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\r\ninterface IERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external view returns (string memory _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external view returns (string memory _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}"
18     },
19     "contracts/interfaces/IERC721TokenReceiver.sol": {
20       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface IERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}"
21     }
22   },
23   "settings": {
24     "optimizer": {
25       "enabled": false,
26       "runs": 200
27     },
28     "outputSelection": {
29       "*": {
30         "*": [
31           "evm.bytecode",
32           "evm.deployedBytecode",
33           "devdoc",
34           "userdoc",
35           "metadata",
36           "abi"
37         ]
38       }
39     },
40     "libraries": {}
41   }
42 }}