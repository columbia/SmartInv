{{
  "language": "Solidity",
  "sources": {
    "src/RedeemBBTV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport { IERC20     } from \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { Owned      } from \"solmate/auth/Owned.sol\";\nimport { ICNV       } from \"./ICNV.sol\";\nimport { IRedeemBBT } from \"./IRedeemBBT.sol\";\n\ncontract RedeemBBTV2 is Owned {\n\n    ////////////////////////////////////////////////////////////////////////////\n    // EVENTS\n    ////////////////////////////////////////////////////////////////////////////\n\n    // @notice Emitted when a BBT redemption happens.\n    event Redemption(\n        address indexed _from,\n        uint256 indexed _amount\n    );\n\n    // @notice Emitted when contract is paused/unpaused\n    event Paused (\n        address indexed caller,\n        bool isPaused\n    );\n\n    ////////////////////////////////////////////////////////////////////////////\n    // MUTABLE STATE\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice address of bbtCNV Token\n    address public immutable bbtCNV;\n    /// @notice address of CNV Token\n    address public immutable CNV;\n    /// @notice address of RedeemBBT V1\n    address public immutable redeemBBTV1;\n    /// @notice mapping of how many CNV tokens a bbtCNV holder has redeemed\n    mapping(address => uint256) public redeemed;\n    /// @notice redeem paused;\n    bool public paused;\n    \n    ////////////////////////////////////////////////////////////////////////////\n    // IMMUTABLE STATE\n    ////////////////////////////////////////////////////////////////////////////\n    \n    string internal constant NONE = \"NONE LEFT\";\n    uint256 internal constant JUNE_5_2022 = 1654387200;\n    uint256 internal constant APRIL_1_2023 = 1680307200;\n\n\n    ////////////////////////////////////////////////////////////////////////////\n    // CONSTRUCTOR\n    ////////////////////////////////////////////////////////////////////////////\n    \n    // Better to use cosntants for production here. \n    constructor(\n        address _bbtCNV, \n        address _CNV, \n        address _redeemBBTV1\n    ) Owned(msg.sender) {\n        bbtCNV = _bbtCNV;\n        CNV = _CNV;\n        redeemBBTV1 = _redeemBBTV1;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // ADMIN/MGMT\n    ////////////////////////////////////////////////////////////////////////////\n\n    function setPause(\n        bool _paused\n    ) external onlyOwner {\n        paused = _paused;\n        emit Paused(msg.sender, _paused);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // ACTIONS\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice             redeem bbtCNV for CNV following vesting schedule\n    /// @param  _amount     amount of CNV to redeem, irrelevant if _max = true\n    /// @param  _to         address to which to mint CNV\n    /// @param  _max        whether to redeem maximum amount possible\n    /// @return amountOut   amount of CNV tokens to be minted to _to\n    function redeem(\n        uint256 _amount, \n        address _to, \n        bool _max\n    ) external returns (uint256 amountOut) {\n        // Check if it's paused\n        require(!paused, \"PAUSED\");\n        // Get user bbtCNV balance, and get amount already redeemed.\n        // If already redeemed full balance - revert on \"FULLY_REDEEMED\" since\n        // all balance has already been redeemed.\n        uint256 bbtCNVBalance = IERC20(bbtCNV).balanceOf(msg.sender);\n        uint256 amountRedeemed = redeemed[msg.sender] + IRedeemBBT(redeemBBTV1).redeemed(msg.sender);\n        require(bbtCNVBalance > amountRedeemed, NONE);\n\n        // Check how much is currently vested for user.\n        // Revert if currently no more available to redeem.\n        uint256 currentTime = block.timestamp;\n        require(currentTime >= JUNE_5_2022, \"NOT_VESTED\");\n        uint256 amountVested;\n        \n        if (currentTime > APRIL_1_2023) {\n            amountVested = bbtCNVBalance;\n        } else {\n            uint256 vpct = vestedPercent(currentTime);\n            amountVested = bbtCNVBalance * vpct / 1e18;\n        }\n        \n        require(amountVested > amountRedeemed, NONE);\n\n        // Calculate amount redeemable as the amountVested minus the amount that\n        // has previously been redeemed.\n        // If _max was not selected and thus a specified amount is to be\n        // redeemed, ensure this amount doesn't exceed amountRedeemable.\n        uint256 amountRedeemable = amountVested - amountRedeemed;\n        amountOut = amountRedeemable;\n        if (!_max) {\n            require(amountRedeemable >= _amount,\"EXCEEDS\");\n            amountOut = _amount;\n        }\n\n        // Update state to reflect redemption.\n        redeemed[msg.sender] += amountOut;\n\n        // Transfer CNV\n        ICNV(CNV).transfer(_to, amountOut);\n\n        emit Redemption(msg.sender, amountOut);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // VIEW\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice         to view how much a holder has redeemable\n    /// @param  _who    bbtHolder address\n    /// @return         amount redeemable\n    function redeemable(\n        address _who\n    ) external view returns (uint256) {\n        uint256 bbtCNVBalance = IERC20(bbtCNV).balanceOf(_who);\n        uint256 amountRedeemed = redeemed[_who] + IRedeemBBT(redeemBBTV1).redeemed(_who);\n        if (bbtCNVBalance == amountRedeemed) return 0;\n\n        uint256 currentTime = block.timestamp;\n        if (currentTime < JUNE_5_2022) return 0;\n\n        uint256 amountVested;\n        if (currentTime > APRIL_1_2023) {\n            amountVested = bbtCNVBalance;\n        } else {\n            uint256 vpct = vestedPercent(currentTime);\n            amountVested = bbtCNVBalance * vpct / 1e18;\n        }\n        if (amountVested <= amountRedeemed) return 0;\n\n        return amountVested - amountRedeemed;\n    }\n\n    /// @notice         returns the percent of holdings vested for a given point\n    ///                 in time.\n    /// @param  _time   point in time\n    /// @return vpct    percent of holdings vested\n    function vestedPercent(\n        uint256 _time\n    ) public pure returns (uint256 vpct) {\n        // Hardcode variables in method to avoid state reads and save gas.\n        //\n        // vestingTimeStart\n        // - time vesting begins: JUNE_5_2022 (Sun Jun 05 2022 00:00:00 GMT+0000)\n        //\n        // vestingTimeLength\n        // - duration of vesting: 25920000 (10 30-day months)\n        //\n        // vestingAmountStart\n        // - vesting begins at 2%\n        //\n        // vestingAmountLength\n        // - vesting grows to 100%, thus has a length of 98\n\n        uint256 vestingTimeStart    = JUNE_5_2022;\n        uint256 vestingTimeLength   = 25920000;\n        uint256 vestingAmountStart  = 2e16;\n        uint256 vestingAmountLength = 98e16;\n\n        uint256 pctOf = _percentOf(vestingTimeStart, _time, vestingTimeLength);\n        vpct = _linearMapping(vestingAmountStart, pctOf, vestingAmountLength);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // INTERNAL\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice             returns the elapsed percentage of a point within\n    ///                     a given range\n    /// @param  _start      starting point\n    /// @param  _point      current point\n    /// @param  _length     lenght\n    /// @return elapsedPct  percent from _start\n    function _percentOf(\n        uint256 _start, \n        uint256 _point, \n        uint256 _length\n    ) internal pure returns(uint256 elapsedPct) {\n        uint256 elapsed             = _point - _start;\n                elapsedPct          = elapsed * 1e18 / _length;\n    }\n\n    /// @notice             linearly maps a percentage point to a range\n    /// @param  _start      starting point\n    /// @param  _pct        percentage point\n    /// @param  _length     lenght\n    /// @return point       point\n    function _linearMapping(\n        uint256 _start, \n        uint256 _pct, \n        uint256 _length\n    ) internal pure returns (uint256 point) {\n        uint256 elapsed             = _length * _pct / 1e18;\n                point               = _start + elapsed;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "lib/solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnerUpdated(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setOwner(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n"
    },
    "src/ICNV.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport {IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\ninterface ICNV is IERC20 {\n    function mint(address account, uint256 amount) external;\n}\n"
    },
    "src/IRedeemBBT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\n\ninterface IRedeemBBT {\n\n    /// @notice mapping of how many CNV tokens a bbtCNV holder has redeemed\n    /// @param      _who    address\n    /// @return     amount  amount redeemed so far\n    function redeemed(address _who)\n        external\n        view\n        returns(uint256 amount);\n\n    /// @notice             redeem bbtCNV for CNV following vesting schedule\n    /// @param  _amount     amount of CNV to redeem, irrelevant if _max = true\n    /// @param  _who        address of bbtCNV holder to redeem\n    /// @param  _to         address to which to mint CNV\n    /// @param  _max        whether to redeem maximum amount possible\n    /// @return amountOut   amount of CNV tokens to be minted to _to\n    function redeem(uint256 _amount, address _who, address _to, bool _max)\n        external\n        returns(uint256 amountOut);\n\n    /// @notice         to view how much a holder has redeemable\n    /// @param  _who    bbtHolder address\n    /// @return         amount redeemable\n    function redeemable(address _who)\n        external\n        view\n        returns(uint256);\n\n    /// @notice         returns the percent of holdings vested for a given point\n    ///                 in time.\n    /// @param  _time   point in time\n    /// @return vpct    percent of holdings vested\n    function vestedPercent(uint256 _time)\n        external\n        pure\n        returns(uint256 vpct);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/ds-test/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "solmate/=lib/solmate/src/",
      "src/=src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london"
  }
}}