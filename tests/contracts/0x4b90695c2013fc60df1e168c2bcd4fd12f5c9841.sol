{{
  "language": "Solidity",
  "sources": {
    "/Users/yudi/git/staking-rewards/packages/solidity/contracts/IStakingRewardsStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@bancor/contracts-solidity/solidity/contracts/token/interfaces/IDSToken.sol\";\n\nstruct PoolProgram {\n    uint256 startTime;\n    uint256 endTime;\n    uint256 rewardRate;\n    IERC20[2] reserveTokens;\n    uint32[2] rewardShares;\n}\n\nstruct PoolRewards {\n    uint256 lastUpdateTime;\n    uint256 rewardPerToken;\n    uint256 totalClaimedRewards;\n}\n\nstruct ProviderRewards {\n    uint256 rewardPerToken;\n    uint256 pendingBaseRewards;\n    uint256 totalClaimedRewards;\n    uint256 effectiveStakingTime;\n    uint256 baseRewardsDebt;\n    uint32 baseRewardsDebtMultiplier;\n}\n\ninterface IStakingRewardsStore {\n    function isPoolParticipating(IDSToken poolToken) external view returns (bool);\n\n    function isReserveParticipating(IDSToken poolToken, IERC20 reserveToken) external view returns (bool);\n\n    function addPoolProgram(\n        IDSToken poolToken,\n        IERC20[2] calldata reserveTokens,\n        uint32[2] calldata rewardShares,\n        uint256 endTime,\n        uint256 rewardRate\n    ) external;\n\n    function removePoolProgram(IDSToken poolToken) external;\n\n    function setPoolProgramEndTime(IDSToken poolToken, uint256 newEndTime) external;\n\n    function poolProgram(IDSToken poolToken)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            IERC20[2] memory,\n            uint32[2] memory\n        );\n\n    function poolPrograms()\n        external\n        view\n        returns (\n            IDSToken[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            IERC20[2][] memory,\n            uint32[2][] memory\n        );\n\n    function poolRewards(IDSToken poolToken, IERC20 reserveToken)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function updatePoolRewardsData(\n        IDSToken poolToken,\n        IERC20 reserveToken,\n        uint256 lastUpdateTime,\n        uint256 rewardPerToken,\n        uint256 totalClaimedRewards\n    ) external;\n\n    function providerRewards(\n        address provider,\n        IDSToken poolToken,\n        IERC20 reserveToken\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint32\n        );\n\n    function updateProviderRewardsData(\n        address provider,\n        IDSToken poolToken,\n        IERC20 reserveToken,\n        uint256 rewardPerToken,\n        uint256 pendingBaseRewards,\n        uint256 totalClaimedRewards,\n        uint256 effectiveStakingTime,\n        uint256 baseRewardsDebt,\n        uint32 baseRewardsDebtMultiplier\n    ) external;\n\n    function updateProviderLastClaimTime(address provider) external;\n\n    function providerLastClaimTime(address provider) external view returns (uint256);\n}\n"
    },
    "/Users/yudi/git/staking-rewards/packages/solidity/contracts/StakingRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\nimport \"@bancor/contracts-solidity/solidity/contracts/utility/ContractRegistryClient.sol\";\nimport \"@bancor/contracts-solidity/solidity/contracts/utility/Utils.sol\";\nimport \"@bancor/contracts-solidity/solidity/contracts/utility/Time.sol\";\nimport \"@bancor/contracts-solidity/solidity/contracts/utility/interfaces/ICheckpointStore.sol\";\nimport \"@bancor/contracts-solidity/solidity/contracts/liquidity-protection/interfaces/ILiquidityProtection.sol\";\nimport \"@bancor/contracts-solidity/solidity/contracts/liquidity-protection/interfaces/ILiquidityProtectionEventsSubscriber.sol\";\n\nimport \"./IStakingRewardsStore.sol\";\n\n/**\n * @dev This contract manages the distribution of the staking rewards\n */\ncontract StakingRewards is ILiquidityProtectionEventsSubscriber, AccessControl, Time, Utils, ContractRegistryClient {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // the role is used to globally govern the contract and its governing roles.\n    bytes32 public constant ROLE_SUPERVISOR = keccak256(\"ROLE_SUPERVISOR\");\n\n    // the roles is used to restrict who is allowed to publish liquidity protection events.\n    bytes32 public constant ROLE_PUBLISHER = keccak256(\"ROLE_PUBLISHER\");\n\n    // the roles is used to restrict who is allowed to update/cache provider rewards.\n    bytes32 public constant ROLE_UPDATER = keccak256(\"ROLE_UPDATER\");\n\n    uint32 private constant PPM_RESOLUTION = 1000000;\n\n    // the weekly 25% increase of the rewards multiplier (in units of PPM).\n    uint32 private constant MULTIPLIER_INCREMENT = PPM_RESOLUTION / 4;\n\n    // the maximum weekly 200% rewards multiplier (in units of PPM).\n    uint32 private constant MAX_MULTIPLIER = PPM_RESOLUTION + MULTIPLIER_INCREMENT * 4;\n\n    // the rewards halving factor we need to take into account during the sanity verification process.\n    uint8 private constant REWARDS_HALVING_FACTOR = 2;\n\n    // since we will be dividing by the total amount of protected tokens in units of wei, we can encounter cases\n    // where the total amount in the denominator is higher than the product of the rewards rate and staking duration. In\n    // order to avoid this imprecision, we will amplify the reward rate by the units amount.\n    uint256 private constant REWARD_RATE_FACTOR = 1e18;\n\n    uint256 private constant MAX_UINT256 = uint256(-1);\n\n    // the staking rewards settings.\n    IStakingRewardsStore private immutable _store;\n\n    // the permissioned wrapper around the network token which should allow this contract to mint staking rewards.\n    ITokenGovernance private immutable _networkTokenGovernance;\n\n    // the address of the network token.\n    IERC20 private immutable _networkToken;\n\n    // the checkpoint store recording last protected position removal times.\n    ICheckpointStore private immutable _lastRemoveTimes;\n\n    /**\n     * @dev triggered when pending rewards are being claimed\n     *\n     * @param provider the owner of the liquidity\n     * @param amount the total rewards amount\n     */\n    event RewardsClaimed(address indexed provider, uint256 amount);\n\n    /**\n     * @dev triggered when pending rewards are being staked in a pool\n     *\n     * @param provider the owner of the liquidity\n     * @param poolToken the pool token representing the rewards pool\n     * @param amount the reward amount\n     * @param newId the ID of the new position\n     */\n    event RewardsStaked(address indexed provider, IDSToken indexed poolToken, uint256 amount, uint256 indexed newId);\n\n    /**\n     * @dev initializes a new StakingRewards contract\n     *\n     * @param store the staking rewards store\n     * @param networkTokenGovernance the permissioned wrapper around the network token\n     * @param lastRemoveTimes the checkpoint store recording last protected position removal times\n     * @param registry address of a contract registry contract\n     */\n    constructor(\n        IStakingRewardsStore store,\n        ITokenGovernance networkTokenGovernance,\n        ICheckpointStore lastRemoveTimes,\n        IContractRegistry registry\n    )\n        public\n        validAddress(address(store))\n        validAddress(address(networkTokenGovernance))\n        validAddress(address(lastRemoveTimes))\n        ContractRegistryClient(registry)\n    {\n        _store = store;\n        _networkTokenGovernance = networkTokenGovernance;\n        _networkToken = networkTokenGovernance.token();\n        _lastRemoveTimes = lastRemoveTimes;\n\n        // set up administrative roles.\n        _setRoleAdmin(ROLE_SUPERVISOR, ROLE_SUPERVISOR);\n        _setRoleAdmin(ROLE_PUBLISHER, ROLE_SUPERVISOR);\n        _setRoleAdmin(ROLE_UPDATER, ROLE_SUPERVISOR);\n\n        // allow the deployer to initially govern the contract.\n        _setupRole(ROLE_SUPERVISOR, _msgSender());\n    }\n\n    modifier onlyPublisher() {\n        _onlyPublisher();\n        _;\n    }\n\n    function _onlyPublisher() internal view {\n        require(hasRole(ROLE_PUBLISHER, msg.sender), \"ERR_ACCESS_DENIED\");\n    }\n\n    modifier onlyUpdater() {\n        _onlyUpdater();\n        _;\n    }\n\n    function _onlyUpdater() internal view {\n        require(hasRole(ROLE_UPDATER, msg.sender), \"ERR_ACCESS_DENIED\");\n    }\n\n    /**\n     * @dev liquidity provision notification callback. The callback should be called *before* the liquidity is added in\n     * the LP contract.\n     *\n     * @param provider the owner of the liquidity\n     * @param poolAnchor the pool token representing the rewards pool\n     * @param reserveToken the reserve token of the added liquidity\n     */\n    function onAddingLiquidity(\n        address provider,\n        IConverterAnchor poolAnchor,\n        IERC20 reserveToken,\n        uint256, /* poolAmount */\n        uint256 /* reserveAmount */\n    ) external override onlyPublisher validExternalAddress(provider) {\n        IDSToken poolToken = IDSToken(address(poolAnchor));\n        PoolProgram memory program = poolProgram(poolToken);\n        if (program.startTime == 0) {\n            return;\n        }\n\n        updateRewards(provider, poolToken, reserveToken, program, liquidityProtectionStats());\n    }\n\n    /**\n     * @dev liquidity removal callback. The callback must be called *before* the liquidity is removed in the LP\n     * contract\n     *\n     * @param provider the owner of the liquidity\n     */\n    function onRemovingLiquidity(\n        uint256, /* id */\n        address provider,\n        IConverterAnchor, /* poolAnchor */\n        IERC20, /* reserveToken */\n        uint256, /* poolAmount */\n        uint256 /* reserveAmount */\n    ) external override onlyPublisher validExternalAddress(provider) {\n        ILiquidityProtectionStats lpStats = liquidityProtectionStats();\n\n        // make sure that all pending rewards are properly stored for future claims, with retroactive rewards\n        // multipliers.\n        storeRewards(provider, lpStats.providerPools(provider), lpStats);\n    }\n\n    /**\n     * @dev returns the staking rewards store\n     *\n     * @return the staking rewards store\n     */\n    function store() external view returns (IStakingRewardsStore) {\n        return _store;\n    }\n\n    /**\n     * @dev returns the network token governance\n     *\n     * @return the network token governance\n     */\n    function networkTokenGovernance() external view returns (ITokenGovernance) {\n        return _networkTokenGovernance;\n    }\n\n    /**\n     * @dev returns the last remove times\n     *\n     * @return the last remove times\n     */\n    function lastRemoveTimes() external view returns (ICheckpointStore) {\n        return _lastRemoveTimes;\n    }\n\n    /**\n     * @dev returns specific provider's pending rewards for all participating pools\n     *\n     * @param provider the owner of the liquidity\n     *\n     * @return all pending rewards\n     */\n    function pendingRewards(address provider) external view returns (uint256) {\n        return pendingRewards(provider, liquidityProtectionStats());\n    }\n\n    /**\n     * @dev returns specific provider's pending rewards for a specific participating pool\n     *\n     * @param provider the owner of the liquidity\n     * @param poolToken the pool token representing the new rewards pool\n     *\n     * @return all pending rewards\n     */\n    function pendingPoolRewards(address provider, IDSToken poolToken) external view returns (uint256) {\n        return pendingRewards(provider, poolToken, liquidityProtectionStats());\n    }\n\n    /**\n     * @dev returns specific provider's pending rewards for a specific participating pool/reserve\n     *\n     * @param provider the owner of the liquidity\n     * @param poolToken the pool token representing the new rewards pool\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     *\n     * @return all pending rewards\n     */\n    function pendingReserveRewards(\n        address provider,\n        IDSToken poolToken,\n        IERC20 reserveToken\n    ) external view returns (uint256) {\n        PoolProgram memory program = poolProgram(poolToken);\n\n        return pendingRewards(provider, poolToken, reserveToken, program, liquidityProtectionStats());\n    }\n\n    /**\n     * @dev returns the current rewards multiplier for a provider in a given pool\n     *\n     * @param provider the owner of the liquidity\n     * @param poolToken the pool to query\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     *\n     * @return rewards multiplier\n     */\n    function rewardsMultiplier(\n        address provider,\n        IDSToken poolToken,\n        IERC20 reserveToken\n    ) external view returns (uint32) {\n        ProviderRewards memory providerRewards = providerRewards(provider, poolToken, reserveToken);\n        PoolProgram memory program = poolProgram(poolToken);\n        return rewardsMultiplier(provider, providerRewards.effectiveStakingTime, program);\n    }\n\n    /**\n     * @dev returns specific provider's total claimed rewards from all participating pools\n     *\n     * @param provider the owner of the liquidity\n     *\n     * @return total claimed rewards from all participating pools\n     */\n    function totalClaimedRewards(address provider) external view returns (uint256) {\n        uint256 totalRewards = 0;\n\n        ILiquidityProtectionStats lpStats = liquidityProtectionStats();\n        IDSToken[] memory poolTokens = lpStats.providerPools(provider);\n\n        for (uint256 i = 0; i < poolTokens.length; ++i) {\n            IDSToken poolToken = poolTokens[i];\n            PoolProgram memory program = poolProgram(poolToken);\n\n            for (uint256 j = 0; j < program.reserveTokens.length; ++j) {\n                IERC20 reserveToken = program.reserveTokens[j];\n\n                ProviderRewards memory providerRewards = providerRewards(provider, poolToken, reserveToken);\n\n                totalRewards = totalRewards.add(providerRewards.totalClaimedRewards);\n            }\n        }\n\n        return totalRewards;\n    }\n\n    /**\n     * @dev claims pending rewards from all participating pools\n     *\n     * @return all claimed rewards\n     */\n    function claimRewards() external returns (uint256) {\n        return claimPendingRewards(msg.sender, liquidityProtectionStats());\n    }\n\n    /**\n     * @dev stakes specific pending rewards from all participating pools\n     *\n     * @param maxAmount an optional cap on the rewards to stake\n     * @param poolToken the pool token representing the new rewards pool\n\n     * @return all staked rewards and the ID of the new position\n     */\n    function stakeRewards(uint256 maxAmount, IDSToken poolToken) external returns (uint256, uint256) {\n        return stakeRewards(msg.sender, maxAmount, poolToken, liquidityProtectionStats());\n    }\n\n    /**\n     * @dev store pending rewards for a list of providers in a specific pool for future claims\n     *\n     * @param providers owners of the liquidity\n     * @param poolToken the participating pool to update\n     */\n    function storePoolRewards(address[] calldata providers, IDSToken poolToken) external onlyUpdater {\n        ILiquidityProtectionStats lpStats = liquidityProtectionStats();\n        PoolProgram memory program = poolProgram(poolToken);\n\n        for (uint256 i = 0; i < providers.length; ++i) {\n            for (uint256 j = 0; j < program.reserveTokens.length; ++j) {\n                storeRewards(providers[i], poolToken, program.reserveTokens[j], program, lpStats, false);\n            }\n        }\n    }\n\n    /**\n     * @dev returns specific provider's pending rewards for all participating pools\n     *\n     * @param provider the owner of the liquidity\n     * @param lpStats liquidity protection statistics store\n     *\n     * @return all pending rewards\n     */\n    function pendingRewards(address provider, ILiquidityProtectionStats lpStats) private view returns (uint256) {\n        return pendingRewards(provider, lpStats.providerPools(provider), lpStats);\n    }\n\n    /**\n     * @dev returns specific provider's pending rewards for a specific list of participating pools\n     *\n     * @param provider the owner of the liquidity\n     * @param poolTokens the list of participating pools to query\n     * @param lpStats liquidity protection statistics store\n     *\n     * @return all pending rewards\n     */\n    function pendingRewards(\n        address provider,\n        IDSToken[] memory poolTokens,\n        ILiquidityProtectionStats lpStats\n    ) private view returns (uint256) {\n        uint256 reward = 0;\n\n        uint256 length = poolTokens.length;\n        for (uint256 i = 0; i < length; ++i) {\n            uint256 poolReward = pendingRewards(provider, poolTokens[i], lpStats);\n            reward = reward.add(poolReward);\n        }\n\n        return reward;\n    }\n\n    /**\n     * @dev returns specific provider's pending rewards for a specific pool\n     *\n     * @param provider the owner of the liquidity\n     * @param poolToken the pool to query\n     * @param lpStats liquidity protection statistics store\n     *\n     * @return reward all pending rewards\n     */\n    function pendingRewards(\n        address provider,\n        IDSToken poolToken,\n        ILiquidityProtectionStats lpStats\n    ) private view returns (uint256) {\n        uint256 reward = 0;\n        PoolProgram memory program = poolProgram(poolToken);\n\n        for (uint256 i = 0; i < program.reserveTokens.length; ++i) {\n            uint256 reserveReward = pendingRewards(provider, poolToken, program.reserveTokens[i], program, lpStats);\n            reward = reward.add(reserveReward);\n        }\n\n        return reward;\n    }\n\n    /**\n     * @dev returns specific provider's pending rewards for a specific pool/reserve\n     *\n     * @param provider the owner of the liquidity\n     * @param poolToken the pool to query\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     * @param program the pool program info\n     * @param lpStats liquidity protection statistics store\n     *\n     * @return reward all pending rewards\n     */\n\n    function pendingRewards(\n        address provider,\n        IDSToken poolToken,\n        IERC20 reserveToken,\n        PoolProgram memory program,\n        ILiquidityProtectionStats lpStats\n    ) private view returns (uint256) {\n        if (!isProgramValid(reserveToken, program)) {\n            return 0;\n        }\n\n        // calculate the new reward rate per-token\n        PoolRewards memory poolRewardsData = poolRewards(poolToken, reserveToken);\n\n        // rewardPerToken must be calculated with the previous value of lastUpdateTime.\n        poolRewardsData.rewardPerToken = rewardPerToken(poolToken, reserveToken, poolRewardsData, program, lpStats);\n        poolRewardsData.lastUpdateTime = Math.min(time(), program.endTime);\n\n        // update provider's rewards with the newly claimable base rewards and the new reward rate per-token.\n        ProviderRewards memory providerRewards = providerRewards(provider, poolToken, reserveToken);\n\n        // if this is the first liquidity provision - set the effective staking time to the current time.\n        if (\n            providerRewards.effectiveStakingTime == 0 &&\n            lpStats.totalProviderAmount(provider, poolToken, reserveToken) == 0\n        ) {\n            providerRewards.effectiveStakingTime = time();\n        }\n\n        // pendingBaseRewards must be calculated with the previous value of providerRewards.rewardPerToken.\n        providerRewards.pendingBaseRewards = providerRewards.pendingBaseRewards.add(\n            baseRewards(provider, poolToken, reserveToken, poolRewardsData, providerRewards, program, lpStats)\n        );\n        providerRewards.rewardPerToken = poolRewardsData.rewardPerToken;\n\n        // get full rewards and the respective rewards multiplier.\n        (uint256 fullReward, ) =\n            fullRewards(provider, poolToken, reserveToken, poolRewardsData, providerRewards, program, lpStats);\n\n        return fullReward;\n    }\n\n    /**\n     * @dev claims specific provider's pending rewards for a specific list of participating pools\n     *\n     * @param provider the owner of the liquidity\n     * @param poolTokens the list of participating pools to query\n     * @param maxAmount an optional bound on the rewards to claim (when partial claiming is required)\n     * @param lpStats liquidity protection statistics store\n     * @param resetStakingTime true to reset the effective staking time, false to keep it as is\n     *\n     * @return all pending rewards\n     */\n    function claimPendingRewards(\n        address provider,\n        IDSToken[] memory poolTokens,\n        uint256 maxAmount,\n        ILiquidityProtectionStats lpStats,\n        bool resetStakingTime\n    ) private returns (uint256) {\n        uint256 reward = 0;\n\n        uint256 length = poolTokens.length;\n        for (uint256 i = 0; i < length && maxAmount > 0; ++i) {\n            uint256 poolReward = claimPendingRewards(provider, poolTokens[i], maxAmount, lpStats, resetStakingTime);\n            reward = reward.add(poolReward);\n\n            if (maxAmount != MAX_UINT256) {\n                maxAmount = maxAmount.sub(poolReward);\n            }\n        }\n\n        return reward;\n    }\n\n    /**\n     * @dev claims specific provider's pending rewards for a specific pool\n     *\n     * @param provider the owner of the liquidity\n     * @param poolToken the pool to query\n     * @param maxAmount an optional bound on the rewards to claim (when partial claiming is required)\n     * @param lpStats liquidity protection statistics store\n     * @param resetStakingTime true to reset the effective staking time, false to keep it as is\n     *\n     * @return reward all pending rewards\n     */\n    function claimPendingRewards(\n        address provider,\n        IDSToken poolToken,\n        uint256 maxAmount,\n        ILiquidityProtectionStats lpStats,\n        bool resetStakingTime\n    ) private returns (uint256) {\n        uint256 reward = 0;\n        PoolProgram memory program = poolProgram(poolToken);\n\n        for (uint256 i = 0; i < program.reserveTokens.length && maxAmount > 0; ++i) {\n            uint256 reserveReward =\n                claimPendingRewards(\n                    provider,\n                    poolToken,\n                    program.reserveTokens[i],\n                    program,\n                    maxAmount,\n                    lpStats,\n                    resetStakingTime\n                );\n            reward = reward.add(reserveReward);\n\n            if (maxAmount != MAX_UINT256) {\n                maxAmount = maxAmount.sub(reserveReward);\n            }\n        }\n\n        return reward;\n    }\n\n    /**\n     * @dev claims specific provider's pending rewards for a specific pool/reserve\n     *\n     * @param provider the owner of the liquidity\n     * @param poolToken the pool to query\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     * @param program the pool program info\n     * @param maxAmount an optional bound on the rewards to claim (when partial claiming is required)\n     * @param lpStats liquidity protection statistics store\n     * @param resetStakingTime true to reset the effective staking time, false to keep it as is\n     *\n     * @return reward all pending rewards\n     */\n\n    function claimPendingRewards(\n        address provider,\n        IDSToken poolToken,\n        IERC20 reserveToken,\n        PoolProgram memory program,\n        uint256 maxAmount,\n        ILiquidityProtectionStats lpStats,\n        bool resetStakingTime\n    ) private returns (uint256) {\n        // update all provider's pending rewards, in order to apply retroactive reward multipliers.\n        (PoolRewards memory poolRewardsData, ProviderRewards memory providerRewards) =\n            updateRewards(provider, poolToken, reserveToken, program, lpStats);\n\n        // get full rewards and the respective rewards multiplier.\n        (uint256 fullReward, uint32 multiplier) =\n            fullRewards(provider, poolToken, reserveToken, poolRewardsData, providerRewards, program, lpStats);\n\n        // mark any debt as repaid.\n        providerRewards.baseRewardsDebt = 0;\n        providerRewards.baseRewardsDebtMultiplier = 0;\n\n        if (maxAmount != MAX_UINT256 && fullReward > maxAmount) {\n            // get the amount of the actual base rewards that were claimed.\n            providerRewards.baseRewardsDebt = removeMultiplier(fullReward.sub(maxAmount), multiplier);\n\n            // store the current multiplier for future retroactive rewards correction.\n            providerRewards.baseRewardsDebtMultiplier = multiplier;\n\n            // grant only maxAmount rewards.\n            fullReward = maxAmount;\n        }\n\n        // update pool rewards data total claimed rewards.\n        _store.updatePoolRewardsData(\n            poolToken,\n            reserveToken,\n            poolRewardsData.lastUpdateTime,\n            poolRewardsData.rewardPerToken,\n            poolRewardsData.totalClaimedRewards.add(fullReward)\n        );\n\n        // update provider rewards data with the remaining pending rewards and if needed, set the effective\n        // staking time to the timestamp of the current block.\n        _store.updateProviderRewardsData(\n            provider,\n            poolToken,\n            reserveToken,\n            providerRewards.rewardPerToken,\n            0,\n            providerRewards.totalClaimedRewards.add(fullReward),\n            resetStakingTime ? time() : providerRewards.effectiveStakingTime,\n            providerRewards.baseRewardsDebt,\n            providerRewards.baseRewardsDebtMultiplier\n        );\n\n        return fullReward;\n    }\n\n    /**\n     * @dev claims specific provider's pending rewards from all participating pools\n     *\n     * @param provider the owner of the liquidity\n     * @param lpStats liquidity protection statistics store\n     *\n     * @return all claimed rewards\n     */\n    function claimPendingRewards(address provider, ILiquidityProtectionStats lpStats) private returns (uint256) {\n        return claimPendingRewards(provider, lpStats.providerPools(provider), MAX_UINT256, lpStats);\n    }\n\n    /**\n     * @dev claims specific provider's pending rewards for a specific list of participating pools\n     *\n     * @param provider the owner of the liquidity\n     * @param poolTokens the list of participating pools to query\n     * @param maxAmount an optional cap on the rewards to claim\n     * @param lpStats liquidity protection statistics store\n     *\n     * @return all pending rewards\n     */\n    function claimPendingRewards(\n        address provider,\n        IDSToken[] memory poolTokens,\n        uint256 maxAmount,\n        ILiquidityProtectionStats lpStats\n    ) private returns (uint256) {\n        uint256 amount = claimPendingRewards(provider, poolTokens, maxAmount, lpStats, true);\n        if (amount == 0) {\n            return amount;\n        }\n\n        // make sure to update the last claim time so that it'll be taken into effect when calculating the next rewards\n        // multiplier.\n        _store.updateProviderLastClaimTime(provider);\n\n        // mint the reward tokens directly to the provider.\n        _networkTokenGovernance.mint(provider, amount);\n\n        emit RewardsClaimed(provider, amount);\n\n        return amount;\n    }\n\n    /**\n     * @dev stakes specific provider's pending rewards from all participating pools\n     *\n     * @param provider the owner of the liquidity\n     * @param maxAmount an optional cap on the rewards to stake\n     * @param poolToken the pool token representing the new rewards pool\n     * @param lpStats liquidity protection statistics store\n     *\n     * @return all staked rewards and the ID of the new position\n     */\n    function stakeRewards(\n        address provider,\n        uint256 maxAmount,\n        IDSToken poolToken,\n        ILiquidityProtectionStats lpStats\n    ) private returns (uint256, uint256) {\n        return stakeRewards(provider, lpStats.providerPools(provider), maxAmount, poolToken, lpStats);\n    }\n\n    /**\n     * @dev claims and stakes specific provider's pending rewards for a specific list of participating pools\n     *\n     * @param provider the owner of the liquidity\n     * @param poolTokens the list of participating pools to query\n     * @param newPoolToken the pool token representing the new rewards pool\n     * @param maxAmount an optional cap on the rewards to stake\n     * @param lpStats liquidity protection statistics store\n     *\n     * @return all staked rewards and the ID of the new position\n     */\n    function stakeRewards(\n        address provider,\n        IDSToken[] memory poolTokens,\n        uint256 maxAmount,\n        IDSToken newPoolToken,\n        ILiquidityProtectionStats lpStats\n    ) private returns (uint256, uint256) {\n        uint256 amount = claimPendingRewards(provider, poolTokens, maxAmount, lpStats, false);\n        if (amount == 0) {\n            return (amount, 0);\n        }\n\n        // approve the LiquidityProtection contract to pull the rewards.\n        ILiquidityProtection liquidityProtection = liquidityProtection();\n        address liquidityProtectionAddress = address(liquidityProtection);\n        uint256 allowance = _networkToken.allowance(address(this), liquidityProtectionAddress);\n        if (allowance < amount) {\n            if (allowance > 0) {\n                _networkToken.safeApprove(liquidityProtectionAddress, 0);\n            }\n            _networkToken.safeApprove(liquidityProtectionAddress, amount);\n        }\n\n        // mint the reward tokens directly to the staking contract, so that the LiquidityProtection could pull the\n        // rewards and attribute them to the provider.\n        _networkTokenGovernance.mint(address(this), amount);\n\n        uint256 newId =\n            liquidityProtection.addLiquidityFor(provider, newPoolToken, IERC20(address(_networkToken)), amount);\n\n        // please note, that in order to incentivize staking, we won't be updating the time of the last claim, thus\n        // preserving the rewards bonus multiplier.\n\n        emit RewardsStaked(provider, newPoolToken, amount, newId);\n\n        return (amount, newId);\n    }\n\n    /**\n     * @dev store specific provider's pending rewards for future claims\n     *\n     * @param provider the owner of the liquidity\n     * @param poolTokens the list of participating pools to query\n     * @param lpStats liquidity protection statistics store\n     *\n     */\n    function storeRewards(\n        address provider,\n        IDSToken[] memory poolTokens,\n        ILiquidityProtectionStats lpStats\n    ) private {\n        for (uint256 i = 0; i < poolTokens.length; ++i) {\n            IDSToken poolToken = poolTokens[i];\n            PoolProgram memory program = poolProgram(poolToken);\n\n            for (uint256 j = 0; j < program.reserveTokens.length; ++j) {\n                storeRewards(provider, poolToken, program.reserveTokens[j], program, lpStats, true);\n            }\n        }\n    }\n\n    /**\n     * @dev store specific provider's pending rewards for future claims\n     *\n     * @param provider the owner of the liquidity\n     * @param poolToken the participating pool to query\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     * @param program the pool program info\n     * @param lpStats liquidity protection statistics store\n     * @param resetStakingTime true to reset the effective staking time, false to keep it as is\n     *\n     */\n    function storeRewards(\n        address provider,\n        IDSToken poolToken,\n        IERC20 reserveToken,\n        PoolProgram memory program,\n        ILiquidityProtectionStats lpStats,\n        bool resetStakingTime\n    ) private {\n        if (!isProgramValid(reserveToken, program)) {\n            return;\n        }\n\n        // update all provider's pending rewards, in order to apply retroactive reward multipliers.\n        (PoolRewards memory poolRewardsData, ProviderRewards memory providerRewards) =\n            updateRewards(provider, poolToken, reserveToken, program, lpStats);\n\n        // get full rewards and the respective rewards multiplier.\n        (uint256 fullReward, uint32 multiplier) =\n            fullRewards(provider, poolToken, reserveToken, poolRewardsData, providerRewards, program, lpStats);\n\n        // get the amount of the actual base rewards that were claimed.\n        providerRewards.baseRewardsDebt = removeMultiplier(fullReward, multiplier);\n\n        // update store data with the store pending rewards and set the last update time to the timestamp of the\n        // current block. if we're resetting the effective staking time, then we'd have to store the rewards multiplier in order to\n        // account for it in the future. Otherwise, we must store base rewards without any rewards multiplier.\n        _store.updateProviderRewardsData(\n            provider,\n            poolToken,\n            reserveToken,\n            providerRewards.rewardPerToken,\n            0,\n            providerRewards.totalClaimedRewards,\n            resetStakingTime ? time() : providerRewards.effectiveStakingTime,\n            providerRewards.baseRewardsDebt,\n            resetStakingTime ? multiplier : PPM_RESOLUTION\n        );\n    }\n\n    /**\n     * @dev updates pool rewards.\n     *\n     * @param poolToken the pool token representing the rewards pool\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     * @param program the pool program info\n     * @param lpStats liquidity protection statistics store\n     */\n    function updateReserveRewards(\n        IDSToken poolToken,\n        IERC20 reserveToken,\n        PoolProgram memory program,\n        ILiquidityProtectionStats lpStats\n    ) private returns (PoolRewards memory) {\n        // calculate the new reward rate per-token and update it in the store.\n        PoolRewards memory poolRewardsData = poolRewards(poolToken, reserveToken);\n\n        bool update = false;\n\n        // rewardPerToken must be calculated with the previous value of lastUpdateTime.\n        uint256 newRewardPerToken = rewardPerToken(poolToken, reserveToken, poolRewardsData, program, lpStats);\n        if (poolRewardsData.rewardPerToken != newRewardPerToken) {\n            poolRewardsData.rewardPerToken = newRewardPerToken;\n\n            update = true;\n        }\n\n        uint256 newLastUpdateTime = Math.min(time(), program.endTime);\n        if (poolRewardsData.lastUpdateTime != newLastUpdateTime) {\n            poolRewardsData.lastUpdateTime = newLastUpdateTime;\n\n            update = true;\n        }\n\n        if (update) {\n            _store.updatePoolRewardsData(\n                poolToken,\n                reserveToken,\n                poolRewardsData.lastUpdateTime,\n                poolRewardsData.rewardPerToken,\n                poolRewardsData.totalClaimedRewards\n            );\n        }\n\n        return poolRewardsData;\n    }\n\n    /**\n     * @dev updates provider rewards. this function is called during every liquidity changes\n     *\n     * @param provider the owner of the liquidity\n     * @param poolToken the pool token representing the rewards pool\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     * @param program the pool program info\n     * @param lpStats liquidity protection statistics store\n     */\n    function updateProviderRewards(\n        address provider,\n        IDSToken poolToken,\n        IERC20 reserveToken,\n        PoolRewards memory poolRewardsData,\n        PoolProgram memory program,\n        ILiquidityProtectionStats lpStats\n    ) private returns (ProviderRewards memory) {\n        // update provider's rewards with the newly claimable base rewards and the new reward rate per-token.\n        ProviderRewards memory providerRewards = providerRewards(provider, poolToken, reserveToken);\n\n        bool update = false;\n\n        // if this is the first liquidity provision - set the effective staking time to the current time.\n        if (\n            providerRewards.effectiveStakingTime == 0 &&\n            lpStats.totalProviderAmount(provider, poolToken, reserveToken) == 0\n        ) {\n            providerRewards.effectiveStakingTime = time();\n\n            update = true;\n        }\n\n        // pendingBaseRewards must be calculated with the previous value of providerRewards.rewardPerToken.\n        uint256 rewards =\n            baseRewards(provider, poolToken, reserveToken, poolRewardsData, providerRewards, program, lpStats);\n        if (rewards != 0) {\n            providerRewards.pendingBaseRewards = providerRewards.pendingBaseRewards.add(rewards);\n\n            update = true;\n        }\n\n        if (providerRewards.rewardPerToken != poolRewardsData.rewardPerToken) {\n            providerRewards.rewardPerToken = poolRewardsData.rewardPerToken;\n\n            update = true;\n        }\n\n        if (update) {\n            _store.updateProviderRewardsData(\n                provider,\n                poolToken,\n                reserveToken,\n                providerRewards.rewardPerToken,\n                providerRewards.pendingBaseRewards,\n                providerRewards.totalClaimedRewards,\n                providerRewards.effectiveStakingTime,\n                providerRewards.baseRewardsDebt,\n                providerRewards.baseRewardsDebtMultiplier\n            );\n        }\n\n        return providerRewards;\n    }\n\n    /**\n     * @dev updates pool and provider rewards. this function is called during every liquidity changes\n     *\n     * @param provider the owner of the liquidity\n     * @param poolToken the pool token representing the rewards pool\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     * @param program the pool program info\n     * @param lpStats liquidity protection statistics store\n     */\n    function updateRewards(\n        address provider,\n        IDSToken poolToken,\n        IERC20 reserveToken,\n        PoolProgram memory program,\n        ILiquidityProtectionStats lpStats\n    ) private returns (PoolRewards memory, ProviderRewards memory) {\n        PoolRewards memory poolRewardsData = updateReserveRewards(poolToken, reserveToken, program, lpStats);\n        ProviderRewards memory providerRewards =\n            updateProviderRewards(provider, poolToken, reserveToken, poolRewardsData, program, lpStats);\n\n        return (poolRewardsData, providerRewards);\n    }\n\n    /**\n     * @dev returns the aggregated reward rate per-token\n     *\n     * @param poolToken the participating pool to query\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     * @param poolRewardsData the rewards data of the pool\n     * @param program the pool program info\n     * @param lpStats liquidity protection statistics store\n     *\n     * @return the aggregated reward rate per-token\n     */\n    function rewardPerToken(\n        IDSToken poolToken,\n        IERC20 reserveToken,\n        PoolRewards memory poolRewardsData,\n        PoolProgram memory program,\n        ILiquidityProtectionStats lpStats\n    ) private view returns (uint256) {\n        // if there is no longer any liquidity in this reserve, return the historic rate (i.e., rewards won't accrue).\n        uint256 totalReserveAmount = lpStats.totalReserveAmount(poolToken, reserveToken);\n        if (totalReserveAmount == 0) {\n            return poolRewardsData.rewardPerToken;\n        }\n\n        // don't grant any rewards before the starting time of the program.\n        uint256 currentTime = time();\n        if (currentTime < program.startTime) {\n            return 0;\n        }\n\n        uint256 stakingEndTime = Math.min(currentTime, program.endTime);\n        uint256 stakingStartTime = Math.max(program.startTime, poolRewardsData.lastUpdateTime);\n        if (stakingStartTime == stakingEndTime) {\n            return poolRewardsData.rewardPerToken;\n        }\n\n        // since we will be dividing by the total amount of protected tokens in units of wei, we can encounter cases\n        // where the total amount in the denominator is higher than the product of the rewards rate and staking duration.\n        // in order to avoid this imprecision, we will amplify the reward rate by the units amount.\n        return\n            poolRewardsData.rewardPerToken.add( // the aggregated reward rate\n                stakingEndTime\n                    .sub(stakingStartTime) // the duration of the staking\n                    .mul(program.rewardRate) // multiplied by the rate\n                    .mul(REWARD_RATE_FACTOR) // and factored to increase precision\n                    .mul(rewardShare(reserveToken, program)) // and applied the specific token share of the whole reward\n                    .div(totalReserveAmount.mul(PPM_RESOLUTION)) // and divided by the total protected tokens amount in the pool\n            );\n    }\n\n    /**\n     * @dev returns the base rewards since the last claim\n     *\n     * @param provider the owner of the liquidity\n     * @param poolToken the participating pool to query\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     * @param poolRewardsData the rewards data of the pool\n     * @param providerRewards the rewards data of the provider\n     * @param program the pool program info\n     * @param lpStats liquidity protection statistics store\n     *\n     * @return the base rewards since the last claim\n     */\n    function baseRewards(\n        address provider,\n        IDSToken poolToken,\n        IERC20 reserveToken,\n        PoolRewards memory poolRewardsData,\n        ProviderRewards memory providerRewards,\n        PoolProgram memory program,\n        ILiquidityProtectionStats lpStats\n    ) private view returns (uint256) {\n        uint256 totalProviderAmount = lpStats.totalProviderAmount(provider, poolToken, reserveToken);\n        uint256 newRewardPerToken = rewardPerToken(poolToken, reserveToken, poolRewardsData, program, lpStats);\n\n        return\n            totalProviderAmount // the protected tokens amount held by the provider\n                .mul(newRewardPerToken.sub(providerRewards.rewardPerToken)) // multiplied by the difference between the previous and the current rate\n                .div(REWARD_RATE_FACTOR); // and factored back\n    }\n\n    /**\n     * @dev returns the full rewards since the last claim\n     *\n     * @param provider the owner of the liquidity\n     * @param poolToken the participating pool to query\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     * @param poolRewardsData the rewards data of the pool\n     * @param providerRewards the rewards data of the provider\n     * @param program the pool program info\n     * @param lpStats liquidity protection statistics store\n     *\n     * @return full rewards and the respective rewards multiplier\n     */\n    function fullRewards(\n        address provider,\n        IDSToken poolToken,\n        IERC20 reserveToken,\n        PoolRewards memory poolRewardsData,\n        ProviderRewards memory providerRewards,\n        PoolProgram memory program,\n        ILiquidityProtectionStats lpStats\n    ) private view returns (uint256, uint32) {\n        // calculate the claimable base rewards (since the last claim).\n        uint256 newBaseRewards =\n            baseRewards(provider, poolToken, reserveToken, poolRewardsData, providerRewards, program, lpStats);\n\n        // make sure that we aren't exceeding the reward rate for any reason.\n        verifyBaseReward(newBaseRewards, providerRewards.effectiveStakingTime, reserveToken, program);\n\n        // calculate pending rewards and apply the rewards multiplier.\n        uint32 multiplier = rewardsMultiplier(provider, providerRewards.effectiveStakingTime, program);\n        uint256 fullReward = applyMultiplier(providerRewards.pendingBaseRewards.add(newBaseRewards), multiplier);\n\n        // add any debt, while applying the best retroactive multiplier.\n        fullReward = fullReward.add(\n            applyHigherMultiplier(\n                providerRewards.baseRewardsDebt,\n                multiplier,\n                providerRewards.baseRewardsDebtMultiplier\n            )\n        );\n\n        // make sure that we aren't exceeding the full reward rate for any reason.\n        verifyFullReward(fullReward, reserveToken, poolRewardsData, program);\n\n        return (fullReward, multiplier);\n    }\n\n    /**\n     * @dev returns the specific reserve token's share of all rewards\n     *\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     * @param program the pool program info\n     */\n    function rewardShare(IERC20 reserveToken, PoolProgram memory program) private pure returns (uint32) {\n        if (reserveToken == program.reserveTokens[0]) {\n            return program.rewardShares[0];\n        }\n\n        return program.rewardShares[1];\n    }\n\n    /**\n     * @dev returns the rewards multiplier for the specific provider\n     *\n     * @param provider the owner of the liquidity\n     * @param stakingStartTime the staking time in the pool\n     * @param program the pool program info\n     *\n     * @return the rewards multiplier for the specific provider\n     */\n    function rewardsMultiplier(\n        address provider,\n        uint256 stakingStartTime,\n        PoolProgram memory program\n    ) private view returns (uint32) {\n        uint256 effectiveStakingEndTime = Math.min(time(), program.endTime);\n        uint256 effectiveStakingStartTime =\n            Math.max( // take the latest of actual staking start time and the latest multiplier reset\n                Math.max(stakingStartTime, program.startTime), // don't count staking before the start of the program\n                Math.max(_lastRemoveTimes.checkpoint(provider), _store.providerLastClaimTime(provider)) // get the latest multiplier reset timestamp\n            );\n\n        // check that the staking range is valid. for example, it can be invalid when calculating the multiplier when\n        // the staking has started before the start of the program, in which case the effective staking start time will\n        // be in the future, compared to the effective staking end time (which will be the time of the current block).\n        if (effectiveStakingStartTime >= effectiveStakingEndTime) {\n            return PPM_RESOLUTION;\n        }\n\n        uint256 effectiveStakingDuration = effectiveStakingEndTime.sub(effectiveStakingStartTime);\n\n        // given x representing the staking duration (in seconds), the resulting multiplier (in PPM) is:\n        // * for 0 <= x <= 1 weeks: 100% PPM\n        // * for 1 <= x <= 2 weeks: 125% PPM\n        // * for 2 <= x <= 3 weeks: 150% PPM\n        // * for 3 <= x <= 4 weeks: 175% PPM\n        // * for x > 4 weeks: 200% PPM\n        return PPM_RESOLUTION + MULTIPLIER_INCREMENT * uint32(Math.min(effectiveStakingDuration.div(1 weeks), 4));\n    }\n\n    /**\n     * @dev returns the pool program for a specific pool\n     *\n     * @param poolToken the pool token representing the rewards pool\n     *\n     * @return the pool program for a specific pool\n     */\n    function poolProgram(IDSToken poolToken) private view returns (PoolProgram memory) {\n        PoolProgram memory program;\n        (program.startTime, program.endTime, program.rewardRate, program.reserveTokens, program.rewardShares) = _store\n            .poolProgram(poolToken);\n\n        return program;\n    }\n\n    /**\n     * @dev returns pool rewards for a specific pool and reserve\n     *\n     * @param poolToken the pool token representing the rewards pool\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     *\n     * @return pool rewards for a specific pool and reserve\n     */\n    function poolRewards(IDSToken poolToken, IERC20 reserveToken) private view returns (PoolRewards memory) {\n        PoolRewards memory data;\n        (data.lastUpdateTime, data.rewardPerToken, data.totalClaimedRewards) = _store.poolRewards(\n            poolToken,\n            reserveToken\n        );\n\n        return data;\n    }\n\n    /**\n     * @dev returns provider rewards for a specific pool and reserve\n     *\n     * @param provider the owner of the liquidity\n     * @param poolToken the pool token representing the rewards pool\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     *\n     * @return provider rewards for a specific pool and reserve\n     */\n    function providerRewards(\n        address provider,\n        IDSToken poolToken,\n        IERC20 reserveToken\n    ) private view returns (ProviderRewards memory) {\n        ProviderRewards memory data;\n        (\n            data.rewardPerToken,\n            data.pendingBaseRewards,\n            data.totalClaimedRewards,\n            data.effectiveStakingTime,\n            data.baseRewardsDebt,\n            data.baseRewardsDebtMultiplier\n        ) = _store.providerRewards(provider, poolToken, reserveToken);\n\n        return data;\n    }\n\n    /**\n     * @dev applies the multiplier on the provided amount\n     *\n     * @param amount the amount of the reward\n     * @param multiplier the first multiplier\n     *\n     * @return new reward amount\n     */\n    function applyMultiplier(uint256 amount, uint32 multiplier) private pure returns (uint256) {\n        if (multiplier == PPM_RESOLUTION) {\n            return amount;\n        }\n\n        return amount.mul(multiplier).div(PPM_RESOLUTION);\n    }\n\n    /**\n     * @dev removes the multiplier on the provided amount\n     *\n     * @param amount the amount of the reward\n     * @param multiplier the first multiplier\n     *\n     * @return new reward amount\n     */\n    function removeMultiplier(uint256 amount, uint32 multiplier) private pure returns (uint256) {\n        if (multiplier == PPM_RESOLUTION) {\n            return amount;\n        }\n\n        return amount.mul(PPM_RESOLUTION).div(multiplier);\n    }\n\n    /**\n     * @dev applies the best of two rewards multipliers on the provided amount\n     *\n     * @param amount the amount of the reward\n     * @param multiplier1 the first multiplier\n     * @param multiplier2 the second multiplier\n     *\n     * @return new reward amount\n     */\n    function applyHigherMultiplier(\n        uint256 amount,\n        uint32 multiplier1,\n        uint32 multiplier2\n    ) private pure returns (uint256) {\n        return applyMultiplier(amount, multiplier1 > multiplier2 ? multiplier1 : multiplier2);\n    }\n\n    /**\n     * @dev performs a sanity check on the newly claimable base rewards\n     *\n     * @param baseReward the base reward to check\n     * @param stakingStartTime the staking time in the pool\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     * @param program the pool program info\n     */\n    function verifyBaseReward(\n        uint256 baseReward,\n        uint256 stakingStartTime,\n        IERC20 reserveToken,\n        PoolProgram memory program\n    ) private view {\n        // don't grant any rewards before the starting time of the program or for stakes after the end of the program.\n        uint256 currentTime = time();\n        if (currentTime < program.startTime || stakingStartTime >= program.endTime) {\n            require(baseReward == 0, \"ERR_BASE_REWARD_TOO_HIGH\");\n\n            return;\n        }\n\n        uint256 effectiveStakingStartTime = Math.max(stakingStartTime, program.startTime);\n        uint256 effectiveStakingEndTime = Math.min(currentTime, program.endTime);\n\n        // make sure that we aren't exceeding the base reward rate for any reason.\n        require(\n            baseReward <=\n                (program.rewardRate * REWARDS_HALVING_FACTOR)\n                    .mul(effectiveStakingEndTime.sub(effectiveStakingStartTime))\n                    .mul(rewardShare(reserveToken, program))\n                    .div(PPM_RESOLUTION),\n            \"ERR_BASE_REWARD_RATE_TOO_HIGH\"\n        );\n    }\n\n    /**\n     * @dev performs a sanity check on the newly claimable full rewards\n     *\n     * @param fullReward the full reward to check\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     * @param poolRewardsData the rewards data of the pool\n     * @param program the pool program info\n     */\n    function verifyFullReward(\n        uint256 fullReward,\n        IERC20 reserveToken,\n        PoolRewards memory poolRewardsData,\n        PoolProgram memory program\n    ) private pure {\n        uint256 maxClaimableReward =\n            (\n                (program.rewardRate * REWARDS_HALVING_FACTOR)\n                    .mul(program.endTime.sub(program.startTime))\n                    .mul(rewardShare(reserveToken, program))\n                    .mul(MAX_MULTIPLIER)\n                    .div(PPM_RESOLUTION)\n                    .div(PPM_RESOLUTION)\n            )\n                .sub(poolRewardsData.totalClaimedRewards);\n\n        // make sure that we aren't exceeding the full reward rate for any reason.\n        require(fullReward <= maxClaimableReward, \"ERR_REWARD_RATE_TOO_HIGH\");\n    }\n\n    /**\n     * @dev returns the liquidity protection stats data contract\n     *\n     * @return the liquidity protection store data contract\n     */\n    function liquidityProtectionStats() private view returns (ILiquidityProtectionStats) {\n        return liquidityProtection().stats();\n    }\n\n    /**\n     * @dev returns the liquidity protection contract\n     *\n     * @return the liquidity protection contract\n     */\n    function liquidityProtection() private view returns (ILiquidityProtection) {\n        return ILiquidityProtection(addressOf(LIQUIDITY_PROTECTION));\n    }\n\n    /**\n     * @dev returns if the program is valid\n     *\n     * @param reserveToken the reserve token representing the liquidity in the pool\n     * @param program the pool program info\n     *\n     * @return if the program is invalid\n     */\n    function isProgramValid(IERC20 reserveToken, PoolProgram memory program) private pure returns (bool) {\n        return\n            address(reserveToken) != address(0) &&\n            (program.reserveTokens[0] == reserveToken || program.reserveTokens[1] == reserveToken);\n    }\n}\n"
    },
    "@bancor/contracts-solidity/solidity/contracts/converter/interfaces/IConverterAnchor.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\nimport \"../../utility/interfaces/IOwned.sol\";\n\n/*\n    Converter Anchor interface\n*/\ninterface IConverterAnchor is IOwned {\n\n}\n"
    },
    "@bancor/contracts-solidity/solidity/contracts/liquidity-protection/interfaces/ILiquidityProtection.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./ILiquidityProtectionStore.sol\";\nimport \"./ILiquidityProtectionStats.sol\";\nimport \"./ILiquidityProtectionSettings.sol\";\nimport \"./ILiquidityProtectionSystemStore.sol\";\nimport \"../../utility/interfaces/ITokenHolder.sol\";\nimport \"../../converter/interfaces/IConverterAnchor.sol\";\n\n/*\n    Liquidity Protection interface\n*/\ninterface ILiquidityProtection {\n    function store() external view returns (ILiquidityProtectionStore);\n\n    function stats() external view returns (ILiquidityProtectionStats);\n\n    function settings() external view returns (ILiquidityProtectionSettings);\n\n    function systemStore() external view returns (ILiquidityProtectionSystemStore);\n\n    function wallet() external view returns (ITokenHolder);\n\n    function addLiquidityFor(\n        address owner,\n        IConverterAnchor poolAnchor,\n        IERC20 reserveToken,\n        uint256 amount\n    ) external payable returns (uint256);\n\n    function addLiquidity(\n        IConverterAnchor poolAnchor,\n        IERC20 reserveToken,\n        uint256 amount\n    ) external payable returns (uint256);\n\n    function removeLiquidity(uint256 id, uint32 portion) external;\n}\n"
    },
    "@bancor/contracts-solidity/solidity/contracts/liquidity-protection/interfaces/ILiquidityProtectionEventsSubscriber.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../converter/interfaces/IConverterAnchor.sol\";\n\n/**\n * @dev Liquidity protection events subscriber interface\n */\ninterface ILiquidityProtectionEventsSubscriber {\n    function onAddingLiquidity(\n        address provider,\n        IConverterAnchor poolAnchor,\n        IERC20 reserveToken,\n        uint256 poolAmount,\n        uint256 reserveAmount\n    ) external;\n\n    function onRemovingLiquidity(\n        uint256 id,\n        address provider,\n        IConverterAnchor poolAnchor,\n        IERC20 reserveToken,\n        uint256 poolAmount,\n        uint256 reserveAmount\n    ) external;\n}\n"
    },
    "@bancor/contracts-solidity/solidity/contracts/liquidity-protection/interfaces/ILiquidityProtectionSettings.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./ILiquidityProtectionEventsSubscriber.sol\";\nimport \"../../converter/interfaces/IConverterAnchor.sol\";\n\n/*\n    Liquidity Protection Store Settings interface\n*/\ninterface ILiquidityProtectionSettings {\n    function isPoolWhitelisted(IConverterAnchor poolAnchor) external view returns (bool);\n\n    function poolWhitelist() external view returns (address[] memory);\n\n    function subscribers() external view returns (address[] memory);\n\n    function isPoolSupported(IConverterAnchor poolAnchor) external view returns (bool);\n\n    function minNetworkTokenLiquidityForMinting() external view returns (uint256);\n\n    function defaultNetworkTokenMintingLimit() external view returns (uint256);\n\n    function networkTokenMintingLimits(IConverterAnchor poolAnchor) external view returns (uint256);\n\n    function addLiquidityDisabled(IConverterAnchor poolAnchor, IERC20 reserveToken) external view returns (bool);\n\n    function minProtectionDelay() external view returns (uint256);\n\n    function maxProtectionDelay() external view returns (uint256);\n\n    function minNetworkCompensation() external view returns (uint256);\n\n    function lockDuration() external view returns (uint256);\n\n    function averageRateMaxDeviation() external view returns (uint32);\n}\n"
    },
    "@bancor/contracts-solidity/solidity/contracts/liquidity-protection/interfaces/ILiquidityProtectionStats.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../converter/interfaces/IConverterAnchor.sol\";\nimport \"../../token/interfaces/IDSToken.sol\";\n\n/*\n    Liquidity Protection Stats interface\n*/\ninterface ILiquidityProtectionStats {\n    function increaseTotalAmounts(\n        address provider,\n        IDSToken poolToken,\n        IERC20 reserveToken,\n        uint256 poolAmount,\n        uint256 reserveAmount\n    ) external;\n\n    function decreaseTotalAmounts(\n        address provider,\n        IDSToken poolToken,\n        IERC20 reserveToken,\n        uint256 poolAmount,\n        uint256 reserveAmount\n    ) external;\n\n    function addProviderPool(address provider, IDSToken poolToken) external returns (bool);\n\n    function removeProviderPool(address provider, IDSToken poolToken) external returns (bool);\n\n    function totalPoolAmount(IDSToken poolToken) external view returns (uint256);\n\n    function totalReserveAmount(IDSToken poolToken, IERC20 reserveToken) external view returns (uint256);\n\n    function totalProviderAmount(\n        address provider,\n        IDSToken poolToken,\n        IERC20 reserveToken\n    ) external view returns (uint256);\n\n    function providerPools(address provider) external view returns (IDSToken[] memory);\n}\n"
    },
    "@bancor/contracts-solidity/solidity/contracts/liquidity-protection/interfaces/ILiquidityProtectionStore.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../converter/interfaces/IConverterAnchor.sol\";\nimport \"../../token/interfaces/IDSToken.sol\";\nimport \"../../utility/interfaces/IOwned.sol\";\n\n/*\n    Liquidity Protection Store interface\n*/\ninterface ILiquidityProtectionStore is IOwned {\n    function withdrawTokens(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external;\n\n    function protectedLiquidity(uint256 _id)\n        external\n        view\n        returns (\n            address,\n            IDSToken,\n            IERC20,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function addProtectedLiquidity(\n        address _provider,\n        IDSToken _poolToken,\n        IERC20 _reserveToken,\n        uint256 _poolAmount,\n        uint256 _reserveAmount,\n        uint256 _reserveRateN,\n        uint256 _reserveRateD,\n        uint256 _timestamp\n    ) external returns (uint256);\n\n    function updateProtectedLiquidityAmounts(\n        uint256 _id,\n        uint256 _poolNewAmount,\n        uint256 _reserveNewAmount\n    ) external;\n\n    function removeProtectedLiquidity(uint256 _id) external;\n\n    function lockedBalance(address _provider, uint256 _index) external view returns (uint256, uint256);\n\n    function lockedBalanceRange(\n        address _provider,\n        uint256 _startIndex,\n        uint256 _endIndex\n    ) external view returns (uint256[] memory, uint256[] memory);\n\n    function addLockedBalance(\n        address _provider,\n        uint256 _reserveAmount,\n        uint256 _expirationTime\n    ) external returns (uint256);\n\n    function removeLockedBalance(address _provider, uint256 _index) external;\n\n    function systemBalance(IERC20 _poolToken) external view returns (uint256);\n\n    function incSystemBalance(IERC20 _poolToken, uint256 _poolAmount) external;\n\n    function decSystemBalance(IERC20 _poolToken, uint256 _poolAmount) external;\n}\n"
    },
    "@bancor/contracts-solidity/solidity/contracts/liquidity-protection/interfaces/ILiquidityProtectionSystemStore.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../converter/interfaces/IConverterAnchor.sol\";\n\n/*\n    Liquidity Protection System Store interface\n*/\ninterface ILiquidityProtectionSystemStore {\n    function systemBalance(IERC20 poolToken) external view returns (uint256);\n\n    function incSystemBalance(IERC20 poolToken, uint256 poolAmount) external;\n\n    function decSystemBalance(IERC20 poolToken, uint256 poolAmount) external;\n\n    function networkTokensMinted(IConverterAnchor poolAnchor) external view returns (uint256);\n\n    function incNetworkTokensMinted(IConverterAnchor poolAnchor, uint256 amount) external;\n\n    function decNetworkTokensMinted(IConverterAnchor poolAnchor, uint256 amount) external;\n}\n"
    },
    "@bancor/contracts-solidity/solidity/contracts/token/interfaces/IDSToken.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../converter/interfaces/IConverterAnchor.sol\";\nimport \"../../utility/interfaces/IOwned.sol\";\n\n/*\n    DSToken interface\n*/\ninterface IDSToken is IConverterAnchor, IERC20 {\n    function issue(address _to, uint256 _amount) external;\n\n    function destroy(address _from, uint256 _amount) external;\n}\n"
    },
    "@bancor/contracts-solidity/solidity/contracts/utility/ContractRegistryClient.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\nimport \"./Owned.sol\";\nimport \"./Utils.sol\";\nimport \"./interfaces/IContractRegistry.sol\";\n\n/**\n * @dev This is the base contract for ContractRegistry clients.\n */\ncontract ContractRegistryClient is Owned, Utils {\n    bytes32 internal constant CONTRACT_REGISTRY = \"ContractRegistry\";\n    bytes32 internal constant BANCOR_NETWORK = \"BancorNetwork\";\n    bytes32 internal constant BANCOR_FORMULA = \"BancorFormula\";\n    bytes32 internal constant CONVERTER_FACTORY = \"ConverterFactory\";\n    bytes32 internal constant CONVERSION_PATH_FINDER = \"ConversionPathFinder\";\n    bytes32 internal constant CONVERTER_UPGRADER = \"BancorConverterUpgrader\";\n    bytes32 internal constant CONVERTER_REGISTRY = \"BancorConverterRegistry\";\n    bytes32 internal constant CONVERTER_REGISTRY_DATA = \"BancorConverterRegistryData\";\n    bytes32 internal constant BNT_TOKEN = \"BNTToken\";\n    bytes32 internal constant BANCOR_X = \"BancorX\";\n    bytes32 internal constant BANCOR_X_UPGRADER = \"BancorXUpgrader\";\n    bytes32 internal constant LIQUIDITY_PROTECTION = \"LiquidityProtection\";\n\n    IContractRegistry public registry; // address of the current contract-registry\n    IContractRegistry public prevRegistry; // address of the previous contract-registry\n    bool public onlyOwnerCanUpdateRegistry; // only an owner can update the contract-registry\n\n    /**\n     * @dev verifies that the caller is mapped to the given contract name\n     *\n     * @param _contractName    contract name\n     */\n    modifier only(bytes32 _contractName) {\n        _only(_contractName);\n        _;\n    }\n\n    // error message binary size optimization\n    function _only(bytes32 _contractName) internal view {\n        require(msg.sender == addressOf(_contractName), \"ERR_ACCESS_DENIED\");\n    }\n\n    /**\n     * @dev initializes a new ContractRegistryClient instance\n     *\n     * @param  _registry   address of a contract-registry contract\n     */\n    constructor(IContractRegistry _registry) internal validAddress(address(_registry)) {\n        registry = IContractRegistry(_registry);\n        prevRegistry = IContractRegistry(_registry);\n    }\n\n    /**\n     * @dev updates to the new contract-registry\n     */\n    function updateRegistry() public {\n        // verify that this function is permitted\n        require(msg.sender == owner || !onlyOwnerCanUpdateRegistry, \"ERR_ACCESS_DENIED\");\n\n        // get the new contract-registry\n        IContractRegistry newRegistry = IContractRegistry(addressOf(CONTRACT_REGISTRY));\n\n        // verify that the new contract-registry is different and not zero\n        require(newRegistry != registry && address(newRegistry) != address(0), \"ERR_INVALID_REGISTRY\");\n\n        // verify that the new contract-registry is pointing to a non-zero contract-registry\n        require(newRegistry.addressOf(CONTRACT_REGISTRY) != address(0), \"ERR_INVALID_REGISTRY\");\n\n        // save a backup of the current contract-registry before replacing it\n        prevRegistry = registry;\n\n        // replace the current contract-registry with the new contract-registry\n        registry = newRegistry;\n    }\n\n    /**\n     * @dev restores the previous contract-registry\n     */\n    function restoreRegistry() public ownerOnly {\n        // restore the previous contract-registry\n        registry = prevRegistry;\n    }\n\n    /**\n     * @dev restricts the permission to update the contract-registry\n     *\n     * @param _onlyOwnerCanUpdateRegistry  indicates whether or not permission is restricted to owner only\n     */\n    function restrictRegistryUpdate(bool _onlyOwnerCanUpdateRegistry) public ownerOnly {\n        // change the permission to update the contract-registry\n        onlyOwnerCanUpdateRegistry = _onlyOwnerCanUpdateRegistry;\n    }\n\n    /**\n     * @dev returns the address associated with the given contract name\n     *\n     * @param _contractName    contract name\n     *\n     * @return contract address\n     */\n    function addressOf(bytes32 _contractName) internal view returns (address) {\n        return registry.addressOf(_contractName);\n    }\n}\n"
    },
    "@bancor/contracts-solidity/solidity/contracts/utility/Owned.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\nimport \"./interfaces/IOwned.sol\";\n\n/**\n * @dev This contract provides support and utilities for contract ownership.\n */\ncontract Owned is IOwned {\n    address public override owner;\n    address public newOwner;\n\n    /**\n     * @dev triggered when the owner is updated\n     *\n     * @param _prevOwner previous owner\n     * @param _newOwner  new owner\n     */\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\n\n    /**\n     * @dev initializes a new Owned instance\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        _ownerOnly();\n        _;\n    }\n\n    // error message binary size optimization\n    function _ownerOnly() internal view {\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\n    }\n\n    /**\n     * @dev allows transferring the contract ownership\n     * the new owner still needs to accept the transfer\n     * can only be called by the contract owner\n     *\n     * @param _newOwner    new contract owner\n     */\n    function transferOwnership(address _newOwner) public override ownerOnly {\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\n        newOwner = _newOwner;\n    }\n\n    /**\n     * @dev used by a new owner to accept an ownership transfer\n     */\n    function acceptOwnership() public override {\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\n        emit OwnerUpdate(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n"
    },
    "@bancor/contracts-solidity/solidity/contracts/utility/Time.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\n/*\n    Time implementing contract\n*/\ncontract Time {\n    /**\n     * @dev returns the current time\n     */\n    function time() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n}\n"
    },
    "@bancor/contracts-solidity/solidity/contracts/utility/Utils.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\n/**\n * @dev Utilities & Common Modifiers\n */\ncontract Utils {\n    // verifies that a value is greater than zero\n    modifier greaterThanZero(uint256 _value) {\n        _greaterThanZero(_value);\n        _;\n    }\n\n    // error message binary size optimization\n    function _greaterThanZero(uint256 _value) internal pure {\n        require(_value > 0, \"ERR_ZERO_VALUE\");\n    }\n\n    // validates an address - currently only checks that it isn't null\n    modifier validAddress(address _address) {\n        _validAddress(_address);\n        _;\n    }\n\n    // error message binary size optimization\n    function _validAddress(address _address) internal pure {\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\n    }\n\n    // verifies that the address is different than this contract address\n    modifier notThis(address _address) {\n        _notThis(_address);\n        _;\n    }\n\n    // error message binary size optimization\n    function _notThis(address _address) internal view {\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\n    }\n\n    // validates an external address - currently only checks that it isn't null or this\n    modifier validExternalAddress(address _address) {\n        _validExternalAddress(_address);\n        _;\n    }\n\n    // error message binary size optimization\n    function _validExternalAddress(address _address) internal view {\n        require(_address != address(0) && _address != address(this), \"ERR_INVALID_EXTERNAL_ADDRESS\");\n    }\n}\n"
    },
    "@bancor/contracts-solidity/solidity/contracts/utility/interfaces/ICheckpointStore.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\n/**\n * @dev Checkpoint store contract interface\n */\ninterface ICheckpointStore {\n    function addCheckpoint(address _address) external;\n\n    function addPastCheckpoint(address _address, uint256 _time) external;\n\n    function addPastCheckpoints(address[] calldata _addresses, uint256[] calldata _times) external;\n\n    function checkpoint(address _address) external view returns (uint256);\n}\n"
    },
    "@bancor/contracts-solidity/solidity/contracts/utility/interfaces/IContractRegistry.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\n/*\n    Contract Registry interface\n*/\ninterface IContractRegistry {\n    function addressOf(bytes32 _contractName) external view returns (address);\n}\n"
    },
    "@bancor/contracts-solidity/solidity/contracts/utility/interfaces/IOwned.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\n/*\n    Owned contract interface\n*/\ninterface IOwned {\n    // this function isn't since the compiler emits automatically generated getter functions as external\n    function owner() external view returns (address);\n\n    function transferOwnership(address _newOwner) external;\n\n    function acceptOwnership() external;\n}\n"
    },
    "@bancor/contracts-solidity/solidity/contracts/utility/interfaces/ITokenHolder.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IOwned.sol\";\n\n/*\n    Token Holder interface\n*/\ninterface ITokenHolder is IOwned {\n    function withdrawTokens(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external;\n}\n"
    },
    "@bancor/token-governance/contracts/IClaimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/// @title Claimable contract interface\ninterface IClaimable {\n    function owner() external view returns (address);\n\n    function transferOwnership(address newOwner) external;\n\n    function acceptOwnership() external;\n}\n"
    },
    "@bancor/token-governance/contracts/IMintableToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IClaimable.sol\";\n\n/// @title Mintable Token interface\ninterface IMintableToken is IERC20, IClaimable {\n    function issue(address to, uint256 amount) external;\n\n    function destroy(address from, uint256 amount) external;\n}\n"
    },
    "@bancor/token-governance/contracts/ITokenGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./IMintableToken.sol\";\n\n/// @title The interface for mintable/burnable token governance.\ninterface ITokenGovernance {\n    // The address of the mintable ERC20 token.\n    function token() external view returns (IMintableToken);\n\n    /// @dev Mints new tokens.\n    ///\n    /// @param to Account to receive the new amount.\n    /// @param amount Amount to increase the supply by.\n    ///\n    function mint(address to, uint256 amount) external;\n\n    /// @dev Burns tokens from the caller.\n    ///\n    /// @param amount Amount to decrease the supply by.\n    ///\n    function burn(uint256 amount) external;\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "istanbul",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}