{"Adminable.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./Ownable.sol\";\n\ncontract Adminable is Ownable {\n    mapping (address =\u003e bool) public admins;\n\n    modifier onlyAdmin() {\n        require(isAdmin(msg.sender), \"not admin\");\n        _;\n    }\n\n    function setAdmin(address user, bool value) external onlyOwner {\n        admins[user] = value;\n    }\n\n    function isAdmin(address user) internal view returns (bool) {\n      return admins[user] || isOwner();\n    }\n}\n"},"DSMath.sol":{"content":"pragma solidity ^0.5.2;\n\n\ncontract DSMath {\n    /*\n    standard uint256 functions\n     */\n\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assert((z = x + y) \u003e= x);\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assert((z = x - y) \u003c= x);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assert((z = x * y) \u003e= x);\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x \u003c= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x \u003e= y ? x : y;\n    }\n\n    /*\n    uint128 functions (h is for half)\n     */\n\n    function hadd(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        assert((z = x + y) \u003e= x);\n    }\n\n    function hsub(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        assert((z = x - y) \u003c= x);\n    }\n\n    function hmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        assert((z = x * y) \u003e= x);\n    }\n\n    function hdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = x / y;\n    }\n\n    function hmin(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        return x \u003c= y ? x : y;\n    }\n\n    function hmax(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        return x \u003e= y ? x : y;\n    }\n\n    /*\n    int256 functions\n     */\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x \u003c= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x \u003e= y ? x : y;\n    }\n\n    /*\n    WAD math\n     */\n\n    uint128 constant WAD = 10 ** 18;\n\n    function wadd(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function wsub(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function wmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\n    }\n\n    function wdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = cast((uint256(x) * WAD + y / 2) / y);\n    }\n\n    function wmin(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hmin(x, y);\n    }\n\n    function wmax(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hmax(x, y);\n    }\n\n    /*\n    RAY math\n     */\n\n    uint128 constant RAY = 10 ** 27;\n\n    function radd(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function rsub(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function rmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\n    }\n\n    function rdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = cast((uint256(x) * RAY + y / 2) / y);\n    }\n\n    function rpow(uint128 x, uint64 n) internal pure returns (uint128 z) {\n        // This famous algorithm is called \"exponentiation by squaring\"\n        // and calculates x^n with x as fixed-point and n as regular unsigned.\n        //\n        // It\u0027s O(log n), instead of O(n) for naive repeated multiplication.\n        //\n        // These facts are why it works:\n        //\n        //  If n is even, then x^n = (x^2)^(n/2).\n        //  If n is odd,  then x^n = x * x^(n-1),\n        //   and applying the equation for even x gives\n        //    x^n = x * (x^2)^((n-1) / 2).\n        //\n        //  Also, EVM division is flooring and\n        //    floor[(n-1) / 2] = floor[n / 2].\n\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n\n    function rmin(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hmin(x, y);\n    }\n\n    function rmax(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hmax(x, y);\n    }\n\n    function cast(uint256 x) internal pure returns (uint128 z) {\n        assert((z = uint128(x)) == x);\n    }\n\n}\n"},"DSTokenBase.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./DSMath.sol\";\nimport \"./ERC20.sol\";\n\ncontract DSTokenBase is ERC20, DSMath {\n    uint256                                            _supply;\n    mapping (address =\u003e uint256)                       _balances;\n    mapping (address =\u003e mapping (address =\u003e uint256))  _approvals;\n\n    constructor(uint supply) public {\n        _supply = supply;\n    }\n\n    function totalSupply() public view returns (uint) {\n        return _supply;\n    }\n    function balanceOf(address src) public view returns (uint) {\n        return _balances[src];\n    }\n    function allowance(address src, address guy) public view returns (uint) {\n        return _approvals[src][guy];\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        if (src != msg.sender) {\n            require(_approvals[src][msg.sender] \u003e= wad, \"ds-token-insufficient-approval\");\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n        }\n\n        require(_balances[src] \u003e= wad, \"ds-token-insufficient-balance\");\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        _approvals[msg.sender][guy] = wad;\n\n        emit Approval(msg.sender, guy, wad);\n\n        return true;\n    }\n}\n"},"ERC20.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./DSMath.sol\";\n\ncontract ERC20Events {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n}\n\ncontract ERC20 is ERC20Events {\n    function totalSupply() public view returns (uint);\n    function balanceOf(address guy) public view returns (uint);\n    function allowance(address src, address guy) public view returns (uint);\n\n    function approve(address guy, uint wad) public returns (bool);\n    function transfer(address dst, uint wad) public returns (bool);\n    function transferFrom(address src, address dst, uint wad) public returns (bool);\n}\n"},"Lottoshi.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./DSTokenBase.sol\";\nimport \"./Ownable.sol\";\n\ninterface ILottery {\n    function getAvailablePrize() external view returns (uint256);\n}\n\ncontract Lottoshi is DSTokenBase(0), Ownable {\n    uint256 constant internal magnitude = 2 ** 64;\n    uint256 constant internal HOUSE_PERCENTAGE = 75; // 7.5%\n    uint256 constant internal REFERRAL_PERCENTAGE = 50; // 5%\n    uint256 constant internal FOMO_PERCENTAGE = 120; // 12%\n    uint256 constant internal PRIZE_LIMIT_TO_INVEST = 50000 ether;\n    uint256 constant internal MAX_SUPPLY = 500000 * (10 ** 6);\n    string constant public name = \"Lottoshi\";\n    string constant public symbol = \"LTS\";\n    uint256 constant public decimals = 6;\n\n    uint256 public profitPerShare;\n    uint256 public totalStakes;\n    address payable public lottery;\n    bool public decentralized;\n\n    mapping (address =\u003e uint256) public stakesOf;\n    mapping (address =\u003e uint256) public payout;\n    mapping (address =\u003e uint256) public dividends;\n\n    event Invest(address indexed user, uint256 ethAmount, uint256 tokenAmount, address referee);\n    event Stake(address indexed user, uint256 amount);\n    event Unstake(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n\n    constructor (address payable _lottery) public {\n        lottery = _lottery;\n    }\n\n    function () external {\n    }\n\n    function decentralize() external {\n        require(lottery == msg.sender, \"invalid sender\");\n        decentralized = true;\n    }\n\n    function contribute(address referral) external payable {\n        uint256 referralAmount;\n        if (referral != address(0)) {\n            referralAmount = msg.value * REFERRAL_PERCENTAGE / 300;\n            dividends[referral] += referralAmount;\n        }\n        uint256 houseAmount;\n        if (!decentralized) {\n            houseAmount = msg.value * HOUSE_PERCENTAGE / 300;\n            dividends[owner()] += houseAmount;\n        }\n        profitPerShare += (msg.value - houseAmount - referralAmount) * magnitude / totalStakes;\n    }\n\n    function invest(address referral) public payable {\n        uint256 prize = getPrize();\n        require(prize \u003c PRIZE_LIMIT_TO_INVEST, \"prize is enough\");\n        uint256 fomoAmount;\n        if (totalStakes \u003e 0) {\n            fomoAmount = msg.value * FOMO_PERCENTAGE / 1000;\n            profitPerShare += fomoAmount * magnitude / totalStakes;\n        }\n        lottery.transfer(msg.value - fomoAmount);\n        uint256 token1 = ethToTokens(prize);\n        uint256 token2 = ethToTokens(prize + msg.value);\n        uint256 tokenAmount = (token2 - token1) / 1000000000000;\n        uint256 referralAmount;\n        if (referral != address(0) \u0026\u0026 referral != msg.sender) {\n            referralAmount = tokenAmount / 20;\n            stakesOf[referral] += referralAmount;\n            payout[referral] += referralAmount * profitPerShare;\n            emit Invest(referral, 0, referralAmount, msg.sender);\n            emit Transfer(address(0), referral, referralAmount);\n            emit Transfer(referral, address(this), referralAmount);\n            emit Stake(referral, referralAmount);\n        }\n        uint256 totalAmount = referralAmount + tokenAmount;\n        require(_supply + totalAmount \u003c= MAX_SUPPLY, \"exceed max supply\");\n        stakesOf[msg.sender] += tokenAmount;\n        payout[msg.sender] += tokenAmount * profitPerShare;\n        _supply += totalAmount;\n        totalStakes += totalAmount;\n        _balances[address(this)] += totalAmount;\n        emit Invest(msg.sender, msg.value, tokenAmount, address(0));\n        emit Transfer(address(0), msg.sender, tokenAmount);\n        emit Transfer(msg.sender, address(this), tokenAmount);\n        emit Stake(msg.sender, tokenAmount);\n    }\n\n    function stake(uint256 amount) external {\n        internalTransfer(msg.sender, address(this), amount);\n        stakesOf[msg.sender] += amount;\n        payout[msg.sender] += amount * profitPerShare;\n        totalStakes += amount;\n        emit Stake(msg.sender, amount);\n    }\n\n    function unstake(uint256 amount) external {\n        require(stakesOf[msg.sender] \u003e= amount, \"stakesOf not enough\");\n        withdrawDividends(msg.sender);\n        payout[msg.sender] -= amount * profitPerShare;\n        stakesOf[msg.sender] -= amount;\n        totalStakes -= amount;\n        emit Unstake(msg.sender, amount);\n        internalTransfer(address(this), msg.sender, amount);\n    }\n\n    function withdrawDividends() public {\n        withdrawDividends(msg.sender);\n    }\n\n    function withdrawDividends(address payable user) internal {\n        uint256 dividend = dividendOf(user);\n        if (dividend \u003e 0) {\n            uint256 dividend2 = dividends[user];\n            payout[user] += (dividend - dividend2) * magnitude;\n            if (dividend2 \u003e 0) {\n                dividends[user] = 0;\n            }\n            user.transfer(dividend);\n            emit Withdraw(user, dividend);\n        }\n    }\n\n    function dividendOf(address user) public view returns (uint256) {\n        return (profitPerShare * stakesOf[user] - payout[user]) / magnitude + dividends[user];\n    }\n\n    function ethToTokens(uint256 eth) internal pure returns (uint256) {\n        return (sqrt(10000800016000000000000000000000000000000000000 + 4000000000000000000000000 * eth) - 100004000000000000000000) \u003e\u003e 1;\n    }\n\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = (x + 1) \u003e\u003e 1;\n        y = x;\n        while (z \u003c y) {\n            y = z;\n            z = (x / z + z) \u003e\u003e 1;\n        }\n    }\n\n    function getPrize() internal view returns (uint256) {\n        return ILottery(lottery).getAvailablePrize();\n    }\n\n    function internalTransfer(address src, address dst, uint wad) internal {\n        require(_balances[src] \u003e= wad, \"ds-token-insufficient-balance\");\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n\n        emit Transfer(src, dst, wad);\n    }\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.5.2;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"}}