{"IERC20.sol":{"content":"pragma solidity 0.5.16;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IMorpherStaking.sol":{"content":"pragma solidity 0.5.16;\ncontract IMorpherStaking {\n    \n    function lastReward() public view returns (uint256);\n\n    function totalShares() public view returns (uint256);\n\n    function interestRate() public view returns (uint256);\n\n    function lockupPeriod() public view returns (uint256);\n    \n    function minimumStake() public view returns (uint256);\n\n    function stakingAdmin() public view returns (address);\n\n    function updatePoolShareValue() public returns (uint256 _newPoolShareValue) ;\n\n    function stake(uint256 _amount) public returns (uint256 _poolShares);\n\n    function unStake(uint256 _numOfShares) public returns (uint256 _amount);\n\n}\n"},"IMorpherState.sol":{"content":"pragma solidity 0.5.16;\n\ncontract IMorpherState {\n    function setPosition(\n        address _address,\n        bytes32 _marketId,\n        uint256 _timeStamp,\n        uint256 _longShares,\n        uint256 _shortShares,\n        uint256 _meanEntryPrice,\n        uint256 _meanEntrySpread,\n        uint256 _meanEntryLeverage,\n        uint256 _liquidationPrice\n    ) public; \n\n    function getPosition(\n        address _address,\n        bytes32 _marketId\n    ) public view returns (\n        uint256 _longShares,\n        uint256 _shortShares,\n        uint256 _meanEntryPrice,\n        uint256 _meanEntrySpread,\n        uint256 _meanEntryLeverage,\n        uint256 _liquidationPrice\n    );\n\n    function getLastUpdated(address _address, bytes32 _marketId) public view returns (uint256 _lastUpdated);\n\n    function transfer(address _from, address _to, uint256 _token) public;\n    \n    function balanceOf(address _tokenOwner) public view returns (uint256 balance);\n\n    function mint(address _address, uint256 _token) public;\n\n    function burn(address _address, uint256 _token) public;\n\n     function getSideChainOperator() public view returns (address _address);\n\n    function inactivityPeriod() public view returns (uint256);\n\n    function getSideChainMerkleRootWrittenAtTime() public view returns(uint256 _sideChainMerkleRoot);\n\n    function fastTransfersEnabled() public view returns(bool);\n\n    function mainChain() public view returns(bool);\n\n    function setInactivityPeriod(uint256 _periodLength) public;\n\n    function disableFastWithdraws() public;\n\n    function setSideChainMerkleRoot(bytes32 _sideChainMerkleRoot) public;\n\n    function resetLast24HoursAmountWithdrawn() public;\n\n    function set24HourWithdrawLimit(uint256 _limit) public;\n\n    function getTokenSentToLinkedChain(address _address) public view returns (uint256 _token);\n\n    function getTokenClaimedOnThisChain(address _address) public view returns (uint256 _token);\n\n    function getTokenSentToLinkedChainTime(address _address) public view returns (uint256 _timeStamp);\n\n    function lastWithdrawLimitReductionTime() public view returns (uint256);\n\n    function withdrawLimit24Hours() public view returns (uint256);\n\n    function update24HoursWithdrawLimit(uint256 _amount) public;\n\n    function last24HoursAmountWithdrawn() public view returns (uint256);\n\n    function setTokenSentToLinkedChain(address _address, uint256 _token) public;\n\n    function setTokenClaimedOnThisChain(address _address, uint256 _token) public;\n\n    function add24HoursWithdrawn(uint256 _amount) public;\n\n    function getPositionHash(\n        address _address,\n        bytes32 _marketId,\n        uint256 _timeStamp,\n        uint256 _longShares,\n        uint256 _shortShares,\n        uint256 _meanEntryPrice,\n        uint256 _meanEntrySpread,\n        uint256 _meanEntryLeverage,\n        uint256 _liquidationPrice\n    ) public pure returns (bytes32 _hash);\n\n    function getPositionClaimedOnMainChain(bytes32 _positionHash) public view returns (bool _alreadyClaimed);\n\n    function setPositionClaimedOnMainChain(bytes32 _positionHash) public;\n\n     function getBalanceHash(address _address, uint256 _balance) public pure returns (bytes32 _hash);\n\n     function getSideChainMerkleRoot() public view returns(bytes32 _sideChainMerkleRoot);\n\n     function getBridgeNonce() public returns (uint256 _nonce);\n}"},"IMorpherToken.sol":{"content":"pragma solidity 0.5.16;\n\ninterface IMorpherToken {\n    /**\n     * Emits a {Transfer} event in ERC-20 token contract.\n     */\n    function emitTransfer(address _from, address _to, uint256 _amount) external;\n}\n"},"MerkleProof.sol":{"content":"pragma solidity 0.5.16;\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        require(proof.length \u003c 100, \"MerkleProof: proof too long. Use only sibling hashes.\");\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i \u003c proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash \u003c proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"},"Migrations.sol":{"content":"pragma solidity 0.5.16;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"},"MorpherAdmin.sol":{"content":"pragma solidity 0.5.16;\n\nimport \"./SafeMath.sol\";\nimport \"./MorpherState.sol\";\nimport \"./MorpherTradeEngine.sol\";\n\n// ----------------------------------------------------------------------------------\n// Administrator of the Morpher platform\n// ----------------------------------------------------------------------------------\n\ncontract MorpherAdmin {\n    MorpherState state;\n    MorpherTradeEngine tradeEngine;\n    using SafeMath for uint256;\n\n    event AdminLiquidationOrderCreated(\n        bytes32 indexed _orderId,\n        address indexed _address,\n        bytes32 indexed _marketId,\n        uint256 _closeSharesAmount,\n        uint256 _openMPHTokenAmount,\n        bool _tradeDirection,\n        uint256 _orderLeverage\n        );\n\n// ----------------------------------------------------------------------------\n// Precision of prices and leverage\n// ----------------------------------------------------------------------------\n\n    modifier onlyAdministrator {\n        require(msg.sender == state.getAdministrator(), \"Function can only be called by the Administrator.\");\n        _;\n    }\n    \n    constructor(address _stateAddress, address _tradeEngine) public {\n        state = MorpherState(_stateAddress);\n        tradeEngine = MorpherTradeEngine(_tradeEngine);\n    }\n\n// ----------------------------------------------------------------------------\n// Administrative functions\n// Set state address and maximum permitted leverage on platform\n// ----------------------------------------------------------------------------\n    function setMorpherState(address _stateAddress) public onlyAdministrator {\n        state = MorpherState(_stateAddress);\n    }\n\n    function setMorpherTradeEngine(address _tradeEngine) public onlyAdministrator {\n        tradeEngine = MorpherTradeEngine(_tradeEngine);\n    }\n\n// ----------------------------------------------------------------------------------\n// stockSplits(bytes32 _marketId, uint256 _fromIx, uint256 _toIx, uint256 _nominator, uint256 _denominator)\n// Experimental and untested\n// ----------------------------------------------------------------------------------\n\n    function stockSplits(bytes32 _marketId, uint256 _fromIx, uint256 _toIx, uint256 _nominator, uint256 _denominator) public onlyAdministrator {\n        require(state.getMarketActive(_marketId) == false, \"Market must be paused to process stock splits.\");\n        // If no _fromIx and _toIx specified, do entire _list\n        if (_fromIx == 0) {\n            _fromIx = 1;\n        }\n        if (_toIx == 0) {\n            _toIx = state.getMaxMappingIndex(_marketId);\n        }\n        uint256 _positionLongShares;\n        uint256 _positionShortShares;\n        uint256 _positionAveragePrice;\n        uint256 _positionAverageSpread;\n        uint256 _positionAverageLeverage;\n        uint256 _liquidationPrice;\n        address _address;\n        \n        for (uint256 i = _fromIx; i \u003c= _toIx; i++) {\n             // GET position from state\n             // multiply with nominator, divide by denominator (longShares/shortShares/meanEntry/meanSpread)\n             // Write back to state\n            _address = state.getExposureMappingAddress(_marketId, i);\n            (_positionLongShares, _positionShortShares, _positionAveragePrice, _positionAverageSpread, _positionAverageLeverage, _liquidationPrice) = state.getPosition(_address, _marketId);\n            _positionLongShares      = _positionLongShares.mul(_denominator).div(_nominator);\n            _positionShortShares     = _positionShortShares.mul(_denominator).div(_nominator);\n            _positionAveragePrice    = _positionAveragePrice.mul(_nominator).div(_denominator);\n            _positionAverageSpread   = _positionAverageSpread.mul(_nominator).div(_denominator);\n            if (_positionShortShares \u003e 0) {\n                _liquidationPrice    = getLiquidationPriceInternal(false, _address, _marketId);\n            } else {\n                _liquidationPrice    = getLiquidationPriceInternal(true, _address, _marketId);\n            }               \n            state.setPosition(_address, _marketId, now, _positionLongShares, _positionShortShares, _positionAveragePrice, _positionAverageSpread, _positionAverageLeverage, _liquidationPrice);   \n        }\n    }\n\n// ----------------------------------------------------------------------------------\n// contractRolls(bytes32 _marketId, uint256 _fromIx, uint256 _toIx, uint256 _rollUp, uint256 _rollDown)\n// Experimental and untested\n// ----------------------------------------------------------------------------------\n    function contractRolls(bytes32 _marketId, uint256 _fromIx, uint256 _toIx, uint256 _rollUp, uint256 _rollDown) public onlyAdministrator {\n        // If no _fromIx and _toIx specified, do entire _list\n        // dividends set meanEntry down, rolls either up or down\n        require(state.getMarketActive(_marketId) == false, \"Market must be paused to process rolls.\");\n        // If no _fromIx and _toIx specified, do entire _list\n        if (_fromIx == 0) {\n            _fromIx = 1;\n        }\n        if (_toIx == 0) {\n            _toIx = state.getMaxMappingIndex(_marketId);\n        }\n        uint256 _positionLongShares;\n        uint256 _positionShortShares;\n        uint256 _positionAveragePrice;\n        uint256 _positionAverageSpread;\n        uint256 _positionAverageLeverage;\n        uint256 _liquidationPrice;\n        address _address;\n        \n        for (uint256 i = _fromIx; i \u003c= _toIx; i++) {\n            _address = state.getExposureMappingAddress(_marketId, i);\n            (_positionLongShares, _positionShortShares, _positionAveragePrice, _positionAverageSpread, _positionAverageLeverage, _liquidationPrice) = state.getPosition(_address, _marketId);\n            _positionAveragePrice    = _positionAveragePrice.add(_rollUp).sub(_rollDown);\n            if (_positionShortShares \u003e 0) {\n                _liquidationPrice    = getLiquidationPriceInternal(false, _address, _marketId);\n            } else {\n                _liquidationPrice    = getLiquidationPriceInternal(true, _address, _marketId);\n            }               \n            state.setPosition(_address, _marketId, now, _positionLongShares, _positionShortShares, _positionAveragePrice, _positionAverageSpread, _positionAverageLeverage, _liquidationPrice);   \n        }\n    }\n\n/**\n * Stack too deep error\n */\n    function getLiquidationPriceInternal(bool isLong, address _userAddress, bytes32 _marketId) internal view returns (uint) {\n        ( , , uint price, , uint leverage, ) = state.getPosition(_userAddress, _marketId);\n        return tradeEngine.getLiquidationPrice(price, leverage, isLong, state.getLastUpdated(_userAddress, _marketId));\n    }\n    \n// ----------------------------------------------------------------------------------\n// delistMarket(bytes32 _marketId)\n// Administrator closes out all existing positions on _marketId market at current prices\n// ----------------------------------------------------------------------------------\n    function delistMarket(bytes32 _marketId, uint256 _fromIx, uint256 _toIx) public onlyAdministrator {\n        require(state.getMarketActive(_marketId) == true, \"Market must be active to process position liquidations.\");\n        // If no _fromIx and _toIx specified, do entire _list\n        if (_fromIx == 0) {\n            _fromIx = 1;\n        }\n        if (_toIx == 0) {\n            _toIx = state.getMaxMappingIndex(_marketId);\n        }\n        address _address;\n        for (uint256 i = _fromIx; i \u003c= _toIx; i++) {\n            _address = state.getExposureMappingAddress(_marketId, i);\n            adminLiquidationOrder(_address, _marketId);\n        }\n    }\n\n// ----------------------------------------------------------------------------------\n// delistMarket(bytes32 _marketId)\n// Administrator closes out an existing positions on _marketId market at current price\n// ----------------------------------------------------------------------------------\n    function adminLiquidationOrder(\n        address _address,\n        bytes32 _marketId\n        ) public onlyAdministrator returns (bytes32 _orderId) {\n            uint256 _positionLongShares = state.getLongShares(_address, _marketId);\n            uint256 _positionShortShares = state.getShortShares(_address, _marketId);\n            if (_positionLongShares \u003e 0) {\n                _orderId = tradeEngine.requestOrderId(_address, _marketId, _positionLongShares, 0, false, 10**8);\n                emit AdminLiquidationOrderCreated(_orderId, _address, _marketId, _positionLongShares, 0, false, 10**8);\n            }\n            if (_positionShortShares \u003e 0) {\n                _orderId = tradeEngine.requestOrderId(_address, _marketId, _positionShortShares, 0, true, 10**8);\n                emit AdminLiquidationOrderCreated(_orderId, _address, _marketId, _positionShortShares, 0, true, 10**8);\n            }\n            return _orderId;\n    }\n\n// ----------------------------------------------------------------------------------\n// payOperatingReward()\n// Calls paying of operating reward in state\n// ----------------------------------------------------------------------------------\n    function payOperatingReward() public view {\n        if (state.mainChain() == true) {\n            uint256 _lastRewardTime = state.lastRewardTime();\n            if (now \u003e _lastRewardTime) {\n                for (uint256 i = 1; i \u003c= now.sub(state.lastRewardTime()).div(86400); i++) {\n                    state.payOperatingReward;\n                }\n            }\n        }\n    }\n\n// ----------------------------------------------------------------------------------\n// stockDividends()\n// May want to add support for dividends later\n// ----------------------------------------------------------------------------------\n/*    function stockDividends(bytes32 _marketId, uint256 _fromIx, uint256 _toIx, uint256 _meanEntryUp, uint256 _meanEntryDown) public onlyOracle returns (bool _success){\n    }\n*/\n}\n"},"MorpherAdministratorProxy.sol":{"content":"pragma solidity 0.5.16;\n\nimport \"./Ownable.sol\";\n\ncontract MorpherAdministratorProxy is Ownable {\n\n    address public morpherStateAddress;\n\n    constructor(address _morpherAdministrator, address _morpherStateAddress) public {\n        transferOwnership(_morpherAdministrator);\n        morpherStateAddress = _morpherStateAddress;\n    }\n\n    function bulkActivateMarkets(bytes32[] memory _marketHashes) public onlyOwner {\n        for(uint i = 0; i \u003c _marketHashes.length; i++) {\n            bytes memory payload = abi.encodeWithSignature(\"activateMarket(bytes32)\", _marketHashes[i]);\n            (bool success, ) = morpherStateAddress.call(payload);\n            require(success,  \"MorpherAdministratorProxy: Failed to activate Market\");\n        }\n    }\n\n    function () external payable onlyOwner {\n        (bool success, ) = morpherStateAddress.call.value(msg.value)(msg.data);\n        require(success, \"MorpherAdministratorProxy: Failed to forward call\");\n    }\n}"},"MorpherAirdrop.sol":{"content":"pragma solidity 0.5.16;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IERC20.sol\";\n\n// ----------------------------------------------------------------------------------\n// Holds the Airdrop Token balance on contract address\n// AirdropAdmin can authorize addresses to receive airdrop.\n// Users have to claim their airdrop actively or Admin initiates transfer.\n// ----------------------------------------------------------------------------------\n\ncontract MorpherAirdrop is Ownable {\n    using SafeMath for uint256;\n\n// ----------------------------------------------------------------------------\n// Mappings for authorized / claimed airdrop\n// ----------------------------------------------------------------------------\n    mapping(address =\u003e uint256) private airdropClaimed;\n    mapping(address =\u003e uint256) private airdropAuthorized;\n\n    uint256 public totalAirdropAuthorized;\n    uint256 public totalAirdropClaimed;\n\n    address public airdropAdmin;\n    address public morpherToken;\n\n// ----------------------------------------------------------------------------\n// Events\n// ----------------------------------------------------------------------------\n    event AirdropSent(address indexed _operator, address indexed _recipient, uint256 _amountClaimed, uint256 _amountAuthorized);\n    event SetAirdropAuthorized(address indexed _recipient, uint256 _amountClaimed, uint256 _amountAuthorized);\n\n    constructor(address _airdropAdminAddress, address _morpherToken, address _coldStorageOwnerAddress) public {\n        setAirdropAdmin(_airdropAdminAddress);\n        setMorpherTokenAddress(_morpherToken);\n        transferOwnership(_coldStorageOwnerAddress);\n    }\n\n    modifier onlyAirdropAdmin {\n        require(msg.sender == airdropAdmin, \"MorpherAirdrop: can only be called by Airdrop Administrator.\");\n        _;\n    }\n\n// ----------------------------------------------------------------------------\n// Administrative functions\n// ----------------------------------------------------------------------------\n    function setAirdropAdmin(address _address) public onlyOwner {\n        airdropAdmin = _address;\n    }\n\n    function setMorpherTokenAddress(address _address) public onlyOwner {\n        morpherToken = _address;\n    }\n\n// ----------------------------------------------------------------------------\n// Get airdrop amount authorized for or claimed by address\n// ----------------------------------------------------------------------------\n    function getAirdropClaimed(address _userAddress) public view returns (uint256 _amount) {\n        return airdropClaimed[_userAddress];\n    }\n\n    function getAirdropAuthorized(address _userAddress) public view returns (uint256 _balance) {\n        return airdropAuthorized[_userAddress];\n    }\n\n    function getAirdrop(address _userAddress) public view returns(uint256 _claimed, uint256 _authorized) {\n        return (airdropClaimed[_userAddress], airdropAuthorized[_userAddress]);\n    }\n\n// ----------------------------------------------------------------------------\n// Airdrop Administrator can authorize airdrop amount per address\n// ----------------------------------------------------------------------------\n    function setAirdropAuthorized(address _userAddress, uint256 _authorized) public onlyAirdropAdmin {\n        // Can only set authorized amount to be higher than claimed\n        require(_authorized \u003e= airdropClaimed[_userAddress], \"MorpherAirdrop: airdrop authorized must be larger than claimed.\");\n        // Authorized amount can be higher or lower than previously authorized amount, adjust accordingly\n        totalAirdropAuthorized = totalAirdropAuthorized.sub(getAirdropAuthorized(_userAddress)).add(_authorized);\n        airdropAuthorized[_userAddress] = _authorized;\n        emit SetAirdropAuthorized(_userAddress, airdropClaimed[_userAddress], _authorized);\n    }\n\n// ----------------------------------------------------------------------------\n// User claims their entire airdrop\n// ----------------------------------------------------------------------------\n    function claimAirdrop() public {\n        uint256 _amount = airdropAuthorized[msg.sender].sub(airdropClaimed[msg.sender]);\n        _sendAirdrop(msg.sender, _amount);\n    }\n\n// ----------------------------------------------------------------------------\n// User claims part of their airdrop\n// ----------------------------------------------------------------------------\n    function claimSomeAirdrop(uint256 _amount) public {\n        _sendAirdrop(msg.sender, _amount);\n    }\n\n// ----------------------------------------------------------------------------\n// Administrator sends user their entire airdrop\n// ----------------------------------------------------------------------------\n    function adminSendAirdrop(address _recipient) public onlyAirdropAdmin {\n        uint256 _amount = airdropAuthorized[_recipient].sub(airdropClaimed[_recipient]);\n        _sendAirdrop(_recipient, _amount);\n    }\n\n// ----------------------------------------------------------------------------\n// Administrator sends user part of their airdrop\n// ----------------------------------------------------------------------------\n    function adminSendSomeAirdrop(address _recipient, uint256 _amount) public onlyAirdropAdmin {\n        _sendAirdrop(_recipient, _amount);\n    }\n\n// ----------------------------------------------------------------------------\n// Administrator sends user entire airdrop\n// ----------------------------------------------------------------------------\n    function _sendAirdrop(address _recipient, uint256 _amount) private {\n        require(airdropAuthorized[_recipient] \u003e= airdropClaimed[_recipient].add(_amount), \"MorpherAirdrop: amount exceeds authorized airdrop amount.\");\n        airdropClaimed[_recipient] = airdropClaimed[_recipient].add(_amount);\n        totalAirdropClaimed = totalAirdropClaimed.add(_amount);\n        IERC20(morpherToken).transfer(_recipient, _amount);\n        emit AirdropSent(msg.sender, _recipient, airdropClaimed[_recipient], airdropAuthorized[_recipient]);\n    }\n\n// ----------------------------------------------------------------------------\n// Administrator sends user part of their airdrop\n// ----------------------------------------------------------------------------\n    function adminAuthorizeAndSend(address _recipient, uint256 _amount) public onlyAirdropAdmin {\n        setAirdropAuthorized(_recipient, getAirdropAuthorized(_recipient).add(_amount));\n        _sendAirdrop(_recipient, _amount);\n    }\n\n// ------------------------------------------------------------------------\n// Don\u0027t accept ETH\n// ------------------------------------------------------------------------\n    function () external payable {\n        revert(\"MorpherAirdrop: you can\u0027t deposit Ether here\");\n    }\n}\n"},"MorpherBridge.sol":{"content":"// ------------------------------------------------------------------------\n// MorpherBridge\n// Handles deposit to and withdraws from the side chain, writing of the merkle\n// root to the main chain by the side chain operator, and enforces a rolling 24 hours\n// token withdraw limit from side chain to main chain.\n// If side chain operator doesn\u0027t write a merkle root hash to main chain for more than\n// 72 hours positions and balaces from side chain can be transferred to main chain.\n// ------------------------------------------------------------------------\n\npragma solidity 0.5.16;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IMorpherState.sol\";\nimport \"./MerkleProof.sol\";\n\ncontract MorpherBridge is Ownable {\n\n    IMorpherState state;\n    using SafeMath for uint256;\n\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) withdrawalPerDay; //[address][day] = withdrawalAmount\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) withdrawalPerMonth; //[address][month] = withdrawalAmount\n\n    uint256 public withdrawalLimitDaily = 200000 * (10**18); //200k MPH per day\n    uint256 public withdrawalLimitMonthly = 1000000 * (10 ** 18); //1M MPH per month\n\n    event TransferToLinkedChain(\n        address indexed from,\n        uint256 tokens,\n        uint256 totalTokenSent,\n        uint256 timeStamp,\n        uint256 transferNonce,\n        bytes32 indexed transferHash\n    );\n    event TrustlessWithdrawFromSideChain(address indexed from, uint256 tokens);\n    event OperatorChainTransfer(address indexed from, uint256 tokens, bytes32 sidechainTransactionHash);\n    event ClaimFailedTransferToSidechain(address indexed from, uint256 tokens);\n    event PositionRecoveryFromSideChain(address indexed from, bytes32 positionHash);\n    event TokenRecoveryFromSideChain(address indexed from, bytes32 positionHash);\n    event SideChainMerkleRootUpdated(bytes32 _rootHash);\n    event WithdrawLimitReset();\n    event WithdrawLimitChanged(uint256 _withdrawLimit);\n    event WithdrawLimitDailyChanged(uint256 _oldLimit, uint256 _newLimit);\n    event WithdrawLimitMonthlyChanged(uint256 _oldLimit, uint256 _newLimit);\n    event LinkState(address _address);\n\n    constructor(address _stateAddress, address _coldStorageOwnerAddress) public {\n        setMorpherState(_stateAddress);\n        transferOwnership(_coldStorageOwnerAddress);\n    }\n\n    modifier onlySideChainOperator {\n        require(msg.sender == state.getSideChainOperator(), \"MorpherBridge: Function can only be called by Sidechain Operator.\");\n        _;\n    }\n\n    modifier sideChainInactive {\n        require(now - state.inactivityPeriod() \u003e state.getSideChainMerkleRootWrittenAtTime(), \"MorpherBridge: Function can only be called if sidechain is inactive.\");\n        _;\n    }\n    \n    modifier fastTransfers {\n        require(state.fastTransfersEnabled() == true, \"MorpherBridge: Fast transfers have been disabled permanently.\");\n        _;\n    }\n\n    modifier onlyMainchain {\n        require(state.mainChain() == true, \"MorpherBridge: Function can only be executed on Ethereum.\" );\n        _;\n    }\n    \n    // ------------------------------------------------------------------------\n    // Links Token Contract with State\n    // ------------------------------------------------------------------------\n    function setMorpherState(address _stateAddress) public onlyOwner {\n        state = IMorpherState(_stateAddress);\n        emit LinkState(_stateAddress);\n    }\n\n    function setInactivityPeriod(uint256 _periodInSeconds) private {\n        state.setInactivityPeriod(_periodInSeconds);\n    }\n\n    function disableFastTransfers() public onlyOwner  {\n        state.disableFastWithdraws();\n    }\n\n    function updateSideChainMerkleRoot(bytes32 _rootHash) public onlySideChainOperator {\n        state.setSideChainMerkleRoot(_rootHash);\n        emit SideChainMerkleRootUpdated(_rootHash);\n    }\n\n    function resetLast24HoursAmountWithdrawn() public onlySideChainOperator {\n        state.resetLast24HoursAmountWithdrawn();\n        emit WithdrawLimitReset();\n    }\n\n    function set24HourWithdrawLimit(uint256 _withdrawLimit) public onlySideChainOperator {\n        state.set24HourWithdrawLimit(_withdrawLimit);\n        emit WithdrawLimitChanged(_withdrawLimit);\n    }\n\n    function updateWithdrawLimitDaily(uint256 _withdrawLimit) public onlySideChainOperator {\n        emit WithdrawLimitDailyChanged(withdrawalLimitDaily, _withdrawLimit);\n        withdrawalLimitDaily = _withdrawLimit;\n    }\n\n    function updateWithdrawLimitMonthly(uint256 _withdrawLimit) public onlySideChainOperator {\n        emit WithdrawLimitMonthlyChanged(withdrawalLimitMonthly, _withdrawLimit);\n        withdrawalLimitMonthly = _withdrawLimit;\n    }\n\n    function getTokenSentToLinkedChain(address _address) public view returns (uint256 _token) {\n        return state.getTokenSentToLinkedChain(_address);\n    }\n\n    function getTokenClaimedOnThisChain(address _address) public view returns (uint256 _token)  {\n        return state.getTokenClaimedOnThisChain(_address);\n    }\n\n    function getTokenSentToLinkedChainTime(address _address) public view returns (uint256 _time)  {\n        return state.getTokenSentToLinkedChainTime(_address);\n    }\n\n    // ------------------------------------------------------------------------\n    // verifyWithdrawOk(uint256 _amount)\n    // Checks if creating _amount token on main chain does not violate the 24 hour transfer limit\n    // ------------------------------------------------------------------------\n    function verifyWithdrawOk(uint256 _amount) public returns (bool _authorized) {\n        uint256 _lastWithdrawLimitReductionTime = state.lastWithdrawLimitReductionTime();\n        uint256 _withdrawLimit24Hours = state.withdrawLimit24Hours();\n        \n        if (now \u003e _lastWithdrawLimitReductionTime) {\n            uint256 _timePassed = now.sub(_lastWithdrawLimitReductionTime);\n            state.update24HoursWithdrawLimit(_timePassed.mul(_withdrawLimit24Hours).div(1 days));\n        }\n        \n        if (state.last24HoursAmountWithdrawn().add(_amount) \u003c= _withdrawLimit24Hours) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function isNotDailyLimitExceeding(uint256 _amount) public view returns(bool) {\n        return (withdrawalPerDay[msg.sender][block.timestamp / 1 days].add(_amount) \u003c= withdrawalLimitDaily);\n    }\n    function isNotMonthlyLimitExceeding(uint256 _amount) public view returns(bool) {\n        return (withdrawalPerMonth[msg.sender][block.timestamp / 30 days].add(_amount) \u003c= withdrawalLimitMonthly);\n    }\n\n    function verifyUpdateDailyLimit(uint256 _amount) public {\n        require(isNotDailyLimitExceeding(_amount), \"MorpherBridge: Withdrawal Amount exceeds daily limit\");\n        withdrawalPerDay[msg.sender][block.timestamp / 1 days] = withdrawalPerDay[msg.sender][block.timestamp / 1 days].add(_amount);\n    }\n\n    function verifyUpdateMonthlyLimit(uint256 _amount) public {\n        require(isNotMonthlyLimitExceeding(_amount), \"MorpherBridge: Withdrawal Amount exceeds monthly limit\");\n        withdrawalPerMonth[msg.sender][block.timestamp / 30 days] = withdrawalPerMonth[msg.sender][block.timestamp / 30 days].add(_amount);\n    }\n\n    // ------------------------------------------------------------------------\n    // transferToSideChain(uint256 _tokens)\n    // Transfer token to Morpher\u0027s side chain to trade without fees and near instant\n    // settlement.\n    // - Owner\u0027s account must have sufficient balance to transfer\n    // - 0 value transfers are not supported\n    // Token are burned on the main chain and are created and credited to msg.sender\n    //  on the side chain\n    // ------------------------------------------------------------------------\n    function transferToSideChain(uint256 _tokens) public {\n        require(_tokens \u003e= 0, \"MorpherBridge: Amount of tokens must be positive.\");\n        require(state.balanceOf(msg.sender) \u003e= _tokens, \"MorpherBridge: Insufficient balance.\");\n        state.burn(msg.sender, _tokens);\n        uint256 _newTokenSentToLinkedChain = getTokenSentToLinkedChain(msg.sender).add(_tokens);\n        uint256 _transferNonce = state.getBridgeNonce();\n        uint256 _timeStamp = now;\n        bytes32 _transferHash = keccak256(\n            abi.encodePacked(\n                msg.sender,\n                _tokens,\n                _newTokenSentToLinkedChain,\n                _timeStamp,\n                _transferNonce\n            )\n        );\n        state.setTokenSentToLinkedChain(msg.sender, _newTokenSentToLinkedChain);\n        emit TransferToLinkedChain(msg.sender, _tokens, _newTokenSentToLinkedChain, _timeStamp, _transferNonce, _transferHash);\n    }\n\n    // ------------------------------------------------------------------------\n    // fastTransferFromSideChain(uint256 _numOfToken, uint256 _tokenBurnedOnLinkedChain, bytes32[] memory _proof)\n    // The sidechain operator can credit users with token they burend on the sidechain. Transfers\n    // happen immediately. To be removed after Beta.\n    // ------------------------------------------------------------------------\n    function fastTransferFromSideChain(address _address, uint256 _numOfToken, uint256 _tokenBurnedOnLinkedChain, bytes32 _sidechainTransactionHash) public onlySideChainOperator fastTransfers {\n        uint256 _tokenClaimed = state.getTokenClaimedOnThisChain(_address);\n        require(verifyWithdrawOk(_numOfToken), \"MorpherBridge: Withdraw amount exceeds permitted 24 hour limit. Please try again in a few hours.\");\n        require(_tokenClaimed.add(_numOfToken) \u003c= _tokenBurnedOnLinkedChain, \"MorpherBridge: Token amount exceeds token deleted on linked chain.\");\n        _chainTransfer(_address, _tokenClaimed, _numOfToken);\n        emit OperatorChainTransfer(_address, _numOfToken, _sidechainTransactionHash);\n    }\n    \n    // ------------------------------------------------------------------------\n    // trustlessTransferFromSideChain(uint256 _numOfToken, uint256 _claimLimit, bytes32[] memory _proof)\n    // Performs a merkle proof on the number of token that have been burned by the user on the side chain.\n    // If the number of token claimed on the main chain is less than the number of burned token on the side chain\n    // the difference (or less) can be claimed on the main chain.\n    // ------------------------------------------------------------------------\n    function trustlessTransferFromLinkedChain(uint256 _numOfToken, uint256 _claimLimit, bytes32[] memory _proof) public {\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _claimLimit));\n        uint256 _tokenClaimed = state.getTokenClaimedOnThisChain(msg.sender);        \n        require(mProof(_proof, leaf), \"MorpherBridge: Merkle Proof failed. Please make sure you entered the correct claim limit.\");\n        require(verifyWithdrawOk(_numOfToken), \"MorpherBridge: Withdraw amount exceeds permitted 24 hour limit. Please try again in a few hours.\");\n        verifyUpdateDailyLimit(_numOfToken);\n        verifyUpdateMonthlyLimit(_numOfToken);\n        require(_tokenClaimed.add(_numOfToken) \u003c= _claimLimit, \"MorpherBridge: Token amount exceeds token deleted on linked chain.\");     \n        _chainTransfer(msg.sender, _tokenClaimed, _numOfToken);   \n        emit TrustlessWithdrawFromSideChain(msg.sender, _numOfToken);\n    }\n    \n    // ------------------------------------------------------------------------\n    // _chainTransfer(address _address, uint256 _tokenClaimed, uint256 _numOfToken)\n    // Creates token on the chain for the user after proving their distruction on the \n    // linked chain has been proven before \n    // ------------------------------------------------------------------------\n    function _chainTransfer(address _address, uint256 _tokenClaimed, uint256 _numOfToken) private {\n        state.setTokenClaimedOnThisChain(_address, _tokenClaimed.add(_numOfToken));\n        state.add24HoursWithdrawn(_numOfToken);\n        state.mint(_address, _numOfToken);\n    }\n        \n    // ------------------------------------------------------------------------\n    // claimFailedTransferToSidechain(uint256 _wrongSideChainBalance, bytes32[] memory _proof)\n    // If token sent to side chain were not credited to the user on the side chain within inactivityPeriod\n    // they can reclaim the token on the main chain by submitting the proof that their\n    // side chain balance is less than the number of token sent from main chain.\n    // ------------------------------------------------------------------------\n    function claimFailedTransferToSidechain(uint256 _wrongSideChainBalance, bytes32[] memory _proof) public {\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _wrongSideChainBalance));\n        uint256 _tokenSentToLinkedChain = getTokenSentToLinkedChain(msg.sender);\n        uint256 _tokenSentToLinkedChainTime = getTokenSentToLinkedChainTime(msg.sender);\n        uint256 _inactivityPeriod = state.inactivityPeriod();\n        \n        require(now \u003e _tokenSentToLinkedChainTime.add(_inactivityPeriod), \"MorpherBridge: Failed deposits can only be claimed after inactivity period.\");\n        require(_wrongSideChainBalance \u003c _tokenSentToLinkedChain, \"MorpherBridge: Other chain credit is greater equal to wrongSideChainBalance.\");\n        require(verifyWithdrawOk(_tokenSentToLinkedChain.sub(_wrongSideChainBalance)), \"MorpherBridge: Claim amount exceeds permitted 24 hour limit.\");\n        require(mProof(_proof, leaf), \"MorpherBridge: Merkle Proof failed. Enter total amount of deposits on side chain.\");\n        \n        uint256 _claimAmount = _tokenSentToLinkedChain.sub(_wrongSideChainBalance);\n        state.setTokenSentToLinkedChain(msg.sender, _tokenSentToLinkedChain.sub(_claimAmount));\n        state.add24HoursWithdrawn(_claimAmount);\n        state.mint(msg.sender, _claimAmount);\n        emit ClaimFailedTransferToSidechain(msg.sender, _claimAmount);\n    }\n\n    // ------------------------------------------------------------------------\n    // recoverPositionFromSideChain(bytes32[] memory _proof, bytes32 _leaf, bytes32 _marketId, uint256 _timeStamp, uint256 _longShares, uint256 _shortShares, uint256 _meanEntryPrice, uint256 _meanEntrySpread, uint256 _meanEntryLeverage)\n    // Failsafe against side chain operator becoming inactive or withholding Times (Time withhold attack).\n    // After 72 hours of no update of the side chain merkle root users can withdraw their last recorded\n    // positions from side chain to main chain. Overwrites eventually existing position on main chain.\n    // ------------------------------------------------------------------------\n    function recoverPositionFromSideChain(\n        bytes32[] memory _proof,\n        bytes32 _leaf,\n        bytes32 _marketId,\n        uint256 _timeStamp,\n        uint256 _longShares,\n        uint256 _shortShares,\n        uint256 _meanEntryPrice,\n        uint256 _meanEntrySpread,\n        uint256 _meanEntryLeverage,\n        uint256 _liquidationPrice\n        ) public sideChainInactive onlyMainchain {\n        require(_leaf == state.getPositionHash(msg.sender, _marketId, _timeStamp, _longShares, _shortShares, _meanEntryPrice, _meanEntrySpread, _meanEntryLeverage, _liquidationPrice), \"MorpherBridge: leaf does not equal position hash.\");\n        require(state.getPositionClaimedOnMainChain(_leaf) == false, \"MorpherBridge: Position already transferred.\");\n        require(mProof(_proof,_leaf) == true, \"MorpherBridge: Merkle proof failed.\");\n        state.setPositionClaimedOnMainChain(_leaf);\n        state.setPosition(msg.sender, _marketId, _timeStamp, _longShares, _shortShares, _meanEntryPrice, _meanEntrySpread, _meanEntryLeverage, _liquidationPrice);\n        emit PositionRecoveryFromSideChain(msg.sender, _leaf);\n        // Remark: After resuming operations side chain operator has 72 hours to sync and eliminate transferred positions on side chain to avoid double spend\n    }\n\n    // ------------------------------------------------------------------------\n    // recoverTokenFromSideChain(bytes32[] memory _proof, bytes32 _leaf, bytes32 _marketId, uint256 _timeStamp, uint256 _longShares, uint256 _shortShares, uint256 _meanEntryPrice, uint256 _meanEntrySpread, uint256 _meanEntryLeverage)\n    // Failsafe against side chain operator becoming inactive or withholding times (time withhold attack).\n    // After 72 hours of no update of the side chain merkle root users can withdraw their last recorded\n    // token balance from side chain to main chain.\n    // ------------------------------------------------------------------------\n    function recoverTokenFromSideChain(bytes32[] memory _proof, bytes32 _leaf, uint256 _balance) public sideChainInactive onlyMainchain {\n        // Require side chain root hash not set on Mainchain for more than 72 hours (=3 days)\n        require(_leaf == state.getBalanceHash(msg.sender, _balance), \"MorpherBridge: Wrong balance.\");\n        require(state.getPositionClaimedOnMainChain(_leaf) == false, \"MorpherBridge: Token already transferred.\");\n        require(mProof(_proof,_leaf) == true, \"MorpherBridge: Merkle proof failed.\");\n        require(verifyWithdrawOk(_balance), \"MorpherBridge: Withdraw amount exceeds permitted 24 hour limit.\");\n        state.setPositionClaimedOnMainChain(_leaf);\n        _chainTransfer(msg.sender, state.getTokenClaimedOnThisChain(msg.sender), _balance);\n        emit TokenRecoveryFromSideChain(msg.sender, _leaf);\n        // Remark: Side chain operator must adjust side chain balances for token recoveries before restarting operations to avoid double spend\n    }\n\n    // ------------------------------------------------------------------------\n    // mProof(bytes32[] memory _proof, bytes32 _leaf)\n    // Computes merkle proof against the root hash of the sidechain stored in Morpher state\n    // ------------------------------------------------------------------------\n    function mProof(bytes32[] memory _proof, bytes32 _leaf) public view returns(bool _isTrue) {\n        return MerkleProof.verify(_proof, state.getSideChainMerkleRoot(), _leaf);\n    }\n}\n"},"MorpherEscrow.sol":{"content":"pragma solidity 0.5.16;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IERC20.sol\";\n\n// ----------------------------------------------------------------------------------\n// Escrow contract to safely store and release the token allocated to Morpher at\n// protocol inception\n// ----------------------------------------------------------------------------------\n\ncontract MorpherEscrow is Ownable{\n    using SafeMath for uint256;\n\n    uint256 public lastEscrowTransferTime;\n    address public recipient;\n    address public morpherToken;\n\n    uint256 public constant RELEASEAMOUNT = 10**25;\n    uint256 public constant RELEASEPERIOD = 30 days;\n\n    event EscrowReleased(uint256 _released, uint256 _leftInEscrow);\n\n    constructor(address _recipientAddress, address _morpherToken, address _coldStorageOwnerAddress) public {\n        setRecipientAddress(_recipientAddress);\n        setMorpherTokenAddress(_morpherToken);\n        lastEscrowTransferTime = now;\n        transferOwnership(_coldStorageOwnerAddress);\n    }\n\n    // ----------------------------------------------------------------------------------\n    // Owner can modify recipient address and update morpherToken adddress\n    // ----------------------------------------------------------------------------------\n    function setRecipientAddress(address _recipientAddress) public onlyOwner {\n        recipient = _recipientAddress;\n    }\n\n    function setMorpherTokenAddress(address _address) public onlyOwner {\n        morpherToken = _address;\n    }\n\n    // ----------------------------------------------------------------------------------\n    // Anyone can release funds from escrow if enough time has elapsed\n    // Every 30 days 1% of the total initial supply or 10m token are released to Morpher\n    // ----------------------------------------------------------------------------------\n    function releaseFromEscrow() public {\n        require(IERC20(morpherToken).balanceOf(address(this)) \u003e 0, \"No funds left in escrow.\");\n        uint256 _releasedAmount;\n        if (now \u003e lastEscrowTransferTime.add(RELEASEPERIOD)) {\n            if (IERC20(morpherToken).balanceOf(address(this)) \u003e RELEASEAMOUNT) {\n                _releasedAmount = RELEASEAMOUNT;\n            } else {\n                _releasedAmount = IERC20(morpherToken).balanceOf(address(this));\n            }\n            IERC20(morpherToken).transfer(recipient, _releasedAmount);\n            lastEscrowTransferTime = lastEscrowTransferTime.add(RELEASEPERIOD);\n            emit EscrowReleased(_releasedAmount, IERC20(morpherToken).balanceOf(address(this)));\n        }\n    }\n}\n"},"MorpherFaucet.sol":{"content":"pragma solidity 0.5.16;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./MorpherToken.sol\";\n\n// ----------------------------------------------------------------------------------\n// Holds the Faucet Token balance on contract addressrdrop.\n// Users can topup to fillUpAmount\n// ----------------------------------------------------------------------------------\n\ncontract MorpherFaucet is Ownable {\n    using SafeMath for uint256;\n\n    MorpherToken morpherToken;\n\n    uint public fillUpAmount; //100 * 10**18; //fill up to 100 MPH.\n\n    event MorpherFaucetTopUp(address indexed _receiver, uint _amount);\n    event MorpherFaucetFillUpAmountChanged(uint _oldAmount, uint _newAmount);\n\n    constructor(address payable _morpherToken, address _coldStorageOwnerAddress, uint _fillUpAmount) public {\n        morpherToken = MorpherToken(_morpherToken);\n        transferOwnership(_coldStorageOwnerAddress);\n        setFillUpAmount(_fillUpAmount);\n    }\n  \n    function setMorpherTokenAddress(address payable _address) public onlyOwner {\n        morpherToken = MorpherToken(_address);\n    }\n\n    function setFillUpAmount(uint _newFillUpAmount) public onlyOwner {\n        emit MorpherFaucetFillUpAmountChanged(fillUpAmount, _newFillUpAmount);\n        fillUpAmount = _newFillUpAmount;\n    }\n\n\n    /**\n     * Only important function: User can top-up to his max amount. Needs to have less than fillUpAmount, otherwise it will fail.\n     */\n    function topUpToken() public {\n        require(morpherToken.balanceOf(msg.sender) \u003c fillUpAmount, \"FILLUP_AMOUNT_REACHED\");\n        morpherToken.transfer(msg.sender, fillUpAmount.sub(morpherToken.balanceOf(msg.sender)));\n        emit MorpherFaucetTopUp(msg.sender, fillUpAmount.sub(morpherToken.balanceOf(msg.sender)));\n    }\n\n    function () external payable {\n        revert(\"MorpherFaucet: you can\u0027t deposit Ether here\");\n    }\n\n\n}\n"},"MorpherGovernance.sol":{"content":"pragma solidity 0.5.16;\n// ------------------------------------------------------------------------\n// Morpher Governance (MAIN CHAIN ONLY)\n//\n// Every user able and willig to lock up sufficient token can become a validator\n// of the Morpher protocol. Validators function similiar to a board of directors\n// and vote on the protocol Administrator and the Oracle contract.\n// The Administrator (=Protocol CEO) has the power to add/delete markets and to\n// pause the contracts to allow for updates.\n// The Oracle contract is the address of the contract allowed to fetch prices\n// from outside the smart contract.\n//\n// It becomes progressively harder to become a valdiator. Each new validator\n// has to lock up (numberOfValidators + 1) * 10m Morpher token. Upon stepping\n// down as validator only 99% of the locked up token are returned, the other 1%\n// are burned.\n//\n// Governance is expected to become more sophisticated in the future\n// ------------------------------------------------------------------------\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./MorpherState.sol\";\n\ncontract MorpherGovernance is Ownable {\n\n    using SafeMath for uint256;\n    MorpherState state;\n    \n    event BecomeValidator(address indexed _sender, uint256 indexed _myValidatorIndex);\n    event StepDownAsValidator(address indexed _sender, uint256 indexed _myValidatorIndex);\n    event ElectedAdministrator(address indexed _administratorAddress, uint256 _votes);\n    event ElectedOracle(address indexed _oracleAddress, uint256 _votes);\n\n    uint256 public constant MINVALIDATORLOCKUP = 10**25;\n    uint256 public constant MAXVALIDATORS = 21;\n    uint256 public constant VALIDATORWARMUPPERIOD = 7 days;\n\n    uint256 public numberOfValidators;\n    uint256 public lastValidatorJoined;\n    uint256 public rewardBasisPoints;\n\n    address public morpherToken;\n\n    mapping(address =\u003e uint256) private validatorIndex;\n    mapping(address =\u003e uint256) private validatorJoinedAtTime;\n    mapping(uint256 =\u003e address) private validatorAddress;\n    mapping(address =\u003e address) private oracleVote;\n    mapping(address =\u003e address) private administratorVote;\n    mapping(address =\u003e uint256) private countVotes;\n\n    constructor(address _stateAddress, address _coldStorageOwnerAddress) public {\n        setMorpherState(_stateAddress);\n        transferOwnership(_coldStorageOwnerAddress);        \n    }\n    \n    modifier onlyValidator() {\n        require(isValidator(msg.sender), \"MorpherGovernance: Only Validators can invoke that function.\");\n        _;\n    }\n\n    function setMorpherState(address _stateAddress) private {\n        state = MorpherState(_stateAddress);\n    }\n\n    function setMorpherTokenAddress(address _address) public onlyOwner {\n        morpherToken = _address;\n    }\n\n    function getValidatorAddress(uint256 _index) public view returns (address _address) {\n        return validatorAddress[_index];\n    }\n\n    function getValidatorIndex(address _address) public view returns (uint256 _index) {\n        return validatorIndex[_address];\n    }\n\n    function isValidator(address _address) public view returns (bool) {\n        return validatorIndex[_address] \u003e 0;\n    }\n\n    function setOracle(address  _oracleAddress) private {\n        state.setOracleContract(_oracleAddress);\n    }\n\n    function setAdministrator(address _administratorAddress) private {\n        state.setAdministrator(_administratorAddress);\n    }\n\n    function getMorpherAdministrator() public view returns (address _address) {\n        return state.getAdministrator();\n    }\n\n    function getMorpherOracle() public view returns (address _address)  {\n        return state.getOracleContract();\n    }\n\n    function getOracleVote(address _address) public view returns (address _votedOracleAddress) {\n        return oracleVote[_address];\n    }\n\n    function becomeValidator() public {\n        // To become a validator you have to lock up 10m * (number of validators + 1) Morpher Token in escrow\n        // After a warmup period of 7 days the new validator can vote on Oracle contract and protocol Administrator\n        uint256 _requiredAmount = MINVALIDATORLOCKUP.mul(numberOfValidators.add(1));\n        require(state.balanceOf(msg.sender) \u003e= _requiredAmount, \"MorpherGovernance: Insufficient balance to become Validator.\");\n        require(isValidator(msg.sender) == false, \"MorpherGovernance: Address is already Validator.\");\n        require(numberOfValidators \u003c= MAXVALIDATORS, \"MorpherGovernance: number of Validators can not exceed Max Validators.\");\n        state.transfer(msg.sender, address(this), _requiredAmount);\n        numberOfValidators = numberOfValidators.add(1);\n        validatorIndex[msg.sender] = numberOfValidators;\n        validatorJoinedAtTime[msg.sender] = now;\n        lastValidatorJoined = now;\n        validatorAddress[numberOfValidators] = msg.sender;\n        emit BecomeValidator(msg.sender, numberOfValidators);\n    }\n\n    function stepDownValidator() public onlyValidator {\n        // Stepping down as validator nullifies the validator\u0027s votes and releases his token\n        // from escrow. If the validator stepping down is not the validator that joined last,\n        // all validators who joined after the validator stepping down receive 10^7 * 0.99 token from\n        // escrow, and their validator ordinal number is reduced by one. E.g. if validator 3 of 5 steps down\n        // validator 4 becomes validator 3, and validator 5 becomes validator 4. Both receive 10^7 * 0.99 token\n        // from escrow, as their new position requires fewer token in lockup. 1% of the token released from escrow \n        // are burned for every validator receiving a payout. \n        // Burning prevents vote delay attacks: validators stepping down and re-joining could\n        // delay votes for VALIDATORWARMUPPERIOD.\n        uint256 _myValidatorIndex = validatorIndex[msg.sender];\n        require(state.balanceOf(address(this)) \u003e= MINVALIDATORLOCKUP.mul(numberOfValidators), \"MorpherGovernance: Escrow does not have enough funds. Should not happen.\");\n        // Stepping down as validator potentially releases token to the other validatorAddresses\n        for (uint256 i = _myValidatorIndex; i \u003c numberOfValidators; i++) {\n            validatorAddress[i] = validatorAddress[i+1];\n            validatorIndex[validatorAddress[i]] = i;\n            // Release 9.9m of token to every validator moving up, burn 0.1m token\n            state.transfer(address(this), validatorAddress[i], MINVALIDATORLOCKUP.div(100).mul(99));\n            state.burn(address(this), MINVALIDATORLOCKUP.div(100));\n        }\n        // Release 99% of escrow token of validator dropping out, burn 1%\n        validatorAddress[numberOfValidators] = address(0);\n        validatorIndex[msg.sender] = 0;\n        validatorJoinedAtTime[msg.sender] = 0;\n        oracleVote[msg.sender] = address(0);\n        administratorVote[msg.sender] = address(0);\n        numberOfValidators = numberOfValidators.sub(1);\n        countOracleVote();\n        countAdministratorVote();\n        state.transfer(address(this), msg.sender, MINVALIDATORLOCKUP.mul(_myValidatorIndex).div(100).mul(99));\n        state.burn(address(this), MINVALIDATORLOCKUP.mul(_myValidatorIndex).div(100));\n        emit StepDownAsValidator(msg.sender, validatorIndex[msg.sender]);\n    }\n\n    function voteOracle(address _oracleAddress) public onlyValidator {\n        require(validatorJoinedAtTime[msg.sender].add(VALIDATORWARMUPPERIOD) \u003c now, \"MorpherGovernance: Validator was just appointed and is not eligible to vote yet.\");\n        require(lastValidatorJoined.add(VALIDATORWARMUPPERIOD) \u003c now, \"MorpherGovernance: New validator joined the board recently, please wait for the end of the warm up period.\");\n        oracleVote[msg.sender] = _oracleAddress;\n        // Count Oracle Votes\n        (address _votedOracleAddress, uint256 _votes) = countOracleVote();\n        emit ElectedOracle(_votedOracleAddress, _votes);\n    }\n\n    function voteAdministrator(address _administratorAddress) public onlyValidator {\n        require(validatorJoinedAtTime[msg.sender].add(VALIDATORWARMUPPERIOD) \u003c now, \"MorpherGovernance: Validator was just appointed and is not eligible to vote yet.\");\n        require(lastValidatorJoined.add(VALIDATORWARMUPPERIOD) \u003c now, \"MorpherGovernance: New validator joined the board recently, please wait for the end of the warm up period.\");\n        administratorVote[msg.sender] = _administratorAddress;\n        // Count Administrator Votes\n        (address _appointedAdministrator, uint256 _votes) = countAdministratorVote();\n        emit ElectedAdministrator(_appointedAdministrator, _votes);\n    }\n\n    function countOracleVote() public returns (address _votedOracleAddress, uint256 _votes) {\n        // Count oracle votes\n        for (uint256 i = 1; i \u003c= numberOfValidators; i++) {\n            countVotes[oracleVote[validatorAddress[i]]]++;\n            if (countVotes[oracleVote[validatorAddress[i]]] \u003e _votes) {\n                _votes = countVotes[oracleVote[validatorAddress[i]]];\n                _votedOracleAddress = oracleVote[validatorAddress[i]];\n            }\n        }\n        // Evaluate: Simple majority of Validators resets oracleAddress\n        if (_votes \u003e numberOfValidators.div(2)) {\n            setOracle(_votedOracleAddress);\n        }\n        for (uint256 i = 1; i \u003c= numberOfValidators; i++) {\n            countVotes[administratorVote[validatorAddress[i]]] = 0;\n        }\n        return(_votedOracleAddress, _votes);\n    }\n\n    function countAdministratorVote() public returns (address _appointedAdministrator, uint256 _votes) {\n        // Count Administrator votes\n        for (uint256 i=1; i\u003c=numberOfValidators; i++) {\n            countVotes[administratorVote[validatorAddress[i]]]++;\n            if (countVotes[administratorVote[validatorAddress[i]]] \u003e _votes) {\n                _votes = countVotes[administratorVote[validatorAddress[i]]];\n                _appointedAdministrator = administratorVote[validatorAddress[i]];\n            }\n        }\n        // Evaluate: Simple majority of Validators resets administratorAddress\n        if (_votes \u003e numberOfValidators / 2) {\n            setAdministrator(_appointedAdministrator);\n        }\n        for (uint256 i = 1; i \u003c= numberOfValidators; i++) {\n            countVotes[administratorVote[validatorAddress[i]]] = 0;\n        }\n        return(_appointedAdministrator, _votes);\n    }\n}\n"},"MorpherMintingLimiter.sol":{"content":"pragma solidity 0.5.16;\n\nimport \"./MorpherState.sol\";\nimport \"./MorpherTradeEngine.sol\";\nimport \"./SafeMath.sol\";\n\ncontract MorpherMintingLimiter {\n    using SafeMath for uint256; \n\n    uint256 public mintingLimitPerUser;\n    uint256 public mintingLimitDaily;\n    uint256 public timeLockingPeriod;\n\n    mapping(address =\u003e uint256) public escrowedTokens;\n    mapping(address =\u003e uint256) public lockedUntil;\n    mapping(uint256 =\u003e uint256) public dailyMintedTokens;\n\n    address tradeEngineAddress; \n    MorpherState state;\n\n    event MintingEscrowed(address _user, uint256 _tokenAmount);\n    event EscrowReleased(address _user, uint256 _tokenAmount);\n    event MintingDenied(address _user, uint256 _tokenAmount);\n    event MintingLimitUpdatedPerUser(uint256 _mintingLimitOld, uint256 _mintingLimitNew);\n    event MintingLimitUpdatedDaily(uint256 _mintingLimitOld, uint256 _mintingLimitNew);\n    event TimeLockPeriodUpdated(uint256 _timeLockPeriodOld, uint256 _timeLockPeriodNew);\n    event TradeEngineAddressSet(address _tradeEngineAddress);\n    event DailyMintedTokensReset();\n\n    modifier onlyTradeEngine() {\n        require(msg.sender == tradeEngineAddress, \"MorpherMintingLimiter: Only Trade Engine is allowed to call this function\");\n        _;\n    }\n\n    modifier onlyAdministrator() {\n        require(msg.sender == state.getAdministrator(), \"MorpherMintingLimiter: Only Administrator can call this function\");\n        _;\n    }\n\n    constructor(address _stateAddress, uint256 _mintingLimitPerUser, uint256 _mintingLimitDaily, uint256 _timeLockingPeriodInSeconds) public {\n        state = MorpherState(_stateAddress);\n        mintingLimitPerUser = _mintingLimitPerUser;\n        mintingLimitDaily = _mintingLimitDaily;\n        timeLockingPeriod = _timeLockingPeriodInSeconds;\n    }\n\n    function setTradeEngineAddress(address _tradeEngineAddress) public onlyAdministrator {\n        emit TradeEngineAddressSet(_tradeEngineAddress);\n        tradeEngineAddress = _tradeEngineAddress;\n    }\n    \n\n    function setMintingLimitDaily(uint256 _newMintingLimit) public onlyAdministrator {\n        emit MintingLimitUpdatedDaily(mintingLimitDaily, _newMintingLimit);\n        mintingLimitDaily = _newMintingLimit;\n    }\n    function setMintingLimitPerUser(uint256 _newMintingLimit) public onlyAdministrator {\n        emit MintingLimitUpdatedPerUser(mintingLimitDaily, _newMintingLimit);\n        mintingLimitPerUser = _newMintingLimit;\n    }\n\n    function setTimeLockingPeriod(uint256 _newTimeLockingPeriodInSeconds) public onlyAdministrator {\n        emit TimeLockPeriodUpdated(timeLockingPeriod, _newTimeLockingPeriodInSeconds);\n        timeLockingPeriod = _newTimeLockingPeriodInSeconds;\n    }\n\n    function mint(address _user, uint256 _tokenAmount) public onlyTradeEngine {\n        uint256 mintingDay = block.timestamp / 1 days;\n        if((mintingLimitDaily == 0 || dailyMintedTokens[mintingDay].add(_tokenAmount) \u003c= mintingLimitDaily) \u0026\u0026 (mintingLimitPerUser == 0 || _tokenAmount \u003c= mintingLimitPerUser )) {\n            state.mint(_user, _tokenAmount);\n            dailyMintedTokens[mintingDay] = dailyMintedTokens[mintingDay].add(_tokenAmount);\n        } else {\n            escrowedTokens[_user] = escrowedTokens[_user].add(_tokenAmount);\n            lockedUntil[_user] = block.timestamp + timeLockingPeriod;\n            emit MintingEscrowed(_user, _tokenAmount);\n        }\n    }\n\n    function delayedMint(address _user) public {\n        require(lockedUntil[_user] \u003c= block.timestamp, \"MorpherMintingLimiter: Funds are still time locked\");\n        uint256 sendAmount = escrowedTokens[_user];\n        escrowedTokens[_user] = 0;\n        state.mint(_user, sendAmount);\n        emit EscrowReleased(_user, sendAmount);\n    }\n\n    function adminApprovedMint(address _user, uint256 _tokenAmount) public onlyAdministrator {\n        escrowedTokens[_user] = escrowedTokens[_user].sub(_tokenAmount);\n        state.mint(_user, _tokenAmount);\n        emit EscrowReleased(_user, _tokenAmount);\n    }\n\n    function adminDisapproveMint(address _user, uint256 _tokenAmount) public onlyAdministrator {\n        escrowedTokens[_user] = escrowedTokens[_user].sub(_tokenAmount);\n        emit MintingDenied(_user, _tokenAmount);\n    }\n\n    function resetDailyMintedTokens() public onlyAdministrator {\n        dailyMintedTokens[block.timestamp / 1 days] = 0;\n        emit DailyMintedTokensReset();\n    }\n\n    function getDailyMintedTokens() public view returns(uint256) {\n        return dailyMintedTokens[block.timestamp / 1 days];\n    }\n}"},"MorpherOracle.sol":{"content":"pragma solidity 0.5.16;\n\nimport \"./Ownable.sol\";\nimport \"./MorpherTradeEngine.sol\";\nimport \"./MorpherState.sol\";\nimport \"./SafeMath.sol\";\n\n// ----------------------------------------------------------------------------------\n// Morpher Oracle contract v 2.0\n// The oracle initates a new trade by calling trade engine and requesting a new orderId.\n// An event is fired by the contract notifying the oracle operator to query a price/liquidation unchecked\n// for a market/user and return the information via the callback function. Since calling\n// the callback function requires gas, the user must send a fixed amount of Ether when\n// creating their order.\n// ----------------------------------------------------------------------------------\n\ncontract MorpherOracle is Ownable {\n\n    MorpherTradeEngine tradeEngine;\n    MorpherState state; // read only, Oracle doesn\u0027t need writing access to state\n\n    using SafeMath for uint256;\n\n    bool public paused;\n    bool public useWhiteList; //always false at the moment\n\n    uint256 public gasForCallback;\n\n    address payable public callBackCollectionAddress;\n\n    mapping(address =\u003e bool) public callBackAddress;\n    mapping(address =\u003e bool) public whiteList;\n    \n    mapping(bytes32 =\u003e uint256) public priceBelow;\n    mapping(bytes32 =\u003e uint256) public priceAbove;\n    mapping(bytes32 =\u003e uint256) public goodFrom;\n    mapping(bytes32 =\u003e uint256) public goodUntil;\n\n    mapping(bytes32 =\u003e bool) public orderCancellationRequested;\n\n    mapping(bytes32 =\u003e address) public orderIdTradeEngineAddress;\n    address public previousTradeEngineAddress;\n    address public skipPreviousTradeEngineAddress; //skips a trade engine address, e.g. typos\n    address public previousOracleAddress;\n\n// ----------------------------------------------------------------------------------\n// Events\n// ----------------------------------------------------------------------------------\n    event OrderCreated(\n        bytes32 indexed _orderId,\n        address indexed _address,\n        bytes32 indexed _marketId,\n        uint256 _closeSharesAmount,\n        uint256 _openMPHTokenAmount,\n        bool _tradeDirection,\n        uint256 _orderLeverage,\n        uint256 _onlyIfPriceBelow,\n        uint256 _onlyIfPriceAbove,\n        uint256 _goodFrom,\n        uint256 _goodUntil\n        );\n\n    event LiquidationOrderCreated(\n        bytes32 indexed _orderId,\n        address _sender,\n        address indexed _address,\n        bytes32 indexed _marketId\n\n        );\n\n    event OrderProcessed(\n        bytes32 indexed _orderId,\n        uint256 _price,\n        uint256 _unadjustedMarketPrice,\n        uint256 _spread,\n        uint256 _positionLiquidationTimestamp,\n        uint256 _timeStamp,\n        uint256 _newLongShares,\n        uint256 _newShortShares,\n        uint256 _newMeanEntry,\n        uint256 _newMeanSprad,\n        uint256 _newMeanLeverage,\n        uint256 _liquidationPrice\n        );\n\n    event OrderFailed(\n        bytes32 indexed _orderId,\n        address indexed _address,\n        bytes32 indexed _marketId,\n        uint256 _closeSharesAmount,\n        uint256 _openMPHTokenAmount,\n        bool _tradeDirection,\n        uint256 _orderLeverage,\n        uint256 _onlyIfPriceBelow,\n        uint256 _onlyIfPriceAbove,\n        uint256 _goodFrom,\n        uint256 _goodUntil\n        );\n\n    event OrderCancelled(\n        bytes32 indexed _orderId,\n        address indexed _sender,\n        address indexed _oracleAddress\n        );\n    \n    event AdminOrderCancelled(\n        bytes32 indexed _orderId,\n        address indexed _sender,\n        address indexed _oracleAddress\n        );\n\n    event OrderCancellationRequestedEvent(\n        bytes32 indexed _orderId,\n        address indexed _sender\n        );\n\n    event CallbackAddressEnabled(\n        address indexed _address\n        );\n\n    event CallbackAddressDisabled(\n        address indexed _address\n        );\n\n    event OraclePaused(\n        bool _paused\n        );\n        \n    event CallBackCollectionAddressChange(\n        address _address\n        );\n\n    event SetGasForCallback(\n        uint256 _gasForCallback\n        );\n\n    event LinkTradeEngine(\n        address _address\n        );\n\n    event LinkMorpherState(\n        address _address\n        );\n\n    event SetUseWhiteList(\n        bool _useWhiteList\n        );\n\n    event AddressWhiteListed(\n        address _address\n        );\n\n    event AddressBlackListed(\n        address _address\n        );\n\n    event AdminLiquidationOrderCreated(\n        bytes32 indexed _orderId,\n        address indexed _address,\n        bytes32 indexed _marketId,\n        uint256 _closeSharesAmount,\n        uint256 _openMPHTokenAmount,\n        bool _tradeDirection,\n        uint256 _orderLeverage\n        );\n\n    /**\n     * Delisting markets is a function that stops when gas is running low\n     * if it reached all positions it will emit \"DelistMarketComplete\"\n     * otherwise it needs to be re-run.\n     */\n    event DelistMarketIncomplete(bytes32 _marketId, uint256 _processedUntilIndex);\n    event DelistMarketComplete(bytes32 _marketId);\n    event LockedPriceForClosingPositions(bytes32 _marketId, uint256 _price);\n\n\n    event FallbackOracleUpdated(address _oldFallbackOracle, address _newFallbackOracle);\n    event FallbackTradeEngineUpdated(address _oldFallbackTradeEngine, address _newFallbackTradeEngine);\n    event UpdateSkipPreviousTradeEngineAddress(address _oldAddress, address _newAddress);\n\n    modifier onlyOracleOperator {\n        require(isCallbackAddress(msg.sender), \"MorpherOracle: Only the oracle operator can call this function.\");\n        _;\n    }\n\n    modifier onlyAdministrator {\n        require(msg.sender == state.getAdministrator(), \"Function can only be called by the Administrator.\");\n        _;\n    }\n\n    modifier notPaused {\n        require(paused == false, \"MorpherOracle: Oracle paused, aborting\");\n        _;\n    }\n\n   constructor(address _tradeEngineAddress, address _morpherState, address _callBackAddress, address payable _gasCollectionAddress, uint256 _gasForCallback, address _coldStorageOwnerAddress, address _previousTradeEngineAddress, address _previousOracleAddress) public {\n        setTradeEngineAddress(_tradeEngineAddress);\n        setStateAddress(_morpherState);\n        enableCallbackAddress(_callBackAddress);\n        setCallbackCollectionAddress(_gasCollectionAddress);\n        setGasForCallback(_gasForCallback);\n        transferOwnership(_coldStorageOwnerAddress);\n        previousTradeEngineAddress = _previousTradeEngineAddress; //that is the address before updating the trade engine. Can set to 0x0000 if a completely new deployment happens. It is only valid when mid-term updating the tradeengine\n        previousOracleAddress = _previousOracleAddress; //if we are updating the oracle, then this is the previous oracle address. Can be set to 0x00 if a completely new deployment happens.\n    }\n\n// ----------------------------------------------------------------------------------\n// Setter/getter functions for trade engine address, oracle operator (callback) address,\n// and prepaid gas limit for callback function\n// ----------------------------------------------------------------------------------\n    function setTradeEngineAddress(address _address) public onlyOwner {\n        tradeEngine = MorpherTradeEngine(_address);\n        emit LinkTradeEngine(_address);\n    }\n\n    function setStateAddress(address _address) public onlyOwner {\n        state = MorpherState(_address);\n        emit LinkMorpherState(_address);\n    }\n\n    function overrideGasForCallback(uint256 _gasForCallback) public onlyOwner {\n        gasForCallback = _gasForCallback;\n        emit SetGasForCallback(_gasForCallback);\n    }\n    \n    function setGasForCallback(uint256 _gasForCallback) private {\n        gasForCallback = _gasForCallback;\n        emit SetGasForCallback(_gasForCallback);\n    }\n\n    function enableCallbackAddress(address _address) public onlyOwner {\n        callBackAddress[_address] = true;\n        emit CallbackAddressEnabled(_address);\n    }\n\n    function disableCallbackAddress(address _address) public onlyOwner {\n        callBackAddress[_address] = false;\n        emit CallbackAddressDisabled(_address);\n    }\n\n    function isCallbackAddress(address _address) public view returns (bool _isCallBackAddress) {\n        return callBackAddress[_address];\n    }\n\n    function setCallbackCollectionAddress(address payable _address) public onlyOwner {\n        callBackCollectionAddress = _address;\n        emit CallBackCollectionAddressChange(_address);\n    }\n\n    function getAdministrator() public view returns(address _administrator) {\n        return state.getAdministrator();\n    }\n\n// ----------------------------------------------------------------------------------\n// Oracle Owner can use a whitelist and authorize individual addresses\n// ----------------------------------------------------------------------------------\n    function setUseWhiteList(bool _useWhiteList) public onlyOracleOperator {\n        require(false, \"MorpherOracle: Cannot use this functionality in the oracle at the moment\");\n        useWhiteList = _useWhiteList;\n        emit SetUseWhiteList(_useWhiteList);\n    }\n\n    function setWhiteList(address _whiteList) public onlyOracleOperator {\n        whiteList[_whiteList] = true;\n        emit AddressWhiteListed(_whiteList);\n    }\n\n    function setBlackList(address _blackList) public onlyOracleOperator {\n        whiteList[_blackList] = false;\n        emit AddressBlackListed(_blackList);\n    }\n\n    function isWhiteListed(address _address) public view returns (bool _whiteListed) {\n        if (useWhiteList == false ||  whiteList[_address] == true) {\n            _whiteListed = true;\n        }\n        return(_whiteListed);\n    }\n\n// ----------------------------------------------------------------------------------\n// emitOrderFailed\n// Can be called by Oracle Operator to notifiy user of failed order\n// ----------------------------------------------------------------------------------\n    function emitOrderFailed(\n        bytes32 _orderId,\n        address _address,\n        bytes32 _marketId,\n        uint256 _closeSharesAmount,\n        uint256 _openMPHTokenAmount,\n        bool _tradeDirection,\n        uint256 _orderLeverage,\n        uint256 _onlyIfPriceBelow,\n        uint256 _onlyIfPriceAbove,\n        uint256 _goodFrom,\n        uint256 _goodUntil\n    ) public onlyOracleOperator {\n        emit OrderFailed(\n            _orderId,\n            _address,\n            _marketId,\n            _closeSharesAmount,\n            _openMPHTokenAmount,\n            _tradeDirection,\n            _orderLeverage,\n            _onlyIfPriceBelow,\n            _onlyIfPriceAbove,\n            _goodFrom,\n            _goodUntil);\n    }\n\n// ----------------------------------------------------------------------------------\n// createOrder(bytes32  _marketId, bool _tradeAmountGivenInShares, uint256 _tradeAmount, bool _tradeDirection, uint256 _orderLeverage)\n// Request a new orderId from trade engine and fires event for price/liquidation check request.\n// ----------------------------------------------------------------------------------\n    function createOrder(\n        bytes32 _marketId,\n        uint256 _closeSharesAmount,\n        uint256 _openMPHTokenAmount,\n        bool _tradeDirection,\n        uint256 _orderLeverage,\n        uint256 _onlyIfPriceAbove,\n        uint256 _onlyIfPriceBelow,\n        uint256 _goodUntil,\n        uint256 _goodFrom\n        ) public payable notPaused returns (bytes32 _orderId) {\n        require(isWhiteListed(msg.sender),\"MorpherOracle: Address not eligible to create an order.\");\n        if (gasForCallback \u003e 0) {\n            require(msg.value \u003e= gasForCallback, \"MorpherOracle: Must transfer gas costs for Oracle Callback function.\");\n            callBackCollectionAddress.transfer(msg.value);\n        }\n        _orderId = tradeEngine.requestOrderId(msg.sender, _marketId, _closeSharesAmount, _openMPHTokenAmount, _tradeDirection, _orderLeverage);\n        orderIdTradeEngineAddress[_orderId] = address(tradeEngine);\n\n        //if the market was deactivated, and the trader didn\u0027t fail yet, then we got an orderId to close the position with a locked in price\n        if(state.getMarketActive(_marketId) == false) {\n\n            //price will come from the position where price is stored forever\n            tradeEngine.processOrder(_orderId, tradeEngine.getDeactivatedMarketPrice(_marketId), 0, 0, now.mul(1000));\n            \n            emit OrderProcessed(\n                _orderId,\n                tradeEngine.getDeactivatedMarketPrice(_marketId),\n                0,\n                0,\n                0,\n                now.mul(1000),\n                0,\n                0,\n                0,\n                0,\n                0,\n                0\n                );\n        } else {\n            priceAbove[_orderId] = _onlyIfPriceAbove;\n            priceBelow[_orderId] = _onlyIfPriceBelow;\n            goodFrom[_orderId]   = _goodFrom;\n            goodUntil[_orderId]  = _goodUntil;\n            emit OrderCreated(\n                _orderId,\n                msg.sender,\n                _marketId,\n                _closeSharesAmount,\n                _openMPHTokenAmount,\n                _tradeDirection,\n                _orderLeverage,\n                _onlyIfPriceBelow,\n                _onlyIfPriceAbove,\n                _goodFrom,\n                _goodUntil\n                );\n        }\n\n        return _orderId;\n    }\n\n    function getTradeEngineFromOrderId(bytes32 _orderId) public view returns (address) {\n        //get the current trade engine\n        if(orderIdTradeEngineAddress[_orderId] != address(0)){\n            return orderIdTradeEngineAddress[_orderId];\n        }\n\n        if(previousOracleAddress != address(0)) {\n            MorpherOracle _oracle = MorpherOracle(previousOracleAddress);\n            address _previousTradeEngine = _oracle.getTradeEngineFromOrderId(_orderId);\n            if(_previousTradeEngine != skipPreviousTradeEngineAddress) { //fixing a typo\n                return _previousTradeEngine;\n            }\n        }\n\n        //nothing in there, take the previous tradeEngine then.\n        return previousTradeEngineAddress;\n    }\n\n    function updateSkipTradeEngineAddress(address _skipTradeEngineAddress) public onlyAdministrator {\n        emit UpdateSkipPreviousTradeEngineAddress(skipPreviousTradeEngineAddress, _skipTradeEngineAddress);\n        skipPreviousTradeEngineAddress = _skipTradeEngineAddress;\n    }\n\n\n    function updateFallbackTradeEngineAddress(address _tradeEngineFallbackAddress) public onlyAdministrator {\n        emit FallbackTradeEngineUpdated(previousTradeEngineAddress, _tradeEngineFallbackAddress);\n        previousTradeEngineAddress = _tradeEngineFallbackAddress;\n    }\n\n\n    function updateFallbackOracleAddress(address _oracleFallbackAddress) public onlyAdministrator {\n        emit FallbackOracleUpdated(previousOracleAddress, _oracleFallbackAddress);\n        previousOracleAddress = _oracleFallbackAddress;\n    }\n\n    function initiateCancelOrder(bytes32 _orderId) public {\n        MorpherTradeEngine _tradeEngine = MorpherTradeEngine(getTradeEngineFromOrderId(_orderId));\n        require(orderCancellationRequested[_orderId] == false, \"MorpherOracle: Order was already canceled.\");\n        (address userId, , , , , , ) = _tradeEngine.getOrder(_orderId);\n        require(userId == msg.sender, \"MorpherOracle: Only the user can request an order cancellation.\");\n        orderCancellationRequested[_orderId] = true;\n        emit OrderCancellationRequestedEvent(_orderId, msg.sender);\n\n    }\n    // ----------------------------------------------------------------------------------\n    // cancelOrder(bytes32  _orderId)\n    // User or Administrator can cancel their own orders before the _callback has been executed\n    // ----------------------------------------------------------------------------------\n    function cancelOrder(bytes32 _orderId) public onlyOracleOperator {\n        require(orderCancellationRequested[_orderId] == true, \"MorpherOracle: Order-Cancellation was not requested.\");\n        MorpherTradeEngine _tradeEngine = MorpherTradeEngine(getTradeEngineFromOrderId(_orderId));\n        (address userId, , , , , , ) = _tradeEngine.getOrder(_orderId);\n        _tradeEngine.cancelOrder(_orderId, userId);\n        clearOrderConditions(_orderId);\n        emit OrderCancelled(\n            _orderId,\n            userId,\n            msg.sender\n            );\n    }\n    \n    // ----------------------------------------------------------------------------------\n    // adminCancelOrder(bytes32  _orderId)\n    // Administrator can cancel before the _callback has been executed to provide an updateOrder functionality\n    // ----------------------------------------------------------------------------------\n    function adminCancelOrder(bytes32 _orderId) public onlyOracleOperator {\n        MorpherTradeEngine _tradeEngine = MorpherTradeEngine(getTradeEngineFromOrderId(_orderId));\n        (address userId, , , , , , ) = _tradeEngine.getOrder(_orderId);\n        _tradeEngine.cancelOrder(_orderId, userId);\n        clearOrderConditions(_orderId);\n        emit AdminOrderCancelled(\n            _orderId,\n            userId,\n            msg.sender\n            );\n    }\n\n    function getGoodUntil(bytes32 _orderId) public view returns(uint) {\n        if(goodUntil[_orderId] \u003e 0) {\n            return goodUntil[_orderId];\n        }\n\n        //just return the old one\n        if(previousOracleAddress != address(0)) {\n            MorpherOracle _oldOracle = MorpherOracle(previousOracleAddress);\n            return _oldOracle.goodUntil(_orderId);\n        }\n\n        return 0;\n    }\n    function getGoodFrom(bytes32 _orderId) public view returns(uint) {\n        if(goodFrom[_orderId] \u003e 0) {\n            return goodFrom[_orderId];\n        }\n\n        //just return the old one\n        if(previousOracleAddress != address(0)) {\n            MorpherOracle _oldOracle = MorpherOracle(previousOracleAddress);\n            return _oldOracle.goodFrom(_orderId);\n        }\n        return 0;\n    }\n    function getPriceAbove(bytes32 _orderId) public view returns(uint) {\n        if(priceAbove[_orderId] \u003e 0) {\n            return priceAbove[_orderId];\n        }\n\n        //just return the old one\n        if(previousOracleAddress != address(0)) {\n            MorpherOracle _oldOracle = MorpherOracle(previousOracleAddress);\n            return _oldOracle.priceAbove(_orderId);\n        }\n        return 0;\n    }\n    function getPriceBelow(bytes32 _orderId) public view returns(uint) {\n        if(priceBelow[_orderId] \u003e 0) {\n            return priceBelow[_orderId];\n        }\n\n        //just return the old one\n        if(previousOracleAddress != address(0)) {\n            MorpherOracle _oldOracle = MorpherOracle(previousOracleAddress);\n            return _oldOracle.priceBelow(_orderId);\n        }\n        return 0;\n    }\n\n// ------------------------------------------------------------------------\n// checkOrderConditions(bytes32 _orderId, uint256 _price)\n// Checks if callback satisfies the order conditions\n// ------------------------------------------------------------------------\n    function checkOrderConditions(bytes32 _orderId, uint256 _price) public view returns (bool _conditionsMet) {\n        _conditionsMet = true;\n        if (now \u003e getGoodUntil(_orderId) \u0026\u0026 getGoodUntil(_orderId) \u003e 0) {\n            _conditionsMet = false;\n        }\n        if (now \u003c getGoodFrom(_orderId) \u0026\u0026 getGoodFrom(_orderId) \u003e 0) {\n            _conditionsMet = false;\n        }\n\n        if(getPriceAbove(_orderId) \u003e 0 \u0026\u0026 getPriceBelow(_orderId) \u003e 0) {\n            if(_price \u003c getPriceAbove(_orderId) \u0026\u0026 _price \u003e getPriceBelow(_orderId)) {\n                _conditionsMet = false;\n            }\n        } else {\n            if (_price \u003c getPriceAbove(_orderId) \u0026\u0026 getPriceAbove(_orderId) \u003e 0) {\n                _conditionsMet = false;\n            }\n            if (_price \u003e getPriceBelow(_orderId) \u0026\u0026 getPriceBelow(_orderId) \u003e 0) {\n                _conditionsMet = false;\n            }\n        }\n        \n        return _conditionsMet;\n    }\n\n// ----------------------------------------------------------------------------------\n// Deletes parameters of cancelled or processed orders\n// ----------------------------------------------------------------------------------\n    function clearOrderConditions(bytes32 _orderId) internal {\n        priceAbove[_orderId] = 0;\n        priceBelow[_orderId] = 0;\n        goodFrom[_orderId]   = 0;\n        goodUntil[_orderId]  = 0;\n    }\n\n// ----------------------------------------------------------------------------------\n// Pausing/unpausing the Oracle contract\n// ----------------------------------------------------------------------------------\n    function pauseOracle() public onlyOwner {\n        paused = true;\n        emit OraclePaused(true);\n    }\n\n    function unpauseOracle() public onlyOwner {\n        paused = false;\n        emit OraclePaused(false);\n    }\n\n// ----------------------------------------------------------------------------------\n// createLiquidationOrder(address _address, bytes32 _marketId)\n// Checks if position has been liquidated since last check. Requires gas for callback\n// function. Anyone can issue a liquidation order for any other address and market.\n// ----------------------------------------------------------------------------------\n    function createLiquidationOrder(\n        address _address,\n        bytes32 _marketId\n        ) public notPaused onlyOracleOperator payable returns (bytes32 _orderId) {\n        if (gasForCallback \u003e 0) {\n            require(msg.value \u003e= gasForCallback, \"MorpherOracle: Must transfer gas costs for Oracle Callback function.\");\n            callBackCollectionAddress.transfer(msg.value);\n        }\n        _orderId = tradeEngine.requestOrderId(_address, _marketId, 0, 0, true, 10**8);\n        orderIdTradeEngineAddress[_orderId] = address(tradeEngine);\n        emit LiquidationOrderCreated(_orderId, msg.sender, _address, _marketId);\n        return _orderId;\n    }\n\n// ----------------------------------------------------------------------------------\n// __callback(bytes32 _orderId, uint256 _price, uint256 _spread, uint256 _liquidationTimestamp, uint256 _timeStamp)\n// Called by the oracle operator. Writes price/spread/liquidiation check to the blockchain.\n// Trade engine processes the order and updates the portfolio in state if successful.\n// ----------------------------------------------------------------------------------\n    function __callback(\n        bytes32 _orderId,\n        uint256 _price,\n        uint256 _unadjustedMarketPrice,\n        uint256 _spread,\n        uint256 _liquidationTimestamp,\n        uint256 _timeStamp,\n        uint256 _gasForNextCallback\n        ) public onlyOracleOperator notPaused returns (uint256 _newLongShares, uint256 _newShortShares, uint256 _newMeanEntry, uint256 _newMeanSpread, uint256 _newMeanLeverage, uint256 _liquidationPrice)  {\n        \n        require(checkOrderConditions(_orderId, _price), \u0027MorpherOracle Error: Order Conditions are not met\u0027);\n       \n       MorpherTradeEngine _tradeEngine = MorpherTradeEngine(getTradeEngineFromOrderId(_orderId));\n        (\n            _newLongShares,\n            _newShortShares,\n            _newMeanEntry,\n            _newMeanSpread,\n            _newMeanLeverage,\n            _liquidationPrice\n        ) = _tradeEngine.processOrder(_orderId, _price, _spread, _liquidationTimestamp, _timeStamp);\n        \n        clearOrderConditions(_orderId);\n        emit OrderProcessed(\n            _orderId,\n            _price,\n            _unadjustedMarketPrice,\n            _spread,\n            _liquidationTimestamp,\n            _timeStamp,\n            _newLongShares,\n            _newShortShares,\n            _newMeanEntry,\n            _newMeanSpread,\n            _newMeanLeverage,\n            _liquidationPrice\n            );\n        setGasForCallback(_gasForNextCallback);\n        return (_newLongShares, _newShortShares, _newMeanEntry, _newMeanSpread, _newMeanLeverage, _liquidationPrice);\n    }\n\n// ----------------------------------------------------------------------------------\n// delistMarket(bytes32 _marketId)\n// Administrator closes out all existing positions on _marketId market at current prices\n// ----------------------------------------------------------------------------------\n\n    uint delistMarketFromIx = 0;\n    function delistMarket(bytes32 _marketId, bool _startFromScratch) public onlyAdministrator {\n        require(state.getMarketActive(_marketId) == true, \"Market must be active to process position liquidations.\");\n        // If no _fromIx and _toIx specified, do entire _list\n        if (_startFromScratch) {\n            delistMarketFromIx = 0;\n        }\n        \n        uint _toIx = state.getMaxMappingIndex(_marketId);\n        \n        address _address;\n        for (uint256 i = delistMarketFromIx; i \u003c= _toIx; i++) {\n             if(gasleft() \u003c 250000 \u0026\u0026 i != _toIx) { //stop if there\u0027s not enough gas to write the next transaction\n                delistMarketFromIx = i;\n                emit DelistMarketIncomplete(_marketId, _toIx);\n                return;\n            } \n            \n            _address = state.getExposureMappingAddress(_marketId, i);\n            adminLiquidationOrder(_address, _marketId);\n            \n        }\n        emit DelistMarketComplete(_marketId);\n    }\n\n    /**\n     * Course of action would be:\n     * 1. de-activate market through state\n     * 2. set the Deactivated Market Price\n     * 3. let users still close their positions\n     */\n    function setDeactivatedMarketPrice(bytes32 _marketId, uint256 _price) public onlyAdministrator {\n        //todo updateable tradeEngine\n        tradeEngine.setDeactivatedMarketPrice(_marketId, _price);\n        emit LockedPriceForClosingPositions(_marketId, _price);\n\n    }\n\n// ----------------------------------------------------------------------------------\n// adminLiquidationOrder(address _address, bytes32 _marketId)\n// Administrator closes out an existing position of _address on _marketId market at current price\n// ----------------------------------------------------------------------------------\n    function adminLiquidationOrder(\n        address _address,\n        bytes32 _marketId\n        ) public onlyAdministrator returns (bytes32 _orderId) {\n            uint256 _positionLongShares = state.getLongShares(_address, _marketId);\n            uint256 _positionShortShares = state.getShortShares(_address, _marketId);\n            if (_positionLongShares \u003e 0) {\n                _orderId = tradeEngine.requestOrderId(_address, _marketId, _positionLongShares, 0, false, 10**8);\n                emit AdminLiquidationOrderCreated(_orderId, _address, _marketId, _positionLongShares, 0, false, 10**8);\n            }\n            if (_positionShortShares \u003e 0) {\n                _orderId = tradeEngine.requestOrderId(_address, _marketId, _positionShortShares, 0, true, 10**8);\n                emit AdminLiquidationOrderCreated(_orderId, _address, _marketId, _positionShortShares, 0, true, 10**8);\n            }\n            orderIdTradeEngineAddress[_orderId] = address(tradeEngine);\n            return _orderId;\n    }\n    \n// ----------------------------------------------------------------------------------\n// Auxiliary function to hash a string market name i.e.\n// \"CRYPTO_BTC\" =\u003e 0x0bc89e95f9fdaab7e8a11719155f2fd638cb0f665623f3d12aab71d1a125daf9;\n// ----------------------------------------------------------------------------------\n    function stringToHash(string memory _source) public pure returns (bytes32 _result) {\n        return keccak256(abi.encodePacked(_source));\n    }\n}\n\n"},"MorpherStaking.sol":{"content":"pragma solidity 0.5.16;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IMorpherState.sol\";\n\n// ----------------------------------------------------------------------------------\n// Staking Morpher Token generates interest\n// The interest is set to 0.015% a day or ~5.475% in the first year\n// Stakers will be able to vote on all ProtocolDecisions in MorpherGovernance (soon...)\n// There is a lockup after staking or topping up (30 days) and a minimum stake (100k MPH)\n// ----------------------------------------------------------------------------------\n\ncontract MorpherStaking is Ownable {\n    using SafeMath for uint256;\n    IMorpherState state;\n\n    uint256 constant PRECISION = 10**8;\n    uint256 constant INTERVAL  = 1 days;\n\n    //mapping(address =\u003e uint256) private poolShares;\n    //mapping(address =\u003e uint256) private lockup;\n\n    uint256 public poolShareValue = PRECISION;\n    uint256 public lastReward;\n    uint256 public totalShares;\n    uint256 public interestRate = 15000; // 0.015% per day initially, diminishing returns over time\n    uint256 public lockupPeriod = 30 days; // to prevent tactical staking and ensure smooth governance\n    uint256 public minimumStake = 10**23; // 100k MPH minimum\n\n    address public stakingAdmin;\n\n    address public stakingAddress = 0x2222222222222222222222222222222222222222;\n    bytes32 public marketIdStakingMPH = 0x9a31fdde7a3b1444b1befb10735dcc3b72cbd9dd604d2ff45144352bf0f359a6; //STAKING_MPH\n\n// ----------------------------------------------------------------------------\n// Events\n// ----------------------------------------------------------------------------\n    event SetInterestRate(uint256 newInterestRate);\n    event SetLockupPeriod(uint256 newLockupPeriod);\n    event SetMinimumStake(uint256 newMinimumStake);\n    event LinkState(address stateAddress);\n    event SetStakingAdmin(address stakingAdmin);\n    \n    event PoolShareValueUpdated(uint256 indexed lastReward, uint256 poolShareValue);\n    event StakingRewardsMinted(uint256 indexed lastReward, uint256 delta);\n    event Staked(address indexed userAddress, uint256 indexed amount, uint256 poolShares, uint256 lockedUntil);\n    event Unstaked(address indexed userAddress, uint256 indexed amount, uint256 poolShares);\n    \n    modifier onlyStakingAdmin {\n        require(msg.sender == stakingAdmin, \"MorpherStaking: can only be called by Staking Administrator.\");\n        _;\n    }\n    \n    constructor(address _morpherState, address _stakingAdmin) public {\n        setStakingAdmin(_stakingAdmin);\n        setMorpherStateAddress(_morpherState);\n        emit SetLockupPeriod(lockupPeriod);\n        emit SetMinimumStake(minimumStake);\n        emit SetInterestRate(interestRate);\n        lastReward = now;\n        // missing: transferOwnership to Governance once deployed\n    }\n\n// ----------------------------------------------------------------------------\n// updatePoolShareValue\n// Updates the value of the Pool Shares and returns the new value.\n// Staking rewards are linear, there is no compound interest.\n// ----------------------------------------------------------------------------\n    \n    function updatePoolShareValue() public returns (uint256 _newPoolShareValue) {\n        if (now \u003e= lastReward.add(INTERVAL)) {\n            uint256 _numOfIntervals = now.sub(lastReward).div(INTERVAL);\n            poolShareValue = poolShareValue.add(_numOfIntervals.mul(interestRate));\n            lastReward = lastReward.add(_numOfIntervals.mul(INTERVAL));\n            emit PoolShareValueUpdated(lastReward, poolShareValue);\n        }\n        mintStakingRewards();\n        return poolShareValue;        \n    }\n\n// ----------------------------------------------------------------------------\n// Staking rewards are minted if necessary\n// ----------------------------------------------------------------------------\n\n    function mintStakingRewards() private {\n        uint256 _targetBalance = poolShareValue.mul(totalShares);\n        if (state.balanceOf(stakingAddress) \u003c _targetBalance) {\n            // If there are not enough token held by the contract, mint them\n            uint256 _delta = _targetBalance.sub(state.balanceOf(stakingAddress));\n            state.mint(stakingAddress, _delta);\n            emit StakingRewardsMinted(lastReward, _delta);\n        }\n    }\n\n// ----------------------------------------------------------------------------\n// stake(uint256 _amount)\n// User specifies an amount they intend to stake. Pool Shares are issued accordingly\n// and the _amount is transferred to the staking contract\n// ----------------------------------------------------------------------------\n\n    function stake(uint256 _amount) public returns (uint256 _poolShares) {\n        require(state.balanceOf(msg.sender) \u003e= _amount, \"MorpherStaking: insufficient MPH token balance\");\n        updatePoolShareValue();\n        _poolShares = _amount.div(poolShareValue);\n        (uint256 _numOfShares, , , , , ) = state.getPosition(msg.sender, marketIdStakingMPH);\n        require(minimumStake \u003c= _numOfShares.add(_poolShares).mul(poolShareValue), \"MorpherStaking: stake amount lower than minimum stake\");\n        state.transfer(msg.sender, stakingAddress, _poolShares.mul(poolShareValue));\n        totalShares = totalShares.add(_poolShares);\n        state.setPosition(msg.sender, marketIdStakingMPH, now.add(lockupPeriod), _numOfShares.add(_poolShares), 0, 0, 0, 0, 0);\n        emit Staked(msg.sender, _amount, _poolShares, now.add(lockupPeriod));\n        return _poolShares;\n    }\n\n// ----------------------------------------------------------------------------\n// unstake(uint256 _amount)\n// User specifies number of Pool Shares they want to unstake. \n// Pool Shares get deleted and the user receives their MPH plus interest\n// ----------------------------------------------------------------------------\n\n    function unstake(uint256 _numOfShares) public returns (uint256 _amount) {\n        (uint256 _numOfExistingShares, , , , , ) = state.getPosition(msg.sender, marketIdStakingMPH);\n        require(_numOfShares \u003c= _numOfExistingShares, \"MorpherStaking: insufficient pool shares\");\n\n        uint256 lockedInUntil = state.getLastUpdated(msg.sender, marketIdStakingMPH);\n        require(now \u003e= lockedInUntil, \"MorpherStaking: cannot unstake before lockup expiration\");\n        updatePoolShareValue();\n        state.setPosition(msg.sender, marketIdStakingMPH, lockedInUntil, _numOfExistingShares.sub(_numOfShares), 0, 0, 0, 0, 0);\n        totalShares = totalShares.sub(_numOfShares);\n        _amount = _numOfShares.mul(poolShareValue);\n        state.transfer(stakingAddress, msg.sender, _amount);\n        emit Unstaked(msg.sender, _amount, _numOfShares);\n        return _amount;\n    }\n\n// ----------------------------------------------------------------------------\n// Administrative functions\n// ----------------------------------------------------------------------------\n\n    function setStakingAdmin(address _address) public onlyOwner {\n        stakingAdmin = _address;\n        emit SetStakingAdmin(_address);\n    }\n\n    function setMorpherStateAddress(address _stateAddress) public onlyOwner {\n        state = IMorpherState(_stateAddress);\n        emit LinkState(_stateAddress);\n    }\n\n    function setInterestRate(uint256 _interestRate) public onlyStakingAdmin {\n        interestRate = _interestRate;\n        emit SetInterestRate(_interestRate);\n    }\n\n    function setLockupPeriodRate(uint256 _lockupPeriod) public onlyStakingAdmin {\n        lockupPeriod = _lockupPeriod;\n        emit SetLockupPeriod(_lockupPeriod);\n    }\n    \n    function setMinimumStake(uint256 _minimumStake) public onlyStakingAdmin {\n        minimumStake = _minimumStake;\n        emit SetMinimumStake(_minimumStake);\n    }\n\n// ----------------------------------------------------------------------------\n// Getter functions\n// ----------------------------------------------------------------------------\n\n    function getTotalPooledValue() public view returns (uint256 _totalPooled) {\n        // Only accurate if poolShareValue is up to date\n        return poolShareValue.mul(totalShares);\n    }\n\n    function getStake(address _address) public view returns (uint256 _poolShares) {\n        (uint256 _numOfShares, , , , , ) = state.getPosition(_address, marketIdStakingMPH);\n        return _numOfShares;\n    }\n\n    function getStakeValue(address _address) public view returns(uint256 _value, uint256 _lastUpdate) {\n        // Only accurate if poolShareValue is up to date\n        \n        (uint256 _numOfShares, , , , , ) = state.getPosition(_address, marketIdStakingMPH);\n\n        return (_numOfShares.mul(poolShareValue), lastReward);\n    }\n    \n// ------------------------------------------------------------------------\n// Don\u0027t accept ETH\n// ------------------------------------------------------------------------\n\n    function () external payable {\n        revert(\"MorpherStaking: you can\u0027t deposit Ether here\");\n    }\n}\n"},"MorpherState.sol":{"content":"pragma solidity 0.5.16;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IMorpherToken.sol\";\n\n// ----------------------------------------------------------------------------------\n// Data and token balance storage of the Morpher platform\n// Writing access is only granted to platform contracts. The contract can be paused\n// by an elected platform administrator (see MorpherGovernance) to perform protocol updates.\n// ----------------------------------------------------------------------------------\n\ncontract MorpherState is Ownable {\n    using SafeMath for uint256;\n\n    bool public mainChain;\n    uint256 public totalSupply;\n    uint256 public totalToken;\n    uint256 public totalInPositions;\n    uint256 public totalOnOtherChain;\n    uint256 public maximumLeverage = 10**9; // Leverage precision is 1e8, maximum leverage set to 10 initially\n    uint256 constant PRECISION = 10**8;\n    uint256 constant DECIMALS = 18;\n    uint256 constant REWARDPERIOD = 1 days;\n    bool public paused = false;\n\n    address public morpherGovernance;\n    address public morpherRewards;\n    address public administrator;\n    address public oracleContract;\n    address public sideChainOperator;\n    address public morpherBridge;\n    address public morpherToken;\n\n    uint256 public rewardBasisPoints;\n    uint256 public lastRewardTime;\n\n    bytes32 public sideChainMerkleRoot;\n    uint256 public sideChainMerkleRootWrittenAtTime;\n\n    // Set initial withdraw limit from sidechain to 20m token or 2% of initial supply\n    uint256 public mainChainWithdrawLimit24 = 2 * 10**25;\n\n    mapping(address =\u003e bool) private stateAccess;\n    mapping(address =\u003e bool) private transferAllowed;\n\n    mapping(address =\u003e uint256) private balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) private allowed;\n\n    mapping(bytes32 =\u003e bool) private marketActive;\n\n    // ----------------------------------------------------------------------------\n    // Position struct records virtual futures\n    // ----------------------------------------------------------------------------\n    struct position {\n        uint256 lastUpdated;\n        uint256 longShares;\n        uint256 shortShares;\n        uint256 meanEntryPrice;\n        uint256 meanEntrySpread;\n        uint256 meanEntryLeverage;\n        uint256 liquidationPrice;\n        bytes32 positionHash;\n    }\n\n    // ----------------------------------------------------------------------------\n    // A portfolio is an address specific collection of postions\n    // ----------------------------------------------------------------------------\n    mapping(address =\u003e mapping(bytes32 =\u003e position)) private portfolio;\n\n    // ----------------------------------------------------------------------------\n    // Record all addresses that hold a position of a market, needed for clean stock splits\n    // ----------------------------------------------------------------------------\n    struct hasExposure {\n        uint256 maxMappingIndex;\n        mapping(address =\u003e uint256) index;\n        mapping(uint256 =\u003e address) addy;\n    }\n\n    mapping(bytes32 =\u003e hasExposure) private exposureByMarket;\n\n    // ----------------------------------------------------------------------------\n    // Bridge Variables\n    // ----------------------------------------------------------------------------\n    mapping (address =\u003e uint256) private tokenClaimedOnThisChain;\n    mapping (address =\u003e uint256) private tokenSentToLinkedChain;\n    mapping (address =\u003e uint256) private tokenSentToLinkedChainTime;\n    mapping (bytes32 =\u003e bool) private positionClaimedOnMainChain;\n\n    uint256 public lastWithdrawLimitReductionTime;\n    uint256 public last24HoursAmountWithdrawn;\n    uint256 public withdrawLimit24Hours;\n    uint256 public inactivityPeriod = 3 days;\n    uint256 public transferNonce;\n    bool public fastTransfersEnabled;\n\n    // ----------------------------------------------------------------------------\n    // Sidechain spam protection\n    // ----------------------------------------------------------------------------\n\n    mapping(address =\u003e uint256) private lastRequestBlock;\n    mapping(address =\u003e uint256) private numberOfRequests;\n    uint256 public numberOfRequestsLimit;\n\n    // ----------------------------------------------------------------------------\n    // Events\n    // ----------------------------------------------------------------------------\n    event StateAccessGranted(address indexed whiteList, uint256 indexed blockNumber);\n    event StateAccessDenied(address indexed blackList, uint256 indexed blockNumber);\n\n    event TransfersEnabled(address indexed whiteList);\n    event TransfersDisabled(address indexed blackList);\n\n    event Transfer(address indexed sender, address indexed recipient, uint256 amount);\n    event Mint(address indexed recipient, uint256 amount, uint256 totalToken);\n    event Burn(address indexed recipient, uint256 amount, uint256 totalToken);\n    event NewTotalSupply(uint256 newTotalSupply);\n    event NewTotalOnOtherChain(uint256 newTotalOnOtherChain);\n    event NewTotalInPositions(uint256 newTotalOnOtherChain);\n    event OperatingRewardMinted(address indexed recipient, uint256 amount);\n\n    event RewardsChange(address indexed rewardsAddress, uint256 indexed rewardsBasisPoints);\n    event LastRewardTime(uint256 indexed rewardsTime);\n    event GovernanceChange(address indexed governanceAddress);\n    event TokenChange(address indexed tokenAddress);\n    event AdministratorChange(address indexed administratorAddress);\n    event OracleChange(address indexed oracleContract);\n    event MaximumLeverageChange(uint256 maxLeverage);\n    event MarketActivated(bytes32 indexed activateMarket);\n    event MarketDeActivated(bytes32 indexed deActivateMarket);\n    event BridgeChange(address _bridgeAddress);\n    event SideChainMerkleRootUpdate(bytes32 indexed sideChainMerkleRoot);\n    event NewSideChainOperator(address indexed sideChainOperator);\n    event NumberOfRequestsLimitUpdate(uint256 _numberOfRequests);\n\n    event MainChainWithdrawLimitUpdate(uint256 indexed mainChainWithdrawLimit24);\n    event TokenSentToLinkedChain(address _address, uint256 _token, uint256 _totalTokenSent, bytes32 indexed _tokenSentToLinkedChainHash);\n    event TransferredTokenClaimed(address _address, uint256 _token);\n    event LastWithdrawAt();\n    event RollingWithdrawnAmountUpdated(uint256 _last24HoursAmountWithdrawn, uint256 _lastWithdrawLimitReductionTime);\n    event WithdrawLimitUpdated(uint256 _amount);\n    event InactivityPeriodUpdated(uint256 _periodLength);\n    event FastWithdrawsDisabled();\n    event NewBridgeNonce(uint256 _transferNonce);\n    event Last24HoursAmountWithdrawnReset();\n\n    event StatePaused(address administrator, bool _paused);\n\n    event SetAllowance(address indexed sender, address indexed spender, uint256 tokens);\n    event SetPosition(bytes32 indexed positionHash,\n        address indexed sender,\n        bytes32 indexed marketId,\n        uint256 timeStamp,\n        uint256 longShares,\n        uint256 shortShares,\n        uint256 meanEntryPrice,\n        uint256 meanEntrySpread,\n        uint256 meanEntryLeverage,\n        uint256 liquidationPrice\n    );\n    event SetBalance(address indexed account, uint256 balance, bytes32 indexed balanceHash);\n    event TokenTransferredToOtherChain(address indexed account, uint256 tokenTransferredToOtherChain, bytes32 indexed transferHash);\n\n    modifier notPaused {\n        require(paused == false, \"MorpherState: Contract paused, aborting\");\n        _;\n    }\n\n    modifier onlyPlatform {\n        require(stateAccess[msg.sender] == true, \"MorpherState: Only Platform is allowed to execute operation.\");\n        _;\n    }\n\n    modifier onlyGovernance {\n        require(msg.sender == getGovernance(), \"MorpherState: Calling contract not the Governance Contract. Aborting.\");\n        _;\n    }\n\n    modifier onlyAdministrator {\n        require(msg.sender == getAdministrator(), \"MorpherState: Caller is not the Administrator. Aborting.\");\n        _;\n    }\n\n    modifier onlySideChainOperator {\n        require(msg.sender == sideChainOperator, \"MorpherState: Caller is not the Sidechain Operator. Aborting.\");\n        _;\n    }\n\n    modifier canTransfer {\n        require(getCanTransfer(msg.sender), \"MorpherState: Caller may not transfer token. Aborting.\");\n        _;\n    }\n\n    modifier onlyBridge {\n        require(msg.sender == getMorpherBridge(), \"MorpherState: Caller is not the Bridge. Aborting.\");\n        _;\n    }\n\n    modifier onlyMainChain {\n        require(mainChain == true, \"MorpherState: Can only be called on mainchain.\");\n        _;\n    }\n\n    modifier onlySideChain {\n        require(mainChain == false, \"MorpherState: Can only be called on mainchain.\");\n        _;\n    }\n\n    constructor(bool _mainChain, address _sideChainOperator, address _morpherTreasury) public {\n        // @Deployer: Transfer State Ownership to cold storage address after deploying protocol\n        mainChain = _mainChain; // true for Ethereum, false for Morpher PoA sidechain\n        setLastRewardTime(now);\n        uint256 _sideChainMint = 575000000 * 10**(DECIMALS);\n        uint256 _mainChainMint = 425000000 * 10**(DECIMALS);\n        \n        administrator = owner(); //first set the owner as administrator\n        morpherGovernance = owner(); //first set the owner as governance\n        \n        grantAccess(owner());\n        setSideChainOperator(owner());\n        if (mainChain == false) { // Create token only on sidechain\n            balances[owner()] = _sideChainMint; // Create airdrop and team token on sidechain\n            totalToken = _sideChainMint;\n            emit Mint(owner(), balanceOf(owner()), _sideChainMint);\n            setRewardBasisPoints(0); // Reward is minted on mainchain\n            setRewardAddress(address(0));\n            setTotalOnOtherChain(_mainChainMint);\n        } else {\n            balances[owner()] = _mainChainMint; // Create treasury and investor token on mainchain\n            totalToken = _mainChainMint;\n            emit Mint(owner(), balanceOf(owner()), _mainChainMint);\n            setRewardBasisPoints(15000); // 15000 / PRECISION = 0.00015\n            setRewardAddress(_morpherTreasury);\n            setTotalOnOtherChain(_sideChainMint);\n        }\n        fastTransfersEnabled = true;\n        setNumberOfRequestsLimit(3);\n        setMainChainWithdrawLimit(totalSupply / 50);\n        setSideChainOperator(_sideChainOperator);\n        denyAccess(owner());\n    }\n\n    // ----------------------------------------------------------------------------\n    // Setter/Getter functions for market wise exposure\n    // ----------------------------------------------------------------------------\n\n    function getMaxMappingIndex(bytes32 _marketId) public view returns(uint256 _maxMappingIndex) {\n        return exposureByMarket[_marketId].maxMappingIndex;\n    }\n\n    function getExposureMappingIndex(bytes32 _marketId, address _address) public view returns(uint256 _mappingIndex) {\n        return exposureByMarket[_marketId].index[_address];\n    }\n\n    function getExposureMappingAddress(bytes32 _marketId, uint256 _mappingIndex) public view returns(address _address) {\n        return exposureByMarket[_marketId].addy[_mappingIndex];\n    }\n\n    function setMaxMappingIndex(bytes32 _marketId, uint256 _maxMappingIndex) public onlyPlatform {\n        exposureByMarket[_marketId].maxMappingIndex = _maxMappingIndex;\n    }\n\n    function setExposureMapping(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform  {\n        setExposureMappingIndex(_marketId, _address, _index);\n        setExposureMappingAddress(_marketId, _address, _index);\n    }\n\n    function setExposureMappingIndex(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform {\n        exposureByMarket[_marketId].index[_address] = _index;\n    }\n\n    function setExposureMappingAddress(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform {\n        exposureByMarket[_marketId].addy[_index] = _address;\n    }\n\n    // ----------------------------------------------------------------------------\n    // Setter/Getter functions for bridge variables\n    // ----------------------------------------------------------------------------\n    function setTokenClaimedOnThisChain(address _address, uint256 _token) public onlyBridge {\n        tokenClaimedOnThisChain[_address] = _token;\n        emit TransferredTokenClaimed(_address, _token);\n    }\n\n    function getTokenClaimedOnThisChain(address _address) public view returns (uint256 _token) {\n        return tokenClaimedOnThisChain[_address];\n    }\n\n    function setTokenSentToLinkedChain(address _address, uint256 _token) public onlyBridge {\n        tokenSentToLinkedChain[_address] = _token;\n        tokenSentToLinkedChainTime[_address] = now;\n        emit TokenSentToLinkedChain(_address, _token, tokenSentToLinkedChain[_address], getBalanceHash(_address, tokenSentToLinkedChain[_address]));\n    }\n\n    function getTokenSentToLinkedChain(address _address) public view returns (uint256 _token) {\n        return tokenSentToLinkedChain[_address];\n    }\n\n    function getTokenSentToLinkedChainTime(address _address) public view returns (uint256 _timeStamp) {\n        return tokenSentToLinkedChainTime[_address];\n    }\n\n    function add24HoursWithdrawn(uint256 _amount) public onlyBridge {\n        last24HoursAmountWithdrawn = last24HoursAmountWithdrawn.add(_amount);\n        emit RollingWithdrawnAmountUpdated(last24HoursAmountWithdrawn, lastWithdrawLimitReductionTime);\n    }\n\n    function update24HoursWithdrawLimit(uint256 _amount) public onlyBridge {\n        if (last24HoursAmountWithdrawn \u003e _amount) {\n            last24HoursAmountWithdrawn = last24HoursAmountWithdrawn.sub(_amount);\n        } else {\n            last24HoursAmountWithdrawn = 0;\n        }\n        lastWithdrawLimitReductionTime = now;\n        emit RollingWithdrawnAmountUpdated(last24HoursAmountWithdrawn, lastWithdrawLimitReductionTime);\n    }\n\n    function set24HourWithdrawLimit(uint256 _limit) public onlyBridge {\n        withdrawLimit24Hours = _limit;\n        emit WithdrawLimitUpdated(_limit);\n    }\n\n    function resetLast24HoursAmountWithdrawn() public onlyBridge {\n        last24HoursAmountWithdrawn = 0;\n        emit Last24HoursAmountWithdrawnReset();\n    }\n\n    function setInactivityPeriod(uint256 _periodLength) public onlyBridge {\n        inactivityPeriod = _periodLength;\n        emit InactivityPeriodUpdated(_periodLength);\n    }\n\n    function getBridgeNonce() public onlyBridge returns (uint256 _nonce) {\n        transferNonce++;\n        emit NewBridgeNonce(transferNonce);\n        return transferNonce;\n    }\n\n    function disableFastWithdraws() public onlyBridge {\n        fastTransfersEnabled = false;\n        emit FastWithdrawsDisabled();\n    }\n\n    function setPositionClaimedOnMainChain(bytes32 _positionHash) public onlyBridge {\n        positionClaimedOnMainChain[_positionHash] = true;\n    }\n\n    function getPositionClaimedOnMainChain(bytes32 _positionHash) public view returns (bool _alreadyClaimed) {\n        return positionClaimedOnMainChain[_positionHash];\n    }\n\n    // ----------------------------------------------------------------------------\n    // Setter/Getter functions for spam protection\n    // ----------------------------------------------------------------------------\n\n    function setLastRequestBlock(address _address) public onlyPlatform {\n        lastRequestBlock[_address] = block.number;\n    }\n\n    function getLastRequestBlock(address _address) public view returns(uint256 _lastRequestBlock) {\n        return lastRequestBlock[_address];\n    }\n\n    function setNumberOfRequests(address _address, uint256 _numberOfRequests) public onlyPlatform {\n        numberOfRequests[_address] = _numberOfRequests;\n    }\n\n    function increaseNumberOfRequests(address _address) public onlyPlatform{\n        numberOfRequests[_address]++;\n    }\n\n    function getNumberOfRequests(address _address) public view returns(uint256 _numberOfRequests) {\n        return numberOfRequests[_address];\n    }\n\n    function setNumberOfRequestsLimit(uint256 _numberOfRequestsLimit) public onlyPlatform {\n        numberOfRequestsLimit = _numberOfRequestsLimit;\n        emit NumberOfRequestsLimitUpdate(_numberOfRequestsLimit);\n    }\n\n    function getNumberOfRequestsLimit() public view returns (uint256 _numberOfRequestsLimit) {\n        return numberOfRequestsLimit;\n    }\n\n    function setMainChainWithdrawLimit(uint256 _mainChainWithdrawLimit24) public onlyGovernance {\n        mainChainWithdrawLimit24 = _mainChainWithdrawLimit24;\n        emit MainChainWithdrawLimitUpdate(_mainChainWithdrawLimit24);\n    }\n\n    function getMainChainWithdrawLimit() public view returns (uint256 _mainChainWithdrawLimit24) {\n        return mainChainWithdrawLimit24;\n    }\n\n    // ----------------------------------------------------------------------------\n    // Setter/Getter functions for state access\n    // ----------------------------------------------------------------------------\n\n    function grantAccess(address _address) public onlyAdministrator {\n        stateAccess[_address] = true;\n        emit StateAccessGranted(_address, block.number);\n    }\n\n    function denyAccess(address _address) public onlyAdministrator {\n        stateAccess[_address] = false;\n        emit StateAccessDenied(_address, block.number);\n    }\n\n    function getStateAccess(address _address) public view returns(bool _hasAccess) {\n        return stateAccess[_address];\n    }\n\n    // ----------------------------------------------------------------------------\n    // Setter/Getter functions for addresses that can transfer tokens (sidechain only)\n    // ----------------------------------------------------------------------------\n\n    function enableTransfers(address _address) public onlyAdministrator {\n        transferAllowed[_address] = true;\n        emit TransfersEnabled(_address);\n    }\n\n    function disableTransfers(address _address) public onlyAdministrator {\n        transferAllowed[_address] = false;\n        emit TransfersDisabled(_address);\n    }\n\n    function getCanTransfer(address _address) public view returns(bool _hasAccess) {\n        return mainChain || transferAllowed[_address];\n    }\n\n    // ----------------------------------------------------------------------------\n    // Minting/burning/transfer of token\n    // ----------------------------------------------------------------------------\n\n    function transfer(address _from, address _to, uint256 _token) public onlyPlatform notPaused {\n        require(balances[_from] \u003e= _token, \"MorpherState: Not enough token.\");\n        balances[_from] = balances[_from].sub(_token);\n        balances[_to] = balances[_to].add(_token);\n        IMorpherToken(morpherToken).emitTransfer(_from, _to, _token);\n        emit Transfer(_from, _to, _token);\n        emit SetBalance(_from, balances[_from], getBalanceHash(_from, balances[_from]));\n        emit SetBalance(_to, balances[_to], getBalanceHash(_to, balances[_to]));\n    }\n\n    function mint(address _address, uint256 _token) public onlyPlatform notPaused {\n        balances[_address] = balances[_address].add(_token);\n        totalToken = totalToken.add(_token);\n        updateTotalSupply();\n        IMorpherToken(morpherToken).emitTransfer(address(0), _address, _token);\n        emit Mint(_address, _token, totalToken);\n        emit SetBalance(_address, balances[_address], getBalanceHash(_address, balances[_address]));\n    }\n\n    function burn(address _address, uint256 _token) public onlyPlatform notPaused {\n        require(balances[_address] \u003e= _token, \"MorpherState: Not enough token.\");\n        balances[_address] = balances[_address].sub(_token);\n        totalToken = totalToken.sub(_token);\n        updateTotalSupply();\n        IMorpherToken(morpherToken).emitTransfer(_address, address(0), _token);\n        emit Burn(_address, _token, totalToken);\n        emit SetBalance(_address, balances[_address], getBalanceHash(_address, balances[_address]));\n    }\n\n    // ----------------------------------------------------------------------------\n    // Setter/Getter functions for balance and token functions (ERC20)\n    // ----------------------------------------------------------------------------\n    function updateTotalSupply() private {\n        totalSupply = totalToken.add(totalInPositions).add(totalOnOtherChain);\n        emit NewTotalSupply(totalSupply);\n    }\n\n    function setTotalInPositions(uint256 _totalInPositions) public onlyAdministrator {\n        totalInPositions = _totalInPositions;\n        updateTotalSupply();\n        emit NewTotalInPositions(_totalInPositions);\n    }\n\n    function setTotalOnOtherChain(uint256 _newTotalOnOtherChain) public onlySideChainOperator {\n        totalOnOtherChain = _newTotalOnOtherChain;\n        updateTotalSupply();\n        emit NewTotalOnOtherChain(_newTotalOnOtherChain);\n    }\n\n    function balanceOf(address _tokenOwner) public view returns (uint256 balance) {\n        return balances[_tokenOwner];\n    }\n\n    function setAllowance(address _from, address _spender, uint256 _tokens) public onlyPlatform {\n        allowed[_from][_spender] = _tokens;\n        emit SetAllowance(_from, _spender, _tokens);\n    }\n\n    function getAllowance(address _tokenOwner, address spender) public view returns (uint256 remaining) {\n        return allowed[_tokenOwner][spender];\n    }\n\n    // ----------------------------------------------------------------------------\n    // Setter/Getter functions for platform roles\n    // ----------------------------------------------------------------------------\n\n    function setGovernanceContract(address _newGovernanceContractAddress) public onlyGovernance {\n        morpherGovernance = _newGovernanceContractAddress;\n        emit GovernanceChange(_newGovernanceContractAddress);\n    }\n\n    function getGovernance() public view returns (address _governanceContract) {\n        return morpherGovernance;\n    }\n\n    function setMorpherBridge(address _newBridge) public onlyGovernance {\n        morpherBridge = _newBridge;\n        emit BridgeChange(_newBridge);\n    }\n\n    function getMorpherBridge() public view returns (address _currentBridge) {\n        return morpherBridge;\n    }\n\n    function setOracleContract(address _newOracleContract) public onlyGovernance {\n        oracleContract = _newOracleContract;\n        emit OracleChange(_newOracleContract);\n    }\n\n    function getOracleContract() public view returns(address) {\n        return oracleContract;\n    }\n\n    function setTokenContract(address _newTokenContract) public onlyGovernance {\n        morpherToken = _newTokenContract;\n        emit TokenChange(_newTokenContract);\n    }\n\n    function getTokenContract() public view returns(address) {\n        return morpherToken;\n    }\n\n    function setAdministrator(address _newAdministrator) public onlyGovernance {\n        administrator = _newAdministrator;\n        emit AdministratorChange(_newAdministrator);\n    }\n\n    function getAdministrator() public view returns(address) {\n        return administrator;\n    }\n\n    // ----------------------------------------------------------------------------\n    // Setter/Getter functions for platform operating rewards\n    // ----------------------------------------------------------------------------\n\n    function setRewardAddress(address _newRewardsAddress) public onlyGovernance {\n        morpherRewards = _newRewardsAddress;\n        emit RewardsChange(_newRewardsAddress, rewardBasisPoints);\n    }\n\n    function setRewardBasisPoints(uint256 _newRewardBasisPoints) public onlyGovernance {\n        if (mainChain == true) {\n            require(_newRewardBasisPoints \u003c= 15000, \"MorpherState: Reward basis points need to be less or equal to 15000.\");\n        } else {\n            require(_newRewardBasisPoints == 0, \"MorpherState: Reward basis points can only be set on Ethereum.\");\n        }\n        rewardBasisPoints = _newRewardBasisPoints;\n        emit RewardsChange(morpherRewards, _newRewardBasisPoints);\n    }\n\n    function setLastRewardTime(uint256 _lastRewardTime) private {\n        lastRewardTime = _lastRewardTime;\n        emit LastRewardTime(_lastRewardTime);\n    }\n\n    // ----------------------------------------------------------------------------\n    // Setter/Getter functions for platform administration\n    // ----------------------------------------------------------------------------\n\n    function activateMarket(bytes32 _activateMarket) public onlyAdministrator {\n        marketActive[_activateMarket] = true;\n        emit MarketActivated(_activateMarket);\n    }\n\n    function deActivateMarket(bytes32 _deActivateMarket) public onlyAdministrator {\n        marketActive[_deActivateMarket] = false;\n        emit MarketDeActivated(_deActivateMarket);\n    }\n\n    function getMarketActive(bytes32 _marketId) public view returns(bool _active) {\n        return marketActive[_marketId];\n    }\n\n    function setMaximumLeverage(uint256 _newMaximumLeverage) public onlyAdministrator {\n        require(_newMaximumLeverage \u003e PRECISION, \"MorpherState: Leverage precision is 1e8\");\n        maximumLeverage = _newMaximumLeverage;\n        emit MaximumLeverageChange(_newMaximumLeverage);\n    }\n\n    function getMaximumLeverage() public view returns(uint256 _maxLeverage) {\n        return maximumLeverage;\n    }\n\n    function pauseState() public onlyAdministrator {\n        paused = true;\n        emit StatePaused(msg.sender, true);\n    }\n\n    function unPauseState() public onlyAdministrator {\n        paused = false;\n        emit StatePaused(msg.sender, false);\n    }\n\n    // ----------------------------------------------------------------------------\n    // Setter/Getter for side chain state\n    // ----------------------------------------------------------------------------\n\n    function setSideChainMerkleRoot(bytes32 _sideChainMerkleRoot) public onlyBridge {\n        sideChainMerkleRoot = _sideChainMerkleRoot;\n        sideChainMerkleRootWrittenAtTime = now;\n        payOperatingReward();\n        emit SideChainMerkleRootUpdate(_sideChainMerkleRoot);\n    }\n\n    function getSideChainMerkleRoot() public view returns(bytes32 _sideChainMerkleRoot) {\n        return sideChainMerkleRoot;\n    }\n\n    function setSideChainOperator(address _address) public onlyAdministrator {\n        sideChainOperator = _address;\n        emit NewSideChainOperator(_address);\n    }\n\n    function getSideChainOperator() public view returns (address _address) {\n        return sideChainOperator;\n    }\n\n    function getSideChainMerkleRootWrittenAtTime() public view returns(uint256 _sideChainMerkleRoot) {\n        return sideChainMerkleRootWrittenAtTime;\n    }\n\n    // ----------------------------------------------------------------------------\n    // Setter/Getter functions for portfolio\n    // ----------------------------------------------------------------------------\n\n    function setPosition(\n        address _address,\n        bytes32 _marketId,\n        uint256 _timeStamp,\n        uint256 _longShares,\n        uint256 _shortShares,\n        uint256 _meanEntryPrice,\n        uint256 _meanEntrySpread,\n        uint256 _meanEntryLeverage,\n        uint256 _liquidationPrice\n    ) public onlyPlatform {\n        portfolio[_address][_marketId].lastUpdated = _timeStamp;\n        portfolio[_address][_marketId].longShares = _longShares;\n        portfolio[_address][_marketId].shortShares = _shortShares;\n        portfolio[_address][_marketId].meanEntryPrice = _meanEntryPrice;\n        portfolio[_address][_marketId].meanEntrySpread = _meanEntrySpread;\n        portfolio[_address][_marketId].meanEntryLeverage = _meanEntryLeverage;\n        portfolio[_address][_marketId].liquidationPrice = _liquidationPrice;\n        portfolio[_address][_marketId].positionHash = getPositionHash(\n            _address,\n            _marketId,\n            _timeStamp,\n            _longShares,\n            _shortShares,\n            _meanEntryPrice,\n            _meanEntrySpread,\n            _meanEntryLeverage,\n            _liquidationPrice\n        );\n        if (_longShares \u003e 0 || _shortShares \u003e 0) {\n            addExposureByMarket(_marketId, _address);\n        } else {\n            deleteExposureByMarket(_marketId, _address);\n        }\n        emit SetPosition(\n            portfolio[_address][_marketId].positionHash,\n            _address,\n            _marketId,\n            _timeStamp,\n            _longShares,\n            _shortShares,\n            _meanEntryPrice,\n            _meanEntrySpread,\n            _meanEntryLeverage,\n            _liquidationPrice\n        );\n    }\n\n    function getPosition(\n        address _address,\n        bytes32 _marketId\n    ) public view returns (\n        uint256 _longShares,\n        uint256 _shortShares,\n        uint256 _meanEntryPrice,\n        uint256 _meanEntrySpread,\n        uint256 _meanEntryLeverage,\n        uint256 _liquidationPrice\n    ) {\n        return(\n        portfolio[_address][_marketId].longShares,\n        portfolio[_address][_marketId].shortShares,\n        portfolio[_address][_marketId].meanEntryPrice,\n        portfolio[_address][_marketId].meanEntrySpread,\n        portfolio[_address][_marketId].meanEntryLeverage,\n        portfolio[_address][_marketId].liquidationPrice\n        );\n    }\n\n    function getPositionHash(\n        address _address,\n        bytes32 _marketId,\n        uint256 _timeStamp,\n        uint256 _longShares,\n        uint256 _shortShares,\n        uint256 _meanEntryPrice,\n        uint256 _meanEntrySpread,\n        uint256 _meanEntryLeverage,\n        uint256 _liquidationPrice\n    ) public pure returns (bytes32 _hash) {\n        return keccak256(\n            abi.encodePacked(\n                _address,\n                _marketId,\n                _timeStamp,\n                _longShares,\n                _shortShares,\n                _meanEntryPrice,\n                _meanEntrySpread,\n                _meanEntryLeverage,\n                _liquidationPrice\n            )\n        );\n    }\n\n    function getBalanceHash(address _address, uint256 _balance) public pure returns (bytes32 _hash) {\n        return keccak256(abi.encodePacked(_address, _balance));\n    }\n\n    function getLastUpdated(address _address, bytes32 _marketId) public view returns (uint256 _lastUpdated) {\n        return(portfolio[_address][_marketId].lastUpdated);\n    }\n\n    function getLongShares(address _address, bytes32 _marketId) public view returns (uint256 _longShares) {\n        return(portfolio[_address][_marketId].longShares);\n    }\n\n    function getShortShares(address _address, bytes32 _marketId) public view returns (uint256 _shortShares) {\n        return(portfolio[_address][_marketId].shortShares);\n    }\n\n    function getMeanEntryPrice(address _address, bytes32 _marketId) public view returns (uint256 _meanEntryPrice) {\n        return(portfolio[_address][_marketId].meanEntryPrice);\n    }\n\n    function getMeanEntrySpread(address _address, bytes32 _marketId) public view returns (uint256 _meanEntrySpread) {\n        return(portfolio[_address][_marketId].meanEntrySpread);\n    }\n\n    function getMeanEntryLeverage(address _address, bytes32 _marketId) public view returns (uint256 _meanEntryLeverage) {\n        return(portfolio[_address][_marketId].meanEntryLeverage);\n    }\n\n    function getLiquidationPrice(address _address, bytes32 _marketId) public view returns (uint256 _liquidationPrice) {\n        return(portfolio[_address][_marketId].liquidationPrice);\n    }\n\n    // ----------------------------------------------------------------------------\n    // Record positions by market by address. Needed for exposure aggregations\n    // and spits and dividends.\n    // ----------------------------------------------------------------------------\n    function addExposureByMarket(bytes32 _symbol, address _address) private {\n        // Address must not be already recored\n        uint256 _myExposureIndex = getExposureMappingIndex(_symbol, _address);\n        if (_myExposureIndex == 0) {\n            uint256 _maxMappingIndex = getMaxMappingIndex(_symbol).add(1);\n            setMaxMappingIndex(_symbol, _maxMappingIndex);\n            setExposureMapping(_symbol, _address, _maxMappingIndex);\n        }\n    }\n\n    function deleteExposureByMarket(bytes32 _symbol, address _address) private {\n        // Get my index in mapping\n        uint256 _myExposureIndex = getExposureMappingIndex(_symbol, _address);\n        // Get last element of mapping\n        uint256 _lastIndex = getMaxMappingIndex(_symbol);\n        address _lastAddress = getExposureMappingAddress(_symbol, _lastIndex);\n        // If _myExposureIndex is greater than 0 (i.e. there is an exposure of that address on that market) delete it\n        if (_myExposureIndex \u003e 0) {\n            // If _myExposureIndex is less than _lastIndex overwrite element at _myExposureIndex with element at _lastIndex in\n            // deleted elements position.\n            if (_myExposureIndex \u003c _lastIndex) {\n                setExposureMappingAddress(_symbol, _lastAddress, _myExposureIndex);\n                setExposureMappingIndex(_symbol, _lastAddress, _myExposureIndex);\n            }\n            // Delete _lastIndex and _lastAddress element and reduce maxExposureIndex\n            setExposureMappingAddress(_symbol, address(0), _lastIndex);\n            setExposureMappingIndex(_symbol, _address, 0);\n            // Shouldn\u0027t happen, but check that not empty\n            if (_lastIndex \u003e 0) {\n                setMaxMappingIndex(_symbol, _lastIndex.sub(1));\n            }\n        }\n    }\n\n    // ----------------------------------------------------------------------------\n    // Calculate and send operating reward\n    // Every 24 hours the protocol mints rewardBasisPoints/(PRECISION) percent of the total\n    // supply as reward for the protocol operator. The amount can not exceed 0.015% per\n    // day.\n    // ----------------------------------------------------------------------------\n\n    function payOperatingReward() public onlyMainChain {\n        if (now \u003e lastRewardTime.add(REWARDPERIOD)) {\n            uint256 _reward = totalSupply.mul(rewardBasisPoints).div(PRECISION);\n            setLastRewardTime(lastRewardTime.add(REWARDPERIOD));\n            mint(morpherRewards, _reward);\n            emit OperatingRewardMinted(morpherRewards, _reward);\n        }\n    }\n}\n"},"MorpherToken.sol":{"content":"pragma solidity 0.5.16;\n\nimport \"./IERC20.sol\";\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./MorpherState.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\u0027t required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract MorpherToken is IERC20, Ownable {\n\n    MorpherState state;\n    using SafeMath for uint256;\n\n    string public constant name     = \"Morpher\";\n    string public constant symbol   = \"MPH\";\n    uint8  public constant decimals = 18;\n    \n    modifier onlyState {\n        require(msg.sender == address(state), \"ERC20: caller must be MorpherState contract.\");\n        _;\n    }\n\n    modifier canTransfer {\n        require(state.getCanTransfer(msg.sender), \"ERC20: token transfers disabled on sidechain.\");\n        _;\n    }\n    \n    event LinkState(address _address);\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    constructor(address _stateAddress, address _coldStorageOwnerAddress) public {\n        setMorpherState(_stateAddress);\n        transferOwnership(_coldStorageOwnerAddress);\n    }\n\n    // ------------------------------------------------------------------------\n    // Links Token Contract with State\n    // ------------------------------------------------------------------------\n    function setMorpherState(address _stateAddress) public onlyOwner {\n        state = MorpherState(_stateAddress);\n        emit LinkState(_stateAddress);\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return state.totalSupply();\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address _account) public view returns (uint256) {\n        return state.balanceOf(_account);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     * \n     * Emits a {Transfer} event via emitTransfer called by MorpherState\n     */\n    function transfer(address _recipient, uint256 _amount) public returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n   /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return state.getAllowance(_owner, _spender);\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address _spender, uint256 _amount) public returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `_sender` and `_recipient` cannot be the zero address.\n     * - `_sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `_sender`\u0027s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 amount) public returns (bool) {\n        _transfer(_sender, _recipient, amount);\n        _approve(_sender, msg.sender, state.getAllowance(_sender, msg.sender).sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\n        _approve(msg.sender, _spender, state.getAllowance(msg.sender, _spender).add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\n        _approve(msg.sender, _spender,  state.getAllowance(msg.sender, _spender).sub(_subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Caller destroys `_amount` tokens permanently\n     *\n     * Emits a {Transfer} event to zero address called by MorpherState via emitTransfer.\n     *\n     * Requirements:\n     *\n     * - Caller must have token balance of at least `_amount`\n     * \n     */\n     function burn(uint256 _amount) public returns (bool) {\n        state.burn(msg.sender, _amount);\n        return true;\n    }\n\n    /**\n     * @dev Emits a {Transfer} event\n     *\n     * MorpherState emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - Caller must be MorpherState\n     * \n     */\n     function emitTransfer(address _from, address _to, uint256 _amount) public onlyState {\n        emit Transfer(_from, _to, _amount);\n    }\n\n     /**\n     * @dev Moves tokens `_amount` from `sender` to `_recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event via emitTransfer called by MorpherState\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address.\n     * - `_sender` must have a balance of at least `_amount`.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) canTransfer internal {\n        require(_sender != address(0), \"ERC20: transfer from the zero address\");\n        require(_recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(state.balanceOf(_sender) \u003e= _amount, \"ERC20: transfer amount exceeds balance\");\n        state.transfer(_sender, _recipient, _amount);\n    }\n\n    /**\n     * @dev Sets `_amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\n        state.setAllowance(_owner, _spender, _amount);\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    // ------------------------------------------------------------------------\n    // Don\u0027t accept ETH\n    // ------------------------------------------------------------------------\n    function () external payable {\n        revert(\"ERC20: You can\u0027t deposit Ether here\");\n    }\n}\n"},"MorpherTradeEngine.sol":{"content":"pragma solidity 0.5.16;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./MorpherState.sol\";\nimport \"./IMorpherStaking.sol\";\nimport \"./MorpherMintingLimiter.sol\";\n\n// ----------------------------------------------------------------------------------\n// Tradeengine of the Morpher platform\n// Creates and processes orders, and computes the state change of portfolio.\n// Needs writing/reading access to/from Morpher State. Order objects are stored locally,\n// portfolios are stored in state.\n// ----------------------------------------------------------------------------------\n\ncontract MorpherTradeEngine is Ownable {\n    MorpherState state;\n    IMorpherStaking staking;\n    MorpherMintingLimiter mintingLimiter;\n    using SafeMath for uint256;\n\n// ----------------------------------------------------------------------------\n// Precision of prices and leverage\n// ----------------------------------------------------------------------------\n    uint256 constant PRECISION = 10**8;\n    uint256 public orderNonce;\n    bytes32 public lastOrderId;\n    uint256 public deployedTimeStamp;\n\n    address public escrowOpenOrderAddress = 0x1111111111111111111111111111111111111111;\n    bool public escrowOpenOrderEnabled;\n\n\n    //we\u0027re locking positions in for this price at a market marketId;\n    address public closedMarketPriceLock = 0x0000000000000000000000000000000000000001;\n\n\n// ----------------------------------------------------------------------------\n// Order struct contains all order specific varibles. Variables are completed\n// during processing of trade. State changes are saved in the order struct as\n// well, since local variables would lead to stack to deep errors *sigh*.\n// ----------------------------------------------------------------------------\n    struct order {\n        address userId;\n        bytes32 marketId;\n        uint256 closeSharesAmount;\n        uint256 openMPHTokenAmount;\n        bool tradeDirection; // true = long, false = short\n        uint256 liquidationTimestamp;\n        uint256 marketPrice;\n        uint256 marketSpread;\n        uint256 orderLeverage;\n        uint256 timeStamp;\n        uint256 longSharesOrder;\n        uint256 shortSharesOrder;\n        uint256 balanceDown;\n        uint256 balanceUp;\n        uint256 newLongShares;\n        uint256 newShortShares;\n        uint256 newMeanEntryPrice;\n        uint256 newMeanEntrySpread;\n        uint256 newMeanEntryLeverage;\n        uint256 newLiquidationPrice;\n        uint256 orderEscrowAmount;\n    }\n\n    mapping(bytes32 =\u003e order) private orders;\n\n// ----------------------------------------------------------------------------\n// Events\n// Order created/processed events are fired by MorpherOracle.\n// ----------------------------------------------------------------------------\n\n    event PositionLiquidated(\n        address indexed _address,\n        bytes32 indexed _marketId,\n        bool _longPosition,\n        uint256 _timeStamp,\n        uint256 _marketPrice,\n        uint256 _marketSpread\n    );\n\n    event OrderCancelled(\n        bytes32 indexed _orderId,\n        address indexed _address\n    );\n\n    event OrderIdRequested(\n        bytes32 _orderId,\n        address indexed _address,\n        bytes32 indexed _marketId,\n        uint256 _closeSharesAmount,\n        uint256 _openMPHTokenAmount,\n        bool _tradeDirection,\n        uint256 _orderLeverage\n    );\n\n    event OrderProcessed(\n        bytes32 _orderId,\n        uint256 _marketPrice,\n        uint256 _marketSpread,\n        uint256 _liquidationTimestamp,\n        uint256 _timeStamp,\n        uint256 _newLongShares,\n        uint256 _newShortShares,\n        uint256 _newAverageEntry,\n        uint256 _newAverageSpread,\n        uint256 _newAverageLeverage,\n        uint256 _liquidationPrice\n    );\n\n    event PositionUpdated(\n        address _userId,\n        bytes32 _marketId,\n        uint256 _timeStamp,\n        uint256 _newLongShares,\n        uint256 _newShortShares,\n        uint256 _newMeanEntryPrice,\n        uint256 _newMeanEntrySpread,\n        uint256 _newMeanEntryLeverage,\n        uint256 _newLiquidationPrice,\n        uint256 _mint,\n        uint256 _burn\n    );\n\n    event LinkState(address _address);\n    event LinkStaking(address _stakingAddress);\n    event LinkMintingLimiter(address _mintingLimiterAddress);\n\n    \n    event LockedPriceForClosingPositions(bytes32 _marketId, uint256 _price);\n\n\n    constructor(address _stateAddress, address _coldStorageOwnerAddress, address _stakingContractAddress, bool _escrowOpenOrderEnabled, uint256 _deployedTimestampOverride, address _mintingLimiterAddress) public {\n        setMorpherState(_stateAddress);\n        setMorpherStaking(_stakingContractAddress);\n        setMorpherMintingLimiter(_mintingLimiterAddress);\n        transferOwnership(_coldStorageOwnerAddress);\n        escrowOpenOrderEnabled = _escrowOpenOrderEnabled;\n        deployedTimeStamp = _deployedTimestampOverride \u003e 0 ? _deployedTimestampOverride : block.timestamp;\n    }\n\n    modifier onlyOracle {\n        require(msg.sender == state.getOracleContract(), \"MorpherTradeEngine: function can only be called by Oracle Contract.\");\n        _;\n    }\n\n    modifier onlyAdministrator {\n        require(msg.sender == getAdministrator(), \"MorpherTradeEngine: function can only be called by the Administrator.\");\n        _;\n    }\n\n// ----------------------------------------------------------------------------\n// Administrative functions\n// Set state address, get administrator address\n// ----------------------------------------------------------------------------\n\n    function setMorpherState(address _stateAddress) public onlyOwner {\n        state = MorpherState(_stateAddress);\n        emit LinkState(_stateAddress);\n    }\n\n    function setMorpherStaking(address _stakingAddress) public onlyOwner {\n        staking = IMorpherStaking(_stakingAddress);\n        emit LinkStaking(_stakingAddress);\n    }\n\n    function setMorpherMintingLimiter(address _mintingLimiterAddress) public onlyOwner {\n        mintingLimiter = MorpherMintingLimiter(_mintingLimiterAddress);\n        emit LinkMintingLimiter(_mintingLimiterAddress);\n    }\n\n    function getAdministrator() public view returns(address _administrator) {\n        return state.getAdministrator();\n    }\n\n    function setEscrowOpenOrderEnabled(bool _isEnabled) public onlyOwner {\n        escrowOpenOrderEnabled = _isEnabled;\n    }\n    \n    function paybackEscrow(bytes32 _orderId) private {\n        //pay back the escrow to the user so he has it back on his balance/**\n        if(orders[_orderId].orderEscrowAmount \u003e 0) {\n            //checks effects interaction\n            uint256 paybackAmount = orders[_orderId].orderEscrowAmount;\n            orders[_orderId].orderEscrowAmount = 0;\n            state.transfer(escrowOpenOrderAddress, orders[_orderId].userId, paybackAmount);\n        }\n    }\n\n    function buildupEscrow(bytes32 _orderId, uint256 _amountInMPH) private {\n        if(escrowOpenOrderEnabled \u0026\u0026 _amountInMPH \u003e 0) {\n            state.transfer(orders[_orderId].userId, escrowOpenOrderAddress, _amountInMPH);\n            orders[_orderId].orderEscrowAmount = _amountInMPH;\n        }\n    }\n\n\n    function validateClosedMarketOrderConditions(address _address, bytes32 _marketId, uint256 _closeSharesAmount, uint256 _openMPHTokenAmount, bool _tradeDirection ) internal view {\n        //markets active? Still tradeable?\n        if(_openMPHTokenAmount \u003e 0) {\n            require(state.getMarketActive(_marketId) == true, \"MorpherTradeEngine: market unknown or currently not enabled for trading.\");\n        } else {\n            //we\u0027re just closing a position, but it needs a forever price locked in if market is not active\n            //the user needs to close his complete position\n            if(state.getMarketActive(_marketId) == false) {\n                require(getDeactivatedMarketPrice(_marketId) \u003e 0, \"MorpherTradeEngine: Can\u0027t close a position, market not active and closing price not locked\");\n                if(_tradeDirection) {\n                    //long\n                    require(_closeSharesAmount == state.getShortShares(_address, _marketId), \"MorpherTradeEngine: Deactivated market order needs all shares to be closed\");\n                } else {\n                    //short\n                    require(_closeSharesAmount == state.getLongShares(_address, _marketId), \"MorpherTradeEngine: Deactivated market order needs all shares to be closed\");\n                }\n            }\n        }\n    }\n\n    //wrapper for stack too deep errors\n    function validateClosedMarketOrder(bytes32 _orderId) internal view {\n         validateClosedMarketOrderConditions(orders[_orderId].userId, orders[_orderId].marketId, orders[_orderId].closeSharesAmount, orders[_orderId].openMPHTokenAmount, orders[_orderId].tradeDirection);\n    }\n\n// ----------------------------------------------------------------------------\n// requestOrderId(address _address, bytes32 _marketId, bool _closeSharesAmount, uint256 _openMPHTokenAmount, bool _tradeDirection, uint256 _orderLeverage)\n// Creates a new order object with unique orderId and assigns order information.\n// Must be called by MorpherOracle contract.\n// ----------------------------------------------------------------------------\n\n    function requestOrderId(\n        address _address,\n        bytes32 _marketId,\n        uint256 _closeSharesAmount,\n        uint256 _openMPHTokenAmount,\n        bool _tradeDirection,\n        uint256 _orderLeverage\n        ) public onlyOracle returns (bytes32 _orderId) {\n            \n        require(_orderLeverage \u003e= PRECISION, \"MorpherTradeEngine: leverage too small. Leverage precision is 1e8\");\n        require(_orderLeverage \u003c= state.getMaximumLeverage(), \"MorpherTradeEngine: leverage exceeds maximum allowed leverage.\");\n\n        validateClosedMarketOrderConditions(_address, _marketId, _closeSharesAmount, _openMPHTokenAmount, _tradeDirection);\n\n        //request limits\n        require(state.getNumberOfRequests(_address) \u003c= state.getNumberOfRequestsLimit() ||\n            state.getLastRequestBlock(_address) \u003c block.number,\n            \"MorpherTradeEngine: request exceeded maximum permitted requests per block.\"\n        );\n\n        /**\n         * The user can\u0027t partially close a position and open another one with MPH\n         */\n        if(_openMPHTokenAmount \u003e 0) {\n            if(_tradeDirection) {\n                //long\n                require(_closeSharesAmount == state.getShortShares(_address, _marketId), \"MorpherTradeEngine: Can\u0027t partially close a position and open another one in opposite direction\");\n            } else {\n                //short\n                require(_closeSharesAmount == state.getLongShares(_address, _marketId), \"MorpherTradeEngine: Can\u0027t partially close a position and open another one in opposite direction\");\n            }\n        }\n\n        state.setLastRequestBlock(_address);\n        state.increaseNumberOfRequests(_address);\n        orderNonce++;\n        _orderId = keccak256(\n            abi.encodePacked(\n                _address,\n                block.number,\n                _marketId,\n                _closeSharesAmount,\n                _openMPHTokenAmount,\n                _tradeDirection,\n                _orderLeverage,\n                orderNonce\n                )\n            );\n        lastOrderId = _orderId;\n        orders[_orderId].userId = _address;\n        orders[_orderId].marketId = _marketId;\n        orders[_orderId].closeSharesAmount = _closeSharesAmount;\n        orders[_orderId].openMPHTokenAmount = _openMPHTokenAmount;\n        orders[_orderId].tradeDirection = _tradeDirection;\n        orders[_orderId].orderLeverage = _orderLeverage;\n        emit OrderIdRequested(\n            _orderId,\n            _address,\n            _marketId,\n            _closeSharesAmount,\n            _openMPHTokenAmount,\n            _tradeDirection,\n            _orderLeverage\n        );\n\n        /**\n         * put the money in escrow here if given MPH to open an order\n         * - also, can only close positions if in shares, so it will\n         * definitely trigger a mint there.\n         * The money must be put in escrow even though we have an existing position\n         */\n        buildupEscrow(_orderId, _openMPHTokenAmount);\n\n        return _orderId;\n    }\n\n// ----------------------------------------------------------------------------\n// Getter functions for orders, shares, and positions\n// ----------------------------------------------------------------------------\n\n    function getOrder(bytes32 _orderId) public view returns (\n        address _userId,\n        bytes32 _marketId,\n        uint256 _closeSharesAmount,\n        uint256 _openMPHTokenAmount,\n        uint256 _marketPrice,\n        uint256 _marketSpread,\n        uint256 _orderLeverage\n        ) {\n        return(\n            orders[_orderId].userId,\n            orders[_orderId].marketId,\n            orders[_orderId].closeSharesAmount,\n            orders[_orderId].openMPHTokenAmount,\n            orders[_orderId].marketPrice,\n            orders[_orderId].marketSpread,\n            orders[_orderId].orderLeverage\n            );\n    }\n\n    function getPosition(address _address, bytes32 _marketId) public view returns (\n        uint256 _positionLongShares,\n        uint256 _positionShortShares,\n        uint256 _positionAveragePrice,\n        uint256 _positionAverageSpread,\n        uint256 _positionAverageLeverage,\n        uint256 _liquidationPrice\n        ) {\n        return(\n            state.getLongShares(_address, _marketId),\n            state.getShortShares(_address, _marketId),\n            state.getMeanEntryPrice(_address,_marketId),\n            state.getMeanEntrySpread(_address,_marketId),\n            state.getMeanEntryLeverage(_address,_marketId),\n            state.getLiquidationPrice(_address,_marketId)\n        );\n    }\n\n    function setDeactivatedMarketPrice(bytes32 _marketId, uint256 _price) public onlyOracle {\n         state.setPosition(\n            closedMarketPriceLock,\n            _marketId,\n            now.mul(1000),\n            0,\n            0,\n            _price,\n            0,\n            0,\n            0\n        );\n\n        emit LockedPriceForClosingPositions(_marketId, _price);\n\n    }\n\n    function getDeactivatedMarketPrice(bytes32 _marketId) public view returns(uint256) {\n        ( , , uint positionForeverClosingPrice, , ,) = state.getPosition(closedMarketPriceLock, _marketId);\n        return positionForeverClosingPrice;\n    }\n\n// ----------------------------------------------------------------------------\n// liquidate(bytes32 _orderId)\n// Checks for bankruptcy of position between its last update and now\n// Time check is necessary to avoid two consecutive / unorderded liquidations\n// ----------------------------------------------------------------------------\n\n    function liquidate(bytes32 _orderId) private {\n        address _address = orders[_orderId].userId;\n        bytes32 _marketId = orders[_orderId].marketId;\n        uint256 _liquidationTimestamp = orders[_orderId].liquidationTimestamp;\n        if (_liquidationTimestamp \u003e state.getLastUpdated(_address, _marketId)) {\n            if (state.getLongShares(_address,_marketId) \u003e 0) {\n                state.setPosition(\n                    _address,\n                    _marketId,\n                    orders[_orderId].timeStamp,\n                    0,\n                    state.getShortShares(_address, _marketId),\n                    0,\n                    0,\n                    PRECISION,\n                    0);\n                emit PositionLiquidated(\n                    _address,\n                    _marketId,\n                    true,\n                    orders[_orderId].timeStamp,\n                    orders[_orderId].marketPrice,\n                    orders[_orderId].marketSpread\n                );\n            }\n            if (state.getShortShares(_address,_marketId) \u003e 0) {\n                state.setPosition(\n                    _address,\n                    _marketId,\n                    orders[_orderId].timeStamp,\n                    state.getLongShares(_address, _marketId),\n                    0,\n                    0,\n                    0,\n                    PRECISION,\n                    0\n                );\n                emit PositionLiquidated(\n                    _address,\n                    _marketId,\n                    false,\n                    orders[_orderId].timeStamp,\n                    orders[_orderId].marketPrice,\n                    orders[_orderId].marketSpread\n                );\n            }\n        }\n    }\n\n// ----------------------------------------------------------------------------\n// processOrder(bytes32 _orderId, uint256 _marketPrice, uint256 _marketSpread, uint256 _liquidationTimestamp, uint256 _timeStamp)\n// ProcessOrder receives the price/spread/liqidation information from the Oracle and\n// triggers the processing of the order. If successful, processOrder updates the portfolio state.\n// Liquidation time check is necessary to avoid two consecutive / unorderded liquidations\n// ----------------------------------------------------------------------------\n\n    function processOrder(\n        bytes32 _orderId,\n        uint256 _marketPrice,\n        uint256 _marketSpread,\n        uint256 _liquidationTimestamp,\n        uint256 _timeStampInMS\n        ) public onlyOracle returns (\n            uint256 _newLongShares,\n            uint256 _newShortShares,\n            uint256 _newAverageEntry,\n            uint256 _newAverageSpread,\n            uint256 _newAverageLeverage,\n            uint256 _liquidationPrice\n        ) {\n        require(orders[_orderId].userId != address(0), \"MorpherTradeEngine: unable to process, order has been deleted.\");\n        require(_marketPrice \u003e 0, \"MorpherTradeEngine: market priced at zero. Buy order cannot be processed.\");\n        require(_marketPrice \u003e= _marketSpread, \"MorpherTradeEngine: market price lower then market spread. Order cannot be processed.\");\n        \n        orders[_orderId].marketPrice = _marketPrice;\n        orders[_orderId].marketSpread = _marketSpread;\n        orders[_orderId].timeStamp = _timeStampInMS;\n        orders[_orderId].liquidationTimestamp = _liquidationTimestamp;\n        \n        /**\n        * If the market is deactivated, then override the price with the locked in market price\n        * if the price wasn\u0027t locked in: error out.\n        */\n        if(state.getMarketActive(orders[_orderId].marketId) == false) {\n            validateClosedMarketOrder(_orderId);\n            orders[_orderId].marketPrice = getDeactivatedMarketPrice(orders[_orderId].marketId);\n        }\n        \n        // Check if previous position on that market was liquidated\n        if (_liquidationTimestamp \u003e state.getLastUpdated(orders[_orderId].userId, orders[_orderId].marketId)) {\n            liquidate(_orderId);\n        }\n    \n\n        paybackEscrow(_orderId);\n\n        if (orders[_orderId].tradeDirection) {\n            processBuyOrder(_orderId);\n        } else {\n            processSellOrder(_orderId);\n        }\n\n        address _address = orders[_orderId].userId;\n        bytes32 _marketId = orders[_orderId].marketId;\n        delete orders[_orderId];\n        emit OrderProcessed(\n            _orderId,\n            _marketPrice,\n            _marketSpread,\n            _liquidationTimestamp,\n            _timeStampInMS,\n            _newLongShares,\n            _newShortShares,\n            _newAverageEntry,\n            _newAverageSpread,\n            _newAverageLeverage,\n            _liquidationPrice\n        );\n\n        return (\n            state.getLongShares(_address, _marketId),\n            state.getShortShares(_address, _marketId),\n            state.getMeanEntryPrice(_address,_marketId),\n            state.getMeanEntrySpread(_address,_marketId),\n            state.getMeanEntryLeverage(_address,_marketId),\n            state.getLiquidationPrice(_address,_marketId)\n        );\n    }\n\n// ----------------------------------------------------------------------------\n// function cancelOrder(bytes32 _orderId, address _address)\n// Users or Administrator can delete pending orders before the callback went through\n// ----------------------------------------------------------------------------\n    function cancelOrder(bytes32 _orderId, address _address) public onlyOracle {\n        require(_address == orders[_orderId].userId || _address == getAdministrator(), \"MorpherTradeEngine: only Administrator or user can cancel an order.\");\n        require(orders[_orderId].userId != address(0), \"MorpherTradeEngine: unable to process, order does not exist.\");\n\n        /**\n         * Pay back any escrow there\n         */\n        paybackEscrow(_orderId);\n\n        delete orders[_orderId];\n        emit OrderCancelled(_orderId, _address);\n    }\n\n// ----------------------------------------------------------------------------\n// shortShareValue / longShareValue compute the value of a virtual future\n// given current price/spread/leverage of the market and mean price/spread/leverage\n// at the beginning of the trade\n// ----------------------------------------------------------------------------\n    function shortShareValue(\n        uint256 _positionAveragePrice,\n        uint256 _positionAverageLeverage,\n        uint256 _positionTimeStampInMs,\n        uint256 _marketPrice,\n        uint256 _marketSpread,\n        uint256 _orderLeverage,\n        bool _sell\n        ) public view returns (uint256 _shareValue) {\n\n        uint256 _averagePrice = _positionAveragePrice;\n        uint256 _averageLeverage = _positionAverageLeverage;\n\n        if (_positionAverageLeverage \u003c PRECISION) {\n            // Leverage can never be less than 1. Fail safe for empty positions, i.e. undefined _positionAverageLeverage\n            _averageLeverage = PRECISION;\n        }\n        if (_sell == false) {\n            // New short position\n            // It costs marketPrice + marketSpread to build up a new short position\n            _averagePrice = _marketPrice;\n\t        // This is the average Leverage\n\t        _averageLeverage = _orderLeverage;\n        }\n        if (\n            getLiquidationPrice(_averagePrice, _averageLeverage, false, _positionTimeStampInMs) \u003c= _marketPrice\n            ) {\n\t        // Position is worthless\n            _shareValue = 0;\n        } else {\n            // The regular share value is 2x the entry price minus the current price for short positions.\n            _shareValue = _averagePrice.mul((PRECISION.add(_averageLeverage))).div(PRECISION);\n            _shareValue = _shareValue.sub(_marketPrice.mul(_averageLeverage).div(PRECISION));\n            if (_sell == true) {\n                // We have to reduce the share value by the average spread (i.e. the average expense to build up the position)\n                // and reduce the value further by the spread for selling.\n                _shareValue = _shareValue.sub(_marketSpread.mul(_averageLeverage).div(PRECISION));\n                uint256 _marginInterest = calculateMarginInterest(_averagePrice, _averageLeverage, _positionTimeStampInMs);\n                if (_marginInterest \u003c= _shareValue) {\n                    _shareValue = _shareValue.sub(_marginInterest);\n                } else {\n                    _shareValue = 0;\n                }\n            } else {\n                // If a new short position is built up each share costs value + spread\n                _shareValue = _shareValue.add(_marketSpread.mul(_orderLeverage).div(PRECISION));\n            }\n        }\n      \n        return _shareValue;\n    }\n\n    function longShareValue(\n        uint256 _positionAveragePrice,\n        uint256 _positionAverageLeverage,\n        uint256 _positionTimeStampInMs,\n        uint256 _marketPrice,\n        uint256 _marketSpread,\n        uint256 _orderLeverage,\n        bool _sell\n        ) public view returns (uint256 _shareValue) {\n\n        uint256 _averagePrice = _positionAveragePrice;\n        uint256 _averageLeverage = _positionAverageLeverage;\n\n        if (_positionAverageLeverage \u003c PRECISION) {\n            // Leverage can never be less than 1. Fail safe for empty positions, i.e. undefined _positionAverageLeverage\n            _averageLeverage = PRECISION;\n        }\n        if (_sell == false) {\n            // New long position\n            // It costs marketPrice + marketSpread to build up a new long position\n            _averagePrice = _marketPrice;\n\t        // This is the average Leverage\n\t        _averageLeverage = _orderLeverage;\n        }\n        if (\n            _marketPrice \u003c= getLiquidationPrice(_averagePrice, _averageLeverage, true, _positionTimeStampInMs)\n            ) {\n\t        // Position is worthless\n            _shareValue = 0;\n        } else {\n            _shareValue = _averagePrice.mul(_averageLeverage.sub(PRECISION)).div(PRECISION);\n            // The regular share value is market price times leverage minus entry price times entry leverage minus one.\n            _shareValue = (_marketPrice.mul(_averageLeverage).div(PRECISION)).sub(_shareValue);\n            if (_sell == true) {\n                // We sell a long and have to correct the shareValue with the averageSpread and the currentSpread for selling.\n                _shareValue = _shareValue.sub(_marketSpread.mul(_averageLeverage).div(PRECISION));\n                \n                uint256 _marginInterest = calculateMarginInterest(_averagePrice, _averageLeverage, _positionTimeStampInMs);\n                if (_marginInterest \u003c= _shareValue) {\n                    _shareValue = _shareValue.sub(_marginInterest);\n                } else {\n                    _shareValue = 0;\n                }\n            } else {\n                // We buy a new long position and have to pay the spread\n                _shareValue = _shareValue.add(_marketSpread.mul(_orderLeverage).div(PRECISION));\n            }\n        }\n        return _shareValue;\n    }\n\n// ----------------------------------------------------------------------------\n// calculateMarginInterest(uint256 _averagePrice, uint256 _averageLeverage, uint256 _positionTimeStamp)\n// Calculates the interest for leveraged positions\n// ----------------------------------------------------------------------------\n\n\n    function calculateMarginInterest(uint256 _averagePrice, uint256 _averageLeverage, uint256 _positionTimeStampInMs) public view returns (uint256 _marginInterest) {\n        if (_positionTimeStampInMs.div(1000) \u003c deployedTimeStamp) {\n            _positionTimeStampInMs = deployedTimeStamp.mul(1000);\n        }\n        _marginInterest = _averagePrice.mul(_averageLeverage.sub(PRECISION));\n        _marginInterest = _marginInterest.mul((now.sub(_positionTimeStampInMs.div(1000)).div(86400)).add(1));\n        _marginInterest = _marginInterest.mul(staking.interestRate()).div(PRECISION).div(PRECISION);\n        return _marginInterest;\n    }\n\n// ----------------------------------------------------------------------------\n// processBuyOrder(bytes32 _orderId)\n// Converts orders specified in virtual shares to orders specified in Morpher token\n// and computes the number of short shares that are sold and long shares that are bought.\n// long shares are bought only if the order amount exceeds all open short positions\n// ----------------------------------------------------------------------------\n\n    function processBuyOrder(bytes32 _orderId) private {\n        if (orders[_orderId].closeSharesAmount \u003e 0) {\n            //calcualte the balanceUp/down first\n            //then reopen the position with MPH amount\n\n             // Investment was specified in shares\n            if (orders[_orderId].closeSharesAmount \u003c= state.getShortShares(orders[_orderId].userId, orders[_orderId].marketId)) {\n                // Partial closing of short position\n                orders[_orderId].shortSharesOrder = orders[_orderId].closeSharesAmount;\n            } else {\n                // Closing of entire short position\n                orders[_orderId].shortSharesOrder = state.getShortShares(orders[_orderId].userId, orders[_orderId].marketId);\n            }\n        }\n\n        //calculate the long shares, but only if the old position is completely closed out (if none exist shortSharesOrder = 0)\n        if(\n            orders[_orderId].shortSharesOrder == state.getShortShares(orders[_orderId].userId, orders[_orderId].marketId) \u0026\u0026 \n            orders[_orderId].openMPHTokenAmount \u003e 0\n        ) {\n            orders[_orderId].longSharesOrder = orders[_orderId].openMPHTokenAmount.div(\n                longShareValue(\n                    orders[_orderId].marketPrice,\n                    orders[_orderId].orderLeverage,\n                    now.mul(1000),\n                    orders[_orderId].marketPrice,\n                    orders[_orderId].marketSpread,\n                    orders[_orderId].orderLeverage,\n                    false\n            ));\n        }\n\n        // Investment equals number of shares now.\n        if (orders[_orderId].shortSharesOrder \u003e 0) {\n            closeShort(_orderId);\n        }\n        if (orders[_orderId].longSharesOrder \u003e 0) {\n            openLong(_orderId);\n        }\n    }\n\n// ----------------------------------------------------------------------------\n// processSellOrder(bytes32 _orderId)\n// Converts orders specified in virtual shares to orders specified in Morpher token\n// and computes the number of long shares that are sold and short shares that are bought.\n// short shares are bought only if the order amount exceeds all open long positions\n// ----------------------------------------------------------------------------\n\n    function processSellOrder(bytes32 _orderId) private {\n        if (orders[_orderId].closeSharesAmount \u003e 0) {\n            //calcualte the balanceUp/down first\n            //then reopen the position with MPH amount\n\n            // Investment was specified in shares\n            if (orders[_orderId].closeSharesAmount \u003c= state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId)) {\n                // Partial closing of long position\n                orders[_orderId].longSharesOrder = orders[_orderId].closeSharesAmount;\n            } else {\n                // Closing of entire long position\n                orders[_orderId].longSharesOrder = state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId);\n            }\n        }\n\n        if(\n            orders[_orderId].longSharesOrder == state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId) \u0026\u0026 \n            orders[_orderId].openMPHTokenAmount \u003e 0\n        ) {\n        orders[_orderId].shortSharesOrder = orders[_orderId].openMPHTokenAmount.div(\n                    shortShareValue(\n                        orders[_orderId].marketPrice,\n                        orders[_orderId].orderLeverage,\n                        now.mul(1000),\n                        orders[_orderId].marketPrice,\n                        orders[_orderId].marketSpread,\n                        orders[_orderId].orderLeverage,\n                        false\n                ));\n        }\n        // Investment equals number of shares now.\n        if (orders[_orderId].longSharesOrder \u003e 0) {\n            closeLong(_orderId);\n        }\n        if (orders[_orderId].shortSharesOrder \u003e 0) {\n            openShort(_orderId);\n        }\n    }\n\n// ----------------------------------------------------------------------------\n// openLong(bytes32 _orderId)\n// Opens a new long position and computes the new resulting average entry price/spread/leverage.\n// Computation is broken down to several instructions for readability.\n// ----------------------------------------------------------------------------\n    function openLong(bytes32 _orderId) private {\n        address _userId = orders[_orderId].userId;\n        bytes32 _marketId = orders[_orderId].marketId;\n\n        uint256 _newMeanSpread;\n        uint256 _newMeanLeverage;\n\n        // Existing position is virtually liquidated and reopened with current marketPrice\n        // orders[_orderId].newMeanEntryPrice = orders[_orderId].marketPrice;\n        // _factorLongShares is a factor to adjust the existing longShares via virtual liqudiation and reopening at current market price\n\n        uint256 _factorLongShares = state.getMeanEntryLeverage(_userId, _marketId);\n        if (_factorLongShares \u003c PRECISION) {\n            _factorLongShares = PRECISION;\n        }\n        _factorLongShares = _factorLongShares.sub(PRECISION);\n        _factorLongShares = _factorLongShares.mul(state.getMeanEntryPrice(_userId, _marketId)).div(orders[_orderId].marketPrice);\n        if (state.getMeanEntryLeverage(_userId, _marketId) \u003e _factorLongShares) {\n            _factorLongShares = state.getMeanEntryLeverage(_userId, _marketId).sub(_factorLongShares);\n        } else {\n            _factorLongShares = 0;\n        }\n\n        uint256 _adjustedLongShares = _factorLongShares.mul(state.getLongShares(_userId, _marketId)).div(PRECISION);\n\n        // _newMeanLeverage is the weighted leverage of the existing position and the new position\n        _newMeanLeverage = state.getMeanEntryLeverage(_userId, _marketId).mul(_adjustedLongShares);\n        _newMeanLeverage = _newMeanLeverage.add(orders[_orderId].orderLeverage.mul(orders[_orderId].longSharesOrder));\n        _newMeanLeverage = _newMeanLeverage.div(_adjustedLongShares.add(orders[_orderId].longSharesOrder));\n\n        // _newMeanSpread is the weighted spread of the existing position and the new position\n        _newMeanSpread = state.getMeanEntrySpread(_userId, _marketId).mul(state.getLongShares(_userId, _marketId));\n        _newMeanSpread = _newMeanSpread.add(orders[_orderId].marketSpread.mul(orders[_orderId].longSharesOrder));\n        _newMeanSpread = _newMeanSpread.div(_adjustedLongShares.add(orders[_orderId].longSharesOrder));\n\n        orders[_orderId].balanceDown = orders[_orderId].longSharesOrder.mul(orders[_orderId].marketPrice).add(\n            orders[_orderId].longSharesOrder.mul(orders[_orderId].marketSpread).mul(orders[_orderId].orderLeverage).div(PRECISION)\n        );\n        orders[_orderId].balanceUp = 0;\n        orders[_orderId].newLongShares = _adjustedLongShares.add(orders[_orderId].longSharesOrder);\n        orders[_orderId].newShortShares = state.getShortShares(_userId, _marketId);\n        orders[_orderId].newMeanEntryPrice = orders[_orderId].marketPrice;\n        orders[_orderId].newMeanEntrySpread = _newMeanSpread;\n        orders[_orderId].newMeanEntryLeverage = _newMeanLeverage;\n\n        setPositionInState(_orderId);\n    }\n// ----------------------------------------------------------------------------\n// closeLong(bytes32 _orderId)\n// Closes an existing long position. Average entry price/spread/leverage do not change.\n// ----------------------------------------------------------------------------\n     function closeLong(bytes32 _orderId) private {\n        address _userId = orders[_orderId].userId;\n        bytes32 _marketId = orders[_orderId].marketId;\n        uint256 _newLongShares  = state.getLongShares(_userId, _marketId).sub(orders[_orderId].longSharesOrder);\n        uint256 _balanceUp = calculateBalanceUp(_orderId);\n        uint256 _newMeanEntry;\n        uint256 _newMeanSpread;\n        uint256 _newMeanLeverage;\n\n        if (orders[_orderId].longSharesOrder == state.getLongShares(_userId, _marketId)) {\n            _newMeanEntry = 0;\n            _newMeanSpread = 0;\n            _newMeanLeverage = PRECISION;\n        } else {\n            _newMeanEntry = state.getMeanEntryPrice(_userId, _marketId);\n\t        _newMeanSpread = state.getMeanEntrySpread(_userId, _marketId);\n\t        _newMeanLeverage = state.getMeanEntryLeverage(_userId, _marketId);\n            resetTimestampInOrderToLastUpdated(_orderId);\n        }\n\n        orders[_orderId].balanceDown = 0;\n        orders[_orderId].balanceUp = _balanceUp;\n        orders[_orderId].newLongShares = _newLongShares;\n        orders[_orderId].newShortShares = state.getShortShares(_userId, _marketId);\n        orders[_orderId].newMeanEntryPrice = _newMeanEntry;\n        orders[_orderId].newMeanEntrySpread = _newMeanSpread;\n        orders[_orderId].newMeanEntryLeverage = _newMeanLeverage;\n\n        setPositionInState(_orderId);\n    }\n\nevent ResetTimestampInOrder(bytes32 _orderId, uint oldTimestamp, uint newTimestamp);\nfunction resetTimestampInOrderToLastUpdated(bytes32 _orderId) internal {\n    address userId = orders[_orderId].userId;\n    bytes32 marketId = orders[_orderId].marketId;\n    uint lastUpdated = state.getLastUpdated(userId, marketId);\n    emit ResetTimestampInOrder(_orderId, orders[_orderId].timeStamp, lastUpdated);\n    orders[_orderId].timeStamp = lastUpdated;\n}\n\n// ----------------------------------------------------------------------------\n// closeShort(bytes32 _orderId)\n// Closes an existing short position. Average entry price/spread/leverage do not change.\n// ----------------------------------------------------------------------------\nfunction calculateBalanceUp(bytes32 _orderId) private view returns (uint256 _balanceUp) {\n        address _userId = orders[_orderId].userId;\n        bytes32 _marketId = orders[_orderId].marketId;\n        uint256 _shareValue;\n\n        if (orders[_orderId].tradeDirection == false) { //we are selling our long shares\n            _balanceUp = orders[_orderId].longSharesOrder;\n            _shareValue = longShareValue(\n                state.getMeanEntryPrice(_userId, _marketId),\n                state.getMeanEntryLeverage(_userId, _marketId),\n                state.getLastUpdated(_userId, _marketId),\n                orders[_orderId].marketPrice,\n                orders[_orderId].marketSpread,\n                state.getMeanEntryLeverage(_userId, _marketId),\n                true\n            );\n        } else { //we are going long, we are selling our short shares\n            _balanceUp = orders[_orderId].shortSharesOrder;\n            _shareValue = shortShareValue(\n                state.getMeanEntryPrice(_userId, _marketId),\n                state.getMeanEntryLeverage(_userId, _marketId),\n                state.getLastUpdated(_userId, _marketId),\n                orders[_orderId].marketPrice,\n                orders[_orderId].marketSpread,\n                state.getMeanEntryLeverage(_userId, _marketId),\n                true\n            );\n        }\n        return _balanceUp.mul(_shareValue); \n    }\n\n    function closeShort(bytes32 _orderId) private {\n        address _userId = orders[_orderId].userId;\n        bytes32 _marketId = orders[_orderId].marketId;\n        uint256 _newMeanEntry;\n        uint256 _newMeanSpread;\n        uint256 _newMeanLeverage;\n        uint256 _newShortShares = state.getShortShares(_userId, _marketId).sub(orders[_orderId].shortSharesOrder);\n        uint256 _balanceUp = calculateBalanceUp(_orderId);\n        \n        if (orders[_orderId].shortSharesOrder == state.getShortShares(_userId, _marketId)) {\n            _newMeanEntry = 0;\n            _newMeanSpread = 0;\n\t        _newMeanLeverage = PRECISION;\n        } else {\n            _newMeanEntry = state.getMeanEntryPrice(_userId, _marketId);\n\t        _newMeanSpread = state.getMeanEntrySpread(_userId, _marketId);\n\t        _newMeanLeverage = state.getMeanEntryLeverage(_userId, _marketId);\n\n            /**\n             * we need the timestamp of the old order for partial closes, not the new one\n             */\n            resetTimestampInOrderToLastUpdated(_orderId);\n        }\n\n        orders[_orderId].balanceDown = 0;\n        orders[_orderId].balanceUp = _balanceUp;\n        orders[_orderId].newLongShares = state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId);\n        orders[_orderId].newShortShares = _newShortShares;\n        orders[_orderId].newMeanEntryPrice = _newMeanEntry;\n        orders[_orderId].newMeanEntrySpread = _newMeanSpread;\n        orders[_orderId].newMeanEntryLeverage = _newMeanLeverage;\n\n        setPositionInState(_orderId);\n    }\n\n// ----------------------------------------------------------------------------\n// openShort(bytes32 _orderId)\n// Opens a new short position and computes the new resulting average entry price/spread/leverage.\n// Computation is broken down to several instructions for readability.\n// ----------------------------------------------------------------------------\n    function openShort(bytes32 _orderId) private {\n        address _userId = orders[_orderId].userId;\n        bytes32 _marketId = orders[_orderId].marketId;\n\n        uint256 _newMeanSpread;\n        uint256 _newMeanLeverage;\n        //\n        // Existing position is virtually liquidated and reopened with current marketPrice\n        // orders[_orderId].newMeanEntryPrice = orders[_orderId].marketPrice;\n        // _factorShortShares is a factor to adjust the existing shortShares via virtual liqudiation and reopening at current market price\n\n        uint256 _factorShortShares = state.getMeanEntryLeverage(_userId, _marketId);\n        if (_factorShortShares \u003c PRECISION) {\n            _factorShortShares = PRECISION;\n        }\n        _factorShortShares = _factorShortShares.add(PRECISION);\n        _factorShortShares = _factorShortShares.mul(state.getMeanEntryPrice(_userId, _marketId)).div(orders[_orderId].marketPrice);\n        if (state.getMeanEntryLeverage(_userId, _marketId) \u003c _factorShortShares) {\n            _factorShortShares = _factorShortShares.sub(state.getMeanEntryLeverage(_userId, _marketId));\n        } else {\n            _factorShortShares = 0;\n        }\n\n        uint256 _adjustedShortShares = _factorShortShares.mul(state.getShortShares(_userId, _marketId)).div(PRECISION);\n\n        // _newMeanLeverage is the weighted leverage of the existing position and the new position\n        _newMeanLeverage = state.getMeanEntryLeverage(_userId, _marketId).mul(_adjustedShortShares);\n        _newMeanLeverage = _newMeanLeverage.add(orders[_orderId].orderLeverage.mul(orders[_orderId].shortSharesOrder));\n        _newMeanLeverage = _newMeanLeverage.div(_adjustedShortShares.add(orders[_orderId].shortSharesOrder));\n\n        // _newMeanSpread is the weighted spread of the existing position and the new position\n        _newMeanSpread = state.getMeanEntrySpread(_userId, _marketId).mul(state.getShortShares(_userId, _marketId));\n        _newMeanSpread = _newMeanSpread.add(orders[_orderId].marketSpread.mul(orders[_orderId].shortSharesOrder));\n        _newMeanSpread = _newMeanSpread.div(_adjustedShortShares.add(orders[_orderId].shortSharesOrder));\n\n        orders[_orderId].balanceDown = orders[_orderId].shortSharesOrder.mul(orders[_orderId].marketPrice).add(\n            orders[_orderId].shortSharesOrder.mul(orders[_orderId].marketSpread).mul(orders[_orderId].orderLeverage).div(PRECISION)\n        );\n        orders[_orderId].balanceUp = 0;\n        orders[_orderId].newLongShares = state.getLongShares(_userId, _marketId);\n        orders[_orderId].newShortShares = _adjustedShortShares.add(orders[_orderId].shortSharesOrder);\n        orders[_orderId].newMeanEntryPrice = orders[_orderId].marketPrice;\n        orders[_orderId].newMeanEntrySpread = _newMeanSpread;\n        orders[_orderId].newMeanEntryLeverage = _newMeanLeverage;\n\n        setPositionInState(_orderId);\n    }\n\n    function computeLiquidationPrice(bytes32 _orderId) public returns(uint256 _liquidationPrice) {\n        orders[_orderId].newLiquidationPrice = 0;\n        if (orders[_orderId].newLongShares \u003e 0) {\n            orders[_orderId].newLiquidationPrice = getLiquidationPrice(orders[_orderId].newMeanEntryPrice, orders[_orderId].newMeanEntryLeverage, true, orders[_orderId].timeStamp);\n        }\n        if (orders[_orderId].newShortShares \u003e 0) {\n            orders[_orderId].newLiquidationPrice = getLiquidationPrice(orders[_orderId].newMeanEntryPrice, orders[_orderId].newMeanEntryLeverage, false, orders[_orderId].timeStamp);\n        }\n        return orders[_orderId].newLiquidationPrice;\n    }\n\n    function getLiquidationPrice(uint256 _newMeanEntryPrice, uint256 _newMeanEntryLeverage, bool _long, uint _positionTimestampInMs) public view returns (uint256 _liquidationPrice) {\n        if (_long == true) {\n            _liquidationPrice = _newMeanEntryPrice.mul(_newMeanEntryLeverage.sub(PRECISION)).div(_newMeanEntryLeverage);\n            _liquidationPrice = _liquidationPrice.add(calculateMarginInterest(_newMeanEntryPrice, _newMeanEntryLeverage, _positionTimestampInMs));\n        } else {\n            _liquidationPrice = _newMeanEntryPrice.mul(_newMeanEntryLeverage.add(PRECISION)).div(_newMeanEntryLeverage);\n            _liquidationPrice = _liquidationPrice.sub(calculateMarginInterest(_newMeanEntryPrice, _newMeanEntryLeverage, _positionTimestampInMs));\n        }\n        return _liquidationPrice;\n    }\n\n    \n// ----------------------------------------------------------------------------\n// setPositionInState(bytes32 _orderId)\n// Updates the portfolio in Morpher State. Called by closeLong/closeShort/openLong/openShort\n// ----------------------------------------------------------------------------\n    function setPositionInState(bytes32 _orderId) private {\n        require(state.balanceOf(orders[_orderId].userId).add(orders[_orderId].balanceUp) \u003e= orders[_orderId].balanceDown, \"MorpherTradeEngine: insufficient funds.\");\n        computeLiquidationPrice(_orderId);\n        // Net balanceUp and balanceDown\n        if (orders[_orderId].balanceUp \u003e orders[_orderId].balanceDown) {\n            orders[_orderId].balanceUp.sub(orders[_orderId].balanceDown);\n            orders[_orderId].balanceDown = 0;\n        } else {\n            orders[_orderId].balanceDown.sub(orders[_orderId].balanceUp);\n            orders[_orderId].balanceUp = 0;\n        }\n        if (orders[_orderId].balanceUp \u003e 0) {\n            mintingLimiter.mint(orders[_orderId].userId, orders[_orderId].balanceUp);\n        }\n        if (orders[_orderId].balanceDown \u003e 0) {\n            state.burn(orders[_orderId].userId, orders[_orderId].balanceDown);\n        }\n        state.setPosition(\n            orders[_orderId].userId,\n            orders[_orderId].marketId,\n            orders[_orderId].timeStamp,\n            orders[_orderId].newLongShares,\n            orders[_orderId].newShortShares,\n            orders[_orderId].newMeanEntryPrice,\n            orders[_orderId].newMeanEntrySpread,\n            orders[_orderId].newMeanEntryLeverage,\n            orders[_orderId].newLiquidationPrice\n        );\n        emit PositionUpdated(\n            orders[_orderId].userId,\n            orders[_orderId].marketId,\n            orders[_orderId].timeStamp,\n            orders[_orderId].newLongShares,\n            orders[_orderId].newShortShares,\n            orders[_orderId].newMeanEntryPrice,\n            orders[_orderId].newMeanEntrySpread,\n            orders[_orderId].newMeanEntryLeverage,\n            orders[_orderId].newLiquidationPrice,\n            orders[_orderId].balanceUp,\n            orders[_orderId].balanceDown\n        );\n    }\n}\n"},"Ownable.sol":{"content":"pragma solidity 0.5.16;\n\nimport \"./IERC20.sol\";\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller should be owner.\");\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     * @notice Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: use renounce ownership instead.\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    // ------------------------------------------------------------------------\n    // Owner can transfer out any accidentally sent ERC20 tokens\n    // ------------------------------------------------------------------------\n    function transferAnyERC20Token(address _tokenAddress, uint256 _tokens) public onlyOwner returns (bool _success) {\n        return IERC20(_tokenAddress).transfer(owner(), _tokens);\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity 0.5.16;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}