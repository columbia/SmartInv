{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\n/***************************************************************************\n          ___        __         _     __           __   __ ___\n        / __ \\      / /_  _____(_)___/ /____       \\ \\ / /  _ \\\n       / / / /_  __/ __/ / ___/ / __  / __  )       \\ / /| |\n      / /_/ / /_/ / /_  (__  ) / /_/ / ____/         | | | |_\n      \\____/\\____/\\__/ /____/_/\\__,_/\\____/          |_|  \\___/\n                                       \n****************************************************************************/\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"Market.sol":{"content":"// SPDX-License-Identifier: MIT\n\n/***************************************************************************\n          ___        __         _     __           __   __ ___\n        / __ \\      / /_  _____(_)___/ /____       \\ \\ / /  _ \\\n       / / / /_  __/ __/ / ___/ / __  / __  )       \\ / /| |\n      / /_/ / /_/ / /_  (__  ) / /_/ / ____/         | | | |_\n      \\____/\\____/\\__/ /____/_/\\__,_/\\____/          |_|  \\___/\n                                       \n****************************************************************************/\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\ninterface IERC20 {\n    function burn(address from, uint256 amount) external;\n}\n\ninterface IERC721 {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n\ninterface IERC1155 {\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n}\n\ncontract Market is Ownable {\n    address admin = 0x44f7c870fA937578f6eacE3fCD4789726E105354;\n    address osycAddress = 0xdDEF9122b0b4d76Df98e60FD97e36e8dC5831079;\n\n    string private constant CONTRACT_NAME = \"OSYC Market Contract\";\n    bytes32 private constant DOMAIN_TYPEHASH =\n        keccak256(\n            \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\n        );\n    bytes32 private constant BUY_TYPEHASH =\n        keccak256(\n            \"Buy(address user,uint256 pid,bool isERC721,address collection,uint16 tokenId,uint16 totalAmount,uint16 amount,uint256 price,address owner)\"\n        );\n\n    struct BuyInfo {\n        uint256 pid;\n        bool isERC721;\n        address collection;\n        uint16 tokenId;\n        uint16 totalAmount;\n        uint16 amount;\n        uint256 price;\n        address owner;\n    }\n\n    mapping(uint256 =\u003e uint16) public mintedFromPid;\n\n    constructor() {}\n\n    function Buy(\n        BuyInfo memory buyInfo,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(tx.origin == msg.sender, \"Only EOA\");\n\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(CONTRACT_NAME)),\n                getChainId(),\n                address(this)\n            )\n        );\n        bytes32 structHash = keccak256(\n            abi.encode(\n                BUY_TYPEHASH,\n                msg.sender,\n                buyInfo.pid,\n                buyInfo.isERC721,\n                buyInfo.collection,\n                buyInfo.tokenId,\n                buyInfo.totalAmount,\n                buyInfo.amount,\n                buyInfo.price,\n                buyInfo.owner\n            )\n        );\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory == admin, \"Invalid signatory\");\n\n        if (buyInfo.isERC721) {\n            require(buyInfo.amount == 1 \u0026\u0026 mintedFromPid[buyInfo.pid] == 0, \"Already sold\");\n        } else {\n            require(buyInfo.amount \u003e 0, \"No correct amount\");\n            require(\n                buyInfo.amount \u003e 0 \u0026\u0026 mintedFromPid[buyInfo.pid] + buyInfo.amount \u003c= buyInfo.totalAmount,\n                \"Already sold out\"\n            );\n        }\n\n        mintedFromPid[buyInfo.pid] = mintedFromPid[buyInfo.pid] + buyInfo.amount;\n\n        IERC20(osycAddress).burn(msg.sender, buyInfo.price);\n        if (buyInfo.isERC721) {\n            IERC721(buyInfo.collection).transferFrom(\n                buyInfo.owner,\n                msg.sender,\n                buyInfo.tokenId\n            );\n        } else {\n            IERC1155(buyInfo.collection).safeTransferFrom(\n                buyInfo.owner,\n                msg.sender,\n                buyInfo.tokenId,\n                buyInfo.amount,\n                \"\"\n            );\n        }\n    }\n\n    function getChainId() internal view returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\n/***************************************************************************\n          ___        __         _     __           __   __ ___\n        / __ \\      / /_  _____(_)___/ /____       \\ \\ / /  _ \\\n       / / / /_  __/ __/ / ___/ / __  / __  )       \\ / /| |\n      / /_/ / /_/ / /_  (__  ) / /_/ / ____/         | | | |_\n      \\____/\\____/\\__/ /____/_/\\__,_/\\____/          |_|  \\___/\n                                       \n****************************************************************************/\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"}}