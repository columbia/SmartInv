{{
  "language": "Solidity",
  "sources": {
    "CollectorETH.sol": {
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.18;\n\nimport \"./ClaimerContract.sol\";\nimport \"./CollectorViews.sol\";\n\nerror InvestmentTooLow();\nerror SelfReferralDetected();\nerror InvalidReferralAddress();\n\ncontract CollectorETH is CollectorViews {\n\n    address public tokenDefiner;\n    address public tokenAddress;\n    address public bonusAddress;\n\n    ClaimerContract public claimer;\n\n    uint256 constant VESTING_TIME = 540 days;\n\n    modifier onlyTokenDefiner() {\n        require(\n            msg.sender == tokenDefiner,\n            \"CollectorETH: INVALID_SENDER\"\n        );\n        _;\n    }\n\n    modifier afterInvestmentPhase() {\n        require(\n            currentInvestmentDay() > INVESTMENT_DAYS,\n            \"CollectorETH: COLLECTOR_IN_PROGRESS\"\n        );\n        _;\n    }\n\n    modifier afterSupplyGenerated() {\n        require(\n            g.generatedDays == fundedDays(),\n            \"CollectorETH: SUPPLY_NOT_GENERATED\"\n        );\n        _;\n    }\n\n    modifier afterTokenProfitCreated() {\n        require (\n            g.generatedDays > 0 &&\n            g.totalWeiContributed == 0,\n            \"CollectorETH: CREATE_TOKEN_PROFIT\"\n        );\n        _;\n    }\n\n    constructor() {\n        tokenDefiner = msg.sender;\n        bonusAddress = msg.sender;\n    }\n\n    /** @dev Allows to define WISER token\n      */\n    function defineToken(\n        address _tokenAddress\n    )\n        external\n        onlyTokenDefiner\n    {\n        tokenAddress = _tokenAddress;\n    }\n\n    function defineBonus(\n        address _bonusAddress\n    )\n        external\n        onlyTokenDefiner\n    {\n        bonusAddress = _bonusAddress;\n    }\n\n    /** @dev Revokes access to define configs\n      */\n    function revokeAccess()\n        external\n        onlyTokenDefiner\n    {\n        tokenDefiner = address(0x0);\n    }\n\n    /** @dev Performs reservation of WISER tokens with ETH\n      */\n    function reserveWiser(\n        uint8[] calldata _investmentDays,\n        address _referralAddress\n    )\n        external\n        payable\n    {\n        checkInvestmentDays(\n            _investmentDays,\n            currentInvestmentDay()\n        );\n\n        _reserveWiser(\n            _investmentDays,\n            _referralAddress,\n            msg.sender,\n            msg.value\n        );\n    }\n\n    /** @notice Allows reservation of WISER tokens with other ERC20 tokens\n      * @dev this will require this contract to be approved as spender\n      */\n    function reserveWiserWithToken(\n        address _tokenAddress,\n        uint256 _tokenAmount,\n        uint256 _minExpected,\n        uint8[] calldata _investmentDays,\n        address _referralAddress\n    )\n        external\n    {\n        TokenERC20 _token = TokenERC20(\n            _tokenAddress\n        );\n\n        _token.transferFrom(\n            msg.sender,\n            address(this),\n            _tokenAmount\n        );\n\n        _token.approve(\n            address(UNISWAP_ROUTER),\n            _tokenAmount\n        );\n\n        address[] memory _path = preparePath(\n            _tokenAddress\n        );\n\n        uint256[] memory amounts =\n        UNISWAP_ROUTER.swapExactTokensForETH(\n            _tokenAmount,\n            _minExpected,\n            _path,\n            address(this),\n            block.timestamp + 2 hours\n        );\n\n        checkInvestmentDays(\n            _investmentDays,\n            currentInvestmentDay()\n        );\n\n        _reserveWiser(\n            _investmentDays,\n            _referralAddress,\n            msg.sender,\n            amounts[1]\n        );\n    }\n\n    function _reserveWiser(\n        uint8[] memory _investmentDays,\n        address _referralAddress,\n        address _senderAddress,\n        uint256 _senderValue\n    )\n        internal\n    {\n        if (_senderAddress == _referralAddress) {\n            revert SelfReferralDetected();\n        }\n\n        if (isContract(_referralAddress) == true) {\n            revert InvalidReferralAddress();\n        }\n\n        if (_senderValue < MIN_INVEST * _investmentDays.length) {\n            revert InvestmentTooLow();\n        }\n\n        uint256 _investmentBalance = _referralAddress == address(0x0)\n            ? _senderValue // no referral bonus\n            : _senderValue * 1100 / 1000;\n\n        uint256 _totalDays = _investmentDays.length;\n        uint256 _dailyAmount = _investmentBalance / _totalDays;\n        uint256 _leftOver = _investmentBalance % _totalDays;\n\n        _addBalance(\n            _senderAddress,\n            _investmentDays[0],\n            _dailyAmount + _leftOver\n        );\n\n        for (uint8 _i = 1; _i < _totalDays; _i++) {\n            _addBalance(\n                _senderAddress,\n                _investmentDays[_i],\n                _dailyAmount\n            );\n        }\n\n        _trackInvestors(\n            _senderAddress,\n            _investmentBalance\n        );\n\n        originalInvestment[_senderAddress] += _senderValue;\n        g.totalWeiContributed += _senderValue;\n\n        if (_referralAddress == address(0x0)) {\n            return;\n        }\n\n        _trackReferrals(\n            _referralAddress,\n            _senderValue\n        );\n\n        emit ReferralAdded(\n            _referralAddress,\n            _senderAddress,\n            _senderValue\n        );\n    }\n\n    /** @notice Allocates investors balance to specific day\n      */\n    function _addBalance(\n        address _senderAddress,\n        uint256 _investmentDay,\n        uint256 _investmentBalance\n    )\n        internal\n    {\n        if (investorBalances[_senderAddress][_investmentDay] == 0) {\n            investorAccounts[_investmentDay][investorAccountCount[_investmentDay]] = _senderAddress;\n            investorAccountCount[_investmentDay]++;\n        }\n\n        investorBalances[_senderAddress][_investmentDay] += _investmentBalance;\n        dailyTotalInvestment[_investmentDay] += _investmentBalance;\n\n        emit WiseReservation(\n            _senderAddress,\n            _investmentDay,\n            _investmentBalance\n        );\n    }\n\n    /** @notice Tracks investorTotalBalance and uniqueInvestors\n      * @dev used in _reserveWiser() internal function\n      */\n    function _trackInvestors(\n        address _investorAddress,\n        uint256 _value\n    )\n        internal\n    {\n        if (investorTotalBalance[_investorAddress] == 0) {\n            uniqueInvestors[uniqueInvestorCount] = _investorAddress;\n            uniqueInvestorCount++;\n        }\n\n        investorTotalBalance[_investorAddress] += _value;\n    }\n\n    /** @notice Tracks referralAmount and referralAccounts\n      * @dev used in _reserveWiser() internal function\n      */\n    function _trackReferrals(\n        address _referralAddress,\n        uint256 _value\n    )\n        internal\n    {\n        if (referralAmount[_referralAddress] == 0) {\n            referralAccounts[referralAccountCount] = _referralAddress;\n            referralAccountCount++;\n        }\n\n        referralAmount[_referralAddress] += _value;\n    }\n\n    /** @notice Allows to generate supply for past funded days\n      */\n    function generateSupply()\n        external\n        afterInvestmentPhase\n    {\n        for (uint8 i = 1; i <= INVESTMENT_DAYS; i++) {\n\n            if (dailyTotalSupply[i] > 0) continue;\n            if (dailyTotalInvestment[i] == 0) continue;\n\n            dailyTotalSupply[i] = DAILY_SUPPLY;\n            g.totalTransferTokens += DAILY_SUPPLY;\n\n            g.generatedDays++;\n\n            emit GeneratedStaticSupply(\n                i,\n                DAILY_SUPPLY\n            );\n        }\n    }\n\n    /** @notice Pre-calculates amount of tokens each referrer will get\n      * @dev must run this for all referrer addresses in batches\n      * converts _referralAmount to _referralTokens based on dailyRatio\n      */\n    function prepareReferralBonuses(\n        uint256 _referralBatchFrom,\n        uint256 _referralBatchTo\n    )\n        external\n        afterInvestmentPhase\n        afterSupplyGenerated\n    {\n        require(\n            _referralBatchFrom < _referralBatchTo,\n            \"CollectorETH: INVALID_REFERRAL_BATCH\"\n        );\n\n        require(\n            g.preparedReferrals < referralAccountCount,\n            \"CollectorETH: REFERRALS_ALREADY_PREPARED\"\n        );\n\n        uint256 _totalRatio = g.totalTransferTokens / g.totalWeiContributed;\n\n        for (uint256 i = _referralBatchFrom; i < _referralBatchTo; i++) {\n\n            address _referralAddress = referralAccounts[i];\n            uint256 _referralAmount = referralAmount[_referralAddress];\n\n            if (_referralAmount == 0) continue;\n\n            g.preparedReferrals++;\n            referralAmount[_referralAddress] = 0;\n\n            if (_referralAmount < MINIMUM_REFERRAL) continue;\n\n            uint256 referralBonus = _getReferralAmount(\n                _referralAmount,\n                _totalRatio\n            );\n\n            g.totalReferralTokens += referralBonus;\n            referralTokens[_referralAddress] = referralBonus;\n        }\n    }\n\n    /** @notice Creates tokenProfit contract aka WISER contract\n      * and forwards all collected funds for the governance\n      * also mints all the supply and locks in vesting contract\n      */\n    function createTokenProfitContract(/*ü¶â*/)\n        external\n        afterInvestmentPhase\n        afterSupplyGenerated\n    {\n        require(\n            g.preparedReferrals == referralAccountCount,\n            \"CollectorETH: REFERRALS_NOT_READY\"\n        );\n\n        require(\n            address(claimer) == address(0x0),\n            \"CollectorETH: ALREADY_CREATED\"\n        );\n\n        claimer = new ClaimerContract(\n            address(this),\n            VESTING_TIME,\n            tokenAddress\n        );\n\n        uint256 tokensForRef = g.totalReferralTokens;\n        uint256 collectedETH = g.totalWeiContributed;\n        uint256 tokensToMint = g.totalTransferTokens + tokensForRef;\n\n        uint256 tokensToGift = LIMIT_REFERRALS > tokensForRef\n            ? LIMIT_REFERRALS - tokensForRef\n            : 0;\n\n        payable(tokenAddress).transfer(\n            collectedETH\n        );\n\n        WiserToken(tokenAddress).mintSupply(\n            address(claimer),\n            tokensToMint\n        );\n\n        WiserToken(tokenAddress).mintSupply(\n            bonusAddress,\n            tokensToGift\n        );\n\n        WiserToken(tokenAddress).mintSupply(\n            bonusAddress,\n            WISER_FUNDRAISE\n        );\n\n        g.totalWeiContributed = 0;\n        g.totalTransferTokens = 0;\n        g.totalReferralTokens = 0;\n    }\n\n    /** @notice Allows to start vesting of purchased tokens\n      * from investor and referrer perspectives address\n      * @dev can be called after createTokenProfitContract()\n      */\n    function startMyVesting(/*‚è≥*/)\n        external\n        afterTokenProfitCreated\n    {\n        uint256 locked = _payoutInvestorAddress(\n            msg.sender\n        );\n\n        uint256 opened = _payoutReferralAddress(\n            msg.sender\n        );\n\n        if (locked + opened == 0) return;\n\n        claimer.enrollAndScrape(\n            msg.sender,\n            locked,\n            opened,\n            VESTING_TIME\n        );\n    }\n\n    /** @notice Returns minting amount for specific investor address\n      * @dev aggregades investors tokens across all investment days\n      */\n    function _payoutInvestorAddress(\n        address _investorAddress\n    )\n        internal\n        returns (uint256 payoutAmount)\n    {\n        for (uint8 i = 1; i <= INVESTMENT_DAYS; i++) {\n\n            uint256 balance = investorBalances[_investorAddress][i];\n\n            if (balance == 0) continue;\n\n            payoutAmount += balance\n                * _calculateDailyRatio(i)\n                / PRECISION_POINT;\n\n            investorBalances[_investorAddress][i] = 0;\n        }\n    }\n\n    /** @notice Returns minting amount for specific referrer address\n      * @dev must be pre-calculated in prepareReferralBonuses()\n      */\n    function _payoutReferralAddress(\n        address _referralAddress\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 payoutAmount = referralTokens[_referralAddress];\n\n        if (referralTokens[_referralAddress] > 0) {\n            referralTokens[_referralAddress] = 0;\n        }\n\n        return payoutAmount;\n    }\n\n    function requestRefund()\n        external\n        returns (uint256 _amount)\n    {\n        address investor = msg.sender;\n\n        require(\n            g.totalWeiContributed > 0  &&\n            originalInvestment[investor] > 0 &&\n            currentInvestmentDay() > INVESTMENT_DAYS + 15,\n           \"CollectorETH: REFUND_NOT_POSSIBLE\"\n        );\n\n        _amount = originalInvestment[investor];\n        originalInvestment[investor] = 0;\n        g.totalTransferTokens = 0;\n\n        payable(investor).transfer(\n            _amount\n        );\n    }\n}\n"
    },
    "CollectorViews.sol": {
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.18;\n\nimport \"./CollectorDeclaration.sol\";\n\ncontract CollectorViews is CollectorDeclaration {\n\n    /** @notice checks for callers investment amount on specific day (with bonus)\n      * @return total amount invested across all investment days (with bonus)\n      */\n    function myInvestmentAmount(\n        uint256 _investmentDay\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return investorBalances[msg.sender][_investmentDay];\n    }\n\n    /** @notice checks for callers investment amount on each day (with bonus)\n      * @return _myAllDays total amount invested across all days (with bonus)\n      */\n    function myInvestmentAmountAllDays()\n        external\n        view\n        returns (uint256[51] memory _myAllDays)\n    {\n        for (uint256 i = 1; i <= INVESTMENT_DAYS; i++) {\n            _myAllDays[i] = investorBalances[msg.sender][i];\n        }\n    }\n\n    /** @notice checks for callers total investment amount (with bonus)\n      * @return total amount invested across all investment days (with bonus)\n      */\n    function myTotalInvestmentAmount()\n        external\n        view\n        returns (uint256)\n    {\n        return investorTotalBalance[msg.sender];\n    }\n\n    /** @notice checks for investors count on specific day\n      * @return investors count for specific day\n      */\n    function investorsOnDay(\n        uint256 _investmentDay\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return dailyTotalInvestment[_investmentDay] > 0\n            ? investorAccountCount[_investmentDay]\n            : 0;\n    }\n\n    /** @notice checks for investors count on each day\n      * @return _allInvestors array with investors count for each day\n      */\n    function investorsOnAllDays()\n        external\n        view\n        returns (uint256[51] memory _allInvestors)\n    {\n        for (uint256 i = 1; i <= INVESTMENT_DAYS; i++) {\n            _allInvestors[i] = dailyTotalInvestment[i] > 0\n            ? investorAccountCount[i]\n            : 0;\n        }\n    }\n\n    /** @notice checks for investment amount on each day\n      * @return _allInvestments array with investment amount for each day\n      */\n    function investmentsOnAllDays()\n        external\n        view\n        returns (uint256[51] memory _allInvestments)\n    {\n        for (uint256 i = 1; i <= INVESTMENT_DAYS; i++) {\n            _allInvestments[i] = dailyTotalInvestment[i];\n        }\n    }\n\n    /** @notice checks for supply amount on each day\n      * @return _allSupply array with supply amount for each day\n      */\n    function supplyOnAllDays()\n        external\n        view\n        returns (uint256[51] memory _allSupply)\n    {\n        for (uint256 i = 1; i <= INVESTMENT_DAYS; i++) {\n            _allSupply[i] = dailyTotalSupply[i];\n        }\n    }\n\n    /** @notice shows current investment day\n      */\n    function currentInvestmentDay()\n        public\n        view\n        returns (uint256)\n    {\n        return block.timestamp > INCEPTION_TIME\n            ? (block.timestamp - INCEPTION_TIME) / SECONDS_IN_DAY + 1\n            : 0;\n    }\n\n    function isContract(\n        address _walletAddress\n    )\n        public\n        view\n        returns (bool)\n    {\n        uint32 size;\n        assembly {\n            size := extcodesize(\n                _walletAddress\n            )\n        }\n        return (size > 0);\n    }\n\n    /** @notice prepares path variable for uniswap to exchange tokens\n      * @dev used in reserveWiserWithToken() swapExactTokensForETH call\n      */\n    function preparePath(\n        address _tokenAddress\n    )\n        public\n        pure\n        returns\n    (\n        address[] memory _path\n    ) {\n        _path = new address[](2);\n        _path[0] = _tokenAddress;\n        _path[1] = WETH;\n    }\n\n    /** @notice checks that provided days are valid for investemnt\n      * @dev used in reserveWise() and reserveWiseWithToken()\n      */\n    function checkInvestmentDays(\n        uint8[] memory _investmentDays,\n        uint256 _investmentDay\n    )\n        public\n        pure\n    {\n        for (uint8 _i = 0; _i < _investmentDays.length; _i++) {\n            require(\n                _investmentDays[_i] >= _investmentDay,\n                \"CollectorViews: DAY_ALREADY_PASSED\"\n            );\n            require(\n                _investmentDays[_i] > 0 &&\n                _investmentDays[_i] <= INVESTMENT_DAYS,\n                \"CollectorViews: INVALID_INVESTMENT_DAY\"\n            );\n        }\n    }\n\n    /** @notice checks for invesments on all days\n      * @dev used in createTokenProfitContract()\n      */\n    function fundedDays()\n        public\n        view\n        returns (uint8 $fundedDays)\n    {\n        for (uint8 i = 1; i <= INVESTMENT_DAYS; i++) {\n            if (dailyTotalInvestment[i] > 0) {\n                $fundedDays++;\n            }\n        }\n    }\n\n    /** @notice WISER equivalent in ETH price calculation\n      * @dev returned value has 100E18 precision point\n      */\n    function _calculateDailyRatio(\n        uint256 _investmentDay\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 dailyRatio = dailyTotalSupply[_investmentDay]\n            * PRECISION_POINT\n            / dailyTotalInvestment[_investmentDay];\n\n        uint256 remainderCheck = dailyTotalSupply[_investmentDay]\n            * PRECISION_POINT\n            % dailyTotalInvestment[_investmentDay];\n\n        return remainderCheck == 0\n            ? dailyRatio\n            : dailyRatio + 1;\n    }\n\n    /** @notice calculates referral bonus\n      */\n    function _getReferralAmount(\n        uint256 _referralAmount,\n        uint256 _ratio\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return _referralAmount / REFERRAL_BONUS * _ratio;\n    }\n}\n"
    },
    "ClaimerContract.sol": {
      "content": "// SPDX-License-Identifier: --WISE--\n\npragma solidity =0.8.18;\n\nimport \"./ClaimerHelper.sol\";\n\ncontract ClaimerContract is ClaimerHelper {\n\n    address public immutable collector;\n    uint256 public immutable createTime;\n    uint256 public immutable minimumTime;\n\n    struct KeeperInfo {\n        uint256 keeperRate;\n        uint256 keeperTill;\n        uint256 keeperInstant;\n        uint256 keeperPayouts;\n    }\n\n    mapping(address => KeeperInfo) public keeperList;\n\n    modifier onlyCollector() {\n        require(\n            msg.sender == collector,\n            \"ClaimerContract: INVALID_COLLECTOR\"\n        );\n        _;\n    }\n\n    constructor(\n        address _collector,\n        uint256 _timeFrame,\n        address _tokenAddress\n    )\n        ClaimerHelper(\n            _tokenAddress\n        )\n    {\n        if (_timeFrame == 0) {\n            revert(\"ClaimerContract: INVALID_TIMEFRAME\");\n        }\n\n        collector = _collector;\n        createTime = getNow();\n        minimumTime = _timeFrame;\n    }\n\n    function enrollAndScrape(\n        address _recipient,\n        uint256 _tokensLocked,\n        uint256 _tokensOpened,\n        uint256 _timeFrame\n    )\n        external\n        onlyCollector\n    {\n        _enrollRecipient(\n            _recipient,\n            _tokensLocked,\n            _tokensOpened,\n            _timeFrame\n        );\n\n        _scrapeTokens(\n            _recipient\n        );\n    }\n\n    function _enrollRecipient(\n        address _recipient,\n        uint256 _tokensLocked,\n        uint256 _tokensOpened,\n        uint256 _timeFrame\n    )\n        private\n    {\n        require(\n            keeperList[_recipient].keeperTill == 0,\n            \"ClaimerContract: RECIPIENT_ALREADY_ENROLLED\"\n        );\n\n        _allocateTokens(\n            _recipient,\n            _tokensLocked,\n            _tokensOpened,\n            _timeFrame\n        );\n    }\n\n    function _allocateTokens(\n        address _recipient,\n        uint256 _tokensLocked,\n        uint256 _tokensOpened,\n        uint256 _timeFrame\n    )\n        private\n    {\n        require(\n            _timeFrame >= minimumTime,\n            \"ClaimerContract: INVALID_TIME_FRAME\"\n        );\n\n        totalRequired = totalRequired\n            + _tokensOpened\n            + _tokensLocked;\n\n        keeperList[_recipient].keeperTill = createTime\n            + _timeFrame;\n\n        keeperList[_recipient].keeperRate = _tokensLocked\n            / _timeFrame;\n\n        keeperList[_recipient].keeperInstant = _tokensLocked\n            % _timeFrame\n            + _tokensOpened;\n\n        _checkBalance(\n            totalRequired\n        );\n\n        emit recipientEnrolled(\n            _recipient,\n            _timeFrame,\n            _tokensLocked,\n            _tokensOpened\n        );\n    }\n\n    function scrapeMyTokens()\n        external\n    {\n        _scrapeTokens(\n            msg.sender\n        );\n    }\n\n    function _scrapeTokens(\n        address _recipient\n    )\n        private\n    {\n        uint256 scrapeAmount = availableBalance(\n            _recipient\n        );\n\n        keeperList[_recipient].keeperPayouts += scrapeAmount;\n\n        _safeScrape(\n            _recipient,\n            scrapeAmount\n        );\n\n        emit tokensScraped(\n            _recipient,\n            scrapeAmount,\n            getNow()\n        );\n    }\n\n    function availableBalance(\n        address _recipient\n    )\n        public\n        view\n        returns (uint256 balance)\n    {\n        uint256 timeNow = getNow();\n        uint256 timeMax = keeperList[_recipient].keeperTill;\n\n        if (timeMax == 0) return 0;\n\n        uint256 timePassed = timeNow > timeMax\n            ? timeMax - createTime\n            : timeNow - createTime;\n\n        balance = keeperList[_recipient].keeperRate\n            * timePassed\n            + keeperList[_recipient].keeperInstant\n            - keeperList[_recipient].keeperPayouts;\n    }\n\n    function lockedBalance(\n        address _recipient\n    )\n        external\n        view\n        returns (uint256 balance)\n    {\n        uint256 timeNow = getNow();\n\n        uint256 timeRemaining =\n            keeperList[_recipient].keeperTill > timeNow ?\n            keeperList[_recipient].keeperTill - timeNow : 0;\n\n        balance = keeperList[_recipient].keeperRate\n            * timeRemaining;\n    }\n}\n"
    },
    "CollectorDeclaration.sol": {
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.18;\n\ninterface UniswapV2 {\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (uint256[] memory amounts);\n}\n\ninterface TokenERC20 {\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        external\n        returns (bool success);\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        external\n        returns (bool success);\n}\n\ninterface WiserToken {\n    function mintSupply(\n        address _to,\n        uint256 _value\n    )\n        external\n        returns (bool success);\n}\n\ncontract CollectorDeclaration {\n\n    UniswapV2 public constant UNISWAP_ROUTER = UniswapV2(\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n    );\n\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    uint256 constant INVESTMENT_DAYS = 50;\n    uint256 constant REFERRAL_BONUS = 10;\n    uint256 constant SECONDS_IN_DAY = 86400;\n    uint256 constant PRECISION_POINT = 100E18;\n    uint256 constant INCEPTION_TIME = 1677628800;\n    uint256 constant LIMIT_REFERRALS = 90000000E18;\n    uint256 constant WISER_FUNDRAISE = 10000000E18;\n    uint128 constant MINIMUM_REFERRAL = 10 ether;\n    uint128 constant MIN_INVEST = 50000000000000000;\n    uint128 constant DAILY_SUPPLY = 18000000E18;\n\n    struct Globals {\n        uint64 generatedDays;\n        uint64 preparedReferrals;\n        uint256 totalTransferTokens;\n        uint256 totalWeiContributed;\n        uint256 totalReferralTokens;\n    }\n\n    Globals public g;\n\n    mapping(uint256 => uint256) public dailyTotalSupply;\n    mapping(uint256 => uint256) public dailyTotalInvestment;\n\n    mapping(uint256 => uint256) public investorAccountCount;\n    mapping(uint256 => mapping(uint256 => address)) public investorAccounts;\n    mapping(address => mapping(uint256 => uint256)) public investorBalances;\n\n    mapping(address => uint256) public referralAmount;\n    mapping(address => uint256) public referralTokens;\n    mapping(address => uint256) public investorTotalBalance;\n    mapping(address => uint256) public originalInvestment;\n\n    uint256 public referralAccountCount;\n    uint256 public uniqueInvestorCount;\n\n    mapping (uint256 => address) public uniqueInvestors;\n    mapping (uint256 => address) public referralAccounts;\n\n    event GeneratedStaticSupply(\n        uint256 indexed investmentDay,\n        uint256 staticSupply\n    );\n\n    event ReferralAdded(\n        address indexed referral,\n        address indexed referee,\n        uint256 amount\n    );\n\n    event WiseReservation(\n        address indexed sender,\n        uint256 indexed investmentDay,\n        uint256 amount\n    );\n}\n"
    },
    "ClaimerHelper.sol": {
      "content": "// SPDX-License-Identifier: --BCOM--\n\npragma solidity =0.8.18;\n\ncontract ClaimerHelper {\n\n    uint256 public totalRequired;\n    address public immutable wiserToken;\n\n    event recipientEnrolled(\n        address indexed recipient,\n        uint256 timeFrame,\n        uint256 tokensLocked,\n        uint256 tokensOpened\n    );\n\n    event tokensScraped(\n        address indexed scraper,\n        uint256 scrapedAmount,\n        uint256 timestamp\n    );\n\n    constructor(\n        address _wiserTokenAddress\n    ) {\n        if (_wiserTokenAddress == address(0x0)) {\n            revert(\"ClaimerHelper: INVALID_TOKEN\");\n        }\n\n        wiserToken = _wiserTokenAddress;\n    }\n\n    bytes4 private constant TRANSFER = bytes4(\n        keccak256(\n            bytes(\n                \"transfer(address,uint256)\"\n            )\n        )\n    );\n\n    bytes4 private constant BALANCEOF = bytes4(\n        keccak256(\n            bytes(\n                \"balanceOf(address)\"\n            )\n        )\n    );\n\n    function _safeScrape(\n        address _to,\n        uint256 _scrapeAmount\n    )\n        internal\n    {\n        totalRequired -= _scrapeAmount;\n\n        (bool success, bytes memory data) = wiserToken.call(\n            abi.encodeWithSelector(\n                TRANSFER,\n                _to,\n                _scrapeAmount\n            )\n        );\n\n        require(\n            success && (\n                abi.decode(\n                    data, (bool)\n                )\n            ),\n            \"ClaimerHelper: TRANSFER_FAILED\"\n        );\n    }\n\n    function _checkBalance(\n        uint256 _required\n    )\n        internal\n    {\n        (bool success, bytes memory data) = wiserToken.call(\n            abi.encodeWithSelector(\n                BALANCEOF,\n                address(this)\n            )\n        );\n\n        require(\n            success && abi.decode(\n                data, (uint256)\n            ) >= _required,\n            \"ClaimerHelper: BALANCE_CHECK_FAILED\"\n        );\n    }\n\n    function getNow()\n        public\n        view\n        returns (uint256 time)\n    {\n        time = block.timestamp;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}