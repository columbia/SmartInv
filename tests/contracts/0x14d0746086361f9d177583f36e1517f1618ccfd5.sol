{{
  "language": "Solidity",
  "sources": {
    "contracts/liquidity-protection/LiquidityProtection.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\n\nimport \"../utility/MathEx.sol\";\nimport \"../utility/Types.sol\";\nimport \"../utility/Time.sol\";\nimport \"../utility/Utils.sol\";\nimport \"../utility/Owned.sol\";\n\nimport \"../token/interfaces/IDSToken.sol\";\nimport \"../token/ReserveToken.sol\";\n\nimport \"../converter/interfaces/IConverterAnchor.sol\";\nimport \"../converter/interfaces/IConverter.sol\";\nimport \"../converter/interfaces/IConverterRegistry.sol\";\n\nimport \"./interfaces/ILiquidityProtection.sol\";\n\ninterface ILiquidityPoolConverter is IConverter {\n    function addLiquidity(\n        IReserveToken[] memory reserveTokens,\n        uint256[] memory reserveAmounts,\n        uint256 minReturn\n    ) external payable;\n\n    function removeLiquidity(\n        uint256 amount,\n        IReserveToken[] memory reserveTokens,\n        uint256[] memory reserveMinReturnAmounts\n    ) external returns (uint256[] memory);\n\n    function recentAverageRate(IReserveToken reserveToken) external view returns (uint256, uint256);\n}\n\ninterface IBancorNetworkV3 {\n    function migrateLiquidity(\n        IReserveToken reserveToken,\n        address provider,\n        uint256 amount,\n        uint256 availableAmount,\n        uint256 originalAmount\n    ) external payable;\n}\n\n/**\n * @dev This contract implements the liquidity protection mechanism.\n */\ncontract LiquidityProtection is ILiquidityProtection, Utils, Owned, ReentrancyGuard, Time {\n    using Math for uint256;\n    using SafeMath for uint256;\n    using ReserveToken for IReserveToken;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IDSToken;\n    using SafeERC20Ex for IERC20;\n    using Address for address payable;\n\n    struct Position {\n        address provider; // liquidity provider\n        IDSToken poolToken; // pool token address\n        IReserveToken reserveToken; // reserve token address\n        uint256 poolAmount; // pool token amount\n        uint256 reserveAmount; // reserve token amount\n        uint256 reserveRateN; // rate of 1 protected reserve token in units of the other reserve token (numerator)\n        uint256 reserveRateD; // rate of 1 protected reserve token in units of the other reserve token (denominator)\n        uint256 timestamp; // timestamp\n    }\n\n    // various rates between the two reserve tokens. the rate is of 1 unit of the protected reserve token in units of the other reserve token\n    struct PackedRates {\n        uint128 addSpotRateN; // spot rate of 1 A in units of B when liquidity was added (numerator)\n        uint128 addSpotRateD; // spot rate of 1 A in units of B when liquidity was added (denominator)\n        uint128 removeSpotRateN; // spot rate of 1 A in units of B when liquidity is removed (numerator)\n        uint128 removeSpotRateD; // spot rate of 1 A in units of B when liquidity is removed (denominator)\n        uint128 removeAverageRateN; // average rate of 1 A in units of B when liquidity is removed (numerator)\n        uint128 removeAverageRateD; // average rate of 1 A in units of B when liquidity is removed (denominator)\n    }\n\n    struct PositionList {\n        IDSToken poolToken; // pool token address\n        IReserveToken reserveToken; // reserve token address\n        uint256[] positionIds; // position ids\n    }\n\n    uint256 internal constant MAX_UINT128 = 2**128 - 1;\n    uint256 internal constant MAX_UINT256 = uint256(-1);\n\n    IBancorNetworkV3 private immutable _networkV3;\n    address payable private immutable _vaultV3;\n    ILiquidityProtectionSettings private immutable _settings;\n    ILiquidityProtectionStore private immutable _store;\n    ILiquidityProtectionStats private immutable _stats;\n    ILiquidityProtectionSystemStore private immutable _systemStore;\n    ITokenHolder private immutable _wallet;\n    IERC20 private immutable _networkToken;\n    ITokenGovernance private immutable _networkTokenGovernance;\n    IERC20 private immutable _govToken;\n    ITokenGovernance private immutable _govTokenGovernance;\n\n    bool private _addingEnabled = true;\n    bool private _removingEnabled = true;\n\n    /**\n     * @dev initializes a new LiquidityProtection contract\n     */\n    constructor(\n        IBancorNetworkV3 networkV3,\n        address payable vaultV3,\n        ILiquidityProtectionSettings settings,\n        ILiquidityProtectionStore store,\n        ILiquidityProtectionStats stats,\n        ILiquidityProtectionSystemStore systemStore,\n        ITokenHolder wallet,\n        ITokenGovernance networkTokenGovernance,\n        ITokenGovernance govTokenGovernance\n    ) public {\n        _validAddress(address(networkV3));\n        _validAddress(address(vaultV3));\n        _validAddress(address(settings));\n        _validAddress(address(store));\n        _validAddress(address(stats));\n        _validAddress(address(systemStore));\n        _validAddress(address(wallet));\n\n        _networkV3 = networkV3;\n        _vaultV3 = vaultV3;\n        _settings = settings;\n        _store = store;\n        _stats = stats;\n        _systemStore = systemStore;\n        _wallet = wallet;\n        _networkTokenGovernance = networkTokenGovernance;\n        _govTokenGovernance = govTokenGovernance;\n\n        _networkToken = networkTokenGovernance.token();\n        _govToken = govTokenGovernance.token();\n    }\n\n    // ensures that the pool is supported and whitelisted\n    modifier poolSupportedAndWhitelisted(IConverterAnchor poolAnchor) {\n        _poolSupported(poolAnchor);\n        _poolWhitelisted(poolAnchor);\n\n        _;\n    }\n\n    // ensures that add liquidity is enabled\n    modifier addLiquidityEnabled(IConverterAnchor poolAnchor, IReserveToken reserveToken) {\n        _addLiquidityEnabled(poolAnchor, reserveToken);\n\n        _;\n    }\n\n    // ensures that remove liquidity is enabled\n    modifier removeLiquidityEnabled() {\n        _removeLiquidityEnabled();\n\n        _;\n    }\n\n    // error message binary size optimization\n    function _poolSupported(IConverterAnchor poolAnchor) internal view {\n        require(_settings.isPoolSupported(poolAnchor), \"ERR_POOL_NOT_SUPPORTED\");\n    }\n\n    // error message binary size optimization\n    function _poolWhitelisted(IConverterAnchor poolAnchor) internal view {\n        require(_settings.isPoolWhitelisted(poolAnchor), \"ERR_POOL_NOT_WHITELISTED\");\n    }\n\n    // error message binary size optimization\n    function _addLiquidityEnabled(IConverterAnchor poolAnchor, IReserveToken reserveToken) internal view {\n        require(\n            _addingEnabled && !_settings.addLiquidityDisabled(poolAnchor, reserveToken),\n            \"ERR_ADD_LIQUIDITY_DISABLED\"\n        );\n    }\n\n    // error message binary size optimization\n    function _removeLiquidityEnabled() internal view {\n        require(_removingEnabled);\n    }\n\n    // error message binary size optimization\n    function _verifyEthAmount(uint256 value) internal view {\n        require(msg.value == value, \"ERR_ETH_AMOUNT_MISMATCH\");\n    }\n\n    /**\n     * @dev returns the LP store\n     */\n    function store() external view override returns (ILiquidityProtectionStore) {\n        return _store;\n    }\n\n    /**\n     * @dev returns the LP stats\n     */\n    function stats() external view override returns (ILiquidityProtectionStats) {\n        return _stats;\n    }\n\n    /**\n     * @dev returns the LP settings\n     */\n    function settings() external view override returns (ILiquidityProtectionSettings) {\n        return _settings;\n    }\n\n    /**\n     * @dev accept ETH\n     */\n    receive() external payable {}\n\n    /**\n     * @dev transfers the ownership of the store\n     *\n     * Requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function transferStoreOwnership(address newOwner) external ownerOnly {\n        _store.transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev accepts the ownership of the store\n     *\n     * Requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function acceptStoreOwnership() external ownerOnly {\n        _store.acceptOwnership();\n    }\n\n    /**\n     * @dev transfers the ownership of the wallet\n     *\n     * Requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function transferWalletOwnership(address newOwner) external ownerOnly {\n        _wallet.transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev accepts the ownership of the wallet\n     *\n     * Requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function acceptWalletOwnership() external ownerOnly {\n        _wallet.acceptOwnership();\n    }\n\n    /**\n     * @dev adds protected liquidity to a pool for a specific recipient, mints new governance tokens for the caller\n     * if the caller adds network tokens, and returns the new position id\n     */\n    function addLiquidityFor(\n        address owner,\n        IConverterAnchor poolAnchor,\n        IReserveToken reserveToken,\n        uint256 amount\n    )\n        external\n        payable\n        override\n        nonReentrant\n        validAddress(owner)\n        poolSupportedAndWhitelisted(poolAnchor)\n        addLiquidityEnabled(poolAnchor, reserveToken)\n        greaterThanZero(amount)\n        returns (uint256)\n    {\n        return _addLiquidity(owner, poolAnchor, reserveToken, amount);\n    }\n\n    /**\n     * @dev adds protected liquidity to a pool, mints new governance tokens for the caller if the caller adds network\n     * tokens, and returns the new position id\n     */\n    function addLiquidity(\n        IConverterAnchor poolAnchor,\n        IReserveToken reserveToken,\n        uint256 amount\n    )\n        external\n        payable\n        override\n        nonReentrant\n        poolSupportedAndWhitelisted(poolAnchor)\n        addLiquidityEnabled(poolAnchor, reserveToken)\n        greaterThanZero(amount)\n        returns (uint256)\n    {\n        return _addLiquidity(msg.sender, poolAnchor, reserveToken, amount);\n    }\n\n    /**\n     * @dev adds protected liquidity to a pool for a specific recipient, mints new governance tokens for the caller if\n     * the caller adds network tokens, and returns the new position id\n     */\n    function _addLiquidity(\n        address owner,\n        IConverterAnchor poolAnchor,\n        IReserveToken reserveToken,\n        uint256 amount\n    ) private returns (uint256) {\n        if (_isNetworkToken(reserveToken)) {\n            _verifyEthAmount(0);\n\n            return _addNetworkTokenLiquidity(owner, poolAnchor, amount);\n        }\n\n        // verify that ETH was passed with the call if needed\n        _verifyEthAmount(reserveToken.isNativeToken() ? amount : 0);\n\n        return _addBaseTokenLiquidity(owner, poolAnchor, reserveToken, amount);\n    }\n\n    /**\n     * @dev adds network token liquidity to a pool, mints new governance tokens for the caller, and returns the new ]\n     * position id\n     */\n    function _addNetworkTokenLiquidity(\n        address owner,\n        IConverterAnchor poolAnchor,\n        uint256 amount\n    ) internal returns (uint256) {\n        IDSToken poolToken = IDSToken(address(poolAnchor));\n        IReserveToken networkToken = IReserveToken(address(_networkToken));\n\n        // get the rate between the pool token and the reserve\n        Fraction memory poolRate = _poolTokenRate(poolToken, networkToken);\n\n        // calculate the amount of pool tokens based on the amount of reserve tokens\n        uint256 poolTokenAmount = _mulDivF(amount, poolRate.d, poolRate.n);\n\n        // remove the pool tokens from the system's ownership (will revert if not enough tokens are available)\n        _systemStore.decSystemBalance(poolToken, poolTokenAmount);\n\n        // add the position for the recipient\n        uint256 id = _addPosition(owner, poolToken, networkToken, poolTokenAmount, amount, _time());\n\n        // burns the network tokens from the caller. we need to transfer the tokens to the contract itself, since only\n        // token holders can burn their tokens\n        _networkToken.safeTransferFrom(msg.sender, address(this), amount);\n        _burnNetworkTokens(poolAnchor, amount);\n\n        // mint governance tokens to the recipient\n        _govTokenGovernance.mint(owner, amount);\n\n        return id;\n    }\n\n    /**\n     * @dev adds base token liquidity to a pool\n     */\n    function _addBaseTokenLiquidity(\n        address owner,\n        IConverterAnchor poolAnchor,\n        IReserveToken baseToken,\n        uint256 amount\n    ) internal returns (uint256) {\n        IDSToken poolToken = IDSToken(address(poolAnchor));\n        IReserveToken networkToken = IReserveToken(address(_networkToken));\n\n        // get the reserve balances\n        ILiquidityPoolConverter converter = ILiquidityPoolConverter(payable(_ownedBy(poolAnchor)));\n        (uint256 reserveBalanceBase, uint256 reserveBalanceNetwork) = _converterReserveBalances(\n            converter,\n            baseToken,\n            networkToken\n        );\n\n        require(reserveBalanceNetwork >= _settings.minNetworkTokenLiquidityForMinting(), \"ERR_NOT_ENOUGH_LIQUIDITY\");\n\n        // calculate and mint the required amount of network tokens for adding liquidity\n        uint256 newNetworkLiquidityAmount = _mulDivF(amount, reserveBalanceNetwork, reserveBalanceBase);\n\n        // get network token minting limit\n        uint256 mintingLimit = _networkTokenMintingLimit(poolAnchor);\n\n        uint256 newNetworkTokensMinted = _systemStore.networkTokensMinted(poolAnchor).add(newNetworkLiquidityAmount);\n        require(newNetworkTokensMinted <= mintingLimit, \"ERR_MAX_AMOUNT_REACHED\");\n\n        // issue new network tokens to the system\n        _mintNetworkTokens(address(this), poolAnchor, newNetworkLiquidityAmount);\n\n        // transfer the base tokens from the caller and approve the converter\n        networkToken.ensureApprove(address(converter), newNetworkLiquidityAmount);\n\n        if (!baseToken.isNativeToken()) {\n            baseToken.safeTransferFrom(msg.sender, address(this), amount);\n            baseToken.ensureApprove(address(converter), amount);\n        }\n\n        // add the liquidity to the converter\n        _addLiquidity(converter, baseToken, networkToken, amount, newNetworkLiquidityAmount, msg.value);\n\n        // transfer the new pool tokens to the wallet\n        uint256 poolTokenAmount = poolToken.balanceOf(address(this));\n        poolToken.safeTransfer(address(_wallet), poolTokenAmount);\n\n        // the system splits the pool tokens with the caller\n        // increase the system's pool token balance and add the position for the caller\n        _systemStore.incSystemBalance(poolToken, poolTokenAmount - poolTokenAmount / 2); // account for rounding errors\n\n        return _addPosition(owner, poolToken, baseToken, poolTokenAmount / 2, amount, _time());\n    }\n\n    /**\n     * @dev returns the single-side staking base and network token limits of a given pool\n     */\n    function poolAvailableSpace(IConverterAnchor poolAnchor)\n        external\n        view\n        poolSupportedAndWhitelisted(poolAnchor)\n        returns (uint256, uint256)\n    {\n        return (_baseTokenAvailableSpace(poolAnchor), _networkTokenAvailableSpace(poolAnchor));\n    }\n\n    /**\n     * @dev returns the base token staking limits of a given pool\n     */\n    function _baseTokenAvailableSpace(IConverterAnchor poolAnchor) internal view returns (uint256) {\n        // get the pool converter\n        ILiquidityPoolConverter converter = ILiquidityPoolConverter(payable(_ownedBy(poolAnchor)));\n\n        // get the base token\n        IReserveToken networkToken = IReserveToken(address(_networkToken));\n        IReserveToken baseToken = _converterOtherReserve(converter, networkToken);\n\n        // get the reserve balances\n        (uint256 reserveBalanceBase, uint256 reserveBalanceNetwork) = _converterReserveBalances(\n            converter,\n            baseToken,\n            networkToken\n        );\n\n        // get the network token minting limit\n        uint256 mintingLimit = _networkTokenMintingLimit(poolAnchor);\n\n        // get the amount of network tokens already minted for the pool\n        uint256 networkTokensMinted = _systemStore.networkTokensMinted(poolAnchor);\n\n        // get the amount of network tokens which can minted for the pool\n        uint256 networkTokensCanBeMinted = Math.max(mintingLimit, networkTokensMinted) - networkTokensMinted;\n\n        // return the maximum amount of base token liquidity that can be single-sided staked in the pool\n        return _mulDivF(networkTokensCanBeMinted, reserveBalanceBase, reserveBalanceNetwork);\n    }\n\n    /**\n     * @dev returns the network token staking limits of a given pool\n     */\n    function _networkTokenAvailableSpace(IConverterAnchor poolAnchor) internal view returns (uint256) {\n        // get the pool token\n        IDSToken poolToken = IDSToken(address(poolAnchor));\n        IReserveToken networkToken = IReserveToken(address(_networkToken));\n\n        // get the pool token rate\n        Fraction memory poolRate = _poolTokenRate(poolToken, networkToken);\n\n        // return the maximum amount of network token liquidity that can be single-sided staked in the pool\n        return _systemStore.systemBalance(poolToken).mul(poolRate.n).add(poolRate.n).sub(1).div(poolRate.d);\n    }\n\n    /**\n     * @dev returns the expected, actual, and network token compensation amounts the provider will receive for removing\n     * liquidity\n     *\n     * note that it's also possible to provide the remove liquidity time to get an estimation for the return at that\n     * given point\n     */\n    function removeLiquidityReturn(\n        uint256 id,\n        uint32 portion,\n        uint256 removeTimestamp\n    )\n        external\n        view\n        removeLiquidityEnabled\n        validPortion(portion)\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        Position memory pos = _position(id);\n\n        require(pos.provider != address(0), \"ERR_INVALID_ID\");\n        require(removeTimestamp >= pos.timestamp, \"ERR_INVALID_TIMESTAMP\");\n\n        // calculate the portion of the liquidity to remove\n        if (portion != PPM_RESOLUTION) {\n            (pos.poolAmount, pos.reserveAmount) = _portionAmounts(pos.poolAmount, pos.reserveAmount, portion);\n        }\n\n        // get the various rates between the reserves upon adding liquidity and now\n        PackedRates memory packedRates = _packRates(\n            pos.poolToken,\n            pos.reserveToken,\n            pos.reserveRateN,\n            pos.reserveRateD\n        );\n\n        uint256 targetAmount = _removeLiquidityTargetAmount(\n            pos.poolToken,\n            pos.reserveToken,\n            pos.poolAmount,\n            pos.reserveAmount,\n            packedRates,\n            pos.timestamp,\n            removeTimestamp\n        );\n\n        // for network token, the return amount is identical to the target amount\n        if (_isNetworkToken(pos.reserveToken)) {\n            return (targetAmount, targetAmount, 0);\n        }\n\n        // handle base token return\n\n        // calculate the amount of pool tokens required for liquidation\n        // note that the amount is doubled since it's not possible to liquidate one reserve only\n        Fraction memory poolRate = _poolTokenRate(pos.poolToken, pos.reserveToken);\n        uint256 poolAmount = _liquidationAmount(targetAmount, poolRate, pos.poolToken, pos.poolAmount);\n\n        // calculate the base token amount received by liquidating the pool tokens\n        // note that the amount is divided by 2 since the pool amount represents both reserves\n        uint256 baseAmount = _mulDivF(poolAmount, poolRate.n, poolRate.d.mul(2));\n        uint256 networkAmount = _networkCompensation(targetAmount, baseAmount, packedRates);\n\n        return (targetAmount, baseAmount, networkAmount);\n    }\n\n    /**\n     * @dev removes protected liquidity from a pool and also burns governance tokens from the caller if the caller\n     * removes network tokens\n     */\n    function removeLiquidity(uint256 id, uint32 portion)\n        external\n        override\n        nonReentrant\n        removeLiquidityEnabled\n        validPortion(portion)\n    {\n        _removeLiquidity(msg.sender, id, portion);\n    }\n\n    /**\n     * @dev removes a position from a pool and burns governance tokens from the caller if the caller removes network tokens\n     */\n    function _removeLiquidity(\n        address payable provider,\n        uint256 id,\n        uint32 portion\n    ) internal {\n        // remove the position from the store and update the stats\n        Position memory removedPos = _removePosition(provider, id, portion);\n\n        // add the pool tokens to the system\n        _systemStore.incSystemBalance(removedPos.poolToken, removedPos.poolAmount);\n\n        // if removing network token liquidity, burn the governance tokens from the caller. we need to transfer the\n        // tokens to the contract itself, since only token holders can burn their tokens\n        if (_isNetworkToken(removedPos.reserveToken)) {\n            _govToken.safeTransferFrom(provider, address(this), removedPos.reserveAmount);\n            _govTokenGovernance.burn(removedPos.reserveAmount);\n        }\n\n        // get the various rates between the reserves upon adding liquidity and now\n        PackedRates memory packedRates = _packRates(\n            removedPos.poolToken,\n            removedPos.reserveToken,\n            removedPos.reserveRateN,\n            removedPos.reserveRateD\n        );\n\n        // verify rate deviation as early as possible in order to reduce gas-cost for failing transactions\n        _verifyRateDeviation(\n            packedRates.removeSpotRateN,\n            packedRates.removeSpotRateD,\n            packedRates.removeAverageRateN,\n            packedRates.removeAverageRateD\n        );\n\n        // get the target token amount\n        uint256 targetAmount = _removeLiquidityTargetAmount(\n            removedPos.poolToken,\n            removedPos.reserveToken,\n            removedPos.poolAmount,\n            removedPos.reserveAmount,\n            packedRates,\n            removedPos.timestamp,\n            _time()\n        );\n\n        // remove network token liquidity\n        if (_isNetworkToken(removedPos.reserveToken)) {\n            // mint network tokens for the caller and lock them\n            _mintNetworkTokens(address(_wallet), removedPos.poolToken, targetAmount);\n            _lockTokens(provider, targetAmount);\n            return;\n        }\n\n        // remove base token liquidity\n\n        // calculate the amount of pool tokens required for liquidation\n        // note that the amount is doubled since it's not possible to liquidate one reserve only\n        Fraction memory poolRate = _poolTokenRate(removedPos.poolToken, removedPos.reserveToken);\n        uint256 poolAmount = _liquidationAmount(targetAmount, poolRate, removedPos.poolToken, 0);\n\n        // withdraw the pool tokens from the wallet\n        _withdrawPoolTokens(removedPos.poolToken, poolAmount);\n\n        // remove liquidity\n        _removeLiquidity(\n            removedPos.poolToken,\n            poolAmount,\n            removedPos.reserveToken,\n            IReserveToken(address(_networkToken))\n        );\n\n        // transfer the base tokens to the caller\n        uint256 baseBalance = removedPos.reserveToken.balanceOf(address(this));\n        removedPos.reserveToken.safeTransfer(provider, baseBalance);\n\n        // compensate the caller with network tokens if still needed\n        uint256 delta = _networkCompensation(targetAmount, baseBalance, packedRates);\n        if (delta > 0) {\n            // check if there's enough network token balance, otherwise mint more\n            uint256 networkBalance = _networkToken.balanceOf(address(this));\n            if (networkBalance < delta) {\n                _networkTokenGovernance.mint(address(this), delta - networkBalance);\n            }\n\n            // lock network tokens for the caller\n            _networkToken.safeTransfer(address(_wallet), delta);\n            _lockTokens(provider, delta);\n        }\n\n        // if the contract still holds network tokens, burn them\n        uint256 networkBalance = _networkToken.balanceOf(address(this));\n        if (networkBalance > 0) {\n            _burnNetworkTokens(removedPos.poolToken, networkBalance);\n        }\n    }\n\n    /**\n     * @dev migrates a set of position lists to v3\n     *\n     * Requirements:\n     *\n     * - the caller must be the owner of all of the positions\n     */\n    function migratePositions(PositionList[] calldata positionLists) external nonReentrant {\n        uint256 length = positionLists.length;\n        for (uint256 i = 0; i < length; ++i) {\n            _migratePositions(positionLists[i]);\n        }\n    }\n\n    /**\n     * @dev migrates a list of positions to v3\n     *\n     * Requirements:\n     *\n     * - the caller must be the owner of all of the positions\n     */\n    function _migratePositions(PositionList calldata positionList) internal {\n        IDSToken poolToken = positionList.poolToken;\n        IReserveToken reserveToken = positionList.reserveToken;\n\n        Fraction memory poolRate = _poolTokenRate(poolToken, reserveToken);\n\n        (Fraction memory removeSpotRate, Fraction memory removeAverageRate) = _reserveTokenRates(\n            poolToken,\n            reserveToken\n        );\n\n        // verify rate deviation as early as possible in order to reduce gas-cost for failing transactions\n        _verifyRateDeviation(removeSpotRate.n, removeSpotRate.d, removeAverageRate.n, removeAverageRate.d);\n\n        uint256 poolTokenAmount = 0;\n        uint256 originalAmount = 0;\n        uint256 fullyProtectedAmount = 0;\n\n        uint256 length = positionList.positionIds.length;\n        for (uint256 i = 0; i < length; ++i) {\n            Position memory removedPos = _removePosition(msg.sender, positionList.positionIds[i], PPM_RESOLUTION);\n            require(\n                removedPos.poolToken == poolToken && removedPos.reserveToken == reserveToken,\n                \"ERR_INVALID_POSITION_LIST\"\n            );\n\n            // collect pool token amounts\n            poolTokenAmount = poolTokenAmount.add(removedPos.poolAmount);\n\n            // collect originally provided amounts\n            originalAmount = originalAmount.add(removedPos.reserveAmount);\n\n            // get the various rates between the reserves upon adding liquidity and now\n            PackedRates memory packedRates = _packRates(\n                removedPos.reserveRateN,\n                removedPos.reserveRateD,\n                removeSpotRate,\n                removeAverageRate\n            );\n\n            // get the fully protected amount (+ fees)\n            fullyProtectedAmount = fullyProtectedAmount.add(\n                _removeLiquidityTargetAmount(\n                    poolRate,\n                    removedPos.poolAmount,\n                    removedPos.reserveAmount,\n                    packedRates,\n                    Fraction({ n: 1, d: 1 })\n                )\n            );\n        }\n\n        // add the pool tokens to the system\n        _systemStore.incSystemBalance(poolToken, poolTokenAmount);\n\n        // remove network token liquidity\n        if (_isNetworkToken(reserveToken)) {\n            // mint the fully protected amount (+ fees) and migrate it\n            _mintNetworkTokens(address(this), poolToken, fullyProtectedAmount);\n\n            _networkToken.approve(address(_networkV3), fullyProtectedAmount);\n\n            _networkV3.migrateLiquidity(\n                IReserveToken(address(_networkToken)),\n                msg.sender,\n                fullyProtectedAmount,\n                fullyProtectedAmount,\n                originalAmount\n            );\n\n            return;\n        }\n\n        // remove base token liquidity\n\n        // calculate the amount of pool tokens required for liquidation\n        // note that the amount is doubled since it's not possible to liquidate one reserve only\n        uint256 poolLiquidationAmount = _liquidationAmount(fullyProtectedAmount, poolRate, poolToken, 0);\n\n        // withdraw the pool tokens from the wallet\n        _withdrawPoolTokens(poolToken, poolLiquidationAmount);\n\n        // remove liquidity\n        _removeLiquidity(poolToken, poolLiquidationAmount, reserveToken, IReserveToken(address(_networkToken)));\n\n        // migrate the received tokens\n        uint256 removedAmount = reserveToken.balanceOf(address(this));\n        uint256 value;\n        if (reserveToken.isNativeToken()) {\n            value = removedAmount;\n        } else {\n            IERC20(address(reserveToken)).safeApprove(address(_networkV3), removedAmount);\n        }\n        _networkV3.migrateLiquidity{ value: value }(\n            reserveToken,\n            msg.sender,\n            fullyProtectedAmount,\n            removedAmount,\n            originalAmount\n        );\n\n        // if the contract still holds network tokens, burn them\n        uint256 networkBalance = _networkToken.balanceOf(address(this));\n        if (networkBalance > 0) {\n            _burnNetworkTokens(poolToken, networkBalance);\n        }\n    }\n\n    /**\n     * @dev returns the amount the provider will receive for removing liquidity\n     */\n    function _removeLiquidityTargetAmount(\n        IDSToken poolToken,\n        IReserveToken reserveToken,\n        uint256 poolAmount,\n        uint256 reserveAmount,\n        PackedRates memory packedRates,\n        uint256 addTimestamp,\n        uint256 removeTimestamp\n    ) internal view returns (uint256) {\n        // get the rate between the pool token and the reserve token\n        Fraction memory poolRate = _poolTokenRate(poolToken, reserveToken);\n\n        // calculate the protection level\n        Fraction memory level = _protectionLevel(addTimestamp, removeTimestamp);\n\n        return _removeLiquidityTargetAmount(poolRate, poolAmount, reserveAmount, packedRates, level);\n    }\n\n    /**\n     * @dev returns the amount the provider will receive for removing liquidity\n     */\n    function _removeLiquidityTargetAmount(\n        Fraction memory poolRate,\n        uint256 poolAmount,\n        uint256 reserveAmount,\n        PackedRates memory packedRates,\n        Fraction memory level\n    ) internal pure returns (uint256) {\n        // get the rate between the reserves upon adding liquidity and now\n        Fraction memory addSpotRate = Fraction({ n: packedRates.addSpotRateN, d: packedRates.addSpotRateD });\n        Fraction memory removeSpotRate = Fraction({ n: packedRates.removeSpotRateN, d: packedRates.removeSpotRateD });\n        Fraction memory removeAverageRate = Fraction({\n            n: packedRates.removeAverageRateN,\n            d: packedRates.removeAverageRateD\n        });\n\n        // calculate the protected amount of reserve tokens plus accumulated fee before compensation\n        uint256 total = _protectedAmountPlusFee(poolAmount, poolRate, addSpotRate, removeSpotRate);\n\n        // calculate the impermanent loss\n        Fraction memory loss = _impLoss(addSpotRate, removeAverageRate);\n\n        // calculate the compensation amount\n        return _compensationAmount(reserveAmount, Math.max(reserveAmount, total), loss, level);\n    }\n\n    /**\n     * @dev transfers a position to a new provider\n     *\n     * Requirements:\n     *\n     * - the caller must be the owner of the position\n     */\n    function transferPosition(uint256 id, address newProvider)\n        external\n        override\n        nonReentrant\n        validAddress(newProvider)\n        returns (uint256)\n    {\n        return _transferPosition(msg.sender, id, newProvider);\n    }\n\n    /**\n     * @dev transfers a position to a new provider and optionally notifies another contract\n     *\n     * Requirements:\n     *\n     * - the caller must be the owner of the position\n     */\n    function transferPositionAndNotify(\n        uint256 id,\n        address newProvider,\n        ITransferPositionCallback callback,\n        bytes calldata data\n    ) external override nonReentrant validAddress(newProvider) validAddress(address(callback)) returns (uint256) {\n        uint256 newId = _transferPosition(msg.sender, id, newProvider);\n\n        callback.onTransferPosition(newId, msg.sender, data);\n\n        return newId;\n    }\n\n    /**\n     * @dev migrates system pool tokens to v3\n     *\n     * Requirements:\n     *\n     * - the caller must be the owner of this contract\n     */\n    function migrateSystemPoolTokens(IConverterAnchor[] calldata poolAnchors) external nonReentrant ownerOnly {\n        uint256 length = poolAnchors.length;\n        for (uint256 i = 0; i < length; i++) {\n            IDSToken poolToken = IDSToken(address(poolAnchors[i]));\n            uint256 poolAmount = _systemStore.systemBalance(poolToken);\n\n            _withdrawPoolTokens(poolToken, poolAmount);\n\n            ILiquidityPoolConverter converter = ILiquidityPoolConverter(payable(_ownedBy(poolToken)));\n            (IReserveToken[] memory reserveTokens, uint256[] memory minReturns) = _removeLiquidityInput(\n                IReserveToken(address(_networkToken)),\n                _converterOtherReserve(converter, IReserveToken(address(_networkToken)))\n            );\n\n            uint256[] memory reserveAmounts = converter.removeLiquidity(poolAmount, reserveTokens, minReturns);\n\n            _burnNetworkTokens(poolAnchors[i], reserveAmounts[0]);\n            if (reserveTokens[1].isNativeToken()) {\n                _vaultV3.sendValue(reserveAmounts[1]);\n            } else {\n                reserveTokens[1].safeTransfer(_vaultV3, reserveAmounts[1]);\n            }\n        }\n    }\n\n    /**\n     * @dev transfers a position to a new provider\n     */\n    function _transferPosition(\n        address provider,\n        uint256 id,\n        address newProvider\n    ) internal returns (uint256) {\n        // remove the position from the store and update the stats\n        Position memory removedPos = _removePosition(provider, id, PPM_RESOLUTION);\n\n        // add the position to the store, update the stats, and return the new id\n        return\n            _addPosition(\n                newProvider,\n                removedPos.poolToken,\n                removedPos.reserveToken,\n                removedPos.poolAmount,\n                removedPos.reserveAmount,\n                removedPos.timestamp\n            );\n    }\n\n    /**\n     * @dev allows the caller to claim network token balance that is no longer locked\n     *\n     * note that the function can revert if the range is too large\n     */\n    function claimBalance(uint256 startIndex, uint256 endIndex) external nonReentrant {\n        // get the locked balances from the store\n        (uint256[] memory amounts, uint256[] memory expirationTimes) = _store.lockedBalanceRange(\n            msg.sender,\n            startIndex,\n            endIndex\n        );\n\n        uint256 totalAmount = 0;\n        uint256 length = amounts.length;\n        assert(length == expirationTimes.length);\n\n        // reverse iteration since we're removing from the list\n        for (uint256 i = length; i > 0; i--) {\n            uint256 index = i - 1;\n            if (expirationTimes[index] > _time()) {\n                continue;\n            }\n\n            // remove the locked balance item\n            _store.removeLockedBalance(msg.sender, startIndex + index);\n            totalAmount = totalAmount.add(amounts[index]);\n        }\n\n        if (totalAmount > 0) {\n            // transfer the tokens to the caller in a single call\n            _wallet.withdrawTokens(IReserveToken(address(_networkToken)), msg.sender, totalAmount);\n        }\n    }\n\n    /**\n     * @dev returns the ROI for removing liquidity in the current state after providing liquidity with the given args\n     *\n     * note that the function assumes full protection is in effect and that the return value is in PPM and can be\n     * larger than PPM_RESOLUTION for positive ROI, 1M = 0% ROI\n     */\n    function poolROI(\n        IDSToken poolToken,\n        IReserveToken reserveToken,\n        uint256 reserveAmount,\n        uint256 poolRateN,\n        uint256 poolRateD,\n        uint256 reserveRateN,\n        uint256 reserveRateD\n    ) external view returns (uint256) {\n        // calculate the amount of pool tokens based on the amount of reserve tokens\n        uint256 poolAmount = _mulDivF(reserveAmount, poolRateD, poolRateN);\n\n        // get the various rates between the reserves upon adding liquidity and now\n        PackedRates memory packedRates = _packRates(poolToken, reserveToken, reserveRateN, reserveRateD);\n\n        // get the current return\n        uint256 protectedReturn = _removeLiquidityTargetAmount(\n            poolToken,\n            reserveToken,\n            poolAmount,\n            reserveAmount,\n            packedRates,\n            _time().sub(_settings.maxProtectionDelay()),\n            _time()\n        );\n\n        // calculate the ROI as the ratio between the current fully protected return and the initial amount\n        return _mulDivF(protectedReturn, PPM_RESOLUTION, reserveAmount);\n    }\n\n    /**\n     * @dev adds the position to the store and updates the stats\n     */\n    function _addPosition(\n        address provider,\n        IDSToken poolToken,\n        IReserveToken reserveToken,\n        uint256 poolAmount,\n        uint256 reserveAmount,\n        uint256 timestamp\n    ) internal returns (uint256) {\n        // verify rate deviation as early as possible in order to reduce gas-cost for failing transactions\n        (Fraction memory spotRate, Fraction memory averageRate) = _reserveTokenRates(poolToken, reserveToken);\n        _verifyRateDeviation(spotRate.n, spotRate.d, averageRate.n, averageRate.d);\n\n        _stats.increaseTotalAmounts(provider, poolToken, reserveToken, poolAmount, reserveAmount);\n        _stats.addProviderPool(provider, poolToken);\n\n        return\n            _store.addProtectedLiquidity(\n                provider,\n                poolToken,\n                reserveToken,\n                poolAmount,\n                reserveAmount,\n                spotRate.n,\n                spotRate.d,\n                timestamp\n            );\n    }\n\n    /**\n     * @dev removes the position from the store and updates the stats\n     */\n    function _removePosition(\n        address provider,\n        uint256 id,\n        uint32 portion\n    ) private returns (Position memory) {\n        Position memory pos = _providerPosition(id, provider);\n\n        // verify that the pool is whitelisted\n        _poolWhitelisted(pos.poolToken);\n\n        // verify that the position is not removed on the same block in which it was added\n        require(pos.timestamp < _time(), \"ERR_TOO_EARLY\");\n\n        if (portion == PPM_RESOLUTION) {\n            // remove the position from the provider\n            _store.removeProtectedLiquidity(id);\n        } else {\n            // remove a portion of the position from the provider\n            uint256 fullPoolAmount = pos.poolAmount;\n            uint256 fullReserveAmount = pos.reserveAmount;\n            (pos.poolAmount, pos.reserveAmount) = _portionAmounts(pos.poolAmount, pos.reserveAmount, portion);\n\n            _store.updateProtectedLiquidityAmounts(\n                id,\n                fullPoolAmount - pos.poolAmount,\n                fullReserveAmount - pos.reserveAmount\n            );\n        }\n\n        // update the statistics\n        _stats.decreaseTotalAmounts(pos.provider, pos.poolToken, pos.reserveToken, pos.poolAmount, pos.reserveAmount);\n\n        return pos;\n    }\n\n    /**\n     * @dev locks network tokens for the provider and emits the tokens locked event\n     */\n    function _lockTokens(address provider, uint256 amount) internal {\n        uint256 expirationTime = _time().add(_settings.lockDuration());\n        _store.addLockedBalance(provider, amount, expirationTime);\n    }\n\n    /**\n     * @dev returns the rate of 1 pool token in reserve token units\n     */\n    function _poolTokenRate(IDSToken poolToken, IReserveToken reserveToken)\n        internal\n        view\n        virtual\n        returns (Fraction memory)\n    {\n        // get the pool token supply\n        uint256 poolTokenSupply = poolToken.totalSupply();\n\n        // get the reserve balance\n        IConverter converter = IConverter(payable(_ownedBy(poolToken)));\n        uint256 reserveBalance = converter.getConnectorBalance(reserveToken);\n\n        // for standard pools, 50% of the pool supply value equals the value of each reserve\n        return Fraction({ n: reserveBalance.mul(2), d: poolTokenSupply });\n    }\n\n    /**\n     * @dev returns the spot rate and average rate of 1 reserve token in the other reserve token units\n     */\n    function _reserveTokenRates(IDSToken poolToken, IReserveToken reserveToken)\n        internal\n        view\n        returns (Fraction memory, Fraction memory)\n    {\n        ILiquidityPoolConverter converter = ILiquidityPoolConverter(payable(_ownedBy(poolToken)));\n        IReserveToken otherReserve = _converterOtherReserve(converter, reserveToken);\n\n        (uint256 spotRateN, uint256 spotRateD) = _converterReserveBalances(converter, otherReserve, reserveToken);\n        (uint256 averageRateN, uint256 averageRateD) = converter.recentAverageRate(reserveToken);\n\n        return (Fraction({ n: spotRateN, d: spotRateD }), Fraction({ n: averageRateN, d: averageRateD }));\n    }\n\n    /**\n     * @dev returns the various rates between the reserves\n     */\n    function _packRates(\n        IDSToken poolToken,\n        IReserveToken reserveToken,\n        uint256 addSpotRateN,\n        uint256 addSpotRateD\n    ) internal view returns (PackedRates memory) {\n        (Fraction memory removeSpotRate, Fraction memory removeAverageRate) = _reserveTokenRates(\n            poolToken,\n            reserveToken\n        );\n\n        assert((removeSpotRate.n | removeSpotRate.d | removeAverageRate.n | removeAverageRate.d) <= MAX_UINT128);\n\n        return _packRates(addSpotRateN, addSpotRateD, removeSpotRate, removeAverageRate);\n    }\n\n    /**\n     * @dev returns the various rates between the reserves\n     */\n    function _packRates(\n        uint256 addSpotRateN,\n        uint256 addSpotRateD,\n        Fraction memory removeSpotRate,\n        Fraction memory removeAverageRate\n    ) internal pure returns (PackedRates memory) {\n        assert((addSpotRateN | addSpotRateD) <= MAX_UINT128);\n\n        return\n            PackedRates({\n                addSpotRateN: uint128(addSpotRateN),\n                addSpotRateD: uint128(addSpotRateD),\n                removeSpotRateN: uint128(removeSpotRate.n),\n                removeSpotRateD: uint128(removeSpotRate.d),\n                removeAverageRateN: uint128(removeAverageRate.n),\n                removeAverageRateD: uint128(removeAverageRate.d)\n            });\n    }\n\n    /**\n     * @dev verifies that the deviation of the average rate from the spot rate is within the permitted range\n     *\n     * for example, if the maximum permitted deviation is 5%, then verify `95/100 <= average/spot <= 100/95`\n     */\n    function _verifyRateDeviation(\n        uint256 spotRateN,\n        uint256 spotRateD,\n        uint256 averageRateN,\n        uint256 averageRateD\n    ) internal view {\n        uint256 ppmDelta = PPM_RESOLUTION - _settings.averageRateMaxDeviation();\n        uint256 min = spotRateN.mul(averageRateD).mul(ppmDelta).mul(ppmDelta);\n        uint256 mid = spotRateD.mul(averageRateN).mul(ppmDelta).mul(PPM_RESOLUTION);\n        uint256 max = spotRateN.mul(averageRateD).mul(PPM_RESOLUTION).mul(PPM_RESOLUTION);\n        require(min <= mid && mid <= max, \"ERR_INVALID_RATE\");\n    }\n\n    /**\n     * @dev utility to add liquidity to a converter\n     */\n    function _addLiquidity(\n        ILiquidityPoolConverter converter,\n        IReserveToken reserveToken1,\n        IReserveToken reserveToken2,\n        uint256 reserveAmount1,\n        uint256 reserveAmount2,\n        uint256 value\n    ) internal {\n        IReserveToken[] memory reserveTokens = new IReserveToken[](2);\n        uint256[] memory amounts = new uint256[](2);\n        reserveTokens[0] = reserveToken1;\n        reserveTokens[1] = reserveToken2;\n        amounts[0] = reserveAmount1;\n        amounts[1] = reserveAmount2;\n        converter.addLiquidity{ value: value }(reserveTokens, amounts, 1);\n    }\n\n    /**\n     * @dev utility to remove liquidity from a converter\n     */\n    function _removeLiquidity(\n        IDSToken poolToken,\n        uint256 poolAmount,\n        IReserveToken reserveToken1,\n        IReserveToken reserveToken2\n    ) internal {\n        ILiquidityPoolConverter converter = ILiquidityPoolConverter(payable(_ownedBy(poolToken)));\n        (IReserveToken[] memory reserveTokens, uint256[] memory minReturns) = _removeLiquidityInput(\n            reserveToken1,\n            reserveToken2\n        );\n        converter.removeLiquidity(poolAmount, reserveTokens, minReturns);\n    }\n\n    /**\n     * @dev returns a position from the store\n     */\n    function _position(uint256 id) internal view returns (Position memory) {\n        Position memory pos;\n        (\n            pos.provider,\n            pos.poolToken,\n            pos.reserveToken,\n            pos.poolAmount,\n            pos.reserveAmount,\n            pos.reserveRateN,\n            pos.reserveRateD,\n            pos.timestamp\n        ) = _store.protectedLiquidity(id);\n\n        return pos;\n    }\n\n    /**\n     * @dev returns a position from the store\n     */\n    function _providerPosition(uint256 id, address provider) internal view returns (Position memory) {\n        Position memory pos = _position(id);\n        require(pos.provider == provider, \"ERR_ACCESS_DENIED\");\n\n        return pos;\n    }\n\n    /**\n     * @dev returns the protected amount of reserve tokens plus accumulated fee before compensation\n     */\n    function _protectedAmountPlusFee(\n        uint256 poolAmount,\n        Fraction memory poolRate,\n        Fraction memory addRate,\n        Fraction memory removeRate\n    ) internal pure returns (uint256) {\n        uint256 n = MathEx.ceilSqrt(addRate.d.mul(removeRate.n)).mul(poolRate.n);\n        uint256 d = MathEx.floorSqrt(addRate.n.mul(removeRate.d)).mul(poolRate.d);\n\n        uint256 x = n * poolAmount;\n        if (x / n == poolAmount) {\n            return x / d;\n        }\n\n        (uint256 hi, uint256 lo) = n > poolAmount ? (n, poolAmount) : (poolAmount, n);\n        (uint256 p, uint256 q) = MathEx.reducedRatio(hi, d, MAX_UINT256 / lo);\n        uint256 min = (hi / d).mul(lo);\n\n        if (q > 0) {\n            return Math.max(min, (p * lo) / q);\n        }\n        return min;\n    }\n\n    /**\n     * @dev returns the impermanent loss incurred due to the change in rates between the reserve tokens\n     */\n    function _impLoss(Fraction memory prevRate, Fraction memory newRate) internal pure returns (Fraction memory) {\n        uint256 ratioN = newRate.n.mul(prevRate.d);\n        uint256 ratioD = newRate.d.mul(prevRate.n);\n\n        uint256 prod = ratioN * ratioD;\n        uint256 root = prod / ratioN == ratioD\n            ? MathEx.floorSqrt(prod)\n            : MathEx.floorSqrt(ratioN) * MathEx.floorSqrt(ratioD);\n        uint256 sum = ratioN.add(ratioD);\n\n        // the arithmetic below is safe because `x + y >= sqrt(x * y) * 2`\n        if (sum % 2 == 0) {\n            sum /= 2;\n            return Fraction({ n: sum - root, d: sum });\n        }\n        return Fraction({ n: sum - root * 2, d: sum });\n    }\n\n    /**\n     * @dev returns the protection level based on the timestamp and protection delays\n     */\n    function _protectionLevel(uint256 addTimestamp, uint256 removeTimestamp) internal view returns (Fraction memory) {\n        uint256 timeElapsed = removeTimestamp.sub(addTimestamp);\n        uint256 minProtectionDelay = _settings.minProtectionDelay();\n        uint256 maxProtectionDelay = _settings.maxProtectionDelay();\n        if (timeElapsed < minProtectionDelay) {\n            return Fraction({ n: 0, d: 1 });\n        }\n\n        if (timeElapsed >= maxProtectionDelay) {\n            return Fraction({ n: 1, d: 1 });\n        }\n\n        return Fraction({ n: timeElapsed, d: maxProtectionDelay });\n    }\n\n    /**\n     * @dev returns the compensation amount based on the impermanent loss and the protection level\n     */\n    function _compensationAmount(\n        uint256 amount,\n        uint256 total,\n        Fraction memory loss,\n        Fraction memory level\n    ) internal pure returns (uint256) {\n        uint256 levelN = level.n.mul(amount);\n        uint256 levelD = level.d;\n        uint256 maxVal = Math.max(Math.max(levelN, levelD), total);\n        (uint256 lossN, uint256 lossD) = MathEx.reducedRatio(loss.n, loss.d, MAX_UINT256 / maxVal);\n        return total.mul(lossD.sub(lossN)).div(lossD).add(lossN.mul(levelN).div(lossD.mul(levelD)));\n    }\n\n    function _networkCompensation(\n        uint256 targetAmount,\n        uint256 baseAmount,\n        PackedRates memory packedRates\n    ) internal view returns (uint256) {\n        if (targetAmount <= baseAmount) {\n            return 0;\n        }\n\n        // calculate the delta in network tokens\n        uint256 delta = _mulDivF(\n            targetAmount - baseAmount,\n            packedRates.removeAverageRateN,\n            packedRates.removeAverageRateD\n        );\n\n        // the delta might be very small due to precision loss\n        // in which case no compensation will take place (gas optimization)\n        if (delta >= _settings.minNetworkCompensation()) {\n            return delta;\n        }\n\n        return 0;\n    }\n\n    /**\n     * @dev utility to mint network tokens\n     */\n    function _mintNetworkTokens(\n        address owner,\n        IConverterAnchor poolAnchor,\n        uint256 amount\n    ) private {\n        _systemStore.incNetworkTokensMinted(poolAnchor, amount);\n        _networkTokenGovernance.mint(owner, amount);\n    }\n\n    /**\n     * @dev utility to burn network tokens\n     */\n    function _burnNetworkTokens(IConverterAnchor poolAnchor, uint256 amount) private {\n        _systemStore.decNetworkTokensMinted(poolAnchor, amount);\n        _networkTokenGovernance.burn(amount);\n    }\n\n    /**\n     * @dev utility to get the reserve balances\n     */\n    function _converterReserveBalances(\n        IConverter converter,\n        IReserveToken reserveToken1,\n        IReserveToken reserveToken2\n    ) private view returns (uint256, uint256) {\n        return (converter.getConnectorBalance(reserveToken1), converter.getConnectorBalance(reserveToken2));\n    }\n\n    /**\n     * @dev utility to get the other reserve\n     */\n    function _converterOtherReserve(IConverter converter, IReserveToken thisReserve)\n        private\n        view\n        returns (IReserveToken)\n    {\n        IReserveToken otherReserve = converter.connectorTokens(0);\n        return otherReserve != thisReserve ? otherReserve : converter.connectorTokens(1);\n    }\n\n    /**\n     * @dev utility to get the owner\n     */\n    function _ownedBy(IOwned owned) private view returns (address) {\n        return owned.owner();\n    }\n\n    /**\n     * @dev returns whether the provided reserve token is the network token\n     */\n    function _isNetworkToken(IReserveToken reserveToken) private view returns (bool) {\n        return address(reserveToken) == address(_networkToken);\n    }\n\n    /**\n     * @dev returns custom input for the `removeLiquidity` converter function\n     */\n    function _removeLiquidityInput(IReserveToken reserveToken1, IReserveToken reserveToken2)\n        private\n        pure\n        returns (IReserveToken[] memory, uint256[] memory)\n    {\n        IReserveToken[] memory reserveTokens = new IReserveToken[](2);\n        uint256[] memory minReturns = new uint256[](2);\n        reserveTokens[0] = reserveToken1;\n        reserveTokens[1] = reserveToken2;\n        minReturns[0] = 1;\n        minReturns[1] = 1;\n        return (reserveTokens, minReturns);\n    }\n\n    /**\n     * @dev returns the relative position amounts\n     */\n    function _portionAmounts(\n        uint256 poolAmount,\n        uint256 reserveAmount,\n        uint256 portion\n    ) private pure returns (uint256, uint256) {\n        return (_mulDivF(poolAmount, portion, PPM_RESOLUTION), _mulDivF(reserveAmount, portion, PPM_RESOLUTION));\n    }\n\n    /**\n     * @dev returns the network token minting limit\n     */\n    function _networkTokenMintingLimit(IConverterAnchor poolAnchor) private view returns (uint256) {\n        uint256 mintingLimit = _settings.networkTokenMintingLimits(poolAnchor);\n        return mintingLimit > 0 ? mintingLimit : _settings.defaultNetworkTokenMintingLimit();\n    }\n\n    /**\n     * @dev returns the amount of pool tokens required for liquidation\n     */\n    function _liquidationAmount(\n        uint256 targetAmount,\n        Fraction memory poolRate,\n        IDSToken poolToken,\n        uint256 additionalAmount\n    ) private view returns (uint256) {\n        // note that the amount is doubled since it's not possible to liquidate one reserve only\n        uint256 poolAmount = _mulDivF(targetAmount, poolRate.d.mul(2), poolRate.n);\n        // limit the amount of pool tokens by the amount the system/caller holds\n        return Math.min(poolAmount, _systemStore.systemBalance(poolToken).add(additionalAmount));\n    }\n\n    /**\n     * @dev withdraw pool tokens from the wallet\n     */\n    function _withdrawPoolTokens(IDSToken poolToken, uint256 poolAmount) private {\n        _systemStore.decSystemBalance(poolToken, poolAmount);\n        _wallet.withdrawTokens(IReserveToken(address(poolToken)), address(this), poolAmount);\n    }\n\n    /**\n     * @dev returns `x * y / z`\n     */\n    function _mulDivF(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) private pure returns (uint256) {\n        return x.mul(y).div(z);\n    }\n\n    /**\n     * @dev enables/disabled deposits\n     *\n     * Requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function enableDepositing(bool state) external ownerOnly {\n        _addingEnabled = state;\n    }\n\n    /**\n     * @dev enables/disabled removals\n     *\n     * Requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function enableRemoving(bool state) external ownerOnly {\n        _removingEnabled = state;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@bancor/token-governance/contracts/ITokenGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\nimport \"./IMintableToken.sol\";\n\n/// @title The interface for mintable/burnable token governance.\ninterface ITokenGovernance {\n    // The address of the mintable ERC20 token.\n    function token() external view returns (IMintableToken);\n\n    /// @dev Mints new tokens.\n    ///\n    /// @param to Account to receive the new amount.\n    /// @param amount Amount to increase the supply by.\n    ///\n    function mint(address to, uint256 amount) external;\n\n    /// @dev Burns tokens from the caller.\n    ///\n    /// @param amount Amount to decrease the supply by.\n    ///\n    function burn(uint256 amount) external;\n}\n"
    },
    "contracts/utility/MathEx.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\n/**\n * @dev This library provides a set of complex math operations.\n */\nlibrary MathEx {\n    uint256 private constant MAX_EXP_BIT_LEN = 4;\n    uint256 private constant MAX_EXP = 2**MAX_EXP_BIT_LEN - 1;\n    uint256 private constant MAX_UINT256 = uint256(-1);\n\n    /**\n     * @dev returns the largest integer smaller than or equal to the square root of a positive integer\n     */\n    function floorSqrt(uint256 num) internal pure returns (uint256) {\n        uint256 x = num / 2 + 1;\n        uint256 y = (x + num / x) / 2;\n        while (x > y) {\n            x = y;\n            y = (x + num / x) / 2;\n        }\n        return x;\n    }\n\n    /**\n     * @dev returns the smallest integer larger than or equal to the square root of a positive integer\n     */\n    function ceilSqrt(uint256 num) internal pure returns (uint256) {\n        uint256 x = floorSqrt(num);\n\n        return x * x == num ? x : x + 1;\n    }\n\n    /**\n     * @dev computes the product of two given ratios\n     */\n    function productRatio(\n        uint256 xn,\n        uint256 yn,\n        uint256 xd,\n        uint256 yd\n    ) internal pure returns (uint256, uint256) {\n        uint256 n = mulDivC(xn, yn, MAX_UINT256);\n        uint256 d = mulDivC(xd, yd, MAX_UINT256);\n        uint256 z = n > d ? n : d;\n        if (z > 1) {\n            return (mulDivC(xn, yn, z), mulDivC(xd, yd, z));\n        }\n        return (xn * yn, xd * yd);\n    }\n\n    /**\n     * @dev computes a reduced-scalar ratio\n     */\n    function reducedRatio(\n        uint256 n,\n        uint256 d,\n        uint256 max\n    ) internal pure returns (uint256, uint256) {\n        (uint256 newN, uint256 newD) = (n, d);\n        if (newN > max || newD > max) {\n            (newN, newD) = normalizedRatio(newN, newD, max);\n        }\n        if (newN != newD) {\n            return (newN, newD);\n        }\n        return (1, 1);\n    }\n\n    /**\n     * @dev computes \"scale * a / (a + b)\" and \"scale * b / (a + b)\".\n     */\n    function normalizedRatio(\n        uint256 a,\n        uint256 b,\n        uint256 scale\n    ) internal pure returns (uint256, uint256) {\n        if (a <= b) {\n            return accurateRatio(a, b, scale);\n        }\n        (uint256 y, uint256 x) = accurateRatio(b, a, scale);\n        return (x, y);\n    }\n\n    /**\n     * @dev computes \"scale * a / (a + b)\" and \"scale * b / (a + b)\", assuming that \"a <= b\".\n     */\n    function accurateRatio(\n        uint256 a,\n        uint256 b,\n        uint256 scale\n    ) internal pure returns (uint256, uint256) {\n        uint256 maxVal = MAX_UINT256 / scale;\n        if (a > maxVal) {\n            uint256 c = a / (maxVal + 1) + 1;\n            a /= c; // we can now safely compute `a * scale`\n            b /= c;\n        }\n        if (a != b) {\n            uint256 newN = a * scale;\n            uint256 newD = unsafeAdd(a, b); // can overflow\n            if (newD >= a) {\n                // no overflow in `a + b`\n                uint256 x = roundDiv(newN, newD); // we can now safely compute `scale - x`\n                uint256 y = scale - x;\n                return (x, y);\n            }\n            if (newN < b - (b - a) / 2) {\n                return (0, scale); // `a * scale < (a + b) / 2 < MAX_UINT256 < a + b`\n            }\n            return (1, scale - 1); // `(a + b) / 2 < a * scale < MAX_UINT256 < a + b`\n        }\n        return (scale / 2, scale / 2); // allow reduction to `(1, 1)` in the calling function\n    }\n\n    /**\n     * @dev computes the nearest integer to a given quotient without overflowing or underflowing.\n     */\n    function roundDiv(uint256 n, uint256 d) internal pure returns (uint256) {\n        return n / d + (n % d) / (d - d / 2);\n    }\n\n    /**\n     * @dev returns the average number of decimal digits in a given list of positive integers\n     */\n    function geometricMean(uint256[] memory values) internal pure returns (uint256) {\n        uint256 numOfDigits = 0;\n        uint256 length = values.length;\n        for (uint256 i = 0; i < length; ++i) {\n            numOfDigits += decimalLength(values[i]);\n        }\n        return uint256(10)**(roundDivUnsafe(numOfDigits, length) - 1);\n    }\n\n    /**\n     * @dev returns the number of decimal digits in a given positive integer\n     */\n    function decimalLength(uint256 x) internal pure returns (uint256) {\n        uint256 y = 0;\n        for (uint256 tmpX = x; tmpX > 0; tmpX /= 10) {\n            ++y;\n        }\n        return y;\n    }\n\n    /**\n     * @dev returns the nearest integer to a given quotient\n     *\n     * note the computation is overflow-safe assuming that the input is sufficiently small\n     */\n    function roundDivUnsafe(uint256 n, uint256 d) internal pure returns (uint256) {\n        return (n + d / 2) / d;\n    }\n\n    /**\n     * @dev returns the largest integer smaller than or equal to `x * y / z`\n     */\n    function mulDivF(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) internal pure returns (uint256) {\n        (uint256 xyh, uint256 xyl) = mul512(x, y);\n\n        // if `x * y < 2 ^ 256`\n        if (xyh == 0) {\n            return xyl / z;\n        }\n\n        // assert `x * y / z < 2 ^ 256`\n        require(xyh < z, \"ERR_OVERFLOW\");\n\n        uint256 m = mulMod(x, y, z); // `m = x * y % z`\n        (uint256 nh, uint256 nl) = sub512(xyh, xyl, m); // `n = x * y - m` hence `n / z = floor(x * y / z)`\n\n        // if `n < 2 ^ 256`\n        if (nh == 0) {\n            return nl / z;\n        }\n\n        uint256 p = unsafeSub(0, z) & z; // `p` is the largest power of 2 which `z` is divisible by\n        uint256 q = div512(nh, nl, p); // `n` is divisible by `p` because `n` is divisible by `z` and `z` is divisible by `p`\n        uint256 r = inv256(z / p); // `z / p = 1 mod 2` hence `inverse(z / p) = 1 mod 2 ^ 256`\n        return unsafeMul(q, r); // `q * r = (n / p) * inverse(z / p) = n / z`\n    }\n\n    /**\n     * @dev returns the smallest integer larger than or equal to `x * y / z`\n     */\n    function mulDivC(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) internal pure returns (uint256) {\n        uint256 w = mulDivF(x, y, z);\n        if (mulMod(x, y, z) > 0) {\n            require(w < MAX_UINT256, \"ERR_OVERFLOW\");\n            return w + 1;\n        }\n        return w;\n    }\n\n    /**\n     * @dev returns the value of `x * y` as a pair of 256-bit values\n     */\n    function mul512(uint256 x, uint256 y) private pure returns (uint256, uint256) {\n        uint256 p = mulModMax(x, y);\n        uint256 q = unsafeMul(x, y);\n        if (p >= q) {\n            return (p - q, q);\n        }\n        return (unsafeSub(p, q) - 1, q);\n    }\n\n    /**\n     * @dev returns the value of `2 ^ 256 * xh + xl - y`, where `2 ^ 256 * xh + xl >= y`\n     */\n    function sub512(\n        uint256 xh,\n        uint256 xl,\n        uint256 y\n    ) private pure returns (uint256, uint256) {\n        if (xl >= y) {\n            return (xh, xl - y);\n        }\n        return (xh - 1, unsafeSub(xl, y));\n    }\n\n    /**\n     * @dev returns the value of `(2 ^ 256 * xh + xl) / pow2n`, where `xl` is divisible by `pow2n`\n     */\n    function div512(\n        uint256 xh,\n        uint256 xl,\n        uint256 pow2n\n    ) private pure returns (uint256) {\n        uint256 pow2nInv = unsafeAdd(unsafeSub(0, pow2n) / pow2n, 1); // `1 << (256 - n)`\n        return unsafeMul(xh, pow2nInv) | (xl / pow2n); // `(xh << (256 - n)) | (xl >> n)`\n    }\n\n    /**\n     * @dev returns the inverse of `d` modulo `2 ^ 256`, where `d` is congruent to `1` modulo `2`\n     */\n    function inv256(uint256 d) private pure returns (uint256) {\n        // approximate the root of `f(x) = 1 / x - d` using the newtonraphson convergence method\n        uint256 x = 1;\n        for (uint256 i = 0; i < 8; ++i) {\n            x = unsafeMul(x, unsafeSub(2, unsafeMul(x, d))); // `x = x * (2 - x * d) mod 2 ^ 256`\n        }\n        return x;\n    }\n\n    /**\n     * @dev returns `(x + y) % 2 ^ 256`\n     */\n    function unsafeAdd(uint256 x, uint256 y) private pure returns (uint256) {\n        return x + y;\n    }\n\n    /**\n     * @dev returns `(x - y) % 2 ^ 256`\n     */\n    function unsafeSub(uint256 x, uint256 y) private pure returns (uint256) {\n        return x - y;\n    }\n\n    /**\n     * @dev returns `(x * y) % 2 ^ 256`\n     */\n    function unsafeMul(uint256 x, uint256 y) private pure returns (uint256) {\n        return x * y;\n    }\n\n    /**\n     * @dev returns `x * y % (2 ^ 256 - 1)`\n     */\n    function mulModMax(uint256 x, uint256 y) private pure returns (uint256) {\n        return mulmod(x, y, MAX_UINT256);\n    }\n\n    /**\n     * @dev returns `x * y % z`\n     */\n    function mulMod(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) private pure returns (uint256) {\n        return mulmod(x, y, z);\n    }\n}\n"
    },
    "contracts/utility/Types.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\n/**\n * @dev This contract provides types which can be used by various contracts.\n */\n\nstruct Fraction {\n    uint256 n; // numerator\n    uint256 d; // denominator\n}\n"
    },
    "contracts/utility/Time.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\n/*\n    Time implementing contract\n*/\ncontract Time {\n    /**\n     * @dev returns the current time\n     */\n    function _time() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/utility/Utils.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @dev Utilities & Common Modifiers\n */\ncontract Utils {\n    uint32 internal constant PPM_RESOLUTION = 1000000;\n\n    // verifies that a value is greater than zero\n    modifier greaterThanZero(uint256 value) {\n        _greaterThanZero(value);\n\n        _;\n    }\n\n    // error message binary size optimization\n    function _greaterThanZero(uint256 value) internal pure {\n        require(value > 0, \"ERR_ZERO_VALUE\");\n    }\n\n    // validates an address - currently only checks that it isn't null\n    modifier validAddress(address addr) {\n        _validAddress(addr);\n\n        _;\n    }\n\n    // error message binary size optimization\n    function _validAddress(address addr) internal pure {\n        require(addr != address(0), \"ERR_INVALID_ADDRESS\");\n    }\n\n    // ensures that the portion is valid\n    modifier validPortion(uint32 _portion) {\n        _validPortion(_portion);\n\n        _;\n    }\n\n    // error message binary size optimization\n    function _validPortion(uint32 _portion) internal pure {\n        require(_portion > 0 && _portion <= PPM_RESOLUTION, \"ERR_INVALID_PORTION\");\n    }\n\n    // validates an external address - currently only checks that it isn't null or this\n    modifier validExternalAddress(address addr) {\n        _validExternalAddress(addr);\n\n        _;\n    }\n\n    // error message binary size optimization\n    function _validExternalAddress(address addr) internal view {\n        require(addr != address(0) && addr != address(this), \"ERR_INVALID_EXTERNAL_ADDRESS\");\n    }\n\n    // ensures that the fee is valid\n    modifier validFee(uint32 fee) {\n        _validFee(fee);\n\n        _;\n    }\n\n    // error message binary size optimization\n    function _validFee(uint32 fee) internal pure {\n        require(fee <= PPM_RESOLUTION, \"ERR_INVALID_FEE\");\n    }\n}\n"
    },
    "contracts/utility/Owned.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"./interfaces/IOwned.sol\";\n\n/**\n * @dev This contract provides support and utilities for contract ownership.\n */\ncontract Owned is IOwned {\n    address private _owner;\n    address private _newOwner;\n\n    /**\n     * @dev triggered when the owner is updated\n     */\n    event OwnerUpdate(address indexed prevOwner, address indexed newOwner);\n\n    /**\n     * @dev initializes a new Owned instance\n     */\n    constructor() public {\n        _owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly() {\n        _ownerOnly();\n\n        _;\n    }\n\n    // error message binary size optimization\n    function _ownerOnly() private view {\n        require(msg.sender == _owner, \"ERR_ACCESS_DENIED\");\n    }\n\n    /**\n     * @dev allows transferring the contract ownership\n     *\n     * Requirements:\n     *\n     * - the caller must be the owner of the contract\n     *\n     * note the new owner still needs to accept the transfer\n     */\n    function transferOwnership(address newOwner) public override ownerOnly {\n        require(newOwner != _owner, \"ERR_SAME_OWNER\");\n\n        _newOwner = newOwner;\n    }\n\n    /**\n     * @dev used by a new owner to accept an ownership transfer\n     */\n    function acceptOwnership() public override {\n        require(msg.sender == _newOwner, \"ERR_ACCESS_DENIED\");\n\n        emit OwnerUpdate(_owner, _newOwner);\n\n        _owner = _newOwner;\n        _newOwner = address(0);\n    }\n\n    /**\n     * @dev returns the address of the current owner\n     */\n    function owner() public view override returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev returns the address of the new owner candidate\n     */\n    function newOwner() external view returns (address) {\n        return _newOwner;\n    }\n}\n"
    },
    "contracts/token/interfaces/IDSToken.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../converter/interfaces/IConverterAnchor.sol\";\nimport \"../../utility/interfaces/IOwned.sol\";\n\n/**\n * @dev DSToken interface\n */\ninterface IDSToken is IConverterAnchor, IERC20 {\n    function issue(address recipient, uint256 amount) external;\n\n    function destroy(address recipient, uint256 amount) external;\n}\n"
    },
    "contracts/token/ReserveToken.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IReserveToken.sol\";\n\nimport \"./SafeERC20Ex.sol\";\n\n/**\n * @dev This library implements ERC20 and SafeERC20 utilities for reserve tokens, which can be either ERC20 tokens or ETH\n */\nlibrary ReserveToken {\n    using SafeERC20 for IERC20;\n    using SafeERC20Ex for IERC20;\n\n    // the address that represents an ETH reserve\n    IReserveToken public constant NATIVE_TOKEN_ADDRESS = IReserveToken(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    /**\n     * @dev returns whether the provided token represents an ERC20 or ETH reserve\n     */\n    function isNativeToken(IReserveToken reserveToken) internal pure returns (bool) {\n        return reserveToken == NATIVE_TOKEN_ADDRESS;\n    }\n\n    /**\n     * @dev returns the balance of the reserve token\n     */\n    function balanceOf(IReserveToken reserveToken, address account) internal view returns (uint256) {\n        if (isNativeToken(reserveToken)) {\n            return account.balance;\n        }\n\n        return toIERC20(reserveToken).balanceOf(account);\n    }\n\n    /**\n     * @dev transfers a specific amount of the reserve token\n     */\n    function safeTransfer(\n        IReserveToken reserveToken,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (isNativeToken(reserveToken)) {\n            payable(to).transfer(amount);\n        } else {\n            toIERC20(reserveToken).safeTransfer(to, amount);\n        }\n    }\n\n    /**\n     * @dev transfers a specific amount of the reserve token from a specific holder using the allowance mechanism\n     *\n     * note that the function ignores a reserve token which represents an ETH reserve\n     */\n    function safeTransferFrom(\n        IReserveToken reserveToken,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount == 0 || isNativeToken(reserveToken)) {\n            return;\n        }\n\n        toIERC20(reserveToken).safeTransferFrom(from, to, amount);\n    }\n\n    /**\n     * @dev ensures that the spender has sufficient allowance\n     *\n     * note that this function ignores a reserve token which represents an ETH reserve\n     */\n    function ensureApprove(\n        IReserveToken reserveToken,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (isNativeToken(reserveToken)) {\n            return;\n        }\n\n        toIERC20(reserveToken).ensureApprove(spender, amount);\n    }\n\n    /**\n     * @dev utility function that converts an IReserveToken to an IERC20\n     */\n    function toIERC20(IReserveToken reserveToken) private pure returns (IERC20) {\n        return IERC20(address(reserveToken));\n    }\n}\n"
    },
    "contracts/converter/interfaces/IConverterAnchor.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"../../utility/interfaces/IOwned.sol\";\n\n/**\n * @dev Converter Anchor interface\n */\ninterface IConverterAnchor is IOwned {\n\n}\n"
    },
    "contracts/converter/interfaces/IConverter.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IConverterAnchor.sol\";\n\nimport \"../../utility/interfaces/IOwned.sol\";\n\nimport \"../../token/interfaces/IReserveToken.sol\";\n\n/**\n * @dev Converter interface\n */\ninterface IConverter is IOwned {\n    function converterType() external pure returns (uint16);\n\n    function anchor() external view returns (IConverterAnchor);\n\n    function isActive() external view returns (bool);\n\n    function targetAmountAndFee(\n        IReserveToken sourceToken,\n        IReserveToken targetToken,\n        uint256 sourceAmount\n    ) external view returns (uint256, uint256);\n\n    function convert(\n        IReserveToken sourceToken,\n        IReserveToken targetToken,\n        uint256 sourceAmount,\n        address trader,\n        address payable beneficiary\n    ) external payable returns (uint256);\n\n    function conversionFee() external view returns (uint32);\n\n    function maxConversionFee() external view returns (uint32);\n\n    function reserveBalance(IReserveToken reserveToken) external view returns (uint256);\n\n    receive() external payable;\n\n    function transferAnchorOwnership(address newOwner) external;\n\n    function acceptAnchorOwnership() external;\n\n    function setConversionFee(uint32 fee) external;\n\n    function addReserve(IReserveToken token, uint32 weight) external;\n\n    function transferReservesOnUpgrade(address newConverter) external;\n\n    function onUpgradeComplete() external;\n\n    // deprecated, backward compatibility\n    function token() external view returns (IConverterAnchor);\n\n    function transferTokenOwnership(address newOwner) external;\n\n    function acceptTokenOwnership() external;\n\n    function reserveTokenCount() external view returns (uint16);\n\n    function reserveTokens() external view returns (IReserveToken[] memory);\n\n    function connectors(IReserveToken reserveToken)\n        external\n        view\n        returns (\n            uint256,\n            uint32,\n            bool,\n            bool,\n            bool\n        );\n\n    function getConnectorBalance(IReserveToken connectorToken) external view returns (uint256);\n\n    function connectorTokens(uint256 index) external view returns (IReserveToken);\n\n    function connectorTokenCount() external view returns (uint16);\n\n    /**\n     * @dev triggered when the converter is activated\n     */\n    event Activation(uint16 indexed converterType, IConverterAnchor indexed anchor, bool indexed activated);\n\n    /**\n     * @dev triggered when a conversion between two tokens occurs\n     */\n    event Conversion(\n        IReserveToken indexed sourceToken,\n        IReserveToken indexed targetToken,\n        address indexed trader,\n        uint256 sourceAmount,\n        uint256 targetAmount,\n        int256 conversionFee\n    );\n\n    /**\n     * @dev triggered when the rate between two tokens in the converter changes\n     *\n     * note that the event might be dispatched for rate updates between any two tokens in the converter\n     */\n    event TokenRateUpdate(address indexed token1, address indexed token2, uint256 rateN, uint256 rateD);\n\n    /**\n     * @dev triggered when the conversion fee is updated\n     */\n    event ConversionFeeUpdate(uint32 prevFee, uint32 newFee);\n}\n"
    },
    "contracts/converter/interfaces/IConverterRegistry.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"../../token/interfaces/IReserveToken.sol\";\n\nimport \"./IConverterAnchor.sol\";\n\n/**\n * @dev Converter Registry interface\n */\ninterface IConverterRegistry {\n    function getAnchorCount() external view returns (uint256);\n\n    function getAnchors() external view returns (address[] memory);\n\n    function getAnchor(uint256 index) external view returns (IConverterAnchor);\n\n    function isAnchor(address value) external view returns (bool);\n\n    function getLiquidityPoolCount() external view returns (uint256);\n\n    function getLiquidityPools() external view returns (address[] memory);\n\n    function getLiquidityPool(uint256 index) external view returns (IConverterAnchor);\n\n    function isLiquidityPool(address value) external view returns (bool);\n\n    function getConvertibleTokenCount() external view returns (uint256);\n\n    function getConvertibleTokens() external view returns (address[] memory);\n\n    function getConvertibleToken(uint256 index) external view returns (IReserveToken);\n\n    function isConvertibleToken(address value) external view returns (bool);\n\n    function getConvertibleTokenAnchorCount(IReserveToken convertibleToken) external view returns (uint256);\n\n    function getConvertibleTokenAnchors(IReserveToken convertibleToken) external view returns (address[] memory);\n\n    function getConvertibleTokenAnchor(IReserveToken convertibleToken, uint256 index)\n        external\n        view\n        returns (IConverterAnchor);\n\n    function isConvertibleTokenAnchor(IReserveToken convertibleToken, address value) external view returns (bool);\n\n    function getLiquidityPoolByConfig(\n        uint16 converterType,\n        IReserveToken[] memory reserveTokens,\n        uint32[] memory reserveWeights\n    ) external view returns (IConverterAnchor);\n}\n"
    },
    "contracts/liquidity-protection/interfaces/ILiquidityProtection.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"./ILiquidityProtectionStore.sol\";\nimport \"./ILiquidityProtectionStats.sol\";\nimport \"./ILiquidityProtectionSettings.sol\";\nimport \"./ILiquidityProtectionSystemStore.sol\";\nimport \"./ITransferPositionCallback.sol\";\n\nimport \"../../utility/interfaces/ITokenHolder.sol\";\n\nimport \"../../token/interfaces/IReserveToken.sol\";\n\nimport \"../../converter/interfaces/IConverterAnchor.sol\";\n\n/**\n * @dev Liquidity Protection interface\n */\ninterface ILiquidityProtection {\n    function store() external view returns (ILiquidityProtectionStore);\n\n    function stats() external view returns (ILiquidityProtectionStats);\n\n    function settings() external view returns (ILiquidityProtectionSettings);\n\n    function addLiquidityFor(\n        address owner,\n        IConverterAnchor poolAnchor,\n        IReserveToken reserveToken,\n        uint256 amount\n    ) external payable returns (uint256);\n\n    function addLiquidity(\n        IConverterAnchor poolAnchor,\n        IReserveToken reserveToken,\n        uint256 amount\n    ) external payable returns (uint256);\n\n    function removeLiquidity(uint256 id, uint32 portion) external;\n\n    function transferPosition(uint256 id, address newProvider) external returns (uint256);\n\n    function transferPositionAndNotify(\n        uint256 id,\n        address newProvider,\n        ITransferPositionCallback callback,\n        bytes calldata data\n    ) external returns (uint256);\n}\n"
    },
    "@bancor/token-governance/contracts/IMintableToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IClaimable.sol\";\n\n/// @title Mintable Token interface\ninterface IMintableToken is IERC20, IClaimable {\n    function issue(address to, uint256 amount) external;\n\n    function destroy(address from, uint256 amount) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@bancor/token-governance/contracts/IClaimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\n/// @title Claimable contract interface\ninterface IClaimable {\n    function owner() external view returns (address);\n\n    function transferOwnership(address newOwner) external;\n\n    function acceptOwnership() external;\n}\n"
    },
    "contracts/utility/interfaces/IOwned.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\n/**\n * @dev Owned interface\n */\ninterface IOwned {\n    function owner() external view returns (address);\n\n    function transferOwnership(address newOwner) external;\n\n    function acceptOwnership() external;\n}\n"
    },
    "contracts/token/interfaces/IReserveToken.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\n/**\n * @dev This contract is used to represent reserve tokens, which are tokens that can either be regular ERC20 tokens or\n * native ETH (represented by the NATIVE_TOKEN_ADDRESS address)\n *\n * Please note that this interface is intentionally doesn't inherit from IERC20, so that it'd be possible to effectively\n * override its balanceOf() function in the ReserveToken library\n */\ninterface IReserveToken {\n\n}\n"
    },
    "contracts/token/SafeERC20Ex.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n/**\n * @dev Extends the SafeERC20 library with additional operations\n */\nlibrary SafeERC20Ex {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @dev ensures that the spender has sufficient allowance\n     */\n    function ensureApprove(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        uint256 allowance = token.allowance(address(this), spender);\n        if (allowance >= amount) {\n            return;\n        }\n\n        if (allowance > 0) {\n            token.safeApprove(spender, 0);\n        }\n        token.safeApprove(spender, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/liquidity-protection/interfaces/ILiquidityProtectionStore.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"../../converter/interfaces/IConverterAnchor.sol\";\n\nimport \"../../token/interfaces/IDSToken.sol\";\nimport \"../../token/interfaces/IReserveToken.sol\";\n\nimport \"../../utility/interfaces/IOwned.sol\";\n\n/**\n * @dev Liquidity Protection Store interface\n */\ninterface ILiquidityProtectionStore is IOwned {\n    function withdrawTokens(\n        IReserveToken token,\n        address recipient,\n        uint256 amount\n    ) external;\n\n    function protectedLiquidity(uint256 id)\n        external\n        view\n        returns (\n            address,\n            IDSToken,\n            IReserveToken,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function addProtectedLiquidity(\n        address provider,\n        IDSToken poolToken,\n        IReserveToken reserveToken,\n        uint256 poolAmount,\n        uint256 reserveAmount,\n        uint256 reserveRateN,\n        uint256 reserveRateD,\n        uint256 timestamp\n    ) external returns (uint256);\n\n    function updateProtectedLiquidityAmounts(\n        uint256 id,\n        uint256 poolNewAmount,\n        uint256 reserveNewAmount\n    ) external;\n\n    function removeProtectedLiquidity(uint256 id) external;\n\n    function lockedBalance(address provider, uint256 index) external view returns (uint256, uint256);\n\n    function lockedBalanceRange(\n        address provider,\n        uint256 startIndex,\n        uint256 endIndex\n    ) external view returns (uint256[] memory, uint256[] memory);\n\n    function addLockedBalance(\n        address provider,\n        uint256 reserveAmount,\n        uint256 expirationTime\n    ) external returns (uint256);\n\n    function removeLockedBalance(address provider, uint256 index) external;\n\n    function systemBalance(IReserveToken poolToken) external view returns (uint256);\n\n    function incSystemBalance(IReserveToken poolToken, uint256 poolAmount) external;\n\n    function decSystemBalance(IReserveToken poolToken, uint256 poolAmount) external;\n}\n"
    },
    "contracts/liquidity-protection/interfaces/ILiquidityProtectionStats.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"../../converter/interfaces/IConverterAnchor.sol\";\n\nimport \"../../token/interfaces/IDSToken.sol\";\nimport \"../../token/interfaces/IReserveToken.sol\";\n\n/**\n * @dev Liquidity Protection Stats interface\n */\ninterface ILiquidityProtectionStats {\n    function increaseTotalAmounts(\n        address provider,\n        IDSToken poolToken,\n        IReserveToken reserveToken,\n        uint256 poolAmount,\n        uint256 reserveAmount\n    ) external;\n\n    function decreaseTotalAmounts(\n        address provider,\n        IDSToken poolToken,\n        IReserveToken reserveToken,\n        uint256 poolAmount,\n        uint256 reserveAmount\n    ) external;\n\n    function addProviderPool(address provider, IDSToken poolToken) external returns (bool);\n\n    function removeProviderPool(address provider, IDSToken poolToken) external returns (bool);\n\n    function totalPoolAmount(IDSToken poolToken) external view returns (uint256);\n\n    function totalReserveAmount(IDSToken poolToken, IReserveToken reserveToken) external view returns (uint256);\n\n    function totalProviderAmount(\n        address provider,\n        IDSToken poolToken,\n        IReserveToken reserveToken\n    ) external view returns (uint256);\n\n    function providerPools(address provider) external view returns (IDSToken[] memory);\n}\n"
    },
    "contracts/liquidity-protection/interfaces/ILiquidityProtectionSettings.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"../../converter/interfaces/IConverterAnchor.sol\";\n\nimport \"../../token/interfaces/IReserveToken.sol\";\n\nimport \"./ILiquidityProvisionEventsSubscriber.sol\";\n\n/**\n * @dev Liquidity Protection Settings interface\n */\ninterface ILiquidityProtectionSettings {\n    function isPoolWhitelisted(IConverterAnchor poolAnchor) external view returns (bool);\n\n    function poolWhitelist() external view returns (address[] memory);\n\n    function subscribers() external view returns (address[] memory);\n\n    function isPoolSupported(IConverterAnchor poolAnchor) external view returns (bool);\n\n    function minNetworkTokenLiquidityForMinting() external view returns (uint256);\n\n    function defaultNetworkTokenMintingLimit() external view returns (uint256);\n\n    function networkTokenMintingLimits(IConverterAnchor poolAnchor) external view returns (uint256);\n\n    function addLiquidityDisabled(IConverterAnchor poolAnchor, IReserveToken reserveToken) external view returns (bool);\n\n    function minProtectionDelay() external view returns (uint256);\n\n    function maxProtectionDelay() external view returns (uint256);\n\n    function minNetworkCompensation() external view returns (uint256);\n\n    function lockDuration() external view returns (uint256);\n\n    function averageRateMaxDeviation() external view returns (uint32);\n}\n"
    },
    "contracts/liquidity-protection/interfaces/ILiquidityProtectionSystemStore.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../converter/interfaces/IConverterAnchor.sol\";\n\n/**\n * @dev Liquidity Protection System Store interface\n */\ninterface ILiquidityProtectionSystemStore {\n    function systemBalance(IERC20 poolToken) external view returns (uint256);\n\n    function incSystemBalance(IERC20 poolToken, uint256 poolAmount) external;\n\n    function decSystemBalance(IERC20 poolToken, uint256 poolAmount) external;\n\n    function networkTokensMinted(IConverterAnchor poolAnchor) external view returns (uint256);\n\n    function incNetworkTokensMinted(IConverterAnchor poolAnchor, uint256 amount) external;\n\n    function decNetworkTokensMinted(IConverterAnchor poolAnchor, uint256 amount) external;\n}\n"
    },
    "contracts/liquidity-protection/interfaces/ITransferPositionCallback.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\n/**\n * @dev Transfer position event callback interface\n */\ninterface ITransferPositionCallback {\n    function onTransferPosition(\n        uint256 newId,\n        address provider,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/utility/interfaces/ITokenHolder.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"../../token/interfaces/IReserveToken.sol\";\n\nimport \"./IOwned.sol\";\n\n/**\n * @dev Token Holder interface\n */\ninterface ITokenHolder is IOwned {\n    receive() external payable;\n\n    function withdrawTokens(\n        IReserveToken reserveToken,\n        address payable to,\n        uint256 amount\n    ) external;\n\n    function withdrawTokensMultiple(\n        IReserveToken[] calldata reserveTokens,\n        address payable to,\n        uint256[] calldata amounts\n    ) external;\n}\n"
    },
    "contracts/liquidity-protection/interfaces/ILiquidityProvisionEventsSubscriber.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\nimport \"../../converter/interfaces/IConverterAnchor.sol\";\n\nimport \"../../token/interfaces/IReserveToken.sol\";\n\n/**\n * @dev Liquidity provision events subscriber interface\n */\ninterface ILiquidityProvisionEventsSubscriber {\n    function onAddingLiquidity(\n        address provider,\n        IConverterAnchor poolAnchor,\n        IReserveToken reserveToken,\n        uint256 poolAmount,\n        uint256 reserveAmount\n    ) external;\n\n    function onRemovingLiquidity(\n        uint256 id,\n        address provider,\n        IConverterAnchor poolAnchor,\n        IReserveToken reserveToken,\n        uint256 poolAmount,\n        uint256 reserveAmount\n    ) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "bytecodeHash": "none"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}