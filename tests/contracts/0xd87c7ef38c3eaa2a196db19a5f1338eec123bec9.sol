{"Earnings.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract Earnings {\r\n    using SafeMath for *;\r\n\r\n    // -------------------- mapping ------------------------ //\r\n    mapping(address =\u003e UserWithdraw) public userWithdraw; // record user withdraw reward information\r\n\r\n    // -------------------- variate ------------------------ //\r\n    uint8 constant internal percent = 100;\r\n    uint8 constant internal remain = 20;       // Static and dynamic rewards returns remain at 20 percent\r\n\r\n    address public resonanceAddress;\r\n    address public owner;\r\n\r\n    // -------------------- struct ------------------------ //\r\n    struct UserWithdraw {\r\n        uint256 withdrawStraight; // withdraw straight eth amount\r\n        uint256 withdrawTeam;  // withdraw team eth amount\r\n        uint256 withdrawStatic; // withdraw static eth amount\r\n        uint256 withdrawTerminator;//withdraw terminator amount\r\n        uint256 withdrawNode;  // withdraw node amount\r\n        uint256 lockEth;      // user lock eth\r\n        uint256 activateEth;  // record user activate eth\r\n    }\r\n\r\n    constructor()\r\n    public{\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // -------------------- modifier ------------------------ //\r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyResonance (){\r\n        require(msg.sender == resonanceAddress);\r\n        _;\r\n    }\r\n\r\n    // -------------------- owner api ------------------------ //\r\n    function allowResonance(address _addr) public onlyOwner() {\r\n        resonanceAddress = _addr;\r\n    }\r\n\r\n    // -------------------- Resonance api ------------------------ //\r\n    // calculate actual reinvest amount, include amount + lockEth\r\n    function calculateReinvestAmount(\r\n        address reinvestAddress,\r\n        uint256 amount,\r\n        uint256 userAmount,\r\n        uint8 requireType)//type: 1 =\u003e straightEth, 2 =\u003e teamEth, 3 =\u003e withdrawStatic, 4 =\u003e withdrawNode\r\n    public\r\n    onlyResonance()\r\n    returns (uint256)\r\n    {\r\n        if (requireType == 1) {\r\n            require(amount.add((userWithdraw[reinvestAddress].withdrawStatic).mul(100).div(80)) \u003c= userAmount);\r\n        } else if (requireType == 2) {\r\n            require(amount.add((userWithdraw[reinvestAddress].withdrawStraight).mul(100).div(80)) \u003c= userAmount.add(amount));\r\n        } else if (requireType == 3) {\r\n            require(amount.add((userWithdraw[reinvestAddress].withdrawTeam).mul(100).div(80)) \u003c= userAmount.add(amount));\r\n        } else if (requireType == 5) {\r\n            require(amount.add((userWithdraw[reinvestAddress].withdrawNode).mul(100).div(80)) \u003c= userAmount);\r\n        }\r\n\r\n        //      userWithdraw[reinvestAddress].lockEth = userWithdraw[reinvestAddress].lockEth.add(amount.mul(remain).div(100));\\\r\n        uint256 _active = userWithdraw[reinvestAddress].lockEth - userWithdraw[reinvestAddress].activateEth;\r\n        if (amount \u003e _active) {\r\n            userWithdraw[reinvestAddress].activateEth += _active;\r\n            amount = amount.add(_active);\r\n        } else {\r\n            userWithdraw[reinvestAddress].activateEth = userWithdraw[reinvestAddress].activateEth.add(amount);\r\n            amount = amount.mul(2);\r\n        }\r\n\r\n        return amount;\r\n    }\r\n\r\n    function routeAddLockEth(\r\n        address withdrawAddress,\r\n        uint256 amount,\r\n        uint256 lockProfits,\r\n        uint256 userRouteEth,\r\n        uint256 routeType)\r\n    public\r\n    onlyResonance()\r\n    {\r\n        if (routeType == 1) {\r\n            addLockEthStatic(withdrawAddress, amount, lockProfits, userRouteEth);\r\n        } else if (routeType == 2) {\r\n            addLockEthStraight(withdrawAddress, amount, userRouteEth);\r\n        } else if (routeType == 3) {\r\n            addLockEthTeam(withdrawAddress, amount, userRouteEth);\r\n        } else if (routeType == 4) {\r\n            addLockEthTerminator(withdrawAddress, amount, userRouteEth);\r\n        } else if (routeType == 5) {\r\n            addLockEthNode(withdrawAddress, amount, userRouteEth);\r\n        }\r\n    }\r\n\r\n    function addLockEthStatic(address withdrawAddress, uint256 amount, uint256 lockProfits, uint256 userStatic)\r\n    internal\r\n    {\r\n        require(amount.add(userWithdraw[withdrawAddress].withdrawStatic.mul(100).div(percent - remain)) \u003c= userStatic);\r\n        userWithdraw[withdrawAddress].lockEth += lockProfits;\r\n        userWithdraw[withdrawAddress].withdrawStatic += amount.sub(lockProfits);\r\n    }\r\n\r\n    function addLockEthStraight(address withdrawAddress, uint256 amount, uint256 userStraightEth)\r\n    internal\r\n    {\r\n        require(amount.add(userWithdraw[withdrawAddress].withdrawStraight.mul(100).div(percent - remain)) \u003c= userStraightEth);\r\n        userWithdraw[withdrawAddress].lockEth += amount.mul(remain).div(100);\r\n        userWithdraw[withdrawAddress].withdrawStraight += amount.mul(percent - remain).div(100);\r\n    }\r\n\r\n    function addLockEthTeam(address withdrawAddress, uint256 amount, uint256 userTeamEth)\r\n    internal\r\n    {\r\n        require(amount.add(userWithdraw[withdrawAddress].withdrawTeam.mul(100).div(percent - remain)) \u003c= userTeamEth);\r\n        userWithdraw[withdrawAddress].lockEth += amount.mul(remain).div(100);\r\n        userWithdraw[withdrawAddress].withdrawTeam += amount.mul(percent - remain).div(100);\r\n    }\r\n\r\n    function addLockEthTerminator(address withdrawAddress, uint256 amount, uint256 withdrawAmount)\r\n    internal\r\n    {\r\n        userWithdraw[withdrawAddress].lockEth += amount.mul(remain).div(100);\r\n        userWithdraw[withdrawAddress].withdrawTerminator += withdrawAmount;\r\n    }\r\n\r\n    function addLockEthNode(address withdrawAddress, uint256 amount, uint256 userNodeEth)\r\n    internal\r\n    {\r\n        require(amount.add(userWithdraw[withdrawAddress].withdrawNode.mul(100).div(percent - remain)) \u003c= userNodeEth);\r\n        userWithdraw[withdrawAddress].lockEth += amount.mul(remain).div(100);\r\n        userWithdraw[withdrawAddress].withdrawNode += amount.mul(percent - remain).div(100);\r\n    }\r\n\r\n\r\n    function addActivateEth(address userAddress, uint256 amount)\r\n    public\r\n    onlyResonance()\r\n    {\r\n        uint256 _afterFounds = getAfterFounds(userAddress);\r\n        if (amount \u003e _afterFounds) {\r\n            userWithdraw[userAddress].activateEth = userWithdraw[userAddress].lockEth;\r\n        }\r\n        else {\r\n            userWithdraw[userAddress].activateEth += amount;\r\n        }\r\n    }\r\n\r\n    function changeWithdrawTeamZero(address userAddress)\r\n    public\r\n    onlyResonance()\r\n    {\r\n        userWithdraw[userAddress].withdrawTeam = 0;\r\n    }\r\n\r\n    function getWithdrawStraight(address reinvestAddress)\r\n    public\r\n    view\r\n    onlyResonance()\r\n    returns (uint256)\r\n    {\r\n        return userWithdraw[reinvestAddress].withdrawStraight;\r\n    }\r\n\r\n    function getWithdrawStatic(address reinvestAddress)\r\n    public\r\n    view\r\n    onlyResonance()\r\n    returns (uint256)\r\n    {\r\n        return userWithdraw[reinvestAddress].withdrawStatic;\r\n    }\r\n\r\n    function getWithdrawTeam(address reinvestAddress)\r\n    public\r\n    view\r\n    onlyResonance()\r\n    returns (uint256)\r\n    {\r\n        return userWithdraw[reinvestAddress].withdrawTeam;\r\n    }\r\n\r\n    function getWithdrawNode(address reinvestAddress)\r\n    public\r\n    view\r\n    onlyResonance()\r\n    returns (uint256)\r\n    {\r\n        return userWithdraw[reinvestAddress].withdrawNode;\r\n    }\r\n\r\n    function getAfterFounds(address userAddress)\r\n    public\r\n    view\r\n    onlyResonance()\r\n    returns (uint256)\r\n    {\r\n        return userWithdraw[userAddress].lockEth - userWithdraw[userAddress].activateEth;\r\n    }\r\n\r\n    function getStaticAfterFounds(address reinvestAddress) public\r\n    view\r\n    onlyResonance()\r\n    returns (uint256, uint256)\r\n    {\r\n        return (userWithdraw[reinvestAddress].withdrawStatic, userWithdraw[reinvestAddress].lockEth - userWithdraw[reinvestAddress].activateEth);\r\n    }\r\n\r\n    function getStaticAfterFoundsTeam(address userAddress) public\r\n    view\r\n    onlyResonance()\r\n    returns (uint256, uint256, uint256)\r\n    {\r\n        return (userWithdraw[userAddress].withdrawStatic, userWithdraw[userAddress].lockEth - userWithdraw[userAddress].activateEth, userWithdraw[userAddress].withdrawTeam);\r\n    }\r\n\r\n    function getUserWithdrawInfo(address reinvestAddress) public\r\n    view\r\n    onlyResonance()\r\n    returns (\r\n        uint256 withdrawStraight,\r\n        uint256 withdrawTeam,\r\n        uint256 withdrawStatic,\r\n        uint256 withdrawNode\r\n    )\r\n    {\r\n        withdrawStraight = userWithdraw[reinvestAddress].withdrawStraight;\r\n        withdrawTeam = userWithdraw[reinvestAddress].withdrawTeam;\r\n        withdrawStatic = userWithdraw[reinvestAddress].withdrawStatic;\r\n        withdrawNode = userWithdraw[reinvestAddress].withdrawNode;\r\n    }\r\n\r\n}\r\n"},"ERC20.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\u0027t required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`\u0027s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller\u0027s allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n"},"ERC20Burnable.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of `ERC20` that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\ncontract ERC20Burnable is ERC20 {\n    /**\n     * @dev Destoys `amount` tokens from the caller.\n     *\n     * See `ERC20._burn`.\n     */\n    function burn(uint256 amount) public {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * @dev See `ERC20._burnFrom`.\n     */\n    function burnFrom(address account, uint256 amount) public {\n        _burnFrom(account, amount);\n    }\n}\n"},"ERC20Capped.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ERC20Mintable.sol\";\n\n/**\n * @dev Extension of `ERC20Mintable` that adds a cap to the supply of tokens.\n */\ncontract ERC20Capped is ERC20Mintable {\n    uint256 private _cap;\n\n    /**\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n     * set once during construction.\n     */\n    constructor (uint256 cap) public {\n        require(cap \u003e 0, \"ERC20Capped: cap is 0\");\n        _cap = cap;\n    }\n\n    /**\n     * @dev Returns the cap on the token\u0027s total supply.\n     */\n    function cap() public view returns (uint256) {\n        return _cap;\n    }\n\n    /**\n     * @dev See `ERC20Mintable.mint`.\n     *\n     * Requirements:\n     *\n     * - `value` must not cause the total supply to go over the cap.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(totalSupply().add(value) \u003c= _cap, \"ERC20Capped: cap exceeded\");\n        super._mint(account, value);\n    }\n}\n"},"ERC20Detailed.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * \u003e Note that this information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * `IERC20.balanceOf` and `IERC20.transfer`.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"},"ERC20Mintable.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\nimport \"./MinterRole.sol\";\n\n/**\n * @dev Extension of `ERC20` that adds a set of accounts with the `MinterRole`,\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev See `ERC20._mint`.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MinterRole`.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n"},"IERC20.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * \u003e Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"KOCToken.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\r\n\r\nimport \"./ERC20.sol\";\r\nimport \"./ERC20Detailed.sol\";\r\nimport \"./ERC20Capped.sol\";\r\nimport \"./ERC20Burnable.sol\";\r\n\r\n// 测试用的Token\r\ncontract KOCToken is ERC20, ERC20Detailed, ERC20Burnable {\r\n\r\n    event CreateTokenSuccess(address owner, uint256 balance);\r\n\r\n    uint256 amount = 2100000000;\r\n    constructor(\r\n\r\n    )\r\n    ERC20Burnable()\r\n    ERC20Detailed(\"KOC\", \"KOC\", 18)\r\n    ERC20()\r\n    public\r\n    {\r\n        _mint(msg.sender, amount * (10 ** 18));\r\n        emit CreateTokenSuccess(msg.sender, balanceOf(msg.sender));\r\n    }\r\n}\r\n"},"MinterRole.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Roles.sol\";\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n"},"Recommend.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\r\n\r\ncontract Recommend {\r\n    // -------------------- mapping ------------------------ //\r\n    mapping(address =\u003e RecommendRecord) internal recommendRecord;  // record straight reward information\r\n\r\n\r\n    // -------------------- struct ------------------------ //\r\n    struct RecommendRecord {\r\n        uint256[] straightTime;  // this record start time, 3 days timeout\r\n        address[] refeAddress; // referral address\r\n        uint256[] ethAmount; // this record buy eth amount\r\n        bool[] supported; // false means unsupported\r\n    }\r\n\r\n    // -------------------- variate ------------------------ //\r\n    address public resonanceAddress;\r\n    address public owner;\r\n\r\n    constructor()\r\n    public{\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // -------------------- modifier ------------------------ //\r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyResonance (){\r\n        require(msg.sender == resonanceAddress);\r\n        _;\r\n    }\r\n\r\n    // -------------------- owner api ------------------------ //\r\n    function allowResonance(address _addr) public onlyOwner() {\r\n        resonanceAddress = _addr;\r\n    }\r\n\r\n    // -------------------- Resonance api ----------------//\r\n    function getRecommendByIndex(uint256 index, address userAddress)\r\n    public\r\n    view\r\n//    onlyResonance() TODO\r\n    returns (\r\n        uint256 straightTime,\r\n        address refeAddress,\r\n        uint256 ethAmount,\r\n        bool supported\r\n    )\r\n    {\r\n        straightTime = recommendRecord[userAddress].straightTime[index];\r\n        refeAddress = recommendRecord[userAddress].refeAddress[index];\r\n        ethAmount = recommendRecord[userAddress].ethAmount[index];\r\n        supported = recommendRecord[userAddress].supported[index];\r\n    }\r\n\r\n    function pushRecommend(\r\n        address userAddress,\r\n        address refeAddress,\r\n        uint256 ethAmount\r\n    )\r\n    public\r\n    onlyResonance()\r\n    {\r\n        RecommendRecord storage _recommendRecord = recommendRecord[userAddress];\r\n        _recommendRecord.straightTime.push(block.timestamp);\r\n        _recommendRecord.refeAddress.push(refeAddress);\r\n        _recommendRecord.ethAmount.push(ethAmount);\r\n        _recommendRecord.supported.push(false);\r\n    }\r\n\r\n    function setSupported(uint256 index, address userAddress, bool supported)\r\n    public\r\n    onlyResonance()\r\n    {\r\n        recommendRecord[userAddress].supported[index] = supported;\r\n    }\r\n\r\n    // -------------------- user api ------------------------ //\r\n    // get current address\u0027s recommend record\r\n    function getRecommendRecord()\r\n    public\r\n    view\r\n    returns (\r\n        uint256[] memory straightTime,\r\n        address[] memory refeAddress,\r\n        uint256[] memory ethAmount,\r\n        bool[]    memory supported\r\n    )\r\n    {\r\n        RecommendRecord memory records = recommendRecord[msg.sender];\r\n        straightTime = records.straightTime;\r\n        refeAddress = records.refeAddress;\r\n        ethAmount = records.ethAmount;\r\n        supported = records.supported;\r\n    }\r\n\r\n}\r\n"},"Resonance.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Earnings.sol\";\r\nimport \"./TeamRewards.sol\";\r\nimport \"./Terminator.sol\";\r\nimport \"./Recommend.sol\";\r\n\r\nimport \"./ResonanceF.sol\";\r\n\r\ncontract Resonance is ResonanceF {\r\n    using SafeMath for uint256;\r\n\r\n    uint256     public totalSupply = 0;\r\n    uint256     constant internal bonusPrice = 0.0000001 ether; // init price\r\n    uint256     constant internal priceIncremental = 0.00000001 ether; // increase price\r\n    uint256     constant internal magnitude = 2 ** 64;\r\n    uint256     public perBonusDivide = 0; //per Profit divide\r\n    uint256     public  systemRetain = 0;\r\n    uint256     public terminatorPoolAmount; //terminator award Pool Amount\r\n    uint256     public activateSystem = 20;\r\n    uint256     public activateGlobal = 20;\r\n\r\n    mapping(address =\u003e User) public userInfo; // user define all user\u0027s information\r\n    mapping(address =\u003e address[]) public straightInviteAddress; // user  effective straight invite address, sort reward\r\n    mapping(address =\u003e int256) internal payoutsTo; // record\r\n    mapping(address =\u003e uint256[11]) public userSubordinateCount;\r\n    mapping(address =\u003e uint256) public whitelistPerformance;\r\n    mapping(address =\u003e UserReinvest) public userReinvest;\r\n    mapping(address =\u003e uint256) public lastStraightLength;\r\n\r\n    uint8   constant internal remain = 20;       // Static and dynamic rewards returns remain at 20 percent\r\n    uint32  constant internal ratio = 1000;      // eth to erc20 token ratio\r\n    uint32  constant internal blockNumber = 40000; // straight sort reward block number\r\n    uint256 public   currentBlockNumber;\r\n    uint256 public   straightSortRewards = 0;\r\n    uint256  public initAddressAmount = 0;   // The first 100 addresses and enough to 1 eth, 100 -500 enough to 5 eth, 500 addresses later cancel limit\r\n    uint256 public totalEthAmount = 0; // all user total buy eth amount\r\n    uint8 constant public percent = 100;\r\n\r\n    address  public eggAddress = address(0x12d4fEcccc3cbD5F7A2C9b88D709317e0E616691);   // total eth 1 percent to  egg address\r\n    address  public systemAddress = address(0x6074510054e37D921882B05Ab40537Ce3887F3AD);\r\n    address  public nodeAddressReward = address(0xB351d5030603E8e89e1925f6d6F50CDa4D6754A6);\r\n    address  public globalAddressReward = address(0x49eec1928b457d1f26a2466c8bd9eC1318EcB68f);\r\n    address [10] public straightSort; // straight reward\r\n\r\n    Earnings internal earningsInstance;\r\n    TeamRewards internal teamRewardInstance;\r\n    Terminator internal terminatorInstance;\r\n    Recommend internal recommendInstance;\r\n\r\n    struct User {\r\n        address userAddress;  // user address\r\n        uint256 ethAmount;    // user buy eth amount\r\n        uint256 profitAmount; // user profit amount\r\n        uint256 tokenAmount;  // user get token amount\r\n        uint256 tokenProfit;  // profit by profitAmount\r\n        uint256 straightEth;  // user straight eth\r\n        uint256 lockStraight;\r\n        uint256 teamEth;      // team eth reward\r\n        bool staticTimeout;      // static timeout, 3 days\r\n        uint256 staticTime;     // record static out time\r\n        uint8 level;        // user team level\r\n        address straightAddress;\r\n        uint256 refeTopAmount; // subordinate address topmost eth amount\r\n        address refeTopAddress; // subordinate address topmost eth address\r\n    }\r\n\r\n    struct UserReinvest {\r\n//        uint256 nodeReinvest;\r\n        uint256 staticReinvest;\r\n        bool    isPush;\r\n    }\r\n\r\n    uint8[7] internal rewardRatio;  // [0] means market support rewards         10%\r\n    // [1] means static rewards                 30%\r\n    // [2] means straight rewards               30%\r\n    // [3] means team rewards                   29%\r\n    // [4] means terminator rewards             5%\r\n    // [5] means straight sort rewards          5%\r\n    // [6] means egg rewards                    1%\r\n\r\n    uint8[11] internal teamRatio; // team reward ratio\r\n\r\n    modifier mustAdmin (address adminAddress){\r\n        require(adminAddress != address(0));\r\n        require(adminAddress == admin[0] || adminAddress == admin[1] || adminAddress == admin[2] || adminAddress == admin[3] || adminAddress == admin[4]);\r\n        _;\r\n    }\r\n\r\n    modifier mustReferralAddress (address referralAddress) {\r\n        require(msg.sender != admin[0] || msg.sender != admin[1] || msg.sender != admin[2] || msg.sender != admin[3] || msg.sender != admin[4]);\r\n        if (teamRewardInstance.isWhitelistAddress(msg.sender)) {\r\n            require(referralAddress == admin[0] || referralAddress == admin[1] || referralAddress == admin[2] || referralAddress == admin[3] || referralAddress == admin[4]);\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier limitInvestmentCondition(uint256 ethAmount){\r\n         if (initAddressAmount \u003c= 50) {\r\n            require(ethAmount \u003c= 5 ether);\r\n            _;\r\n        } else {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier limitAddressReinvest() {\r\n        if (initAddressAmount \u003c= 50 \u0026\u0026 userInfo[msg.sender].ethAmount \u003e 0) {\r\n            require(msg.value \u003c= userInfo[msg.sender].ethAmount.mul(3));\r\n        }\r\n        _;\r\n    }\r\n    // -------------------- modifier ------------------------ //\r\n\r\n    // --------------------- event -------------------------- //\r\n    event WithdrawStaticProfits(address indexed user, uint256 ethAmount);\r\n    event Buy(address indexed user, uint256 ethAmount, uint256 buyTime);\r\n    event Withdraw(address indexed user, uint256 ethAmount, uint8 indexed value, uint256 buyTime);\r\n    event Reinvest(address indexed user, uint256 indexed ethAmount, uint8 indexed value, uint256 buyTime);\r\n    event SupportSubordinateAddress(uint256 indexed index, address indexed subordinate, address indexed refeAddress, bool supported);\r\n    // --------------------- event -------------------------- //\r\n\r\n    constructor(\r\n        address _erc20Address,\r\n        address _earningsAddress,\r\n        address _teamRewardsAddress,\r\n        address _terminatorAddress,\r\n        address _recommendAddress\r\n    )\r\n    public\r\n    {\r\n        earningsInstance = Earnings(_earningsAddress);\r\n        teamRewardInstance = TeamRewards(_teamRewardsAddress);\r\n        terminatorInstance = Terminator(_terminatorAddress);\r\n        kocInstance = KOCToken(_erc20Address);\r\n        recommendInstance = Recommend(_recommendAddress);\r\n        rewardRatio = [10, 30, 30, 29, 5, 5, 1];\r\n        teamRatio = [6, 5, 4, 3, 3, 2, 2, 1, 1, 1, 1];\r\n        currentBlockNumber = block.number;\r\n    }\r\n\r\n    // -------------------- user api ----------------//\r\n    function buy(address referralAddress)\r\n    public\r\n    mustReferralAddress(referralAddress)\r\n    limitInvestmentCondition(msg.value)\r\n    payable\r\n    {\r\n        require(!teamRewardInstance.getWhitelistTime());\r\n        uint256 ethAmount = msg.value;\r\n        address userAddress = msg.sender;\r\n        User storage _user = userInfo[userAddress];\r\n\r\n        _user.userAddress = userAddress;\r\n\r\n        if (_user.ethAmount == 0 \u0026\u0026 !teamRewardInstance.isWhitelistAddress(userAddress)) {\r\n            teamRewardInstance.referralPeople(userAddress, referralAddress);\r\n            _user.straightAddress = referralAddress;\r\n        } else {\r\n            referralAddress == teamRewardInstance.getUserreferralAddress(userAddress);\r\n        }\r\n\r\n        address straightAddress;\r\n        address whiteAddress;\r\n        address adminAddress;\r\n        bool whitelist;\r\n        (straightAddress, whiteAddress, adminAddress, whitelist) = teamRewardInstance.getUserSystemInfo(userAddress);\r\n        require(adminAddress == admin[0] || adminAddress == admin[1] || adminAddress == admin[2] || adminAddress == admin[3] || adminAddress == admin[4]);\r\n\r\n        if (userInfo[referralAddress].userAddress == address(0)) {\r\n            userInfo[referralAddress].userAddress = referralAddress;\r\n        }\r\n\r\n        if (userInfo[userAddress].straightAddress == address(0)) {\r\n            userInfo[userAddress].straightAddress = straightAddress;\r\n        }\r\n\r\n        // uint256 _withdrawStatic;\r\n        uint256 _lockEth;\r\n        uint256 _withdrawTeam;\r\n        (, _lockEth, _withdrawTeam) = earningsInstance.getStaticAfterFoundsTeam(userAddress);\r\n\r\n        if (ethAmount \u003e= _lockEth) {\r\n            ethAmount = ethAmount.add(_lockEth);\r\n            if (userInfo[userAddress].staticTimeout \u0026\u0026 userInfo[userAddress].staticTime + 3 days \u003c block.timestamp) {\r\n                address(uint160(systemAddress)).transfer(userInfo[userAddress].teamEth.sub(_withdrawTeam.mul(100).div(80)));\r\n                userInfo[userAddress].teamEth = 0;\r\n                earningsInstance.changeWithdrawTeamZero(userAddress);\r\n            }\r\n            userInfo[userAddress].staticTimeout = false;\r\n            userInfo[userAddress].staticTime = block.timestamp;\r\n        } else {\r\n            _lockEth = ethAmount;\r\n            ethAmount = ethAmount.mul(2);\r\n        }\r\n\r\n        earningsInstance.addActivateEth(userAddress, _lockEth);\r\n        if (initAddressAmount \u003c= 50 \u0026\u0026 userInfo[userAddress].ethAmount \u003e 0) {\r\n            require(userInfo[userAddress].profitAmount == 0);\r\n        }\r\n\r\n        if (ethAmount \u003e= 1 ether \u0026\u0026 _user.ethAmount == 0) {// when initAddressAmount \u003c= 500, address can only invest once before out of static\r\n            initAddressAmount++;\r\n        }\r\n\r\n        calculateBuy(_user, ethAmount, straightAddress, whiteAddress, adminAddress, userAddress);\r\n\r\n        straightReferralReward(_user, ethAmount);\r\n        // calculate straight referral reward\r\n\r\n        uint256 topProfits = whetherTheCap();\r\n        require(earningsInstance.getWithdrawStatic(msg.sender).mul(100).div(80) \u003c= topProfits);\r\n\r\n        emit Buy(userAddress, ethAmount, block.timestamp);\r\n    }\r\n\r\n    // contains some methods for buy or reinvest\r\n    function calculateBuy(\r\n        User storage user,\r\n        uint256 ethAmount,\r\n        address straightAddress,\r\n        address whiteAddress,\r\n        address adminAddress,\r\n        address users\r\n    )\r\n    internal\r\n    {\r\n        require(ethAmount \u003e 0);\r\n        user.ethAmount = teamRewardInstance.isWhitelistAddress(user.userAddress) ? (ethAmount.mul(110).div(100)).add(user.ethAmount) : ethAmount.add(user.ethAmount);\r\n\r\n        if (user.ethAmount \u003e user.refeTopAmount.mul(60).div(100)) {\r\n            user.straightEth += user.lockStraight;\r\n            user.lockStraight = 0;\r\n        }\r\n        if (user.ethAmount \u003e= 1 ether \u0026\u0026 !userReinvest[user.userAddress].isPush \u0026\u0026 !teamRewardInstance.isWhitelistAddress(user.userAddress)) {\r\n                straightInviteAddress[straightAddress].push(user.userAddress);\r\n                userReinvest[user.userAddress].isPush = true;\r\n                // record straight address\r\n            if (straightInviteAddress[straightAddress].length.sub(lastStraightLength[straightAddress]) \u003e straightInviteAddress[straightSort[9]].length.sub(lastStraightLength[straightSort[9]])) {\r\n                    bool has = false;\r\n                    //search this address\r\n                    for (uint i = 0; i \u003c 10; i++) {\r\n                        if (straightSort[i] == straightAddress) {\r\n                            has = true;\r\n                        }\r\n                    }\r\n                    if (!has) {\r\n                        //search this address if not in this array,go sort after cover last\r\n                        straightSort[9] = straightAddress;\r\n                    }\r\n                    // sort referral address\r\n                    quickSort(straightSort, int(0), int(9));\r\n                    // straightSortAddress(straightAddress);\r\n                }\r\n//            }\r\n\r\n        }\r\n\r\n        address(uint160(eggAddress)).transfer(ethAmount.mul(rewardRatio[6]).div(100));\r\n        // transfer to eggAddress 1% eth\r\n\r\n        straightSortRewards += ethAmount.mul(rewardRatio[5]).div(100);\r\n        // straight sort rewards, 5% eth\r\n\r\n        teamReferralReward(ethAmount, straightAddress);\r\n        // issue team reward\r\n\r\n        terminatorPoolAmount += ethAmount.mul(rewardRatio[4]).div(100);\r\n        // issue terminator reward\r\n\r\n        calculateToken(user, ethAmount);\r\n        // calculate and transfer KOC token\r\n\r\n        calculateProfit(user, ethAmount, users);\r\n        // calculate user earn profit\r\n\r\n        updateTeamLevel(straightAddress);\r\n        // update team level\r\n\r\n        totalEthAmount += ethAmount;\r\n\r\n        whitelistPerformance[whiteAddress] += ethAmount;\r\n        whitelistPerformance[adminAddress] += ethAmount;\r\n\r\n        addTerminator(user.userAddress);\r\n    }\r\n\r\n    // contains five kinds of reinvest, 1 means reinvest static rewards, 2 means recommend rewards\r\n    //                                  3 means team rewards,  4 means terminators rewards, 5 means node rewards\r\n    function reinvest(uint256 amount, uint8 value)\r\n    public\r\n    payable\r\n    {\r\n        address reinvestAddress = msg.sender;\r\n\r\n        address straightAddress;\r\n        address whiteAddress;\r\n        address adminAddress;\r\n        (straightAddress, whiteAddress, adminAddress,) = teamRewardInstance.getUserSystemInfo(msg.sender);\r\n\r\n        require(value == 1 || value == 2 || value == 3 || value == 4, \"resonance 303\");\r\n\r\n        uint256 earningsProfits = 0;\r\n\r\n        if (value == 1) {\r\n            earningsProfits = whetherTheCap();\r\n            uint256 _withdrawStatic;\r\n            uint256 _afterFounds;\r\n            uint256 _withdrawTeam;\r\n            (_withdrawStatic, _afterFounds, _withdrawTeam) = earningsInstance.getStaticAfterFoundsTeam(reinvestAddress);\r\n\r\n            _withdrawStatic = _withdrawStatic.mul(100).div(80);\r\n            require(_withdrawStatic.add(userReinvest[reinvestAddress].staticReinvest).add(amount) \u003c= earningsProfits);\r\n\r\n            if (amount \u003e= _afterFounds) {\r\n                if (userInfo[reinvestAddress].staticTimeout \u0026\u0026 userInfo[reinvestAddress].staticTime + 3 days \u003c block.timestamp) {\r\n                    address(uint160(systemAddress)).transfer(userInfo[reinvestAddress].teamEth.sub(_withdrawTeam.mul(100).div(80)));\r\n                    userInfo[reinvestAddress].teamEth = 0;\r\n                    earningsInstance.changeWithdrawTeamZero(reinvestAddress);\r\n                }\r\n                userInfo[reinvestAddress].staticTimeout = false;\r\n                userInfo[reinvestAddress].staticTime = block.timestamp;\r\n            }\r\n            userReinvest[reinvestAddress].staticReinvest += amount;\r\n        } else if (value == 2) {\r\n            //复投直推\r\n            require(userInfo[reinvestAddress].straightEth \u003e= amount);\r\n            userInfo[reinvestAddress].straightEth = userInfo[reinvestAddress].straightEth.sub(amount);\r\n\r\n            earningsProfits = userInfo[reinvestAddress].straightEth;\r\n        } else if (value == 3) {\r\n            require(userInfo[reinvestAddress].teamEth \u003e= amount);\r\n            userInfo[reinvestAddress].teamEth = userInfo[reinvestAddress].teamEth.sub(amount);\r\n\r\n            earningsProfits = userInfo[reinvestAddress].teamEth;\r\n        } else if (value == 4) {\r\n            terminatorInstance.reInvestTerminatorReward(reinvestAddress, amount);\r\n        }\r\n\r\n        amount = earningsInstance.calculateReinvestAmount(msg.sender, amount, earningsProfits, value);\r\n\r\n        calculateBuy(userInfo[reinvestAddress], amount, straightAddress, whiteAddress, adminAddress, reinvestAddress);\r\n\r\n        straightReferralReward(userInfo[reinvestAddress], amount);\r\n\r\n        emit Reinvest(reinvestAddress, amount, value, block.timestamp);\r\n    }\r\n\r\n    // contains five kinds of withdraw, 1 means withdraw static rewards, 2 means recommend rewards\r\n    //                                  3 means team rewards,  4 means terminators rewards, 5 means node rewards\r\n    function withdraw(uint256 amount, uint8 value)\r\n    public\r\n    {\r\n        address withdrawAddress = msg.sender;\r\n        require(value == 1 || value == 2 || value == 3 || value == 4);\r\n\r\n        uint256 _lockProfits = 0;\r\n        uint256 _userRouteEth = 0;\r\n        uint256 transValue = amount.mul(80).div(100);\r\n\r\n        if (value == 1) {\r\n            _userRouteEth = whetherTheCap();\r\n            _lockProfits = SafeMath.mul(amount, remain).div(100);\r\n        } else if (value == 2) {\r\n            _userRouteEth = userInfo[withdrawAddress].straightEth;\r\n        } else if (value == 3) {\r\n            if (userInfo[withdrawAddress].staticTimeout) {\r\n                require(userInfo[withdrawAddress].staticTime + 3 days \u003e= block.timestamp);\r\n            }\r\n            _userRouteEth = userInfo[withdrawAddress].teamEth;\r\n        } else if (value == 4) {\r\n            _userRouteEth = amount.mul(80).div(100);\r\n            terminatorInstance.modifyTerminatorReward(withdrawAddress, _userRouteEth);\r\n        }\r\n\r\n        earningsInstance.routeAddLockEth(withdrawAddress, amount, _lockProfits, _userRouteEth, value);\r\n\r\n        address(uint160(withdrawAddress)).transfer(transValue);\r\n\r\n        emit Withdraw(withdrawAddress, amount, value, block.timestamp);\r\n    }\r\n\r\n    // referral address support subordinate, 10%\r\n    function supportSubordinateAddress(uint256 index, address subordinate)\r\n    public\r\n    payable\r\n    {\r\n        User storage _user = userInfo[msg.sender];\r\n\r\n        require(_user.ethAmount.sub(_user.tokenProfit.mul(100).div(120)) \u003e= _user.refeTopAmount.mul(60).div(100));\r\n\r\n        uint256 straightTime;\r\n        address refeAddress;\r\n        uint256 ethAmount;\r\n        bool supported;\r\n        (straightTime, refeAddress, ethAmount, supported) = recommendInstance.getRecommendByIndex(index, _user.userAddress);\r\n        require(!supported);\r\n\r\n        require(straightTime.add(3 days) \u003e= block.timestamp \u0026\u0026 refeAddress == subordinate \u0026\u0026 msg.value \u003e= ethAmount.div(10));\r\n\r\n        if (_user.ethAmount.add(msg.value) \u003e= _user.refeTopAmount.mul(60).div(100)) {\r\n            _user.straightEth += ethAmount.mul(rewardRatio[2]).div(100);\r\n        } else {\r\n            _user.lockStraight += ethAmount.mul(rewardRatio[2]).div(100);\r\n        }\r\n\r\n        address straightAddress;\r\n        address whiteAddress;\r\n        address adminAddress;\r\n        (straightAddress, whiteAddress, adminAddress,) = teamRewardInstance.getUserSystemInfo(subordinate);\r\n        calculateBuy(userInfo[subordinate], msg.value, straightAddress, whiteAddress, adminAddress, subordinate);\r\n\r\n        recommendInstance.setSupported(index, _user.userAddress, true);\r\n\r\n        emit SupportSubordinateAddress(index, subordinate, refeAddress, supported);\r\n    }\r\n\r\n    // -------------------- internal function ----------------//\r\n    // calculate team reward and issue reward\r\n    //teamRatio = [6, 5, 4, 3, 3, 2, 2, 1, 1, 1, 1];\r\n    function teamReferralReward(uint256 ethAmount, address referralStraightAddress)\r\n    internal\r\n    {\r\n        if (teamRewardInstance.isWhitelistAddress(msg.sender)) {\r\n            uint256 _systemRetain = ethAmount.mul(rewardRatio[3]).div(100);\r\n            uint256 _nodeReward = _systemRetain.mul(activateSystem).div(100);\r\n            systemRetain += _nodeReward;\r\n            address(uint160(nodeAddressReward)).transfer(_nodeReward.mul(100 - activateGlobal).div(100));\r\n            address(uint160(globalAddressReward)).transfer(_nodeReward.mul(activateGlobal).div(100));\r\n            address(uint160(systemAddress)).transfer(_systemRetain.mul(100 - activateSystem).div(100));\r\n        } else {\r\n            uint256 _refeReward = ethAmount.mul(rewardRatio[3]).div(100);\r\n\r\n            //system residue eth\r\n            uint256 residueAmount = _refeReward;\r\n\r\n            //user straight address\r\n            User memory currentUser = userInfo[referralStraightAddress];\r\n\r\n            //issue team reward\r\n            for (uint8 i = 2; i \u003c= 12; i++) {//i start at 2, end at 12\r\n                //get straight user\r\n                address straightAddress = currentUser.straightAddress;\r\n\r\n                User storage currentUserStraight = userInfo[straightAddress];\r\n                //if straight user meet requirements\r\n                if (currentUserStraight.level \u003e= i) {\r\n                    uint256 currentReward = _refeReward.mul(teamRatio[i - 2]).div(29);\r\n                    currentUserStraight.teamEth = currentUserStraight.teamEth.add(currentReward);\r\n                    //sub reward amount\r\n                    residueAmount = residueAmount.sub(currentReward);\r\n                }\r\n\r\n                currentUser = userInfo[straightAddress];\r\n            }\r\n\r\n            uint256 _nodeReward = residueAmount.mul(activateSystem).div(100);\r\n            systemRetain = systemRetain.add(_nodeReward);\r\n            address(uint160(systemAddress)).transfer(residueAmount.mul(100 - activateSystem).div(100));\r\n\r\n            address(uint160(nodeAddressReward)).transfer(_nodeReward.mul(100 - activateGlobal).div(100));\r\n            address(uint160(globalAddressReward)).transfer(_nodeReward.mul(activateGlobal).div(100));\r\n        }\r\n    }\r\n\r\n    function updateTeamLevel(address refferAddress)\r\n    internal\r\n    {\r\n        User memory currentUserStraight = userInfo[refferAddress];\r\n\r\n        uint8 levelUpCount = 0;\r\n\r\n        uint256 currentInviteCount = straightInviteAddress[refferAddress].length;\r\n        if (currentInviteCount \u003e= 2) {\r\n            levelUpCount = 2;\r\n        }\r\n\r\n        if (currentInviteCount \u003e 12) {\r\n            currentInviteCount = 12;\r\n        }\r\n\r\n        uint256 lackCount = 0;\r\n        for (uint8 j = 2; j \u003c currentInviteCount; j++) {\r\n            if (userSubordinateCount[refferAddress][j - 1] \u003e= 1 + lackCount) {\r\n                levelUpCount = j + 1;\r\n                lackCount = 0;\r\n            } else {\r\n                lackCount++;\r\n            }\r\n        }\r\n\r\n        if (levelUpCount \u003e currentUserStraight.level) {\r\n            uint8 oldLevel = userInfo[refferAddress].level;\r\n            userInfo[refferAddress].level = levelUpCount;\r\n\r\n            if (currentUserStraight.straightAddress != address(0)) {\r\n                if (oldLevel \u003e 0) {\r\n                    if (userSubordinateCount[currentUserStraight.straightAddress][oldLevel - 1] \u003e 0) {\r\n                        userSubordinateCount[currentUserStraight.straightAddress][oldLevel - 1] = userSubordinateCount[currentUserStraight.straightAddress][oldLevel - 1] - 1;\r\n                    }\r\n                }\r\n\r\n                userSubordinateCount[currentUserStraight.straightAddress][levelUpCount - 1] = userSubordinateCount[currentUserStraight.straightAddress][levelUpCount - 1] + 1;\r\n                updateTeamLevel(currentUserStraight.straightAddress);\r\n            }\r\n        }\r\n    }\r\n\r\n    // calculate bonus profit\r\n    function calculateProfit(User storage user, uint256 ethAmount, address users)\r\n    internal\r\n    {\r\n        if (teamRewardInstance.isWhitelistAddress(user.userAddress)) {\r\n            ethAmount = ethAmount.mul(110).div(100);\r\n        }\r\n\r\n        uint256 userBonus = ethToBonus(ethAmount);\r\n        require(userBonus \u003e= 0 \u0026\u0026 SafeMath.add(userBonus, totalSupply) \u003e= totalSupply);\r\n        totalSupply += userBonus;\r\n        uint256 tokenDivided = SafeMath.mul(ethAmount, rewardRatio[1]).div(100);\r\n        getPerBonusDivide(tokenDivided, userBonus, users);\r\n        user.profitAmount += userBonus;\r\n    }\r\n\r\n    // get user bonus information for calculate static rewards\r\n    function getPerBonusDivide(uint256 tokenDivided, uint256 userBonus, address users)\r\n    public\r\n    {\r\n        uint256 fee = tokenDivided * magnitude;\r\n        perBonusDivide += SafeMath.div(SafeMath.mul(tokenDivided, magnitude), totalSupply);\r\n        //calculate every bonus earnings eth\r\n        fee = fee - (fee - (userBonus * (tokenDivided * magnitude / (totalSupply))));\r\n\r\n        int256 updatedPayouts = (int256) ((perBonusDivide * userBonus) - fee);\r\n\r\n        payoutsTo[users] += updatedPayouts;\r\n    }\r\n\r\n    // calculate and transfer KOC token\r\n    function calculateToken(User storage user, uint256 ethAmount)\r\n    internal\r\n    {\r\n        kocInstance.transfer(user.userAddress, ethAmount.mul(ratio));\r\n        user.tokenAmount += ethAmount.mul(ratio);\r\n    }\r\n\r\n    // calculate straight reward and record referral address recommendRecord\r\n    function straightReferralReward(User memory user, uint256 ethAmount)\r\n    internal\r\n    {\r\n        address _referralAddresses = user.straightAddress;\r\n        userInfo[_referralAddresses].refeTopAmount = (userInfo[_referralAddresses].refeTopAmount \u003e user.ethAmount) ? userInfo[_referralAddresses].refeTopAmount : user.ethAmount;\r\n        userInfo[_referralAddresses].refeTopAddress = (userInfo[_referralAddresses].refeTopAmount \u003e user.ethAmount) ? userInfo[_referralAddresses].refeTopAddress : user.userAddress;\r\n\r\n        recommendInstance.pushRecommend(_referralAddresses, user.userAddress, ethAmount);\r\n\r\n        if (teamRewardInstance.isWhitelistAddress(user.userAddress)) {\r\n            uint256 _systemRetain = ethAmount.mul(rewardRatio[2]).div(100);\r\n\r\n            uint256 _nodeReward = _systemRetain.mul(activateSystem).div(100);\r\n            systemRetain += _nodeReward;\r\n            address(uint160(systemAddress)).transfer(_systemRetain.mul(100 - activateSystem).div(100));\r\n\r\n            address(uint160(globalAddressReward)).transfer(_nodeReward.mul(activateGlobal).div(100));\r\n            address(uint160(nodeAddressReward)).transfer(_nodeReward.mul(100 - activateGlobal).div(100));\r\n        }\r\n    }\r\n\r\n    // sort straight address, 10\r\n    function straightSortAddress(address referralAddress)\r\n    internal\r\n    {\r\n        for (uint8 i = 0; i \u003c 10; i++) {\r\n            if (straightInviteAddress[straightSort[i]].length.sub(lastStraightLength[straightSort[i]]) \u003c straightInviteAddress[referralAddress].length.sub(lastStraightLength[referralAddress])) {\r\n                address  [] memory temp;\r\n                for (uint j = i; j \u003c 10; j++) {\r\n                    temp[j] = straightSort[j];\r\n                }\r\n                straightSort[i] = referralAddress;\r\n                for (uint k = i; k \u003c 9; k++) {\r\n                    straightSort[k + 1] = temp[k];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //sort straight address, 10\r\n    function quickSort(address  [10] storage arr, int left, int right) internal {\r\n        int i = left;\r\n        int j = right;\r\n        if (i == j) return;\r\n        uint pivot = straightInviteAddress[arr[uint(left + (right - left) / 2)]].length.sub(lastStraightLength[arr[uint(left + (right - left) / 2)]]);\r\n        while (i \u003c= j) {\r\n            while (straightInviteAddress[arr[uint(i)]].length.sub(lastStraightLength[arr[uint(i)]]) \u003e pivot) i++;\r\n            while (pivot \u003e straightInviteAddress[arr[uint(j)]].length.sub(lastStraightLength[arr[uint(j)]])) j--;\r\n            if (i \u003c= j) {\r\n                (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);\r\n                i++;\r\n                j--;\r\n            }\r\n        }\r\n        if (left \u003c j)\r\n            quickSort(arr, left, j);\r\n        if (i \u003c right)\r\n            quickSort(arr, i, right);\r\n    }\r\n\r\n    // settle straight rewards\r\n    function settleStraightRewards()\r\n    internal\r\n    {\r\n        uint256 addressAmount;\r\n        for (uint8 i = 0; i \u003c 10; i++) {\r\n            addressAmount += straightInviteAddress[straightSort[i]].length - lastStraightLength[straightSort[i]];\r\n        }\r\n\r\n        uint256 _straightSortRewards = SafeMath.div(straightSortRewards, 2);\r\n        uint256 perAddressReward = SafeMath.div(_straightSortRewards, addressAmount);\r\n        for (uint8 j = 0; j \u003c 10; j++) {\r\n            address(uint160(straightSort[j])).transfer(SafeMath.mul(straightInviteAddress[straightSort[j]].length.sub(lastStraightLength[straightSort[j]]), perAddressReward));\r\n            straightSortRewards = SafeMath.sub(straightSortRewards, SafeMath.mul(straightInviteAddress[straightSort[j]].length.sub(lastStraightLength[straightSort[j]]), perAddressReward));\r\n            lastStraightLength[straightSort[j]] = straightInviteAddress[straightSort[j]].length;\r\n        }\r\n        delete (straightSort);\r\n        currentBlockNumber = block.number;\r\n    }\r\n\r\n    // calculate bonus\r\n    function ethToBonus(uint256 ethereum)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 _price = bonusPrice * 1e18;\r\n        // calculate by wei\r\n        uint256 _tokensReceived =\r\n        (\r\n        (\r\n        SafeMath.sub(\r\n            (sqrt\r\n        (\r\n            (_price ** 2)\r\n            +\r\n            (2 * (priceIncremental * 1e18) * (ethereum * 1e18))\r\n            +\r\n            (((priceIncremental) ** 2) * (totalSupply ** 2))\r\n            +\r\n            (2 * (priceIncremental) * _price * totalSupply)\r\n        )\r\n            ), _price\r\n        )\r\n        ) / (priceIncremental)\r\n        ) - (totalSupply);\r\n\r\n        return _tokensReceived;\r\n    }\r\n\r\n    // utils for calculate bonus\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z \u003c y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n\r\n    // get user bonus profits\r\n    function myBonusProfits(address user)\r\n    view\r\n    public\r\n    returns (uint256)\r\n    {\r\n        return (uint256) ((int256)(perBonusDivide.mul(userInfo[user].profitAmount)) - payoutsTo[user]).div(magnitude);\r\n    }\r\n\r\n    function whetherTheCap()\r\n    internal\r\n    returns (uint256)\r\n    {\r\n        require(userInfo[msg.sender].ethAmount.mul(120).div(100) \u003e= userInfo[msg.sender].tokenProfit);\r\n        uint256 _currentAmount = userInfo[msg.sender].ethAmount.sub(userInfo[msg.sender].tokenProfit.mul(100).div(120));\r\n        uint256 topProfits = _currentAmount.mul(remain + 100).div(100);\r\n        uint256 userProfits = myBonusProfits(msg.sender);\r\n\r\n        if (userProfits \u003e topProfits) {\r\n            userInfo[msg.sender].profitAmount = 0;\r\n            payoutsTo[msg.sender] = 0;\r\n            userInfo[msg.sender].tokenProfit += topProfits;\r\n            userInfo[msg.sender].staticTime = block.timestamp;\r\n            userInfo[msg.sender].staticTimeout = true;\r\n        }\r\n\r\n        if (topProfits == 0) {\r\n            topProfits = userInfo[msg.sender].tokenProfit;\r\n        } else {\r\n            topProfits = (userProfits \u003e= topProfits) ? topProfits : userProfits.add(userInfo[msg.sender].tokenProfit); // not add again\r\n        }\r\n\r\n        return topProfits;\r\n    }\r\n\r\n    // -------------------- set api ---------------- //\r\n    function setStraightSortRewards()\r\n    public\r\n    onlyAdmin()\r\n    returns (bool)\r\n    {\r\n        require(currentBlockNumber + blockNumber \u003c block.number);\r\n        settleStraightRewards();\r\n        return true;\r\n    }\r\n\r\n    // -------------------- get api ---------------- //\r\n    // get straight sort list, 10 addresses\r\n    function getStraightSortList()\r\n    public\r\n    view\r\n    returns (address[10] memory)\r\n    {\r\n        return straightSort;\r\n    }\r\n\r\n    // get effective straight addresses current step\r\n    function getStraightInviteAddress()\r\n    public\r\n    view\r\n    returns (address[] memory)\r\n    {\r\n        return straightInviteAddress[msg.sender];\r\n    }\r\n\r\n    // get currentBlockNumber\r\n    function getcurrentBlockNumber()\r\n    public\r\n    view\r\n    returns (uint256){\r\n        return currentBlockNumber;\r\n    }\r\n\r\n    function getPurchaseTasksInfo()\r\n    public\r\n    view\r\n    returns (\r\n        uint256 ethAmount,\r\n        uint256 refeTopAmount,\r\n        address refeTopAddress,\r\n        uint256 lockStraight\r\n    )\r\n    {\r\n        User memory getUser = userInfo[msg.sender];\r\n        ethAmount = getUser.ethAmount.sub(getUser.tokenProfit.mul(100).div(120));\r\n        refeTopAmount = getUser.refeTopAmount;\r\n        refeTopAddress = getUser.refeTopAddress;\r\n        lockStraight = getUser.lockStraight;\r\n    }\r\n\r\n    function getPersonalStatistics()\r\n    public\r\n    view\r\n    returns (\r\n        uint256 holdings,\r\n        uint256 dividends,\r\n        uint256 invites,\r\n        uint8 level,\r\n        uint256 afterFounds,\r\n        uint256 referralRewards,\r\n        uint256 teamRewards,\r\n        uint256 nodeRewards\r\n    )\r\n    {\r\n        User memory getUser = userInfo[msg.sender];\r\n\r\n        uint256 _withdrawStatic;\r\n        (_withdrawStatic, afterFounds) = earningsInstance.getStaticAfterFounds(getUser.userAddress);\r\n\r\n        holdings = getUser.ethAmount.sub(getUser.tokenProfit.mul(100).div(120));\r\n        dividends = (myBonusProfits(msg.sender) \u003e= holdings.mul(120).div(100)) ? holdings.mul(120).div(100) : myBonusProfits(msg.sender);\r\n        invites = straightInviteAddress[msg.sender].length;\r\n        level = getUser.level;\r\n        referralRewards = getUser.straightEth;\r\n        teamRewards = getUser.teamEth;\r\n        uint256 _nodeRewards = (totalEthAmount == 0) ? 0 : whitelistPerformance[msg.sender].mul(systemRetain).div(totalEthAmount);\r\n        nodeRewards = (whitelistPerformance[msg.sender] \u003c 500 ether) ? 0 : _nodeRewards;\r\n    }\r\n\r\n    function getUserBalance()\r\n    public\r\n    view\r\n    returns (\r\n        uint256 staticBalance,\r\n        uint256 recommendBalance,\r\n        uint256 teamBalance,\r\n        uint256 terminatorBalance,\r\n        uint256 nodeBalance,\r\n        uint256 totalInvest,\r\n        uint256 totalDivided,\r\n        uint256 withdrawDivided\r\n    )\r\n    {\r\n        User memory getUser = userInfo[msg.sender];\r\n        uint256 _currentEth = getUser.ethAmount.sub(getUser.tokenProfit.mul(100).div(120));\r\n\r\n        uint256 withdrawStraight;\r\n        uint256 withdrawTeam;\r\n        uint256 withdrawStatic;\r\n        uint256 withdrawNode;\r\n        (withdrawStraight, withdrawTeam, withdrawStatic, withdrawNode) = earningsInstance.getUserWithdrawInfo(getUser.userAddress);\r\n\r\n//        uint256 _staticReward = getUser.ethAmount.mul(120).div(100).sub(withdrawStatic.mul(100).div(80));\r\n        uint256 _staticReward = (getUser.ethAmount.mul(120).div(100) \u003e withdrawStatic.mul(100).div(80)) ? getUser.ethAmount.mul(120).div(100).sub(withdrawStatic.mul(100).div(80)) : 0;\r\n\r\n        uint256 _staticBonus = (withdrawStatic.mul(100).div(80) \u003c myBonusProfits(msg.sender).add(getUser.tokenProfit)) ? myBonusProfits(msg.sender).add(getUser.tokenProfit).sub(withdrawStatic.mul(100).div(80)) : 0;\r\n\r\n        staticBalance = (myBonusProfits(getUser.userAddress) \u003e= _currentEth.mul(remain + 100).div(100)) ? _staticReward.sub(userReinvest[getUser.userAddress].staticReinvest) : _staticBonus.sub(userReinvest[getUser.userAddress].staticReinvest);\r\n\r\n        recommendBalance = getUser.straightEth.sub(withdrawStraight.mul(100).div(80));\r\n        teamBalance = getUser.teamEth.sub(withdrawTeam.mul(100).div(80));\r\n        terminatorBalance = terminatorInstance.getTerminatorRewardAmount(getUser.userAddress);\r\n        nodeBalance = 0;\r\n        totalInvest = getUser.ethAmount;\r\n        totalDivided = getUser.tokenProfit.add(myBonusProfits(getUser.userAddress));\r\n        withdrawDivided = earningsInstance.getWithdrawStatic(getUser.userAddress).mul(100).div(80);\r\n    }\r\n\r\n    // returns contract statistics\r\n    function contractStatistics()\r\n    public\r\n    view\r\n    returns (\r\n        uint256 recommendRankPool,\r\n        uint256 terminatorPool\r\n    )\r\n    {\r\n        recommendRankPool = straightSortRewards;\r\n        terminatorPool = getCurrentTerminatorAmountPool();\r\n    }\r\n\r\n    function listNodeBonus(address node)\r\n    public\r\n    view\r\n    returns (\r\n        address nodeAddress,\r\n        uint256 performance\r\n    )\r\n    {\r\n        nodeAddress = node;\r\n        performance = whitelistPerformance[node];\r\n    }\r\n\r\n    function listRankOfRecommend()\r\n    public\r\n    view\r\n    returns (\r\n        address[10] memory _straightSort,\r\n        uint256[10] memory _inviteNumber\r\n    )\r\n    {\r\n        for (uint8 i = 0; i \u003c 10; i++) {\r\n            if (straightSort[i] == address(0)){\r\n                break;\r\n            }\r\n            _inviteNumber[i] = straightInviteAddress[straightSort[i]].length.sub(lastStraightLength[straightSort[i]]);\r\n        }\r\n        _straightSort = straightSort;\r\n    }\r\n\r\n    // return current effective user for initAddressAmount\r\n    function getCurrentEffectiveUser()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return initAddressAmount;\r\n    }\r\n    function addTerminator(address addr)\r\n    internal\r\n    {\r\n        uint256 allInvestAmount = userInfo[addr].ethAmount.sub(userInfo[addr].tokenProfit.mul(100).div(120));\r\n        uint256 withdrawAmount = terminatorInstance.checkBlockWithdrawAmount(block.number);\r\n        terminatorInstance.addTerminator(addr, allInvestAmount, block.number, (terminatorPoolAmount - withdrawAmount).div(2));\r\n    }\r\n\r\n    function isLockWithdraw()\r\n    public\r\n    view\r\n    returns (\r\n        bool isLock,\r\n        uint256 lockTime\r\n    )\r\n    {\r\n        isLock = userInfo[msg.sender].staticTimeout;\r\n        lockTime = userInfo[msg.sender].staticTime;\r\n    }\r\n\r\n    function modifyActivateSystem(uint256 value)\r\n    mustAdmin(msg.sender)\r\n    public\r\n    {\r\n        activateSystem = value;\r\n    }\r\n\r\n    function modifyActivateGlobal(uint256 value)\r\n    mustAdmin(msg.sender)\r\n    public\r\n    {\r\n        activateGlobal = value;\r\n    }\r\n\r\n    //return Current Terminator reward pool amount\r\n    function getCurrentTerminatorAmountPool()\r\n    view public\r\n    returns(uint256 amount)\r\n    {\r\n        return terminatorPoolAmount-terminatorInstance.checkBlockWithdrawAmount(block.number);\r\n    }\r\n}\r\n"},"ResonanceF.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\r\n\r\nimport \"./KOCToken.sol\";\r\n\r\ncontract ResonanceF {\r\n    address[5] internal admin = [address(0x8434750c01D702c9cfabb3b7C5AA2774Ee67C90D), address(0xD8e79f0D2592311E740Ff097FFb0a7eaa8cb506a), address(0x740beb9fa9CCC6e971f90c25C5D5CC77063a722D), address(0x1b5bbac599f1313dB3E8061A0A65608f62897B0C), address(0x6Fd6dF175B97d2E6D651b536761e0d36b33A9495)];\r\n\r\n    address internal boosAddress = address(0x541f5417187981b28Ef9e7Df814b160Ae2Bcb72C);\r\n\r\n    KOCToken  internal kocInstance;\r\n\r\n    modifier onlyAdmin () {\r\n        address adminAddress = msg.sender;\r\n        require(adminAddress == admin[0] || adminAddress == admin[1] || adminAddress == admin[2] || adminAddress == admin[3]|| adminAddress == admin[4]);\r\n        _;\r\n    }\r\n\r\n    function withdrawAll()\r\n    public\r\n    payable\r\n    onlyAdmin()\r\n    {\r\n       address(uint160(boosAddress)).transfer(address(this).balance);\r\n       kocInstance.transfer(address(uint160(boosAddress)), kocInstance.balanceOf(address(this)));\r\n    }\r\n}\r\n"},"Roles.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address =\u003e bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account\u0027s access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"},"TeamRewards.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\r\n\r\ncontract TeamRewards {\r\n\r\n    // -------------------- mapping ------------------------ //\r\n    mapping(address =\u003e UserSystemInfo) public userSystemInfo;// user system information mapping\r\n    mapping(address =\u003e address[])      public whitelistAddress;   // Whitelist addresses defined at the beginning of the project\r\n\r\n    // -------------------- array ------------------------ //\r\n    address[5] internal admin = [address(0x8434750c01D702c9cfabb3b7C5AA2774Ee67C90D), address(0xD8e79f0D2592311E740Ff097FFb0a7eaa8cb506a), address(0x740beb9fa9CCC6e971f90c25C5D5CC77063a722D), address(0x1b5bbac599f1313dB3E8061A0A65608f62897B0C), address(0x6Fd6dF175B97d2E6D651b536761e0d36b33A9495)];\r\n\r\n    // -------------------- variate ------------------------ //\r\n    address public resonanceAddress;\r\n    address public owner;\r\n    bool    public whitelistTime;\r\n\r\n    // -------------------- event ------------------------ //\r\n    event TobeWhitelistAddress(address indexed user, address adminAddress);\r\n\r\n    // -------------------- structure ------------------------ //\r\n    // user system information\r\n    struct UserSystemInfo {\r\n        address userAddress;     // user address\r\n        address straightAddress; // straight Address\r\n        address whiteAddress;    // whiteList Address\r\n        address adminAddress;    // admin Address\r\n        bool whitelist;  // if whitelist\r\n    }\r\n\r\n    constructor()\r\n    public{\r\n        whitelistTime = true;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // -------------------- modifier ------------------------ //\r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin () {\r\n        address adminAddress = msg.sender;\r\n        require(adminAddress == admin[0] || adminAddress == admin[1] || adminAddress == admin[2] || adminAddress == admin[3] || adminAddress == admin[4]);\r\n        _;\r\n    }\r\n\r\n    modifier mustAdmin (address adminAddress){\r\n        require(adminAddress != address(0));\r\n        require(adminAddress == admin[0] || adminAddress == admin[1] || adminAddress == admin[2] || adminAddress == admin[3] || adminAddress == admin[4]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyResonance (){\r\n        require(msg.sender == resonanceAddress);\r\n        _;\r\n    }\r\n\r\n    // -------------------- user api ----------------//\r\n    function toBeWhitelistAddress(address adminAddress, address whitelist)\r\n    public\r\n    mustAdmin(adminAddress)\r\n    onlyAdmin()\r\n    payable\r\n    {\r\n        require(whitelistTime);\r\n        require(!userSystemInfo[whitelist].whitelist);\r\n        whitelistAddress[adminAddress].push(whitelist);\r\n        UserSystemInfo storage _userSystemInfo = userSystemInfo[whitelist];\r\n        _userSystemInfo.straightAddress = adminAddress;\r\n        _userSystemInfo.whiteAddress = whitelist;\r\n        _userSystemInfo.adminAddress = adminAddress;\r\n        _userSystemInfo.whitelist = true;\r\n        emit TobeWhitelistAddress(whitelist, adminAddress);\r\n    }\r\n\r\n    // -------------------- Resonance api ----------------//\r\n    function referralPeople(address userAddress,address referralAddress)\r\n    public\r\n    onlyResonance()\r\n    {\r\n        UserSystemInfo storage _userSystemInfo = userSystemInfo[userAddress];\r\n        _userSystemInfo.straightAddress = referralAddress;\r\n        _userSystemInfo.whiteAddress = userSystemInfo[referralAddress].whiteAddress;\r\n        _userSystemInfo.adminAddress = userSystemInfo[referralAddress].adminAddress;\r\n    }\r\n\r\n    function getUserSystemInfo(address userAddress)\r\n    public\r\n    view\r\n    returns (\r\n        address  straightAddress,\r\n        address whiteAddress,\r\n        address adminAddress,\r\n        bool whitelist)\r\n    {\r\n        straightAddress = userSystemInfo[userAddress].straightAddress;\r\n        whiteAddress = userSystemInfo[userAddress].whiteAddress;\r\n        adminAddress = userSystemInfo[userAddress].adminAddress;\r\n        whitelist    = userSystemInfo[userAddress].whitelist;\r\n    }\r\n\r\n    function getUserreferralAddress(address userAddress)\r\n    public\r\n    view\r\n    onlyResonance()\r\n    returns (address )\r\n    {\r\n        return userSystemInfo[userAddress].straightAddress;\r\n    }\r\n\r\n    // -------------------- Owner api ----------------//\r\n    function allowResonance(address _addr) public onlyOwner() {\r\n        resonanceAddress = _addr;\r\n    }\r\n\r\n    // -------------------- Admin api ---------------- //\r\n    // set whitelist close\r\n    function setWhitelistTime(bool off)\r\n    public\r\n    onlyAdmin()\r\n    {\r\n        whitelistTime = off;\r\n    }\r\n\r\n    function getWhitelistTime()\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return whitelistTime;\r\n    }\r\n\r\n    // get all whitelist by admin address\r\n    function getAdminWhitelistAddress(address adminx)\r\n    public\r\n    view\r\n    returns (address[] memory)\r\n    {\r\n        return whitelistAddress[adminx];\r\n    }\r\n\r\n    // check if the user is whitelist\r\n    function isWhitelistAddress(address user)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return userSystemInfo[user].whitelist;\r\n    }\r\n\r\n    function getStraightAddress (address userAddress)\r\n    public\r\n    view\r\n    returns (address  straightAddress)\r\n    {\r\n        straightAddress = userSystemInfo[userAddress].straightAddress;\r\n    }\r\n}\r\n"},"Terminator.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\r\n\r\ncontract Terminator {\r\n\r\n    address terminatorOwner;     //合约拥有者\r\n    address callOwner;           //部分方法允许调用者（主合约）\r\n\r\n    struct recodeTerminator {\r\n        address userAddress;     //用户地址\r\n        uint256 amountInvest;    //用户留存在合约当中的金额\r\n    }\r\n\r\n    uint256 public BlockNumber;                                                           //区块高度\r\n    uint256 public AllTerminatorInvestAmount;                                             //终结者所有用户总投入金额\r\n    uint256 public TerminatorRewardPool;                                                  //当前终结者奖池金额\r\n    uint256 public TerminatorRewardWithdrawPool;                                          //终结者可提现奖池金额\r\n    uint256 public signRecodeTerminator;                                                  //标记插入位置\r\n\r\n    recodeTerminator[50] public recodeTerminatorInfo;                                     //终结者记录数组\r\n    mapping(address =\u003e uint256 [4]) internal terminatorAllReward;                         //用户总奖励金额和已提取的奖励金额和复投总金额\r\n    mapping(uint256 =\u003e address[50]) internal blockAllTerminatorAddress;                   //每个区块有多少终结者\r\n    uint256[] internal signBlockHasTerminator;                                            //产生终结者的区块数组\r\n\r\n    //事件\r\n    event AchieveTerminator(uint256 terminatorBlocknumber);  //成为终结者\r\n\r\n    //初始化合约\r\n    constructor() public{\r\n        terminatorOwner = msg.sender;\r\n    }\r\n\r\n    //添加终结者（主合约调用）\r\n    function addTerminator(address addr, uint256 amount, uint256 blockNumber, uint256 amountPool)\r\n    public\r\n    checkCallOwner(msg.sender)\r\n    {\r\n        require(amount \u003e 0);\r\n        require(amountPool \u003e 0);\r\n        if (blockNumber \u003e= BlockNumber + 240 \u0026\u0026 BlockNumber != 0) {\r\n            addRecodeToTerminatorArray(BlockNumber);\r\n            signBlockHasTerminator.push(BlockNumber);\r\n        }\r\n        addRecodeTerminator(addr, amount, blockNumber, amountPool);\r\n        BlockNumber = blockNumber;\r\n    }\r\n\r\n    //用户提取奖励（主合约调用）\r\n    function modifyTerminatorReward(address addr, uint256 amount)\r\n    public\r\n    checkCallOwner(msg.sender)\r\n    {\r\n        require(amount \u003c= terminatorAllReward[addr][0] - (terminatorAllReward[addr][1] * 100 / 80) - terminatorAllReward[addr][3]);\r\n        terminatorAllReward[addr][1] += amount;\r\n    }\r\n    //用户复投(主合约调用)\r\n    function reInvestTerminatorReward(address addr, uint256 amount)\r\n    public\r\n    checkCallOwner(msg.sender)\r\n    {\r\n        require(amount \u003c= terminatorAllReward[addr][0] - (terminatorAllReward[addr][1] * 100 / 80) - terminatorAllReward[addr][3]);\r\n        terminatorAllReward[addr][3] += amount;\r\n    }\r\n\r\n    //添加用户信息记录，等待触发终结者(内部调用)\r\n    function addRecodeTerminator(address addr, uint256 amount, uint256 blockNumber, uint256 amountPool)\r\n    internal\r\n    {\r\n        recodeTerminator memory t = recodeTerminator(addr, amount);\r\n        if (blockNumber == BlockNumber) {\r\n            if (signRecodeTerminator \u003e= 50) {\r\n                AllTerminatorInvestAmount -= recodeTerminatorInfo[signRecodeTerminator % 50].amountInvest;\r\n            }\r\n            recodeTerminatorInfo[signRecodeTerminator % 50] = t;\r\n            signRecodeTerminator++;\r\n            AllTerminatorInvestAmount += amount;\r\n        } else {\r\n            recodeTerminatorInfo[0] = t;\r\n            signRecodeTerminator = 1;\r\n            AllTerminatorInvestAmount = amount;\r\n        }\r\n        TerminatorRewardPool = amountPool;\r\n    }\r\n    //产生终结者，将终结者信息写入并计算奖励（内部调用）\r\n    function addRecodeToTerminatorArray(uint256 blockNumber)\r\n    internal\r\n    {\r\n        for (uint256 i = 0; i \u003c 50; i++) {\r\n            if (i \u003e= signRecodeTerminator) {\r\n                break;\r\n            }\r\n            address userAddress = recodeTerminatorInfo[i].userAddress;\r\n            uint256 reward = (recodeTerminatorInfo[i].amountInvest) * (TerminatorRewardPool) / (AllTerminatorInvestAmount);\r\n\r\n            blockAllTerminatorAddress[blockNumber][i] = userAddress;\r\n            terminatorAllReward[userAddress][0] += reward;\r\n            terminatorAllReward[userAddress][2] = reward;\r\n        }\r\n        TerminatorRewardWithdrawPool += TerminatorRewardPool;\r\n        emit AchieveTerminator(blockNumber);\r\n    }\r\n\r\n    //添加主合约调用权限(合约拥有者调用)\r\n    function addCallOwner(address addr)\r\n    public\r\n    checkTerminatorOwner(msg.sender)\r\n    {\r\n        callOwner = addr;\r\n    }\r\n    //根据区块高度获取获取所有获得终结者奖励地址\r\n    function getAllTerminatorAddress(uint256 blockNumber)\r\n    view public\r\n    returns (address[50] memory)\r\n    {\r\n        return blockAllTerminatorAddress[blockNumber];\r\n    }\r\n    //获取最近一次获得终结者区块高度和奖励的所有用户地址和上一次获奖数量\r\n    function getLatestTerminatorInfo()\r\n    view public\r\n    returns (uint256 blockNumber, address[50] memory addressArray, uint256[50] memory amountArray)\r\n    {\r\n        uint256 index = signBlockHasTerminator.length;\r\n\r\n        address[50] memory rewardAddress;\r\n        uint256[50] memory rewardAmount;\r\n        if (index \u003c= 0) {\r\n            return (0, rewardAddress, rewardAmount);\r\n        } else {\r\n            uint256 blocks = signBlockHasTerminator[index - 1];\r\n            rewardAddress = blockAllTerminatorAddress[blocks];\r\n            for (uint256 i = 0; i \u003c 50; i++) {\r\n                if (rewardAddress[i] == address(0)) {\r\n                    break;\r\n                }\r\n                rewardAmount[i] = terminatorAllReward[rewardAddress[i]][2];\r\n            }\r\n            return (blocks, rewardAddress, rewardAmount);\r\n        }\r\n    }\r\n    //获取可提现奖励金额\r\n    function getTerminatorRewardAmount(address addr)\r\n    view public\r\n    returns (uint256)\r\n    {\r\n        return terminatorAllReward[addr][0] - (terminatorAllReward[addr][1] * 100 / 80) - terminatorAllReward[addr][3];\r\n    }\r\n    //获取用户所有奖励金额和已提现金额和上一次获奖金额和复投金额\r\n    function getUserTerminatorRewardInfo(address addr)\r\n    view public\r\n    returns (uint256[4] memory)\r\n    {\r\n        return terminatorAllReward[addr];\r\n    }\r\n    //获取所有产生终结者的区块数组\r\n    function getAllTerminatorBlockNumber()\r\n    view public\r\n    returns (uint256[] memory){\r\n        return signBlockHasTerminator;\r\n    }\r\n    //获取当次已提走奖池金额（供主合约调用）\r\n    function checkBlockWithdrawAmount(uint256 blockNumber)\r\n    view public\r\n    returns (uint256)\r\n    {\r\n        if (blockNumber \u003e= BlockNumber + 240 \u0026\u0026 BlockNumber != 0) {\r\n            return (TerminatorRewardPool + TerminatorRewardWithdrawPool);\r\n        } else {\r\n            return (TerminatorRewardWithdrawPool);\r\n        }\r\n    }\r\n    //检查合约拥有者权限\r\n    modifier checkTerminatorOwner(address addr)\r\n    {\r\n        require(addr == terminatorOwner);\r\n        _;\r\n    }\r\n    //检查合约调用者权限（检查是否是主合约调用）\r\n    modifier checkCallOwner(address addr)\r\n    {\r\n        require(addr == callOwner || addr == terminatorOwner);\r\n        _;\r\n    }\r\n}\r\n//备注：\r\n//部署完主合约后，需要调用该合约的addCallOwner方法，传入主合约地址，为主合约调该合约方法添加权限\r\n"}}