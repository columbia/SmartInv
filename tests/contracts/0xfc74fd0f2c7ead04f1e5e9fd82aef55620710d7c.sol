{{
  "language": "Solidity",
  "sources": {
    "contracts/minter-suite/MinterDAExpV0.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"../interfaces/0.8.x/IGenArt721CoreContractV1.sol\";\nimport \"../interfaces/0.8.x/IMinterFilterV0.sol\";\nimport \"../interfaces/0.8.x/IFilteredMinterV0.sol\";\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\npragma solidity 0.8.9;\n\n/**\n * @title Filtered Minter contract that allows tokens to be minted with ETH.\n * Pricing is achieved using an automated Dutch-auction mechanism.\n * @author Art Blocks Inc.\n */\ncontract MinterDAExpV0 is ReentrancyGuard, IFilteredMinterV0 {\n    /// Auction details updated for project `projectId`.\n    event SetAuctionDetails(\n        uint256 indexed projectId,\n        uint256 _auctionTimestampStart,\n        uint256 _priceDecayHalfLifeSeconds,\n        uint256 _startPrice,\n        uint256 _basePrice\n    );\n\n    /// Auction details cleared for project `projectId`.\n    event ResetAuctionDetails(uint256 indexed projectId);\n\n    /// Maximum and minimum allowed price decay half lifes updated.\n    event AuctionHalfLifeRangeSecondsUpdated(\n        uint256 _minimumPriceDecayHalfLifeSeconds,\n        uint256 _maximumPriceDecayHalfLifeSeconds\n    );\n\n    /// Core contract address this minter interacts with\n    address public immutable genArt721CoreAddress;\n\n    /// This contract handles cores with interface IV1\n    IGenArt721CoreContractV1 private immutable genArtCoreContract;\n\n    /// Minter filter address this minter interacts with\n    address public immutable minterFilterAddress;\n\n    /// Minter filter this minter may interact with.\n    IMinterFilterV0 private immutable minterFilter;\n\n    /// minterType for this minter\n    string public constant minterType = \"MinterDAExpV0\";\n\n    uint256 constant ONE_MILLION = 1_000_000;\n\n    /// projectId => are contracts allowed to mint?\n    mapping(uint256 => bool) public contractMintable;\n    /// projectId => are tokens allowed to be minted to other addresses?\n    mapping(uint256 => bool) public purchaseToDisabled;\n    /// purchaser address => projectId => number of mints purchased\n    mapping(address => mapping(uint256 => uint256)) public projectMintCounter;\n    /// projectId => maximum number of mints a given address may invoke\n    mapping(uint256 => uint256) public projectMintLimit;\n    /// projectId => has project reached its maximum number of invocations?\n    mapping(uint256 => bool) public projectMaxHasBeenInvoked;\n    /// projectId => project's maximum number of invocations\n    mapping(uint256 => uint256) public projectMaxInvocations;\n\n    /// Minimum price decay half life: price must decay with a half life of at\n    /// least this amount (must cut in half at least every N seconds).\n    uint256 public minimumPriceDecayHalfLifeSeconds = 300; // 5 minutes\n    /// Maximum price decay half life: price may decay with a half life of no\n    /// more than this amount (may cut in half at no more than every N seconds).\n    uint256 public maximumPriceDecayHalfLifeSeconds = 3600; // 60 minutes\n\n    /// projectId => auction parameters\n    mapping(uint256 => AuctionParameters) public projectAuctionParameters;\n    struct AuctionParameters {\n        uint256 timestampStart;\n        uint256 priceDecayHalfLifeSeconds;\n        uint256 startPrice;\n        uint256 basePrice;\n    }\n\n    modifier onlyCoreWhitelisted() {\n        require(\n            genArtCoreContract.isWhitelisted(msg.sender),\n            \"Only Core whitelisted\"\n        );\n        _;\n    }\n\n    modifier onlyArtist(uint256 _projectId) {\n        require(\n            (msg.sender ==\n                genArtCoreContract.projectIdToArtistAddress(_projectId)),\n            \"Only Artist\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Initializes contract to be a Filtered Minter for\n     * `_minterFilter`, integrated with Art Blocks core contract\n     * at address `_genArt721Address`.\n     * @param _genArt721Address Art Blocks core contract address for\n     * which this contract will be a minter.\n     * @param _minterFilter Minter filter for which\n     * this will a filtered minter.\n     */\n    constructor(address _genArt721Address, address _minterFilter)\n        ReentrancyGuard()\n    {\n        genArt721CoreAddress = _genArt721Address;\n        genArtCoreContract = IGenArt721CoreContractV1(_genArt721Address);\n        minterFilterAddress = _minterFilter;\n        minterFilter = IMinterFilterV0(_minterFilter);\n        require(\n            minterFilter.genArt721CoreAddress() == _genArt721Address,\n            \"Illegal contract pairing\"\n        );\n    }\n\n    /**\n     * @notice Sets the mint limit of a single purchaser for project\n     * `_projectId` to `_limit`.\n     * @param _projectId Project ID to set the mint limit for.\n     * @param _limit Number of times a given address may mint the\n     * project's tokens.\n     */\n    function setProjectMintLimit(uint256 _projectId, uint8 _limit)\n        external\n        onlyCoreWhitelisted\n    {\n        projectMintLimit[_projectId] = _limit;\n    }\n\n    /**\n     * @notice Sets the maximum invocations of project `_projectId` based\n     * on the value currently defined in the core contract.\n     * @param _projectId Project ID to set the maximum invocations for.\n     * @dev also checks and may refresh projectMaxHasBeenInvoked for project\n     * @dev this enables gas reduction after maxInvocations have been reached -\n     * core contracts shall still enforce a maxInvocation check during mint.\n     */\n    function setProjectMaxInvocations(uint256 _projectId)\n        external\n        onlyCoreWhitelisted\n    {\n        uint256 invocations;\n        uint256 maxInvocations;\n        (, , invocations, maxInvocations, , , , , ) = genArtCoreContract\n            .projectTokenInfo(_projectId);\n        // update storage with results\n        projectMaxInvocations[_projectId] = maxInvocations;\n        if (invocations < maxInvocations) {\n            projectMaxHasBeenInvoked[_projectId] = false;\n        }\n    }\n\n    /**\n     * @notice Toggles if contracts are allowed to mint tokens for\n     * project `_projectId`.\n     * @param _projectId Project ID to be toggled.\n     */\n    function toggleContractMintable(uint256 _projectId)\n        external\n        onlyCoreWhitelisted\n    {\n        contractMintable[_projectId] = !contractMintable[_projectId];\n    }\n\n    /**\n     * @notice Toggles if purchases to other address are enabled for\n     * project `_projectId`.\n     * @param _projectId Project ID to be toggled.\n     */\n    function togglePurchaseToDisabled(uint256 _projectId)\n        external\n        onlyCoreWhitelisted\n    {\n        purchaseToDisabled[_projectId] = !purchaseToDisabled[_projectId];\n        emit PurchaseToDisabledUpdated(\n            _projectId,\n            purchaseToDisabled[_projectId]\n        );\n    }\n\n    /**\n     * @notice Sets the minimum and maximum values that are settable for\n     * `_priceDecayHalfLifeSeconds` across all projects.\n     * @param _minimumPriceDecayHalfLifeSeconds Minimum price decay half life\n     * (in seconds).\n     * @param _maximumPriceDecayHalfLifeSeconds Maximum price decay half life\n     * (in seconds).\n     */\n    function setAllowablePriceDecayHalfLifeRangeSeconds(\n        uint256 _minimumPriceDecayHalfLifeSeconds,\n        uint256 _maximumPriceDecayHalfLifeSeconds\n    ) external onlyCoreWhitelisted {\n        require(\n            _maximumPriceDecayHalfLifeSeconds >\n                _minimumPriceDecayHalfLifeSeconds,\n            \"Maximum half life must be greater than minimum\"\n        );\n        require(\n            _minimumPriceDecayHalfLifeSeconds > 0,\n            \"Half life of zero not allowed\"\n        );\n        minimumPriceDecayHalfLifeSeconds = _minimumPriceDecayHalfLifeSeconds;\n        maximumPriceDecayHalfLifeSeconds = _maximumPriceDecayHalfLifeSeconds;\n        emit AuctionHalfLifeRangeSecondsUpdated(\n            _minimumPriceDecayHalfLifeSeconds,\n            _maximumPriceDecayHalfLifeSeconds\n        );\n    }\n\n    ////// Auction Functions\n    /**\n     * @notice Sets auction details for project `_projectId`.\n     * @param _projectId Project ID to set auction details for.\n     * @param _auctionTimestampStart Timestamp at which to start the auction.\n     * @param _priceDecayHalfLifeSeconds The half life with which to decay the\n     *  price (in seconds).\n     * @param _startPrice Price at which to start the auction, in Wei.\n     * @param _basePrice Resting price of the auction, in Wei.\n     */\n    function setAuctionDetails(\n        uint256 _projectId,\n        uint256 _auctionTimestampStart,\n        uint256 _priceDecayHalfLifeSeconds,\n        uint256 _startPrice,\n        uint256 _basePrice\n    ) external onlyArtist(_projectId) {\n        AuctionParameters memory auctionParams = projectAuctionParameters[\n            _projectId\n        ];\n        require(\n            auctionParams.timestampStart == 0 ||\n                block.timestamp < auctionParams.timestampStart,\n            \"No modifications mid-auction\"\n        );\n        require(\n            block.timestamp < _auctionTimestampStart,\n            \"Only future auctions\"\n        );\n        require(\n            _startPrice > _basePrice,\n            \"Auction start price must be greater than auction end price\"\n        );\n        require(\n            (_priceDecayHalfLifeSeconds >= minimumPriceDecayHalfLifeSeconds) &&\n                (_priceDecayHalfLifeSeconds <=\n                    maximumPriceDecayHalfLifeSeconds),\n            \"Price decay half life must fall between min and max allowable values\"\n        );\n        projectAuctionParameters[_projectId] = AuctionParameters(\n            _auctionTimestampStart,\n            _priceDecayHalfLifeSeconds,\n            _startPrice,\n            _basePrice\n        );\n        emit SetAuctionDetails(\n            _projectId,\n            _auctionTimestampStart,\n            _priceDecayHalfLifeSeconds,\n            _startPrice,\n            _basePrice\n        );\n    }\n\n    /**\n     * @notice Resets auction details for project `_projectId`, zero-ing out all\n     * relevant auction fields. Not intended to be used in normal auction\n     * operation, but rather only in case of the need to halt an auction.\n     * @param _projectId Project ID to set auction details for.\n     */\n    function resetAuctionDetails(uint256 _projectId)\n        external\n        onlyCoreWhitelisted\n    {\n        delete projectAuctionParameters[_projectId];\n        emit ResetAuctionDetails(_projectId);\n    }\n\n    /**\n     * @notice Purchases a token from project `_projectId`.\n     * @param _projectId Project ID to mint a token on.\n     * @return tokenId Token ID of minted token\n     */\n    function purchase(uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId)\n    {\n        tokenId = purchaseTo(msg.sender, _projectId);\n        return tokenId;\n    }\n\n    /**\n     * @notice Purchases a token from project `_projectId` and sets\n     * the token's owner to `_to`.\n     * @param _to Address to be the new token's owner.\n     * @param _projectId Project ID to mint a token on.\n     * @return tokenId Token ID of minted token\n     */\n    function purchaseTo(address _to, uint256 _projectId)\n        public\n        payable\n        nonReentrant\n        returns (uint256 tokenId)\n    {\n        // CHECKS\n        require(\n            !projectMaxHasBeenInvoked[_projectId],\n            \"Maximum number of invocations reached\"\n        );\n\n        // no need to check if price is configured - auction init values fail\n\n        // if contract filter is off, allow calls from another contract\n        if (!contractMintable[_projectId]) {\n            require(msg.sender == tx.origin, \"No Contract Buys\");\n        }\n\n        // if purchaseTo is disabled, enforce purchase destination to be the TX\n        // sending address.\n        if (purchaseToDisabled[_projectId]) {\n            require(msg.sender == _to, \"No `purchaseTo` Allowed\");\n        }\n\n        // _getPrice reverts if auction is unconfigured or has not started\n        uint256 currentPriceInWei = _getPrice(_projectId);\n        require(\n            msg.value >= currentPriceInWei,\n            \"Must send minimum value to mint!\"\n        );\n\n        // limit mints per address by project\n        if (projectMintLimit[_projectId] > 0) {\n            require(\n                projectMintCounter[msg.sender][_projectId] <\n                    projectMintLimit[_projectId],\n                \"Reached minting limit\"\n            );\n            // EFFECTS\n            projectMintCounter[msg.sender][_projectId]++;\n        }\n\n        tokenId = minterFilter.mint(_to, _projectId, msg.sender);\n        // what if projectMaxInvocations[_projectId] is 0 (default value)?\n        // that is intended, so that by default the minter allows infinite transactions,\n        // allowing the artblocks contract to stop minting\n        // uint256 tokenInvocation = tokenId % ONE_MILLION;\n        if (\n            projectMaxInvocations[_projectId] > 0 &&\n            tokenId % ONE_MILLION == projectMaxInvocations[_projectId] - 1\n        ) {\n            projectMaxHasBeenInvoked[_projectId] = true;\n        }\n\n        // INTERACTIONS\n        _splitFundsETHAuction(_projectId, currentPriceInWei);\n        return tokenId;\n    }\n\n    /**\n     * @dev splits ETH funds between sender (if refund), foundation,\n     * artist, and artist's additional payee for a token purchased on\n     * project `_projectId`.\n     * @dev utilizes transfer() to send ETH, which may fail if access\n     * lists are not properly populated when purchasing tokens.\n     * @param _projectId Project ID for which funds shall be split.\n     * @param _currentPriceInWei Current price of token, in Wei.\n     */\n    function _splitFundsETHAuction(\n        uint256 _projectId,\n        uint256 _currentPriceInWei\n    ) internal {\n        if (msg.value > 0) {\n            uint256 refund = msg.value - _currentPriceInWei;\n            if (refund > 0) {\n                (bool success_, ) = msg.sender.call{value: refund}(\"\");\n                require(success_, \"Refund failed\");\n            }\n            uint256 foundationAmount = (_currentPriceInWei *\n                genArtCoreContract.artblocksPercentage()) / 100;\n            if (foundationAmount > 0) {\n                (bool success_, ) = genArtCoreContract.artblocksAddress().call{\n                    value: foundationAmount\n                }(\"\");\n                require(success_, \"Foundation payment failed\");\n            }\n            uint256 projectFunds = _currentPriceInWei - foundationAmount;\n            uint256 additionalPayeeAmount;\n            if (\n                genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                    _projectId\n                ) > 0\n            ) {\n                additionalPayeeAmount =\n                    (projectFunds *\n                        genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                            _projectId\n                        )) /\n                    100;\n                if (additionalPayeeAmount > 0) {\n                    (bool success_, ) = genArtCoreContract\n                        .projectIdToAdditionalPayee(_projectId)\n                        .call{value: additionalPayeeAmount}(\"\");\n                    require(success_, \"Additional payment failed\");\n                }\n            }\n            uint256 creatorFunds = projectFunds - additionalPayeeAmount;\n            if (creatorFunds > 0) {\n                (bool success_, ) = genArtCoreContract\n                    .projectIdToArtistAddress(_projectId)\n                    .call{value: creatorFunds}(\"\");\n                require(success_, \"Artist payment failed\");\n            }\n        }\n    }\n\n    /**\n     * @notice Gets price of minting a token on project `_projectId` given\n     * the project's AuctionParameters and current block timestamp.\n     * Reverts if auction has not yet started or auction is unconfigured.\n     * @param _projectId Project ID to get price of token for.\n     * @return current price of token in Wei\n     * @dev This method calculates price decay using a linear interpolation\n     * of exponential decay based on the artist-provided half-life for price\n     * decay, `_priceDecayHalfLifeSeconds`.\n     */\n    function _getPrice(uint256 _projectId) private view returns (uint256) {\n        AuctionParameters memory auctionParams = projectAuctionParameters[\n            _projectId\n        ];\n        require(\n            block.timestamp > auctionParams.timestampStart,\n            \"Auction not yet started\"\n        );\n        require(\n            auctionParams.priceDecayHalfLifeSeconds > 0,\n            \"Only configured auctions\"\n        );\n        uint256 decayedPrice = auctionParams.startPrice;\n        uint256 elapsedTimeSeconds = block.timestamp -\n            auctionParams.timestampStart;\n        // Divide by two (via bit-shifting) for the number of entirely completed\n        // half-lives that have elapsed since auction start time.\n        decayedPrice >>=\n            elapsedTimeSeconds /\n            auctionParams.priceDecayHalfLifeSeconds;\n        // Perform a linear interpolation between partial half-life points, to\n        // approximate the current place on a perfect exponential decay curve.\n        decayedPrice -=\n            (decayedPrice *\n                (elapsedTimeSeconds %\n                    auctionParams.priceDecayHalfLifeSeconds)) /\n            auctionParams.priceDecayHalfLifeSeconds /\n            2;\n        if (decayedPrice < auctionParams.basePrice) {\n            // Price may not decay below stay `basePrice`.\n            return auctionParams.basePrice;\n        }\n        return decayedPrice;\n    }\n\n    /**\n     * @notice Gets if price of token is configured, price of minting a\n     * token on project `_projectId`, and currency symbol and address to be\n     * used as payment. Supersedes any core contract price information.\n     * @param _projectId Project ID to get price information for.\n     * @return isConfigured true only if project's auction parameters have been\n     * configured on this minter\n     * @return tokenPriceInWei current price of token on this minter - invalid\n     * if auction has not yet been configured\n     * @return currencySymbol currency symbol for purchases of project on this\n     * minter. This minter always returns \"ETH\"\n     * @return currencyAddress currency address for purchases of project on\n     * this minter. This minter always returns null address, reserved for ether\n     */\n    function getPriceInfo(uint256 _projectId)\n        external\n        view\n        returns (\n            bool isConfigured,\n            uint256 tokenPriceInWei,\n            string memory currencySymbol,\n            address currencyAddress\n        )\n    {\n        AuctionParameters memory auctionParams = projectAuctionParameters[\n            _projectId\n        ];\n        isConfigured = (auctionParams.startPrice > 0);\n        if (block.timestamp <= auctionParams.timestampStart) {\n            // Provide a reasonable value for `tokenPriceInWei` when it would\n            // otherwise revert, using the starting price before auction starts.\n            tokenPriceInWei = auctionParams.startPrice;\n        } else if (auctionParams.startPrice == 0) {\n            // In the case of unconfigured auction, return price of zero when\n            // it would otherwise revert\n            tokenPriceInWei = 0;\n        } else {\n            tokenPriceInWei = _getPrice(_projectId);\n        }\n        currencySymbol = \"ETH\";\n        currencyAddress = address(0);\n    }\n}\n"
    },
    "contracts/interfaces/0.8.x/IGenArt721CoreContractV1.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IGenArt721CoreContractV1 {\n    event Mint(\n        address indexed _to,\n        uint256 indexed _tokenId,\n        uint256 indexed _projectId\n    );\n\n    // getter function of public variable\n    function admin() external view returns (address);\n\n    // getter function of public variable\n    function nextProjectId() external view returns (uint256);\n\n    // getter function of public mapping\n    function tokenIdToProjectId(uint256 tokenId)\n        external\n        view\n        returns (uint256 projectId);\n\n    function isWhitelisted(address sender) external view returns (bool);\n\n    // @dev this is not available in V0\n    function isMintWhitelisted(address minter) external view returns (bool);\n\n    function projectIdToArtistAddress(uint256 _projectId)\n        external\n        view\n        returns (address payable);\n\n    function projectIdToAdditionalPayee(uint256 _projectId)\n        external\n        view\n        returns (address payable);\n\n    function projectIdToAdditionalPayeePercentage(uint256 _projectId)\n        external\n        view\n        returns (uint256);\n\n    function projectTokenInfo(uint256 _projectId)\n        external\n        view\n        returns (\n            address,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            address,\n            uint256,\n            string memory,\n            address\n        );\n\n    function artblocksAddress() external view returns (address payable);\n\n    function artblocksPercentage() external view returns (uint256);\n\n    function mint(\n        address _to,\n        uint256 _projectId,\n        address _by\n    ) external returns (uint256 tokenId);\n\n    function getRoyaltyData(uint256 _tokenId)\n        external\n        view\n        returns (\n            address artistAddress,\n            address additionalPayee,\n            uint256 additionalPayeePercentage,\n            uint256 royaltyFeeByID\n        );\n}\n"
    },
    "contracts/interfaces/0.8.x/IMinterFilterV0.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IMinterFilterV0 {\n    /**\n     * @notice Approved minter `_minterAddress`.\n     */\n    event MinterApproved(address indexed _minterAddress, string _minterType);\n\n    /**\n     * @notice Revoked approval for minter `_minterAddress`\n     */\n    event MinterRevoked(address indexed _minterAddress);\n\n    /**\n     * @notice Minter `_minterAddress` of type `_minterType`\n     * registered for project `_projectId`.\n     */\n    event ProjectMinterRegistered(\n        uint256 indexed _projectId,\n        address indexed _minterAddress,\n        string _minterType\n    );\n\n    /**\n     * @notice Any active minter removed for project `_projectId`.\n     */\n    event ProjectMinterRemoved(uint256 indexed _projectId);\n\n    function genArt721CoreAddress() external returns (address);\n\n    function setMinterForProject(uint256, address) external;\n\n    function removeMinterForProject(uint256) external;\n\n    function mint(\n        address _to,\n        uint256 _projectId,\n        address sender\n    ) external returns (uint256);\n\n    function getMinterForProject(uint256) external view returns (address);\n\n    function projectHasMinter(uint256) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/0.8.x/IFilteredMinterV0.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IFilteredMinterV0 {\n    /**\n     * @notice Price per token in wei updated for project `_projectId` to\n     * `_pricePerTokenInWei`.\n     */\n    event PricePerTokenInWeiUpdated(\n        uint256 indexed _projectId,\n        uint256 indexed _pricePerTokenInWei\n    );\n\n    /**\n     * @notice Currency updated for project `_projectId` to symbol\n     * `_currencySymbol` and address `_currencyAddress`.\n     */\n    event ProjectCurrencyInfoUpdated(\n        uint256 indexed _projectId,\n        address indexed _currencyAddress,\n        string _currencySymbol\n    );\n\n    /// togglePurchaseToDisabled updated\n    event PurchaseToDisabledUpdated(\n        uint256 indexed _projectId,\n        bool _purchaseToDisabled\n    );\n\n    // getter function of public variable\n    function minterType() external view returns (string memory);\n\n    function genArt721CoreAddress() external returns (address);\n\n    function minterFilterAddress() external returns (address);\n\n    // Triggers a purchase of a token from the desired project, to the\n    // TX-sending address.\n    function purchase(uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId);\n\n    // Triggers a purchase of a token from the desired project, to the specified\n    // receiving address.\n    function purchaseTo(address _to, uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId);\n\n    // Toggles the ability for `purchaseTo` to be called directly with a\n    // specified receiving address that differs from the TX-sending address.\n    function togglePurchaseToDisabled(uint256 _projectId) external;\n\n    // Called to make the minter contract aware of the max invocations for a\n    // given project.\n    function setProjectMaxInvocations(uint256 _projectId) external;\n\n    // Gets if token price is configured, token price in wei, currency symbol,\n    // and currency address, assuming this is project's minter.\n    // Supersedes any defined core price.\n    function getPriceInfo(uint256 _projectId)\n        external\n        view\n        returns (\n            bool isConfigured,\n            uint256 tokenPriceInWei,\n            string memory currencySymbol,\n            address currencyAddress\n        );\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}