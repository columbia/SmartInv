{{
  "language": "Solidity",
  "sources": {
    "contracts/protocol/configuration/PermissionManager.sol": {
      "content": "pragma solidity 0.6.12;\n\nimport {IPermissionManager} from '../../interfaces/IPermissionManager.sol';\nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol';\n\n/**\n * @title PermissionManager contract\n * @notice Implements basic whitelisting functions for different actors of the permissioned protocol\n\n * @author Aave\n **/\ncontract PermissionManager is IPermissionManager, Ownable {\n  struct UserData {\n    uint256 permissions;\n    address permissionAdmin;\n  }\n\n  mapping(address => UserData) _users;\n  mapping(address => uint256) _permissionsAdmins;\n\n  uint256 public constant MAX_NUM_OF_ROLES = 256;\n\n  modifier onlyPermissionAdmins(address user) {\n    require(_permissionsAdmins[user] > 0, 'CALLER_NOT_PERMISSIONS_ADMIN');\n    _;\n  }\n\n  ///@inheritdoc IPermissionManager\n  function addPermissionAdmins(address[] calldata admins) external override onlyOwner {\n    for (uint256 i = 0; i < admins.length; i++) {\n      _permissionsAdmins[admins[i]] = 1;\n\n      emit PermissionsAdminSet(admins[i], true);\n    }\n  }\n\n  ///@inheritdoc IPermissionManager\n  function removePermissionAdmins(address[] calldata admins) external override onlyOwner {\n    for (uint256 i = 0; i < admins.length; i++) {\n      _permissionsAdmins[admins[i]] = 0;\n\n      emit PermissionsAdminSet(admins[i], false);\n    }\n  }\n\n  ///@inheritdoc IPermissionManager\n  function addPermissions(uint256[] calldata roles, address[] calldata users)\n    external\n    override\n    onlyPermissionAdmins(msg.sender)\n  {\n    require(roles.length == users.length, 'INCONSISTENT_ARRAYS_LENGTH');\n\n    for (uint256 i = 0; i < users.length; i++) {\n      uint256 role = roles[i];\n      address user = users[i];\n\n      require(role < MAX_NUM_OF_ROLES, 'INVALID_ROLE');\n\n      uint256 permissions = _users[user].permissions;\n      address permissionAdmin = _users[user].permissionAdmin;\n\n      require(\n        (permissions != 0 && permissionAdmin == msg.sender) ||\n          _users[user].permissionAdmin == address(0),\n        'INVALID_PERMISSIONADMIN'\n      );\n\n      if (permissions == 0) {\n        _users[user].permissionAdmin = msg.sender;\n      }\n\n      _users[user].permissions = permissions | (1 << role);\n\n      emit RoleSet(user, role, msg.sender, true);\n    }\n  }\n\n  ///@inheritdoc IPermissionManager\n  function removePermissions(uint256[] calldata roles, address[] calldata users)\n    external\n    override\n    onlyPermissionAdmins(msg.sender)\n  {\n    require(roles.length == users.length, 'INCONSISTENT_ARRAYS_LENGTH');\n\n    for (uint256 i = 0; i < users.length; i++) {\n      uint256 role = roles[i];\n      address user = users[i];\n\n      require(role < MAX_NUM_OF_ROLES, 'INVALID_ROLE');\n\n      uint256 permissions = _users[user].permissions;\n      address permissionAdmin = _users[user].permissionAdmin;\n\n      require(\n        (permissions != 0 && permissionAdmin == msg.sender) ||\n          _users[user].permissionAdmin == address(0),\n        'INVALID_PERMISSIONADMIN'\n      );\n\n      _users[user].permissions = permissions & ~(1 << role);\n\n      if (_users[user].permissions == 0) {\n        //all permission have been removed\n        _users[user].permissionAdmin = address(0);\n      }\n\n      emit RoleSet(user, role, msg.sender, false);\n    }\n  }\n\n  ///@inheritdoc IPermissionManager\n  function getUserPermissions(address user)\n    external\n    view\n    override\n    returns (uint256[] memory, uint256)\n  {\n    uint256[] memory roles = new uint256[](256);\n    uint256 rolesCount = 0;\n    uint256 userPermissions = _users[user].permissions;\n\n    for (uint256 i = 0; i < 256; i++) {\n      if ((userPermissions >> i) & 1 > 0) {\n        roles[rolesCount] = i;\n        rolesCount++;\n      }\n    }\n\n    return (roles, rolesCount);\n  }\n\n  ///@inheritdoc IPermissionManager\n  function isInRole(address user, uint256 role) external view override returns (bool) {\n    return (_users[user].permissions >> role) & 1 > 0;\n  }\n\n  ///@inheritdoc IPermissionManager\n  function isInAllRoles(address user, uint256[] calldata roles)\n    external\n    view\n    override\n    returns (bool)\n  {\n    for (uint256 i = 0; i < roles.length; i++) {\n      if ((_users[user].permissions >> roles[i]) & 1 == 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///@inheritdoc IPermissionManager\n  function isInAnyRole(address user, uint256[] calldata roles)\n    external\n    view\n    override\n    returns (bool)\n  {\n    for (uint256 i = 0; i < roles.length; i++) {\n      if ((_users[user].permissions >> roles[i]) & 1 > 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  ///@inheritdoc IPermissionManager\n  function isPermissionsAdmin(address admin) public view override returns (bool) {\n    return _permissionsAdmins[admin] > 0;\n  }\n\n  ///@inheritdoc IPermissionManager\n  function getUserPermissionAdmin(address user) external view override returns (address) {\n    return _users[user].permissionAdmin;\n  }\n\n  ///@inheritdoc IPermissionManager\n  function isUserPermissionAdminValid(address user) external view override returns (bool) {\n    return _permissionsAdmins[_users[user].permissionAdmin] > 0;\n  }\n}\n"
    },
    "contracts/interfaces/IPermissionManager.sol": {
      "content": "pragma solidity 0.6.12;\n\ninterface IPermissionManager {\n  event RoleSet(address indexed user, uint256 indexed role, address indexed whiteLister, bool set);\n  event PermissionsAdminSet(address indexed user, bool set);\n\n  /**\n   * @dev Allows owner to add new permission admins\n   * @param admins The addresses to promote to permission admin\n   **/\n  function addPermissionAdmins(address[] calldata admins) external;\n\n  /**\n   * @dev Allows owner to remove permission admins\n   * @param admins The addresses to demote as permission admin\n   **/\n  function removePermissionAdmins(address[] calldata admins) external;\n\n  /**\n   * @dev Allows owner to whitelist a set of addresses for multiple roles\n   * @param roles The list of roles to assign\n   * @param users The list of users to add to the corresponding role\n   **/\n  function addPermissions(uint256[] calldata roles, address[] calldata users) external;\n\n  /**\n   * @dev Allows owner to remove permissions on a set of addresses\n   * @param roles The list of roles to remove\n   * @param users The list of users to remove from the corresponding role\n   **/\n  function removePermissions(uint256[] calldata roles, address[] calldata users) external;\n\n  /**\n   * @dev Returns the permissions configuration for a specific user\n   * @param user The address of the user\n   * @return the set of permissions states for the user\n   **/\n  function getUserPermissions(address user) external view returns (uint256[] memory, uint256);\n\n  /**\n   * @dev Used to query if a certain user has a certain role\n   * @param user The address of the user\n   * @return True if the user is in the specific role\n   **/\n  function isInRole(address user, uint256 role) external view returns (bool);\n\n  /**\n   * @dev Used to query if a certain user has the permissions admin role\n   * @param user The address of the user\n   * @return True if the user is a permissions admin, false otherwise\n   **/\n  function isPermissionsAdmin(address user) external view returns (bool);\n\n  /**\n   * @dev Used to query if a certain user satisfies certain roles\n   * @param user The address of the user\n   * @param roles The roles to check\n   * @return True if the user has all the roles, false otherwise\n   **/\n  function isInAllRoles(address user, uint256[] calldata roles) external view returns (bool);\n\n  /**\n   * @dev Used to query if a certain user is in at least one of the roles specified\n   * @param user The address of the user\n   * @return True if the user has all the roles, false otherwise\n   **/\n  function isInAnyRole(address user, uint256[] calldata roles) external view returns (bool);\n\n  /**\n   * @dev Used to query if a certain user is in at least one of the roles specified\n   * @param user The address of the user\n   * @return the address of the permissionAdmin of the user\n   **/\n  function getUserPermissionAdmin(address user) external view returns (address);\n\n  /**\n   * @dev Used to query if the permission admin of a certain user is valid\n   * @param user The address of the user\n   * @return true if the permission admin of user is valid, false otherwise\n   **/\n  function isUserPermissionAdminValid(address user) external view returns (bool);\n}\n"
    },
    "contracts/dependencies/openzeppelin/contracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport './Context.sol';\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor() internal {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\n    _;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n"
    },
    "contracts/dependencies/openzeppelin/contracts/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address payable) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes memory) {\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n    return msg.data;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "evmVersion": "istanbul",
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}