{"GenArt721Minter_Flutter.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./SafeMath.sol\";\nimport \"./Strings.sol\";\nimport \"./Validator.sol\";\n\ninterface GenArt721CoreV2 {\n  function isWhitelisted(address sender) external view returns (bool);\n  function projectIdToCurrencySymbol(uint256 _projectId) external view returns (string memory);\n  function projectIdToCurrencyAddress(uint256 _projectId) external view returns (address);\n  function projectIdToArtistAddress(uint256 _projectId) external view returns (address payable);\n  function projectIdToPricePerTokenInWei(uint256 _projectId) external view returns (uint256);\n  function projectIdToAdditionalPayee(uint256 _projectId) external view returns (address payable);\n  function projectIdToAdditionalPayeePercentage(uint256 _projectId) external view returns (uint256);\n  function projectTokenInfo(uint256 _projectId) external view returns (address, uint256, uint256, uint256, bool, address, uint256, string memory, address);\n  function renderProviderAddress() external view returns (address payable);\n  function renderProviderPercentage() external view returns (uint256);\n  function mint(address _to, uint256 _projectId, address _by) external returns (uint256 tokenId);\n}\n\ninterface ERC20 {\n  function balanceOf(address _owner) external view returns (uint balance);\n  function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n  function allowance(address _owner, address _spender) external view returns (uint remaining);\n}\n\ninterface BonusContract {\n  function triggerBonus(address _to) external returns (bool);\n  function bonusIsActive() external view returns (bool);\n}\n\ncontract GenArt721Minter_Flutter {\n  using SafeMath for uint256;\n\n  GenArt721CoreV2 public genArtCoreContract;\n\n  uint256 constant ONE_MILLION = 1_000_000;\n\n  address payable public ownerAddress;\n  uint256 public ownerPercentage;\n\n  mapping(uint256 =\u003e bool) public projectIdToBonus;\n  mapping(uint256 =\u003e address) public projectIdToBonusContractAddress;\n  mapping(uint256 =\u003e bool) public contractFilterProject;\n  mapping(address =\u003e mapping (uint256 =\u003e uint256)) public projectMintCounter;\n  mapping(uint256 =\u003e uint256) public projectMintLimit;\n  mapping(uint256 =\u003e bool) public projectMaxHasBeenInvoked;\n  mapping(uint256 =\u003e uint256) public projectMaxInvocations;\n  mapping(uint256 =\u003e address) public validatorContracts;\n\n  constructor(address _genArt721Address) public {\n    genArtCoreContract=GenArt721CoreV2(_genArt721Address);\n  }\n\n  function setValidator(uint256 _projectId, address _validatorContract) public {\n    require(genArtCoreContract.isWhitelisted(msg.sender), \"can only be set by admin\");\n    validatorContracts[_projectId] = _validatorContract;\n  }\n  \n  function getYourBalanceOfProjectERC20(uint256 _projectId) public view returns (uint256){\n    uint256 balance = ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).balanceOf(msg.sender);\n    return balance;\n  }\n\n  function checkYourAllowanceOfProjectERC20(uint256 _projectId) public view returns (uint256){\n    uint256 remaining = ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).allowance(msg.sender, address(this));\n    return remaining;\n  }\n\n  function setProjectMintLimit(uint256 _projectId,uint8 _limit) public {\n    require(genArtCoreContract.isWhitelisted(msg.sender), \"can only be set by admin\");\n    projectMintLimit[_projectId] = _limit;\n  }\n\n  function setProjectMaxInvocations(uint256 _projectId) public {\n    require(genArtCoreContract.isWhitelisted(msg.sender), \"can only be set by admin\");\n    uint256 maxInvocations;\n    ( , , , maxInvocations, , , , , ) = genArtCoreContract.projectTokenInfo(_projectId);\n    projectMaxInvocations[_projectId] = maxInvocations;\n  }\n\n  function setOwnerAddress(address payable _ownerAddress) public {\n    require(genArtCoreContract.isWhitelisted(msg.sender), \"can only be set by admin\");\n    ownerAddress = _ownerAddress;\n  }\n\n  function setOwnerPercentage(uint256 _ownerPercentage) public {\n    require(genArtCoreContract.isWhitelisted(msg.sender), \"can only be set by admin\");\n    ownerPercentage = _ownerPercentage;\n  }\n\n  function toggleContractFilter(uint256 _projectId) public {\n    require(genArtCoreContract.isWhitelisted(msg.sender), \"can only be set by admin\");\n    contractFilterProject[_projectId]=!contractFilterProject[_projectId];\n  }\n\n  function artistToggleBonus(uint256 _projectId) public {\n    require(msg.sender==genArtCoreContract.projectIdToArtistAddress(_projectId), \"can only be set by artist\");\n    projectIdToBonus[_projectId]=!projectIdToBonus[_projectId];\n  }\n\n  function artistSetBonusContractAddress(uint256 _projectId, address _bonusContractAddress) public {\n    require(msg.sender==genArtCoreContract.projectIdToArtistAddress(_projectId), \"can only be set by artist\");\n    projectIdToBonusContractAddress[_projectId]=_bonusContractAddress;\n  }\n  \n  function addressCanMint(address _to, uint256 _projectId) public view returns (bool) {\n    address validatorAddress = validatorContracts[_projectId];\n    \n    return validatorAddress == address(0) || Validator(validatorAddress).validateMint(_to);\n  }\n  \n  function getValidationErrorMessage(uint256 _projectId) public view returns (string memory) {\n    address validatorAddress = validatorContracts[_projectId];\n    if (validatorAddress != address(0)) {\n      Validator(validatorAddress).errorMessage();\n    }\n  }\n  \n  function mintDao(address _to, uint256 _projectId, uint256 count) public {\n    require(genArtCoreContract.isWhitelisted(msg.sender), \"can only be called by admin\");\n    require(!projectMaxHasBeenInvoked[_projectId], \"Maximum number of invocations reached\");\n\n    for (uint256 x = 0; x \u003c count; x++) {\n      genArtCoreContract.mint(_to, _projectId, msg.sender);\n    }\n  }\n\n  function purchase(uint256 _projectId) public payable returns (uint256 _tokenId) {\n    return purchaseTo(msg.sender, _projectId);\n  }\n\n  // Remove `public`` and `payable`` to prevent public use\n  // of the `purchaseTo`` function.\n  function purchaseTo(address _to, uint256 _projectId) public payable returns(uint256 _tokenId){\n    require(!projectMaxHasBeenInvoked[_projectId], \"Maximum number of invocations reached\");\n    require(addressCanMint(_to, _projectId), getValidationErrorMessage(_projectId));\n    \n    if (keccak256(abi.encodePacked(genArtCoreContract.projectIdToCurrencySymbol(_projectId))) != keccak256(abi.encodePacked(\"ETH\"))){\n      require(msg.value==0, \"this project accepts a different currency and cannot accept ETH\");\n      require(ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).allowance(msg.sender, address(this)) \u003e= genArtCoreContract.projectIdToPricePerTokenInWei(_projectId), \"Insufficient Funds Approved for TX\");\n      require(ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).balanceOf(msg.sender) \u003e= genArtCoreContract.projectIdToPricePerTokenInWei(_projectId), \"Insufficient balance.\");\n      _splitFundsERC20(_projectId);\n    } else {\n      require(msg.value\u003e=genArtCoreContract.projectIdToPricePerTokenInWei(_projectId), \"Must send minimum value to mint!\");\n      _splitFundsETH(_projectId);\n    }\n\n    // if contract filter is active prevent calls from another contract\n    if (contractFilterProject[_projectId]) require(msg.sender == tx.origin, \"No Contract Buys\");\n\n    // limit mints per address by project\n    if (projectMintLimit[_projectId] \u003e 0) {\n        require(projectMintCounter[msg.sender][_projectId] \u003c projectMintLimit[_projectId], \"Reached minting limit\");\n        projectMintCounter[msg.sender][_projectId]++;\n    }\n\n    uint256 tokenId = genArtCoreContract.mint(_to, _projectId, msg.sender);\n\n    // What if this overflows, since default value of uint256 is 0?\n    // That is intended, so that by default the minter allows infinite\n    // transactions, allowing the `genArtCoreContract` to stop minting\n    // `uint256 tokenInvocation = tokenId % ONE_MILLION;`\n    if (tokenId % ONE_MILLION == projectMaxInvocations[_projectId]-1){\n        projectMaxHasBeenInvoked[_projectId] = true;\n    }\n\n    if (projectIdToBonus[_projectId]){\n      require(BonusContract(projectIdToBonusContractAddress[_projectId]).bonusIsActive(), \"bonus must be active\");\n      BonusContract(projectIdToBonusContractAddress[_projectId]).triggerBonus(msg.sender);\n    }\n\n    return tokenId;\n  }\n\n  function _splitFundsETH(uint256 _projectId) internal {\n    if (msg.value \u003e 0) {\n      uint256 pricePerTokenInWei = genArtCoreContract.projectIdToPricePerTokenInWei(_projectId);\n      uint256 refund = msg.value.sub(genArtCoreContract.projectIdToPricePerTokenInWei(_projectId));\n      if (refund \u003e 0) {\n        msg.sender.transfer(refund);\n      }\n      uint256 renderProviderAmount = pricePerTokenInWei.div(100).mul(genArtCoreContract.renderProviderPercentage());\n      if (renderProviderAmount \u003e 0) {\n        genArtCoreContract.renderProviderAddress().transfer(renderProviderAmount);\n      }\n\n      uint256 remainingFunds = pricePerTokenInWei.sub(renderProviderAmount);\n\n      uint256 ownerFunds = remainingFunds.div(100).mul(ownerPercentage);\n      if (ownerFunds \u003e 0) {\n        ownerAddress.transfer(ownerFunds);\n      }\n\n      uint256 projectFunds = pricePerTokenInWei.sub(renderProviderAmount).sub(ownerFunds);\n      uint256 additionalPayeeAmount;\n      if (genArtCoreContract.projectIdToAdditionalPayeePercentage(_projectId) \u003e 0) {\n        additionalPayeeAmount = projectFunds.div(100).mul(genArtCoreContract.projectIdToAdditionalPayeePercentage(_projectId));\n        if (additionalPayeeAmount \u003e 0) {\n          genArtCoreContract.projectIdToAdditionalPayee(_projectId).transfer(additionalPayeeAmount);\n        }\n      }\n      uint256 creatorFunds = projectFunds.sub(additionalPayeeAmount);\n      if (creatorFunds \u003e 0) {\n        genArtCoreContract.projectIdToArtistAddress(_projectId).transfer(creatorFunds);\n      }\n    }\n  }\n\n  function _splitFundsERC20(uint256 _projectId) internal {\n      uint256 pricePerTokenInWei = genArtCoreContract.projectIdToPricePerTokenInWei(_projectId);\n      uint256 renderProviderAmount = pricePerTokenInWei.div(100).mul(genArtCoreContract.renderProviderPercentage());\n      if (renderProviderAmount \u003e 0) {\n        ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).transferFrom(msg.sender, genArtCoreContract.renderProviderAddress(), renderProviderAmount);\n      }\n      uint256 remainingFunds = pricePerTokenInWei.sub(renderProviderAmount);\n\n      uint256 ownerFunds = remainingFunds.div(100).mul(ownerPercentage);\n      if (ownerFunds \u003e 0) {\n        ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).transferFrom(msg.sender, ownerAddress, ownerFunds);\n      }\n\n      uint256 projectFunds = pricePerTokenInWei.sub(renderProviderAmount).sub(ownerFunds);\n      uint256 additionalPayeeAmount;\n      if (genArtCoreContract.projectIdToAdditionalPayeePercentage(_projectId) \u003e 0) {\n        additionalPayeeAmount = projectFunds.div(100).mul(genArtCoreContract.projectIdToAdditionalPayeePercentage(_projectId));\n        if (additionalPayeeAmount \u003e 0) {\n          ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).transferFrom(msg.sender, genArtCoreContract.projectIdToAdditionalPayee(_projectId), additionalPayeeAmount);\n        }\n      }\n      uint256 creatorFunds = projectFunds.sub(additionalPayeeAmount);\n      if (creatorFunds \u003e 0) {\n        ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).transferFrom(msg.sender, genArtCoreContract.projectIdToArtistAddress(_projectId), creatorFunds);\n      }\n    }\n}\n"},"SafeMath.sol":{"content":"// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n}\n"},"Strings.sol":{"content":"// File: contracts/Strings.sol\n\npragma solidity ^0.5.0;\n\n//https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\nlibrary Strings {\n\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory _concatenatedString) {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory _concatenatedString) {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory _concatenatedString) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory _concatenatedString) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        uint i = 0;\n        for (i = 0; i \u003c _ba.length; i++) {\n            babcde[k++] = _ba[i];\n        }\n        for (i = 0; i \u003c _bb.length; i++) {\n            babcde[k++] = _bb[i];\n        }\n        for (i = 0; i \u003c _bc.length; i++) {\n            babcde[k++] = _bc[i];\n        }\n        for (i = 0; i \u003c _bd.length; i++) {\n            babcde[k++] = _bd[i];\n        }\n        for (i = 0; i \u003c _be.length; i++) {\n            babcde[k++] = _be[i];\n        }\n        return string(babcde);\n    }\n\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = byte(uint8(48 + _i % 10));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n"},"Validator.sol":{"content":"// File: Validator.sol\n\npragma solidity ^0.5.0;\n\n/**\n * Interface for a validation mechanism for mint destination addresses.\n */\ninterface Validator {\n    \n  /**\n   * Get error message for this validator.\n   */   \n  function errorMessage() external view returns (string memory);\n\n  /**\n   * Validates that the given destination address is validate for a mint. Function\n   * will return false if validation fails.\n   */\n  function validateMint(address _to) external view returns (bool);\n}\n"}}