{{
  "language": "Solidity",
  "sources": {
    "contracts/statechannels/AllocationExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\n\nimport \"../governance/Governed.sol\";\nimport \"../staking/IStaking.sol\";\nimport \"../token/IGraphToken.sol\";\n\n/**\n * @title Allocation Exchange\n * @dev This contract holds tokens that anyone with a voucher signed by the\n * authority can redeem. The contract validates if the voucher presented is valid\n * and then sends tokens to the Staking contract by calling the collect() function\n * passing the voucher allocationID. The contract enforces that only one voucher for\n * an allocationID can be redeemed.\n * Only governance can change the authority.\n */\ncontract AllocationExchange is Governed {\n    // An allocation voucher represents a signed message that allows\n    // redeeming an amount of funds from this contract and collect\n    // them as part of an allocation\n    struct AllocationVoucher {\n        address allocationID;\n        uint256 amount;\n        bytes signature; // 65 bytes\n    }\n\n    // -- Constants --\n\n    uint256 private constant MAX_UINT256 = 2**256 - 1;\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    // -- State --\n\n    IStaking private immutable staking;\n    IGraphToken private immutable graphToken;\n    address public authority;\n    mapping(address => bool) public allocationsRedeemed;\n\n    // -- Events\n\n    event AuthoritySet(address indexed account);\n    event AllocationRedeemed(address indexed allocationID, uint256 amount);\n    event TokensWithdrawn(address indexed to, uint256 amount);\n\n    // -- Functions\n\n    constructor(\n        IGraphToken _graphToken,\n        IStaking _staking,\n        address _governor,\n        address _authority\n    ) {\n        Governed._initialize(_governor);\n\n        graphToken = _graphToken;\n        staking = _staking;\n        _setAuthority(_authority);\n    }\n\n    /**\n     * @notice Approve the staking contract to pull any amount of tokens from this contract.\n     * @dev Increased gas efficiency instead of approving on each voucher redeem\n     */\n    function approveAll() external {\n        graphToken.approve(address(staking), MAX_UINT256);\n    }\n\n    /**\n     * @notice Withdraw tokens held in the contract.\n     * @dev Only the governor can withdraw\n     * @param _to Destination to send the tokens\n     * @param _amount Amount of tokens to withdraw\n     */\n    function withdraw(address _to, uint256 _amount) external onlyGovernor {\n        require(_to != address(0), \"Exchange: empty destination\");\n        require(_amount != 0, \"Exchange: empty amount\");\n        require(graphToken.transfer(_to, _amount), \"Exchange: cannot transfer\");\n        emit TokensWithdrawn(_to, _amount);\n    }\n\n    /**\n     * @notice Set the authority allowed to sign vouchers.\n     * @dev Only the governor can set the authority\n     * @param _authority Address of the signing authority\n     */\n    function setAuthority(address _authority) external onlyGovernor {\n        _setAuthority(_authority);\n    }\n\n    /**\n     * @notice Set the authority allowed to sign vouchers.\n     * @param _authority Address of the signing authority\n     */\n    function _setAuthority(address _authority) private {\n        require(_authority != address(0), \"Exchange: empty authority\");\n        authority = _authority;\n        emit AuthoritySet(authority);\n    }\n\n    /**\n     * @notice Redeem a voucher signed by the authority. No voucher double spending is allowed.\n     * @dev The voucher must be signed using an Ethereum signed message\n     * @param _voucher Voucher data\n     */\n    function redeem(AllocationVoucher memory _voucher) external {\n        _redeem(_voucher);\n    }\n\n    /**\n     * @notice Redeem multiple vouchers.\n     * @dev Each voucher must be signed using an Ethereum signed message\n     * @param _vouchers An array of vouchers\n     */\n    function redeemMany(AllocationVoucher[] memory _vouchers) external {\n        for (uint256 i = 0; i < _vouchers.length; i++) {\n            _redeem(_vouchers[i]);\n        }\n    }\n\n    /**\n     * @notice Redeem a voucher signed by the authority. No voucher double spending is allowed.\n     * @dev The voucher must be signed using an Ethereum signed message\n     * @param _voucher Voucher data\n     */\n    function _redeem(AllocationVoucher memory _voucher) private {\n        require(_voucher.amount > 0, \"Exchange: zero tokens voucher\");\n        require(_voucher.signature.length == SIGNATURE_LENGTH, \"Exchange: invalid signature\");\n\n        // Already redeemed check\n        require(\n            !allocationsRedeemed[_voucher.allocationID],\n            \"Exchange: allocation already redeemed\"\n        );\n\n        // Signature check\n        bytes32 messageHash = keccak256(abi.encodePacked(_voucher.allocationID, _voucher.amount));\n        require(\n            authority == ECDSA.recover(messageHash, _voucher.signature),\n            \"Exchange: invalid signer\"\n        );\n\n        // Mark allocation as collected\n        allocationsRedeemed[_voucher.allocationID] = true;\n\n        // Make the staking contract collect funds from this contract\n        // The Staking contract will validate if the allocation is valid\n        staking.collect(_voucher.amount, _voucher.allocationID);\n\n        emit AllocationRedeemed(_voucher.allocationID, _voucher.amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "contracts/governance/Governed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\n\n/**\n * @title Graph Governance contract\n * @dev All contracts that will be owned by a Governor entity should extend this contract.\n */\ncontract Governed {\n    // -- State --\n\n    address public governor;\n    address public pendingGovernor;\n\n    // -- Events --\n\n    event NewPendingOwnership(address indexed from, address indexed to);\n    event NewOwnership(address indexed from, address indexed to);\n\n    /**\n     * @dev Check if the caller is the governor.\n     */\n    modifier onlyGovernor {\n        require(msg.sender == governor, \"Only Governor can call\");\n        _;\n    }\n\n    /**\n     * @dev Initialize the governor to the contract caller.\n     */\n    function _initialize(address _initGovernor) internal {\n        governor = _initGovernor;\n    }\n\n    /**\n     * @dev Admin function to begin change of governor. The `_newGovernor` must call\n     * `acceptOwnership` to finalize the transfer.\n     * @param _newGovernor Address of new `governor`\n     */\n    function transferOwnership(address _newGovernor) external onlyGovernor {\n        require(_newGovernor != address(0), \"Governor must be set\");\n\n        address oldPendingGovernor = pendingGovernor;\n        pendingGovernor = _newGovernor;\n\n        emit NewPendingOwnership(oldPendingGovernor, pendingGovernor);\n    }\n\n    /**\n     * @dev Admin function for pending governor to accept role and update governor.\n     * This function must called by the pending governor.\n     */\n    function acceptOwnership() external {\n        require(\n            pendingGovernor != address(0) && msg.sender == pendingGovernor,\n            \"Caller must be pending governor\"\n        );\n\n        address oldGovernor = governor;\n        address oldPendingGovernor = pendingGovernor;\n\n        governor = pendingGovernor;\n        pendingGovernor = address(0);\n\n        emit NewOwnership(oldGovernor, governor);\n        emit NewPendingOwnership(oldPendingGovernor, pendingGovernor);\n    }\n}\n"
    },
    "contracts/staking/IStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12 <0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IStakingData.sol\";\n\ninterface IStaking is IStakingData {\n    // -- Allocation Data --\n\n    /**\n     * @dev Possible states an allocation can be\n     * States:\n     * - Null = indexer == address(0)\n     * - Active = not Null && tokens > 0\n     * - Closed = Active && closedAtEpoch != 0\n     * - Finalized = Closed && closedAtEpoch + channelDisputeEpochs > now()\n     * - Claimed = not Null && tokens == 0\n     */\n    enum AllocationState { Null, Active, Closed, Finalized, Claimed }\n\n    // -- Configuration --\n\n    function setMinimumIndexerStake(uint256 _minimumIndexerStake) external;\n\n    function setThawingPeriod(uint32 _thawingPeriod) external;\n\n    function setCurationPercentage(uint32 _percentage) external;\n\n    function setProtocolPercentage(uint32 _percentage) external;\n\n    function setChannelDisputeEpochs(uint32 _channelDisputeEpochs) external;\n\n    function setMaxAllocationEpochs(uint32 _maxAllocationEpochs) external;\n\n    function setRebateRatio(uint32 _alphaNumerator, uint32 _alphaDenominator) external;\n\n    function setDelegationRatio(uint32 _delegationRatio) external;\n\n    function setDelegationParameters(\n        uint32 _indexingRewardCut,\n        uint32 _queryFeeCut,\n        uint32 _cooldownBlocks\n    ) external;\n\n    function setDelegationParametersCooldown(uint32 _blocks) external;\n\n    function setDelegationUnbondingPeriod(uint32 _delegationUnbondingPeriod) external;\n\n    function setDelegationTaxPercentage(uint32 _percentage) external;\n\n    function setSlasher(address _slasher, bool _allowed) external;\n\n    function setAssetHolder(address _assetHolder, bool _allowed) external;\n\n    // -- Operation --\n\n    function setOperator(address _operator, bool _allowed) external;\n\n    function isOperator(address _operator, address _indexer) external view returns (bool);\n\n    // -- Staking --\n\n    function stake(uint256 _tokens) external;\n\n    function stakeTo(address _indexer, uint256 _tokens) external;\n\n    function unstake(uint256 _tokens) external;\n\n    function slash(\n        address _indexer,\n        uint256 _tokens,\n        uint256 _reward,\n        address _beneficiary\n    ) external;\n\n    function withdraw() external;\n\n    function setRewardsDestination(address _destination) external;\n\n    // -- Delegation --\n\n    function delegate(address _indexer, uint256 _tokens) external returns (uint256);\n\n    function undelegate(address _indexer, uint256 _shares) external returns (uint256);\n\n    function withdrawDelegated(address _indexer, address _newIndexer) external returns (uint256);\n\n    // -- Channel management and allocations --\n\n    function allocate(\n        bytes32 _subgraphDeploymentID,\n        uint256 _tokens,\n        address _allocationID,\n        bytes32 _metadata,\n        bytes calldata _proof\n    ) external;\n\n    function allocateFrom(\n        address _indexer,\n        bytes32 _subgraphDeploymentID,\n        uint256 _tokens,\n        address _allocationID,\n        bytes32 _metadata,\n        bytes calldata _proof\n    ) external;\n\n    function closeAllocation(address _allocationID, bytes32 _poi) external;\n\n    function closeAllocationMany(CloseAllocationRequest[] calldata _requests) external;\n\n    function closeAndAllocate(\n        address _oldAllocationID,\n        bytes32 _poi,\n        address _indexer,\n        bytes32 _subgraphDeploymentID,\n        uint256 _tokens,\n        address _allocationID,\n        bytes32 _metadata,\n        bytes calldata _proof\n    ) external;\n\n    function collect(uint256 _tokens, address _allocationID) external;\n\n    function claim(address _allocationID, bool _restake) external;\n\n    function claimMany(address[] calldata _allocationID, bool _restake) external;\n\n    // -- Getters and calculations --\n\n    function hasStake(address _indexer) external view returns (bool);\n\n    function getIndexerStakedTokens(address _indexer) external view returns (uint256);\n\n    function getIndexerCapacity(address _indexer) external view returns (uint256);\n\n    function getAllocation(address _allocationID) external view returns (Allocation memory);\n\n    function getAllocationState(address _allocationID) external view returns (AllocationState);\n\n    function isAllocation(address _allocationID) external view returns (bool);\n\n    function getSubgraphAllocatedTokens(bytes32 _subgraphDeploymentID)\n        external\n        view\n        returns (uint256);\n\n    function getDelegation(address _indexer, address _delegator)\n        external\n        view\n        returns (Delegation memory);\n\n    function isDelegator(address _indexer, address _delegator) external view returns (bool);\n}\n"
    },
    "contracts/token/IGraphToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IGraphToken is IERC20 {\n    // -- Mint and Burn --\n\n    function burn(uint256 amount) external;\n\n    function mint(address _to, uint256 _amount) external;\n\n    // -- Mint Admin --\n\n    function addMinter(address _account) external;\n\n    function removeMinter(address _account) external;\n\n    function renounceMinter() external;\n\n    function isMinter(address _account) external view returns (bool);\n\n    // -- Permit --\n\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external;\n}\n"
    },
    "contracts/staking/IStakingData.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12 <0.8.0;\n\ninterface IStakingData {\n    /**\n     * @dev Allocate GRT tokens for the purpose of serving queries of a subgraph deployment\n     * An allocation is created in the allocate() function and consumed in claim()\n     */\n    struct Allocation {\n        address indexer;\n        bytes32 subgraphDeploymentID;\n        uint256 tokens; // Tokens allocated to a SubgraphDeployment\n        uint256 createdAtEpoch; // Epoch when it was created\n        uint256 closedAtEpoch; // Epoch when it was closed\n        uint256 collectedFees; // Collected fees for the allocation\n        uint256 effectiveAllocation; // Effective allocation when closed\n        uint256 accRewardsPerAllocatedToken; // Snapshot used for reward calc\n    }\n\n    /**\n     * @dev Represents a request to close an allocation with a specific proof of indexing.\n     * This is passed when calling closeAllocationMany to define the closing parameters for\n     * each allocation.\n     */\n    struct CloseAllocationRequest {\n        address allocationID;\n        bytes32 poi;\n    }\n\n    // -- Delegation Data --\n\n    /**\n     * @dev Delegation pool information. One per indexer.\n     */\n    struct DelegationPool {\n        uint32 cooldownBlocks; // Blocks to wait before updating parameters\n        uint32 indexingRewardCut; // in PPM\n        uint32 queryFeeCut; // in PPM\n        uint256 updatedAtBlock; // Block when the pool was last updated\n        uint256 tokens; // Total tokens as pool reserves\n        uint256 shares; // Total shares minted in the pool\n        mapping(address => Delegation) delegators; // Mapping of delegator => Delegation\n    }\n\n    /**\n     * @dev Individual delegation data of a delegator in a pool.\n     */\n    struct Delegation {\n        uint256 shares; // Shares owned by a delegator in the pool\n        uint256 tokensLocked; // Tokens locked for undelegation\n        uint256 tokensLockedUntil; // Block when locked tokens can be withdrawn\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}