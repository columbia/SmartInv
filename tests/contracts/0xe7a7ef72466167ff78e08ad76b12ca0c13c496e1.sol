{{
  "language": "Solidity",
  "sources": {
    "contracts/DogstonksPro.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport './ERC20.sol';\nimport './StakingPool.sol';\n\n/**\n * @notice ERC20 token with cost basis tracking and restricted loss-taking\n */\ncontract DogstonksPro is ERC20, StakingPool {\n  using Address for address payable;\n\n  enum Phase { PENDING, LIQUIDITY_EVENT, OPEN, CLOSED }\n\n  Phase public _phase;\n  uint public _phaseChangedAt;\n\n  string public override name = 'DogstonksPro (dogstonks.com)';\n  string public override symbol = 'DOGPRO';\n\n  address private constant UNISWAP_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n  address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n  address private constant DOGSTONKS = 0xC9aA1007b1619d04C1911E48A8a7a95770BE21a2;\n\n  uint private constant SUPPLY = 1e12 ether;\n\n  uint private constant TAX_RATE = 1000;\n  uint private constant BP_DIVISOR = 10000;\n\n  // V1 token redemption rate\n  uint private constant V1_VALUE = 12.659726999081298826 ether;\n  uint private constant V1_SUPPLY = 913290958465.509630323815153677 ether;\n\n  address private _owner;\n  address private _pair;\n\n  uint private _initialBasis;\n\n  mapping (address => uint) private _basisOf;\n  mapping (address => uint) public cooldownOf;\n\n  // credits for ETH LE deposits\n  mapping (address => uint) private _lpCredits;\n  uint private _lpCreditsTotal;\n\n  // quantity of UNI-V2 tokens corresponding to initial liquidity, shared among token holders\n  uint private _holderDistributionUNIV2;\n  // quantity of ETH to be distributed to token holders, set after trading close\n  uint private _holderDistributionETH;\n  // quantity of ETH to be distributed to liquidity providers, set after trading close\n  uint private _lpDistributionETH;\n\n  // all time high\n  uint private _ath;\n  uint private _athTimestamp;\n\n  // values to prevent adding liquidity directly\n  address private _lastOrigin;\n  uint private _lastBlock;\n\n  bool private _nohook;\n\n  struct Minting {\n    address recipient;\n    uint amount;\n  }\n\n  modifier phase (Phase p) {\n    require(_phase == p, 'ERR: invalid phase');\n    _;\n  }\n\n  modifier nohook () {\n    _nohook = true;\n    _;\n    _nohook = false;\n  }\n\n  /**\n   * @notice deploy\n   * @param mintings structured minting data (recipient, amount)\n   */\n  constructor (\n    Minting[] memory mintings\n  ) payable {\n    _owner = msg.sender;\n    _phaseChangedAt = block.timestamp;\n\n    // setup uniswap pair and store address\n\n    _pair = IUniswapV2Factory(\n      IUniswapV2Router02(UNISWAP_ROUTER).factory()\n    ).createPair(WETH, address(this));\n\n    // prepare to add/remove liquidity\n\n    _approve(address(this), UNISWAP_ROUTER, type(uint).max);\n    IERC20(_pair).approve(UNISWAP_ROUTER, type(uint).max);\n\n    // mint team tokens\n\n    uint mintedSupply;\n\n    for (uint i; i < mintings.length; i++) {\n      Minting memory m = mintings[i];\n      uint amount = m.amount;\n      address recipient = m.recipient;\n\n      mintedSupply += amount;\n      _balances[recipient] += amount;\n      emit Transfer(address(0), recipient, amount);\n    }\n\n    _totalSupply = mintedSupply;\n  }\n\n  receive () external payable {}\n\n  /**\n   * @inheritdoc ERC20\n   * @dev reverts if Uniswap pair holds more WETH than accounted for in reserves (suggesting liquidity is being added)\n   */\n  function balanceOf (\n    address account\n  ) override public view returns (uint) {\n    if (msg.sender == _pair && tx.origin == _lastOrigin && block.number == _lastBlock) {\n      (uint res0, uint res1, ) = IUniswapV2Pair(_pair).getReserves();\n      require(\n        (address(this) > WETH ? res0 : res1) > IERC20(WETH).balanceOf(_pair),\n        'ERR: liquidity add'\n      );\n    }\n    return super.balanceOf(account);\n  }\n\n  /**\n   * @notice get cost basis for given address\n   * @param account address to query\n   * @return cost basis\n   */\n  function basisOf (\n    address account\n  ) public view returns (uint) {\n    uint basis = _basisOf[account];\n\n    if (basis == 0 && balanceOf(account) > 0) {\n      basis = _initialBasis;\n    }\n\n    return basis;\n  }\n\n  /**\n   * @notice calculate current cost basis for sale of given quantity of tokens\n   * @param amount quantity of tokens sold\n   * @return cost basis for sale\n   */\n  function basisOfSale (\n    uint amount\n  ) public view returns (uint) {\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = WETH;\n\n    uint[] memory amounts = IUniswapV2Router02(UNISWAP_ROUTER).getAmountsOut(\n      amount,\n      path\n    );\n\n    return (1 ether) * amounts[1] / amount;\n  }\n\n  /**\n   * @notice calculate tax for given cost bases and sale amount\n   * @param fromBasis cost basis of seller\n   * @param toBasis cost basis for sale\n   * @param amount quantity of tokens sold\n   * @return tax amount\n   */\n  function taxFor (\n    uint fromBasis,\n    uint toBasis,\n    uint amount\n  ) public pure returns (uint) {\n    return amount * (toBasis - fromBasis) / toBasis * TAX_RATE / BP_DIVISOR;\n  }\n\n  /**\n   * @notice enable liquidity event participation\n   */\n  function openLiquidityEvent () external phase(Phase.PENDING) {\n    require(\n      msg.sender == _owner || block.timestamp > _phaseChangedAt + (2 weeks),\n      'ERR: sender must be owner'\n    );\n\n    _incrementPhase();\n\n    // track lp credits to be used for distribution\n\n    _lpCredits[address(this)] = address(this).balance;\n    _lpCreditsTotal += address(this).balance;\n\n    // add liquidity\n\n    _mint(address(this), SUPPLY - totalSupply());\n\n    IUniswapV2Router02(\n      UNISWAP_ROUTER\n    ).addLiquidityETH{\n      value: address(this).balance\n    }(\n      address(this),\n      balanceOf(address(this)),\n      0,\n      0,\n      address(this),\n      block.timestamp\n    );\n  }\n\n  /**\n   * @notice buy in to liquidity event using DOGSTONKS V1 tokens\n   */\n  function contributeV1 () external {\n    require(_phase == Phase.LIQUIDITY_EVENT || _phase == Phase.OPEN, 'ERR: invalid phase');\n\n    uint amount = IERC20(DOGSTONKS).balanceOf(msg.sender);\n    IERC20(DOGSTONKS).transferFrom(msg.sender, DOGSTONKS, amount);\n\n    address[] memory path = new address[](2);\n    path[0] = WETH;\n    path[1] = address(this);\n\n    uint[] memory amounts = IUniswapV2Router02(\n      UNISWAP_ROUTER\n    ).getAmountsOut(\n      amount * V1_VALUE / V1_SUPPLY,\n      path\n    );\n\n    // credit sender with deposit\n\n    _mintTaxCredit(msg.sender, amounts[1]);\n  }\n\n  /**\n   * @notice buy in to liquidity event using ETH\n   */\n  function contributeETH () external payable phase(Phase.LIQUIDITY_EVENT) nohook {\n    if (block.timestamp < _phaseChangedAt + (15 minutes)) {\n      // at beginning of LE, only V1 depositors and team token holders may contribute\n      require(\n        taxCreditsOf(msg.sender) >= 1e6 ether || balanceOf(msg.sender) > 0,\n        'ERR: must contribute V1 tokens'\n      );\n    }\n\n    // add liquidity via purchase to simulate price action by purchasing tokens\n\n    address[] memory path = new address[](2);\n    path[0] = WETH;\n    path[1] = address(this);\n\n    uint[] memory amounts = IUniswapV2Router02(\n      UNISWAP_ROUTER\n    ).swapExactETHForTokens{\n      value: msg.value\n    }(\n      0,\n      path,\n      msg.sender,\n      block.timestamp\n    );\n\n    _transfer(msg.sender, _pair, amounts[1]);\n    IUniswapV2Pair(_pair).sync();\n\n    // credit sender with deposit\n\n    _mintTaxCredit(msg.sender, amounts[1]);\n    _lpCredits[msg.sender] += msg.value;\n    _lpCreditsTotal += msg.value;\n  }\n\n  /**\n   * @notice open trading\n   * @dev sender must be owner\n   * @dev trading must not yet have been opened\n   */\n  function open () external phase(Phase.LIQUIDITY_EVENT) {\n    require(\n      msg.sender == _owner || block.timestamp > _phaseChangedAt + (1 hours),\n      'ERR: sender must be owner'\n    );\n\n    _incrementPhase();\n\n    // set initial cost basis\n\n    _initialBasis = (1 ether) * IERC20(WETH).balanceOf(_pair) / balanceOf(_pair);\n\n    // calculate proportion of UNI-V2 tokens for distribution\n\n    _holderDistributionUNIV2 = IERC20(_pair).totalSupply() * _lpCredits[address(this)] / _lpCreditsTotal;\n  }\n\n  /**\n   * @notice add Uniswap liquidity\n   * @param amount quantity of DOGPRO to add\n   */\n  function addLiquidity (\n    uint amount\n  ) external payable phase(Phase.OPEN) {\n    _transfer(msg.sender, address(this), amount);\n\n    uint liquidityETH = IERC20(WETH).balanceOf(_pair);\n\n    (uint amountToken, uint amountETH, ) = IUniswapV2Router02(\n      UNISWAP_ROUTER\n    ).addLiquidityETH{\n      value: msg.value\n    }(\n      address(this),\n      amount,\n      0,\n      0,\n      address(this),\n      block.timestamp\n    );\n\n    if (amountToken < amount) {\n      _transfer(address(this), msg.sender, amount - amountToken);\n    }\n\n    if (amountETH < msg.value) {\n      payable(msg.sender).sendValue(msg.value - amountETH);\n    }\n\n    uint lpCreditsDelta = _lpCreditsTotal * amountETH / liquidityETH;\n    _lpCredits[msg.sender] += lpCreditsDelta;\n    _lpCreditsTotal += lpCreditsDelta;\n\n    _mintTaxCredit(msg.sender, amountToken);\n  }\n\n  /**\n   * @notice close trading\n   * @dev trading must not yet have been closed\n   * @dev minimum time since open must have elapsed\n   */\n  function close () external phase(Phase.OPEN) {\n    require(block.timestamp > _phaseChangedAt + (1 days), 'ERR: too soon');\n\n    _incrementPhase();\n\n    require(\n      block.timestamp > _athTimestamp + (1 weeks),\n      'ERR: recent ATH'\n    );\n\n    uint univ2 = IERC20(_pair).balanceOf(address(this));\n\n    (uint amountToken, ) = IUniswapV2Router02(\n      UNISWAP_ROUTER\n    ).removeLiquidityETH(\n      address(this),\n      univ2,\n      0,\n      0,\n      address(this),\n      block.timestamp\n    );\n\n    _burn(address(this), amountToken);\n\n    // split liquidity between holders and liquidity providers\n\n    _holderDistributionETH = address(this).balance * _holderDistributionUNIV2 / univ2;\n    _lpDistributionETH = address(this).balance - _holderDistributionETH;\n\n    // stop tracking LP credit for original deposit\n\n    _lpCreditsTotal -= _lpCredits[address(this)];\n    delete _lpCredits[address(this)];\n  }\n\n  /**\n   * @notice exchange DOGPRO for proportion of ETH in contract\n   * @dev trading must have been closed\n   */\n  function liquidate () external phase(Phase.CLOSED) {\n    // claim tax rewards\n\n    if (taxCreditsOf(msg.sender) > 0) {\n      _transfer(address(this), msg.sender, taxRewardsOf(msg.sender));\n      _burnTaxCredit(msg.sender);\n    }\n\n    // calculate share of holder rewards\n\n    uint balance = balanceOf(msg.sender);\n    uint holderPayout;\n\n    if (balance > 0) {\n      holderPayout = _holderDistributionETH * balance / totalSupply();\n      _holderDistributionETH -= holderPayout;\n      _burn(msg.sender, balance);\n    }\n\n    // calculate share of liquidity\n\n    uint lpCredits = _lpCredits[msg.sender];\n    uint lpPayout;\n\n    if (lpCredits > 0) {\n      lpPayout = _lpDistributionETH * lpCredits / _lpCreditsTotal;\n      _lpDistributionETH -= lpPayout;\n\n      delete _lpCredits[msg.sender];\n      _lpCreditsTotal -= lpCredits;\n    }\n\n    payable(msg.sender).sendValue(holderPayout + lpPayout);\n  }\n\n  /**\n   * @notice withdraw remaining ETH from contract\n   * @dev trading must have been closed\n   * @dev minimum time since close must have elapsed\n   */\n  function liquidateUnclaimed () external phase(Phase.CLOSED) {\n    require(block.timestamp > _phaseChangedAt + (52 weeks), 'ERR: too soon');\n    payable(_owner).sendValue(address(this).balance);\n  }\n\n  /**\n   * @notice update contract phase and track timestamp\n   */\n  function _incrementPhase () private {\n    _phase = Phase(uint8(_phase) + 1);\n    _phaseChangedAt = block.timestamp;\n  }\n\n  /**\n   * @notice ERC20 hook: enforce transfer restrictions and cost basis; collect tax\n   * @param from tranfer sender\n   * @param to transfer recipient\n   * @param amount quantity of tokens transferred\n   */\n  function _beforeTokenTransfer (\n    address from,\n    address to,\n    uint amount\n  ) override internal {\n    super._beforeTokenTransfer(from, to, amount);\n\n    if (_nohook) return;\n\n    // ignore minting and burning\n    if (from == address(0) || to == address(0)) return;\n\n    // ignore add/remove liquidity\n    if (from == address(this) || to == address(this)) return;\n    if (from == UNISWAP_ROUTER || to == UNISWAP_ROUTER) return;\n\n    require(uint8(_phase) >= uint8(Phase.OPEN));\n\n    require(\n      msg.sender == UNISWAP_ROUTER || msg.sender == _pair,\n      'ERR: sender must be uniswap'\n    );\n    require(amount <= 5e9 ether /* revert message not returned by Uniswap */);\n\n    if (from == _pair) {\n      require(cooldownOf[to] < block.timestamp /* revert message not returned by Uniswap */);\n      cooldownOf[to] = block.timestamp + (5 minutes);\n\n      address[] memory path = new address[](2);\n      path[0] = WETH;\n      path[1] = address(this);\n\n      uint[] memory amounts = IUniswapV2Router02(UNISWAP_ROUTER).getAmountsIn(\n        amount,\n        path\n      );\n\n      uint balance = balanceOf(to);\n      uint fromBasis = (1 ether) * amounts[0] / amount;\n      _basisOf[to] = (fromBasis * amount + basisOf(to) * balance) / (amount + balance);\n\n      if (fromBasis > _ath) {\n        _ath = fromBasis;\n        _athTimestamp = block.timestamp;\n      }\n    } else if (to == _pair) {\n      _lastOrigin = tx.origin;\n      _lastBlock = block.number;\n\n      require(cooldownOf[from] < block.timestamp /* revert message not returned by Uniswap */);\n      cooldownOf[from] = block.timestamp + (5 minutes);\n\n      uint fromBasis = basisOf(from);\n      uint toBasis = basisOfSale(amount);\n\n      require(fromBasis <= toBasis /* revert message not returned by Uniswap */);\n\n      // collect tax\n      uint tax = taxFor(fromBasis, toBasis, amount);\n      _transfer(from, address(this), tax);\n      _distributeTax(tax);\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address => uint256) internal _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 internal _totalSupply;\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/StakingPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nabstract contract StakingPool {\n  uint private constant SCALE = 1e18;\n  uint private _rewardPerToken;\n  mapping (address => uint) private _rewardsAccounted;\n  mapping (address => uint) private _rewardsSkipped;\n\n  // credits for tax distribution\n  mapping (address => uint) private _taxCredits;\n  uint private _taxCreditsTotal;\n\n  function taxCreditsOf (\n    address account\n  ) public view returns (uint) {\n    return _taxCredits[account];\n  }\n\n  function taxRewardsOf (\n    address account\n  ) public view returns (uint) {\n    return (_taxCredits[account] * _rewardPerToken + _rewardsAccounted[account] - _rewardsSkipped[account]) / SCALE;\n  }\n\n  function _distributeTax (\n    uint amount\n  ) internal {\n    _rewardPerToken += amount * SCALE / _taxCreditsTotal;\n  }\n\n  function _mintTaxCredit (\n    address account,\n    uint amount\n  ) internal {\n    uint skipped = taxCreditsOf(account) * _rewardPerToken;\n    _rewardsAccounted[account] += skipped - _rewardsSkipped[account];\n    _rewardsSkipped[account] = skipped - amount * _rewardPerToken;\n\n    _taxCredits[account] += amount;\n    _taxCreditsTotal += amount;\n  }\n\n  function _burnTaxCredit (\n    address account\n  ) internal {\n    _taxCreditsTotal -= _taxCredits[account];\n    delete _taxCredits[account];\n  }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}