{{
  "language": "Solidity",
  "sources": {
    "/Users/kyle/workspace/asciipunks/contracts/AsciiPunkFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary AsciiPunkFactory {\n  uint256 private constant TOP_COUNT = 55;\n  uint256 private constant EYE_COUNT = 48;\n  uint256 private constant NOSE_COUNT = 9;\n  uint256 private constant MOUTH_COUNT = 32;\n\n  function draw(uint256 seed) public pure returns (string memory) {\n    uint256 rand = uint256(keccak256(abi.encodePacked(seed)));\n\n    string memory top = _chooseTop(rand);\n    string memory eyes = _chooseEyes(rand);\n    string memory mouth = _chooseMouth(rand);\n\n    string memory chin = unicode\"   │    │   \\n\" unicode\"   └──┘ │   \\n\";\n    string memory neck = unicode\"     │  │   \\n\" unicode\"     │  │   \\n\";\n\n    return string(abi.encodePacked(top, eyes, mouth, chin, neck));\n  }\n\n  function _chooseTop(uint256 rand) internal pure returns (string memory) {\n    string[TOP_COUNT] memory tops =\n      [\n        unicode\"   ┌───┐    \\n\"\n        unicode\"   │   ┼┐   \\n\"\n        unicode\"   ├────┼┼  \\n\",\n        unicode\"   ┌┬┬┬┬┐   \\n\"\n        unicode\"   ╓┬┬┬┬╖   \\n\"\n        unicode\"   ╙┴┴┴┴╜   \\n\",\n        unicode\"   ╒════╕   \\n\"\n        unicode\"  ┌┴────┴┐  \\n\"\n        unicode\"  └┬────┬┘  \\n\",\n        unicode\"   ╒════╕   \\n\"\n        unicode\"   │□□□□│   \\n\"\n        unicode\"  └┬────┬┘  \\n\",\n        unicode\"   ╒════╕   \\n\"\n        unicode\"   │    │   \\n\"\n        unicode\" └─┬────┬─┘ \\n\",\n        unicode\"    ◙◙◙◙    \\n\"\n        unicode\"   ▄████▄   \\n\"\n        unicode\"   ┌────┐   \\n\",\n        unicode\"   ┌───┐    \\n\"\n        unicode\"┌──┤   └┐   \\n\"\n        unicode\"└──┼────┤   \\n\",\n        unicode\"    ┌───┐   \\n\"\n        unicode\"   ┌┘   ├──┐\\n\"\n        unicode\"   ├────┼──┘\\n\",\n        unicode\"   ┌────┐/  \\n\"\n        unicode\"┌──┴────┴──┐\\n\"\n        unicode\"└──┬────┬──┘\\n\",\n        unicode\"   ╒════╕   \\n\"\n        unicode\" ┌─┴────┴─┐ \\n\"\n        unicode\" └─┬────┬─┘ \\n\",\n        unicode\"  ┌──────┐  \\n\"\n        unicode\"  │▲▲▲▲▲▲│  \\n\"\n        unicode\"  └┬────┬┘  \\n\",\n        unicode\"  ┌┌────┐┐  \\n\"\n        unicode\"  ││┌──┐││  \\n\"\n        unicode\"  └┼┴──┴┼┘  \\n\",\n        unicode\"   ┌────┐   \\n\"\n        unicode\"  ┌┘─   │   \\n\"\n        unicode\"  └┌────┐   \\n\",\n        unicode\"            \\n\"\n        unicode\"   ┌┬┬┬┬┐   \\n\"\n        unicode\"   ├┴┴┴┴┤   \\n\",\n        unicode\"            \\n\"\n        unicode\"    ╓┬╥┐    \\n\"\n        unicode\"   ┌╨┴╨┴┐   \\n\",\n        unicode\"            \\n\"\n        unicode\"   ╒╦╦╦╦╕   \\n\"\n        unicode\"   ╞╩╩╩╩╡   \\n\",\n        unicode\"            \\n\"\n        unicode\"            \\n\"\n        unicode\"   ┌┼┼┼┼┐   \\n\",\n        unicode\"            \\n\"\n        unicode\"    ││││    \\n\"\n        unicode\"   ┌┼┼┼┼┐   \\n\",\n        unicode\"      ╔     \\n\"\n        unicode\"     ╔║     \\n\"\n        unicode\"   ┌─╫╫─┐   \\n\",\n        unicode\"            \\n\"\n        unicode\"    ║║║║    \\n\"\n        unicode\"   ┌╨╨╨╨┐   \\n\",\n        unicode\"            \\n\"\n        unicode\"   ▐▐▐▌▌▌   \\n\"\n        unicode\"   ┌────┐   \\n\",\n        unicode\"            \\n\"\n        unicode\"   \\\\/////   \\n\"\n        unicode\"   ┌────┐   \\n\",\n        unicode\"    ┐ ┌     \\n\"\n        unicode\"   ┐││││┌   \\n\"\n        unicode\"   ┌────┐   \\n\",\n        unicode\"  ┌┐ ┐┌┐┌┐  \\n\"\n        unicode\"  └└┐││┌┘   \\n\"\n        unicode\"   ┌┴┴┴┴┐   \\n\",\n        unicode\"  ┐┐┐┐┐     \\n\"\n        unicode\"  └└└└└┐    \\n\"\n        unicode\"   └└└└└┐   \\n\",\n        unicode\"            \\n\"\n        unicode\"   ││││││   \\n\"\n        unicode\"   ┌────┐   \\n\",\n        unicode\"            \\n\"\n        unicode\"    ╓╓╓╓    \\n\"\n        unicode\"   ┌╨╨╨╨┐   \\n\",\n        unicode\"    ╔╔╗╗╗   \\n\"\n        unicode\"   ╔╔╔╗╗╗╗  \\n\"\n        unicode\"  ╔╝╝║ ╚╚╗  \\n\",\n        unicode\"   ╔╔╔╔╔╗   \\n\"\n        unicode\"  ╔╔╔╔╔╗║╗  \\n\"\n        unicode\"  ╝║╨╨╨╨║╚  \\n\",\n        unicode\"   ╔╔═╔═╔   \\n\"\n        unicode\"   ╔╩╔╩╔╝   \\n\"\n        unicode\"   ┌────┐   \\n\",\n        unicode\"            \\n\"\n        unicode\"     ///    \\n\"\n        unicode\"   ┌────┐   \\n\",\n        unicode\"     ╔╗╔╗   \\n\"\n        unicode\"    ╔╗╔╗╝   \\n\"\n        unicode\"   ┌╔╝╔╝┐   \\n\",\n        unicode\"     ╔╔╔╔╝  \\n\"\n        unicode\"    ╔╝╔╝    \\n\"\n        unicode\"   ┌╨╨╨─┐   \\n\",\n        unicode\"       ╔╗   \\n\"\n        unicode\"    ╔╔╔╗╝   \\n\"\n        unicode\"   ┌╚╚╝╝┐   \\n\",\n        unicode\"   ╔════╗   \\n\"\n        unicode\"  ╔╚╚╚╝╝╝╗  \\n\"\n        unicode\"  ╟┌────┐╢  \\n\",\n        unicode\"    ╔═╗     \\n\"\n        unicode\"    ╚╚╚╗    \\n\"\n        unicode\"   ┌────┐   \\n\",\n        unicode\"            \\n\"\n        unicode\"            \\n\"\n        unicode\"   ┌╨╨╨╨┐   \\n\",\n        unicode\"            \\n\"\n        unicode\"    ⌂⌂⌂⌂    \\n\"\n        unicode\"   ┌────┐   \\n\",\n        unicode\"   ┌────┐   \\n\"\n        unicode\"   │   /└┐  \\n\"\n        unicode\"   ├────┐/  \\n\",\n        unicode\"            \\n\"\n        unicode\"   ((((((   \\n\"\n        unicode\"   ┌────┐   \\n\",\n        unicode\"   ┌┌┌┌┌┐   \\n\"\n        unicode\"   ├┘┘┘┘┘   \\n\"\n        unicode\"   ┌────┐   \\n\",\n        unicode\"   «°┐      \\n\"\n        unicode\"    │╪╕     \\n\"\n        unicode\"   ┌└┼──┐   \\n\",\n        unicode\"  <° °>   § \\n\"\n        unicode\"   \\\\'/   /  \\n\"\n        unicode\"   {())}}   \\n\",\n        unicode\"   ██████   \\n\"\n        unicode\"  ██ ██ ██  \\n\"\n        unicode\" █ ██████ █ \\n\",\n        unicode\"    ████    \\n\"\n        unicode\"   ██◙◙██   \\n\"\n        unicode\"   ┌─▼▼─┐   \\n\",\n        unicode\"   ╓╖  ╓╖   \\n\"\n        unicode\"  °╜╚╗╔╝╙°  \\n\"\n        unicode\"   ┌─╨╨─┐   \\n\",\n        unicode\"   ± ±± ±   \\n\"\n        unicode\"   ◙◙◙◙◙◙   \\n\"\n        unicode\"   ┌────┐   \\n\",\n        unicode\"  ♫     ♪   \\n\"\n        unicode\"    ♪     ♫ \\n\"\n        unicode\" ♪ ┌────┐   \\n\",\n        unicode\"    /≡≡\\\\    \\n\"\n        unicode\"   /≡≡≡≡\\\\   \\n\"\n        unicode\"  /┌────┐\\\\  \\n\",\n        unicode\"            \\n\"\n        unicode\"   ♣♥♦♠♣♥   \\n\"\n        unicode\"   ┌────┐   \\n\",\n        unicode\"     [⌂]    \\n\"\n        unicode\"      │     \\n\"\n        unicode\"   ┌────┐   \\n\",\n        unicode\"  /\\\\/\\\\/\\\\/\\\\  \\n\"\n        unicode\"  \\\\\\\\/\\\\/\\\\//  \\n\"\n        unicode\"   ┌────┐   \\n\",\n        unicode\"    ↑↑↓↓    \\n\"\n        unicode\"   ←→←→AB   \\n\"\n        unicode\"   ┌────┐   \\n\",\n        unicode\"    ┌─┬┐    \\n\"\n        unicode\"   ┌┘┌┘└┐   \\n\"\n        unicode\"   ├─┴──┤   \\n\",\n        unicode\"    ☼  ☼    \\n\"\n        unicode\"     \\\\/     \\n\"\n        unicode\"   ┌────┐   \\n\"\n      ];\n    uint256 topId = rand % TOP_COUNT;\n    return tops[topId];\n  }\n\n  function _chooseEyes(uint256 rand) internal pure returns (string memory) {\n    string[EYE_COUNT] memory leftEyes =\n      [\n        unicode\"◕\",\n        unicode\"*\",\n        unicode\"♥\",\n        unicode\"X\",\n        unicode\"⊙\",\n        unicode\"˘\",\n        unicode\"α\",\n        unicode\"◉\",\n        unicode\"☻\",\n        unicode\"¬\",\n        unicode\"^\",\n        unicode\"═\",\n        unicode\"┼\",\n        unicode\"┬\",\n        unicode\"■\",\n        unicode\"─\",\n        unicode\"û\",\n        unicode\"╜\",\n        unicode\"δ\",\n        unicode\"│\",\n        unicode\"┐\",\n        unicode\"┌\",\n        unicode\"┌\",\n        unicode\"╤\",\n        unicode\"/\",\n        unicode\"\\\\\",\n        unicode\"/\",\n        unicode\"\\\\\",\n        unicode\"╦\",\n        unicode\"♥\",\n        unicode\"♠\",\n        unicode\"♦\",\n        unicode\"╝\",\n        unicode\"◄\",\n        unicode\"►\",\n        unicode\"◄\",\n        unicode\"►\",\n        unicode\"I\",\n        unicode\"╚\",\n        unicode\"╔\",\n        unicode\"╙\",\n        unicode\"╜\",\n        unicode\"╓\",\n        unicode\"╥\",\n        unicode\"$\",\n        unicode\"○\",\n        unicode\"N\",\n        unicode\"x\"\n      ];\n\n    string[EYE_COUNT] memory rightEyes =\n      [\n        unicode\"◕\",\n        unicode\"*\",\n        unicode\"♥\",\n        unicode\"X\",\n        unicode\"⊙\",\n        unicode\"˘\",\n        unicode\"α\",\n        unicode\"◉\",\n        unicode\"☻\",\n        unicode\"¬\",\n        unicode\"^\",\n        unicode\"═\",\n        unicode\"┼\",\n        unicode\"┬\",\n        unicode\"■\",\n        unicode\"─\",\n        unicode\"û\",\n        unicode\"╜\",\n        unicode\"δ\",\n        unicode\"│\",\n        unicode\"┐\",\n        unicode\"┐\",\n        unicode\"┌\",\n        unicode\"╤\",\n        unicode\"\\\\\",\n        unicode\"/\",\n        unicode\"/\",\n        unicode\"\\\\\",\n        unicode\"╦\",\n        unicode\"♠\",\n        unicode\"♣\",\n        unicode\"♦\",\n        unicode\"╝\",\n        unicode\"►\",\n        unicode\"◄\",\n        unicode\"◄\",\n        unicode\"◄\",\n        unicode\"I\",\n        unicode\"╚\",\n        unicode\"╗\",\n        unicode\"╜\",\n        unicode\"╜\",\n        unicode\"╓\",\n        unicode\"╥\",\n        unicode\"$\",\n        unicode\"○\",\n        unicode\"N\",\n        unicode\"x\"\n      ];\n    uint256 eyeId = rand % EYE_COUNT;\n\n    string memory leftEye = leftEyes[eyeId];\n    string memory rightEye = rightEyes[eyeId];\n    string memory nose = _chooseNose(rand);\n\n    string memory forehead = unicode\"   │    ├┐  \\n\";\n    string memory leftFace = unicode\"   │\";\n    string memory rightFace = unicode\" └│  \\n\";\n\n    return\n      string(\n        abi.encodePacked(\n          forehead,\n          leftFace,\n          leftEye,\n          \" \",\n          rightEye,\n          rightFace,\n          nose\n        )\n      );\n  }\n\n  function _chooseMouth(uint256 rand) internal pure returns (string memory) {\n    string[MOUTH_COUNT] memory mouths =\n      [\n        unicode\"   │    │   \\n\"\n        unicode\"   │──  │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │δ   │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │─┬  │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │(─) │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │[─] │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │<─> │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │╙─  │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │─╜  │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │└─┘ │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │┌─┐ │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │╓─  │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │─╖  │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │┼─┼ │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │──┼ │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │«─» │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │──  │   \\n\",\n        unicode\" ∙ │    │   \\n\"\n        unicode\" ∙───   │   \\n\",\n        unicode\" ∙ │    │   \\n\"\n        unicode\" ∙───)  │   \\n\",\n        unicode\" ∙ │    │   \\n\"\n        unicode\" ∙───]  │   \\n\",\n        unicode\"   │⌐¬  │   \\n\"\n        unicode\" √────  │   \\n\",\n        unicode\"   │╓╖  │   \\n\"\n        unicode\"   │──  │   \\n\",\n        unicode\"   │~~  │   \\n\"\n        unicode\"   │/\\\\  │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │══  │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │▼▼  │   \\n\",\n        unicode\"   │⌐¬  │   \\n\"\n        unicode\"   │O   │   \\n\",\n        unicode\"   │    │   \\n\"\n        unicode\"   │O   │   \\n\",\n        unicode\" ∙ │⌐¬  │   \\n\"\n        unicode\" ∙───   │   \\n\",\n        unicode\" ∙ │⌐¬  │   \\n\"\n        unicode\" ∙───)  │   \\n\",\n        unicode\" ∙ │⌐¬  │   \\n\"\n        unicode\" ∙───]  │   \\n\",\n        unicode\"   │⌐¬  │   \\n\"\n        unicode\"   │──  │   \\n\",\n        unicode\"   │⌐-¬ │   \\n\"\n        unicode\"   │    │   \\n\",\n        unicode\"   │┌-┐ │   \\n\"\n        unicode\"   ││ │ │   \\n\"\n      ];\n\n    uint256 mouthId = rand % MOUTH_COUNT;\n\n    return mouths[mouthId];\n  }\n\n  function _chooseNose(uint256 rand) internal pure returns (string memory) {\n    string[NOSE_COUNT] memory noses =\n      [\n        unicode\"└\",\n        unicode\"╘\",\n        unicode\"<\",\n        unicode\"└\",\n        unicode\"┌\",\n        unicode\"^\",\n        unicode\"└\",\n        unicode\"┼\",\n        unicode\"Γ\"\n      ];\n\n    uint256 noseId = rand % NOSE_COUNT;\n    string memory nose = noses[noseId];\n    return string(abi.encodePacked(unicode\"   │ \", nose, unicode\"  └┘  \\n\"));\n  }\n}\n"
    },
    "/Users/kyle/workspace/asciipunks/contracts/AsciiPunks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"./AsciiPunkFactory.sol\";\nimport \"./ERC721Metadata.sol\";\nimport \"./PaymentSplitter.sol\";\n\ncontract AsciiPunks is ERC721Metadata, PaymentSplitter {\n  using Address for address;\n  using Strings for uint256;\n\n  // EVENTS\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 indexed tokenId\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed approved,\n    uint256 indexed tokenId\n  );\n\n  event ApprovalForAll(\n    address indexed owner,\n    address indexed operator,\n    bool approved\n  );\n\n  event Generated(uint256 indexed index, address indexed a, string value);\n\n  mapping(uint256 => uint256) internal idToSeed;\n  mapping(uint256 => uint256) internal seedToId;\n  mapping(uint256 => address) internal idToOwner;\n  mapping(address => uint256[]) internal ownerToIds;\n  mapping(uint256 => uint256) internal idToOwnerIndex;\n  mapping(address => mapping(address => bool)) internal ownerToOperators;\n  mapping(uint256 => address) internal idToApproval;\n  uint256 internal numTokens = 0;\n  uint256 public constant TOKEN_LIMIT = 2048;\n  bool public hasSaleStarted = false;\n\n  bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n  bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n  modifier validNFToken(uint256 tokenId) {\n    require(\n      idToOwner[tokenId] != address(0),\n      \"ERC721: query for nonexistent token\"\n    );\n    _;\n  }\n\n  modifier canOperate(uint256 tokenId) {\n    address owner = idToOwner[tokenId];\n\n    require(\n      owner == _msgSender() || ownerToOperators[owner][_msgSender()],\n      \"ERC721: approve caller is not owner nor approved for all\"\n    );\n    _;\n  }\n\n  modifier canTransfer(uint256 tokenId) {\n    address tokenOwner = idToOwner[tokenId];\n\n    require(\n      tokenOwner == _msgSender() ||\n        idToApproval[tokenId] == _msgSender() ||\n        ownerToOperators[tokenOwner][_msgSender()],\n      \"ERC721: transfer caller is not owner nor approved\"\n    );\n    _;\n  }\n\n  constructor() {\n    _registerInterface(_INTERFACE_ID_ERC721);\n    _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n  }\n\n  function createPunk(uint256 seed) external payable returns (string memory) {\n    return _mint(_msgSender(), seed);\n  }\n\n  function calculatePrice() internal view returns (uint256) {\n    uint256 price;\n    if (numTokens < 256) {\n      price = 50000000000000000;\n    } else if (numTokens >= 256 && numTokens < 512) {\n      price = 100000000000000000;\n    } else if (numTokens >= 512 && numTokens < 1024) {\n      price = 200000000000000000;\n    } else if (numTokens >= 1024 && numTokens < 1536) {\n      price = 300000000000000000;\n    } else {\n      price = 400000000000000000;\n    }\n    return price;\n  }\n\n  function _mint(address to, uint256 _seed) internal returns (string memory) {\n    require(hasSaleStarted == true, \"Sale hasn't started\");\n    require(to != address(0), \"ERC721: mint to the zero address\");\n    require(\n      numTokens < TOKEN_LIMIT,\n      \"ERC721: maximum number of tokens already minted\"\n    );\n    require(msg.value >= calculatePrice(), \"ERC721: insufficient ether\");\n\n    uint256 seed = uint256(\n      keccak256(abi.encodePacked(_seed, block.timestamp, msg.sender, numTokens))\n    );\n\n    require(seedToId[seed] == 0, \"ERC721: seed already used\");\n\n    uint256 id = numTokens + 1;\n\n    idToSeed[id] = seed;\n    seedToId[seed] = id;\n\n    string memory punk = AsciiPunkFactory.draw(idToSeed[id]);\n    emit Generated(id, to, punk);\n\n    numTokens = numTokens + 1;\n    _registerToken(to, id);\n\n    emit Transfer(address(0), to, id);\n\n    return punk;\n  }\n\n  function _registerToken(address to, uint256 tokenId) internal {\n    require(idToOwner[tokenId] == address(0));\n    idToOwner[tokenId] = to;\n\n    ownerToIds[to].push(tokenId);\n    uint256 length = ownerToIds[to].length;\n    idToOwnerIndex[tokenId] = length - 1;\n  }\n\n  function draw(uint256 tokenId)\n    external\n    view\n    validNFToken(tokenId)\n    returns (string memory)\n  {\n    string memory uri = AsciiPunkFactory.draw(idToSeed[tokenId]);\n    return uri;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return numTokens;\n  }\n\n  function tokenByIndex(uint256 index) public view returns (uint256) {\n    require(index < numTokens, \"ERC721Enumerable: global index out of bounds\");\n    return index;\n  }\n\n  function tokenOfOwnerByIndex(address owner, uint256 _index)\n    external\n    view\n    returns (uint256)\n  {\n    require(\n      _index < ownerToIds[owner].length,\n      \"ERC721Enumerable: owner index out of bounds\"\n    );\n    return ownerToIds[owner][_index];\n  }\n\n  function balanceOf(address owner) external view returns (uint256) {\n    require(owner != address(0), \"ERC721: balance query for the zero address\");\n    return ownerToIds[owner].length;\n  }\n\n  function ownerOf(uint256 tokenId) external view returns (address) {\n    return _ownerOf(tokenId);\n  }\n\n  function _ownerOf(uint256 tokenId)\n    internal\n    view\n    validNFToken(tokenId)\n    returns (address)\n  {\n    address owner = idToOwner[tokenId];\n    require(owner != address(0), \"ERC721: query for nonexistent token\");\n    return owner;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external validNFToken(tokenId) canTransfer(tokenId) {\n    address tokenOwner = idToOwner[tokenId];\n    require(tokenOwner == from, \"ERC721: transfer of token that is not own\");\n    require(to != address(0), \"ERC721: transfer to the zero address\");\n    _transfer(to, tokenId);\n  }\n\n  function _transfer(address to, uint256 tokenId) internal {\n    address from = idToOwner[tokenId];\n    _clearApproval(tokenId);\n    emit Approval(from, to, tokenId);\n\n    _removeNFToken(from, tokenId);\n    _registerToken(to, tokenId);\n\n    emit Transfer(from, to, tokenId);\n  }\n\n  function _removeNFToken(address from, uint256 tokenId) internal {\n    require(idToOwner[tokenId] == from);\n    delete idToOwner[tokenId];\n\n    uint256 tokenToRemoveIndex = idToOwnerIndex[tokenId];\n    uint256 lastTokenIndex = ownerToIds[from].length - 1;\n\n    if (lastTokenIndex != tokenToRemoveIndex) {\n      uint256 lastToken = ownerToIds[from][lastTokenIndex];\n      ownerToIds[from][tokenToRemoveIndex] = lastToken;\n      idToOwnerIndex[lastToken] = tokenToRemoveIndex;\n    }\n\n    ownerToIds[from].pop();\n  }\n\n  function approve(address approved, uint256 tokenId)\n    external\n    validNFToken(tokenId)\n    canOperate(tokenId)\n  {\n    address owner = idToOwner[tokenId];\n    require(approved != owner, \"ERC721: approval to current owner\");\n    idToApproval[tokenId] = approved;\n    emit Approval(owner, approved, tokenId);\n  }\n\n  function _clearApproval(uint256 tokenId) private {\n    if (idToApproval[tokenId] != address(0)) {\n      delete idToApproval[tokenId];\n    }\n  }\n\n  function getApproved(uint256 tokenId)\n    external\n    view\n    validNFToken(tokenId)\n    returns (address)\n  {\n    return idToApproval[tokenId];\n  }\n\n  function setApprovalForAll(address operator, bool approved) external {\n    require(operator != _msgSender(), \"ERC721: approve to caller\");\n    ownerToOperators[_msgSender()][operator] = approved;\n    emit ApprovalForAll(_msgSender(), operator, approved);\n  }\n\n  function isApprovedForAll(address owner, address operator)\n    external\n    view\n    returns (bool)\n  {\n    return ownerToOperators[owner][operator];\n  }\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes calldata data\n  ) external {\n    _safeTransferFrom(from, to, tokenId, data);\n  }\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external {\n    _safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  function _safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory data\n  ) private validNFToken(tokenId) canTransfer(tokenId) {\n    address tokenOwner = idToOwner[tokenId];\n    require(tokenOwner == from, \"ERC721: transfer of token that is not own\");\n    require(to != address(0), \"ERC721: transfer to the zero address\");\n\n    _transfer(to, tokenId);\n    require(\n      _checkOnERC721Received(from, to, tokenId, data),\n      \"ERC721: transfer to non ERC721Receiver implementer\"\n    );\n  }\n\n  function tokenURI(uint256 tokenId)\n    external\n    view\n    validNFToken(tokenId)\n    returns (string memory)\n  {\n    string memory uri = _baseURI();\n    return\n      bytes(uri).length > 0\n        ? string(abi.encodePacked(uri, tokenId.toString()))\n        : \"\";\n  }\n\n  function startSale() public onlyOwner {\n    hasSaleStarted = true;\n  }\n\n  function pauseSale() public onlyOwner {\n    hasSaleStarted = false;\n  }\n\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory data\n  ) private returns (bool) {\n    if (to.isContract()) {\n      try\n        IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data)\n      returns (bytes4 retval) {\n        return retval == IERC721Receiver(to).onERC721Received.selector;\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n        } else {\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    } else {\n      return true;\n    }\n  }\n}\n"
    },
    "/Users/kyle/workspace/asciipunks/contracts/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract ERC165 {\n  mapping(bytes4 => bool) private _supportedInterfaces;\n\n  bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n  constructor() {\n    _registerInterface(_INTERFACE_ID_ERC165);\n  }\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    return _supportedInterfaces[interfaceId];\n  }\n\n  function _registerInterface(bytes4 interfaceId) internal {\n    require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n    _supportedInterfaces[interfaceId] = true;\n  }\n}\n"
    },
    "/Users/kyle/workspace/asciipunks/contracts/ERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./ERC165.sol\";\n\ncontract ERC721Metadata is Ownable, ERC165 {\n  bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n  string private _baseTokenURI;\n  string private _NFTName = \"AsciiPunks\";\n  string private _NFTSymbol = \"ASC\";\n\n  constructor() {\n    _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    _baseTokenURI = \"https://api.asciipunks.com/punks/\";\n  }\n\n  function name() external view returns (string memory) {\n    return _NFTName;\n  }\n\n  function symbol() external view returns (string memory) {\n    return _NFTSymbol;\n  }\n\n  function setBaseURI(string calldata newBaseTokenURI) public onlyOwner {\n    _baseTokenURI = newBaseTokenURI;\n  }\n\n  function baseURI() public view returns (string memory) {\n    return _baseURI();\n  }\n\n  function _baseURI() internal view returns (string memory) {\n    return _baseTokenURI;\n  }\n}\n"
    },
    "/Users/kyle/workspace/asciipunks/contracts/PaymentSplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title PaymentSplitter\n * @dev This contract allows to split Ether payments among a group of accounts. The sender does not need to be aware\n * that the Ether will be split in this way, since it is handled transparently by the contract.\n *\n * The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each\n * account to a number of shares. Of all the Ether that this contract receives, each account will then be able to claim\n * an amount proportional to the percentage of total shares they were assigned.\n *\n * `PaymentSplitter` follows a _pull payment_ model. This means that payments are not automatically forwarded to the\n * accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the {release}\n * function.\n */\ncontract PaymentSplitter is Context {\n  event PayeeAdded(address account, uint256 shares);\n  event PaymentReleased(address to, uint256 amount);\n  event PaymentReceived(address from, uint256 amount);\n\n  uint256 private _totalShares;\n  uint256 private _totalReleased;\n\n  mapping(address => uint256) private _shares;\n  mapping(address => uint256) private _released;\n  address[] private _payees;\n\n  /**\n   * @dev Creates an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at\n   * the matching position in the `shares` array.\n   *\n   * All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\n   * duplicates in `payees`.\n   */\n  constructor() {\n    address[2] memory initialPayees =\n      [\n        address(0x9386efb02a55A1092dC19f0E68a9816DDaAbDb5b),\n        address(0xF2353AD0930B9F7cf16b4b8300B843349581E817)\n      ];\n    uint256[2] memory initialShares = [uint256(7), uint256(3)];\n\n    for (uint256 i = 0; i < initialPayees.length; i++) {\n      _addPayee(initialPayees[i], initialShares[i]);\n    }\n  }\n\n  /**\n   * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully\n   * reliable: it's possible for a contract to receive Ether without triggering this function. This only affects the\n   * reliability of the events, and not the actual splitting of Ether.\n   *\n   * To learn more about this see the Solidity documentation for\n   * https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function[fallback\n   * functions].\n   */\n  receive() external payable {\n    emit PaymentReceived(_msgSender(), msg.value);\n  }\n\n  /**\n   * @dev Getter for the total shares held by payees.\n   */\n  function totalShares() public view returns (uint256) {\n    return _totalShares;\n  }\n\n  /**\n   * @dev Getter for the total amount of Ether already released.\n   */\n  function totalReleased() public view returns (uint256) {\n    return _totalReleased;\n  }\n\n  /**\n   * @dev Getter for the amount of shares held by an account.\n   */\n  function shares(address account) public view returns (uint256) {\n    return _shares[account];\n  }\n\n  /**\n   * @dev Getter for the amount of Ether already released to a payee.\n   */\n  function released(address account) public view returns (uint256) {\n    return _released[account];\n  }\n\n  /**\n   * @dev Getter for the address of the payee number `index`.\n   */\n  function payee(uint256 index) public view returns (address) {\n    return _payees[index];\n  }\n\n  /**\n   * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the\n   * total shares and their previous withdrawals.\n   */\n  function release(address payable account) public virtual {\n    require(_shares[account] > 0, \"PaymentSplitter: account has no shares\");\n\n    uint256 totalReceived = address(this).balance + _totalReleased;\n    uint256 payment =\n      (totalReceived * _shares[account]) / _totalShares - _released[account];\n\n    require(payment != 0, \"PaymentSplitter: account is not due payment\");\n\n    _released[account] = _released[account] + payment;\n    _totalReleased = _totalReleased + payment;\n\n    Address.sendValue(account, payment);\n    emit PaymentReleased(account, payment);\n  }\n\n  /**\n   * @dev Add a new payee to the contract.\n   * @param account The address of the payee to add.\n   * @param shares_ The number of shares owned by the payee.\n   */\n  function _addPayee(address account, uint256 shares_) private {\n    require(\n      account != address(0),\n      \"PaymentSplitter: account is the zero address\"\n    );\n    require(shares_ > 0, \"PaymentSplitter: shares are 0\");\n    require(\n      _shares[account] == 0,\n      \"PaymentSplitter: account already has shares\"\n    );\n\n    _payees.push(account);\n    _shares[account] = shares_;\n    _totalShares = _totalShares + shares_;\n    emit PayeeAdded(account, shares_);\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "istanbul",
    "libraries": {
      "/Users/kyle/workspace/asciipunks/contracts/AsciiPunkFactory.sol": {
        "AsciiPunkFactory": "0x3c24A5DF4F69199962b163CB5762be1E8367CbEb"
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}