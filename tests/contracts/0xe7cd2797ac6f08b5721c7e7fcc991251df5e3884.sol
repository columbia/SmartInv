{{
  "language": "Solidity",
  "sources": {
    "contracts/Boostable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@prps/solidity/contracts/EIP712Boostable.sol\";\nimport \"./DubiexLib.sol\";\n\n/**\n * @dev Dubiex Boostable primitives following the EIP712 standard\n */\nabstract contract Boostable is EIP712Boostable {\n    bytes32 private constant BOOSTED_MAKE_ORDER_TYPEHASH = keccak256(\n        \"BoostedMakeOrder(MakeOrderInput input,address maker,BoosterFuel fuel,BoosterPayload boosterPayload)BoosterFuel(uint96 dubi,uint96 unlockedPrps,uint96 lockedPrps,uint96 intrinsicFuel)BoosterPayload(address booster,uint64 timestamp,uint64 nonce,bool isLegacySignature)MakeOrderInput(uint96 makerValue,uint96 takerValue,OrderPair pair,uint32 orderId,uint32 ancestorOrderId,uint128 updatedRatioWei)OrderPair(address makerContractAddress,address takerContractAddress,uint8 makerCurrencyType,uint8 takerCurrencyType)\"\n    );\n\n    bytes32 private constant BOOSTED_TAKE_ORDER_TYPEHASH = keccak256(\n        \"BoostedTakeOrder(TakeOrderInput input,address taker,BoosterFuel fuel,BoosterPayload boosterPayload)BoosterFuel(uint96 dubi,uint96 unlockedPrps,uint96 lockedPrps,uint96 intrinsicFuel)BoosterPayload(address booster,uint64 timestamp,uint64 nonce,bool isLegacySignature)TakeOrderInput(uint32 id,address maker,uint96 takerValue,uint256 maxTakerMakerRatio)\"\n    );\n\n    bytes32 private constant BOOSTED_CANCEL_ORDER_TYPEHASH = keccak256(\n        \"BoostedCancelOrder(CancelOrderInput input,BoosterFuel fuel,BoosterPayload boosterPayload)BoosterFuel(uint96 dubi,uint96 unlockedPrps,uint96 lockedPrps,uint96 intrinsicFuel)BoosterPayload(address booster,uint64 timestamp,uint64 nonce,bool isLegacySignature)CancelOrderInput(uint32 id,address maker)\"\n    );\n\n    bytes32 private constant MAKE_ORDER_INPUT_TYPEHASH = keccak256(\n        \"MakeOrderInput(uint96 makerValue,uint96 takerValue,OrderPair pair,uint32 orderId,uint32 ancestorOrderId,uint128 updatedRatioWei)OrderPair(address makerContractAddress,address takerContractAddress,uint8 makerCurrencyType,uint8 takerCurrencyType)\"\n    );\n\n    bytes32 private constant TAKE_ORDER_INPUT_TYPEHASH = keccak256(\n        \"TakeOrderInput(uint32 id,address maker,uint96 takerValue,uint256 maxTakerMakerRatio)\"\n    );\n\n    bytes32 private constant CANCEL_ORDER_INPUT_TYPEHASH = keccak256(\n        \"CancelOrderInput(uint32 id,address maker)\"\n    );\n\n    bytes32 private constant ORDER_PAIR_TYPEHASH = keccak256(\n        \"OrderPair(address makerContractAddress,address takerContractAddress,uint8 makerCurrencyType,uint8 takerCurrencyType)\"\n    );\n\n    constructor(address optIn)\n        public\n        EIP712Boostable(\n            optIn,\n            keccak256(\n                abi.encode(\n                    EIP712_DOMAIN_TYPEHASH,\n                    keccak256(\"Dubiex\"),\n                    keccak256(\"1\"),\n                    _getChainId(),\n                    address(this)\n                )\n            )\n        )\n    {}\n\n    /**\n     * @dev A struct representing the payload of `boostedMakeOrder`.\n     */\n    struct BoostedMakeOrder {\n        DubiexLib.MakeOrderInput input;\n        address payable maker;\n        BoosterFuel fuel;\n        BoosterPayload boosterPayload;\n    }\n\n    /**\n     * @dev A struct representing the payload of `boostedTakeOrder`.\n     */\n    struct BoostedTakeOrder {\n        DubiexLib.TakeOrderInput input;\n        address payable taker;\n        BoosterFuel fuel;\n        BoosterPayload boosterPayload;\n    }\n\n    /**\n     * @dev A struct representing the payload of `boostedCancelOrder`.\n     */\n    struct BoostedCancelOrder {\n        DubiexLib.CancelOrderInput input;\n        BoosterFuel fuel;\n        BoosterPayload boosterPayload;\n    }\n\n    function hashBoostedMakeOrder(\n        BoostedMakeOrder memory boostedMakeOrder,\n        address booster\n    ) internal view returns (bytes32) {\n        return\n            BoostableLib.hashWithDomainSeparator(\n                _DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        BOOSTED_MAKE_ORDER_TYPEHASH,\n                        hashMakeOrderInput(boostedMakeOrder.input),\n                        boostedMakeOrder.maker,\n                        BoostableLib.hashBoosterFuel(boostedMakeOrder.fuel),\n                        BoostableLib.hashBoosterPayload(\n                            boostedMakeOrder.boosterPayload,\n                            booster\n                        )\n                    )\n                )\n            );\n    }\n\n    function hashBoostedTakeOrder(\n        BoostedTakeOrder memory boostedTakeOrder,\n        address booster\n    ) internal view returns (bytes32) {\n        return\n            BoostableLib.hashWithDomainSeparator(\n                _DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        BOOSTED_TAKE_ORDER_TYPEHASH,\n                        hashTakeOrderInput(boostedTakeOrder.input),\n                        boostedTakeOrder.taker,\n                        BoostableLib.hashBoosterFuel(boostedTakeOrder.fuel),\n                        BoostableLib.hashBoosterPayload(\n                            boostedTakeOrder.boosterPayload,\n                            booster\n                        )\n                    )\n                )\n            );\n    }\n\n    function hashBoostedCancelOrder(\n        BoostedCancelOrder memory boostedCancelOrder,\n        address booster\n    ) internal view returns (bytes32) {\n        return\n            BoostableLib.hashWithDomainSeparator(\n                _DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        BOOSTED_CANCEL_ORDER_TYPEHASH,\n                        hashCancelOrderInput(boostedCancelOrder.input),\n                        BoostableLib.hashBoosterFuel(boostedCancelOrder.fuel),\n                        BoostableLib.hashBoosterPayload(\n                            boostedCancelOrder.boosterPayload,\n                            booster\n                        )\n                    )\n                )\n            );\n    }\n\n    function hashMakeOrderInput(DubiexLib.MakeOrderInput memory input)\n        private\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    MAKE_ORDER_INPUT_TYPEHASH,\n                    input.makerValue,\n                    input.takerValue,\n                    hashOrderPair(input.pair),\n                    input.orderId,\n                    input.ancestorOrderId,\n                    input.updatedRatioWei\n                )\n            );\n    }\n\n    function hashOrderPair(DubiexLib.OrderPair memory pair)\n        private\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    ORDER_PAIR_TYPEHASH,\n                    pair.makerContractAddress,\n                    pair.takerContractAddress,\n                    pair.makerCurrencyType,\n                    pair.takerCurrencyType\n                )\n            );\n    }\n\n    function hashTakeOrderInput(DubiexLib.TakeOrderInput memory input)\n        private\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    TAKE_ORDER_INPUT_TYPEHASH,\n                    input.id,\n                    input.maker,\n                    input.takerValue,\n                    input.maxTakerMakerRatio\n                )\n            );\n    }\n\n    function hashCancelOrderInput(DubiexLib.CancelOrderInput memory input)\n        private\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(CANCEL_ORDER_INPUT_TYPEHASH, input.id, input.maker)\n            );\n    }\n}\n"
    },
    "@prps/solidity/contracts/EIP712Boostable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\nimport \"./IOptIn.sol\";\nimport \"./BoostableLib.sol\";\nimport \"./IBoostableERC20.sol\";\n\n/**\n * @dev Boostable base contract\n *\n * All deriving contracts are expected to implement EIP712 for the message signing.\n *\n */\nabstract contract EIP712Boostable {\n    using ECDSA for bytes32;\n\n    // solhint-disable-next-line var-name-mixedcase\n    IOptIn internal immutable _OPT_IN;\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n    );\n\n    bytes32 private constant BOOSTER_PAYLOAD_TYPEHASH = keccak256(\n        \"BoosterPayload(address booster,uint64 timestamp,uint64 nonce,bool isLegacySignature)\"\n    );\n\n    bytes32 internal constant BOOSTER_FUEL_TYPEHASH = keccak256(\n        \"BoosterFuel(uint96 dubi,uint96 unlockedPrps,uint96 lockedPrps,uint96 intrinsicFuel)\"\n    );\n\n    // The boost fuel is capped to 10 of the respective token that will be used for payment.\n    uint96 internal constant MAX_BOOSTER_FUEL = 10 ether;\n\n    // A magic booster permission prefix\n    bytes6 private constant MAGIC_BOOSTER_PERMISSION_PREFIX = \"BOOST-\";\n\n    constructor(address optIn, bytes32 domainSeparator) public {\n        _OPT_IN = IOptIn(optIn);\n        _DOMAIN_SEPARATOR = domainSeparator;\n    }\n\n    // A mapping of mappings to keep track of used nonces by address to\n    // protect against replays. Each 'Boostable' contract maintains it's own\n    // state for nonces.\n    mapping(address => uint64) private _nonces;\n\n    //---------------------------------------------------------------\n\n    function getNonce(address account) external virtual view returns (uint64) {\n        return _nonces[account];\n    }\n\n    function getOptInStatus(address account)\n        internal\n        view\n        returns (IOptIn.OptInStatus memory)\n    {\n        return _OPT_IN.getOptInStatus(account);\n    }\n\n    /**\n     * @dev Called by every 'boosted'-function to ensure that `msg.sender` (i.e. a booster) is\n     * allowed to perform the call for `from` (the origin) by verifying that `messageHash`\n     * has been signed by `from`. Additionally, `from` provides a nonce to prevent\n     * replays. Boosts cannot be verified out of order.\n     *\n     * @param from the address that the boost is made for\n     * @param messageHash the reconstructed message hash based on the function input\n     * @param payload the booster payload\n     * @param signature the signature of `from`\n     */\n    function verifyBoost(\n        address from,\n        bytes32 messageHash,\n        BoosterPayload memory payload,\n        Signature memory signature\n    ) internal {\n        uint64 currentNonce = _nonces[from];\n        require(currentNonce == payload.nonce - 1, \"AB-1\");\n\n        _nonces[from] = currentNonce + 1;\n\n        _verifyBoostWithoutNonce(from, messageHash, payload, signature);\n    }\n\n    /**\n     * @dev Verify a boost without verifying the nonce.\n     */\n    function _verifyBoostWithoutNonce(\n        address from,\n        bytes32 messageHash,\n        BoosterPayload memory payload,\n        Signature memory signature\n    ) internal view {\n        // The sender must be the booster specified in the payload\n        require(msg.sender == payload.booster, \"AB-2\");\n\n        (bool isOptedInToSender, uint256 optOutPeriod) = _OPT_IN.isOptedInBy(\n            msg.sender,\n            from\n        );\n\n        // `from` must be opted-in to booster\n        require(isOptedInToSender, \"AB-3\");\n\n        // The given timestamp must not be greater than `block.timestamp + 1 hour`\n        // and at most `optOutPeriod(booster)` seconds old.\n        uint64 _now = uint64(block.timestamp);\n        uint64 _optOutPeriod = uint64(optOutPeriod);\n\n        bool notTooFarInFuture = payload.timestamp <= _now + 1 hours;\n        bool belowMaxAge = true;\n\n        // Calculate the absolute difference. Because of the small tolerance, `payload.timestamp`\n        // may be greater than `_now`:\n        if (payload.timestamp <= _now) {\n            belowMaxAge = _now - payload.timestamp <= _optOutPeriod;\n        }\n\n        // Signature must not be expired\n        require(notTooFarInFuture && belowMaxAge, \"AB-4\");\n\n        // NOTE: Currently, hardware wallets (e.g. Ledger, Trezor) do not support EIP712 signing (specifically `signTypedData_v4`).\n        // However, a user can still sign the EIP712 hash with the caveat that it's signed using `personal_sign` which prepends\n        // the prefix '\"\\x19Ethereum Signed Message:\\n\" + len(message)'.\n        //\n        // To still support that, we add the prefix to the hash if `isLegacySignature` is true.\n        if (payload.isLegacySignature) {\n            messageHash = messageHash.toEthSignedMessageHash();\n        }\n\n        // Valid, if the recovered address from `messageHash` with the given `signature` matches `from`.\n\n        address signer = ecrecover(\n            messageHash,\n            signature.v,\n            signature.r,\n            signature.s\n        );\n\n        if (!payload.isLegacySignature && signer != from) {\n            // As a last resort we try anyway, in case the caller simply forgot the `isLegacySignature` flag.\n            signer = ecrecover(\n                messageHash.toEthSignedMessageHash(),\n                signature.v,\n                signature.r,\n                signature.s\n            );\n        }\n\n        require(from == signer, \"AB-5\");\n    }\n\n    /**\n     * @dev Returns the hash of `payload` using the provided booster (i.e. `msg.sender`).\n     */\n    function hashBoosterPayload(BoosterPayload memory payload, address booster)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    BOOSTER_PAYLOAD_TYPEHASH,\n                    booster,\n                    payload.timestamp,\n                    payload.nonce\n                )\n            );\n    }\n\n    function _getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"
    },
    "contracts/DubiexLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nlibrary DubiexLib {\n    enum CurrencyType {NULL, ETH, ERC20, BOOSTABLE_ERC20, ERC721}\n\n    // Enum is used to read only a specific part of the order pair from\n    // storage, since it is a bad idea to always perform 4 SLOADs.\n    enum OrderPairReadStrategy {SKIP, MAKER, TAKER, FULL}\n\n    struct OrderPair {\n        address makerContractAddress;\n        CurrencyType makerCurrencyType;\n        address takerContractAddress;\n        CurrencyType takerCurrencyType;\n    }\n\n    // To reduce the number of reads, the order pairs\n    // are stored packed and on read unpacked as required.\n    // Also see `OrderPair` and `OrderPairReadStrategy`.\n    struct PackedOrderPair {\n        // 20 bytes address + 1 byte currency type\n        uint168 makerPair;\n        // 20 bytes address + 1 byte currency type\n        uint168 takerPair;\n    }\n\n    struct PackedOrderBookItem {\n        // Serialized `UnpackedOrderBookItem`\n        uint256 packedData;\n        //\n        // Mostly zero\n        //\n        uint32 successorOrderId;\n        uint32 ancestorOrderId;\n    }\n\n    struct UnpackedOrderBookItem {\n        uint32 id;\n        uint96 makerValue;\n        uint96 takerValue;\n        uint32 orderPairAlias;\n        // The resolved pair based on the order pair alias\n        OrderPair pair;\n        OrderFlags flags;\n    }\n\n    // Struct that contains all unpacked data and the additional almost-always zero fields from\n    // the packed order bookt item - returned from `getOrder()` to be more user-friendly to consume.\n    struct PrettyOrderBookItem {\n        uint32 id;\n        uint96 makerValue;\n        uint96 takerValue;\n        uint32 orderPairAlias;\n        OrderPair pair;\n        OrderFlags flags;\n        uint32 successorOrderId;\n        uint32 ancestorOrderId;\n    }\n\n    struct OrderFlags {\n        bool isMakerERC721;\n        bool isTakerERC721;\n        bool isHidden;\n        bool hasSuccessor;\n    }\n\n    function packOrderBookItem(UnpackedOrderBookItem memory _unpacked)\n        internal\n        pure\n        returns (uint256)\n    {\n        // Bitpacking saves gas on read/write:\n\n        // 61287 gas\n        // struct Item1 {\n        //     uint256 word1;\n        //     uint256 word2;\n        // }\n\n        // // 62198 gas\n        // struct Item2 {\n        //     uint256 word1;\n        //     uint128 a;\n        //     uint128 b;\n        // }\n\n        // // 62374 gas\n        // struct Item3 {\n        //     uint256 word1;\n        //     uint64 a;\n        //     uint64 b;\n        //     uint64 c;\n        //     uint64 d;\n        // }\n\n        uint256 packedData;\n        uint256 offset;\n\n        // 1) Set first 32 bits to id\n        uint32 id = _unpacked.id;\n        packedData |= id;\n        offset += 32;\n\n        // 2) Set next 96 bits to maker value\n        uint96 makerValue = _unpacked.makerValue;\n        packedData |= uint256(makerValue) << offset;\n        offset += 96;\n\n        // 3) Set next 96 bits to taker value\n        uint96 takerValue = _unpacked.takerValue;\n        packedData |= uint256(takerValue) << offset;\n        offset += 96;\n\n        // 4) Set next 28 bits to order pair alias\n        // Since it is stored in a uint32 AND it with a bitmask where the first 28 bits are 1\n        uint32 orderPairAlias = _unpacked.orderPairAlias;\n        uint32 orderPairAliasMask = (1 << 28) - 1;\n        packedData |= uint256(orderPairAlias & orderPairAliasMask) << offset;\n        offset += 28;\n\n        // 5) Set remaining bits to flags\n        OrderFlags memory flags = _unpacked.flags;\n        if (flags.isMakerERC721) {\n            // Maker currency type is ERC721\n            packedData |= 1 << (offset + 0);\n        }\n\n        if (flags.isTakerERC721) {\n            // Taker currency type is ERC721\n            packedData |= 1 << (offset + 1);\n        }\n\n        if (flags.isHidden) {\n            // Order is hidden\n            packedData |= 1 << (offset + 2);\n        }\n\n        if (flags.hasSuccessor) {\n            // Order has a successor\n            packedData |= 1 << (offset + 3);\n        }\n\n        offset += 4;\n\n        assert(offset == 256);\n        return packedData;\n    }\n\n    function unpackOrderBookItem(uint256 packedData)\n        internal\n        pure\n        returns (UnpackedOrderBookItem memory)\n    {\n        UnpackedOrderBookItem memory _unpacked;\n        uint256 offset;\n\n        // 1) Read id from the first 32 bits\n        _unpacked.id = uint32(packedData >> offset);\n        offset += 32;\n\n        // 2) Read maker value from next 96 bits\n        _unpacked.makerValue = uint96(packedData >> offset);\n        offset += 96;\n\n        // 3) Read taker value from next 96 bits\n        _unpacked.takerValue = uint96(packedData >> offset);\n        offset += 96;\n\n        // 4) Read order pair alias from next 28 bits\n        uint32 orderPairAlias = uint32(packedData >> offset);\n        uint32 orderPairAliasMask = (1 << 28) - 1;\n        _unpacked.orderPairAlias = orderPairAlias & orderPairAliasMask;\n        offset += 28;\n\n        // NOTE: the caller still needs to read the order pair from storage\n        // with the unpacked alias\n\n        // 5) Read order flags from remaining bits\n        OrderFlags memory flags = _unpacked.flags;\n\n        flags.isMakerERC721 = (packedData >> (offset + 0)) & 1 == 1;\n        flags.isTakerERC721 = (packedData >> (offset + 1)) & 1 == 1;\n        flags.isHidden = (packedData >> (offset + 2)) & 1 == 1;\n        flags.hasSuccessor = (packedData >> (offset + 3)) & 1 == 1;\n\n        offset += 4;\n\n        assert(offset == 256);\n\n        return _unpacked;\n    }\n\n    function packOrderPair(OrderPair memory unpacked)\n        internal\n        pure\n        returns (PackedOrderPair memory)\n    {\n        uint168 packedMaker = uint160(unpacked.makerContractAddress);\n        packedMaker |= uint168(unpacked.makerCurrencyType) << 160;\n\n        uint168 packedTaker = uint160(unpacked.takerContractAddress);\n        packedTaker |= uint168(unpacked.takerCurrencyType) << 160;\n\n        return PackedOrderPair(packedMaker, packedTaker);\n    }\n\n    function unpackOrderPairAddressType(uint168 packed)\n        internal\n        pure\n        returns (address, CurrencyType)\n    {\n        // The first 20 bytes of order pair are used for the maker address\n        address unpackedAddress = address(packed);\n        // The next 8 bits for the maker currency type\n        CurrencyType unpackedCurrencyType = CurrencyType(uint8(packed >> 160));\n\n        return (unpackedAddress, unpackedCurrencyType);\n    }\n\n    /**\n     * @dev A struct representing the payload of `makeOrder`.\n     */\n    struct MakeOrderInput {\n        uint96 makerValue;\n        uint96 takerValue;\n        OrderPair pair;\n        // An id of an existing order can be optionally provided to\n        // update the makerValue-takerValue ratio with a single call as opposed to cancel-then-make-new-order.\n        uint32 orderId;\n        // If specified, this order becomes a successor for the ancestor order and will be hidden until\n        // the ancestor has been filled.\n        uint32 ancestorOrderId;\n        // When calling make order using an existing order id, the `updatedRatio` will be applied on\n        // the `makerValue` to calculate the new `takerValue`.\n        uint128 updatedRatioWei;\n    }\n\n    /**\n     * @dev A struct representing the payload of `takeOrder`.\n     */\n    struct TakeOrderInput {\n        uint32 id;\n        address payable maker;\n        uint96 takerValue;\n        // The expected max taker maker ratio of the order to take.\n        uint256 maxTakerMakerRatio;\n    }\n\n    /**\n     * @dev A struct representing the payload of `cancelOrder`.\n     */\n    struct CancelOrderInput {\n        uint32 id;\n        address payable maker;\n    }\n}\n"
    },
    "@openzeppelin/contracts/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n\n        if (v != 27 && v != 28) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "@prps/solidity/contracts/IOptIn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nstruct Signature {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n}\n\ninterface IOptIn {\n    struct OptInStatus {\n        bool isOptedIn;\n        bool permaBoostActive;\n        address optedInTo;\n        uint32 optOutPeriod;\n    }\n\n    function getOptInStatusPair(address accountA, address accountB)\n        external\n        view\n        returns (OptInStatus memory, OptInStatus memory);\n\n    function getOptInStatus(address account)\n        external\n        view\n        returns (OptInStatus memory);\n\n    function isOptedInBy(address _sender, address _account)\n        external\n        view\n        returns (bool, uint256);\n}\n"
    },
    "@prps/solidity/contracts/BoostableLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nstruct BoosterFuel {\n    uint96 dubi;\n    uint96 unlockedPrps;\n    uint96 lockedPrps;\n    uint96 intrinsicFuel;\n}\n\nstruct BoosterPayload {\n    address booster;\n    uint64 timestamp;\n    uint64 nonce;\n    // Fallback for 'personal_sign' when e.g. using hardware wallets that don't support\n    // EIP712 signing (yet).\n    bool isLegacySignature;\n}\n\n// Library for Boostable hash functions that are completely inlined.\nlibrary BoostableLib {\n    bytes32 private constant BOOSTER_PAYLOAD_TYPEHASH = keccak256(\n        \"BoosterPayload(address booster,uint64 timestamp,uint64 nonce,bool isLegacySignature)\"\n    );\n\n    bytes32 internal constant BOOSTER_FUEL_TYPEHASH = keccak256(\n        \"BoosterFuel(uint96 dubi,uint96 unlockedPrps,uint96 lockedPrps,uint96 intrinsicFuel)\"\n    );\n\n    /**\n     * @dev Returns the hash of the packed DOMAIN_SEPARATOR and `messageHash` and is used for verifying\n     * a signature.\n     */\n    function hashWithDomainSeparator(\n        bytes32 domainSeparator,\n        bytes32 messageHash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", domainSeparator, messageHash)\n            );\n    }\n\n    /**\n     * @dev Returns the hash of `payload` using the provided booster (i.e. `msg.sender`).\n     */\n    function hashBoosterPayload(BoosterPayload memory payload, address booster)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    BOOSTER_PAYLOAD_TYPEHASH,\n                    booster,\n                    payload.timestamp,\n                    payload.nonce,\n                    payload.isLegacySignature\n                )\n            );\n    }\n\n    function hashBoosterFuel(BoosterFuel memory fuel)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    BOOSTER_FUEL_TYPEHASH,\n                    fuel.dubi,\n                    fuel.unlockedPrps,\n                    fuel.lockedPrps,\n                    fuel.intrinsicFuel\n                )\n            );\n    }\n\n    /**\n     * @dev Returns the tag found in the given `boosterMessage`.\n     */\n    function _readBoosterTag(bytes memory boosterMessage)\n        internal\n        pure\n        returns (uint8)\n    {\n        // The tag is either the 32th byte or the 64th byte depending on whether\n        // the booster message contains dynamic bytes or not.\n        //\n        // If it contains a dynamic byte array, then the first word points to the first\n        // data location.\n        //\n        // Therefore, we read the 32th byte and check if it's >= 32 and if so,\n        // simply read the (32 + first word)th byte to get the tag.\n        //\n        // This imposes a limit on the number of tags we can support (<32), but\n        // given that it is very unlikely for so many tags to exist it is fine.\n        //\n        // Read the 32th byte to get the tag, because it is a uint8 padded to 32 bytes.\n        // i.e.\n        // -----------------------------------------------------------------v\n        // 0x0000000000000000000000000000000000000000000000000000000000000001\n        //   ...\n        //\n        uint8 tag = uint8(boosterMessage[31]);\n        if (tag >= 32) {\n            // Read the (32 + tag) byte. E.g. if tag is 32, then we read the 64th:\n            // --------------------------------------------------------------------\n            // 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            //   0000000000000000000000000000000000000000000000000000000000000001 <\n            //   ...\n            //\n            tag = uint8(boosterMessage[31 + tag]);\n        }\n\n        return tag;\n    }\n}\n"
    },
    "@prps/solidity/contracts/IBoostableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n// Token agnostic fuel struct that is passed around when the fuel is burned by a different (token) contract.\n// The contract has to explicitely support the desired token that should be burned.\nstruct TokenFuel {\n    // A token alias that must be understood by the target contract\n    uint8 tokenAlias;\n    uint96 amount;\n}\n\n/**\n * @dev Extends the interface of the ERC20 standard as defined in the EIP with\n * `boostedTransferFrom` to perform transfers without having to rely on an allowance.\n */\ninterface IBoostableERC20 {\n    // ERC20\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    // Extension\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`.\n     *\n     * If the caller is known by the callee, then the implementation should skip approval checks.\n     * Also accepts a data payload, similar to ERC721's `safeTransferFrom` to pass arbitrary data.\n     *\n     */\n    function boostedTransferFrom(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n\n    /**\n     * @dev Burns `fuel` from `from`.\n     */\n    function burnFuel(address from, TokenFuel memory fuel) external;\n}\n"
    },
    "contracts/Dubiex.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/introspection/IERC1820Registry.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@prps/solidity/contracts/IBoostableERC20.sol\";\nimport \"./DubiexLib.sol\";\nimport \"./Boostable.sol\";\n\n/**\n * @dev The Dubiex contract\n *\n * Supported currencies:\n * - ETH\n * - ERC20\n * - BoostedERC20\n * - ERC721\n *\n * Any owner of ERC721 tokens may wish to approve Dubiex for all his/her tokens,\n * by calling `setApprovalForAll()`. Then approval for subsequent trades isn't required either.\n *\n * ERC20 can be approved once with an practically-infinite amount, then Dubiex requires\n * approval only once as well.\n *\n * BoostedERC20 tokens are designed to work without any explicit approval for Dubiex.\n *\n * External functions:\n * - makeOrder(s)\n * - takeOrder(s)\n * - cancelOrder(s)\n * - getOrder()\n * - boostedMakeOrder(Batch)\n * - boostedTakeOrder(Batch)\n * - boostedCanceleOrder(Batch)\n *\n */\ncontract Dubiex is ReentrancyGuard, ERC721Holder, Boostable {\n    using SafeERC20 for IERC20;\n\n    bytes32 private constant _BOOSTABLE_ERC20_TOKEN_HASH = keccak256(\n        \"BoostableERC20Token\"\n    );\n\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.1.0/contracts/token/ERC721/ERC721.sol#L68\n    bytes4 private constant _ERC721_INTERFACE_HASH = 0x80ac58cd;\n\n    IERC1820Registry private constant _ERC1820_REGISTRY = IERC1820Registry(\n        0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24\n    );\n\n    // This is a empty order to workaround:\n    // \"This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour\"\n    // In places where we need to return a zero-initialized storage order.\n    DubiexLib.PackedOrderBookItem private emptyOrder;\n\n    // Only required for burning fuel\n    address private immutable _prps;\n    address private immutable _dubi;\n\n    // Security mechanism which anyone can enable if the total supply of PRPS or DUBI should ever go >= 1 billion\n    bool private _killSwitchOn;\n\n    function activateKillSwitch() public {\n        require(!_killSwitchOn, \"Dubiex: kill switch already on\");\n\n        uint256 oneBillion = 1000000000 * 1 ether;\n\n        uint256 totalPrpsSupply = IERC20(_prps).totalSupply();\n        uint256 totalDubiSupply = IERC20(_dubi).totalSupply();\n\n        require(\n            totalPrpsSupply >= oneBillion || totalDubiSupply >= oneBillion,\n            \"Dubiex: insufficient total supply for kill switch\"\n        );\n        _killSwitchOn = true;\n    }\n\n    constructor(\n        address optIn,\n        address prps,\n        address dubi\n    ) public ReentrancyGuard() Boostable(optIn) {\n        _prps = prps;\n        _dubi = dubi;\n    }\n\n    event MadeOrder(\n        uint32 id,\n        address maker,\n        // uint96 makerValue, uint96 takerValue, uint32 orderPairAlias, uint32 padding\n        uint256 packedData\n    );\n\n    event TookOrder(\n        uint32 id,\n        address maker,\n        address taker,\n        // uint96 makerValue, uint96 takerValue, uint32 orderPairAlias, uint32 padding\n        uint256 packedData\n    );\n    event CanceledOrder(address maker, uint32 id);\n\n    event UpdatedOrder(address maker, uint32 id);\n\n    /**\n     * @dev Order pair aliases are generated by incrementing a number. Although the counter\n     * is using 32 bits, we do not support more than 2**28 = 268_435_456 pairs for technical reasons.\n     */\n    uint32 private _orderPairAliasCounter;\n\n    /**\n     * @dev A mapping of order pair alias to a packed order pair.\n     */\n    mapping(uint32 => DubiexLib.PackedOrderPair) private _orderPairsByAlias;\n    /**\n     * @dev A reverse mapping of order pair hash to an order pair alias. Required to check if\n     * a given pair already exists when creating an order where the full pair information are\n     * provided instead of an alias. I.e.\n     * MakeOrder {\n     *    ...\n     *    makerCurrencyType: ...,\n     *    takerCurrencyType: ...,\n     *    makerContractAddress: ...,\n     *    takerContractAddress: ...,\n     * }\n     *\n     * The hash of these four fields is used as the key of the mapping.\n     */\n    mapping(bytes32 => uint32) private _orderPairAliasesByHash;\n\n    /**\n     * @dev Mapping of address to a counter for order ids.\n     */\n    mapping(address => uint32) private _counters;\n\n    /**\n     * @dev Mapping of address to packed order book items.\n     */\n    mapping(address => DubiexLib.PackedOrderBookItem[])\n        private _ordersByAddress;\n\n    /**\n     * @dev Get an order by id. If the id doesn't exist (e.g. got cancelled / filled), a default order is returned.\n     * The caller should therefore check the id of the returned item. Any non-zero value means the order exists.\n     */\n    function getOrder(address maker, uint64 id)\n        public\n        view\n        returns (DubiexLib.PrettyOrderBookItem memory)\n    {\n\n            DubiexLib.PackedOrderBookItem[] storage orders\n         = _ordersByAddress[maker];\n        for (uint256 i = 0; i < orders.length; i++) {\n            DubiexLib.PackedOrderBookItem storage _packed = orders[i];\n            DubiexLib.UnpackedOrderBookItem memory _unpacked = DubiexLib\n                .unpackOrderBookItem(_packed.packedData);\n\n            if (_unpacked.id == id) {\n                DubiexLib.PrettyOrderBookItem memory pretty;\n                pretty.id = _unpacked.id;\n                pretty.makerValue = _unpacked.makerValue;\n                pretty.takerValue = _unpacked.takerValue;\n\n                pretty.orderPairAlias = _unpacked.orderPairAlias;\n                pretty.pair = getOrderPairByAlias(_unpacked.orderPairAlias);\n\n                pretty.flags = _unpacked.flags;\n\n                pretty.successorOrderId = _packed.successorOrderId;\n                pretty.ancestorOrderId = _packed.ancestorOrderId;\n\n                return pretty;\n            }\n        }\n\n        DubiexLib.PrettyOrderBookItem memory empty;\n        return empty;\n    }\n\n    /**\n     * @dev Get an order pair by alias.\n     */\n    function getOrderPairByAlias(uint32 orderPairAlias)\n        public\n        view\n        returns (DubiexLib.OrderPair memory)\n    {\n        DubiexLib.OrderPair memory orderPair;\n\n\n            DubiexLib.PackedOrderPair storage packedOrderPair\n         = _orderPairsByAlias[orderPairAlias];\n\n        (\n            address makerContractAddress,\n            DubiexLib.CurrencyType makerCurrencyType\n        ) = DubiexLib.unpackOrderPairAddressType(packedOrderPair.makerPair);\n\n        (\n            address takerContractAddress,\n            DubiexLib.CurrencyType takerCurrencyType\n        ) = DubiexLib.unpackOrderPairAddressType(packedOrderPair.takerPair);\n\n        orderPair.makerContractAddress = makerContractAddress;\n        orderPair.makerCurrencyType = makerCurrencyType;\n        orderPair.takerContractAddress = takerContractAddress;\n        orderPair.takerCurrencyType = takerCurrencyType;\n\n        return orderPair;\n    }\n\n    /**\n     * @dev Get an order pair by it's hash.\n     */\n    function getOrderPairByHash(bytes32 orderPairHash)\n        public\n        view\n        returns (DubiexLib.OrderPair memory)\n    {\n        uint32 orderPairAlias = _orderPairAliasesByHash[orderPairHash];\n        return getOrderPairByAlias(orderPairAlias);\n    }\n\n    /**\n     * @dev Get an order pair alias by it's hash.\n     */\n    function getOrderPairAliasByHash(bytes32 orderPairHash)\n        public\n        view\n        returns (uint32)\n    {\n        return _orderPairAliasesByHash[orderPairHash];\n    }\n\n    /**\n     * @dev Make a single order. Reverts on failure.\n     *\n     * If an `orderId` is provided, an already existing order will be updated\n     * according to `updatedWeiRatio`. For efficiency reasons, the id of the updated order\n     * remains the same. Taker orders provide a minimum ratio to protect themselves against\n     * front-running by the maker.\n     *\n     * Returns the assigned order id.\n     */\n    function makeOrder(DubiexLib.MakeOrderInput memory input)\n        external\n        payable\n        nonReentrant\n        returns (uint32)\n    {\n        require(!_killSwitchOn, \"Dubiex: make order prevented by kill switch\");\n\n        uint256 excessEth = msg.value;\n        uint32 orderId;\n\n        (orderId, excessEth) = _makeOrderInternal({\n            input: input,\n            maker: msg.sender,\n            excessEthAndIntrinsicFuel: excessEth,\n            isBoosted: false,\n            revertOnUpdateError: true\n        });\n\n        _refundExcessEth(excessEth);\n\n        return orderId;\n    }\n\n    /**\n     * @dev Create multiple orders at once. The transaction won't revert if any make order fails, but\n     * silently ignore it. Returns an array of order ids where each item corresponds to an input\n     * at the same index and non-zero values indicate success.\n     */\n    function makeOrders(DubiexLib.MakeOrderInput[] memory inputs)\n        external\n        payable\n        nonReentrant\n        returns (uint32[] memory)\n    {\n        require(!_killSwitchOn, \"Dubiex: make order prevented by kill switch\");\n        require(inputs.length > 0, \"Dubiex: empty inputs\");\n\n        uint32[] memory orderIds = new uint32[](inputs.length);\n\n        uint256 excessEth = msg.value;\n\n        for (uint256 i = 0; i < inputs.length; i++) {\n            uint32 orderId;\n\n            (orderId, excessEth) = _makeOrderInternal({\n                input: inputs[i],\n                maker: msg.sender,\n                excessEthAndIntrinsicFuel: excessEth,\n                isBoosted: false,\n                revertOnUpdateError: false\n            });\n\n            orderIds[i] = orderId;\n        }\n\n        _refundExcessEth(excessEth);\n\n        return orderIds;\n    }\n\n    /**\n     * @dev Take a single order. Reverts on failure.\n     */\n    function takeOrder(DubiexLib.TakeOrderInput calldata input)\n        external\n        payable\n        nonReentrant\n    {\n        require(!_killSwitchOn, \"Dubiex: take order prevented by kill switch\");\n\n        uint256 excessEth = msg.value;\n\n        (, excessEth, ) = _takeOrderInternal({\n            input: input,\n            taker: msg.sender,\n            excessEthAndIntrinsicFuel: excessEth,\n            revertOnError: true,\n            isBoosted: false\n        });\n\n        _refundExcessEth(excessEth);\n    }\n\n    /**\n     * @dev Take multiple orders at once. The transaction won't revert if any take order fails, but\n     * silently ignore it. Check the logs in the receipt to see if any failed.\n     *\n     * See `takeOrder` for more information about the opt-in.\n     *\n     * @param inputs the take order inputs\n     */\n    function takeOrders(DubiexLib.TakeOrderInput[] calldata inputs)\n        external\n        payable\n        nonReentrant\n        returns (bool[] memory)\n    {\n        require(!_killSwitchOn, \"Dubiex: take order prevented by kill switch\");\n        require(inputs.length > 0, \"Dubiex: empty inputs\");\n\n        bool[] memory result = new bool[](inputs.length);\n\n        uint256 excessEth = msg.value;\n\n        for (uint256 i = 0; i < inputs.length; i++) {\n            bool success;\n            (success, excessEth, ) = _takeOrderInternal({\n                input: inputs[i],\n                taker: msg.sender,\n                excessEthAndIntrinsicFuel: uint96(excessEth),\n                revertOnError: false,\n                isBoosted: false\n            });\n\n            result[i] = success;\n        }\n\n        _refundExcessEth(excessEth);\n\n        return result;\n    }\n\n    /**\n     * @dev Cancel a single order.\n     */\n    function cancelOrder(DubiexLib.CancelOrderInput memory input)\n        external\n        nonReentrant\n    {\n        _cancelOrderInternal({\n            maker: input.maker,\n            id: input.id,\n            intrinsicFuel: 0,\n            isBoosted: false,\n            revertOnError: true,\n            isKillSwitchOn: _killSwitchOn\n        });\n    }\n\n    /**\n     * @dev Cancel multiple orders at once. It will not revert on error, but ignore failed\n     * orders silently. Check the logs in the receipt to see if any failed.\n     *\n     * @return Array of booleans with `ids.length` items where each item corresponds to an id\n     * at the same index and `true` indicate success.\n     */\n    function cancelOrders(DubiexLib.CancelOrderInput[] calldata inputs)\n        external\n        nonReentrant\n        returns (bool[] memory)\n    {\n        require(inputs.length > 0, \"Dubiex: empty inputs\");\n\n        bool[] memory result = new bool[](inputs.length);\n\n        bool isKillSwitchOn = _killSwitchOn;\n\n        for (uint256 i = 0; i < inputs.length; i++) {\n            result[i] = _cancelOrderInternal({\n                maker: inputs[i].maker,\n                id: inputs[i].id,\n                intrinsicFuel: 0,\n                isBoosted: false,\n                revertOnError: false,\n                isKillSwitchOn: isKillSwitchOn\n            });\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Create an order for the signer of `signature`.\n     */\n    function boostedMakeOrder(\n        BoostedMakeOrder memory order,\n        Signature memory signature\n    ) public payable nonReentrant returns (uint32) {\n        require(!_killSwitchOn, \"Dubiex: make order prevented by kill switch\");\n\n        uint32 orderId;\n        uint256 excessEth = msg.value;\n        (orderId, excessEth) = _boostedMakeOrderInternal(\n            order,\n            signature,\n            excessEth,\n            true\n        );\n\n        _refundExcessEth(excessEth);\n        return orderId;\n    }\n\n    function _boostedMakeOrderInternal(\n        BoostedMakeOrder memory order,\n        Signature memory signature,\n        uint256 excessEth,\n        bool revertOnUpdateError\n    ) private returns (uint32, uint256) {\n        uint96 intrinsicFuel = _burnFuel(order.maker, order.fuel);\n\n        // We optimize ERC721 sell orders by not increasing the\n        // nonce, because every ERC721 is unique - trying to replay the\n        // transaction while the signature hasn't expired yet is almost\n        // guaranteed to always fail. The only scenarios where it would be\n        // possible is:\n        // - if the order gets cancelled\n        // - the order is filled by the maker OR the taker sends it back to the maker\n        //\n        // But this all has to happen in a very short timeframe, so the chance of this happening\n        // is really low.\n        //\n        if (\n            order.input.pair.makerCurrencyType == DubiexLib.CurrencyType.ERC721\n        ) {\n            _verifyBoostWithoutNonce(\n                order.maker,\n                hashBoostedMakeOrder(order, msg.sender),\n                order.boosterPayload,\n                signature\n            );\n        } else {\n            verifyBoost(\n                order.maker,\n                hashBoostedMakeOrder(order, msg.sender),\n                order.boosterPayload,\n                signature\n            );\n        }\n\n        uint32 orderId;\n\n        // Encode the intrinsic fuel in the upper bits of the excess eth,\n        // because we are hitting 'CompilerError: Stack too deep'.\n        uint256 excessEthAndIntrinsicFuel = excessEth;\n        excessEthAndIntrinsicFuel |= uint256(intrinsicFuel) << 96;\n\n        (orderId, excessEth) = _makeOrderInternal({\n            maker: order.maker,\n            input: order.input,\n            excessEthAndIntrinsicFuel: excessEthAndIntrinsicFuel,\n            isBoosted: true,\n            revertOnUpdateError: revertOnUpdateError\n        });\n\n        return (orderId, excessEth);\n    }\n\n    /**\n     * @dev Take an order for the signer of `signature`.\n     */\n    function boostedTakeOrder(\n        BoostedTakeOrder memory order,\n        Signature memory signature\n    ) public payable nonReentrant {\n        require(!_killSwitchOn, \"Dubiex: take order prevented by kill switch\");\n\n        uint256 excessEth = _boostedTakeOrderInternal({\n            order: order,\n            signature: signature,\n            excessEth: msg.value,\n            revertOnError: true\n        });\n\n        _refundExcessEth(excessEth);\n    }\n\n    function _boostedTakeOrderInternal(\n        BoostedTakeOrder memory order,\n        Signature memory signature,\n        uint256 excessEth,\n        bool revertOnError\n    ) private returns (uint256) {\n        uint96 intrinsicFuel = _burnFuel(order.taker, order.fuel);\n\n        // Encode the intrinsic fuel in the upper bits of the excess eth,\n        // because we are hitting 'CompilerError: Stack too deep'.\n        uint256 excessEthAndIntrinsicFuel = excessEth;\n        excessEthAndIntrinsicFuel |= uint256(intrinsicFuel) << 96;\n\n        DubiexLib.CurrencyType takerCurrencyType;\n        (, excessEth, takerCurrencyType) = _takeOrderInternal({\n            input: order.input,\n            taker: order.taker,\n            excessEthAndIntrinsicFuel: excessEthAndIntrinsicFuel,\n            revertOnError: revertOnError,\n            isBoosted: true\n        });\n\n        // We optimize ERC721 take orders by not increasing the\n        // nonce, because every ERC721 is unique - trying to replay the\n        // transaction will always fail, since once taken - the target order doesn't\n        // exist anymore and thus cannot be filled ever again.\n        if (takerCurrencyType == DubiexLib.CurrencyType.ERC721) {\n            _verifyBoostWithoutNonce(\n                order.taker,\n                hashBoostedTakeOrder(order, msg.sender),\n                order.boosterPayload,\n                signature\n            );\n        } else {\n            verifyBoost(\n                // The signer of the boosted message\n                order.taker,\n                hashBoostedTakeOrder(order, msg.sender),\n                order.boosterPayload,\n                signature\n            );\n        }\n\n        return excessEth;\n    }\n\n    /**\n     * @dev Cancel an order for the signer of `signature`.\n     */\n    function boostedCancelOrder(\n        BoostedCancelOrder memory order,\n        Signature memory signature\n    ) public payable nonReentrant {\n        bool isKillSwitchOn = _killSwitchOn;\n        _boostedCancelOrderInternal(order, signature, true, isKillSwitchOn);\n    }\n\n    function _boostedCancelOrderInternal(\n        BoostedCancelOrder memory order,\n        Signature memory signature,\n        bool reverOnError,\n        bool isKillSwitchOn\n    ) private {\n        uint96 intrinsicFuel = _burnFuel(order.input.maker, order.fuel);\n\n        // We do not need a nonce, since once cancelled the order id can never be re-used again\n        _verifyBoostWithoutNonce(\n            order.input.maker,\n            hashBoostedCancelOrder(order, msg.sender),\n            order.boosterPayload,\n            signature\n        );\n\n        // Encode the intrinsic fuel in the upper bits of the excess eth,\n        // (which for cancel order is always 0), because we are hitting 'CompilerError: Stack too deep'.\n        uint256 excessEthAndIntrinsicFuel;\n        excessEthAndIntrinsicFuel |= uint256(intrinsicFuel) << 96;\n\n        _cancelOrderInternal({\n            maker: order.input.maker,\n            id: order.input.id,\n            isBoosted: true,\n            intrinsicFuel: excessEthAndIntrinsicFuel,\n            revertOnError: reverOnError,\n            isKillSwitchOn: isKillSwitchOn\n        });\n    }\n\n    /**\n     * @dev Perform multiple `boostedMakeOrder` calls in a single transaction.\n     */\n    function boostedMakeOrderBatch(\n        BoostedMakeOrder[] calldata orders,\n        Signature[] calldata signatures\n    ) external payable nonReentrant {\n        require(!_killSwitchOn, \"Dubiex: make order prevented by kill switch\");\n        require(\n            orders.length > 0 && orders.length == signatures.length,\n            \"Dubiex: invalid input lengths\"\n        );\n\n        uint256 excessEth = msg.value;\n\n        for (uint256 i = 0; i < orders.length; i++) {\n            (, excessEth) = _boostedMakeOrderInternal(\n                orders[i],\n                signatures[i],\n                uint96(excessEth),\n                false\n            );\n        }\n    }\n\n    /**\n     * @dev Perform multiple `boostedTakeOrder` calls in a single transaction.\n     */\n    function boostedTakeOrderBatch(\n        BoostedTakeOrder[] memory boostedTakeOrders,\n        Signature[] calldata signatures\n    ) external payable nonReentrant {\n        require(!_killSwitchOn, \"Dubiex: take order prevented by kill switch\");\n        require(\n            boostedTakeOrders.length > 0 &&\n                boostedTakeOrders.length == signatures.length,\n            \"Dubiex: invalid input lengths\"\n        );\n\n        uint256 excessEth = msg.value;\n        for (uint256 i = 0; i < boostedTakeOrders.length; i++) {\n            excessEth = _boostedTakeOrderInternal(\n                boostedTakeOrders[i],\n                signatures[i],\n                uint96(excessEth),\n                false\n            );\n        }\n\n        _refundExcessEth(excessEth);\n    }\n\n    /**\n     * @dev Perform multiple `boostedCancelOrder` calls in a single transaction.\n     */\n    function boostedCancelOrderBatch(\n        BoostedCancelOrder[] memory orders,\n        Signature[] calldata signatures\n    ) external payable nonReentrant returns (uint32) {\n        require(\n            orders.length > 0 && orders.length == signatures.length,\n            \"Dubiex: invalid input lengths\"\n        );\n\n        bool isKillSwitchOn = _killSwitchOn;\n\n        for (uint256 i = 0; i < orders.length; i++) {\n            _boostedCancelOrderInternal(\n                orders[i],\n                signatures[i],\n                false,\n                isKillSwitchOn\n            );\n        }\n    }\n\n    /**\n     * @dev Create a new single order.\n     *\n     * @return the assigned order id\n     */\n    function _makeOrderInternal(\n        DubiexLib.MakeOrderInput memory input,\n        address payable maker,\n        uint256 excessEthAndIntrinsicFuel,\n        bool isBoosted,\n        bool revertOnUpdateError\n    ) private returns (uint32, uint256) {\n        require(\n            maker != address(this) && maker != address(0),\n            \"Dubiex: unexpected maker\"\n        );\n\n        // An explicit id means an existing order should be updated.\n        if (input.orderId > 0) {\n            return (\n                _updateOrder(\n                    maker,\n                    input.orderId,\n                    input.updatedRatioWei,\n                    revertOnUpdateError\n                ),\n                // Update order never uses eth, so we refund everything in case something was mistakenly sent\n                uint96(excessEthAndIntrinsicFuel)\n            );\n        }\n\n        // Reverts if the input is invalid\n        require(input.makerValue > 0, \"Dubiex: makerValue must be greater 0\");\n        require(input.takerValue > 0, \"Dubiex: takerValue must be greater 0\");\n\n        // Reverts if the order pair is incompatible\n        uint32 orderPairAlias = _getOrCreateOrderPairAlias(input.pair);\n\n        // Deposit the makerValue, which will fail if no approval has been given\n        // or the maker hasn't enough funds.\n        // NOTE(reentrancy): safe, because we are using `nonReentrant` for makeOrder(s).\n        // NOTE2: _transfer returns the *excessEth* only, but we reuse the 'excessEthAndIntrinsicFuel' variable\n        // to work around 'CompilerError: Stack too deep'.\n        bool deposited;\n\n        (deposited, excessEthAndIntrinsicFuel) = _transfer({\n            from: maker,\n            to: payable(address(this)),\n            value: input.makerValue,\n            valueContractAddress: input.pair.makerContractAddress,\n            valueCurrencyType: input.pair.makerCurrencyType,\n            excessEthAndIntrinsicFuel: excessEthAndIntrinsicFuel,\n            isBoosted: isBoosted\n        });\n\n        require(deposited, \"Dubiex: failed to deposit. not enough funds?\");\n\n        // Create the orderbook item\n        DubiexLib.PackedOrderBookItem memory _packed;\n\n        DubiexLib.UnpackedOrderBookItem memory _unpacked;\n        _unpacked.id = _getNextOrderId(maker);\n        _unpacked.makerValue = input.makerValue;\n        _unpacked.takerValue = input.takerValue;\n        _unpacked.orderPairAlias = orderPairAlias;\n        _unpacked.flags.isMakerERC721 =\n            input.pair.makerCurrencyType == DubiexLib.CurrencyType.ERC721;\n        _unpacked.flags.isTakerERC721 =\n            input.pair.takerCurrencyType == DubiexLib.CurrencyType.ERC721;\n\n        // Update ancestor order if any\n        _updateOrderAncestorIfAny(input, maker, _unpacked, _packed);\n\n        // Pack unpacked data and write to storage\n        _packed.packedData = DubiexLib.packOrderBookItem(_unpacked);\n        _ordersByAddress[maker].push(_packed);\n\n        // Emit event and done\n\n        uint256 packedData;\n        packedData |= input.makerValue;\n        packedData |= uint256(input.takerValue) << 96;\n        packedData |= uint256(orderPairAlias) << (96 + 96);\n\n        emit MadeOrder(_unpacked.id, maker, packedData);\n\n        return (_unpacked.id, excessEthAndIntrinsicFuel);\n    }\n\n    function _updateOrderAncestorIfAny(\n        DubiexLib.MakeOrderInput memory input,\n        address maker,\n        DubiexLib.UnpackedOrderBookItem memory unpacked,\n        DubiexLib.PackedOrderBookItem memory packed\n    ) private {\n        // If an ancestor is provided, we check if it exists and try to make this order\n        // an successor of it. If it succeeds, then this order ends up being hidden.\n        if (input.ancestorOrderId > 0) {\n            packed.ancestorOrderId = input.ancestorOrderId;\n\n            bool success = _setSuccessorOfAncestor(\n                maker,\n                input.ancestorOrderId,\n                unpacked.id\n            );\n\n            // New successor order must be hidden if it has an existing ancestor now\n            unpacked.flags.isHidden = success;\n        }\n    }\n\n    /**\n     * @dev Take a make order.\n     * @param input the take order input.\n     * @param taker address of the taker\n     * @param revertOnError whether to revert on errors or not. True, when taking a single order.\n     *\n     */\n    function _takeOrderInternal(\n        address payable taker,\n        DubiexLib.TakeOrderInput memory input,\n        uint256 excessEthAndIntrinsicFuel,\n        bool revertOnError,\n        bool isBoosted\n    )\n        private\n        returns (\n            bool,\n            uint256,\n            DubiexLib.CurrencyType\n        )\n    {\n        (\n            DubiexLib.PackedOrderBookItem storage _packed,\n            DubiexLib.UnpackedOrderBookItem memory _unpacked,\n            uint256 index\n        ) = _assertTakeOrderInput(input, revertOnError);\n\n        // Order doesn't exist or input is invalid.\n        if (_unpacked.id == 0) {\n            // Only gets here if 'revertOnError' is false\n            return (\n                false,\n                uint96(excessEthAndIntrinsicFuel),\n                DubiexLib.CurrencyType.NULL\n            );\n        }\n\n        // Get the actual makerValue, which might just be a fraction of the total\n        // `takerValue` of the `_makeOrder`.\n        (uint96 _makerValue, uint96 _takerValue) = _calculateMakerAndTakerValue(\n            _unpacked,\n            input.takerValue,\n            input.maxTakerMakerRatio\n        );\n        if (_makerValue == 0 || _takerValue == 0) {\n            if (revertOnError) {\n                revert(\"Dubiex: invalid takerValue\");\n            }\n\n            return (\n                false,\n                uint96(excessEthAndIntrinsicFuel),\n                DubiexLib.CurrencyType.NULL\n            );\n        }\n\n        // Transfer from taker to maker\n        // NOTE(reentrancy): `takeOrder(s)` is marked nonReentrant\n        // NOTE2: _transferFromTakerToMaker returns the *excessEth* only, but we reuse the 'excessEthAndIntrinsicFuel' variable\n        // to work around 'CompilerError: Stack too deep'.\n        excessEthAndIntrinsicFuel = _transferFromTakerToMaker(\n            taker,\n            input.maker,\n            _takerValue,\n            _unpacked.pair,\n            excessEthAndIntrinsicFuel,\n            isBoosted\n        );\n\n        // Transfer from maker to taker\n        // NOTE(reentrancy): `takeOrder(s)` is marked nonReentrant\n        if (\n            !_transferFromContractToTaker(\n                taker,\n                _makerValue,\n                _unpacked.pair,\n                false,\n                0\n            )\n        ) {\n            if (revertOnError) {\n                revert(\"Dubiex: failed to transfer value to taker\");\n            }\n\n            return (\n                false,\n                excessEthAndIntrinsicFuel,\n                DubiexLib.CurrencyType.NULL\n            );\n        }\n\n        // If filled, the order can be deleted (without having to update the maker/taker value)\n        if (_unpacked.makerValue - _makerValue == 0) {\n            // Make successor of filled order visible if any.\n            if (_unpacked.flags.hasSuccessor) {\n                _setOrderVisible(input.maker, _packed.successorOrderId);\n            }\n\n            // Delete the filled order\n            _deleteOrder({maker: input.maker, index: index});\n        } else {\n            // Not filled yet, so update original make order\n            _unpacked.makerValue -= _makerValue;\n            _unpacked.takerValue -= _takerValue;\n\n            // Write updated item to storage\n            _packed.packedData = DubiexLib.packOrderBookItem(_unpacked);\n        }\n\n        // NOTE: We write the new taker/maker value to the in-memory struct\n        // and pass it to a function that emits 'TookOrder' to avoid the 'Stack too deep' error\n        _unpacked.makerValue = _makerValue;\n        _unpacked.takerValue = _takerValue;\n\n        return\n            _emitTookOrder(\n                input.maker,\n                taker,\n                _unpacked,\n                excessEthAndIntrinsicFuel\n            );\n    }\n\n    /**\n     * @dev Emit 'TookOrder' in a separate function to avoid the 'Stack too deep' error\n     */\n    function _emitTookOrder(\n        address maker,\n        address taker,\n        DubiexLib.UnpackedOrderBookItem memory unpacked,\n        uint256 excessEthAndIntrinsicFuel\n    )\n        private\n        returns (\n            bool,\n            uint256,\n            DubiexLib.CurrencyType\n        )\n    {\n        uint256 packedData;\n        packedData |= unpacked.makerValue;\n        packedData |= uint256(unpacked.takerValue) << 96;\n        packedData |= uint256(unpacked.orderPairAlias) << (96 + 96);\n\n        emit TookOrder(unpacked.id, maker, taker, packedData);\n\n        return (\n            true,\n            excessEthAndIntrinsicFuel,\n            unpacked.pair.takerCurrencyType\n        );\n    }\n\n    /**\n     * @dev Cancel an order\n     * @param maker the maker of the order\n     * @param id the id of the order to cancel\n     * @param revertOnError whether to revert on errors or not\n     */\n    function _cancelOrderInternal(\n        address payable maker,\n        uint32 id,\n        uint256 intrinsicFuel,\n        bool isBoosted,\n        bool revertOnError,\n        bool isKillSwitchOn\n    ) private returns (bool) {\n        // Anyone can cancel any order if the kill switch is on.\n        // For efficiency, we do not need to check the kill switch if this is a boosted cancel order,\n        // because in that case we already have the explicit consent of the maker.\n        // If it's neither a boosted cancel nor a post-kill switch cancel, the msg.sender must be the maker.\n        if (!isBoosted && !isKillSwitchOn) {\n            require(maker == msg.sender, \"Dubiex: msg.sender must be maker\");\n        }\n\n        if (!revertOnError && !_orderExists(maker, id)) {\n            return false;\n        }\n\n        // Get the make order (reverts if order doesn't exist)\n        (\n            ,\n            DubiexLib.UnpackedOrderBookItem memory unpacked,\n            uint256 index\n        ) = _safeGetOrder(maker, id, DubiexLib.OrderPairReadStrategy.MAKER);\n\n        // Transfer remaining `makerValue` back to maker, by assuming the taker role with the maker.\n\n        // NOTE(reentrancy): `cancelOrder(s)` is marked nonReentrant\n        if (\n            !_transferFromContractToTaker({\n                taker: maker,\n                makerValue: unpacked.makerValue,\n                pair: unpacked.pair,\n                isBoosted: isBoosted,\n                excessEthAndIntrinsicFuel: intrinsicFuel\n            })\n        ) {\n            return false;\n        }\n\n        // Delete the cancelled order\n        _deleteOrder({maker: maker, index: index});\n\n        emit CanceledOrder(maker, id);\n\n        return true;\n    }\n\n    /**\n     * @dev Update the `takerValue` of an order using the given `updatedRatioWei`\n     * @param maker the maker of the order to update\n     * @param orderId the id of the existing order\n     * @param updatedRatioWei the new ratio in wei\n     */\n    function _updateOrder(\n        address maker,\n        uint32 orderId,\n        uint128 updatedRatioWei,\n        bool revertOnUpdateError\n    ) private returns (uint32) {\n        (\n            DubiexLib.PackedOrderBookItem storage _packed,\n            DubiexLib.UnpackedOrderBookItem memory _unpacked,\n\n        ) = _getOrder(maker, orderId, DubiexLib.OrderPairReadStrategy.SKIP);\n\n        // Order doesn't exist\n        if (_unpacked.id == 0) {\n            if (revertOnUpdateError) {\n                revert(\"Dubiex: order does not exist\");\n            }\n\n            return 0;\n        }\n\n        // We don't prevent reverts here, even if `revertOnUpdateError` is false since\n        // they are user errors unlike a non-existing order which a user has no control over.\n\n        require(updatedRatioWei > 0, \"Dubiex: ratio is 0\");\n\n        require(\n            !_unpacked.flags.isMakerERC721 && !_unpacked.flags.isTakerERC721,\n            \"Dubiex: cannot update ERC721 value\"\n        );\n\n        // Update the existing order with the new ratio to the takerValue.\n        // The makerValue stays untouched.\n\n        uint256 updatedTakerValue = (uint256(_unpacked.makerValue) *\n            uint256(updatedRatioWei)) / 1 ether;\n\n        require(updatedTakerValue < 2**96, \"Dubiex: takerValue overflow\");\n\n        _unpacked.takerValue = uint96(updatedTakerValue);\n        _packed.packedData = DubiexLib.packOrderBookItem(_unpacked);\n\n        emit UpdatedOrder(maker, orderId);\n\n        return orderId;\n    }\n\n    // If both returned values are > 0, then the provided `takerValue` and `maxTakerMakerRatio` are valid.\n    function _calculateMakerAndTakerValue(\n        DubiexLib.UnpackedOrderBookItem memory _unpacked,\n        uint96 takerValue,\n        uint256 maxTakerMakerRatio\n    ) private pure returns (uint96, uint96) {\n        uint256 calculatedMakerValue = _unpacked.makerValue;\n        uint256 calculatedTakerValue = takerValue;\n\n        // ERC721 cannot be bought/sold partially, therefore the `takerValue` must match the requested\n        // value exactly.\n        if (\n            _unpacked.pair.makerCurrencyType == DubiexLib.CurrencyType.ERC721 ||\n            _unpacked.pair.takerCurrencyType == DubiexLib.CurrencyType.ERC721\n        ) {\n            if (takerValue != _unpacked.takerValue) {\n                return (0, 0);\n            }\n\n            // The order gets filled completely, so we use the values as is.\n        } else {\n            // Calculate the current takerMakerValue ratio and compare it to `maxTakerMakerRatio`.\n            // If it is higher then the order will not be taken.\n            uint256 takerMakerRatio = (uint256(_unpacked.takerValue) *\n                1 ether) / calculatedMakerValue;\n\n            if (maxTakerMakerRatio < takerMakerRatio) {\n                return (0, 0);\n            }\n\n            if (calculatedTakerValue > _unpacked.takerValue) {\n                calculatedTakerValue = _unpacked.takerValue;\n            }\n\n            // Calculate actual makerValue for ETH/ERC20 trades which might only get partially filled by the\n            // takerValue. Since we don't have decimals, we need to multiply by 10^18 and divide by it again at the end\n            // to not lose any information.\n            calculatedMakerValue *= 1 ether;\n            calculatedMakerValue *= calculatedTakerValue;\n            calculatedMakerValue /= _unpacked.takerValue;\n            calculatedMakerValue /= 1 ether;\n        }\n\n        // Sanity checks\n        assert(\n            calculatedMakerValue < 2**96 &&\n                calculatedMakerValue <= _unpacked.makerValue\n        );\n        assert(\n            calculatedTakerValue < 2**96 &&\n                calculatedTakerValue <= _unpacked.takerValue\n        );\n\n        return (uint96(calculatedMakerValue), uint96(calculatedTakerValue));\n    }\n\n    /**\n     * @dev Assert a take order input and return the order. If a zero-order is returned,\n     * then it does not exist and it is up to the caller how to handle it.\n     */\n    function _assertTakeOrderInput(\n        DubiexLib.TakeOrderInput memory input,\n        bool revertOnError\n    )\n        private\n        view\n        returns (\n            DubiexLib.PackedOrderBookItem storage,\n            DubiexLib.UnpackedOrderBookItem memory,\n            uint256 // index\n        )\n    {\n        (\n            DubiexLib.PackedOrderBookItem storage packed,\n            DubiexLib.UnpackedOrderBookItem memory unpacked,\n            uint256 index\n        ) = _getOrder(\n            input.maker,\n            input.id,\n            DubiexLib.OrderPairReadStrategy.FULL\n        );\n\n        bool validTakerValue = input.takerValue > 0;\n        bool orderExistsAndNotHidden = unpacked.id > 0 &&\n            !unpacked.flags.isHidden;\n        if (revertOnError) {\n            require(validTakerValue, \"Dubiex: takerValue must be greater 0\");\n\n            require(orderExistsAndNotHidden, \"Dubiex: order does not exist\");\n        } else {\n            if (!validTakerValue || !orderExistsAndNotHidden) {\n                DubiexLib.UnpackedOrderBookItem memory emptyUnpacked;\n                return (emptyOrder, emptyUnpacked, 0);\n            }\n        }\n\n        return (packed, unpacked, index);\n    }\n\n    function _orderExists(address maker, uint32 id)\n        private\n        view\n        returns (bool)\n    {\n        // Since we don't want to revert for cancelOrders, we have to check that the order\n        // (maker, id) exists by looping over the orders of the maker and comparing the id.\n\n\n            DubiexLib.PackedOrderBookItem[] storage orders\n         = _ordersByAddress[maker];\n\n        uint256 length = orders.length;\n        for (uint256 i = 0; i < length; i++) {\n            // The first 32 bits of the packed data corresponds to the id. By casting to uint32,\n            // we can compare the id without having to unpack the entire thing.\n            uint32 orderId = uint32(orders[i].packedData);\n            if (orderId == id) {\n                // Found order\n                return true;\n            }\n        }\n\n        // Doesn't exist\n        return false;\n    }\n\n    function _refundExcessEth(uint256 excessEth) private {\n        // Casting to uint96 to get rid off any of the higher utility bits\n        excessEth = uint96(excessEth);\n\n        // Sanity check\n        assert(msg.value >= excessEth);\n\n        if (excessEth > 0) {\n            msg.sender.transfer(excessEth);\n        }\n    }\n\n    // Transfer `takerValue` to `maker`.\n    function _transferFromTakerToMaker(\n        address payable taker,\n        address payable maker,\n        uint96 takerValue,\n        DubiexLib.OrderPair memory pair,\n        uint256 excessEthAndIntrinsicFuel,\n        bool isBoosted\n    ) private returns (uint256) {\n        (bool success, uint256 excessEth) = _transfer(\n            taker,\n            maker,\n            takerValue,\n            pair.takerContractAddress,\n            pair.takerCurrencyType,\n            excessEthAndIntrinsicFuel,\n            isBoosted\n        );\n\n        require(success, \"Dubiex: failed to transfer value to maker\");\n\n        return excessEth;\n    }\n\n    // Transfer `makerValue` to `taker`\n    function _transferFromContractToTaker(\n        address payable taker,\n        uint96 makerValue,\n        DubiexLib.OrderPair memory pair,\n        bool isBoosted,\n        uint256 excessEthAndIntrinsicFuel\n    ) private returns (bool) {\n        (bool success, ) = _transfer(\n            payable(address(this)),\n            taker,\n            makerValue,\n            pair.makerContractAddress,\n            pair.makerCurrencyType,\n            excessEthAndIntrinsicFuel,\n            isBoosted\n        );\n\n        return success;\n    }\n\n    function _transfer(\n        address payable from,\n        address payable to,\n        uint256 value,\n        address valueContractAddress,\n        DubiexLib.CurrencyType valueCurrencyType,\n        uint256 excessEthAndIntrinsicFuel,\n        bool isBoosted\n    ) private returns (bool, uint256) {\n        uint256 excessEth = uint96(excessEthAndIntrinsicFuel);\n        if (valueCurrencyType == DubiexLib.CurrencyType.ETH) {\n            // Eth is a bit special, because it's not a token. Therefore we need to ensure\n            // that the taker/maker sent enough eth (`excessEth` >= `value`) and also that\n            // he is refunded at the end of the transaction properly.\n            if (from != address(this)) {\n                if (excessEth < value) {\n                    return (false, excessEth);\n                }\n\n                // Got enough eth, but maybe too much, so we subtract the value from the excessEth. This is important\n                // to refund the sender correctly e.g. he mistakenly sent too much or the order\n                // was partially filled while his transaction was pending.\n                excessEth -= value;\n            }\n\n            // Not a deposit, so transfer eth owned by this contract to maker or taker\n            if (to != address(this)) {\n                to.transfer(value);\n            }\n\n            return (true, excessEth);\n        }\n\n        if (valueCurrencyType == DubiexLib.CurrencyType.ERC20) {\n            IERC20 erc20 = IERC20(valueContractAddress);\n            uint256 recipientBalanceBefore = erc20.balanceOf(to);\n\n            if (from == address(this)) {\n                // If sending own tokens, use `safeTransfer` because Dubiex doesn't have any allowance\n                // for itself which would cause `safeTransferFrom` to fail.\n                erc20.safeTransfer(to, value);\n            } else {\n                erc20.safeTransferFrom(from, to, value);\n            }\n\n            uint256 recipientBalanceAfter = erc20.balanceOf(to);\n            // Safe guard to minimize the risk of getting buggy orders if the contract\n            // deviates from the ERC20 standard.\n            require(\n                recipientBalanceAfter == recipientBalanceBefore + value,\n                \"Dubiex: failed to transfer ERC20 token\"\n            );\n\n            return (true, excessEth);\n        }\n\n        if (valueCurrencyType == DubiexLib.CurrencyType.BOOSTABLE_ERC20) {\n            IBoostableERC20 erc20 = IBoostableERC20(valueContractAddress);\n\n            if (from == address(this)) {\n                // If sending own tokens, use `safeTransfer`, because Dubiex doesn't have any allowance\n                // for itself which would cause `permissionSend` to fail.\n                IERC20(address(erc20)).safeTransfer(to, value);\n            } else {\n                bool success = erc20.boostedTransferFrom(\n                    from,\n                    to,\n                    value,\n                    abi.encodePacked(isBoosted)\n                );\n\n                require(\n                    success,\n                    \"Dubiex: failed to transfer boosted ERC20 token\"\n                );\n            }\n\n            return (true, excessEth);\n        }\n\n        if (valueCurrencyType == DubiexLib.CurrencyType.ERC721) {\n            IERC721 erc721 = IERC721(valueContractAddress);\n\n            // Pass isBoosted flag + fuel if any\n            erc721.safeTransferFrom(\n                from,\n                to,\n                value,\n                abi.encodePacked(\n                    isBoosted,\n                    uint96(excessEthAndIntrinsicFuel >> 96)\n                )\n            );\n\n            // Safe guard to minimize the risk of getting buggy orders if the contract\n            // deviates from the ERC721 standard.\n            require(\n                erc721.ownerOf(value) == to,\n                \"Dubiex: failed to transfer ERC721 token\"\n            );\n\n            return (true, excessEth);\n        }\n\n        revert(\"Dubiex: unexpected currency type\");\n    }\n\n    /**\n     * @dev Validates that the given contract address and currency type are compatible.\n     * @param currencyType type of the currency\n     * @param contractAddress the contract address associated with currency\n     */\n    function _validateCurrencyType(\n        DubiexLib.CurrencyType currencyType,\n        address contractAddress\n    ) private returns (bool) {\n        if (currencyType == DubiexLib.CurrencyType.ETH) {\n            require(\n                contractAddress == address(0),\n                \"Dubiex: expected zero address\"\n            );\n            return true;\n        }\n\n        if (currencyType == DubiexLib.CurrencyType.ERC721) {\n            // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n            //\n            // `contractAddress` must implement the ERC721 standard. According to the ERC721 standard\n            // every compliant token is also expected to use ERC165 for that.\n            require(\n                IERC165(contractAddress).supportsInterface(\n                    _ERC721_INTERFACE_HASH\n                ),\n                \"Dubiex: not ERC721 compliant\"\n            );\n            return true;\n        }\n\n        if (currencyType == DubiexLib.CurrencyType.BOOSTABLE_ERC20) {\n            // The contract must implement the BOOSTABLE_ERC20 interface\n            address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(\n                contractAddress,\n                _BOOSTABLE_ERC20_TOKEN_HASH\n            );\n\n            require(\n                implementer != address(0),\n                \"Dubiex: not BoostableERC20 compliant\"\n            );\n            return true;\n        }\n\n        if (currencyType == DubiexLib.CurrencyType.ERC20) {\n            // Using `call` is our last-resort to check if the given contract implements\n            // ERC721, since we can't just call `supportsInterface` directly without reverting\n            // if `contractAddress` doesn't implement it. Unlike above, where we want an ERC721,\n            // so reverting is fine for non-ERC721 contracts.\n            //\n            // NOTE: bytes4(keccak256(supportsInterface(bytes4))) => 0x01ffc9a7\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory result) = contractAddress.call(\n                abi.encodeWithSelector(0x01ffc9a7, _ERC721_INTERFACE_HASH)\n            );\n\n            // The call above must either fail (success = false) or if it succeeds,\n            // return false.\n            bool isERC721 = false;\n            if (result.length > 0) {\n                isERC721 = abi.decode(result, (bool));\n            }\n\n            require(!success || !isERC721, \"Dubiex: ERC20 implements ERC721\");\n\n            // Lastly, we heuristically check if it responds to `balanceOf`.\n            // If it succeeds, we assume it is an ERC20.\n            // NOTE: bytes4(keccak256(balanceOf(address))) => 0x70a08231\n            result = Address.functionCall(\n                contractAddress,\n                abi.encodeWithSelector(0x70a08231, contractAddress)\n            );\n            require(result.length > 0, \"Dubiex: not ERC20 compliant\");\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev Increment the order id counter and return the new id.\n     */\n    function _getNextOrderId(address account) private returns (uint32) {\n        uint32 currentId = _counters[account];\n        assert(currentId < 2**32);\n\n        uint32 nextId = currentId + 1;\n        _counters[account] = nextId;\n\n        return nextId;\n    }\n\n    /**\n     * @dev Get or create order pair alias from the given order pair.\n     */\n    function _getOrCreateOrderPairAlias(DubiexLib.OrderPair memory pair)\n        private\n        returns (uint32)\n    {\n        bytes32 orderPairHash = keccak256(\n            abi.encode(\n                pair.makerContractAddress,\n                pair.takerContractAddress,\n                pair.makerCurrencyType,\n                pair.takerCurrencyType\n            )\n        );\n\n        uint32 orderPairAlias = _orderPairAliasesByHash[orderPairHash];\n        // If it doesn't exist yet, we create it (which makes the make order for the caller a bit more expensive).\n        if (orderPairAlias == 0) {\n            require(\n                _validateCurrencyType(\n                    pair.makerCurrencyType,\n                    pair.makerContractAddress\n                ),\n                \"Dubiex: makerContractAddress and currencyType mismatch\"\n            );\n            require(\n                _validateCurrencyType(\n                    pair.takerCurrencyType,\n                    pair.takerContractAddress\n                ),\n                \"Dubiex: takerContractAddress and currencyType mismatch\"\n            );\n\n            uint32 orderPairAliasCounter = _orderPairAliasCounter;\n            orderPairAliasCounter++;\n\n            orderPairAlias = orderPairAliasCounter;\n\n            _orderPairAliasCounter = orderPairAliasCounter;\n\n            // Write mappings\n            _orderPairAliasesByHash[orderPairHash] = orderPairAlias;\n            _orderPairsByAlias[orderPairAlias] = DubiexLib.packOrderPair(pair);\n        }\n\n        return orderPairAlias;\n    }\n\n    function _safeGetOrderPairByAlias(\n        uint32 orderPairAlias,\n        DubiexLib.OrderPairReadStrategy strategy\n    ) private view returns (DubiexLib.OrderPair memory) {\n        DubiexLib.OrderPair memory _unpackedOrderPair;\n\n        if (strategy == DubiexLib.OrderPairReadStrategy.SKIP) {\n            return _unpackedOrderPair;\n        }\n\n\n            DubiexLib.PackedOrderPair storage _pairStorage\n         = _orderPairsByAlias[orderPairAlias];\n\n        // Read only maker info if requested\n        if (\n            strategy == DubiexLib.OrderPairReadStrategy.MAKER ||\n            strategy == DubiexLib.OrderPairReadStrategy.FULL\n        ) {\n            (\n                address makerContractAddress,\n                DubiexLib.CurrencyType makerCurrencyType\n            ) = DubiexLib.unpackOrderPairAddressType(_pairStorage.makerPair);\n            _unpackedOrderPair.makerContractAddress = makerContractAddress;\n            _unpackedOrderPair.makerCurrencyType = makerCurrencyType;\n\n            require(\n                _unpackedOrderPair.makerCurrencyType !=\n                    DubiexLib.CurrencyType.NULL,\n                \"Dubiex: maker order pair not found\"\n            );\n        }\n\n        // Read only taker info if requested\n        if (\n            strategy == DubiexLib.OrderPairReadStrategy.TAKER ||\n            strategy == DubiexLib.OrderPairReadStrategy.FULL\n        ) {\n            (\n                address takerContractAddress,\n                DubiexLib.CurrencyType takerCurrencyType\n            ) = DubiexLib.unpackOrderPairAddressType(_pairStorage.takerPair);\n            _unpackedOrderPair.takerContractAddress = takerContractAddress;\n            _unpackedOrderPair.takerCurrencyType = takerCurrencyType;\n\n            require(\n                _unpackedOrderPair.takerCurrencyType !=\n                    DubiexLib.CurrencyType.NULL,\n                \"Dubiex: taker order pair not found\"\n            );\n        }\n\n        return _unpackedOrderPair;\n    }\n\n    /**\n     * @dev Tries to set the successor of the order with `ancestorOrderId`.\n     *\n     * - Reverts, if the ancestor exists and already has a successor.\n     * - Returns false, if the ancestor doesn't exist.\n     * - If it succeeds, then it implies that the ancestor hasn't been filled yet and thus\n     * the caller has to ensure that the successor gets hidden.\n     */\n    function _setSuccessorOfAncestor(\n        address account,\n        uint32 ancestorOrderId,\n        uint32 successorOrderId\n    ) private returns (bool) {\n\n            DubiexLib.PackedOrderBookItem[] storage orders\n         = _ordersByAddress[account];\n        uint256 length = orders.length;\n        for (uint256 i = 0; i < length; i++) {\n            DubiexLib.PackedOrderBookItem storage _packed = orders[i];\n\n            uint256 packedData = _packed.packedData;\n\n            // The first 32 bits of the packed data corresponds to the id. By casting to uint32,\n            // we can compare the id without having to unpack the entire thing.\n            uint32 orderId = uint32(packedData);\n            if (orderId == ancestorOrderId) {\n                DubiexLib.UnpackedOrderBookItem memory _unpacked = DubiexLib\n                    .unpackOrderBookItem(packedData);\n\n                // Set successor if none yet\n                if (!_unpacked.flags.hasSuccessor) {\n                    _unpacked.flags.hasSuccessor = true;\n                    _packed.successorOrderId = successorOrderId;\n\n                    // Pack data again and update storage\n                    _packed.packedData = DubiexLib.packOrderBookItem(_unpacked);\n\n                    return true;\n                }\n\n                // Ancestor exists, but has already a successor\n                revert(\"Dubiex: ancestor order already has a successor\");\n            }\n        }\n\n        // Ancestor doesn't exist - so it got filled/cancelled or was never created to begin with.\n        return false;\n    }\n\n    /**\n     * @dev Makes the given successor order visible if it exists.\n     */\n    function _setOrderVisible(address account, uint32 successorOrderId)\n        private\n    {\n\n            DubiexLib.PackedOrderBookItem[] storage orders\n         = _ordersByAddress[account];\n\n        uint256 length = orders.length;\n        for (uint256 i = 0; i < length; i++) {\n            DubiexLib.PackedOrderBookItem storage _packed = orders[i];\n\n            uint256 packedData = _packed.packedData;\n\n            // The first 32 bits of the packed data corresponds to the id. By casting to uint32,\n            // we can compare the id without having to unpack the entire thing.\n            uint32 orderId = uint32(packedData);\n            if (orderId == successorOrderId) {\n                DubiexLib.UnpackedOrderBookItem memory _unpacked = DubiexLib\n                    .unpackOrderBookItem(packedData);\n                _unpacked.flags.isHidden = false;\n\n                // Write updated data\n                _packed.packedData = DubiexLib.packOrderBookItem(_unpacked);\n\n                break;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the order from `account` with the given id from storage\n     * plus the index of it.\n     *\n     * If it cannot be found, then this function reverts, because we expect the\n     * caller to operate on existing orders.\n     */\n    function _safeGetOrder(\n        address account,\n        uint32 id,\n        DubiexLib.OrderPairReadStrategy strategy\n    )\n        private\n        view\n        returns (\n            DubiexLib.PackedOrderBookItem storage,\n            DubiexLib.UnpackedOrderBookItem memory,\n            uint256\n        )\n    {\n\n            DubiexLib.PackedOrderBookItem[] storage orders\n         = _ordersByAddress[account];\n\n        uint256 length = orders.length;\n        for (uint256 i = 0; i < length; i++) {\n            DubiexLib.PackedOrderBookItem storage _packed = orders[i];\n\n            uint256 packedData = _packed.packedData;\n\n            // The first 32 bits of the packed data corresponds to the id. By casting to uint32,\n            // we can compare the id without having to unpack the entire thing.\n            uint32 orderId = uint32(packedData);\n            if (orderId == id) {\n                DubiexLib.UnpackedOrderBookItem memory _unpacked = DubiexLib\n                    .unpackOrderBookItem(packedData);\n\n                // Read the order pair with the given strategy\n                _unpacked.pair = _safeGetOrderPairByAlias(\n                    _unpacked.orderPairAlias,\n                    strategy\n                );\n\n                return (_packed, _unpacked, i);\n            }\n        }\n\n        revert(\"Dubiex: order does not exist\");\n    }\n\n    /**\n     * @dev Returns the order from `account` with the given id from storage\n     * plus the index of it.\n     *\n     * If it cannot be found, then this function does not revert and it's up to the\n     * caller to decide.\n     */\n    function _getOrder(\n        address account,\n        uint32 id,\n        DubiexLib.OrderPairReadStrategy strategy\n    )\n        private\n        view\n        returns (\n            DubiexLib.PackedOrderBookItem storage,\n            DubiexLib.UnpackedOrderBookItem memory,\n            uint256\n        )\n    {\n\n            DubiexLib.PackedOrderBookItem[] storage orders\n         = _ordersByAddress[account];\n\n        uint256 length = orders.length;\n        for (uint256 i = 0; i < length; i++) {\n            DubiexLib.PackedOrderBookItem storage _packed = orders[i];\n\n            uint256 packedData = _packed.packedData;\n\n            // The first 32 bits of the packed data corresponds to the id. By casting to uint32,\n            // we can compare the id without having to unpack the entire thing.\n            uint32 orderId = uint32(packedData);\n            if (orderId == id) {\n                DubiexLib.UnpackedOrderBookItem memory _unpacked = DubiexLib\n                    .unpackOrderBookItem(packedData);\n\n                // Read the order pair with the given strategy\n                // NOTE: This cannot revert when the order exists.\n                _unpacked.pair = _safeGetOrderPairByAlias(\n                    _unpacked.orderPairAlias,\n                    strategy\n                );\n\n                return (_packed, _unpacked, i);\n            }\n        }\n\n        DubiexLib.UnpackedOrderBookItem memory _unpacked;\n        return (emptyOrder, _unpacked, 0);\n    }\n\n    /**\n     * @dev Delete an order of `maker` by index in O(1).\n     */\n    function _deleteOrder(address maker, uint256 index) private {\n\n            DubiexLib.PackedOrderBookItem[] storage orders\n         = _ordersByAddress[maker];\n\n        uint256 length = orders.length;\n        // swap and pop, changes the order\n        if (index != length - 1) {\n            // Move last item to the position of the to-be-deleted item (`index`)\n            orders[index] = orders[length - 1];\n        }\n\n        orders.pop();\n    }\n\n    //---------------------------------------------------------------\n    // Fuel\n    //---------------------------------------------------------------\n\n    /**\n     * @dev Burn `fuel` from `from`.\n     */\n    function _burnFuel(address from, BoosterFuel memory fuel)\n        internal\n        returns (uint96)\n    {\n        // Burn unlocked PRPS\n        if (fuel.unlockedPrps > 0) {\n            IBoostableERC20(address(_prps)).burnFuel(\n                from,\n                TokenFuel({\n                    tokenAlias: 0, /* UNLOCKED PRPS */\n                    amount: fuel.unlockedPrps\n                })\n            );\n\n            return 0;\n        }\n\n        // Burn locked PRPS\n        if (fuel.lockedPrps > 0) {\n            IBoostableERC20(address(_prps)).burnFuel(\n                from,\n                TokenFuel({\n                    tokenAlias: 1, /* LOCKED PRPS */\n                    amount: fuel.lockedPrps\n                })\n            );\n\n            return 0;\n        }\n\n        // Burn DUBI from balance\n        if (fuel.dubi > 0) {\n            IBoostableERC20(address(_dubi)).burnFuel(\n                from,\n                TokenFuel({\n                    tokenAlias: 2, /* DUBI */\n                    amount: fuel.dubi\n                })\n            );\n\n            return 0;\n        }\n\n        // The intrinsic fuel is only supported for ERC721 tokens via\n        // the 'safeTransferFrom' payload.\n        if (fuel.intrinsicFuel > 0) {\n            return fuel.intrinsicFuel;\n        }\n\n        // No fuel\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transfered from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC721Receiver.sol\";\n\n  /**\n   * @dev Implementation of the {IERC721Receiver} interface.\n   *\n   * Accepts all token transfers. \n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n   */\ncontract ERC721Holder is IERC721Receiver {\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC1820Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\n    external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/EnumerableSet.sol\";\nimport \"../../utils/EnumerableMap.sol\";\nimport \"../../utils/Strings.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n\n        // If there is no base URI, return the token URI.\n        if (bytes(_baseURI).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(_baseURI, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(_baseURI, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mecanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    function _approve(address to, uint256 tokenId) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        return _get(map, key, \"EnumerableMap: nonexistent key\");\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint256(_get(map._inner, bytes32(key))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint256(_get(map._inner, bytes32(key), errorMessage)));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = byte(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/dummy/DummyERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Only used for testing Dubiex\ncontract DummyVanillaERC20 is ERC20, Ownable {\n    string public constant NAME = \"Dummy\";\n    string public constant SYMBOL = \"DUMMY\";\n\n    constructor() public ERC20(NAME, SYMBOL) Ownable() {}\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n"
    },
    "contracts/dummy/DummyERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract DummyVanillaERC721 is ERC721 {\n    string public constant NAME = \"Vanilla ERC721\";\n    string public constant SYMBOL = \"VANILLA-\";\n\n    constructor() public ERC721(NAME, SYMBOL) {}\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}