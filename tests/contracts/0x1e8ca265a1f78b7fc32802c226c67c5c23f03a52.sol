{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "details": {
        "constantOptimizer": true,
        "cse": true,
        "deduplicate": true,
        "inliner": true,
        "jumpdestRemover": true,
        "orderLiterals": true,
        "peephole": true,
        "yul": true,
        "yulDetails": {
          "optimizerSteps": "dhfoDgvulfnTUtnIf",
          "stackAllocation": true
        }
      },
      "runs": 2000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/DenOfAlgol.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./interfaces/IShatteredEON.sol\";\nimport \"./interfaces/IImperialGuild.sol\";\nimport \"./interfaces/IRAW.sol\";\nimport \"./interfaces/IColonist.sol\";\nimport \"./interfaces/IPirates.sol\";\nimport \"./ERC20.sol\";\n\ncontract DenOfAlgol is Pausable {\n    uint8 public onosiaLiquorId;\n    // shard Ids\n    uint256 public spearId;\n    uint256 public templeId;\n    uint256 public riotId;\n    uint256 public phantomId;\n\n    // activate shard minting \n    bool public shardsActive;\n    // address => used in allowing system communication between contracts\n    mapping(address => bool) private admins;\n    //owner\n    address public auth;\n    // reference to raw resource contract\n    address public EON;\n\n    uint256 public spearPriceEon;\n    uint256 public templePriceEon;\n    uint256 public riotPriceEon;\n    uint256 public phantomPriceEon;\n    uint256 public onosiaPriceEon;\n\n    \n    IRAW public RAW;\n    // reference to refined EON for minting and burning\n    IPirates public pirateNFT;\n    // reference to the colonist NFT collection\n    IColonist public colonistNFT;\n    // reference to the ImperialGuild collection\n    IImperialGuild public imperialGuild;\n    //reference to main game logic\n    IShatteredEON public shattered;\n\n    constructor() {\n        _pause();\n        auth = msg.sender;\n        admins[msg.sender] = true;\n    }\n\n    modifier noCheaters() {\n        uint256 size = 0;\n        address acc = msg.sender;\n        assembly {\n            size := extcodesize(acc)\n        }\n\n        require(\n            admins[msg.sender] || (msg.sender == tx.origin && size == 0),\n            \"you're trying to cheat!\"\n        );\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == auth);\n        _;\n    }\n\n    /** CRITICAL TO SETUP */\n    modifier requireContractsSet() {\n        require(\n            address(RAW) != address(0) &&\n                address(EON) != address(0) &&\n                address(pirateNFT) != address(0) &&\n                address(colonistNFT) != address(0) &&\n                address(imperialGuild) != address(0) &&\n                address(shattered) != address(0),\n            \"Contracts not set\"\n        );\n        _;\n    }\n\n    function setContracts(\n        address _RAW,\n        address _EON,\n        address _pirateNFT,\n        address _colonistNFT,\n        address _imperialGuild,\n        address _shatteredEON\n    ) external onlyOwner {\n        RAW = IRAW(_RAW);\n        EON = _EON;\n        pirateNFT = IPirates(_pirateNFT);\n        colonistNFT = IColonist(_colonistNFT);\n        imperialGuild = IImperialGuild(_imperialGuild);\n        shattered = IShatteredEON(_shatteredEON);\n    }\n\n    // $rEON or EON exchange amount handled within ImperialGuild contract\n    // Will fail if sender doesn't have enough $rEON or $EON or does not\n    // provide the required sacrafices,\n    // Transfer does not need approved,\n    // as there is established trust between this contract and the ImperialGuild contract\n\n    function buySpear(bool RAWPayment) external whenNotPaused noCheaters {\n        require(shardsActive = true, \"Shard minting not available yet\");\n        require(tx.origin == msg.sender, \"Only EOA\");\n        if (RAWPayment) {\n            imperialGuild.mint(spearId, 1, 1, msg.sender);\n        } else {\n            require(ERC20(EON).balanceOf(msg.sender) >= spearPriceEon, \"Not enough EON\");\n            imperialGuild.mint(spearId, 0, 1, msg.sender);\n        }\n    }\n\n    function buyTemple(bool RAWPayment) external whenNotPaused noCheaters {\n        require(shardsActive = true, \"Shard minting not available yet\");\n        require(tx.origin == msg.sender, \"Only EOA\");\n        if (RAWPayment) {\n            imperialGuild.mint(templeId, 1, 1, msg.sender);\n        } else {\n            require(ERC20(EON).balanceOf(msg.sender) >= templePriceEon, \"Not enough EON\");\n            imperialGuild.mint(templeId, 0, 1, msg.sender);\n        }\n    }\n\n    function makeOnosiaLiquor(uint16 qty, bool RAWPayment)\n        external\n        whenNotPaused\n        noCheaters\n    {\n        require(tx.origin == msg.sender);\n        require(onosiaLiquorId > 0, \"wrong tokenId\");\n        if (RAWPayment) {\n            imperialGuild.mint(onosiaLiquorId, 1, qty, msg.sender);\n        } else {\n            require(ERC20(EON).balanceOf(msg.sender) >= (onosiaPriceEon * qty), \"Not enough EON\");\n            imperialGuild.mint(onosiaLiquorId, 0, qty, msg.sender);\n        }\n    }\n\n    function buyRiot(uint256 colonistId, bool RAWPayment)\n        external\n        whenNotPaused\n        noCheaters\n    {\n        require(shardsActive = true, \"Shard minting not available yet\");\n        require(tx.origin == msg.sender);\n        // Must check this, as getTokenTraits will be allowed since this contract is an admin\n        if (RAWPayment) {\n            // This will check if origin is the owner of the token\n            colonistNFT.burn(colonistId);\n            imperialGuild.mint(riotId, 1, 1, msg.sender);\n        } else {\n            // check origin of owner of token\n            require(ERC20(EON).balanceOf(msg.sender) >= riotPriceEon, \"Not enough EON\");\n            colonistNFT.burn(colonistId);\n            imperialGuild.mint(riotId, 0, 1, msg.sender);\n        }\n    }\n\n    function buyPhantom(\n        uint256 colonistId,\n        uint256 pirateId,\n        bool RAWPayment\n    ) external whenNotPaused noCheaters {\n        require(shardsActive = true, \"Shard minting not available yet\");\n        require(tx.origin == msg.sender);\n        // Must check this, as getTokenTraits will be allowed since this contract is an admin\n        if (RAWPayment) {\n            // check origin of tokens owner\n            colonistNFT.burn(colonistId);\n            pirateNFT.burn(pirateId);\n            imperialGuild.mint(phantomId, 1, 1, msg.sender);\n        } else {\n            require(ERC20(EON).balanceOf(msg.sender) >= phantomPriceEon , \"Not enough EON\");\n            // check origin of token owner\n            colonistNFT.burn(colonistId);\n            pirateNFT.burn(pirateId);\n            imperialGuild.mint(phantomId, 0, 1, msg.sender);\n        }\n    }\n\n    function setOnosiaLiquorId(uint8 id) external onlyOwner {\n        onosiaLiquorId = id;\n    }\n\n    function setShardIds(\n        uint256 spear,\n        uint256 temple,\n        uint256 riot,\n        uint256 phantom\n    ) external onlyOwner {\n        spearId = spear;\n        templeId = temple;\n        riotId = riot;\n        phantomId = phantom;\n    }\n\n    function setEonPrices(\n        uint256 _spearPriceEon,\n        uint256 _templePriceEon,\n        uint256 _riotPriceEon,\n        uint256 _phantomPriceEon,\n        uint256 _onosiaLiquorPriceEon\n    ) external onlyOwner {\n        spearPriceEon = _spearPriceEon;\n        templePriceEon = _templePriceEon;\n        riotPriceEon = _riotPriceEon;\n        phantomPriceEon = _phantomPriceEon;\n        onosiaPriceEon = _onosiaLiquorPriceEon;\n    }\n\n    /**\n     * enables owner to pause / unpause contract\n     */\n    function setPaused(bool _paused) external requireContractsSet onlyOwner {\n        if (_paused) _pause();\n        else _unpause();\n    }\n\n    /**\n     * enables an address to mint / burn\n     * @param addr the address to enable\n     */\n    function addAdmin(address addr) external onlyOwner {\n        admins[addr] = true;\n    }\n\n    function toggleShardMinting(bool _shardsActive) external onlyOwner {\n        shardsActive = _shardsActive;\n    }\n\n    /**\n     * disables an address from minting / burning\n     * @param addr the address to disable\n     */\n    function removeAdmin(address addr) external onlyOwner {\n        admins[addr] = false;\n    }\n}\n"
    },
    "contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max)\n            allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            PERMIT_TYPEHASH,\n                            owner,\n                            spender,\n                            value,\n                            nonces[owner]++,\n                            deadline\n                        )\n                    )\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n\n            require(\n                recoveredAddress != address(0) && recoveredAddress == owner,\n                \"INVALID_SIGNER\"\n            );\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return\n            block.chainid == INITIAL_CHAIN_ID\n                ? INITIAL_DOMAIN_SEPARATOR\n                : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "contracts/interfaces/IColonist.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface IColonist {\r\n    // struct to store each Colonist's traits\r\n    struct Colonist {\r\n        bool isColonist;\r\n        uint8 background;\r\n        uint8 body;\r\n        uint8 shirt;\r\n        uint8 jacket;\r\n        uint8 jaw;\r\n        uint8 eyes;\r\n        uint8 hair;\r\n        uint8 held;\r\n        uint8 gen;\r\n    }\r\n\r\n    struct HColonist {\r\n        uint8 Legendary;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function isOwner(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function minted() external returns (uint16);\r\n\r\n    function totalCir() external returns (uint256);\r\n\r\n    function _mintColonist(address recipient, uint256 seed) external;\r\n\r\n    function _mintToHonors(address recipient, uint256 seed) external;\r\n\r\n    function _mintHonors(address recipient, uint8 id) external;\r\n\r\n    function burn(uint256 tokenId) external;\r\n\r\n    function getMaxTokens() external view returns (uint256);\r\n\r\n    function getPaidTokens() external view returns (uint256);\r\n\r\n    function getTokenTraitsColonist(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (Colonist memory);\r\n\r\n    function getTokenTraitsHonors(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (HColonist memory);\r\n\r\n    function tokenNameByIndex(uint256 index)\r\n        external\r\n        view\r\n        returns (string memory);\r\n\r\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\r\n\r\n    function nameColonist(uint256 tokenId, string memory newName) external;\r\n}\r\n"
    },
    "contracts/interfaces/IImperialGuild.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface IImperialGuild {\r\n\r\n    function getBalance(\r\n        address account,\r\n        uint256 id\r\n    ) external returns(uint256);\r\n\r\n    function mint(\r\n        uint256 typeId,\r\n        uint256 paymentId,\r\n        uint16 qty,\r\n        address recipient\r\n    ) external;\r\n\r\n    function burn(\r\n        uint256 typeId,\r\n        uint16 qty,\r\n        address burnFrom\r\n    ) external;\r\n\r\n    function handlePayment(uint256 amount) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interfaces/IPirates.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPirates {\r\n    // struct to store each Colonist's traits\r\n    struct Pirate {\r\n        bool isPirate;\r\n        uint8 sky;\r\n        uint8 cockpit;\r\n        uint8 base;\r\n        uint8 engine;\r\n        uint8 nose;\r\n        uint8 wing;\r\n        uint8 weapon1;\r\n        uint8 weapon2;\r\n        uint8 rank;\r\n    }\r\n\r\n    struct HPirates {\r\n        uint8 Legendary;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) external;\r\n\r\n    function minted() external returns (uint16);\r\n\r\n    function piratesMinted() external returns (uint16);\r\n\r\n    function isOwner(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function _mintPirate(address recipient, uint256 seed) external;\r\n\r\n    function burn(uint256 tokenId) external;\r\n\r\n    function getTokenTraitsPirate(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (Pirate memory);\r\n\r\n    function getTokenTraitsHonors(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (HPirates memory);\r\n\r\n    function tokenNameByIndex(uint256 index)\r\n        external\r\n        view\r\n        returns (string memory);\r\n    \r\n    function isHonors(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function updateOriginAccess(uint16[] memory tokenIds) external;\r\n\r\n    function getTokenWriteBlock(uint256 tokenId) \r\n    external \r\n    view  \r\n    returns(uint64);\r\n\r\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\r\n\r\n    function namePirate(uint256 tokenId, string memory newName) external;\r\n}\r\n"
    },
    "contracts/interfaces/IRAW.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\npragma solidity ^0.8.0;\n\ninterface IRAW {\n\n    function updateOriginAccess(address user) external;\n\n\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external returns(uint256);\n\n    function mint(\n        uint256 typeId,\n        uint256 qty,\n        address recipient\n    ) external;\n\n    function burn(\n        uint256 typeId,\n        uint256 qty,\n        address burnFrom\n    ) external;\n\n    function updateMintBurns(\n        uint256 typeId,\n        uint256 mintQty,\n        uint256 burnQty\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external;\n\n}\n"
    },
    "contracts/interfaces/IShatteredEON.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IShatteredEON {}\r\n"
    }
  }
}}