{{
  "language": "Solidity",
  "sources": {
    "contracts/ZONE.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./lib/Ownable.sol\";\nimport \"./lib/Global.sol\";\n\ncontract CompBase is Ownable {\n    using SafeMath for uint256;\n\n    /// @notice EIP-20 token name for this token\n    string public constant name = \"GridZone.io\";\n\n    /// @notice EIP-20 token symbol for this token\n    string public constant symbol = \"ZONE\";\n\n    /// @notice EIP-20 token decimals for this token\n    uint8 public constant decimals = 18;\n\n    // Total number of tokens in circulation\n    uint256 internal constant _teamSupply = 3360000 * (10 ** uint256(decimals)); // 12%\n    uint256 internal constant _advisorsSupply = 980000 * (10 ** uint256(decimals)); // 3.5%\n    uint256 internal constant _genesisSupply = 2800000 * (10 ** uint256(decimals)); // 10%\n    uint256 internal constant _publicSupply = 420000 * (10 ** uint256(decimals)); // 1.5%\n    uint256 internal constant _treasurySupply = 3640000 * (10 ** uint256(decimals)); // 13%\n    uint256 internal constant _airdropSupply = 420000 * (10 ** uint256(decimals)); // 1.5%\n    uint256 internal constant _ecosystemSupply = 16380000 * (10 ** uint256(decimals)); // 58.5%\n\n    uint256 internal constant _genesisEthCapacity = 100e18; // 100 ETH\n    uint256 internal _publicEthCapacity = 2000e18; // 2000 ETH\n\n    uint256 private _totalSupply = 0;\n    uint256 private _totalLockedTokens = 0;\n\n    /**\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n     * set once during construction.\n     */\n    uint256 private constant _cap = _teamSupply + _advisorsSupply + _genesisSupply\n        + _publicSupply + _treasurySupply + _airdropSupply + _ecosystemSupply;\n\n    // Allowance amounts on behalf of others\n    mapping (address => mapping (address => uint256)) internal allowances;\n\n    // Official record of token balances for each account\n    mapping (address => uint256) internal _balances;\n\n    /// @notice A record of each accounts delegate\n    mapping (address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    // A record of the locked token\n    uint8 internal constant LOCK_TYPE_GENESIS = 0;\n    uint8 internal constant LOCK_TYPE_BLACKLIST = 1;\n    struct LockedToken {\n        uint256 id;\n        uint8 lockType;\n        uint256 amount;\n        uint256 start;\n        uint256 end;\n    }\n    mapping(address => LockedToken[]) internal _lockedTokens;\n    uint256 private lastLockId = 0;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /// @notice token locked event\n    event TokenLocked(address indexed account, uint256 amount, uint8 lockType, uint256 end);\n    event TokenUnlocked(address indexed account, uint256 amount, uint8 lockType);\n\n    /**\n     * @notice Construct a new GridZone token\n     * @param ownerAddress Owner address of the GridZone token\n     */\n    constructor(address ownerAddress) Ownable(ownerAddress) public {\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply.add(_totalLockedTokens);\n    }\n\n    /**\n     * @dev Returns the cap on the token's total supply.\n     */\n    function cap() public pure returns (uint256) {\n        return _cap;\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        uint256 amount = _balances[account];\n        return amount.add(getLockedAmount(account));\n    }\n\n    function getLockedAmount(address account) public view returns (uint256) {\n        LockedToken[] memory lockedTokensRef = _lockedTokens[account];\n        uint256 length = lockedTokensRef.length;\n\n        uint256 amount = 0;\n        for (uint256 i = 0; i < length; i ++) {\n            amount = amount.add(lockedTokensRef[i].amount);\n        }\n        return amount;\n    }\n\n    /**\n     * @notice Gets the available votes balance for `account` regarding locked token\n     * @param account The address to get votes balance\n     * @return The number of available votes balance for `account`\n     */\n    function voteBalanceOf(address account) public view returns (uint256) {\n        uint256 amount = _balances[account];\n\n        LockedToken[] memory lockedTokensRef = _lockedTokens[account];\n        uint256 length = lockedTokensRef.length;\n        for (uint256 i = 0; i < length; i ++) {\n            if (lockedTokensRef[i].lockType != LOCK_TYPE_BLACKLIST) {\n                amount = amount.add(lockedTokensRef[i].amount);\n            }\n        }\n\n        return amount;\n    }\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint256) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint rawAmount) external returns (bool) {\n        _approve(_msgSender(), spender, rawAmount);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ZONE: approve from the zero address\");\n        require(spender != address(0), \"ZONE: approve to the zero address\");\n\n        allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 rawAmount) external returns (bool) {\n        _transferTokens(msg.sender, dst, rawAmount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 rawAmount) external returns (bool) {\n        address spender = msg.sender;\n        uint256 spenderAllowance = allowances[src][spender];\n\n        if (spender != src && spenderAllowance != uint256(-1)) {\n            uint256 newAllowance = spenderAllowance.sub(rawAmount);\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, rawAmount);\n        return true;\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"ZONE::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"ZONE::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"ZONE::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint256) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ZONE::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint256 delegatorBalance = voteBalanceOf(delegator);\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _transferTokens(address src, address dst, uint256 amount) internal {\n        require(src != address(0), \"ZONE::_transferTokens: cannot transfer from the zero address\");\n        require(dst != address(0), \"ZONE::_transferTokens: cannot transfer to the zero address\");\n\n        _beforeTokenTransfer(src, dst, amount);\n\n        _balances[src] = _balances[src].sub(amount);\n        _balances[dst] = _balances[dst].add(amount);\n        emit Transfer(src, dst, amount);\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint256 oldVotes, uint256 newVotes) internal {\n      uint32 blockNumber = safe32(block.number, \"ZONE::_writeCheckpoint: block number exceeds 32 bits\");\n\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n      } else {\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n          numCheckpoints[delegatee] = nCheckpoints + 1;\n      }\n\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ZONE: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n\n        _moveDelegates(address(0), delegates[account], amount);\n    }\n\n    function _mintLockedToken(address account, uint256 amount, uint8 lockType, uint256 end) internal {\n        require(account != address(0), \"ZONE: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalLockedTokens = _totalLockedTokens.add(amount);\n\n        LockedToken memory lockedToken = LockedToken({\n            id: lastLockId++,\n            lockType: lockType,\n            amount: amount,\n            start: now,\n            end: end\n        });\n        _lockedTokens[account].push(lockedToken);\n\n        emit Transfer(address(0), account, amount);\n\n        if (lockType != LOCK_TYPE_BLACKLIST) {\n            _moveDelegates(address(0), delegates[account], amount);\n        }\n        emit TokenLocked(account, amount, lockType, end);\n    }\n\n    function _unlockToken(address account, uint256 lockId) internal {\n        LockedToken[] storage lockedTokensRef = _lockedTokens[account];\n        uint256 length = lockedTokensRef.length;\n        require(0 < length, \"ZONE: No locked token\");\n\n        bool found = false;\n        uint256 index = 0;\n        for (uint256 i = 0; i < length; i++) {\n            if (lockedTokensRef[i].id == lockId) {\n                index = i;\n                found = true;\n                break;\n            }\n        }\n        require(found == true, \"ZONE: lockId invalid\");\n\n        uint256 amount = lockedTokensRef[index].amount;\n        uint8 lockType = lockedTokensRef[index].lockType;\n\n        _totalLockedTokens = _totalLockedTokens.sub(amount);\n        _totalSupply = _totalSupply.add(amount);\n\n        // remove item from list\n        uint256 lastIndex = length - 1;\n        if (index < lastIndex) {\n            lockedTokensRef[index] = lockedTokensRef[lastIndex];\n        }\n        lockedTokensRef.pop();\n        _balances[account] = _balances[account].add(amount);\n\n        if (lockType == LOCK_TYPE_BLACKLIST) {\n            _moveDelegates(address(0), delegates[account], amount);\n        }\n        emit TokenUnlocked(account, amount, lockType);\n    }\n\n    function getLockedTokens(address account) external view returns (LockedToken[] memory) {\n        LockedToken[] memory lockedTokensRef = _lockedTokens[account];\n        return lockedTokensRef;\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ZONE: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ZONE: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n\n        _moveDelegates(delegates[account], address(0), amount);\n    }\n\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - minted tokens must not cause the total supply to go over the cap.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) view internal {\n        if (from == address(0)) { // When minting tokens\n            require(totalSupply().add(amount) <= _cap, \"Capped: cap exceeded\");\n        }\n    }\n}\n\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is CompBase {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public {\n        address spender = _msgSender();\n        uint256 spenderAllowance = allowances[account][spender];\n        uint256 decreasedAllowance = spenderAllowance.sub(amount, \"ZONE::burnFrom: burn amount exceeds allowance\");\n\n        _approve(account, spender, decreasedAllowance);\n        _burn(account, amount);\n    }\n}\n\ncontract ZONE is CompBase, ERC20Burnable {\n    using SafeMath for uint256;\n\n    uint256 public immutable launchTime;\n\n    address public immutable vault;\n\n    uint256 private _genesisRate;\n    uint256 private _publicRate;\n    uint256 public immutable genesisSaleEndTime;\n    uint256 public immutable genesisSaleUnlockTime;\n\n    // total purchased eth amount during ICO. The unit is wei\n    uint256 public genesisSaleBoughtEth = 0;\n    uint256 public publicSaleBoughtEth = 0;\n\n    uint256 public genesisSaleSoldToken = 0;\n    uint256 public publicSaleSoldToken = 0;\n\n    bool private _genesisSaleFinished = false;\n    bool private _publicSaleFinished = false;\n\n    struct Vest {\n        address beneficiary;\n        uint256 start;\n        uint256 cliff;\n        uint256 duration;\n        uint256 amount;\n        uint256 claimedAmount;\n        bool revoked;\n    }\n    mapping (address => Vest) public vests;\n\n    uint16[] private quarterlyRate; // sum is same with quarterlyRateDenominator\n    uint16 private constant quarterlyRateDenominator = 10000;\n    uint256 public claimedEcosystemVest = 0;\n\n    address private governorTimelock;\n\n    event VestAdded(address indexed beneficiary, uint256 start, uint256 cliff, uint256 duration, uint256 amount);\n    event VestClaimed(address indexed beneficiary, uint256 amount);\n    event EcosystemVestClaimed(address indexed account, uint256 amount);\n    event SoldOnGenesisSale(address indexed buyer, uint256 ethAmount, uint256 tokenAmount);\n    event SoldOnPublicSale(address indexed buyer, uint256 ethAmount, uint256 tokenAmount);\n    event GenesisSaleFinished(uint256 boughtEth, uint256 soldToken);\n    event PublicSaleFinished(uint256 boughtEth, uint256 soldToken);\n    event GenesisSaleRateChanged(uint256 newRate);\n    event PublicSaleRateChanged(uint256 newRate);\n    event PublicSaleEthCapacityChanged(uint256 newRate, uint256 newEthCapacity);\n\n    constructor(address owner_, address vault_, address advisors_, address treasury_) CompBase(owner_) public {\n        require(owner_ != vault_, \"ZONE: You specified owner address as an vault address\");\n        launchTime = now;\n        quarterlyRate = [3182, 2676, 2250, 1892];\n\n        vault = vault_;\n\n        _genesisRate = _genesisSupply.mul(10).div(_genesisEthCapacity).div(12); // 2/12 is for bonuses\n        _publicRate = _publicSupply.div(_publicEthCapacity);\n        genesisSaleEndTime = now + GLOBAL.SECONDS_IN_MONTH * 3;\n        genesisSaleUnlockTime = now + GLOBAL.SECONDS_IN_MONTH * 4;\n\n        AddVest(owner_, now, 0, GLOBAL.SECONDS_IN_YEAR * 2, _teamSupply);\n        AddVest(advisors_, now, 0, GLOBAL.SECONDS_IN_YEAR, _advisorsSupply);\n\n        _mintLockedToken(treasury_, _treasurySupply, LOCK_TYPE_BLACKLIST, now + GLOBAL.SECONDS_IN_YEAR);\n        _mint(vault_, _airdropSupply);\n    }\n\n    modifier onlyCommunity() {\n        require(msg.sender == governorTimelock, \"ZONE: The caller is not the governance timelock contract.\");\n        _;\n    }\n\n    modifier onlyEndUser {\n        require(msg.sender == tx.origin, \"ZONE: Only end-user\");\n        _;\n    }\n\n    function setGovernorTimelock(address governorTimelock_) external onlyOwner  {\n        governorTimelock = governorTimelock_;\n    }\n\n    /**\n    * @param beneficiary address of the beneficiary to whom vested tokens are transferred\n    * @param cliff duration in seconds of the cliff in which tokens will begin to vest\n    * @param duration duration in seconds of the period in which the tokens will vest\n    */\n    function AddVest(address beneficiary, uint256 start, uint256 cliff, uint256 duration, uint256 amount) internal {\n        require(beneficiary != address(0), \"ZONE::AddVest Invalid beneficiary\");\n        require(cliff <= duration, \"ZONE::AddVest cliff > duration\");\n\n        Vest memory vest = Vest({\n            beneficiary: beneficiary,\n            start: start,\n            cliff: start.add(cliff),\n            duration: duration,\n            amount: amount,\n            claimedAmount: 0,\n            revoked: false\n        });\n\n        vests[beneficiary] = vest;\n        emit VestAdded(beneficiary, start, cliff, duration, amount);\n    }\n\n    function calculateVestClaim(address beneficiary) public view returns (uint256 vestedAmount, uint256 claimedAmount) {\n        Vest storage vest = vests[beneficiary];\n        if (vest.beneficiary != beneficiary) {\n            // Invalid beneficiary\n            return (0, 0);\n        }\n\n        if (now < vest.cliff) {\n            // For vest created with a future start date, that hasn't been reached, return 0, 0\n            return (0, vest.claimedAmount);\n        } else if (vest.revoked == true) {\n            return (vest.claimedAmount, vest.claimedAmount);\n        } else if (vest.start.add(vest.duration) <= now) {\n            return (vest.amount, vest.claimedAmount);\n        } else {\n            vestedAmount = vest.amount.mul(now.sub(vest.start)).div(vest.duration);\n            return (vestedAmount, vest.claimedAmount);\n        }\n    }\n\n    function claimVestedToken(address beneficiary) external {\n        (uint256 vested, uint256 claimed) = calculateVestClaim(beneficiary);\n        require(claimed < vested, \"ZONE: No claimable token\");\n\n        uint256 fund = vested.sub(claimed);\n        vests[beneficiary].claimedAmount = vested;\n        _mint(beneficiary, fund);\n        emit VestClaimed(beneficiary, fund);\n    }\n\n    function revokeVest(address beneficiary) external onlyCommunity {\n        Vest storage vest = vests[beneficiary];\n        require(vest.beneficiary == beneficiary, \"ZONE: Invalid beneficiary\");\n        require(vest.revoked == false, \"ZONE: Already revoked\");\n\n        uint256 fund = vest.amount.sub(vest.claimedAmount);\n        if (0 < fund) {\n            vest.claimedAmount = vest.amount;\n            _mint(beneficiary, fund);\n            emit VestClaimed(beneficiary, fund);\n        }\n        vest.revoked = true;\n    }\n\n    //\n    // Unlock token\n    //\n    function getUnlockableAmount(address account) public view returns (uint256) {\n        LockedToken[] memory lockedTokensRef = _lockedTokens[account];\n        uint256 length = lockedTokensRef.length;\n\n        uint256 amount = 0;\n        for (uint256 i = 0; i < length; i ++) {\n            if (_isUnlockable(lockedTokensRef[i].lockType, lockedTokensRef[i].end) == true) {\n                amount = amount.add(lockedTokensRef[i].amount);\n            }\n        }\n        return amount;\n    }\n\n    function Unlock(address account) public returns (uint256) {\n        LockedToken[] memory lockedTokensRef = _lockedTokens[account];\n        uint256 length = lockedTokensRef.length;\n        bool unlocked = false;\n\n        for (uint256 i = 0; i < length; i ++) {\n            if (_isUnlockable(lockedTokensRef[i].lockType, lockedTokensRef[i].end) == true) {\n                _unlockToken(account, lockedTokensRef[i].id);\n                unlocked = true;\n            }\n        }\n        require(unlocked, \"ZONE: No unlockable token.\");\n    }\n\n    function _isUnlockable(uint8 lockType, uint256 end) internal view returns (bool) {\n        if (end <= now) {\n            return true;\n        }\n        if ((lockType == LOCK_TYPE_GENESIS) && _publicSaleFinished) {\n            return true;\n        }\n        return false;\n    }\n\n    function revokeBlacklistLock(address account) external onlyCommunity {\n        LockedToken[] memory lockedTokensRef = _lockedTokens[account];\n        uint256 length = lockedTokensRef.length;\n\n        for (uint256 i = 0; i < length; i ++) {\n            if (lockedTokensRef[i].lockType == LOCK_TYPE_BLACKLIST) {\n                _unlockToken(account, lockedTokensRef[i].id);\n            }\n        }\n    }\n\n    //\n    // Quarterly vesting for ecosystem\n    //\n    function calculateEcosystemVested() public view returns (uint256 vestedAmount) {\n        uint256 quartersCount = now.sub(launchTime).div(GLOBAL.SECONDS_IN_QUARTER);\n        uint256 yearsCount = quartersCount.div(GLOBAL.QUARTERS_IN_YEAR);\n        uint256 currentQurter = quartersCount.mod(GLOBAL.QUARTERS_IN_YEAR);\n        uint256 yearSupply = _ecosystemSupply >> (yearsCount + 1);\n\n        if (0 < yearsCount) {\n            // _ecosystemSupply * (1 - 1 / (2*yearsCount))\n            vestedAmount =  _ecosystemSupply.sub(_ecosystemSupply.div(2).div(yearsCount));\n        } else {\n            vestedAmount = 0;\n        }\n\n        for (uint8 quarter = 0; quarter <= currentQurter; quarter ++) {\n            uint256 vestedInQuarter = yearSupply.mul(quarterlyRate[quarter]).div(quarterlyRateDenominator);\n            vestedAmount = vestedAmount.add(vestedInQuarter);\n        }\n        return vestedAmount;\n    }\n\n    function claimEcosystemVest() external {\n        uint256 vested = calculateEcosystemVested();\n        require (claimedEcosystemVest < vested, \"ZONE: No claimable token for the ecosystem.\");\n\n        uint256 fund = vested.sub(claimedEcosystemVest);\n        claimedEcosystemVest = vested;\n        _mint(vault, fund);\n        emit EcosystemVestClaimed(vault, fund);\n    }\n\n    function revokeEcosystemVest() external onlyCommunity {\n        require (claimedEcosystemVest < _ecosystemSupply, \"ZONE: All tokens already have been claimed for the ecosystem.\");\n\n        uint256 fund = _ecosystemSupply.sub(claimedEcosystemVest);\n        claimedEcosystemVest = _ecosystemSupply;\n        _mint(vault, fund);\n        emit EcosystemVestClaimed(vault, fund);\n    }\n\n    //\n    // Genesis and Public sale\n    //\n    function isGenesisSaleFinished() external view returns (bool) {\n        if (_genesisSaleFinished == true || genesisSaleEndTime <= now) {\n            return true;\n        }\n        return false;\n    }\n\n    function isPublicSaleFinished() external view returns (bool) {\n        return _publicSaleFinished;\n    }\n\n    // Crowds Sale contains both the Genesis sale and the Public sale\n    function isCrowdsaleFinished() external view returns (bool) {\n        if (_publicSaleFinished) return true;\n        if (genesisSaleEndTime <= now) return false;\n        if (_genesisSaleFinished) return true;\n        return false;\n    }\n\n    function rate() public view returns (uint256) {\n        return (now < genesisSaleEndTime) ? _genesisRate : _publicRate;\n    }\n\n    function getGenesisSaleRate() external view returns(uint256) {\n        return _genesisRate;\n    }\n\n    function setGenesisSaleRate(uint256 newRate) external onlyOwner {\n        require(0 < newRate, \"ZONE: The rate can't be 0.\");\n        _genesisRate = newRate;\n        emit GenesisSaleRateChanged(_genesisRate);\n    }\n\n    function getPublicSaleRate() external view returns(uint256) {\n        return _publicRate;\n    }\n\n    function setPublicSaleRate(uint256 newRate) public onlyOwner {\n        require(0 < newRate, \"ZONE: The rate can't be 0.\");\n        _publicRate = newRate;\n        emit PublicSaleRateChanged(_publicRate);\n    }\n\n    function getPublicSaleEthCapacity() external view returns(uint256) {\n        return _publicEthCapacity;\n    }\n\n    function setPublicSaleEthCapacity(uint256 newEthCapacity) public onlyOwner {\n        require(publicSaleBoughtEth < newEthCapacity, \"ZONE: The capacity must be greater than the already bought amount in the public sale.\");\n\n        _publicRate = _publicSupply.sub(publicSaleSoldToken).div(newEthCapacity.sub(publicSaleBoughtEth));\n        _publicEthCapacity = newEthCapacity;\n        emit PublicSaleEthCapacityChanged(_publicRate, _publicEthCapacity);\n    }\n\n    function finishCrowdsale() external onlyOwner  {\n        _finishGenesisSale();\n       if (genesisSaleEndTime <= now) {\n           _finishPublicSale();\n       }\n    }\n    \n    function _finishGenesisSale() private {\n        if (_genesisSaleFinished) return;\n        _genesisSaleFinished = true;\n\n        uint256 leftOver = _genesisSupply.sub(genesisSaleSoldToken);\n        if (leftOver > 0) {\n            _mint(owner(), leftOver);\n        }\n        emit GenesisSaleFinished(genesisSaleBoughtEth, genesisSaleSoldToken);\n    }\n\n    function _finishPublicSale() private {\n        if (_publicSaleFinished) return;\n        _publicSaleFinished = true;\n\n        uint256 leftOver = _publicSupply.sub(publicSaleSoldToken);\n        if (leftOver > 0) {\n            _mint(owner(), leftOver);\n        }\n        emit PublicSaleFinished(publicSaleBoughtEth, publicSaleSoldToken);\n    }\n\n    function _sellOnGenesisSale(address payable buyer, uint256 ethAmount) private {\n        uint256 capacity = _genesisEthCapacity.sub(genesisSaleBoughtEth);\n        uint256 _ethAmount = (ethAmount < capacity) ? ethAmount : capacity;\n        uint256 refund = ethAmount - _ethAmount;\n        require(0 < _ethAmount, \"ZONE: The amount can't be 0.\");\n\n        uint256 amount = _ethAmount.mul(_genesisRate);\n        uint256 genesisBonus = amount.div(10);   // when buying during Genesis sale, 10% bonus\n        uint256 purchaseBonus = 0;\n\n        if (_ethAmount >= 10e18) {\n            // when buying for over 10eth, 10% bonus\n            purchaseBonus = amount.div(10);\n        }\n\n        // total token amount\n        amount = amount.add(genesisBonus).add(purchaseBonus);\n\n        genesisSaleBoughtEth = genesisSaleBoughtEth.add(_ethAmount);\n        genesisSaleSoldToken = genesisSaleSoldToken.add(amount);\n        require(genesisSaleSoldToken <= _genesisSupply, \"ZONE: Genesis supply is insufficient.\");\n\n        // mint token amount and bonuses to buyer\n        _mintLockedToken(buyer, amount, LOCK_TYPE_GENESIS, genesisSaleUnlockTime);\n\n        address payable ownerAddress = address(uint160(owner()));\n        ownerAddress.transfer(_ethAmount);\n        emit SoldOnGenesisSale(buyer, _ethAmount, amount);\n\n        if (0 < refund) {\n            buyer.transfer(refund);\n        }\n        if (_genesisEthCapacity <= genesisSaleBoughtEth) {\n            _finishGenesisSale();\n        }\n    }\n\n    function _sellOnPublicSale(address payable buyer, uint256 ethAmount) private {\n        uint256 capacity = _publicEthCapacity.sub(publicSaleBoughtEth);\n        uint256 _ethAmount = (ethAmount < capacity) ? ethAmount : capacity;\n        uint256 refund = ethAmount - _ethAmount;\n        require(0 < _ethAmount, \"ZONE: The amount can't be 0.\");\n\n        uint256 amount = _ethAmount.mul(_publicRate);\n\n        publicSaleBoughtEth = publicSaleBoughtEth.add(_ethAmount);\n        publicSaleSoldToken = publicSaleSoldToken.add(amount);\n        require(publicSaleSoldToken <= _publicSupply, \"ZONE: Public supply is insufficient.\");\n\n        // mint token amount to buyer\n        _mint(buyer, amount);\n\n        address payable ownerAddress = address(uint160(owner()));\n        ownerAddress.transfer(_ethAmount);\n        emit SoldOnPublicSale(buyer, _ethAmount, amount);\n\n        if (0 < refund) {\n            buyer.transfer(refund);\n        }\n        if (_publicEthCapacity <= publicSaleBoughtEth) {\n            _finishPublicSale();\n        }\n    }\n\n    // low level token purchase function\n    function purchase() external payable onlyEndUser {\n        address payable buyer = _msgSender();\n        require(buyer != address(0));\n        require(msg.value >= 1e16, \"ZONE: The purchase minimum amount is 0.01 ETH\");\n\n        if (now < genesisSaleEndTime) {\n            require(_genesisSaleFinished == false, \"ZONE: Genesis sale already finished\");\n            _sellOnGenesisSale(buyer, msg.value);\n        } else {\n            _finishGenesisSale();\n\n            require(_publicSaleFinished == false, \"ZONE: Public sale already finished\");\n            _sellOnPublicSale(buyer, msg.value);\n        }\n    }\n\n    receive() external payable {\n        require(false, \"ZONE: Use the purchase function to buy the ZONE token.\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/lib/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n    address private _pendingOwner;\n\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor (address owner) internal {\n        _owner = owner;\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _pendingOwner = newOwner;\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == _pendingOwner, \"acceptOwnership: Call must come from pendingOwner.\");\n        emit OwnershipTransferred(_owner, _pendingOwner);\n        _owner = _pendingOwner;\n    }\n}\n"
    },
    "contracts/lib/Global.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nlibrary GLOBAL {\n    uint256 constant SECONDS_IN_YEAR = 365 * 24 * 3600; // 365 days * 24 hours * 60 minutes * 60 seconds\n    uint256 constant SECONDS_IN_QUARTER = SECONDS_IN_YEAR / 4;\n    uint256 constant SECONDS_IN_MONTH = 30 * 24 * 3600; // 30 days * 24 hours * 60 minutes * 60 seconds\n\n    uint8 constant QUARTERS_IN_YEAR = 4;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}}