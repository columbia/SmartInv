{{
  "language": "Solidity",
  "sources": {
    "contracts/goodblocks.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n\r\n     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \r\n    ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà      \r\n    ‚ñà‚ñà   ‚ñà‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \r\n    ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà  ‚ñà‚ñà       ‚ñà‚ñà \r\n     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà                                                                                                                                                                                 \r\n\r\n    by @0xSomeGuy\r\n\r\n    a collection made with ‚ù§ for creators, innovators, and builders\r\n    having real world impact and doing good.\r\n\r\n    ...or anyone who supports that stuff too. üëä\r\n\r\n    shoutouts/credits to other projects/contract/devs/people:\r\n        @OnChainMonkey: @huuep\r\n        @NuclearNerds: @nftchance (Mimetic Metadata), masonnft, @squeebo_nft\r\n        Azuki: @ChiruLabs (ERC721A)\r\n        @AnonymiceNFT: @_MouseDev and Kiro\r\n        @OnChainKevinNFT     \r\n        @HumansNft\r\n        @FlowerGirlsNFT\r\n        @developer_dao\r\n\r\n        section headers made with: https://patorjk.com/software/taag (ANSI Regular)\r\n\r\n*/\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport '@openzeppelin/contracts/utils/Address.sol';\r\nimport '@openzeppelin/contracts/utils/Strings.sol';\r\n\r\nerror StopTryingToApproveIfYoureNotTheOwnerOrApproved();\r\nerror WhyAreYouTryingToApproveYourself();\r\nerror YoureTheOwnerYouDontNeedApprovalDuh();\r\nerror CantGetApprovalsForTokensThatDontExist();\r\nerror BalanceOfZeroAddressNotAllowedItsComplicated();\r\nerror LoveTheSupportButCantMintThatMany();\r\nerror GenerationAddressNotValidWhoops();\r\nerror UhOhTheGenerationYouRequestedIsNotEnabled();\r\nerror HoldYourHorsesNextGenerationIsNotEnabled();\r\nerror SeriouslyYouDontEvenHaveThatMuchToSend();\r\nerror NotTheRightAmountToUnlockTryAgain();\r\nerror ReallyWantToMintForYouButNotTheRightFunds();\r\nerror TheresNoGenerationsLessThanZeroDude();\r\nerror LoveTheExcitementButMintIsNotActive();\r\nerror SorryFriendContractsCantMint();\r\nerror WeWouldBreakIfWeMintedThisMany();\r\nerror HowCanYouEvenMintLessThanOne();\r\nerror MintingToZeroAddressWouldCauseHavoc();\r\nerror SorryYouCantAbandonOwnershipToTheZeroAddress();\r\nerror WeReallyNeedTheContractOwnerToDoThis();\r\nerror WeKnowYoureTheOwnerAndAllButYouCantMintThatMany();\r\nerror DangCouldntSendTheFundsForYou();\r\nerror StopTryingToChangeOtherPeoplesTokenGenerationYoureNotTheOwner();\r\nerror AreYouReallyTryingToSetTheGenerationForTokensThatDontExist();\r\nerror GottaUnlockThisGenerationBeforeYouSetItFriend();\r\nerror TokensThatDontExistDontHaveDataOrDoThey();\r\nerror ItsTheSameGenerationYoureNotChangingAnything();\r\nerror WhyAreYouTryingToTransferTheTokenIfYoureNotTheOwnerOrApproved();\r\nerror TheFromAddressNeedsToBeTheOwnerPlease();\r\nerror TransferToNonERC721ReceiverImplementer();\r\nerror PleaseDontTransferToTheZeroAddressThanks();\r\nerror DontMessWithOtherPeoplesTokensOnlyOwnersCanUnlockNextGeneration();\r\nerror CantGetTheUriForTokensThatArentEvenReal();\r\nerror SorryCouldntWithdrawYourFundsHomie();\r\n\r\n/**\r\n    @author @0xSomeGuy\r\n    @notice this contract handles the multi generational ERC721 tokens for the goodblocks community\r\n    @dev hit me up with any questions or feedback! dms always open.\r\n*/\r\n\r\ncontract goodblocks is IERC721, IERC721Metadata, ReentrancyGuard\r\n{\r\n\r\n    constructor()\r\n    {\r\n       _Owner = msg.sender;\r\n    }\r\n\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n\r\n\r\n    /*\r\n    \r\n        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà     ‚ñà‚ñà    ‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \r\n        ‚ñà‚ñà         ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà          ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà      \r\n        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà‚ñà‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \r\n             ‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà           ‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà      ‚ñà‚ñà \r\n        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \r\n\r\n        section for state variables in the contract\r\n        secci√≥n de 'state variables' en el contrato\r\n    */\r\n\r\n    // project information\r\n    // informaci√≥n del proyecto\r\n    uint256 constant CollectionSize = 8281;\r\n    string public ProjectName = unicode\"goodblocks\";\r\n    string public ProjectSymbol = unicode\"GDBLK\";\r\n    string public ProjectDescription = unicode\"create x innovate x impact. good vibes guaranteed. üëäüíØ\";\r\n    \r\n    /**\r\n        @notice function to update project info\r\n                funci√≥n para cambiar la informaci√≥n del proyecto\r\n        @param _newName     new project name\r\n                            el nuevo nombre del proyecto\r\n        @param _newSymbol   new project symbol\r\n                            el nuevo s√≠mbolo del proyecto\r\n        @param _newDesc     new project description\r\n                            la nueva descripci√≥n del proyecto\r\n    */\r\n    function updateProjectInfo(string memory _newName, string memory _newSymbol, string memory _newDesc) external onlyOwner\r\n    {\r\n        ProjectName = _newName;\r\n        ProjectSymbol = _newSymbol;\r\n        ProjectDescription = _newDesc;\r\n    }\r\n\r\n    // contract owner\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n        @notice get contract owner\r\n                obtener due√±o del contrato\r\n        @return address     owner address                   \r\n                            direcci√≥n del due√±o\r\n    */\r\n    function owner() public view returns (address)\r\n    {\r\n        return _Owner;\r\n    }\r\n\r\n    /**\r\n        @notice transfer contract ownership\r\n                transferir la propiedad del contrato\r\n        @param _newOwner    address of new owner\r\n                            direcci√≥n de nuevo due√±o/due√±a\r\n    */\r\n    function transferOwnership(address _newOwner) external onlyOwner\r\n    {\r\n        if(_newOwner == address(0)) revert SorryYouCantAbandonOwnershipToTheZeroAddress();\r\n        address oldOwner =_Owner;\r\n       _Owner = _newOwner;\r\n        emit OwnershipTransferred(oldOwner, _newOwner);\r\n    }\r\n\r\n    // mint variables\r\n    // variables para el mint (acu√±aci√≥n)\r\n    uint256 private constant StartTokenIndex = 0;\r\n    uint256 private constant MaxReserve = 410;\r\n    bool public IsMintActive = false;\r\n    uint256 private ReserveUsed = 0;\r\n    uint256 public GoodblockPrice = 0.05 ether;\r\n    uint256 public MaxMintPerAddress = 7;\r\n    uint256 public MaxFreePerAddress = 2;\r\n    uint256 private CurrentTokenIndex = 0;\r\n    uint256 public TotalMinted = 0;\r\n    \r\n    /**\r\n        @notice update mint price\r\n                cambiar precio\r\n        @param _newPriceInWei   new price in wei\r\n                                nuevo precio en wei\r\n    */\r\n    function updateMintPrice(uint256 _newPriceInWei) external onlyOwner\r\n    {\r\n        GoodblockPrice = _newPriceInWei;\r\n    }\r\n\r\n    /**\r\n        @notice update max mint per address\r\n                cambiar mint m√°ximo por direcci√≥n\r\n        @param _newMaxPerAddress     new max per address\r\n                                    nuevo m√°ximo por direcci√≥n  \r\n    */\r\n    function updateMaxMintPerAddress(uint256 _newMaxPerAddress) external onlyOwner\r\n    {\r\n        MaxMintPerAddress = _newMaxPerAddress;\r\n    }\r\n\r\n    /**\r\n        @notice update max free per address\r\n                cambiar m√°ximo gratis por direcci√≥n\r\n        @param _newMaxFreePerAddress     new max per address\r\n                                    nuevo m√°ximo por direcci√≥n  \r\n    */\r\n    function updateMaxFreePerAddress(uint256 _newMaxFreePerAddress) external onlyOwner\r\n    {\r\n        MaxFreePerAddress = _newMaxFreePerAddress;\r\n    }\r\n\r\n    /**\r\n        @notice struct for token data\r\n                struct para datos del token\r\n        @param activeGen            active generation of token\r\n                                    generaci√≥n activa de token\r\n        @param highestGenLevel      highest generation unlocked for token\r\n                                    generaci√≥n m√°s alta desbloqueada para token\r\n        @param timesTransferred     times token has been transferred (including non sale transfers)\r\n                                    veces que se ha transferido el token (incluyendo las transferencias que no son de venta)\r\n        @param ownedSince           time token has been owned by currrent owner (property can be inherited from other token)\r\n                                    tiempo que el token ha sido propiedad del propietario actual (se puede heredar de otro token)\r\n        @param tokenOwner           current owner of token (property can be inherited from other token)\r\n                                    propietario actual del token (se puede heredar de otro token)\r\n        @dev    \"tokenOwner\" and \"ownedSince\" needs special logic due to batch mint approach, can also be inhertied by another token\r\n                \"tokenOwner\" y \"ownedSince\" necesita una l√≥gica especial por el enfoque de acu√±ar por lotes, tambien se puede heredar de otro token\r\n    */\r\n    struct TokenData\r\n    {\r\n        uint8 activeGen;\r\n        uint8 highestGenLevel;\r\n        uint64 timesTransferred;\r\n        uint64 ownedSince;\r\n        address tokenOwner;\r\n    }\r\n\r\n    /**\r\n        @notice struct for address data\r\n                struct para datos de cada direcci√≥n\r\n        @param mintedCount  number of minted tokens for this address\r\n                            n√∫mero de tokens acu√±ados para esta direcci√≥n\r\n        @param balance      current address balance of goodblock tokens\r\n                            balance de tokens goodblock do un direcci√≥n\r\n    */\r\n    struct AddressData\r\n    {\r\n        uint8 mintedCount;\r\n        uint16 balance;\r\n    }\r\n\r\n    /**\r\n        @notice struct for generation data\r\n                struct para datos de cada generaci√≥n\r\n        @param isEnabled        is generation enabled\r\n                                est√° habilitada la generaci√≥n\r\n        @param genAddress       address of generation\r\n                                direcci√≥n de generaci√≥n\r\n        @param unlockCostInWei  cost to unlock in WEI\r\n                                costo para desbloquear en WEI\r\n    */\r\n    struct GenerationData\r\n    {\r\n        bool isEnabled;\r\n        address genAddress;\r\n        uint256 unlockCostInWei;\r\n    }\r\n\r\n    // maps each token to token data\r\n    // asigna cada token a datos de token\r\n    mapping(uint256 => TokenData) private TokenToDataMap;\r\n    // maps each address to address data\r\n    // asigna cada direcci√≥n a los datos de direcci√≥n\r\n    mapping(address => AddressData) public AddressToDataMap;\r\n    // maps each generation to generation data\r\n    // asigna cada generaci√≥n a los datos de la generaci√≥n\r\n    mapping(uint256 => GenerationData) private GenerationToDataMap;\r\n    // maps each token to approved addresses\r\n    // asigna cada token a direcciones aprobadas\r\n    mapping(uint256 => address) private TokenToApprovedMap;\r\n    // maps each owner to operator approvals\r\n    // asigna cada propietario a las aprobaciones del operador\r\n    mapping(address => mapping(address => bool)) private OperatorApprovals;\r\n\r\n    // variables to add times transferred to metadata\r\n    // variables para agregar tiempos transferidos a metadatos\r\n    string[] private TransferCountBucketStrings;\r\n    uint256[] private TransferCountBuckets;\r\n    \r\n    /**\r\n        @notice updates the count and associated metadata string\r\n                actualiza el conteo y los metadatos asociada\r\n        @param _index           index to update\r\n                                √≠ndice para actualizar\r\n        @param _transferMax     max transfer count for this bucket\r\n                                n√∫mero m√°ximo de transferencias para este grupo\r\n        @param _traitName       how trait appears in metadata\r\n                                texto para metadatos\r\n    */\r\n    function updateTransferBucket(uint256 _index, uint256 _transferMax, string memory _traitName) external onlyOwner returns (string[] memory)\r\n    {\r\n        if(_index >= TransferCountBucketStrings.length)\r\n        {\r\n            TransferCountBucketStrings.push(_traitName);\r\n            TransferCountBuckets.push(_transferMax);\r\n        } else\r\n        {\r\n            TransferCountBucketStrings[_index] = _traitName;\r\n            TransferCountBuckets[_index] = _transferMax;\r\n        }\r\n        return TransferCountBucketStrings;\r\n    }\r\n\r\n    // variables to add owned since to metadata\r\n    // variables para agregar la duraci√≥n de la propiedad a los metadatos\r\n    string[] private OwnedSinceBucketStrings;\r\n    uint256[] private OwnedSinceBuckets;\r\n    \r\n    /**\r\n        @notice updates the count and associated metadata string\r\n                actualiza el conteo y los metadatos asociada\r\n        @param _index           index to update\r\n                                √≠ndice para actualizar\r\n        @param _timeMax         max time for this bucket\r\n                                tiempo m√°ximo para este grupo\r\n        @param _traitName       how trait appears in metadata\r\n                                texto para metadatos\r\n    */\r\n    function updateOwnedSinceBucket(uint256 _index, uint256 _timeMax, string memory _traitName) external onlyOwner returns (string[] memory)\r\n    {\r\n        if(_index >= OwnedSinceBucketStrings.length)\r\n        {\r\n            OwnedSinceBucketStrings.push(_traitName);\r\n            OwnedSinceBuckets.push(_timeMax);\r\n        } else\r\n        {\r\n            OwnedSinceBucketStrings[_index] = _traitName;\r\n            OwnedSinceBuckets[_index] = _timeMax;\r\n        }\r\n        return OwnedSinceBucketStrings;\r\n    }\r\n\r\n\r\n\r\n    /*\r\n\r\n        ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \r\n        ‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà      \r\n        ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \r\n        ‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà      ‚ñà‚ñà \r\n        ‚ñà‚ñà      ‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà\r\n\r\n    */\r\n\r\n    modifier onlyOwner()\r\n    {\r\n        if(msg.sender !=_Owner) revert WeReallyNeedTheContractOwnerToDoThis();\r\n        _;\r\n    }\r\n   \r\n\r\n    \r\n    /*\r\n\r\n        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \r\n        ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà‚ñà ‚ñà‚ñà       ‚ñà‚ñà      \r\n        ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà       ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \r\n        ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà       ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà      ‚ñà‚ñà \r\n        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \r\n\r\n    */\r\n\r\n    /**\r\n        @notice see {IERC165-supportsInterface}\r\n    */\r\n    function supportsInterface(bytes4 interfaceId) public pure override(IERC165) returns (bool)\r\n    {\r\n        return interfaceId == type(IERC721).interfaceId || \r\n            interfaceId == type(IERC721Metadata).interfaceId;\r\n    }\r\n\r\n\r\n\r\n    /*\r\n\r\n        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà \r\n        ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà           ‚ñà‚ñà      ‚ñà‚ñà ‚ñà‚ñà‚ñà \r\n        ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà          ‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà \r\n        ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà         ‚ñà‚ñà   ‚ñà‚ñà       ‚ñà‚ñà \r\n        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà                                            \r\n                                                    \r\n    */\r\n\r\n    /**\r\n        @notice see {IERC721-balanceOf}\r\n        @notice gets the balance of an address\r\n        @param _owner   address to be checked\r\n                        direcci√≥n a revisar\r\n        @return uint256 of tokens owned by address\r\n                        balance de tokens de la direcci√≥n\r\n    */\r\n    function balanceOf(address _owner) public view override returns (uint256)\r\n    {\r\n        if (_owner == address(0)) revert BalanceOfZeroAddressNotAllowedItsComplicated();   \r\n        return uint256(AddressToDataMap[_owner].balance);\r\n    }\r\n\r\n    /**\r\n        @notice see {IERC721-ownerOf}\r\n        @notice gets the owner of a specific token\r\n                obtiene el due√±o/la due√±a de un token espec√≠fico\r\n        @param _tokenId     token id to get owner\r\n                            identificaci√≥n del token para obtener el propietario\r\n        @return address     address of token owner\r\n                            direcci√≥n de el due√±o/la due√±a del token\r\n    */\r\n    function ownerOf(uint256 _tokenId) public view override returns (address)\r\n    {\r\n        return getTokenData(_tokenId).tokenOwner;\r\n    }\r\n\r\n    /**\r\n        @notice see {IERC721-safeTransferFrom}\r\n        @notice safely transfers tokens to addresses and contracts\r\n                transfiere tokens de forma segura a carteras y contratos\r\n        @param _from        the originating address\r\n                            la direcci√≥n de origen\r\n        @param _to          the receiving address\r\n                            la direcci√≥n de recepci√≥n\r\n        @param _tokenId     token to be transferred\r\n                            token a transferir\r\n        @param _data        any data with the transfer\r\n                            cualquier dato con la transacci√≥n\r\n    */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public override\r\n    {\r\n        // transfer token\r\n        // token de transferencia\r\n        _transferToken(_from, _to, _tokenId);\r\n        \r\n        // if _to is contract, ensure it implements {IERC721Receiver-onERC721Received}\r\n        // si _to es un contrato, aseg√∫rese de que implemente {IERC721Receiver-onERC721Received}\r\n        if (_to.isContract() && !_checkContractOnERC721Received(_from, _to, _tokenId, _data)) \r\n        {\r\n            revert TransferToNonERC721ReceiverImplementer();\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice see {IERC721-safeTransferFrom}\r\n        @notice see above\r\n                v√©a m√°s arriba\r\n    */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public override\r\n    {\r\n        safeTransferFrom(_from, _to, _tokenId, '');\r\n    }    \r\n\r\n    /**\r\n        @notice see {IERC721-transferFrom}\r\n        @notice transfers tokens\r\n                transfiere tokens\r\n        @param _from        the originating address\r\n                            la direcci√≥n de origen\r\n        @param _to          the receiving address\r\n                            la direcci√≥n de recepci√≥n\r\n        @param _tokenId     token to be transferred\r\n                            token a transferir\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public override\r\n    {\r\n        _transferToken(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n        @notice see {IERC721-safeTransferFrom}\r\n        @notice grant approval for another address to transfer a token\r\n                aprobador otra direcci√≥n para transferir un token\r\n        @param _to          address to approve\r\n                            direcci√≥n para aprobar\r\n        @param _tokenId     token to approve for transfer\r\n                            token para aprobar la transferencia\r\n    */\r\n    function approve(address _to, uint256 _tokenId) public override\r\n    {\r\n        // get token owner\r\n        // obtener due√±o/due√±a de token\r\n        address tokenOwner = getTokenData(_tokenId).tokenOwner;\r\n        \r\n        // check if owner is trying to approve self\r\n        // verificar si el due√±o/la due√±a est√° tratando de aprobarse a s√≠ mismo\r\n        if (_to == tokenOwner) revert YoureTheOwnerYouDontNeedApprovalDuh();\r\n\r\n        // check if owner or operator is calling function\r\n        // verificar si el due√±o/la due√±a u operador est√° llamando a la funci√≥n\r\n        if (msg.sender != tokenOwner && !isApprovedForAll(tokenOwner, msg.sender)) revert StopTryingToApproveIfYoureNotTheOwnerOrApproved();\r\n\r\n        // set approval\r\n        // establecer aprobaci√≥n\r\n        _approve(_to, _tokenId, tokenOwner);\r\n    }\r\n\r\n    /**\r\n        @notice see {IERC721-setApprovalForAll}\r\n        @param _operator        operator to approve\r\n                                operador para aprobar\r\n        @param _approvedStatus  status of operator approval\r\n                                estado de aprobaci√≥n del operador\r\n    */\r\n    function setApprovalForAll(address _operator, bool _approvedStatus) public override\r\n    {\r\n        // check if operator is trying to approve self\r\n        // verificar si el operador est√° tratando de aprobarse a s√≠ mismo\r\n        if (_operator == msg.sender) revert WhyAreYouTryingToApproveYourself();\r\n\r\n        OperatorApprovals[msg.sender][_operator] = _approvedStatus;\r\n        emit ApprovalForAll(msg.sender, _operator, _approvedStatus);\r\n    }\r\n\r\n    /**\r\n        @notice see {IERC721-getApproved}\r\n        @notice get approved address for token\r\n                obtener direcci√≥n aprobada para token\r\n        @param _tokenId token to check\r\n                        token para verificar\r\n        @return address address of approved\r\n                        direcci√≥n de aprobado\r\n    */\r\n    function getApproved(uint256 _tokenId) public view override returns (address)\r\n    {\r\n        // check token exists\r\n        // verificar que existe el token\r\n        if (!_exists(_tokenId)) revert CantGetApprovalsForTokensThatDontExist();\r\n        return TokenToApprovedMap[_tokenId];\r\n    }\r\n\r\n    /**\r\n        @notice see {IERC721-isApprovedForAll}\r\n        @notice check if operator is approved for all\r\n                compruebe si el operador est√° aprobado\r\n        @param _owner       address to check\r\n                            direcci√≥n para verificar\r\n        @param _operator    operator to check\r\n                            operador para verificar\r\n        @return bool        operator approval status\r\n                            estado de aprobaci√≥n del operador\r\n    */\r\n    function isApprovedForAll(address _owner, address _operator) public view override returns (bool)\r\n    {\r\n        return OperatorApprovals[_owner][_operator];\r\n    }  \r\n\r\n    /**\r\n        @notice see {ERC721-_checkOnERC721Received}\r\n        @notice check if target contract implements receiver\r\n        @param _from        the originating address\r\n                            la direcci√≥n de origen\r\n        @param _to          the receiving address\r\n                            la direcci√≥n de recepci√≥n\r\n        @param _tokenId     token to be transferred\r\n                            token a transferir\r\n        @param _data        any data with the transfer\r\n                            cualquier dato con la transacci√≥n\r\n        @return bool        whether the target address implements or not\r\n                            si la direcci√≥n de destino implementa o no\r\n     */\r\n    function _checkContractOnERC721Received(address _from, address _to, uint256 _tokenId, bytes memory _data) private returns (bool)\r\n    {\r\n        try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4 retval)\r\n        {\r\n            return retval == IERC721Receiver(_to).onERC721Received.selector;\r\n        } catch (bytes memory reason)\r\n        {\r\n            if (reason.length == 0)\r\n            {\r\n                revert TransferToNonERC721ReceiverImplementer();\r\n            } else\r\n            {\r\n                assembly\r\n                {\r\n                    revert(add(32, reason), mload(reason))\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /*\r\n\r\n        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà       ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà  \r\n        ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà           ‚ñà‚ñà      ‚ñà‚ñà ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà         ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà \r\n        ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà          ‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \r\n        ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà         ‚ñà‚ñà   ‚ñà‚ñà       ‚ñà‚ñà       ‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà         ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà \r\n        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà       ‚ñà‚ñà      ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà \r\n                                                                                                                                                                                                                                                          \r\n    */\r\n\r\n    /**\r\n        @notice see {IERC721Metadata-name}.\r\n        @notice returns the project name\r\n                devuelve el nombre del proyecto\r\n    */\r\n    function name() public view override returns (string memory)\r\n    {\r\n        return ProjectName;\r\n    }\r\n\r\n    /**\r\n        @notice see {IERC721Metadata-symbol}.\r\n        @notice returns the project symbol\r\n                devuelve el s√≠mbolo del proyecto\r\n    */\r\n    function symbol() public view override returns (string memory)\r\n    {\r\n        return ProjectSymbol;\r\n    }\r\n\r\n    /**\r\n        @notice see {IERC721Metadata-tokenURI}.\r\n        @notice returns the token uri containing image and metadata\r\n                devuelve el token uri que contiene la imagen y los metadatos\r\n        @param _tokenId     token to retrieve\r\n                            token para recuperar\r\n        @return string      token uri (data)\r\n                            token uri (datos)\r\n    */\r\n    function tokenURI(uint256 _tokenId) public view override returns (string memory)\r\n    {\r\n        // who's reading carefully?\r\n        // qui√©n est√° leyendo con atenci√≥n?\r\n        require(_tokenId != 12345678910111213, string(abi.encodePacked(\"interesting... \", rh)));\r\n\r\n        // check token exists first\r\n        // primero verificar que el token existe\r\n        if (!_exists(_tokenId)) revert CantGetTheUriForTokensThatArentEvenReal();\r\n\r\n        // get token generation data\r\n        // obtener datos de generaci√≥n del token\r\n        TokenData memory tokenData = getTokenData(_tokenId);\r\n        address tokenGenAddress = GenerationToDataMap[tokenData.activeGen].genAddress;\r\n        \r\n        // check for valid gen address\r\n        // verifica si hay una direcci√≥n de generaci√≥n v√°lida\r\n        if (tokenGenAddress == address(0)) revert GenerationAddressNotValidWhoops();\r\n\r\n        // get times transferred bucket\r\n        // obtener el grupo de veces transferidas\r\n        string memory transferTrait = \"?\";\r\n        for(uint i=0; i<TransferCountBuckets.length; i++)\r\n        {\r\n            if(tokenData.timesTransferred < TransferCountBuckets[i])\r\n            {\r\n                transferTrait = TransferCountBucketStrings[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        // get owned since bucket\r\n        // obtener el grupo de la duraci√≥n de la propiedad\r\n        string memory ownedSinceTrait = \"?\";\r\n        for(uint i=0; i<OwnedSinceBuckets.length; i++)\r\n        {\r\n            if(tokenData.ownedSince < OwnedSinceBuckets[i])\r\n            {\r\n                ownedSinceTrait = OwnedSinceBucketStrings[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        // generate token uri and metadata\r\n        // generar token uri y metadata\r\n        string memory tokenAttributes = string(abi.encodePacked(\r\n            '{\"trait_type\": \"Generations Unlocked\", \"value\":\"',\r\n            Strings.toString(tokenData.highestGenLevel+1),\r\n            '\"},',\r\n            '{\"trait_type\": \"Active Generation\", \"value\":\"',\r\n            Strings.toString(tokenData.activeGen),\r\n            '\"},',\r\n            '{\"trait_type\": \"Times Transferred\", \"value\":\"',\r\n            transferTrait,\r\n            '\"},',\r\n            '{\"trait_type\": \"Owned Since\", \"value\":\"',\r\n            ownedSinceTrait,\r\n            '\"}'\r\n        ));\r\n        string memory tokenMetadata = string(abi.encodePacked(\r\n            '\"ownedSince\":\"',\r\n            Strings.toString(tokenData.ownedSince),\r\n            '\", \"timesTransferred\":\"',\r\n            Strings.toString(tokenData.timesTransferred),\r\n            '\"'\r\n        )); \r\n\r\n        iGoodblocksGen goodblocksGen = iGoodblocksGen(tokenGenAddress);\r\n        return goodblocksGen.tokenGenURI(_tokenId, tokenMetadata, tokenAttributes);\r\n    }\r\n\r\n\r\n\r\n    /*\r\n\r\n         ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \r\n        ‚ñà‚ñà       ‚ñà‚ñà      ‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà      \r\n        ‚ñà‚ñà   ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \r\n        ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà \r\n         ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \r\n\r\n    */\r\n\r\n    /**\r\n        @notice get data for generation by index\r\n                obtener datos para la generaci√≥n por √≠ndice\r\n        @param _genIndex        index of generation\r\n                                √≠ndice de generaci√≥n\r\n        @return GenerationData  generation data\r\n                                datos de generaci√≥n\r\n    */\r\n    function getGenerationData(uint256 _genIndex) public view returns (GenerationData memory)\r\n    {\r\n        return GenerationToDataMap[_genIndex];\r\n    }\r\n\r\n    /**\r\n        @notice update the data for any generation (index starting at 0)\r\n                cambiar los datos para cualquier generaci√≥n (√≠ndice comienza en 0)\r\n        @param _genIndex    generation index\r\n                            √≠ndice de generaci√≥n\r\n        @param _isEnabled   status of the generation\r\n                            estado de la generacion\r\n        @param _genAddress  rendering address for the generation (tokenURI points here)\r\n                            direcci√≥n de representaci√≥n para la generaci√≥n (tokenURI viene de aqu√≠)\r\n        @param _costInWei   cost for unlocking this generation\r\n                            costo para desbloquear esta generaci√≥n\r\n\r\n        @dev    all tokens start with a '0' index generation so the 'genesis' generation index should be 0\r\n                todos los tokens comienzan con una generaci√≥n de √≠ndice '0', el √≠ndice de generaci√≥n 'g√©nesis' debe ser 0\r\n    */\r\n    function updateGeneration(uint256 _genIndex, bool _isEnabled, address _genAddress, uint256 _costInWei) external onlyOwner\r\n    {\r\n        GenerationToDataMap[_genIndex].isEnabled = _isEnabled;\r\n        GenerationToDataMap[_genIndex].genAddress = _genAddress;\r\n        GenerationToDataMap[_genIndex].unlockCostInWei = _costInWei;\r\n    }\r\n\r\n    /**\r\n        @notice toggle generation status\r\n                cambiar el estado de generaci√≥n\r\n        @param _genIndex    generation index\r\n                            √≠ndice de generaci√≥n\r\n    */\r\n    function toggleGenerationStatus(uint256 _genIndex) external onlyOwner\r\n    {\r\n        GenerationToDataMap[_genIndex].isEnabled = !GenerationToDataMap[_genIndex].isEnabled;\r\n    }\r\n\r\n    /**\r\n        @notice unlock next generation for token\r\n                desbloquear la pr√≥xima generaci√≥n para token\r\n        @param _tokenId     token to upgrade\r\n                            token para cambiar\r\n    */\r\n    function unlockNextGeneration(uint256 _tokenId) public payable\r\n    {\r\n        // get token data\r\n        // obtener datos del token\r\n        TokenData memory tokenData = getTokenData(_tokenId);\r\n        \r\n        // check that owner is calling function\r\n        // verifica que el due√±o/la due√±a est√° llamando a la funci√≥n\r\n        if(msg.sender != tokenData.tokenOwner) revert DontMessWithOtherPeoplesTokensOnlyOwnersCanUnlockNextGeneration();\r\n        \r\n        // get token next generation level\r\n        // obtener el nivel de pr√≥xima generaci√≥n\r\n        GenerationData memory nextGen = GenerationToDataMap[tokenData.highestGenLevel + 1];\r\n        \r\n        // check if next generation is enabled\r\n        // verifica si la pr√≥xima generaci√≥n est√° activa\r\n        if(!nextGen.isEnabled) revert HoldYourHorsesNextGenerationIsNotEnabled();\r\n        \r\n        // check if msg.value is correct for next generation unlock\r\n        // verifica que el valor es correcto para desbloquear la pr√≥xima generaci√≥n\r\n        if(msg.value != nextGen.unlockCostInWei) revert NotTheRightAmountToUnlockTryAgain();\r\n\r\n        // unlock and increment generation for token\r\n        // desbloquear e incrementar la generaci√≥n de token\r\n        TokenToDataMap[_tokenId].highestGenLevel = tokenData.highestGenLevel + 1;\r\n        TokenToDataMap[_tokenId].activeGen = tokenData.highestGenLevel + 1;\r\n    }\r\n\r\n    /**\r\n        @notice focus generation for a token\r\n                seleccionar generaci√≥n para un token\r\n        @param _tokenId     token to update\r\n                            token para cambiar\r\n        @param _genIndex    generation index\r\n                            √≠ndice de generaci√≥n\r\n    */\r\n    function setTokenGeneration(uint256 _tokenId, uint256 _genIndex) public payable\r\n    {\r\n\r\n        // check for valid generation\r\n        // verifica qu la generaci√≥n es v√°lida\r\n        if(_genIndex < 0) revert TheresNoGenerationsLessThanZeroDude();\r\n\r\n        // check if token exists\r\n        // verifica si existe el token\r\n        if(!_exists(_tokenId)) revert AreYouReallyTryingToSetTheGenerationForTokensThatDontExist();\r\n\r\n        // get token data\r\n        // obtener datos del token\r\n        TokenData memory tokenData = getTokenData(_tokenId);\r\n        \r\n        // check that owner is calling function\r\n        // verifica que el due√±o/la due√±a est√° llamando a la funci√≥n\r\n        if(msg.sender != tokenData.tokenOwner) revert StopTryingToChangeOtherPeoplesTokenGenerationYoureNotTheOwner();\r\n\r\n        // check if requested generation is greater than highest level\r\n        // comprueba si la generaci√≥n solicitada es mayor que el nivel m√°s alto\r\n        if(_genIndex > tokenData.highestGenLevel) revert GottaUnlockThisGenerationBeforeYouSetItFriend();\r\n        \r\n        // check if requested gen is current gen\r\n        // comprueba si la generaci√≥n solicitada es la generaci√≥n activa\r\n        if(_genIndex == tokenData.activeGen) revert ItsTheSameGenerationYoureNotChangingAnything();\r\n        \r\n        // get requested generation data\r\n        // obtener los datos de generaci√≥n solicitados\r\n        GenerationData memory requestedGen = GenerationToDataMap[_genIndex];\r\n        \r\n        // check if generation is enabled\r\n        // comprobar si la generaci√≥n est√° activa\r\n        if(!requestedGen.isEnabled) revert UhOhTheGenerationYouRequestedIsNotEnabled();\r\n\r\n        // set generation for token\r\n        // establecer generaci√≥n para token\r\n        TokenToDataMap[_tokenId].activeGen = uint8(_genIndex);\r\n    }\r\n\r\n\r\n\r\n    /*\r\n    \r\n         ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà      \r\n        ‚ñà‚ñà       ‚ñà‚ñà      ‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà      \r\n        ‚ñà‚ñà   ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà      \r\n        ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà      \r\n         ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \r\n    \r\n    */\r\n\r\n    /**\r\n        @notice get total supply count\r\n                obtener el recuento total de tokens\r\n        @return uint256 total token count\r\n                        recuento total de tokens\r\n    */\r\n    function totalSupply() public view returns(uint256)\r\n    {\r\n        return TotalMinted;\r\n    }\r\n\r\n    /**\r\n        @notice function to get token data struct for existing tokens\r\n        @param _tokenId     token index\r\n                            √≠ndice de token\r\n        @return TokenData   token data\r\n                            datos del token\r\n    */\r\n    function getTokenData(uint256 _tokenId) public view returns (TokenData memory)\r\n    {\r\n        uint256 tempTokenId = _tokenId;\r\n        \r\n        // check token exists\r\n        // verifica que existe el token\r\n        if(!_exists(_tokenId)) revert TokensThatDontExistDontHaveDataOrDoThey();\r\n        \r\n        // using unchecked to reduce gas\r\n        // usando \"unchecked\" para reducir el gas\r\n        unchecked\r\n        {\r\n            // get token data\r\n            // obtener datos del token\r\n            TokenData memory tokenData = TokenToDataMap[_tokenId];\r\n\r\n            // if token owner is not address(0), return the data\r\n            // si el due√±o/la due√±a del token no es la direcci√≥n(0), devuelve los datos\r\n            if (tokenData.tokenOwner != address(0))\r\n            {\r\n                return tokenData;\r\n            }\r\n\r\n            // there will always be an owner before a 0 address owner, avoiding underflow\r\n            // siempre habr√° un due√±o/due√±a antes que un propietario de direcci√≥n(0), evitando el desbordamiento                \r\n            while(tokenData.tokenOwner == address(0) && tempTokenId > StartTokenIndex)\r\n            {\r\n                tempTokenId--;\r\n                // when owner found, update owner and ownedSince properties\r\n                // cuando se encuentra el due√±o/ la due√±a, cambia las propiedades\r\n                if (TokenToDataMap[tempTokenId].tokenOwner != address(0))\r\n                {\r\n                    tokenData.tokenOwner = TokenToDataMap[tempTokenId].tokenOwner;\r\n                    tokenData.ownedSince = TokenToDataMap[tempTokenId].ownedSince;\r\n                    return tokenData;\r\n                }\r\n            }\r\n        }\r\n\r\n        // catch all to avoid no exit warning\r\n        // para evitar una advertencia de salida\r\n        revert TokensThatDontExistDontHaveDataOrDoThey();\r\n    }\r\n\r\n    /**\r\n        @notice internal approve address for token\r\n                aprobar direcci√≥n para token\r\n        @param _to          address to approve\r\n                            direcci√≥n para aprobar\r\n        @param _tokenId     token index\r\n                            √≠ndice de tokens\r\n        @param _owner       owner for event\r\n                            due√±o/due√±a para el evento\r\n     */\r\n    function _approve(address _to, uint256 _tokenId, address _owner) private\r\n    {\r\n        TokenToApprovedMap[_tokenId] = _to;\r\n        emit Approval(_owner, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n        @notice check if token exists (has been minted)\r\n        @param _tokenId     token index\r\n                            √≠ndice de tokens\r\n        @return bool        exists status\r\n                            estado de existencia \r\n    */\r\n    function _exists(uint256 _tokenId) internal view returns (bool)\r\n    {\r\n        return _tokenId >= StartTokenIndex && _tokenId < CurrentTokenIndex;\r\n    }\r\n\r\n    /**\r\n        @notice internal transfer token\r\n                transferir token\r\n        @param _from        the originating address\r\n                            la direcci√≥n de origen\r\n        @param _to          the receiving address\r\n                            la direcci√≥n de recepci√≥n\r\n        @param _tokenId     token to be transferred\r\n                            token a transferir  \r\n    */\r\n    function _transferToken(address _from, address _to, uint256 _tokenId) private\r\n    {\r\n        // get token data\r\n        // obtener datos del token\r\n        TokenData memory tokenData = getTokenData(_tokenId);\r\n\r\n        // check _from is owner\r\n        // verifica que \"_from\" es el due√±o/la due√±a\r\n        if (_from != tokenData.tokenOwner) revert TheFromAddressNeedsToBeTheOwnerPlease();\r\n        \r\n        // check for proper transfer approval\r\n        // verificar la aprobaci√≥n de la transferencia\r\n        bool isApprovedOrOwner = (msg.sender == _from ||\r\n            isApprovedForAll(_from, msg.sender) ||\r\n            getApproved(_tokenId) == msg.sender);\r\n\r\n        // revert if not approved\r\n        // negar si no est√° aprobado\r\n        if (!isApprovedOrOwner) revert WhyAreYouTryingToTransferTheTokenIfYoureNotTheOwnerOrApproved();\r\n        \r\n        // revert if transferring to address(0)\r\n        // negar si se transfiere a la direcci√≥n(0)\r\n        if (_to == address(0)) revert PleaseDontTransferToTheZeroAddressThanks();\r\n\r\n        // clear approvals\r\n        // borrar aprobaciones\r\n        _approve(address(0), _tokenId, _from);\r\n\r\n        // underflow not possible as ownership check above guarantees at least 1\r\n        // overflow not possible as collection is capped and getTokenData() checks for existence\r\n        // \"underflow\" no es posible ya que la verificaci√≥n de propiedad anterior garantiza al menos 1\r\n        // \"overflow\" no es posible ya que la colecci√≥n est√° limitada y getTokenData() verifica su existencia\r\n        unchecked\r\n        {\r\n            // update balances\r\n            // actualizar balances\r\n            AddressToDataMap[_from].balance -= 1;\r\n            AddressToDataMap[_to].balance += 1;\r\n\r\n            // udpate ownership, timestamp, and timesTransferred\r\n            // actualizar la propiedad, la marca de tiempo y veces transferido\r\n            TokenToDataMap[_tokenId].tokenOwner = _to;\r\n            TokenToDataMap[_tokenId].ownedSince = uint64(block.timestamp);\r\n            TokenToDataMap[_tokenId].timesTransferred += 1;\r\n\r\n            // if _tokenId+1 owner is not set, set originator as owner\r\n            // si el due√±o/la due√±a de _tokenId+1 no est√° configurado, establezca el originador como due√±o/due√±a\r\n            uint256 nextTokenId = _tokenId + 1;\r\n            TokenData storage nextSlot = TokenToDataMap[nextTokenId];\r\n            \r\n            // if _tokenId+1 owner is not set and token exists, set originator as owner\r\n            // si el el due√±o/la due√±a de _tokenId+1 no est√° configurado y el token existe, establezca el originador como due√±o/due√±a\r\n            if (nextSlot.tokenOwner == address(0) && _exists(nextTokenId))\r\n            {\r\n                nextSlot.tokenOwner = _from;\r\n                nextSlot.ownedSince = tokenData.ownedSince;\r\n            }\r\n        }\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n        @notice withdraw ether from contract\r\n                retirar fondos del contrato\r\n    */\r\n    function withdrawFunds() public payable onlyOwner \r\n    {        \r\n        (bool success, ) = payable(_Owner).call{value: address(this).balance}(\"\");\r\n        if(!success) revert SorryCouldntWithdrawYourFundsHomie();\r\n    }\r\n\r\n    /**\r\n        @notice send ether from contract\r\n                enviar fondos desde el contrato\r\n        @param _to      recipient address\r\n                        direcci√≥n del receptor\r\n        @param _amount  amount to send\r\n                        cantidad a enviar\r\n    */\r\n    function sendFunds(address _to, uint256 _amount) public payable onlyOwner \r\n    {\r\n        // verify funds available\r\n        // verificar que los fondos est√©n disponibles\r\n        if(_amount > address(this).balance) revert SeriouslyYouDontEvenHaveThatMuchToSend();\r\n        // send funds\r\n        // enviar fondos\r\n        (bool success, ) = _to.call{value: address(this).balance}(\"\");\r\n        if(!success) revert DangCouldntSendTheFundsForYou();\r\n    }\r\n\r\n\r\n\r\n    /*\r\n    \r\n        ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \r\n        ‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà    \r\n        ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà    ‚ñà‚ñà    \r\n        ‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà    \r\n        ‚ñà‚ñà      ‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà    \r\n    \r\n    */\r\n\r\n    /**\r\n        @notice toggle mint status\r\n                cambiar el estado del \"mint\"\r\n    */\r\n    function toggleMintStatus() external onlyOwner\r\n    {\r\n        IsMintActive = !IsMintActive;\r\n    }\r\n\r\n    /**\r\n        @notice mint goodblock\r\n                acu√±ar un goodblock\r\n        @param _quantity    quantity to mint\r\n                            cantidad de acu√±ar\r\n    */\r\n    function mintGoodBlock(uint8 _quantity) external payable nonReentrant\r\n    {\r\n        // check for active mint first\r\n        // comprobar si est√° activa primero\r\n        if(!IsMintActive) revert LoveTheExcitementButMintIsNotActive();\r\n\r\n        // mint at least 1\r\n        // acu√±ar al menos 1\r\n        if (_quantity < 1) revert HowCanYouEvenMintLessThanOne();\r\n        \r\n        // get address data\r\n        // obtener datos de direcci√≥n\r\n        AddressData memory addressData = AddressToDataMap[msg.sender];\r\n        \r\n        // check address not minting too many\r\n        // verifique que la direcci√≥n no acumule demasiados\r\n        if (addressData.mintedCount + _quantity > MaxMintPerAddress) revert LoveTheSupportButCantMintThatMany();\r\n\r\n        // check if able to mint quantity\r\n        // comprobar si se puede acu√±ar cantidad\r\n        if (TotalMinted + (MaxReserve-ReserveUsed) + _quantity > CollectionSize) revert WeWouldBreakIfWeMintedThisMany();\r\n        \r\n        // calculate cost\r\n        // calcular el costo\r\n        uint256 totalCost;\r\n        if(addressData.mintedCount < MaxFreePerAddress)\r\n        {\r\n            uint256 remainingFreeTokens = MaxFreePerAddress - addressData.mintedCount;\r\n\r\n            if(_quantity >= remainingFreeTokens)\r\n            {\r\n                totalCost = GoodblockPrice * (_quantity - remainingFreeTokens);\r\n            } else\r\n            {\r\n                totalCost = 0; //STILL FREE!\r\n            }\r\n        } else\r\n        {\r\n            totalCost = GoodblockPrice * _quantity;\r\n        }\r\n\r\n        // check if value sent is correct\r\n        // comprobar si el valor enviado es correcto\r\n        if (totalCost != msg.value) revert ReallyWantToMintForYouButNotTheRightFunds();\r\n\r\n        // MINT THEM THANGS!\r\n        //ACU√ëA LOS TOKENS!\r\n        _mint(msg.sender, _quantity);\r\n    }\r\n\r\n    /**\r\n    @notice mint tokens!\r\n            acu√±ar tokens!\r\n    @param _to          minting address\r\n                        direcci√≥n que va a acu√±ar\r\n    @param _quantity    quantity of tokens to mint\r\n                        cantidad de tokens a acu√±ar\r\n     */\r\n    function _mint(address _to, uint256 _quantity) private\r\n    {\r\n        // check if minting to address(0)\r\n        // verificar si se acu√±a a la direcci√≥n (0)\r\n        if (_to == address(0)) revert MintingToZeroAddressWouldCauseHavoc();\r\n\r\n        // check if contract is minting\r\n        // comprobar si un contrato est√° acu√±ando\r\n        if ((msg.sender).isContract()) revert SorryFriendContractsCantMint();\r\n\r\n        // Overflows are incredibly unrealistic.\r\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\r\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\r\n        unchecked\r\n        {\r\n            // get start token index\r\n            // obtener el √≠ndice del token de inicio\r\n            uint256 startTokenId = CurrentTokenIndex;\r\n\r\n            // update balance and mint count\r\n            // actualizar el balance y el recuento de mint\r\n            AddressToDataMap[_to].balance += uint16(_quantity);\r\n\r\n            // only increment mint count if not sent by owner\r\n            // solo incrementa el recuento de mint si no lo env√≠a el due√±o\r\n            if(msg.sender !=_Owner)\r\n            {\r\n                AddressToDataMap[_to].mintedCount += uint8(_quantity);\r\n            }\r\n\r\n            // update owner and timestamp\r\n            // actualizar due√±o/due√±a y marca de tiempo\r\n            TokenToDataMap[startTokenId].tokenOwner = _to;\r\n            TokenToDataMap[startTokenId].ownedSince = uint64(block.timestamp);\r\n            \r\n            // update start and end\r\n            // actualizar inicio y fin\r\n            uint256 updatedIndex = startTokenId;\r\n            uint256 end = updatedIndex + _quantity;\r\n\r\n            // emit transfer events for logging\r\n            // emitir eventos de transferencia para registro\r\n            do\r\n            {\r\n                emit Transfer(address(0), _to, updatedIndex++);\r\n                TotalMinted++;\r\n            } while (updatedIndex != end);\r\n\r\n            // update current index\r\n            // actualiza el √≠ndice actual\r\n            CurrentTokenIndex = updatedIndex;\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice owner mint to send to self and others\r\n                acu√±ar a s√≠ misma y a otras\r\n        @param _quantity        quantity to mint\r\n                                cantidad\r\n        @param _ignoreAddress   safety to mint to self\r\n                                seguridad para acu√±ar a uno mismo\r\n        @param _to              receiving address\r\n                                direcci√≥n de recepci√≥n\r\n    */\r\n    function ownerMint(uint256 _quantity, bool _ignoreAddress, address _to) external onlyOwner\r\n    {\r\n        if(_quantity > MaxReserve - ReserveUsed) revert WeKnowYoureTheOwnerAndAllButYouCantMintThatMany();\r\n\r\n        // check if ignoring address\r\n        // comprobar si se ignora la direcci√≥n\r\n        if(_ignoreAddress)\r\n        {\r\n            _to =_Owner;\r\n        }\r\n\r\n        // update reserve count\r\n        // actualiza el recuento de reservas\r\n        ReserveUsed += _quantity;\r\n\r\n        // total minted updated here\r\n        // total acu√±ado actualizado aqu√≠\r\n        _mint(_to, _quantity);\r\n    }\r\n    string private rh;\r\n    function setrh(string memory _rh) external onlyOwner {rh = _rh;}\r\n}\r\n\r\ninterface iGoodblocksGen\r\n{\r\n    function tokenGenURI(uint256 _tokenId, string memory _tokenMetadata, string memory _tokenAttributes) external pure returns(string memory);\r\n}"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}