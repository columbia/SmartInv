{{
  "language": "Solidity",
  "sources": {
    "/contracts/SurrealestateStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.12 <0.9.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\n\n// The NFT that can be staked here.\ninterface IPPASurrealestates {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n}\n\n// A listening contract can implement this function to get notified any time a user stakes or unstakes.\ninterface IStakingListener {\n    function notifyChange(address account) external;\n}\n\ncontract SurrealestateStaking is ERC721Holder, Ownable {\n    IPPASurrealestates surrealestates;\n    address surrealestateContractAddress;\n\n    constructor() public {\n        surrealestateContractAddress = _getSurrealestatesContractAddress();\n        surrealestates = IPPASurrealestates(surrealestateContractAddress);\n    }\n\n    function _getSurrealestatesContractAddress()\n        internal\n        view\n        returns (address)\n    {\n        address addr;\n        assembly {\n            switch chainid()\n            case 1 {\n                // mainnet\n                addr := 0x6f3185b51a42e03a4f0eaaf37604ddd499ef9b12\n            }\n            case 4 {\n                // rinkeby\n                addr := 0x6551111b5d3C7e4B5436409C2e70A8Fbe1757407\n            }\n        }\n        return addr;\n    }\n\n    // The period which people can lock their funds up for to get an extra multiplier on rewards earned.\n    uint256 stakingLockPeriod = 7776000; // 90 days in seconds.\n\n    struct StakingMultiplier {\n        uint256 numeratorMinus1; // Store as \"minus 1\" because we want this to default to 1, but uninitialized vars default to 0.\n        uint256 denominatorMinus1;\n    }\n\n    struct AccountInfo {\n        uint256 numStaked;\n        uint256 pointsStaked;\n        uint256 lastRefreshTimestamp;\n        uint256 tokensEarnedBeforeLastRefresh;\n        // A multiplier defaults to 1 but can be set by a manager in the future for a particular address. This increases\n        // the overall rate of earning.\n        StakingMultiplier stakingMultiplier;\n    }\n    mapping(address => AccountInfo) public accounts;\n\n    struct TokenInfo {\n        bool isLocked;\n        uint256 lockedUntil;\n        address owner;\n    }\n    mapping(uint256 => TokenInfo) public tokens;\n\n    // Addresses that are allowed to do things like deduct tokens from a user's account or award earning multipliers.\n    mapping(address => bool) public approvedManagers;\n\n    IStakingListener[] listeners;\n\n    // Earning period for a surrealestate. Default to 10 hours.\n    uint256 public earnPeriodSeconds = 36000;\n\n    modifier onlyApprovedManager() {\n        require(\n            owner() == msg.sender || approvedManagers[msg.sender],\n            \"Caller is not an approved manager\"\n        );\n        _;\n    }\n\n    function _notifyAllListeners(address account) internal {\n        for (uint256 i = 0; i < listeners.length; i++) {\n            listeners[i].notifyChange(account);\n        }\n    }\n\n    /** User must setApprovalForAll on the contract before staking. */\n    function stake(uint256[] calldata tokenIds, bool lock) public {\n        refreshTokensEarned(msg.sender);\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(\n                surrealestates.ownerOf(tokenIds[i]) == msg.sender,\n                \"Not your token\"\n            );\n\n            surrealestates.transferFrom(msg.sender, address(this), tokenIds[i]);\n            tokens[tokenIds[i]].owner = msg.sender;\n            accounts[msg.sender].pointsStaked += pointsByTokenId(tokenIds[i]);\n        }\n        accounts[msg.sender].numStaked += tokenIds.length;\n\n        if (lock) {\n            uint256 lockUntil = block.timestamp + stakingLockPeriod;\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                tokens[tokenIds[i]].lockedUntil = lockUntil;\n                tokens[tokenIds[i]].isLocked = true;\n                accounts[msg.sender].pointsStaked += pointsByTokenId(\n                    tokenIds[i]\n                );\n            }\n        }\n\n        _notifyAllListeners(msg.sender);\n    }\n\n    /**\n     * User can lock their staking in for the stakingLockPeriod, which increases their multiplier.\n     */\n    function lockStaking(uint256[] calldata tokenIds) public {\n        refreshTokensEarned(msg.sender);\n        uint256 lockUntil = block.timestamp + stakingLockPeriod;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(\n                tokens[tokenIds[i]].owner == msg.sender,\n                \"Token is not currently staked\"\n            );\n            require(\n                tokens[tokenIds[i]].lockedUntil < block.timestamp,\n                \"Token is already locked\"\n            );\n            if (!tokens[tokenIds[i]].isLocked) {\n                tokens[tokenIds[i]].isLocked = true;\n                accounts[msg.sender].pointsStaked += pointsByTokenId(\n                    tokenIds[i]\n                );\n            }\n            tokens[tokenIds[i]].lockedUntil = lockUntil;\n        }\n        _notifyAllListeners(msg.sender);\n    }\n\n    function refreshTokensEarned(address addr) internal {\n        if (block.timestamp == accounts[addr].lastRefreshTimestamp) {\n            // No need to refresh anything if we're up to date.\n            return;\n        }\n        if (accounts[addr].lastRefreshTimestamp == 0) {\n            // If this is the first refresh ever done, then just set the timestamp and return.\n            accounts[addr].lastRefreshTimestamp = block.timestamp;\n            return;\n        }\n\n        uint256 totalTokensEarned = calculateTokensEarned(addr);\n        accounts[addr].tokensEarnedBeforeLastRefresh = totalTokensEarned;\n        accounts[addr].lastRefreshTimestamp = block.timestamp;\n    }\n\n    function calculateTokensEarned(address addr) public view returns (uint256) {\n        uint256 secondsStakedSinceLastRefresh = block.timestamp -\n            accounts[addr].lastRefreshTimestamp;\n\n        uint256 tokensEarnedSinceLastRefresh = (secondsStakedSinceLastRefresh *\n            (accounts[addr].pointsStaked) *\n            (accounts[addr].stakingMultiplier.numeratorMinus1 + 1)) /\n            (accounts[addr].stakingMultiplier.denominatorMinus1 + 1) /\n            earnPeriodSeconds;\n        return\n            accounts[addr].tokensEarnedBeforeLastRefresh +\n            tokensEarnedSinceLastRefresh;\n    }\n\n    /**\n     * To unstake, the user calls this function with the tokenIds they want to unstake.\n     */\n    function unstake(uint256[] calldata tokenIds) public {\n        refreshTokensEarned(msg.sender);\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(\n                tokens[tokenIds[i]].owner == msg.sender,\n                \"Caller is not currently staking the provided tokenId\"\n            );\n            _unstakeSingle(tokenIds[i]);\n        }\n        accounts[msg.sender].numStaked -= tokenIds.length;\n        _notifyAllListeners(msg.sender);\n    }\n\n    // Caller is responsible for deducted accounts[addr].numStaked\n    function _unstakeSingle(uint256 tokenId) internal {\n        require(\n            tokens[tokenId].lockedUntil < block.timestamp,\n            \"Token is still locked\"\n        );\n        accounts[tokens[tokenId].owner].pointsStaked -= pointsByTokenId(\n            tokenId\n        );\n\n        // If we are past the token locktime, then we need to update the the lockedTokens map as well.\n        if (tokens[tokenId].isLocked) {\n            tokens[tokenId].isLocked = false;\n            // Deduct again because it was locked, so it was earning double.\n            accounts[tokens[tokenId].owner].pointsStaked -= pointsByTokenId(\n                tokenId\n            );\n        }\n\n        surrealestates.transferFrom(address(this), msg.sender, tokenId);\n\n        tokens[tokenId].owner = address(0);\n    }\n\n    function addApprovedManager(address managerAddr) public onlyOwner {\n        approvedManagers[managerAddr] = true;\n    }\n\n    function removeApprovedManager(address managerAddr) public onlyOwner {\n        approvedManagers[managerAddr] = false;\n    }\n\n    function setStakingLockPeriod(uint256 newPeriod)\n        public\n        onlyApprovedManager\n    {\n        stakingLockPeriod = newPeriod;\n    }\n\n    function setEarnPeriod(uint256 newSeconds) public onlyApprovedManager {\n        earnPeriodSeconds = newSeconds;\n    }\n\n    function setEarningMultiplier(\n        address addr,\n        uint256 numerator,\n        uint256 denominator\n    ) public onlyApprovedManager {\n        refreshTokensEarned(addr);\n        accounts[addr].stakingMultiplier = StakingMultiplier(\n            numerator - 1,\n            denominator - 1\n        );\n    }\n\n    function addStakingListener(address contractAddress) public onlyOwner {\n        listeners.push(IStakingListener(contractAddress));\n    }\n\n    function resetStakingListeners() public onlyOwner {\n        delete listeners;\n    }\n\n    // Do not use in actual transaction due to massive gas cost.\n    function stakedTokensOfOwner(\n        address addr,\n        uint256 start,\n        uint256 stop\n    ) public view returns (uint256[] memory) {\n        if (accounts[addr].numStaked == 0) {\n            return new uint256[](0);\n        }\n\n        uint256 index = 0;\n        uint256[] memory ownedTokens = new uint256[](accounts[addr].numStaked);\n\n        for (uint256 tokenId = start; tokenId <= stop; tokenId++) {\n            if (tokens[tokenId].owner == addr) {\n                ownedTokens[index] = tokenId;\n                index++;\n                if (index == accounts[addr].numStaked) {\n                    break;\n                }\n            }\n        }\n\n        return ownedTokens;\n    }\n\n    // Only for use in emergency. Can be called by owner to unstake. Does not update the rest of the contract state.\n    function unstakeAsOwner(address addr, uint256[] calldata tokenIds)\n        public\n        onlyOwner\n    {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            surrealestates.transferFrom(address(this), addr, tokenIds[i]);\n        }\n    }\n\n    function pointsByTokenId(uint256 tokenId) public view returns (uint256) {\n        return 1000 + uint256(uint8(rawPointsByTokenId[tokenId]));\n    }\n\n    function setRawPoints(bytes memory newRawPoints) public onlyOwner {\n        rawPointsByTokenId = newRawPoints;\n    }\n\n    bytes rawPointsByTokenId;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "evmVersion": "london",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}