{{
  "language": "Solidity",
  "sources": {
    "/contracts/LP_Staking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\nimport \"./IERC20.sol\";\n\ncontract LP_Staking {\n  // balances are stored as uint168 so the structs take up one storage\n  // slot instead of two\n  struct User {\n    bool has_prerewards;\n    uint8 epoch_start;\n    uint168 balance;\n  }\n\n  // Track the total balance for each epoch, such that a per user reward share\n  // can be calculated effectively\n  struct Epoch {\n    uint8 epoch_number;\n    uint248 balance;\n  }\n\n  // Prerewards are compensation for LP holders before this contract was\n  // deployed. The shares are calculated off-chain and added after deployment.\n  // We use 20 bytes for address and 12 bytes for share\n  struct Prereward {\n    address user;\n    uint104 share;\n  }\n\n  uint256 public immutable staking_start;\n  uint256 public immutable staking_end;\n\n  uint256 public immutable epoch_seconds;\n  uint8 public immutable epoch_count;\n\n  uint256 public immutable epoch_reward;\n\n  IERC20 public immutable trusted_lp_token;\n  IERC20 public immutable trusted_reward_token;\n\n  address immutable rewards_refund;\n\n  // List of epochs. Note that this array can have \"gaps\", such that successive\n  // epochs are always monotonically increasing, but many to be exactly one\n  // increment after the other\n  Epoch[] public epochs;\n  mapping (address => User) public users;\n\n  uint256 prerewards_total;\n  // We promote the uint104 share to uint256\n  mapping (address => uint256) public prerewards;\n\n  // Precision here is based on our cap of 168 bits per user balance.\n  // Read this as '88 bits', as we use bit shift to move the precision up and\n  // down in the rewards calculation\n  uint256 constant PRECISION = 88;\n\n  // This precision is directly controlled as we store 104 bits of share data\n  uint256 PREREWARD_PRECISION = 88;\n\n  address controller;\n\n  constructor (\n    address lp_token_address,\n    address reward_token_address,\n    uint8 _epoch_count,\n    uint256 _epoch_seconds,\n    uint256 _epoch_reward,\n    address _rewards_refund\n  ) {\n    staking_start = block.timestamp;\n    staking_end = block.timestamp + _epoch_count * _epoch_seconds;\n\n    epoch_count = _epoch_count;\n    epoch_seconds = _epoch_seconds;\n    epoch_reward = _epoch_reward;\n\n    trusted_lp_token = IERC20(lp_token_address);\n    trusted_reward_token = IERC20(reward_token_address);\n\n    // We add the first epoch as our base-case.\n    // I believe this could be optimised to just manipulate the length\n    // of epochs\n    epochs.push(Epoch(0, 0));\n\n    controller = msg.sender;\n    rewards_refund = _rewards_refund;\n  }\n\n  function get_current_epoch_number () public view returns (uint8) {\n    // First statement here is unreacable as block.timestamp is always monotonic\n    // increasing\n    // if (block.timestamp < staking_start) return 0;\n    if (block.timestamp > staking_end) return epoch_count;\n\n    return uint8((block.timestamp - staking_start) / epoch_seconds);\n  }\n\n  function total_staked_for_user (\n    address user\n  ) external view returns (\n    uint256\n  ) {\n    return uint256(users[user].balance);\n  }\n\n  function get_available_reward (address user) external view returns (uint256) {\n    return _reward_balance(user);\n  }\n\n  function total_staked () external view returns (uint256) {\n    return uint256(epochs[epochs.length - 1].balance);\n  }\n\n  function init_prerewards (\n    Prereward[] calldata _users,\n    uint256 _prerewards_total\n  ) external only_controller {\n    prerewards_total = _prerewards_total;\n    for (uint idx = 0; idx < _users.length; idx++) {\n      Prereward calldata pr = _users[idx];\n\n      users[pr.user].has_prerewards = true;\n      prerewards[pr.user] = pr.share;\n    }\n  }\n\n  // Notes:\n  // - You cannot stake 0 tokens\n  // - You must unstake before you can restake\n  // - You cannot stake more than 2**168\n  //   (rather no more than 2**248 can be staked in total)\n  // - You cannot stake in the very last epoch\n  function stake (uint168 value) external returns (bool) {\n    require(value > 0, \"Must provide positive stake amount\");\n\n    User storage user = users[msg.sender];\n    require(user.balance == 0, \"Must unstake before stake\");\n\n    uint8 epoch_number = get_current_epoch_number();\n    require(epoch_number < epoch_count, \"Staking has ended\");\n\n    Epoch storage latest_epoch = epochs[epochs.length - 1];\n    // Check for overflow before we mutate anything\n    require(type(uint248).max - latest_epoch.balance >= value, \"Total stake is too high\");\n\n    trusted_lp_token.transferFrom(msg.sender, address(this), value);\n\n    user.epoch_start = epoch_number;\n    user.balance = value;\n\n    if (latest_epoch.epoch_number == epoch_number) {\n      latest_epoch.balance += value;\n    } else {\n      epochs.push(Epoch(epoch_number, latest_epoch.balance + value));\n    }\n\n    return true;\n  }\n\n  function unstake () external returns (bool) {\n    User storage user = users[msg.sender];\n    uint168 balance = user.balance;\n    require(balance > 0, \"Must stake before unstake\");\n    uint256 reward = _reward_balance(msg.sender);\n\n    // This is the tricky part about working with epochs, so please read\n    // carefully. We have to remember that the array of epochs is always\n    // in order of increasing epoch_number, but can have gaps between\n    // epochs, eg: [e0, e2, e3, e7]. Epochs are only inserted when someone\n    // stakes or unstakes, which allows us to make some assumptions below.\n    // From hereon forward, withdrawing rewards is the same as staking, as\n    // that operation essentially moves up the time a user started staking to\n    // the previous epoch.\n    //\n    // When looking at eg. e0, the balance is actually the total balance\n    // staked for the next epoch, as you will only get rewarded for full\n    // epochs. When the epoch counter increments (by virtue of time),\n    // the latest epoch is simply \"drawn forward\", as the balance must\n    // have been the same until someone decided to either stake or\n    // unstake, at which point a new epoch struct must be created and\n    // the balance updated.\n    uint8 epoch_number = get_current_epoch_number();\n    uint256 epoch_len = epochs.length;\n    Epoch storage latest_epoch = epochs[epoch_len - 1];\n\n    // Rewards are paid for full epochs which have been staked, which gives a\n    // couple of scenarios:\n    //\n    // 1. User stakes in e0 and unstakes in e0, giving no reward\n    // 2. User stakes in e0 and unstakes in e1, giving no reward\n    // 3. user stakes in e0 and unstakes in eN, giving rewards for e1 to e(N-1)\n    //    both of those epochs incluseive.\n    //\n    // This means that unless we are in case 1. above, we have to change the\n    // balance of two epochs for the ratio of user balance to total balance, to\n    // be fair. This is a little subtle, but we need this as we draw balances\n    // forward into epochs that have not vested yet, however we do not want to\n    // compensate someone for joining the end of e0 and leaving at the start of\n    // e1\n\n    // When unstaking we have two overarching cases to cover:\n    //  1. The user staked and unstaked in the latest epoch\n    //  2. The user staked in a previous epoch than the latest\n\n    // Here we cover case 1. which is the simplest, since the epoch that\n    // the user staked in, is also the one they unstake in. `epoch_start`\n    // can be set by `stake` and `withdraw_rewards`, however the latter\n    // will always set it in the past, hence the strict equality can\n    // never be true in that case. Therefore we know that the two can\n    // only be equal, if in fact the user staked and unstaked in the\n    // same epoch\n    if (epoch_number == user.epoch_start) {\n      latest_epoch.balance -= balance;\n    }\n    // Now we get to case 2. where the user staked in any previous epoch\n    // and we have fix more than one epoch balance\n    else {\n\n      // Let's explain the situation. We can have a couple of complicated\n      // cases here, but remember that epochs are always in order.\n      //\n      // 1. Zero epochs have elapsed since someone either staked or unstaked\n      // 2. One epoch has elapsed since someone either staked or unstaked\n      // 3. Two or more epochs have elapsed since someone staked or unstaked\n\n\n      // We're at the latest epoch\n      if (latest_epoch.epoch_number == epoch_number) {\n        latest_epoch.balance -= balance;\n\n        // We need to look at the previous epoch\n        // There must be at least two epochs, since the latest epoch\n        // is not the one the user staked in, but the earlies epoch someone\n        // could stake is e0, so we must have at least e0 and e1 (or any other\n        // combination)\n        Epoch storage previous_epoch = epochs[epoch_len - 2];\n        // We were lucky and they were in sequence\n        if (previous_epoch.epoch_number == epoch_number - 1) {\n          previous_epoch.balance -= balance;\n        }\n        // We have to duplicate the latest epoch and fix it up\n        else {\n          // This part is very subtle\n          // We essentially clone the latest epoch by pushing it on\n          epochs.push(latest_epoch);\n          // then decrement the 2nd to last epoch to have two in sequence\n          latest_epoch.epoch_number--;\n          // We do not need to decrement the balance, as that was done\n          // before duplicating\n\n          // Example:\n          // We have: [..., e6, e8]\n          // We then push: [..., e6, e8, e8]\n          // And then decr: [..., e6, e8--, e8]\n          // To get: [..., e6, e7, e8]\n        }\n      }\n      // We're just one short\n      else if (latest_epoch.epoch_number == epoch_number - 1) {\n        // Again we can duplicate the epoch after decrementing the balance\n        latest_epoch.balance -= balance;\n        epochs.push(Epoch(epoch_number, latest_epoch.balance));\n      }\n      // We're way in the past and can add both new epochs\n      else {\n        epochs.push(Epoch(epoch_number - 1, latest_epoch.balance - balance));\n        epochs.push(Epoch(epoch_number, latest_epoch.balance - balance));\n      }\n    }\n\n    // Deleting the user gives a gas refund, and there's no reason to keep their\n    // state\n    if (user.has_prerewards) {\n      delete prerewards[msg.sender];\n    }\n\n    delete users[msg.sender];\n\n    trusted_lp_token.transfer(msg.sender, balance);\n    trusted_reward_token.transfer(msg.sender, reward);\n    return true;\n  }\n\n  function withdraw_rewards () external returns (bool) {\n    uint256 reward = _reward_balance(msg.sender);\n    if (reward == 0) return true;\n\n    uint8 epoch_number = get_current_epoch_number();\n    User storage user = users[msg.sender];\n    // First condition here ensures we don't underflow, as the user may\n    // be able to withdraw rewards that come from prerewards. 2nd condition\n    // indirectly checks that the rewards were in fact prerewards\n    if (epoch_number > 0 && user.balance > 0) {\n      user.epoch_start = epoch_number - 1;\n    }\n\n    if (user.has_prerewards) {\n      user.has_prerewards = false;\n      delete prerewards[msg.sender];\n    }\n\n    trusted_reward_token.transfer(msg.sender, reward);\n    return true;\n  }\n\n  function _reward_balance (address _user) internal view returns (uint256) {\n    uint256 staking_reward = 0;\n    User memory user = users[_user];\n\n    if (user.has_prerewards) {\n      staking_reward +=\n        (prerewards[_user] * prerewards_total) >> PREREWARD_PRECISION;\n    }\n\n    // We know that zero user balance, means no rewards\n    if (user.balance == 0) return staking_reward;\n\n    uint8 epoch_number = get_current_epoch_number();\n    // We also know that at least one full epoch must elaps for there to be\n    // any rewards. Eg. stake at t0, does not give any rewards until t2\n    if (epoch_number <= user.epoch_start) return staking_reward;\n\n    uint epoch_len = epochs.length - 1;\n    Epoch memory epoch_u = epochs[epoch_len];\n    // The next check is kept for completeness but is redundant. If any\n    // execution can make it to this step, the balance cannot by definiton be\n    // zero, because some user must have balance\n    // if (epoch_u.balance == 0) return 0;\n\n    // By the rules of how rewards are calculated, we only pay rewards for\n    // elapsed epochs, so if we are looking at the current epoch, we must go\n    // back before that. This can happen if someone stakes or unstakes before we\n    // calculate rewards\n    if (epoch_u.epoch_number == epoch_number) {\n      epoch_len--;\n      epoch_u = epochs[epoch_len];\n    }\n\n    // If the latest epoch is not the one that just elapsed, it means we must\n    // be looking at a gap, eg. we are at e6, but the array is [e0], so we must\n    // create a \"fake\" e5, and \"push back\" e0 into the array\n    if (epoch_u.epoch_number < epoch_number - 1) {\n      // \"push back\", so we look at this epoch again in the loop\n      epoch_len++;\n      // create the fake epoch\n      epoch_u = Epoch(epoch_number - 1, epoch_u.balance);\n    }\n\n    // We can sum up just part of the calculation, as other parts are constant\n    uint256 aggregate_reward_share = 0;\n\n    // We use a while loop here as Solidity has a bug where it will decrement\n    // below zero before checking the condition, causing the new overflow\n    // protection to revert\n    uint idx = epoch_len;\n    while (epoch_u.epoch_number > user.epoch_start) {\n      Epoch memory epoch_l = epochs[idx - 1];\n\n      // Since withdraw_rewards might set the `epoch_start` to something that\n      // does not exist, we may have to add a fake epoch here\n      if (epoch_l.epoch_number < user.epoch_start) {\n        epoch_l = Epoch(user.epoch_start, epoch_l.balance);\n        idx = 0; // defer break\n      }\n\n      uint256 epochSpan = uint256(epoch_u.epoch_number - epoch_l.epoch_number);\n\n      // user.balance is constant, however precision errors arise if moved\n      // outside the loop. `<< PRECISION` is the same as `* 2**PRECISION`\n      // but cheaper\n      aggregate_reward_share +=\n        ((user.balance * epochSpan) << PRECISION) / epoch_l.balance;\n\n      if (idx == 0) break;\n\n      // swap places\n      epoch_u = epoch_l;\n      // This can never underflow, as the break above will always trigger at the\n      // latest on e0\n      idx--;\n    }\n\n    staking_reward += (aggregate_reward_share * epoch_reward) >> PRECISION;\n\n    return staking_reward;\n  }\n\n  // This function is for emergency use only. It specifically only looks at\n  // stored data and does not perform any of the algorithmic reward calculations\n  // to prevent any reverts causing the contract to lock up. User addresses must\n  // be collected off-chain to issue refunds back to the wallets that did the\n  // staking. This means we have no authority to take away tokens, only to\n  // return them. An additional rewards_refund addres must be provided to\n  // receive the remaining rewards tokens, as this contract \"owns\" those tokens.\n  // Calling this function is \"idempotent\", albeit wasteful\n  function emergency_refund (\n    address[] calldata _users\n  ) external only_controller {\n\n    uint248 total_balance = 0;\n    for (uint idx = 0; idx < _users.length; idx++) {\n      address addr = _users[idx];\n      uint168 balance = users[addr].balance;\n      total_balance += balance;\n\n      delete users[addr];\n      trusted_lp_token.transfer(addr, balance);\n    }\n\n    uint8 epoch_number = get_current_epoch_number();\n    Epoch storage latest_epoch = epochs[epochs.length - 1];\n    if (latest_epoch.epoch_number == epoch_number) {\n      latest_epoch.balance -= total_balance;\n    } else {\n      epochs.push(Epoch(epoch_number, latest_epoch.balance - total_balance));\n    }\n\n    trusted_reward_token.transfer(\n      rewards_refund,\n      trusted_reward_token.balanceOf(address(this))\n    );\n  }\n\n  function set_controller(address new_controller) external only_controller {\n    require(new_controller != address(0), \"Controller cannot be address(0)\");\n    controller = new_controller;\n  }\n\n  modifier only_controller () {\n    require(msg.sender == controller, \"Only controller can invoke this function\");\n    _;\n  }\n}\n"
    },
    "/contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 20000
    },
    "evmVersion": "berlin",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}