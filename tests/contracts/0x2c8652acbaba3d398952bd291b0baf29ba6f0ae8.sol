{"SafeMath.sol":{"content":"pragma solidity ^0.6.12;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c \u003e= a, \u0027SafeMath:INVALID_ADD\u0027);\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b \u003c= a, \u0027SafeMath:OVERFLOW_SUB\u0027);\r\n        c = a - b;\r\n    }\r\n\r\n    function mul(uint a, uint b, uint decimal) internal pure returns (uint) {\r\n        uint dc = 10**decimal;\r\n        uint c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"SafeMath: multiple overflow\");\r\n        uint c1 = c0 + (dc / 2);\r\n        require(c1 \u003e= c0, \"SafeMath: multiple overflow\");\r\n        uint c2 = c1 / dc;\r\n        return c2;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, uint decimal) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: division by zero\");\r\n        uint dc = 10**decimal;\r\n        uint c0 = a * dc;\r\n        require(a == 0 || c0 / a == dc, \"SafeMath: division internal\");\r\n        uint c1 = c0 + (b / 2);\r\n        require(c1 \u003e= c0, \"SafeMath: division internal\");\r\n        uint c2 = c1 / b;\r\n        return c2;\r\n    }\r\n}\r\n"},"TransferHelper.sol":{"content":"pragma solidity ^0.6.12;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes(\u0027approve(address,uint256)\u0027)));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(\r\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\r\n            \u0027TransferHelper::safeApprove: approve failed\u0027\r\n        );\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes(\u0027transfer(address,uint256)\u0027)));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(\r\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\r\n            \u0027TransferHelper::safeTransfer: transfer failed\u0027\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes(\u0027transferFrom(address,address,uint256)\u0027)));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(\r\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\r\n            \u0027TransferHelper::transferFrom: transferFrom failed\u0027\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, \u0027TransferHelper::safeTransferETH: ETH transfer failed\u0027);\r\n    }\r\n}\r\n"},"TubeChief.sol":{"content":"pragma solidity ^0.6.12;\r\n\r\nimport \u0027./TransferHelper.sol\u0027;\r\nimport \u0027./SafeMath.sol\u0027;\r\n\r\ncontract TubeChief {\r\n    using SafeMath for uint;\r\n\r\n    uint constant DECIMAL = 18;\r\n    uint constant FARMER  = 750000000000000000;\r\n    uint constant DEV     = 100000000000000000;\r\n    uint constant LOTTERY = 150000000000000000;\r\n\r\n    struct PoolInfo {\r\n        address lpTokenAddress; // the LP token pair address\r\n        uint rewardPerBlock;    // number of TUBE will mint per block\r\n        uint lastBlockNo;       // record pool mint finish last block number\r\n        uint lastDevBlockNo;    // record token mint to development last block number\r\n        uint lastLotBlockNo;    // record token mint to lottery last block number\r\n        uint accLpStaked;       // accumulate number of LP token user staked\r\n        uint accLastBlockNo;    // record last pass in block number\r\n        uint multiplier;        // reward multiplier\r\n        uint accTokenPerShare;  // accumulated token per share\r\n        bool locked;            // pool is locked\r\n        bool finished;          // pool is stop mint token. disable deposit. only allow claim\r\n    }\r\n\r\n    struct UserPoolInfo {\r\n        uint lpStaked;       // user staked LP\r\n        uint rewardDebt;     // user debt\r\n        uint lastClaimBlock; // last block number user retrieve reward\r\n    }\r\n\r\n    mapping(uint =\u003e PoolInfo) public pools; // dynamic pool container (pool ID =\u003e pool related data)\r\n    mapping(address =\u003e uint[]) poolIdByLp;  // pool ids recorder (LP token =\u003e pool ids)\r\n\r\n    // user pool allocate (user addr =\u003e (\u003cpool ID\u003e =\u003e user pool data))\r\n    mapping(address =\u003e mapping(uint =\u003e UserPoolInfo)) public users;\r\n\r\n    address public owner;   // owner of tube chief\r\n    address public tube;    // the TUBE token\r\n    address public devaddr; // development address\r\n    address public lotaddr; // lottery address\r\n    uint public poolLength; // next pool id. current length is (poolLength - 1)\r\n\r\n    event CreatePool(address lpTokenAddress, uint rewardPerBlock, uint poolId);\r\n    event UpdatePool(uint poolId, uint rewardPerBlock, uint multiplier, bool locked);\r\n    event Claim(uint poolId, uint amount, uint claimable);\r\n    event TransferCompany(address old_owner, address new_owner);\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \u0027NOT OWNER\u0027);\r\n        _;\r\n    }\r\n\r\n    constructor (address _tube, address _devaddr, address _lotaddr) public {\r\n        owner   = msg.sender;\r\n        tube    = _tube;\r\n        devaddr = _devaddr;\r\n        lotaddr = _lotaddr;\r\n    }\r\n\r\n    // create new pool. only owner executable\r\n    // XX do not create twice on same LP token. reward will mess up if you do\r\n    function createPool(address _lpTokenAddress, uint _rewardPerBlock, uint _multiplier) public onlyOwner {\r\n        require(_lpTokenAddress != address(0), \u0027CREATE_POOL_EMPTY_ADDRESS\u0027);\r\n\r\n        emit CreatePool(_lpTokenAddress, _rewardPerBlock, poolLength);\r\n        pools[poolLength].lpTokenAddress = _lpTokenAddress;\r\n        pools[poolLength].rewardPerBlock = _rewardPerBlock;\r\n        pools[poolLength].multiplier     = _multiplier;\r\n        pools[poolLength].accLastBlockNo = block.number;\r\n        pools[poolLength].lastDevBlockNo = block.number;\r\n        pools[poolLength].lastLotBlockNo = block.number;\r\n        poolIdByLp[_lpTokenAddress].push(poolLength);\r\n        poolLength = poolLength.add(1);\r\n    }\r\n\r\n    // update pool setting, edit wisely. only owner executable\r\n    function updatePool(uint poolId, uint _rewardPerBlock, uint _multiplier, bool _locked) public onlyOwner {\r\n        _updateAccTokenPerShare(poolId);\r\n        pools[poolId].rewardPerBlock = _rewardPerBlock;\r\n        pools[poolId].multiplier     = _multiplier;\r\n        pools[poolId].locked         = _locked;\r\n        emit UpdatePool(poolId, _rewardPerBlock, _multiplier, _locked);\r\n    }\r\n\r\n    // update development address. only owner executable\r\n    function updateDevAddr(address _address) public onlyOwner {\r\n        devaddr = _address;\r\n    }\r\n\r\n    // update lottery address. only owner executable\r\n    function updateLotAddr(address _address) public onlyOwner {\r\n        lotaddr = _address;\r\n    }\r\n\r\n    // set pool stop mint token. claim reward based on last block number recorded. only owner executable\r\n    function updatePoolFinish(uint poolId, bool _finished) public onlyOwner {\r\n        pools[poolId].finished    = _finished;\r\n        pools[poolId].lastBlockNo = _finished ? block.number : 0;\r\n    }\r\n\r\n    // stake LP token to earn TUBE\r\n    function stake(uint poolId, uint amount) public {\r\n        require(pools[poolId].lpTokenAddress != address(0), \u0027STAKE_POOL_NOT_EXIST\u0027);\r\n        require(pools[poolId].locked == false, \u0027STAKE_POOL_LOCKED\u0027);\r\n        require(pools[poolId].finished == false, \u0027STAKE_POOL_FINISHED\u0027);\r\n\r\n        claim(poolId, 0);\r\n        TransferHelper.safeTransferFrom(pools[poolId].lpTokenAddress, msg.sender, address(this), amount);\r\n        pools[poolId].accLpStaked = pools[poolId].accLpStaked.add(amount);\r\n        users[msg.sender][poolId].lpStaked       = users[msg.sender][poolId].lpStaked.add(amount);\r\n        users[msg.sender][poolId].lastClaimBlock = block.number;\r\n        users[msg.sender][poolId].rewardDebt     = pools[poolId].accTokenPerShare.mul(users[msg.sender][poolId].lpStaked, DECIMAL);\r\n    }\r\n\r\n    // claim TUBE token. input LP token to exit pool\r\n    function claim(uint poolId, uint amount) public {\r\n        require(pools[poolId].lpTokenAddress != address(0), \u0027CLAIM_POOL_NOT_EXIST\u0027);\r\n        require(pools[poolId].locked == false, \u0027CLAIM_POOL_LOCKED\u0027);\r\n        \r\n        _updateAccTokenPerShare(poolId);\r\n\r\n        uint claimable = _getRewardAmount(poolId);\r\n        if (claimable \u003e 0) {\r\n            ITubeToken(tube).farmMint(address(this), claimable);\r\n            TransferHelper.safeTransfer(tube, msg.sender, claimable);\r\n            users[msg.sender][poolId].lastClaimBlock = block.number;\r\n        }\r\n\r\n        if (amount \u003e 0) {\r\n            TransferHelper.safeTransfer(pools[poolId].lpTokenAddress, msg.sender, amount);\r\n            users[msg.sender][poolId].lpStaked = users[msg.sender][poolId].lpStaked.sub(amount);\r\n            pools[poolId].accLpStaked = pools[poolId].accLpStaked.sub(amount);\r\n        }\r\n\r\n        // emit if necessary. cost saving\r\n        if (claimable \u003e 0 || amount \u003e 0) {\r\n            emit Claim(poolId, amount, claimable);\r\n        }\r\n\r\n        // update the user reward debt at this moment\r\n        users[msg.sender][poolId].rewardDebt = pools[poolId].accTokenPerShare.mul(users[msg.sender][poolId].lpStaked, DECIMAL);\r\n    }\r\n\r\n    // get token per share with current block number\r\n    function getAccTokenInfo(uint poolId) public view returns (uint) {\r\n        if (pools[poolId].accLpStaked \u003c= 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint reward_block = pools[poolId].rewardPerBlock;\r\n        uint multiplier   = pools[poolId].multiplier;\r\n        uint total_staked = pools[poolId].accLpStaked;\r\n        uint pending      = block.number.sub(pools[poolId].accLastBlockNo);\r\n        pending           = pending * 10**DECIMAL; // cast to \"wei\" unit\r\n        uint result       = reward_block.mul(multiplier, DECIMAL).mul(pending, DECIMAL).mul(FARMER, DECIMAL);\r\n\r\n        return result.div(total_staked, DECIMAL);\r\n    }\r\n\r\n    // emergency collect token from the contract. only owner executable\r\n    function emergencyCollectToken(address token, uint amount) public onlyOwner {\r\n        IERC20(token).transfer(owner, amount);\r\n    }\r\n\r\n    // emergency collect eth from the contract. only owner executable\r\n    function emergencyCollectEth(uint amount) public onlyOwner {\r\n        address payable owner_address = payable(owner);\r\n        owner_address.send(amount);\r\n    }\r\n\r\n    // transfer ownership. proceed wisely. only owner executable\r\n    function transferCompany(address new_owner) public onlyOwner {\r\n        owner = new_owner;\r\n        emit TransferCompany(owner, new_owner);\r\n    }\r\n\r\n    // transfer mintable token to development address\r\n    function transferDev(uint poolId) public onlyOwner {\r\n        uint mintable = getExMintable(poolId, true);\r\n        require(mintable \u003e 0, \u0027TRANSFER_DEV_EMPTY\u0027);\r\n        ITubeToken(tube).farmMint(address(this), mintable);\r\n        TransferHelper.safeTransfer(tube, devaddr, mintable);\r\n        pools[poolId].lastDevBlockNo = block.number;\r\n    }\r\n\r\n    // transfer mintable token to lottery address\r\n    function transferLottery(uint poolId) public onlyOwner {\r\n        uint mintable = getExMintable(poolId, false);\r\n        require(mintable \u003e 0, \u0027TRANSFER_LOT_EMPTY\u0027);\r\n        ITubeToken(tube).farmMint(address(this), mintable);\r\n        TransferHelper.safeTransfer(tube, lotaddr, mintable);\r\n        pools[poolId].lastLotBlockNo = block.number;\r\n    }\r\n\r\n    // retrieve the mintable amount for development or lottery\r\n    function getExMintable(uint poolId, bool is_dev) public view returns (uint) {\r\n        uint last_block   = 0;\r\n        uint rate         = 0;\r\n\r\n        if (is_dev) {\r\n            last_block = pools[poolId].lastDevBlockNo;\r\n            rate       = DEV;\r\n        } else {\r\n            last_block = pools[poolId].lastLotBlockNo;\r\n            rate       = LOTTERY;\r\n        }\r\n\r\n        uint block_diff = block.number.sub(last_block);\r\n        block_diff      = block_diff * 10**DECIMAL;\r\n\r\n        return block_diff.mul(pools[poolId].rewardPerBlock, DECIMAL).mul(pools[poolId].multiplier, DECIMAL).mul(rate, DECIMAL);\r\n    }\r\n\r\n    // retrieve pool ids by LP token address\r\n    function getPidByLpToken(address _lpTokenAddress) public view returns (uint[] memory) {\r\n        return poolIdByLp[_lpTokenAddress];\r\n    }\r\n\r\n    // retrieve user reward info on the pool with current block number\r\n    function getUserReward(uint poolId) public view returns (uint, uint, uint, uint, uint) {\r\n        uint accTokenPerShare = getAccTokenInfo(poolId);\r\n        accTokenPerShare      = accTokenPerShare.add(pools[poolId].accTokenPerShare);\r\n        \r\n        uint claimable = accTokenPerShare.mul(users[msg.sender][poolId].lpStaked, DECIMAL).sub(users[msg.sender][poolId].rewardDebt);\r\n        return (block.number, claimable, accTokenPerShare, users[msg.sender][poolId].lpStaked, users[msg.sender][poolId].rewardDebt);\r\n    }\r\n    \r\n    function _updateAccTokenPerShare(uint poolId) internal {\r\n        uint result = getAccTokenInfo(poolId);\r\n        pools[poolId].accTokenPerShare = pools[poolId].accTokenPerShare.add(result);\r\n        pools[poolId].accLastBlockNo   = block.number;\r\n    }\r\n\r\n    function _getRewardAmount(uint poolId) view internal returns (uint) {\r\n        if (pools[poolId].accLpStaked \u003c= 0) {\r\n            return (0);\r\n        }\r\n\r\n        uint user_staked = users[msg.sender][poolId].lpStaked;\r\n        uint user_debt   = users[msg.sender][poolId].rewardDebt;\r\n        uint claimable   = pools[poolId].accTokenPerShare.mul(user_staked, DECIMAL).sub(user_debt);\r\n\r\n        return (claimable);\r\n    }\r\n\r\n    fallback() external payable {\r\n    }\r\n}\r\n\r\ninterface ITubeToken {\r\n    function farmMint(address _address, uint amount) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n}\r\n"}}