{"Interfaces.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.7;\n\ninterface IERC20Like {\n\n    function balanceOf(address account_) external view returns (uint256 balance_);\n\n    function transfer(address recipient_, uint256 amount_) external returns (bool success_);\n\n    function allowance(address owner_, address spender_) external view returns (uint256 allowance_);\n\n    function approve(address spender_, uint256 amount_) external returns (bool success_);\n\n    function transferFrom(address sender_, address recipient_, uint256 amount_) external returns (bool success_);\n\n}\n"},"ITokenVesting.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.7;\n\ninterface ITokenVesting {\n\n    /**************************/\n    /*** Contract Ownership ***/\n    /**************************/\n\n    event OwnershipTransferPending(address indexed owner, address indexed pendingOwner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @dev Returns the owner of the contract.\n    function owner() external view returns (address owner_);\n\n    /// @dev Returns the pending owner of the contract.\n    function pendingOwner() external view returns (address pendingOwner_);\n\n    /// @dev Leaves the contract without owner, and clears the pendingOwner, if any.\n    function renounceOwnership() external;\n\n    /// @dev Allows a new account to take ownership of the contract.\n    function transferOwnership(address newOwner_) external;\n\n    /// @dev Takes ownership of the contract.\n    function acceptOwnership() external;\n\n    /*********************/\n    /*** Token Vesting ***/\n    /*********************/\n\n    /**\n     * @dev   Is emitted when a token vesting schedule is set for a receiver.\n     * @param receiver_ The receiver of a token vesting schedule.\n     */\n    event VestingScheduleSet(address indexed receiver_);\n\n    /**\n     * @dev   Is emitted when the contract is funded for vesting.\n     * @param totalTokens_ The total amount of tokens to be vested.\n     */\n    event VestingFunded(uint256 totalTokens_);\n\n    /**\n     * @dev   Is emitted when the receiver of a token vesting schedule is changed.\n     * @param oldReceiver The old receiver of the token vesting schedule.\n     * @param newReceiver The new receiver of the token vesting schedule.\n     */\n    event ReceiverChanged(address indexed oldReceiver, address indexed newReceiver);\n\n    /**\n     * @dev   Is emitted when the token vesting schedule for a receiver is killed.\n     * @param receiver_      The receiver that had its token vesting schedule killed.\n     * @param tokensClaimed_ The amount of tokens claimed.\n     * @param destination_   The destination the token have been sent to.\n     */\n    event VestingKilled(address indexed receiver_, uint256 tokensClaimed_, address indexed destination_);\n\n    /**\n     * @dev   Is emitted when a receiver claims tokens from its vesting schedule.\n     * @param receiver_      The receiver of a token vesting schedule.\n     * @param tokensClaimed_ The amount of tokens claimed.\n     * @param destination_   The destination the claimed tokens have been sent to.\n     */\n    event TokensClaimed(address indexed receiver_, uint256 tokensClaimed_, address indexed destination_);\n\n    struct VestingSchedule {\n        uint256 startTime;\n        uint256 cliff;\n        uint256 totalPeriods;\n        uint256 timePerPeriod;\n        uint256 totalTokens;\n        uint256 tokensClaimed;\n    }\n\n    /// @dev The vesting token.\n    function token() external returns (address token_);\n\n    /// @dev The total amount of tokens being vested.\n    function totalVestingsTokens() external returns (uint256 totalVestingsTokens_);\n\n    /**\n     * @dev   Returns the vesting schedule of a receiver.\n     * @param receiver_      The receiver of a vesting schedule.\n     */\n    function vestingScheduleOf(address receiver_) external returns (\n        uint256 startTime_,\n        uint256 cliff_,\n        uint256 totalPeriods_,\n        uint256 timePerPeriod_,\n        uint256 totalTokens_,\n        uint256 tokensClaimed_\n    );\n\n    /**\n     * @dev   Set the vesting schedules for some receivers, respectively.\n     * @param receivers_ An array of receivers of vesting schedules.\n     * @param vestings_  An array of vesting schedules.\n     */\n    function setVestingSchedules(address[] calldata receivers_, VestingSchedule[] calldata vestings_) external;\n\n    /**\n     * @dev   Fund the contact with tokens that will be vested.\n     * @param totalTokens_ The amount of tokens that will be supplied to this contract.\n     */\n    function fundVesting(uint256 totalTokens_) external;\n\n    /**\n     * @dev   Change the receiver of an existing vesting schedule.\n     * @param oldReceiver_ The old receiver address.\n     * @param newReceiver_ The new receiver address.\n     */\n    function changeReceiver(address oldReceiver_, address newReceiver_) external;\n\n    /**\n     * @dev    Returns the amount of claimable tokens for a receiver of a vesting schedule.\n     * @param  receiver_        The receiver address.\n     * @return claimableTokens_ The amount of claimable tokens.\n     */\n    function claimableTokens(address receiver_) external view returns (uint256 claimableTokens_);\n\n    /**\n     * @dev   Claim the callers tokens of a vesting schedule.\n     * @param destination_ The destination to send the tokens.\n     */\n    function claimTokens(address destination_) external;\n\n    /**\n     * @dev   Kill the vesting schedule for a receiver.\n     * @param receiver_    The receiver address.\n     * @param destination_ The destination to send the tokens.\n     */\n    function killVesting(address receiver_, address destination_) external;\n\n    /*********************/\n    /*** Miscellaneous ***/\n    /*********************/\n\n    /**\n     * @dev   Is emitted when some ERC20 token is recovered from the contract.\n     * @param token       The address of the token.\n     * @param amount      The amount of token recovered.\n     * @param destination The destination the token was sent to.\n     */\n    event RecoveredToken(address indexed token, uint256 amount, address indexed destination);\n\n    /**\n     * @dev   Recover tokens owned by the contract.\n     * @param token_       The token address.\n     * @param destination_ The destination to send the ETH.\n     */\n    function recoverToken(address token_, address destination_) external;\n\n}\n"},"MockERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.7;\n\ncontract MockERC20 {\n\n    string public name;\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    uint256 public totalSupply;\n\n    mapping(address =\u003e uint256) public balanceOf;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n        name     = name_;\n        symbol   = symbol_;\n        decimals = decimals_;\n    }\n\n    function approve(address spender_, uint256 amount_) external returns (bool success_) {\n        _approve(msg.sender, spender_, amount_);\n        return true;\n    }\n\n    function transfer(address to_, uint256 amount_) external returns (bool success_) {\n        _transfer(msg.sender, to_, amount_);\n        return true;\n    }\n\n    function transferFrom(address owner_, address recipient_, uint256 amount_) external returns (bool success_) {\n        _approve(owner_, msg.sender, allowance[owner_][msg.sender] - amount_);\n        _transfer(owner_, recipient_, amount_);\n        return true;\n    }\n\n    function mint(address recipient_, uint256 amount_) external returns (bool success_) {\n        _mint(recipient_, amount_);\n        return true;\n    }\n\n    function burn(address owner_, uint256 amount_) internal returns (bool success_) {\n        _burn(owner_, amount_);\n        return true;\n    }\n\n    function _approve(address owner_, address spender_, uint256 amount_) internal {\n        allowance[owner_][spender_] = amount_;\n    }\n\n    function _transfer(address owner_, address recipient_, uint256 amount_) internal {\n        balanceOf[owner_] -= amount_;\n        balanceOf[recipient_] += amount_;\n    }\n\n    function _mint(address recipient_, uint256 amount_) internal {\n        totalSupply += amount_;\n        balanceOf[recipient_] += amount_;\n    }\n\n    function _burn(address owner_, uint256 amount_) internal {\n        balanceOf[owner_] -= amount_;\n        totalSupply -= amount_;\n    }\n\n}\n"},"TokenVesting.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.7;\n\n// TODO: There is an issue where the sum of all vestingSchedule totalTokens is less than totalVestingsTokens.\n// NOTE: Excess of totalVestingsTokens, after paying out all totalTokens, requires awkward immediate vesting schedule to withdraw.\n\nimport { IERC20Like } from \"./Interfaces.sol\";\nimport { ITokenVesting } from \"./ITokenVesting.sol\";\n\ncontract TokenVesting is ITokenVesting {\n\n    address public override owner;\n    address public override pendingOwner;\n\n    address public override token;\n    uint256 public override totalVestingsTokens;\n\n    mapping(address =\u003e VestingSchedule) public override vestingScheduleOf;\n\n    /**\n     * @dev   Constructor.\n     * @param token_ The address of an erc20 token.\n     */\n    constructor(address token_) {\n        owner = msg.sender;\n        token = token_;\n    }\n\n    /**************************/\n    /*** Contract Ownership ***/\n    /**************************/\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"TV:NOT_OWNER\");\n        _;\n    }\n\n    function renounceOwnership() external override onlyOwner {\n        pendingOwner = owner = address(0);\n\n        emit OwnershipTransferred(msg.sender, address(0));\n    }\n\n    function transferOwnership(address newOwner_) external override onlyOwner {\n        pendingOwner = newOwner_;\n\n        emit OwnershipTransferPending(msg.sender, newOwner_);\n    }\n\n    function acceptOwnership() external override {\n        require(pendingOwner == msg.sender, \"TV:NOT_PENDING_OWNER\");\n\n        emit OwnershipTransferred(owner, msg.sender);\n\n        owner = msg.sender;\n        pendingOwner = address(0);\n    }\n\n    /*********************/\n    /*** Token Vesting ***/\n    /*********************/\n\n    function setVestingSchedules(address[] calldata receivers_, VestingSchedule[] calldata vestingSchedules_) external override onlyOwner {\n        for (uint256 i; i \u003c vestingSchedules_.length; ++i) {\n            address receiver = receivers_[i];\n\n            vestingScheduleOf[receiver] = vestingSchedules_[i];\n\n            emit VestingScheduleSet(receiver);\n        }\n    }\n\n    function fundVesting(uint256 totalTokens_) external override onlyOwner {\n        require(totalVestingsTokens == uint256(0), \"TV:ALREADY_FUNDED\");\n\n        _safeTransferFrom(token, msg.sender, address(this), totalTokens_);\n\n        totalVestingsTokens = totalTokens_;\n\n        emit VestingFunded(totalTokens_);\n    }\n\n    function changeReceiver(address oldReceiver_, address newReceiver_) external override onlyOwner {\n        // Swap old and new receivers\u0027 vesting schedule, using address(0) as a scratch space.\n        // This is done to not overwrite an active vesting schedule.\n        vestingScheduleOf[address(0)] = vestingScheduleOf[oldReceiver_];\n        vestingScheduleOf[oldReceiver_] = vestingScheduleOf[newReceiver_];\n        vestingScheduleOf[newReceiver_] = vestingScheduleOf[address(0)];\n\n        delete vestingScheduleOf[address(0)];\n\n        emit ReceiverChanged(oldReceiver_, newReceiver_);\n    }\n\n    function claimableTokens(address receiver_) public view override returns (uint256 claimableTokens_) {\n        VestingSchedule storage vestingSchedule = vestingScheduleOf[receiver_];\n\n        uint256 totalPeriods = vestingSchedule.totalPeriods;\n\n        if (totalPeriods == uint256(0)) return uint256(0);\n\n        uint256 timePassed = block.timestamp - vestingSchedule.startTime;\n        uint256 cliff = vestingSchedule.cliff;\n\n        if (timePassed \u003c= cliff) return uint256(0);\n\n        uint256 multiplier = (timePassed - cliff) / vestingSchedule.timePerPeriod;\n\n        return\n            (\n                (\n                    (\n                        multiplier \u003e totalPeriods ? totalPeriods : multiplier\n                    )\n                    * vestingSchedule.totalTokens\n                )\n                / totalPeriods\n            )\n            - vestingSchedule.tokensClaimed;\n    }\n\n    function claimTokens(address destination_) external override {\n        require(totalVestingsTokens \u003e uint256(0), \"TV:NOT_FUNDED\");\n\n        VestingSchedule storage vestingSchedule = vestingScheduleOf[msg.sender];\n\n        uint256 tokensToClaim = claimableTokens(msg.sender);\n\n        require(tokensToClaim \u003e uint256(0), \"TV:NO_CLAIMABLE\");\n\n        // NOTE: Setting tokensClaimed before transfer will result in no additional transfer on a reentrance.\n        vestingSchedule.tokensClaimed += tokensToClaim;\n\n        _safeTransfer(token, destination_, tokensToClaim);\n\n        emit TokensClaimed(msg.sender, tokensToClaim, destination_);\n    }\n\n    function killVesting(address receiver_, address destination_) external override onlyOwner {\n        VestingSchedule storage vestingSchedule = vestingScheduleOf[receiver_];\n\n        uint256 totalTokens = vestingSchedule.totalTokens;\n        uint256 tokensToClaim = totalTokens - vestingSchedule.tokensClaimed;\n\n        // NOTE: Setting tokensClaimed before transfer will result in no additional transfer on a reentrance.\n        vestingScheduleOf[receiver_].tokensClaimed = totalTokens;\n\n        _safeTransfer(token, destination_, tokensToClaim);\n\n        emit VestingKilled(receiver_, tokensToClaim, destination_);\n    }\n\n    /*********************/\n    /*** Miscellaneous ***/\n    /*********************/\n\n    function recoverToken(address token_, address destination_) external override onlyOwner {\n        require(token_ != token, \"TV:CANNOT_RECOVER_VESTING_TOKEN\");\n\n        uint256 amount = IERC20Like(token_).balanceOf(address(this));\n\n        require(amount \u003e uint256(0), \"TV:NO_TOKEN\");\n\n        _safeTransfer(token_, destination_, amount);\n\n        emit RecoveredToken(token_, amount, destination_);\n    }\n\n    /******************/\n    /*** Safe ERC20 ***/\n    /******************/\n\n    function _safeTransfer(address token_, address to_, uint256 amount_) internal {\n        ( bool success, bytes memory data ) = token_.call(abi.encodeWithSelector(IERC20Like.transfer.selector, to_, amount_));\n\n        require(success \u0026\u0026 (data.length == uint256(0) || abi.decode(data, (bool))), \u0027TV:SAFE_TRANSFER_FAILED\u0027);\n    }\n\n    function _safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\n        ( bool success, bytes memory data ) = token_.call(abi.encodeWithSelector(IERC20Like.transferFrom.selector, from_, to_, amount_));\n\n        require(success \u0026\u0026 (data.length == uint256(0) || abi.decode(data, (bool))), \u0027TV:SAFE_TRANSFER_FROM_FAILED\u0027);\n    }\n\n}\n"}}