{{
  "language": "Solidity",
  "sources": {
    "contracts/Auction.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract Auction is Ownable, Pausable {\n  using Counters for Counters.Counter;\n\n  uint256 public constant hoursInSeconds = 60 * 60;\n  uint256 public constant auctionEndThresholdHrs = 1;\n\n  uint256 public immutable minimumUnitPrice;\n  uint256 public immutable minimumBidIncrement;\n  uint256 public immutable unitPriceStepSize;\n  uint256 public immutable minimumQuantity;\n  uint256 public immutable maximumQuantity;\n  uint256 public immutable itemsPerDay;\n  uint256 public immutable auctionLengthHrs;\n  uint256 public immutable auctionEnd;\n\n  address payable public immutable beneficiaryAddress;\n\n  Counters.Counter private _bidPlacedCounter;\n\n  event AuctionStarted();\n  event AuctionEnded();\n  event BidPlaced(\n    address indexed bidder,\n    uint256 bidIndex,\n    uint256 unitPrice,\n    uint256 quantity\n  );\n  event BidderRefunded(address indexed bidder, uint256 refundAmount);\n\n  struct Bid {\n    uint128 unitPrice;\n    uint128 quantity;\n  }\n\n  struct AuctionStatus {\n    bool started;\n    bool ended;\n  }\n\n  // current auction status\n  AuctionStatus public auctionStatus;\n  // bidder address => current bid\n  mapping(address => Bid) private _bids;\n\n  // Beneficiary address cannot be changed after deployment.\n  constructor(\n    address payable _beneficiaryAddress,\n    uint256 _minimumUnitPrice,\n    uint256 _minimumBidIncrement,\n    uint256 _unitPriceStepSize,\n    uint256 _minimumQuantity,\n    uint256 _maximumQuantity,\n    uint256 _itemsPerDay,\n    uint256 _auctionLengthHrs,\n    uint256 _auctionEnd\n  ) {\n    beneficiaryAddress = _beneficiaryAddress;\n    minimumUnitPrice = _minimumUnitPrice;\n    minimumBidIncrement = _minimumBidIncrement;\n    unitPriceStepSize = _unitPriceStepSize;\n    minimumQuantity = _minimumQuantity;\n    maximumQuantity = _maximumQuantity;\n    itemsPerDay = _itemsPerDay;\n    auctionLengthHrs = _auctionLengthHrs;\n    require(\n      _auctionEnd >= (block.timestamp + (auctionLengthHrs * hoursInSeconds)),\n      \"Auction end must be at least auction duration from now\"\n    );\n    auctionEnd = _auctionEnd;\n    pause();\n  }\n\n  modifier whenAuctionActive() {\n    require(!auctionStatus.ended, \"Auction has already ended.\");\n    require(auctionStatus.started, \"Auction hasn't started yet.\");\n    _;\n  }\n\n  modifier whenPreAuction() {\n    require(!auctionStatus.ended, \"Auction has already ended.\");\n    require(!auctionStatus.started, \"Auction has already started.\");\n    _;\n  }\n\n  modifier whenAuctionEnded() {\n    require(auctionStatus.ended, \"Auction hasn't ended yet.\");\n    require(auctionStatus.started, \"Auction hasn't started yet.\");\n    _;\n  }\n\n  function pause() public onlyOwner {\n    _pause();\n  }\n\n  function unpause() public onlyOwner {\n    _unpause();\n  }\n\n  function bidsPlacedCount() external view returns (uint256) {\n    return _bidPlacedCounter.current();\n  }\n\n  function startAuction() external onlyOwner whenPreAuction {\n    auctionStatus.started = true;\n    if (paused()) {\n      unpause();\n    }\n    emit AuctionStarted();\n  }\n\n  function endAuction() external onlyOwner whenAuctionActive {\n    require(block.timestamp >= auctionEnd, \"Auction end time not reached\");\n    auctionStatus.ended = true;\n    if (!paused()) {\n      pause();\n    }\n    emit AuctionEnded();\n  }\n\n  function endAuctionFromBid() internal whenAuctionActive {\n    auctionStatus.ended = true;\n    if (!paused()) {\n      _pause();\n    }\n    emit AuctionEnded();\n  }\n\n  function getBid(address bidder) external view returns (Bid memory) {\n    return _bids[bidder];\n  }\n\n  // Refunds losing bidders from the contract's balance.\n  function refundBidders(\n    address payable[] calldata bidders_,\n    uint128[] calldata quantities_\n  ) external onlyOwner whenPaused whenAuctionEnded {\n    require(\n      bidders_.length == quantities_.length,\n      \"bidders length doesn't match quantities length\"\n    );\n\n    for (uint256 i = 0; i < bidders_.length; i++) {\n      require(quantities_[i] > 0, \"Quantity is 0\");\n      address payable bidder = bidders_[i];\n      uint128 refundAmount = _bids[bidder].unitPrice * quantities_[i];\n\n      // Since we deduct from bid.quantity when we issue a refund, this gives us the up-to-date maximum that can still be refunded.\n      uint128 refundMaximum = _bids[bidder].unitPrice * _bids[bidder].quantity;\n\n      require(\n        refundAmount <= refundMaximum,\n        \"Refund amount is greater than balance\"\n      );\n\n      // Skip bidders who aren't entitled to a refund.\n      if (refundAmount == 0 || refundMaximum == 0) {\n        continue;\n      }\n\n      _bids[bidder].quantity -= quantities_[i];\n      (bool success, ) = bidder.call{value: refundAmount}(\"\");\n      require(success, \"Transfer failed.\");\n      emit BidderRefunded(bidder, refundAmount);\n    }\n  }\n\n  function withdrawContractBalance() external onlyOwner {\n    (bool success, ) = beneficiaryAddress.call{value: address(this).balance}(\n      \"\"\n    );\n    require(success, \"Transfer failed.\");\n  }\n\n  // When a bidder places a bid or updates their existing bid, they will use this function.\n  // - total value can never be lowered\n  // - unit price can never be lowered\n  // - quantity can be raised or lowered, but only if unit price is raised to meet or exceed previous total price\n  function placeBid(uint256 quantity, uint256 unitPrice)\n    external\n    payable\n    whenNotPaused\n    whenAuctionActive\n  {\n    // If the bidder is increasing their bid, the amount being added must be greater than or equal to the minimum bid increment.\n    if (msg.value > 0 && msg.value < minimumBidIncrement) {\n      revert(\"Bid lower than minimum bid increment.\");\n    }\n\n    // Cache initial bid values.\n    uint256 initialUnitPrice = _bids[msg.sender].unitPrice;\n    uint256 initialQuantity = _bids[msg.sender].quantity;\n    uint256 initialTotalValue = initialUnitPrice * initialQuantity;\n\n    // Cache final bid values.\n    uint256 finalUnitPrice = unitPrice;\n    uint256 finalQuantity = quantity;\n    uint256 finalTotalValue = initialTotalValue + msg.value;\n\n    // Don't allow bids with a unit price scale smaller than unitPriceStepSize.\n    // For example, allow 1.01 or 111.01 but don't allow 1.011.\n    require(\n      finalUnitPrice % unitPriceStepSize == 0,\n      \"Unit price step too small.\"\n    );\n\n    // Reject bids that don't have a quantity within the valid range.\n    require(finalQuantity >= minimumQuantity, \"Quantity too low.\");\n    require(finalQuantity <= maximumQuantity, \"Quantity too high.\");\n\n    // Total value can never be lowered.\n    require(\n      finalTotalValue >= initialTotalValue,\n      \"Total value can't be lowered.\"\n    );\n\n    // Unit price can never be lowered.\n    // Quantity can be raised or lowered, but it can only be lowered if the unit price is raised to meet or exceed the initial total value. Ensuring the the unit price is never lowered takes care of this.\n    require(finalUnitPrice >= initialUnitPrice, \"Unit price can't be lowered.\");\n\n    // Ensure the new totalValue equals quantity * the unit price that was given in this txn exactly. This is important to prevent rounding errors later when returning ether.\n    require(\n      finalQuantity * finalUnitPrice == finalTotalValue,\n      \"Quantity * Unit Price != Total Value\"\n    );\n\n    // Unit price must be greater than or equal to the minimumUnitPrice.\n    require(finalUnitPrice >= minimumUnitPrice, \"Bid unit price too low.\");\n\n    // Something must be changing from the initial bid for this new bid to be valid.\n    if (\n      initialUnitPrice == finalUnitPrice && initialQuantity == finalQuantity\n    ) {\n      revert(\"This bid doesn't change anything.\");\n    }\n\n    // Update the bidder's bid.\n    _bids[msg.sender].unitPrice = uint128(finalUnitPrice);\n    _bids[msg.sender].quantity = uint128(finalQuantity);\n\n    emit BidPlaced(\n      msg.sender,\n      _bidPlacedCounter.current(),\n      finalUnitPrice,\n      finalQuantity\n    );\n    // Increment after emitting the BidPlaced event because counter is 0-indexed.\n    _bidPlacedCounter.increment();\n\n    // After the bid has been placed, check to see whether the auction is ended\n    _checkAuctionEnd();\n  }\n\n  // Handles receiving ether to the contract.\n  // Reject all direct payments to the contract except from beneficiary and owner.\n  // Bids must be placed using the placeBid function.\n  receive() external payable {\n    require(msg.value > 0, \"No ether was sent.\");\n    require(\n      msg.sender == beneficiaryAddress || msg.sender == owner(),\n      \"Only owner or beneficiary can fund contract.\"\n    );\n  }\n\n  function _checkAuctionEnd() internal {\n    // (1) If we are at or past the end time it's the end of the action:\n    if (block.timestamp >= auctionEnd) {\n      endAuctionFromBid();\n    } else {\n      // (2) Still going? See if we are in the threshold:\n      uint256 auctionEndThreshold = auctionEnd -\n        (auctionEndThresholdHrs * hoursInSeconds);\n      if (block.timestamp >= auctionEndThreshold) {\n        // End logic is simple, we do a modulo on the random number using the number of\n        // seconds until the end of the action, and check if the remainder is = 7\n        // as we approach the end of the auction the odds of such a small remainder increase\n        // (while being possible at all times in the threshold)\n        if (_getRandomNumber() % (auctionEnd - block.timestamp) == 7) {\n          endAuctionFromBid();\n        }\n      }\n    }\n  }\n\n  function _getRandomNumber() internal view returns (uint256) {\n    return\n      uint256(\n        keccak256(\n          abi.encodePacked(\n            _bidPlacedCounter.current(),\n            blockhash(block.number - 1)\n          )\n        )\n      );\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}