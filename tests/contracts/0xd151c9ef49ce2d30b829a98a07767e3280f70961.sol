{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/crosschain/arbitrum/LibArbitrumL1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (crosschain/arbitrum/LibArbitrumL1.sol)\n\npragma solidity ^0.8.4;\n\nimport {IBridge as ArbitrumL1_Bridge} from \"../../vendor/arbitrum/IBridge.sol\";\nimport {IOutbox as ArbitrumL1_Outbox} from \"../../vendor/arbitrum/IOutbox.sol\";\nimport \"../errors.sol\";\n\n/**\n * @dev Primitives for cross-chain aware contracts for\n * https://arbitrum.io/[Arbitrum].\n *\n * This version should only be used on L1 to process cross-chain messages\n * originating from L2. For the other side, use {LibArbitrumL2}.\n */\nlibrary LibArbitrumL1 {\n    /**\n     * @dev Returns whether the current function call is the result of a\n     * cross-chain message relayed by the `bridge`.\n     */\n    function isCrossChain(address bridge) internal view returns (bool) {\n        return msg.sender == bridge;\n    }\n\n    /**\n     * @dev Returns the address of the sender that triggered the current\n     * cross-chain message through the `bridge`.\n     *\n     * NOTE: {isCrossChain} should be checked before trying to recover the\n     * sender, as it will revert with `NotCrossChainCall` if the current\n     * function call is not the result of a cross-chain message.\n     */\n    function crossChainSender(address bridge) internal view returns (address) {\n        if (!isCrossChain(bridge)) revert NotCrossChainCall();\n\n        address sender = ArbitrumL1_Outbox(ArbitrumL1_Bridge(bridge).activeOutbox()).l2ToL1Sender();\n        require(sender != address(0), \"LibArbitrumL1: system messages without sender\");\n\n        return sender;\n    }\n}\n"
    },
    "@openzeppelin/contracts/crosschain/errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/errors.sol)\n\npragma solidity ^0.8.4;\n\nerror NotCrossChainCall();\nerror InvalidCrossChainSender(address actual, address expected);\n"
    },
    "@openzeppelin/contracts/vendor/arbitrum/IBridge.sol": {
      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n// OpenZeppelin Contracts (last updated v4.8.0) (vendor/arbitrum/IBridge.sol)\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\ninterface IBridge {\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash,\n        uint256 baseFeeL1,\n        uint64 timestamp\n    );\n\n    event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data);\n\n    event InboxToggle(address indexed inbox, bool enabled);\n\n    event OutboxToggle(address indexed outbox, bool enabled);\n\n    event SequencerInboxUpdated(address newSequencerInbox);\n\n    function allowedDelayedInboxList(uint256) external returns (address);\n\n    function allowedOutboxList(uint256) external returns (address);\n\n    /// @dev Accumulator for delayed inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\n    function delayedInboxAccs(uint256) external view returns (bytes32);\n\n    /// @dev Accumulator for sequencer inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\n    function sequencerInboxAccs(uint256) external view returns (bytes32);\n\n    // OpenZeppelin: changed return type from IOwnable\n    function rollup() external view returns (address);\n\n    function sequencerInbox() external view returns (address);\n\n    function activeOutbox() external view returns (address);\n\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function sequencerReportedSubMessageCount() external view returns (uint256);\n\n    /**\n     * @dev Enqueue a message in the delayed inbox accumulator.\n     *      These messages are later sequenced in the SequencerInbox, either\n     *      by the sequencer as part of a normal batch, or by force inclusion.\n     */\n    function enqueueDelayedMessage(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable returns (uint256);\n\n    function executeCall(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    function delayedMessageCount() external view returns (uint256);\n\n    function sequencerMessageCount() external view returns (uint256);\n\n    // ---------- onlySequencerInbox functions ----------\n\n    function enqueueSequencerMessage(\n        bytes32 dataHash,\n        uint256 afterDelayedMessagesRead,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    )\n        external\n        returns (\n            uint256 seqMessageIndex,\n            bytes32 beforeAcc,\n            bytes32 delayedAcc,\n            bytes32 acc\n        );\n\n    /**\n     * @dev Allows the sequencer inbox to submit a delayed message of the batchPostingReport type\n     *      This is done through a separate function entrypoint instead of allowing the sequencer inbox\n     *      to call `enqueueDelayedMessage` to avoid the gas overhead of an extra SLOAD in either\n     *      every delayed inbox or every sequencer inbox call.\n     */\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash) external returns (uint256 msgNum);\n\n    // ---------- onlyRollupOrOwner functions ----------\n\n    function setSequencerInbox(address _sequencerInbox) external;\n\n    function setDelayedInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    // ---------- initializer ----------\n\n    // OpenZeppelin: changed rollup_ type from IOwnable\n    function initialize(address rollup_) external;\n}\n"
    },
    "@openzeppelin/contracts/vendor/arbitrum/IOutbox.sol": {
      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n// OpenZeppelin Contracts (last updated v4.8.0) (vendor/arbitrum/IOutbox.sol)\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\nimport \"./IBridge.sol\";\n\ninterface IOutbox {\n    event SendRootUpdated(bytes32 indexed blockHash, bytes32 indexed outputRoot);\n    event OutBoxTransactionExecuted(\n        address indexed to,\n        address indexed l2Sender,\n        uint256 indexed zero,\n        uint256 transactionIndex\n    );\n\n    function rollup() external view returns (address); // the rollup contract\n\n    function bridge() external view returns (IBridge); // the bridge contract\n\n    function spent(uint256) external view returns (bytes32); // packed spent bitmap\n\n    function roots(bytes32) external view returns (bytes32); // maps root hashes => L2 block hash\n\n    // solhint-disable-next-line func-name-mixedcase\n    function OUTBOX_VERSION() external view returns (uint128); // the outbox version\n\n    function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) external;\n\n    /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\n    ///         When the return value is zero, that means this is a system message\n    /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\n    function l2ToL1Sender() external view returns (address);\n\n    /// @return l2Block return L2 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n    function l2ToL1Block() external view returns (uint256);\n\n    /// @return l1Block return L1 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n    function l2ToL1EthBlock() external view returns (uint256);\n\n    /// @return timestamp return L2 timestamp when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n    function l2ToL1Timestamp() external view returns (uint256);\n\n    /// @return outputId returns the unique output identifier of the L2 to L1 tx or 0 if no L2 to L1 transaction is active\n    function l2ToL1OutputId() external view returns (bytes32);\n\n    /**\n     * @notice Executes a messages in an Outbox entry.\n     * @dev Reverts if dispute period hasn't expired, since the outbox entry\n     *      is only created once the rollup confirms the respective assertion.\n     * @dev it is not possible to execute any L2-to-L1 transaction which contains data\n     *      to a contract address without any code (as enforced by the Bridge contract).\n     * @param proof Merkle proof of message inclusion in send root\n     * @param index Merkle path to message\n     * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\n     * @param to destination address for L1 contract call\n     * @param l2Block l2 block number at which sendTxToL1 call was made\n     * @param l1Block l1 block number at which sendTxToL1 call was made\n     * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\n     * @param value wei in L1 message\n     * @param data abi-encoded L1 message data\n     */\n    function executeTransaction(\n        bytes32[] calldata proof,\n        uint256 index,\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n     *  @dev function used to simulate the result of a particular function call from the outbox\n     *       it is useful for things such as gas estimates. This function includes all costs except for\n     *       proof validation (which can be considered offchain as a somewhat of a fixed cost - it's\n     *       not really a fixed cost, but can be treated as so with a fixed overhead for gas estimation).\n     *       We can't include the cost of proof validation since this is intended to be used to simulate txs\n     *       that are included in yet-to-be confirmed merkle roots. The simulation entrypoint could instead pretend\n     *       to confirm a pending merkle root, but that would be less practical for integrating with tooling.\n     *       It is only possible to trigger it when the msg sender is address zero, which should be impossible\n     *       unless under simulation in an eth_call or eth_estimateGas\n     */\n    function executeTransactionSimulation(\n        uint256 index,\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @param index Merkle path to message\n     * @return true if the message has been spent\n     */\n    function isSpent(uint256 index) external view returns (bool);\n\n    function calculateItemHash(\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external pure returns (bytes32);\n\n    function calculateMerkleRoot(\n        bytes32[] memory proof,\n        uint256 path,\n        bytes32 item\n    ) external pure returns (bytes32);\n}\n"
    },
    "contracts/messaging/connectors/Connector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {ProposedOwnable} from \"../../shared/ProposedOwnable.sol\";\nimport {IConnector} from \"../interfaces/IConnector.sol\";\n\n/**\n * @title Connector\n * @author Connext Labs, Inc.\n * @notice This contract has the messaging interface functions used by all connectors.\n *\n * @dev This contract stores information about mirror connectors, but can be used as a\n * base for contracts that do not have a mirror (i.e. the connector handling messaging on\n * mainnet). In this case, the `mirrorConnector` and `MIRROR_DOMAIN`\n * will be empty\n *\n * @dev If ownership is renounced, this contract will be unable to update its `mirrorConnector`\n * or `mirrorGas`\n */\nabstract contract Connector is ProposedOwnable, IConnector {\n  // ========== Custom Errors ===========\n\n  error Connector__processMessage_notUsed();\n\n  // ============ Events ============\n\n  event NewConnector(\n    uint32 indexed domain,\n    uint32 indexed mirrorDomain,\n    address amb,\n    address rootManager,\n    address mirrorConnector\n  );\n\n  event MirrorConnectorUpdated(address previous, address current);\n\n  // ============ Public Storage ============\n\n  /**\n   * @notice The domain of this Messaging (i.e. Connector) contract.\n   */\n  uint32 public immutable DOMAIN;\n\n  /**\n   * @notice Address of the AMB on this domain.\n   */\n  address public immutable AMB;\n\n  /**\n   * @notice RootManager contract address.\n   */\n  address public immutable ROOT_MANAGER;\n\n  /**\n   * @notice The domain of the corresponding messaging (i.e. Connector) contract.\n   */\n  uint32 public immutable MIRROR_DOMAIN;\n\n  /**\n   * @notice Connector on L2 for L1 connectors, and vice versa.\n   */\n  address public mirrorConnector;\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Errors if the msg.sender is not the registered AMB\n   */\n  modifier onlyAMB() {\n    require(msg.sender == AMB, \"!AMB\");\n    _;\n  }\n\n  /**\n   * @notice Errors if the msg.sender is not the registered ROOT_MANAGER\n   */\n  modifier onlyRootManager() {\n    // NOTE: RootManager will be zero address for spoke connectors.\n    // Only root manager can dispatch a message to spokes/L2s via the hub connector.\n    require(msg.sender == ROOT_MANAGER, \"!rootManager\");\n    _;\n  }\n\n  // ============ Constructor ============\n\n  /**\n   * @notice Creates a new HubConnector instance\n   * @dev The connectors are deployed such that there is one on each side of an AMB (i.e.\n   * for optimism, there is one connector on optimism and one connector on mainnet)\n   * @param _domain The domain this connector lives on\n   * @param _mirrorDomain The spoke domain\n   * @param _amb The address of the amb on the domain this connector lives on\n   * @param _rootManager The address of the RootManager on mainnet\n   * @param _mirrorConnector The address of the spoke connector\n   */\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector\n  ) ProposedOwnable() {\n    // set the owner\n    _setOwner(msg.sender);\n\n    // sanity checks on values\n    require(_domain != 0, \"empty domain\");\n    require(_rootManager != address(0), \"empty rootManager\");\n    // see note at top of contract on why the mirror values are not sanity checked\n\n    // set immutables\n    DOMAIN = _domain;\n    AMB = _amb;\n    ROOT_MANAGER = _rootManager;\n    MIRROR_DOMAIN = _mirrorDomain;\n    // set mutables if defined\n    if (_mirrorConnector != address(0)) {\n      _setMirrorConnector(_mirrorConnector);\n    }\n\n    emit NewConnector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector);\n  }\n\n  // ============ Receivable ============\n  /**\n   * @notice Connectors may need to receive native asset to handle fees when sending a\n   * message\n   */\n  receive() external payable {}\n\n  // ============ Admin Functions ============\n\n  /**\n   * @notice Sets the address of the l2Connector for this domain\n   */\n  function setMirrorConnector(address _mirrorConnector) public onlyOwner {\n    _setMirrorConnector(_mirrorConnector);\n  }\n\n  // ============ Public Functions ============\n\n  /**\n   * @notice Processes a message received by an AMB\n   * @dev This is called by AMBs to process messages originating from mirror connector\n   */\n  function processMessage(bytes memory _data) external virtual onlyAMB {\n    _processMessage(_data);\n    emit MessageProcessed(_data, msg.sender);\n  }\n\n  /**\n   * @notice Checks the cross domain sender for a given address\n   */\n  function verifySender(address _expected) external returns (bool) {\n    return _verifySender(_expected);\n  }\n\n  // ============ Virtual Functions ============\n\n  /**\n   * @notice This function is used by the Connext contract on the l2 domain to send a message to the\n   * l1 domain (i.e. called by Connext on optimism to send a message to mainnet with roots)\n   * @param _data The contents of the message\n   * @param _encodedData Data used to send the message; specific to connector\n   */\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal virtual;\n\n  /**\n   * @notice This function is used by the AMBs to handle incoming messages. Should store the latest\n   * root generated on the l2 domain.\n   */\n  function _processMessage(\n    bytes memory /* _data */\n  ) internal virtual {\n    // By default, reverts. This is to ensure the call path is not used unless this function is\n    // overridden by the inheriting class\n    revert Connector__processMessage_notUsed();\n  }\n\n  /**\n   * @notice Verify that the msg.sender is the correct AMB contract, and that the message's origin sender\n   * is the expected address.\n   * @dev Should be overridden by the implementing Connector contract.\n   */\n  function _verifySender(address _expected) internal virtual returns (bool);\n\n  // ============ Private Functions ============\n\n  function _setMirrorConnector(address _mirrorConnector) internal virtual {\n    emit MirrorConnectorUpdated(mirrorConnector, _mirrorConnector);\n    mirrorConnector = _mirrorConnector;\n  }\n}\n"
    },
    "contracts/messaging/connectors/HubConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {Connector} from \"./Connector.sol\";\n\n/**\n * @title HubConnector\n * @author Connext Labs, Inc.\n * @notice This contract implements the messaging functions needed on the hub-side of a given AMB.\n * The HubConnector has a limited set of functionality compared to the SpokeConnector, namely that\n * it contains no logic to store or prove messages.\n *\n * @dev This contract should be deployed on the hub-side of an AMB (i.e. on L1), and contracts\n * which extend this should implement the virtual functions defined in the BaseConnector class\n */\nabstract contract HubConnector is Connector {\n  /**\n   * @notice Creates a new HubConnector instance\n   * @dev The connectors are deployed such that there is one on each side of an AMB (i.e.\n   * for optimism, there is one connector on optimism and one connector on mainnet)\n   * @param _domain The domain this connector lives on\n   * @param _mirrorDomain The spoke domain\n   * @param _amb The address of the amb on the domain this connector lives on\n   * @param _rootManager The address of the RootManager on mainnet\n   * @param _mirrorConnector The address of the spoke connector\n   */\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector\n  ) Connector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector) {}\n\n  // ============ Public fns ============\n  /**\n   * @notice Sends a message over the amb\n   * @dev This is called by the root manager *only* on mainnet to propagate the aggregate root\n   */\n  function sendMessage(bytes memory _data, bytes memory _encodedData) external payable onlyRootManager {\n    _sendMessage(_data, _encodedData);\n    emit MessageSent(_data, _encodedData, msg.sender);\n  }\n}\n"
    },
    "contracts/messaging/connectors/arbitrum/ArbitrumHubConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {LibArbitrumL1} from \"@openzeppelin/contracts/crosschain/arbitrum/LibArbitrumL1.sol\";\n\nimport {TypedMemView} from \"../../../shared/libraries/TypedMemView.sol\";\n\nimport {IRootManager} from \"../../interfaces/IRootManager.sol\";\nimport {IArbitrumInbox} from \"../../interfaces/ambs/arbitrum/IArbitrumInbox.sol\";\nimport {IArbitrumOutbox} from \"../../interfaces/ambs/arbitrum/IArbitrumOutbox.sol\";\nimport {IArbitrumRollup, Node} from \"../../interfaces/ambs/arbitrum/IArbitrumRollup.sol\";\n\nimport {HubConnector} from \"../HubConnector.sol\";\nimport {Connector} from \"../Connector.sol\";\n\nstruct L2Message {\n  address l2Sender;\n  address to;\n  uint256 l2Block;\n  uint256 l1Block;\n  uint256 l2Timestamp;\n  uint256 value;\n  bytes callData;\n}\n\ncontract ArbitrumHubConnector is HubConnector {\n  // ============ Libraries ============\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n\n  // ============ Storage ============\n\n  IArbitrumOutbox public outbox;\n  IArbitrumRollup public rollup;\n\n  /**\n   * @notice Sets cap on maxSubmissionCost used in `createRetryableTicket`\n   * @dev The value used in `createRetryableTicket` is the lesser of the cap or\n   * a value passed in via `_encodedData` in `_sendMessage`.\n   *\n   * This value represents amount of ETH allocated to pay for the base submission fee\n   */\n  uint256 public maxSubmissionCostCap;\n\n  /**\n   * @notice Sets cap on maxGas used in `createRetryableTicket`\n   * @dev The value used in `createRetryableTicket` is the lesser of the cap or\n   * a value passed in via `_encodedData` in `_sendMessage`.\n   *\n   * This value represents gas limit for immediate L2 execution attempt\n   */\n  uint256 public maxGasCap;\n\n  /**\n   * @notice Sets cap on gasPrice used in `createRetryableTicket`\n   * @dev The value used in `createRetryableTicket` is the lesser of the cap or\n   * a value passed in via `_encodedData` in `_sendMessage`.\n   *\n   * This value represents L2 gas price bid for immediate L2 execution attempt\n   */\n  uint256 public gasPriceCap;\n\n  /**\n   * @notice Tracks which messages have been processed from bridge\n   */\n  mapping(uint256 => bool) public processed;\n\n  // ============ Events ============\n  // TODO: do we need any other information from the ticket to link to message?\n  event RetryableTicketCreated(uint256 indexed ticketId);\n\n  /**\n   * @notice Emitted when admin updates the maxSubmissionCap\n   * @param _previous The starting value\n   * @param _updated The final value\n   */\n  event MaxSubmissionCapUpdated(uint256 _previous, uint256 _updated);\n\n  /**\n   * @notice Emitted when admin updates the maxGasCap\n   * @param _previous The starting value\n   * @param _updated The final value\n   */\n  event MaxGasCapUpdated(uint256 _previous, uint256 _updated);\n\n  /**\n   * @notice Emitted when admin updates the gasPriceCap\n   * @param _previous The starting value\n   * @param _updated The final value\n   */\n  event GasPriceCapUpdated(uint256 _previous, uint256 _updated);\n\n  // ============ Constructor ============\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector,\n    address _outbox,\n    uint256 _maxSubmissionCostCap,\n    uint256 _maxGasCap,\n    uint256 _gasPriceCap\n  ) HubConnector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector) {\n    outbox = IArbitrumOutbox(_outbox);\n    rollup = IArbitrumRollup(outbox.rollup());\n\n    // Set initial caps for L1 -> L2 messages\n    maxSubmissionCostCap = _maxSubmissionCostCap;\n    maxGasCap = _maxGasCap;\n    gasPriceCap = _gasPriceCap;\n  }\n\n  // ============ Admin fns ============\n\n  /**\n   * @notice Used (by admin) to update the maxSubmissionCostCap\n   * @param _updated The new value\n   */\n  function setMaxSubmissionCostCap(uint256 _updated) public onlyOwner {\n    emit MaxSubmissionCapUpdated(maxSubmissionCostCap, _updated);\n    maxSubmissionCostCap = _updated;\n  }\n\n  /**\n   * @notice Used (by admin) to update the maxGasCap\n   * @param _updated The new value\n   */\n  function setMaxGasCap(uint256 _updated) public onlyOwner {\n    emit MaxGasCapUpdated(maxGasCap, _updated);\n    maxGasCap = _updated;\n  }\n\n  /**\n   * @notice Used (by admin) to update the gasPriceCap\n   * @param _updated The new value\n   */\n  function setGasPriceCap(uint256 _updated) public onlyOwner {\n    emit GasPriceCapUpdated(maxSubmissionCostCap, _updated);\n    gasPriceCap = _updated;\n  }\n\n  // ============ Private fns ============\n\n  function _verifySender(address _expected) internal view override returns (bool) {\n    return _expected == LibArbitrumL1.crossChainSender(AMB);\n  }\n\n  /**\n   * @notice Helper to return the lesser of two values\n   * @param _a Some number\n   * @param _b Some number\n   */\n  function _lesserOf(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    return _a < _b ? _a : _b;\n  }\n\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\n    // Should always be dispatching the aggregate root\n    require(_data.length == 32, \"!length\");\n    // Get the calldata\n    bytes memory _calldata = abi.encodeWithSelector(Connector.processMessage.selector, _data);\n\n    // Should include specialized calldata\n    require(_encodedData.length == (32 * 3), \"!data length\");\n\n    // Decode all of the gas-related parameters\n    (uint256 maxSubmissionCost, uint256 maxGas, uint256 gasPrice) = abi.decode(\n      _encodedData,\n      (uint256, uint256, uint256)\n    );\n\n    // dispatch to l2\n    uint256 ticketID = IArbitrumInbox(AMB).createRetryableTicket{value: msg.value}(\n      mirrorConnector, // destAddr\n      0, // arbTxCallValue\n      _lesserOf(maxSubmissionCost, maxSubmissionCostCap), // maxSubmissionCost: Amount of ETH allocated to pay for the base submission fee\n      mirrorConnector, // submissionRefundAddress: Address to which all excess gas is credited on L2\n      mirrorConnector, // valueRefundAddress: Address to which CallValue will be credited to on L2 if the retryable ticket times out or is cancelled\n      _lesserOf(maxGas, maxGasCap), // maxGas: Gas limit for immediate L2 execution attempt\n      _lesserOf(gasPrice, gasPriceCap), // gasPriceBid: L2 Gas price bid for immediate L2 execution attempt\n      _calldata // data\n    );\n    emit RetryableTicketCreated(ticketID);\n  }\n\n  // DO NOT override _processMessage, should revert from `Connector` class. All messages must use the\n  // `processMessageFromRoot` flow.\n\n  function processMessageFromRoot(\n    uint64 _nodeNum,\n    bytes32 _sendRoot,\n    bytes32 _blockHash,\n    bytes32[] calldata _proof,\n    uint256 _index,\n    L2Message calldata _message\n  ) external {\n    // Ensure the send root corresponds to an arbitrum node that exists onchain\n    _validateSendRoot(_nodeNum, _sendRoot, _blockHash);\n\n    // Ensure the given l2 message is included in the send root\n    _validateMessage(_sendRoot, _proof, _index, _message);\n\n    // Message has been proven within the send root, process the message\n    // data itself. The message data is defined in the spoke connector as:\n    //\n    // `abi.encodeWithSelector(Connector.processMessage.selector, _data);`\n    //\n    // so to get the root data, we need to decode the _calldata. we can do this\n    // by dropping the 4-byte selector, then using the rest as the raw _data.\n    require(_message.callData.length == 100, \"!length\");\n\n    // NOTE: TypedMemView only loads 32-byte chunks onto stack, which is fine in this case\n    // the calldata is 100 bytes long, the last 32 bytes represent the root to be aggregated.\n    bytes32 _data = _message.callData.ref(0).index(68, 32);\n\n    // Update root manager\n    IRootManager(ROOT_MANAGER).aggregate(MIRROR_DOMAIN, _data);\n\n    // Emit event\n    emit MessageProcessed(abi.encode(_data), msg.sender);\n  }\n\n  function _validateSendRoot(\n    uint64 _nodeNum,\n    bytes32 _sendRoot,\n    bytes32 _blockHash\n  ) internal view {\n    // Get the confirm data to ensure the node has been put on L1 with\n    // the given block hash and send root\n    bytes32 confirmData = _confirmHash(_blockHash, _sendRoot);\n\n    // Validate inputs by checking against the stored none confirm data\n    Node memory node = rollup.getNode(_nodeNum);\n    require(node.confirmData == confirmData, \"!confirmData\");\n\n    // Validate the node is staked / not in dispute\n    // NOTE: a dispute can happen at any point within the timeout window, so the closest\n    // we can get is to ensure the staker count > 0 and that there have been stakes on child\n    // nodes as well, meaning the node is less likely to be staked incorrectly (and thus less\n    // likely to be disputed)\n    require(node.stakerCount > 0 && node.childStakerCount > 0, \"!staked\");\n  }\n\n  // prove the message was included in the given send root\n  function _validateMessage(\n    bytes32 _sendRoot,\n    bytes32[] calldata _proof,\n    uint256 _index,\n    L2Message calldata _msg\n  ) internal {\n    // Check that the l2sender is the mirror connector\n    require(_msg.l2Sender == mirrorConnector, \"!mirrorConnector\");\n\n    // Generate the message sent through from L2 (included in sendRoot)\n    bytes32 userTx = outbox.calculateItemHash(\n      _msg.l2Sender,\n      _msg.to,\n      _msg.l2Block,\n      _msg.l1Block,\n      _msg.l2Timestamp,\n      _msg.value,\n      _msg.callData\n    );\n\n    // Prove message is included in the send root\n    _recordOutputAsSpent(_proof, _index, userTx, _sendRoot);\n  }\n\n  // taken from: https://github.com/OffchainLabs/nitro/blob/208d9d50f250e9b4948f867d3795548256583b17/contracts/src/rollup/RollupLib.sol#L128-L130\n  function _confirmHash(bytes32 _blockHash, bytes32 _sendRoot) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_blockHash, _sendRoot));\n  }\n\n  // modified from: https://github.com/OffchainLabs/nitro/blob/fbaa96d6d6246b427629be176499e1d5c5013d89/contracts/src/bridge/Outbox.sol#L219-L235\n  function _recordOutputAsSpent(\n    bytes32[] memory _proof,\n    uint256 _index,\n    bytes32 _item,\n    bytes32 _sendRoot\n  ) internal {\n    require(_proof.length < 256, \"proof length\");\n    require((_index >> _proof.length) == 0, \"!minimal proof\");\n\n    // NOTE: in the arbitrum contracts, they check that the message index is not yet spent\n    // Because the spoke connector calls `processMessage`, which does nothing, it is important\n    // to check out own internal mapping to ensure the message is not played twice. this forces\n    // all messages from l2 to be processed using the `processMessageFromRoot` fn path.\n    require(!processed[_index], \"spent\");\n\n    // Calculate the root\n    bytes32 calcRoot = outbox.calculateMerkleRoot(_proof, _index, _item);\n\n    // Assert the sendRoot is correct\n    // NOTE: this send root will *not* yet be stored on the `Outbox`\n    // contract (fraud period has not yet elapsed);\n    require(calcRoot == _sendRoot, \"!proof\");\n\n    // Mark as spent\n    processed[_index] = true;\n  }\n}\n"
    },
    "contracts/messaging/interfaces/IConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IProposedOwnable} from \"../../shared/interfaces/IProposedOwnable.sol\";\n\n/**\n * @notice This interface is what the Connext contract will send and receive messages through.\n * The messaging layer should conform to this interface, and should be interchangeable (i.e.\n * could be Nomad or a generic AMB under the hood).\n *\n * @dev This uses the nomad format to ensure nomad can be added in as it comes back online.\n *\n * Flow from transfer from polygon to optimism:\n * 1. User calls `xcall` with destination specified\n * 2. This will swap in to the bridge assets\n * 3. The swapped assets will get burned\n * 4. The Connext contract will call `dispatch` on the messaging contract to add the transfer\n *    to the root\n * 5. [At some time interval] Relayers call `send` to send the current root from polygon to\n *    mainnet. This is done on all \"spoke\" domains.\n * 6. [At some time interval] Relayers call `propagate` [better name] on mainnet, this generates a new merkle\n *    root from all of the AMBs\n *    - This function must be able to read root data from all AMBs and aggregate them into a single merkle\n *      tree root\n *    - Will send the mixed root from all chains back through the respective AMBs to all other chains\n * 7. AMB will call `update` to update the latest root on the messaging contract on spoke domains\n * 8. [At any point] Relayers can call `proveAndProcess` to prove inclusion of dispatched message, and call\n *    process on the `Connext` contract\n * 9. Takes minted bridge tokens and credits the LP\n *\n * AMB requirements:\n * - Access `msg.sender` both from mainnet -> spoke and vice versa\n * - Ability to read *our root* from the AMB\n *\n * AMBs:\n * - PoS bridge from polygon\n * - arbitrum bridge\n * - optimism bridge\n * - gnosis chain\n * - bsc (use multichain for messaging)\n */\ninterface IConnector is IProposedOwnable {\n  // ============ Events ============\n  /**\n   * @notice Emitted whenever a message is successfully sent over an AMB\n   * @param data The contents of the message\n   * @param encodedData Data used to send the message; specific to connector\n   * @param caller Who called the function (sent the message)\n   */\n  event MessageSent(bytes data, bytes encodedData, address caller);\n\n  /**\n   * @notice Emitted whenever a message is successfully received over an AMB\n   * @param data The contents of the message\n   * @param caller Who called the function\n   */\n  event MessageProcessed(bytes data, address caller);\n\n  // ============ Public fns ============\n\n  function processMessage(bytes memory _data) external;\n\n  function verifySender(address _expected) external returns (bool);\n}\n"
    },
    "contracts/messaging/interfaces/IRootManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\ninterface IRootManager {\n  /**\n   * @notice This is called by relayers to generate + send the mixed root from mainnet via AMB to\n   * spoke domains.\n   * @dev This must read information for the root from the registered AMBs.\n   */\n  function propagate(\n    address[] calldata _connectors,\n    uint256[] calldata _fees,\n    bytes[] memory _encodedData\n  ) external payable;\n\n  /**\n   * @notice Called by the connectors for various domains on the hub to aggregate their latest\n   * inbound root.\n   * @dev This must read information for the root from the registered AMBs\n   */\n  function aggregate(uint32 _domain, bytes32 _outbound) external;\n}\n"
    },
    "contracts/messaging/interfaces/ambs/arbitrum/IArbitrumInbox.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @notice Interface for sending L1 -> L2 messagesto Arbitrum.\n * @dev Arbitrum uses an inbox to aggregate messages going from L1 -> L2, source:\n * https://github.com/OffchainLabs/nitro/blob/master/contracts/src/bridge/Inbox.sol\n *\n */\ninterface IArbitrumInbox {\n  function createRetryableTicket(\n    address destAddr,\n    uint256 arbTxCallValue,\n    uint256 maxSubmissionCost,\n    address submissionRefundAddress,\n    address valueRefundAddress,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external payable returns (uint256);\n}\n"
    },
    "contracts/messaging/interfaces/ambs/arbitrum/IArbitrumOutbox.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @notice Interface for sending L1 -> L2 messagesto Arbitrum.\n * @dev Arbitrum uses an inbox to aggregate messages going from L1 -> L2, source:\n * https://github.com/OffchainLabs/nitro/blob/master/contracts/src/bridge/Inbox.sol\n *\n */\ninterface IArbitrumOutbox {\n  event SendRootUpdated(bytes32 indexed blockHash, bytes32 indexed outputRoot);\n  event OutBoxTransactionExecuted(\n    address indexed to,\n    address indexed l2Sender,\n    uint256 indexed zero,\n    uint256 transactionIndex\n  );\n\n  function rollup() external view returns (address); // the rollup contract\n\n  // function bridge() external view returns (IBridge); // the bridge contract\n\n  function spent(uint256) external view returns (bytes32); // packed spent bitmap\n\n  function roots(bytes32) external view returns (bytes32); // maps root hashes => L2 block hash\n\n  // solhint-disable-next-line func-name-mixedcase\n  function OUTBOX_VERSION() external view returns (uint128); // the outbox version\n\n  function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) external;\n\n  /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\n  ///         When the return value is zero, that means this is a system message\n  /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\n  function l2ToL1Sender() external view returns (address);\n\n  /// @return l2Block return L2 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n  function l2ToL1Block() external view returns (uint256);\n\n  /// @return l1Block return L1 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n  function l2ToL1EthBlock() external view returns (uint256);\n\n  /// @return timestamp return L2 timestamp when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n  function l2ToL1Timestamp() external view returns (uint256);\n\n  /// @return outputId returns the unique output identifier of the L2 to L1 tx or 0 if no L2 to L1 transaction is active\n  function l2ToL1OutputId() external view returns (bytes32);\n\n  /**\n   * @notice Executes a messages in an Outbox entry.\n   * @dev Reverts if dispute period hasn't expired, since the outbox entry\n   *      is only created once the rollup confirms the respective assertion.\n   * @dev it is not possible to execute any L2-to-L1 transaction which contains data\n   *      to a contract address without any code (as enforced by the Bridge contract).\n   * @param proof Merkle proof of message inclusion in send root\n   * @param index Merkle path to message\n   * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\n   * @param to destination address for L1 contract call\n   * @param l2Block l2 block number at which sendTxToL1 call was made\n   * @param l1Block l1 block number at which sendTxToL1 call was made\n   * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\n   * @param value wei in L1 message\n   * @param data abi-encoded L1 message data\n   */\n  function executeTransaction(\n    bytes32[] calldata proof,\n    uint256 index,\n    address l2Sender,\n    address to,\n    uint256 l2Block,\n    uint256 l1Block,\n    uint256 l2Timestamp,\n    uint256 value,\n    bytes calldata data\n  ) external;\n\n  /**\n   *  @dev function used to simulate the result of a particular function call from the outbox\n   *       it is useful for things such as gas estimates. This function includes all costs except for\n   *       proof validation (which can be considered offchain as a somewhat of a fixed cost - it's\n   *       not really a fixed cost, but can be treated as so with a fixed overhead for gas estimation).\n   *       We can't include the cost of proof validation since this is intended to be used to simulate txs\n   *       that are included in yet-to-be confirmed merkle roots. The simulation entrypoint could instead pretend\n   *       to confirm a pending merkle root, but that would be less pratical for integrating with tooling.\n   *       It is only possible to trigger it when the msg sender is address zero, which should be impossible\n   *       unless under simulation in an eth_call or eth_estimateGas\n   */\n  function executeTransactionSimulation(\n    uint256 index,\n    address l2Sender,\n    address to,\n    uint256 l2Block,\n    uint256 l1Block,\n    uint256 l2Timestamp,\n    uint256 value,\n    bytes calldata data\n  ) external;\n\n  /**\n   * @param index Merkle path to message\n   * @return true if the message has been spent\n   */\n  function isSpent(uint256 index) external view returns (bool);\n\n  function calculateItemHash(\n    address l2Sender,\n    address to,\n    uint256 l2Block,\n    uint256 l1Block,\n    uint256 l2Timestamp,\n    uint256 value,\n    bytes calldata data\n  ) external pure returns (bytes32);\n\n  function calculateMerkleRoot(\n    bytes32[] memory proof,\n    uint256 path,\n    bytes32 item\n  ) external pure returns (bytes32);\n}\n"
    },
    "contracts/messaging/interfaces/ambs/arbitrum/IArbitrumRollup.sol": {
      "content": "pragma solidity 0.8.17;\n\n// modified from: https://github.com/OffchainLabs/nitro/blob/master/contracts/src/rollup/Node.sol\nstruct Node {\n  // Hash of the state of the chain as of this node\n  bytes32 stateHash;\n  // Hash of the data that can be challenged\n  bytes32 challengeHash;\n  // Hash of the data that will be committed if this node is confirmed\n  bytes32 confirmData;\n  // Index of the node previous to this one\n  uint64 prevNum;\n  // Deadline at which this node can be confirmed\n  uint64 deadlineBlock;\n  // Deadline at which a child of this node can be confirmed\n  uint64 noChildConfirmedBeforeBlock;\n  // Number of stakers staked on this node. This includes real stakers and zombies\n  uint64 stakerCount;\n  // Number of stakers staked on a child node. This includes real stakers and zombies\n  uint64 childStakerCount;\n  // This value starts at zero and is set to a value when the first child is created. After that it is constant until the node is destroyed or the owner destroys pending nodes\n  uint64 firstChildBlock;\n  // The number of the latest child of this node to be created\n  uint64 latestChildNumber;\n  // The block number when this node was created\n  uint64 createdAtBlock;\n  // A hash of all the data needed to determine this node's validity, to protect against reorgs\n  bytes32 nodeHash;\n}\n\n// modified from: https://github.com/OffchainLabs/nitro/blob/master/contracts/src/rollup/IRollupCore.sol\ninterface IArbitrumRollup {\n  /**\n   * @notice Get the Node for the given index.\n   */\n  function getNode(uint64 nodeNum) external view returns (Node memory);\n}\n"
    },
    "contracts/shared/ProposedOwnable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {IProposedOwnable} from \"./interfaces/IProposedOwnable.sol\";\n\n/**\n * @title ProposedOwnable\n * @notice Contract module which provides a basic access control mechanism,\n * where there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed via a two step process:\n * 1. Call `proposeOwner`\n * 2. Wait out the delay period\n * 3. Call `acceptOwner`\n *\n * @dev This module is used through inheritance. It will make available the\n * modifier `onlyOwner`, which can be applied to your functions to restrict\n * their use to the owner.\n *\n * @dev The majority of this code was taken from the openzeppelin Ownable\n * contract\n *\n */\nabstract contract ProposedOwnable is IProposedOwnable {\n  // ========== Custom Errors ===========\n\n  error ProposedOwnable__onlyOwner_notOwner();\n  error ProposedOwnable__onlyProposed_notProposedOwner();\n  error ProposedOwnable__ownershipDelayElapsed_delayNotElapsed();\n  error ProposedOwnable__proposeNewOwner_invalidProposal();\n  error ProposedOwnable__proposeNewOwner_noOwnershipChange();\n  error ProposedOwnable__renounceOwnership_noProposal();\n  error ProposedOwnable__renounceOwnership_invalidProposal();\n\n  // ============ Properties ============\n\n  address private _owner;\n\n  address private _proposed;\n  uint256 private _proposedOwnershipTimestamp;\n\n  uint256 private constant _delay = 7 days;\n\n  // ======== Getters =========\n\n  /**\n   * @notice Returns the address of the current owner.\n   */\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @notice Returns the address of the proposed owner.\n   */\n  function proposed() public view virtual returns (address) {\n    return _proposed;\n  }\n\n  /**\n   * @notice Returns the address of the proposed owner.\n   */\n  function proposedTimestamp() public view virtual returns (uint256) {\n    return _proposedOwnershipTimestamp;\n  }\n\n  /**\n   * @notice Returns the delay period before a new owner can be accepted.\n   */\n  function delay() public view virtual returns (uint256) {\n    return _delay;\n  }\n\n  /**\n   * @notice Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    if (_owner != msg.sender) revert ProposedOwnable__onlyOwner_notOwner();\n    _;\n  }\n\n  /**\n   * @notice Throws if called by any account other than the proposed owner.\n   */\n  modifier onlyProposed() {\n    if (_proposed != msg.sender) revert ProposedOwnable__onlyProposed_notProposedOwner();\n    _;\n  }\n\n  /**\n   * @notice Throws if the ownership delay has not elapsed\n   */\n  modifier ownershipDelayElapsed() {\n    // Ensure delay has elapsed\n    if ((block.timestamp - _proposedOwnershipTimestamp) <= _delay)\n      revert ProposedOwnable__ownershipDelayElapsed_delayNotElapsed();\n    _;\n  }\n\n  /**\n   * @notice Indicates if the ownership has been renounced() by\n   * checking if current owner is address(0)\n   */\n  function renounced() public view returns (bool) {\n    return _owner == address(0);\n  }\n\n  // ======== External =========\n\n  /**\n   * @notice Sets the timestamp for an owner to be proposed, and sets the\n   * newly proposed owner as step 1 in a 2-step process\n   */\n  function proposeNewOwner(address newlyProposed) public virtual onlyOwner {\n    // Contract as source of truth\n    if (_proposed == newlyProposed && _proposedOwnershipTimestamp != 0)\n      revert ProposedOwnable__proposeNewOwner_invalidProposal();\n\n    // Sanity check: reasonable proposal\n    if (_owner == newlyProposed) revert ProposedOwnable__proposeNewOwner_noOwnershipChange();\n\n    _setProposed(newlyProposed);\n  }\n\n  /**\n   * @notice Renounces ownership of the contract after a delay\n   */\n  function renounceOwnership() public virtual onlyOwner ownershipDelayElapsed {\n    // Ensure there has been a proposal cycle started\n    if (_proposedOwnershipTimestamp == 0) revert ProposedOwnable__renounceOwnership_noProposal();\n\n    // Require proposed is set to 0\n    if (_proposed != address(0)) revert ProposedOwnable__renounceOwnership_invalidProposal();\n\n    // Emit event, set new owner, reset timestamp\n    _setOwner(address(0));\n  }\n\n  /**\n   * @notice Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function acceptProposedOwner() public virtual onlyProposed ownershipDelayElapsed {\n    // NOTE: no need to check if _owner == _proposed, because the _proposed\n    // is 0-d out and this check is implicitly enforced by modifier\n\n    // NOTE: no need to check if _proposedOwnershipTimestamp > 0 because\n    // the only time this would happen is if the _proposed was never\n    // set (will fail from modifier) or if the owner == _proposed (checked\n    // above)\n\n    // Emit event, set new owner, reset timestamp\n    _setOwner(_proposed);\n  }\n\n  // ======== Internal =========\n\n  function _setOwner(address newOwner) internal {\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n    delete _proposedOwnershipTimestamp;\n    delete _proposed;\n  }\n\n  function _setProposed(address newlyProposed) private {\n    _proposedOwnershipTimestamp = block.timestamp;\n    _proposed = newlyProposed;\n    emit OwnershipProposed(newlyProposed);\n  }\n}\n"
    },
    "contracts/shared/interfaces/IProposedOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @title IProposedOwnable\n * @notice Defines a minimal interface for ownership with a two step proposal and acceptance\n * process\n */\ninterface IProposedOwnable {\n  /**\n   * @dev This emits when change in ownership of a contract is proposed.\n   */\n  event OwnershipProposed(address indexed proposedOwner);\n\n  /**\n   * @dev This emits when ownership of a contract changes.\n   */\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @notice Get the address of the owner\n   * @return owner_ The address of the owner.\n   */\n  function owner() external view returns (address owner_);\n\n  /**\n   * @notice Get the address of the proposed owner\n   * @return proposed_ The address of the proposed.\n   */\n  function proposed() external view returns (address proposed_);\n\n  /**\n   * @notice Set the address of the proposed owner of the contract\n   * @param newlyProposed The proposed new owner of the contract\n   */\n  function proposeNewOwner(address newlyProposed) external;\n\n  /**\n   * @notice Set the address of the proposed owner of the contract\n   */\n  function acceptProposedOwner() external;\n}\n"
    },
    "contracts/shared/libraries/TypedMemView.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n  // Why does this exist?\n  // the solidity `bytes memory` type has a few weaknesses.\n  // 1. You can't index ranges effectively\n  // 2. You can't slice without copying\n  // 3. The underlying data may represent any type\n  // 4. Solidity never deallocates memory, and memory costs grow\n  //    superlinearly\n\n  // By using a memory view instead of a `bytes memory` we get the following\n  // advantages:\n  // 1. Slices are done on the stack, by manipulating the pointer\n  // 2. We can index arbitrary ranges and quickly convert them to stack types\n  // 3. We can insert type info into the pointer, and typecheck at runtime\n\n  // This makes `TypedMemView` a useful tool for efficient zero-copy\n  // algorithms.\n\n  // Why bytes29?\n  // We want to avoid confusion between views, digests, and other common\n  // types so we chose a large and uncommonly used odd number of bytes\n  //\n  // Note that while bytes are left-aligned in a word, integers and addresses\n  // are right-aligned. This means when working in assembly we have to\n  // account for the 3 unused bytes on the righthand side\n  //\n  // First 5 bytes are a type flag.\n  // - ff_ffff_fffe is reserved for unknown type.\n  // - ff_ffff_ffff is reserved for invalid types/errors.\n  // next 12 are memory address\n  // next 12 are len\n  // bottom 3 bytes are empty\n\n  // Assumptions:\n  // - non-modification of memory.\n  // - No Solidity updates\n  // - - wrt free mem point\n  // - - wrt bytes representation in memory\n  // - - wrt memory addressing in general\n\n  // Usage:\n  // - create type constants\n  // - use `assertType` for runtime type assertions\n  // - - unfortunately we can't do this at compile time yet :(\n  // - recommended: implement modifiers that perform type checking\n  // - - e.g.\n  // - - `uint40 constant MY_TYPE = 3;`\n  // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n  // - instantiate a typed view from a bytearray using `ref`\n  // - use `index` to inspect the contents of the view\n  // - use `slice` to create smaller views into the same memory\n  // - - `slice` can increase the offset\n  // - - `slice can decrease the length`\n  // - - must specify the output type of `slice`\n  // - - `slice` will return a null view if you try to overrun\n  // - - make sure to explicitly check for this with `notNull` or `assertType`\n  // - use `equal` for typed comparisons.\n\n  // The null view\n  bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n  uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n  uint256 constant TWENTY_SEVEN_BYTES = 8 * 27;\n  uint256 private constant _27_BYTES_IN_BITS = 8 * 27; // <--- also used this named constant where ever 216 is used.\n  uint256 private constant LOW_27_BYTES_MASK = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff; // (1 << _27_BYTES_IN_BITS) - 1;\n\n  // ========== Custom Errors ===========\n\n  error TypedMemView__assertType_typeAssertionFailed(uint256 actual, uint256 expected);\n  error TypedMemView__index_overrun(uint256 loc, uint256 len, uint256 index, uint256 slice);\n  error TypedMemView__index_indexMoreThan32Bytes();\n  error TypedMemView__unsafeCopyTo_nullPointer();\n  error TypedMemView__unsafeCopyTo_invalidPointer();\n  error TypedMemView__unsafeCopyTo_identityOOG();\n  error TypedMemView__assertValid_validityAssertionFailed();\n\n  /**\n   * @notice          Changes the endianness of a uint256.\n   * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n   * @param _b        The unsigned integer to reverse\n   * @return          v - The reversed value\n   */\n  function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n    v = _b;\n\n    // swap bytes\n    v =\n      ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n      ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n    // swap 2-byte long pairs\n    v =\n      ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n      ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n    // swap 4-byte long pairs\n    v =\n      ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n      ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n    // swap 8-byte long pairs\n    v =\n      ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n      ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n    // swap 16-byte long pairs\n    v = (v >> 128) | (v << 128);\n  }\n\n  /**\n   * @notice      Create a mask with the highest `_len` bits set.\n   * @param _len  The length\n   * @return      mask - The mask\n   */\n  function leftMask(uint8 _len) private pure returns (uint256 mask) {\n    // ugly. redo without assembly?\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      mask := sar(sub(_len, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n    }\n  }\n\n  /**\n   * @notice      Return the null view.\n   * @return      bytes29 - The null view\n   */\n  function nullView() internal pure returns (bytes29) {\n    return NULL;\n  }\n\n  /**\n   * @notice      Check if the view is null.\n   * @return      bool - True if the view is null\n   */\n  function isNull(bytes29 memView) internal pure returns (bool) {\n    return memView == NULL;\n  }\n\n  /**\n   * @notice      Check if the view is not null.\n   * @return      bool - True if the view is not null\n   */\n  function notNull(bytes29 memView) internal pure returns (bool) {\n    return !isNull(memView);\n  }\n\n  /**\n   * @notice          Check if the view is of a invalid type and points to a valid location\n   *                  in memory.\n   * @dev             We perform this check by examining solidity's unallocated memory\n   *                  pointer and ensuring that the view's upper bound is less than that.\n   * @param memView   The view\n   * @return          ret - True if the view is invalid\n   */\n  function isNotValid(bytes29 memView) internal pure returns (bool ret) {\n    if (typeOf(memView) == 0xffffffffff) {\n      return true;\n    }\n    uint256 _end = end(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ret := gt(_end, mload(0x40))\n    }\n  }\n\n  /**\n   * @notice          Require that a typed memory view be valid.\n   * @dev             Returns the view for easy chaining.\n   * @param memView   The view\n   * @return          bytes29 - The validated view\n   */\n  function assertValid(bytes29 memView) internal pure returns (bytes29) {\n    if (isNotValid(memView)) revert TypedMemView__assertValid_validityAssertionFailed();\n    return memView;\n  }\n\n  /**\n   * @notice          Return true if the memview is of the expected type. Otherwise false.\n   * @param memView   The view\n   * @param _expected The expected type\n   * @return          bool - True if the memview is of the expected type\n   */\n  function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n    return typeOf(memView) == _expected;\n  }\n\n  /**\n   * @notice          Require that a typed memory view has a specific type.\n   * @dev             Returns the view for easy chaining.\n   * @param memView   The view\n   * @param _expected The expected type\n   * @return          bytes29 - The view with validated type\n   */\n  function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n    if (!isType(memView, _expected)) {\n      revert TypedMemView__assertType_typeAssertionFailed(uint256(typeOf(memView)), uint256(_expected));\n    }\n    return memView;\n  }\n\n  /**\n   * @notice          Return an identical view with a different type.\n   * @param memView   The view\n   * @param _newType  The new type\n   * @return          newView - The new view with the specified type\n   */\n  function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n    // then | in the new type\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // shift off the top 5 bytes\n      newView := or(and(memView, LOW_27_BYTES_MASK), shl(_27_BYTES_IN_BITS, _newType))\n    }\n  }\n\n  /**\n   * @notice          Unsafe raw pointer construction. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @dev             Unsafe raw pointer construction. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @param _type     The type\n   * @param _loc      The memory address\n   * @param _len      The length\n   * @return          newView - The new view with the specified type, location and length\n   */\n  function unsafeBuildUnchecked(\n    uint256 _type,\n    uint256 _loc,\n    uint256 _len\n  ) private pure returns (bytes29 newView) {\n    uint256 _uint96Bits = 96;\n    uint256 _emptyBits = 24;\n\n    // Cast params to ensure input is of correct length\n    uint96 len_ = uint96(_len);\n    uint96 loc_ = uint96(_loc);\n    require(len_ == _len && loc_ == _loc, \"!truncated\");\n\n    assembly {\n      // solium-disable-previous-line security/no-inline-assembly\n      newView := shl(_uint96Bits, _type) // insert type\n      newView := shl(_uint96Bits, or(newView, loc_)) // insert loc\n      newView := shl(_emptyBits, or(newView, len_)) // empty bottom 3 bytes\n    }\n  }\n\n  /**\n   * @notice          Instantiate a new memory view. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @dev             Instantiate a new memory view. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @param _type     The type\n   * @param _loc      The memory address\n   * @param _len      The length\n   * @return          newView - The new view with the specified type, location and length\n   */\n  function build(\n    uint256 _type,\n    uint256 _loc,\n    uint256 _len\n  ) internal pure returns (bytes29 newView) {\n    uint256 _end = _loc + _len;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      if gt(_end, mload(0x40)) {\n        _end := 0\n      }\n    }\n    if (_end == 0) {\n      return NULL;\n    }\n    newView = unsafeBuildUnchecked(_type, _loc, _len);\n  }\n\n  /**\n   * @notice          Instantiate a memory view from a byte array.\n   * @dev             Note that due to Solidity memory representation, it is not possible to\n   *                  implement a deref, as the `bytes` type stores its len in memory.\n   * @param arr       The byte array\n   * @param newType   The type\n   * @return          bytes29 - The memory view\n   */\n  function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n    uint256 _len = arr.length;\n\n    uint256 _loc;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      _loc := add(arr, 0x20) // our view is of the data, not the struct\n    }\n\n    return build(newType, _loc, _len);\n  }\n\n  /**\n   * @notice          Return the associated type information.\n   * @param memView   The memory view\n   * @return          _type - The type associated with the view\n   */\n  function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // 216 == 256 - 40\n      _type := shr(_27_BYTES_IN_BITS, memView) // shift out lower 24 bytes\n    }\n  }\n\n  /**\n   * @notice          Return the memory address of the underlying bytes.\n   * @param memView   The view\n   * @return          _loc - The memory address\n   */\n  function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n    uint256 _mask = LOW_12_MASK; // assembly can't use globals\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n      _loc := and(shr(120, memView), _mask)\n    }\n  }\n\n  /**\n   * @notice          The number of memory words this memory view occupies, rounded up.\n   * @param memView   The view\n   * @return          uint256 - The number of memory words\n   */\n  function words(bytes29 memView) internal pure returns (uint256) {\n    return (uint256(len(memView)) + 31) / 32;\n  }\n\n  /**\n   * @notice          The in-memory footprint of a fresh copy of the view.\n   * @param memView   The view\n   * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n   */\n  function footprint(bytes29 memView) internal pure returns (uint256) {\n    return words(memView) * 32;\n  }\n\n  /**\n   * @notice          The number of bytes of the view.\n   * @param memView   The view\n   * @return          _len - The length of the view\n   */\n  function len(bytes29 memView) internal pure returns (uint96 _len) {\n    uint256 _mask = LOW_12_MASK; // assembly can't use globals\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      _len := and(shr(24, memView), _mask)\n    }\n  }\n\n  /**\n   * @notice          Returns the endpoint of `memView`.\n   * @param memView   The view\n   * @return          uint256 - The endpoint of `memView`\n   */\n  function end(bytes29 memView) internal pure returns (uint256) {\n    unchecked {\n      return loc(memView) + len(memView);\n    }\n  }\n\n  /**\n   * @notice          Safe slicing without memory modification.\n   * @param memView   The view\n   * @param _index    The start index\n   * @param _len      The length\n   * @param newType   The new type\n   * @return          bytes29 - The new view\n   */\n  function slice(\n    bytes29 memView,\n    uint256 _index,\n    uint256 _len,\n    uint40 newType\n  ) internal pure returns (bytes29) {\n    uint256 _loc = loc(memView);\n\n    // Ensure it doesn't overrun the view\n    if (_loc + _index + _len > end(memView)) {\n      return NULL;\n    }\n\n    _loc = _loc + _index;\n    return build(newType, _loc, _len);\n  }\n\n  /**\n   * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n   * @param memView   The view\n   * @param _len      The length\n   * @param newType   The new type\n   * @return          bytes29 - The new view\n   */\n  function prefix(\n    bytes29 memView,\n    uint256 _len,\n    uint40 newType\n  ) internal pure returns (bytes29) {\n    return slice(memView, 0, _len, newType);\n  }\n\n  /**\n   * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n   * @param memView   The view\n   * @param _len      The length\n   * @param newType   The new type\n   * @return          bytes29 - The new view\n   */\n  function postfix(\n    bytes29 memView,\n    uint256 _len,\n    uint40 newType\n  ) internal pure returns (bytes29) {\n    return slice(memView, uint256(len(memView)) - _len, _len, newType);\n  }\n\n  /**\n   * @notice          Load up to 32 bytes from the view onto the stack.\n   * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n   *                  This can be immediately cast to a smaller fixed-length byte array.\n   *                  To automatically cast to an integer, use `indexUint`.\n   * @param memView   The view\n   * @param _index    The index\n   * @param _bytes    The bytes\n   * @return          result - The 32 byte result\n   */\n  function index(\n    bytes29 memView,\n    uint256 _index,\n    uint8 _bytes\n  ) internal pure returns (bytes32 result) {\n    if (_bytes == 0) {\n      return bytes32(0);\n    }\n    if (_index + _bytes > len(memView)) {\n      // \"TypedMemView/index - Overran the view. Slice is at {loc} with length {len}. Attempted to index at offset {index} with length {slice},\n      revert TypedMemView__index_overrun(loc(memView), len(memView), _index, uint256(_bytes));\n    }\n    if (_bytes > 32) revert TypedMemView__index_indexMoreThan32Bytes();\n\n    uint8 bitLength;\n    unchecked {\n      bitLength = _bytes * 8;\n    }\n    uint256 _loc = loc(memView);\n    uint256 _mask = leftMask(bitLength);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      result := and(mload(add(_loc, _index)), _mask)\n    }\n  }\n\n  /**\n   * @notice          Parse an unsigned integer from the view at `_index`.\n   * @dev             Requires that the view have >= `_bytes` bytes following that index.\n   * @param memView   The view\n   * @param _index    The index\n   * @param _bytes    The bytes\n   * @return          result - The unsigned integer\n   */\n  function indexUint(\n    bytes29 memView,\n    uint256 _index,\n    uint8 _bytes\n  ) internal pure returns (uint256 result) {\n    return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\n  }\n\n  /**\n   * @notice          Parse an unsigned integer from LE bytes.\n   * @param memView   The view\n   * @param _index    The index\n   * @param _bytes    The bytes\n   * @return          result - The unsigned integer\n   */\n  function indexLEUint(\n    bytes29 memView,\n    uint256 _index,\n    uint8 _bytes\n  ) internal pure returns (uint256 result) {\n    return reverseUint256(uint256(index(memView, _index, _bytes)));\n  }\n\n  /**\n   * @notice          Parse an address from the view at `_index`. Requires that the view have >= 20 bytes\n   *                  following that index.\n   * @param memView   The view\n   * @param _index    The index\n   * @return          address - The address\n   */\n  function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n    return address(uint160(indexUint(memView, _index, 20)));\n  }\n\n  /**\n   * @notice          Return the keccak256 hash of the underlying memory\n   * @param memView   The view\n   * @return          digest - The keccak256 hash of the underlying memory\n   */\n  function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n    uint256 _loc = loc(memView);\n    uint256 _len = len(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      digest := keccak256(_loc, _len)\n    }\n  }\n\n  /**\n   * @notice          Return true if the underlying memory is equal. Else false.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - True if the underlying memory is equal\n   */\n  function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);\n  }\n\n  /**\n   * @notice          Return false if the underlying memory is equal. Else true.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - False if the underlying memory is equal\n   */\n  function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return !untypedEqual(left, right);\n  }\n\n  /**\n   * @notice          Compares type equality.\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - True if the types are the same\n   */\n  function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\n  }\n\n  /**\n   * @notice          Compares type inequality.\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - True if the types are not the same\n   */\n  function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return !equal(left, right);\n  }\n\n  /**\n   * @notice          Copy the view to a location, return an unsafe memory reference\n   * @dev             Super Dangerous direct memory access.\n   *\n   *                  This reference can be overwritten if anything else modifies memory (!!!).\n   *                  As such it MUST be consumed IMMEDIATELY.\n   *                  This function is private to prevent unsafe usage by callers.\n   * @param memView   The view\n   * @param _newLoc   The new location\n   * @return          written - the unsafe memory reference\n   */\n  function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n    if (isNull(memView)) revert TypedMemView__unsafeCopyTo_nullPointer();\n    if (isNotValid(memView)) revert TypedMemView__unsafeCopyTo_invalidPointer();\n\n    uint256 _len = len(memView);\n    uint256 _oldLoc = loc(memView);\n\n    uint256 ptr;\n    bool res;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40)\n      // revert if we're writing in occupied memory\n      if gt(ptr, _newLoc) {\n        revert(0x60, 0x20) // empty revert message\n      }\n\n      // use the identity precompile to copy\n      // guaranteed not to fail, so pop the success\n      res := staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len)\n    }\n    if (!res) revert TypedMemView__unsafeCopyTo_identityOOG();\n    written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n  }\n\n  /**\n   * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n   *                  the new memory\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n   * @param memView   The view\n   * @return          ret - The view pointing to the new memory\n   */\n  function clone(bytes29 memView) internal view returns (bytes memory ret) {\n    uint256 ptr;\n    uint256 _len = len(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40) // load unused memory pointer\n      ret := ptr\n    }\n    unchecked {\n      unsafeCopyTo(memView, ptr + 0x20);\n    }\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n      mstore(ptr, _len) // write len of new array (in bytes)\n    }\n  }\n\n  /**\n   * @notice          Join the views in memory, return an unsafe reference to the memory.\n   * @dev             Super Dangerous direct memory access.\n   *\n   *                  This reference can be overwritten if anything else modifies memory (!!!).\n   *                  As such it MUST be consumed IMMEDIATELY.\n   *                  This function is private to prevent unsafe usage by callers.\n   * @param memViews  The views\n   * @return          unsafeView - The conjoined view pointing to the new memory\n   */\n  function unsafeJoin(bytes29[] memory memViews, uint256 _location) private view returns (bytes29 unsafeView) {\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      let ptr := mload(0x40)\n      // revert if we're writing in occupied memory\n      if gt(ptr, _location) {\n        revert(0x60, 0x20) // empty revert message\n      }\n    }\n\n    uint256 _offset = 0;\n    uint256 _len = memViews.length;\n    for (uint256 i = 0; i < _len; ) {\n      bytes29 memView = memViews[i];\n      unchecked {\n        unsafeCopyTo(memView, _location + _offset);\n        _offset += len(memView);\n        ++i;\n      }\n    }\n    unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n  }\n\n  /**\n   * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n   * @param memViews  The views\n   * @return          bytes32 - The keccak256 digest\n   */\n  function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n    uint256 ptr;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40) // load unused memory pointer\n    }\n    return keccak(unsafeJoin(memViews, ptr));\n  }\n\n  /**\n   * @notice          copies all views, joins them into a new bytearray.\n   * @param memViews  The views\n   * @return          ret - The new byte array\n   */\n  function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n    uint256 ptr;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40) // load unused memory pointer\n    }\n\n    bytes29 _newView;\n    unchecked {\n      _newView = unsafeJoin(memViews, ptr + 0x20);\n    }\n    uint256 _written = len(_newView);\n    uint256 _footprint = footprint(_newView);\n\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // store the legnth\n      mstore(ptr, _written)\n      // new pointer is old + 0x20 + the footprint of the body\n      mstore(0x40, add(add(ptr, _footprint), 0x20))\n      ret := ptr\n    }\n  }\n}\n"
    }
  }
}}