{{
  "language": "Solidity",
  "sources": {
    "contracts/governance/AavePropositionPower.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Capped.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\n\n/// @title AavePropositionPower\n/// @author Aave\n/// @notice Asset to control the permissions on the actions in AaveProtoGovernance, like:\n///  - Register a new Proposal\ncontract AavePropositionPower is ERC20Capped, ERC20Detailed {\n\n    /// @notice Constructor\n    /// @param name Asset name\n    /// @param symbol Asset symbol\n    /// @param decimals Asset decimals\n    /// @param council List of addresses which will receive tokens initially\n    /// @param cap The cap of tokens to mint, length of the council list\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        address[] memory council,\n        uint256 cap\n    )\n    public ERC20Capped(cap * 1 ether) ERC20Detailed(name, symbol, decimals) {\n        require(cap == council.length, \"INCONSISTENT_CAP_AND_COUNCIL_SIZE\");\n        for (uint256 i = 0; i < cap; i++) {\n            _mint(council[i], 1 ether);\n        }\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Capped.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC20Mintable.sol\";\n\n/**\n * @dev Extension of {ERC20Mintable} that adds a cap to the supply of tokens.\n */\ncontract ERC20Capped is ERC20Mintable {\n    uint256 private _cap;\n\n    /**\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n     * set once during construction.\n     */\n    constructor (uint256 cap) public {\n        require(cap > 0, \"ERC20Capped: cap is 0\");\n        _cap = cap;\n    }\n\n    /**\n     * @dev Returns the cap on the token's total supply.\n     */\n    function cap() public view returns (uint256) {\n        return _cap;\n    }\n\n    /**\n     * @dev See {ERC20Mintable-mint}.\n     *\n     * Requirements:\n     *\n     * - `value` must not cause the total supply to go over the cap.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(totalSupply().add(value) <= _cap, \"ERC20Capped: cap exceeded\");\n        super._mint(account, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Mintable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\nimport \"../../access/roles/MinterRole.sol\";\n\n/**\n * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the {MinterRole}.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/roles/MinterRole.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"../Roles.sol\";\n\ncontract MinterRole is Context {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(_msgSender());\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(_msgSender());\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Roles.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/governance/AaveProtoGovernance.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\n\nimport \"../interfaces/IGovernanceParamsProvider.sol\";\nimport \"../interfaces/IAssetVotingWeightProvider.sol\";\nimport \"../interfaces/IProposalExecutor.sol\";\nimport \"../interfaces/IAaveProtoGovernance.sol\";\n\n\n/// @title AaveProtoGovernance\n/// @author Aave\n/// @notice Smart contract containing voting logic and registering voting proposals.\n///  - Allows to granular resolution per proposal\n///  - Fixes the voting logic\n///  - Keeps all the data related with all the proposals\n///  - Allows voters to submit, override or cancel votes directly\n///  - Allows relayers to submit, override or cancel votes on behalf of voters\n///  - Once the voting and validation periods finish, executes a DELEGATECALL to the proposalExecutor of the\n///    corresponding proposal\n///  - The creation of a new proposal can only be triggered by an account with a certain amount of AavePropositionPower\ncontract AaveProtoGovernance is IAaveProtoGovernance {\n    using SafeMath for uint256;\n    using ECDSA for bytes32;\n\n    struct Voter {\n        /// @notice Vote with 0 always as abstain.\n        ///  In a YES/NO scenario, YES would be 1, NO would be 2\n        uint256 vote;\n        /// @notice Weight of the asset coming from the IAssetVotingWeightProvider\n        uint256 weight;\n        /// @notice Asset balance used to vote\n        uint256 balance;\n        /// @notice The nonce of the voter address, to protect agains vote replay attacks\n        //  It is increased in 1 unit on both voting and cancel vote of an user. When the\n        //  user vote overrides his previous vote, it is double increased\n        uint256 nonce;\n        /// @notice Address of the asset using to vote, locked in the voter address\n        IERC20 asset;\n    }\n\n    struct Proposal {\n        /// @notice Hashed type of the proposal, for example keccak256(UPGRADE_ADDRESS_PROPOSAL)\n        bytes32 proposalType;\n        /// @notice Count of the current units of votes accumulated until the current moment (each time somebody votes + 1)\n        uint256 totalVotes;\n        /// @notice Threshold required calculated offchain from the aggregated total supply of the whitelisted\n        ///  assets multiplied by the voting weight of each asset\n        ///  Example: With 2 whitelisted tokens with 1 and 2 as respective voting weights and 10 000 and 20 000\n        ///  respective total supplies, the aggregated voting power would be (10000 * 1) + (20000 * 2) = 50000,\n        ///  so a threshold equivalent to the 50% of total voting power would be 25000\n        uint256 threshold;\n        /// @notice Variable to control how many changes to Voting state are allowed\n        /// (both initially from Initializing and from Validating every time the threshold is crossed down\n        ///  due to double votes)\n        uint256 maxMovesToVotingAllowed;\n        /// @notice Current amount of times the proposal went to Voting state\n        uint256 movesToVoting;\n        /// @notice Minimum number of blocks the proposal needs to be in Voting before being able to change to\n        /// Validating\n        uint256 votingBlocksDuration;\n        /// @notice Minimum number of blocks the proposal needs to be in Validating before being able to be executed\n        uint256 validatingBlocksDuration;\n        /// @notice Block number where the current status started\n        uint256 currentStatusInitBlock;\n        /// @notice Block number when the proposal was created\n        uint256 initProposalBlock;\n        /// @notice Mapping choice id => voting power accumulated in the choice\n        mapping(uint256 => uint256) votes;\n        /// @notice Mapping of voters: Voting Wallet address => vote information\n        mapping(address => Voter) voters;\n        /// @notice Smart contract in charge of .execute() a certain payload\n        address proposalExecutor;\n        /// @notice Status of the proposal\n        ProposalStatus proposalStatus;\n    }\n\n    /// @notice State Machine\n    ///  - Initializing: temporary state during the newProposal() execution, before changing to Voting.\n    ///  - Voting: Once newProposal() execution finishes. Voters are able to vote or cancel their votes.\n    ///  - Validating: After the voting period ends and the proposal threshold gets crossed by one of the\n    ///      allowed choices. During this period, everybody is be able to call challengeVoters() in order\n    ///      to invalidate votes result of double-voting attacks. If the threshold is crossed down at any point,\n    ///      the state changes again to Voting. The validating period will have a defined time\n    ///      length, after which (since the point where the proposal was moved from Voting status)\n    ///      the resolveProposal() function could be called\n    ///  - Executed: After the proposal is resolved\n    enum ProposalStatus {Initializing, Voting, Validating, Executed}\n\n    event ProposalCreated(\n        uint256 indexed proposalId,\n        bytes32 indexed ipfsHash,\n        bytes32 indexed proposalType,\n        uint256 propositionPowerOfCreator,\n        uint256 threshold,\n        uint256 maxMovesToVotingAllowed,\n        uint256 votingBlocksDuration,\n        uint256 validatingBlocksDuration,\n        address proposalExecutor\n    );\n    event StatusChangeToVoting(uint256 indexed proposalId, uint256 movesToVoting);\n    event StatusChangeToValidating(uint256 indexed proposalId);\n    event StatusChangeToExecuted(uint256 indexed proposalId);\n    event VoteEmitted(\n        uint256 indexed proposalId,\n        address indexed voter,\n        uint256 indexed vote,\n        IERC20 asset,\n        uint256 weight,\n        uint256 balance\n    );\n    event VoteCancelled(\n        uint256 indexed proposalId,\n        address indexed voter,\n        uint256 indexed vote,\n        IERC20 asset,\n        uint256 weight,\n        uint256 balance,\n        uint256 proposalStatusBefore\n    );\n    event YesWins(uint256 indexed proposalId, uint256 abstainVotingPower, uint256 yesVotingPower, uint256 noVotingPower);\n    event NoWins(uint256 indexed proposalId, uint256 abstainVotingPower, uint256 yesVotingPower, uint256 noVotingPower);\n    event AbstainWins(uint256 indexed proposalId, uint256 abstainVotingPower, uint256 yesVotingPower, uint256 noVotingPower);\n\n    /// @notice 0: Abstain, 1: YES, 2: NO\n    uint256 public constant COUNT_CHOICES = 2;\n\n    /// @notice Taking as reference the LEND token supply, a minimum of 13M of LEND token (1% of supply)\n    //  on the AssetVotingWeightProvider) can be set as threshold in a new proposal\n    uint256 public constant MIN_THRESHOLD = 13000000 ether;\n\n    /// @notice Minimum number of blocks for a proposal's votingBlocksDuration and validatingBlocksDuration\n    uint256 public constant MIN_STATUS_DURATION = 1660;  // ~6h with 13s blocktime\n\n    /// @notice Minimum for a proposal's maxMovesToVotingAllowed\n    uint256 public constant MIN_MAXMOVESTOVOTINGALLOWED = 2;\n\n    /// @notice Maximum for a proposal's maxMovesToVotingAllowed\n    uint256 public constant MAX_MAXMOVESTOVOTINGALLOWED = 6;\n\n    /// @notice Smart contract holding the global parameters needed in this AaveProtoGovernance\n    IGovernanceParamsProvider private govParamsProvider;\n\n    Proposal[] private proposals;\n\n    constructor(IGovernanceParamsProvider _govParamsProvider) public {\n        govParamsProvider = _govParamsProvider;\n    }\n\n    /// @notice Fallback function, not allowing transfer of ETH\n    function() external payable {\n        revert(\"ETH_TRANSFER_NOT_ALLOWED\");\n    }\n\n    /// @notice Registers a new proposal\n    ///  - Allowed only for holders of aavePropositionPower with more than 100/propositionPowerThreshold % of the total supply\n    ///  - It sets the proposalStatus of the proposal to Voting\n    /// @param _proposalType Hashed type of the proposal\n    /// @param _ipfsHash bytes32-formatted IPFS hash, removed the first 2 bytes of the multihash (multihash identifier)\n    /// @param _threshold Threshold required calculated offchain from the aggregated total supply of the whitelisted\n    ///                 assets multiplied by the voting weight of each asset\n    /// @param _proposalExecutor Smart contract in charge of .execute() a certain payload\n    /// @param _votingBlocksDuration Minimum number of blocks the proposal needs to be in Voting before being able\n    ///                              to change to Validating\n    /// @param _validatingBlocksDuration Minimum number of blocks the proposal needs to be in Validating before being\n    ///                                  able to be executed\n    /// @param _maxMovesToVotingAllowed Variable to control how many changes to Voting state are allowed\n    function newProposal(\n        bytes32 _proposalType,\n        bytes32 _ipfsHash,\n        uint256 _threshold,\n        address _proposalExecutor,\n        uint256 _votingBlocksDuration,\n        uint256 _validatingBlocksDuration,\n        uint256 _maxMovesToVotingAllowed\n    ) external {\n        IERC20 _propositionPower = govParamsProvider.getPropositionPower();\n        uint256 _propositionPowerOfCreator = _propositionPower.balanceOf(msg.sender);\n\n        // Creation of block to avoid \"Stack too deep\"\n        {\n            uint256 _propositionPowerTotalSupply = _propositionPower.totalSupply();\n            require(_propositionPowerTotalSupply > 0 &&\n                _propositionPowerOfCreator >= _propositionPowerTotalSupply.div(govParamsProvider.getPropositionPowerThreshold()),\n            \"INVALID_PROPOSITION_POWER_BALANCE\");\n            require(_threshold >= MIN_THRESHOLD, \"INVALID_THRESHOLD\");\n            require(_votingBlocksDuration >= MIN_STATUS_DURATION, \"INVALID_VOTING_BLOCKS_DURATION\");\n            require(_validatingBlocksDuration >= MIN_STATUS_DURATION, \"INVALID_VALIDATING_BLOCKS_DURATION\");\n            require(_maxMovesToVotingAllowed >= MIN_MAXMOVESTOVOTINGALLOWED &&\n                _maxMovesToVotingAllowed <= MAX_MAXMOVESTOVOTINGALLOWED,\n            \"INVALID_MAXVOTESTOVOTINGALLOWED\");\n        }\n\n        uint256 _proposalId = proposals.push(Proposal({\n            proposalType: _proposalType,\n            totalVotes: 0,\n            threshold: _threshold,\n            maxMovesToVotingAllowed: _maxMovesToVotingAllowed,\n            movesToVoting: 0,\n            votingBlocksDuration: _votingBlocksDuration,\n            validatingBlocksDuration: _validatingBlocksDuration,\n            currentStatusInitBlock: 0,\n            initProposalBlock: block.number,\n            proposalExecutor: _proposalExecutor,\n            proposalStatus: ProposalStatus.Initializing\n        })).sub(1);\n\n        internalMoveToVoting(_proposalId);\n\n        emit ProposalCreated(\n            _proposalId,\n            _ipfsHash,\n            _proposalType,\n            _propositionPowerOfCreator,\n            _threshold,\n            _maxMovesToVotingAllowed,\n            _votingBlocksDuration,\n            _validatingBlocksDuration,\n            _proposalExecutor\n        );\n    }\n\n    /// @notice Verifies the consistency of the action's params and their correct signature\n    function verifyParamsConsistencyAndSignature(\n        bytes32 _paramsHashByRelayer,\n        bytes32 _paramsHashBySigner,\n        bytes memory _signature,\n        address _signer\n    ) public pure {\n        require(_paramsHashBySigner == _paramsHashByRelayer, \"INCONSISTENT_HASHES\");\n        require(_signer == _paramsHashByRelayer.toEthSignedMessageHash().recover(_signature), \"SIGNATURE_NOT_VALID\");\n    }\n\n    /// @notice Verifies the nonce of a voter on a proposal\n    /// @param _proposalId The id of the proposal\n    /// @param _voter The address of the voter\n    /// @param _relayerNonce The nonce submitted by the relayer\n    function verifyNonce(uint256 _proposalId, address _voter, uint256 _relayerNonce) public view {\n        Proposal storage _proposal = proposals[_proposalId];\n        require(_proposal.voters[_voter].nonce.add(1) == _relayerNonce, \"INVALID_NONCE\");\n    }\n\n    /// @notice Validates an action submitted by a relayer\n    /// @param _paramsHashByRelayer Hash of the params of the action, hashed by the relayer on-chain\n    /// @param _paramsHashBySigner Hash of the params of the action, hashed by the signer off-chain, received by the relayer\n    /// @param _signature Signature of the hashed params by the signer, created by the signer offchain, received by the relayer\n    /// @param _signer The address of the signer\n    /// @param _proposalId The id of the proposal\n    /// @param _relayerNonce The nonce by the relayer\n    function validateRelayAction(\n        bytes32 _paramsHashByRelayer,\n        bytes32 _paramsHashBySigner,\n        bytes memory _signature,\n        address _signer,\n        uint256 _proposalId,\n        uint256 _relayerNonce)\n    public view {\n        verifyParamsConsistencyAndSignature(_paramsHashByRelayer, _paramsHashBySigner, _signature, _signer);\n        verifyNonce(_proposalId, _signer, _relayerNonce);\n    }\n\n    /// @notice Internal function to change proposalStatus to Voting\n    /// @param _proposalId The id of the proposal\n    function internalMoveToVoting(uint256 _proposalId) internal {\n        Proposal storage _proposal = proposals[_proposalId];\n        _proposal.proposalStatus = ProposalStatus.Voting;\n        _proposal.currentStatusInitBlock = block.number;\n        _proposal.movesToVoting++;\n        emit StatusChangeToVoting(_proposalId, _proposal.movesToVoting);\n    }\n\n    /// @notice Internal function to change proposalStatus from Voting to Validating\n    /// @param _proposalId The id of the proposal\n    function internalMoveToValidating(uint256 _proposalId) internal {\n        Proposal storage _proposal = proposals[_proposalId];\n        _proposal.proposalStatus = ProposalStatus.Validating;\n        _proposal.currentStatusInitBlock = block.number;\n        emit StatusChangeToValidating(_proposalId);\n    }\n\n    /// @notice Internal function to change proposalStatus from Validating to Executed\n    ///  once the proposal is resolved\n    /// @param _proposalId The id of the proposal\n    function internalMoveToExecuted(uint256 _proposalId) internal {\n        Proposal storage _proposal = proposals[_proposalId];\n        _proposal.proposalStatus = ProposalStatus.Executed;\n        emit StatusChangeToExecuted(_proposalId);\n    }\n\n    /// @notice Function called by a voter to submit his vote directly\n    function submitVoteByVoter(uint256 _proposalId, uint256 _vote, IERC20 _asset) external {\n        internalSubmitVote(_proposalId, _vote, msg.sender, _asset);\n    }\n\n    /// @notice Function called by any address relaying signed vote params from another wallet.\n    //   Initially this relayer is thought to be a \"hot\" wallet of the voter,\n    ///  allowing this way to keep the voting asset funds in a \"cold\" wallet, create an offline\n    ///  signature with it and forwarding everything to the \"hot\" wallet to submit.\n    ///  This function is completely opened, as the nonce + signature methods protects against\n    ///  any malicious actor.\n    function submitVoteByRelayer(\n        uint256 _proposalId,\n        uint256 _vote,\n        address _voter,\n        IERC20 _asset,\n        uint256 _nonce,\n        bytes calldata _signature,\n        bytes32 _paramsHashByVoter)\n    external {\n        validateRelayAction(\n            keccak256(abi.encodePacked(_proposalId, _vote, _voter, _asset, _nonce)),\n            _paramsHashByVoter,\n            _signature,\n            _voter,\n            _proposalId,\n            _nonce);\n        internalSubmitVote(_proposalId, _vote, _voter, _asset);\n    }\n\n    /// @notice Function called by a voter to cancel his vote directly\n    /// @param _proposalId The id of the proposal\n    function cancelVoteByVoter(uint256 _proposalId) external {\n        Proposal storage _proposal = proposals[_proposalId];\n        require(_proposal.proposalStatus == ProposalStatus.Voting, \"VOTING_STATUS_REQUIRED\");\n        internalCancelVote(_proposalId, msg.sender);\n    }\n\n    /// @notice Same logic as submitVoteByRelayer, but to cancel a current vote by a _voter\n    /// @param _proposalId The id of the proposal\n    /// @param _nonce The current nonce of the voter in the proposal\n    /// @param _voter The address of the voter\n    /// @param _signature The signature of the tx, created by the voter and sent to the relayer\n    /// @param _paramsHashByVoter Params hash to validate against the signature\n    function cancelVoteByRelayer(\n        uint256 _proposalId,\n        address _voter,\n        uint256 _nonce,\n        bytes calldata _signature,\n        bytes32 _paramsHashByVoter)\n    external {\n        Proposal storage _proposal = proposals[_proposalId];\n        require(_proposal.proposalStatus == ProposalStatus.Voting, \"VOTING_STATUS_REQUIRED\");\n        validateRelayAction(\n            keccak256(abi.encodePacked(_proposalId, _voter, _nonce)),\n            _paramsHashByVoter,\n            _signature,\n            _voter,\n            _proposalId,\n            _nonce);\n        internalCancelVote(_proposalId, _voter);\n    }\n\n    /// @notice Internal function to submit a vote. This function is called from\n    ///  the external voting functions, by relayers and directly by voters\n    ///  - If the voter has already voted, override the vote with the new one\n    ///  - The vote is only allowed if the _asset is whitelisted in the assetVotingWeightProvider\n    ///  - The _vote needs to be amongst the valid voting choices\n    ///  - The _voter voter address needs to have _asset amount locked\n    /// @param _proposalId The id of the proposal\n    /// @param _vote A value between 0 and COUNT_CHOICES (included)\n    /// @param _asset The asset locked in the _voter address, used to vote\n    /// @param _voter the voter address, original signer of the transaction\n    function internalSubmitVote(uint256 _proposalId, uint256 _vote, address _voter, IERC20 _asset) internal {\n        Proposal storage _proposal = proposals[_proposalId];\n        require(_proposal.proposalStatus == ProposalStatus.Voting, \"VOTING_STATUS_REQUIRED\");\n        uint256 _assetVotingWeight = govParamsProvider.getAssetVotingWeightProvider().getVotingWeight(_asset);\n        require(_assetVotingWeight != 0, \"ASSET_NOT_LISTED\");\n        require(_vote <= COUNT_CHOICES, \"INVALID_VOTE_PARAM\");\n        uint256 _voterAssetBalance = _asset.balanceOf(_voter);\n        require(_voterAssetBalance > 0, \"INVALID_VOTER_BALANCE\");\n\n        // If the voter is replacing a previous vote, cancel the previous one first, to avoid double counting\n        if (address(_proposal.voters[_voter].asset) != address(0)) {\n            internalCancelVote(_proposalId, _voter);\n        }\n\n        uint256 _assetWeight = _assetVotingWeight;\n        uint256 _votingPower = _voterAssetBalance.mul(_assetWeight);\n        _proposal.totalVotes = _proposal.totalVotes.add(1);\n        _proposal.votes[_vote] = _votingPower.add(_proposal.votes[_vote]);\n        Voter storage voter = _proposal.voters[_voter];\n        voter.vote = _vote;\n        voter.weight = _assetWeight;\n        voter.balance = _voterAssetBalance;\n        voter.asset = _asset;\n        voter.nonce = voter.nonce.add(1);\n\n        emit VoteEmitted(_proposalId, _voter, _vote, voter.asset, _assetWeight, _voterAssetBalance);\n\n        tryToMoveToValidating(_proposalId);\n    }\n\n    /// @notice Function to move to Validating the proposal in the case the last vote action\n    ///  was done before the required votingBlocksDuration passed\n    /// @param _proposalId The id of the proposal\n    function tryToMoveToValidating(uint256 _proposalId) public {\n        Proposal storage _proposal = proposals[_proposalId];\n        require(_proposal.proposalStatus == ProposalStatus.Voting, \"VOTING_STATUS_REQUIRED\");\n        if (_proposal.currentStatusInitBlock.add(_proposal.votingBlocksDuration) <= block.number) {\n            for (uint256 i = 0; i <= COUNT_CHOICES; i++) {\n                if (_proposal.votes[i] > _proposal.threshold) {\n                    internalMoveToValidating(_proposalId);\n                    return;\n                }\n            }\n        }\n    }\n\n    /// @notice Internal fuction to cancel a vote. This function is called from\n    ///  the external cancel vote functions (by relayers and directly by voters),\n    ///  from challengeVoters() and from internalSubmitVote()\n    /// @param _proposalId The id of the proposal\n    /// @param _voter the voter address, original signer of the transaction\n    function internalCancelVote(uint256 _proposalId, address _voter) internal {\n        Proposal storage _proposal = proposals[_proposalId];\n        Voter storage voter = _proposal.voters[_voter];\n        Voter memory _cachedVoter = voter;\n\n        require(_cachedVoter.balance > 0, \"VOTER_WITHOUT_VOTE\");\n\n        _proposal.votes[_cachedVoter.vote] = _proposal.votes[_cachedVoter.vote].sub(\n            _cachedVoter.balance.mul(\n                _cachedVoter.weight\n            )\n        );\n        _proposal.totalVotes = _proposal.totalVotes.sub(1);\n        voter.weight = 0;\n        voter.balance = 0;\n        voter.vote = 0;\n        voter.asset = IERC20(address(0));\n        voter.nonce = voter.nonce.add(1);\n        emit VoteCancelled(\n            _proposalId,\n            _voter,\n            _cachedVoter.vote,\n            _cachedVoter.asset,\n            _cachedVoter.weight,\n            _cachedVoter.balance,\n            uint256(_proposal.proposalStatus)\n        );\n    }\n\n    /// @notice Called during the Validating period in order to cancel invalid votes\n    ///  where the voter was trying a double-voting attack\n    /// @param _proposalId The id of the proposal\n    /// @param _voters List of voters to challenge\n    function challengeVoters(uint256 _proposalId, address[] calldata _voters) external {\n\n        Proposal storage _proposal = proposals[_proposalId];\n        require(_proposal.proposalStatus == ProposalStatus.Validating, \"VALIDATING_STATUS_REQUIRED\");\n\n        for (uint256 i = 0; i < _voters.length; i++) {\n            address _voterAddress = _voters[i];\n            Voter memory _voter = _proposal.voters[_voterAddress];\n            uint256 _voterAssetBalance = _voter.asset.balanceOf(_voterAddress);\n            if (_voterAssetBalance < _voter.balance) {\n                internalCancelVote(_proposalId, _voterAddress);\n            }\n        }\n\n        if (_proposal.movesToVoting < _proposal.maxMovesToVotingAllowed &&\n            _proposal.votes[getLeadingChoice(_proposalId)] < _proposal.threshold) {\n            internalMoveToVoting(_proposalId);\n        }\n    }\n\n    /// @notice Function to resolve a proposal\n    ///  - It only validates that the state is correct and the validating minimum blocks have passed,\n    ///    as at that point, the % of the leading option doesn't matter\n    ///  - If the resolution is YES, do a DELEGATECALL to the execute() of the proposalExecutor of the proposal\n    ///  - If the resolution is ABSTAIN or NO, just change the state to Executed\n    /// @param _proposalId The id of the proposal\n    function resolveProposal(uint256 _proposalId) external {\n        Proposal storage _proposal = proposals[_proposalId];\n\n        require(_proposal.proposalStatus == ProposalStatus.Validating, \"VALIDATING_STATUS_REQUIRED\");\n        require(_proposal.currentStatusInitBlock.add(_proposal.validatingBlocksDuration) <= block.number, \"NOT_ENOUGH_BLOCKS_IN_VALIDATING\");\n        require(_proposal.initProposalBlock.add(getLimitBlockOfProposal(_proposalId)) >= block.number, \"BLOCK_ABOVE_THE_PROPOSAL_LIMIT\");\n\n        uint256 _leadingChoice = getLeadingChoice(_proposalId);\n\n        if (_leadingChoice == 1) {\n            (bool _success,) = _proposal.proposalExecutor.delegatecall(abi.encodeWithSignature(\"execute()\"));\n            require(_success, \"resolveProposal(). DELEGATECALL_REVERTED\");\n            emit YesWins(_proposalId, _proposal.votes[0], _proposal.votes[1], _proposal.votes[2]);\n        } else if (_leadingChoice == 2) {\n            emit NoWins(_proposalId, _proposal.votes[0], _proposal.votes[1], _proposal.votes[2]);\n        } else {\n            emit AbstainWins(_proposalId, _proposal.votes[0], _proposal.votes[1], _proposal.votes[2]);\n        }\n        internalMoveToExecuted(_proposalId);\n    }\n\n    /// @notice Return the limit block of the proposal from where it will not be possible to resolve it anymore\n    ///  - The double of the sum(voting blocks, validating blocks) multiplied by the maxMovesToVotingAllowed\n    /// @param _proposalId The id of the proposal\n    /// @return uint256 The limit block number\n    function getLimitBlockOfProposal(uint256 _proposalId) public view returns(uint256 _limitBlockProposal) {\n        Proposal memory _proposal = proposals[_proposalId];\n        uint256 _maxMovesToVotingAllowed = _proposal.maxMovesToVotingAllowed;\n        uint256 _votingBlocksDuration = _proposal.votingBlocksDuration;\n        uint256 _validatingBlocksDuration = _proposal.validatingBlocksDuration;\n        _limitBlockProposal = _maxMovesToVotingAllowed.mul(2).mul(\n            _votingBlocksDuration.add(_validatingBlocksDuration)\n        );\n    }\n\n    /// @notice Gets the current leading choice in votes\n    /// @param _proposalId The id of the proposal\n    /// @return uint256 The numeric reference of the choice\n    function getLeadingChoice(uint256 _proposalId) public view returns(uint256) {\n        uint256 _leadingChoice = 0;\n        uint256 _tempCandidate = 0;\n        Proposal storage _proposal = proposals[_proposalId];\n        for (uint256 i = 0; i <= COUNT_CHOICES; i++) {\n            if (_proposal.votes[i] > _tempCandidate) {\n                _leadingChoice = i;\n                _tempCandidate = _proposal.votes[i];\n            }\n        }\n        return _leadingChoice;\n    }\n\n    /// @notice Get the basic data of a proposal\n    /// @param _proposalId The id of the proposal\n    /// @return Proposal The basic data of the proposal\n    function getProposalBasicData(uint256 _proposalId) external view returns(\n        uint256 _totalVotes,\n        uint256 _threshold,\n        uint256 _maxMovesToVotingAllowed,\n        uint256 _movesToVoting,\n        uint256 _votingBlocksDuration,\n        uint256 _validatingBlocksDuration,\n        uint256 _currentStatusInitBlock,\n        uint256 _initProposalBlock,\n        uint256 _proposalStatus,\n        address _proposalExecutor,\n        bytes32 _proposalType\n    ) {\n        require(_proposalId < proposals.length, \"INVALID_PROPOSAL_ID\");\n        Proposal storage _proposal = proposals[_proposalId];\n        _totalVotes = _proposal.totalVotes;\n        _threshold = _proposal.threshold;\n        _maxMovesToVotingAllowed = _proposal.maxMovesToVotingAllowed;\n        _movesToVoting = _proposal.movesToVoting;\n        _votingBlocksDuration = _proposal.votingBlocksDuration;\n        _validatingBlocksDuration = _proposal.validatingBlocksDuration;\n        _currentStatusInitBlock = _proposal.currentStatusInitBlock;\n        _initProposalBlock = _proposal.initProposalBlock;\n        _proposalStatus = uint256(_proposal.proposalStatus);\n        _proposalExecutor = _proposal.proposalExecutor;\n        _proposalType = _proposal.proposalType;\n    }\n\n    /// @notice Get the voting data of a voter on a particular proposal\n    /// @param _proposalId The id of the proposal\n    /// @param _voterAddress _voterAddress The address of the voter\n    /// @return Voter The data of the voter\n    function getVoterData(uint256 _proposalId, address _voterAddress) external view returns(\n        uint256 _vote,\n        uint256 _weight,\n        uint256 _balance,\n        uint256 _nonce,\n        IERC20 _asset\n    ) {\n        require(_proposalId < proposals.length, \"INVALID_PROPOSAL_ID\");\n        Voter storage _voter = proposals[_proposalId].voters[_voterAddress];\n        _vote = _voter.vote;\n        _weight = _voter.weight;\n        _balance = _voter.balance;\n        _nonce = _voter.nonce;\n        _asset = _voter.asset;\n    }\n\n    /// @notice Get the total votes-related data of a proposal\n    /// @param _proposalId The id of the proposal\n    /// @return uint256[3] The array with the accumulated voting power for every choice (ABSTAIN, YES, NO)\n    function getVotesData(uint256 _proposalId) external view returns(uint256[3] memory) {\n        require(_proposalId < proposals.length, \"INVALID_PROPOSAL_ID\");\n        Proposal storage _proposal = proposals[_proposalId];\n        uint256[3] memory _votes = [_proposal.votes[0],_proposal.votes[1],_proposal.votes[2]];\n        return _votes;\n    }\n\n    /// @notice Return the address of the govParamsProvider\n    /// @return address The address of the govParamsProvider\n    function getGovParamsProvider() external view returns(address _govParamsProvider) {\n        return address(govParamsProvider);\n    }\n\n}"
    },
    "@openzeppelin/contracts/cryptography/ECDSA.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * NOTE: This call _does not revert_ if the signature is invalid, or\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\n     * the zero address is returned.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "contracts/interfaces/IGovernanceParamsProvider.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./IAssetVotingWeightProvider.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IGovernanceParamsProvider {\n    function setPropositionPowerThreshold(uint256 _propositionPowerThreshold) external;\n    function setPropositionPower(IERC20 _propositionPower) external;\n    function setAssetVotingWeightProvider(IAssetVotingWeightProvider _assetVotingWeightProvider) external;\n    function getPropositionPower() external view returns(IERC20);\n    function getPropositionPowerThreshold() external view returns(uint256);\n    function getAssetVotingWeightProvider() external view returns(IAssetVotingWeightProvider);\n}"
    },
    "contracts/interfaces/IAssetVotingWeightProvider.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IAssetVotingWeightProvider {\n    function getVotingWeight(IERC20 _asset) external view returns(uint256);\n    function setVotingWeight(IERC20 _asset, uint256 _weight) external;\n}"
    },
    "contracts/interfaces/IProposalExecutor.sol": {
      "content": "pragma solidity ^0.5.16;\n\ninterface IProposalExecutor {\n    function execute() external;\n}"
    },
    "contracts/interfaces/IAaveProtoGovernance.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface IAaveProtoGovernance {\n    function newProposal(\n        bytes32 _proposalType,\n        bytes32 _ipfsHash,\n        uint256 _threshold,\n        address _proposalExecutor,\n        uint256 _votingBlocksDuration,\n        uint256 _validatingBlocksDuration,\n        uint256 _maxMovesToVotingAllowed\n    ) external;\n    function submitVoteByVoter(uint256 _proposalId, uint256 _vote, IERC20 _asset) external;\n    function submitVoteByRelayer(\n        uint256 _proposalId,\n        uint256 _vote,\n        address _voter,\n        IERC20 _asset,\n        uint256 _nonce,\n        bytes calldata _signature,\n        bytes32 _paramsHashByVoter\n    ) external;\n    function cancelVoteByVoter(uint256 _proposalId) external;\n    function cancelVoteByRelayer(\n        uint256 _proposalId,\n        address _voter,\n        uint256 _nonce,\n        bytes calldata _signature,\n        bytes32 _paramsHashByVoter\n    ) external;\n    function tryToMoveToValidating(uint256 _proposalId) external;\n    function challengeVoters(uint256 _proposalId, address[] calldata _voters) external;\n    function resolveProposal(uint256 _proposalId) external;\n\n    function getLimitBlockOfProposal(uint256 _proposalId) external view returns(uint256 _limitBlockProposal);\n    function getLeadingChoice(uint256 _proposalId) external view returns(uint256);\n    function getProposalBasicData(uint256 _proposalId) external view returns(\n        uint256 _totalVotes,\n        uint256 _threshold,\n        uint256 _maxMovesToVotingAllowed,\n        uint256 _movesToVoting,\n        uint256 _votingBlocksDuration,\n        uint256 _validatingBlocksDuration,\n        uint256 _currentStatusInitBlock,\n        uint256 _initProposalBlock,\n        uint256 _proposalStatus,\n        address _proposalExecutor,\n        bytes32 _proposalType\n    );\n    function getVoterData(uint256 _proposalId, address _voterAddress) external view returns(\n        uint256 _vote,\n        uint256 _weight,\n        uint256 _balance,\n        uint256 _nonce,\n        IERC20 _asset\n    );\n    function getVotesData(uint256 _proposalId) external view returns(uint256[3] memory);\n    function getGovParamsProvider() external view returns(address _govParamsProvider);\n\n    function verifyParamsConsistencyAndSignature(\n        bytes32 _paramsHashByRelayer,\n        bytes32 _paramsHashBySigner,\n        bytes calldata _signature,\n        address _signer\n    ) external pure;\n    function verifyNonce(uint256 _proposalId, address _voter, uint256 _relayerNonce) external view;\n    function validateRelayAction(\n        bytes32 _paramsHashByRelayer,\n        bytes32 _paramsHashBySigner,\n        bytes calldata _signature,\n        address _signer,\n        uint256 _proposalId,\n        uint256 _relayerNonce\n    ) external view;\n}"
    },
    "contracts/governance/AssetVotingWeightProvider.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\n\nimport \"../interfaces/IAssetVotingWeightProvider.sol\";\n\n/// @title AssetVotingWeightProvider\n/// @notice Smart contract to register whitelisted assets with its voting weight per asset\n///  - The ownership is on the AaveProtoGovernance, that way the whitelisting of new assets or\n///    the change of the weight of a current one will be done through governance.\ncontract AssetVotingWeightProvider is Ownable, IAssetVotingWeightProvider {\n\n    event AssetWeightSet(IERC20 indexed asset, address indexed setter, uint256 weight);\n\n    mapping(address => uint256) private votingWeights;\n\n    /// @notice Constructor\n    /// @param _assets Dynamic array of asset addresses\n    /// @param _weights Dynamic array of asset weights, for each one of _assets\n    constructor(IERC20[] memory _assets, uint256[] memory _weights) public {\n        require(_assets.length == _weights.length, \"INCONSISTENT_ASSETS_WEIGHTS_LENGTHS\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            internalSetVotingWeight(_assets[i], _weights[i]);\n        }\n    }\n\n    /// @notice Gets the weight of an asset\n    /// @param _asset The asset smart contract address\n    /// @return The uint256 weight of the asset\n    function getVotingWeight(IERC20 _asset) public view returns(uint256) {\n        address asset = address(_asset);\n        return votingWeights[asset];\n    }\n\n    /// @notice Sets the weight for an asset\n    /// @param _asset The asset smart contract address\n    /// @param _weight The asset smart contract address\n    /// @return The uint256 weight of the asset\n    function setVotingWeight(IERC20 _asset, uint256 _weight) external onlyOwner {\n        internalSetVotingWeight(_asset, _weight);\n    }\n\n    /// @notice Internal function to set the weight for an asset\n    /// @param _asset The asset smart contract address\n    /// @return The uint256 weight of the asset\n    function internalSetVotingWeight(IERC20 _asset, uint256 _weight) internal {\n        address asset = address(_asset);\n        votingWeights[asset] = _weight;\n        emit AssetWeightSet(_asset, msg.sender, _weight);\n    }\n\n}"
    },
    "@openzeppelin/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/governance/GovernanceParamsProvider.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"../interfaces/IGovernanceParamsProvider.sol\";\n\ncontract GovernanceParamsProvider is Ownable, IGovernanceParamsProvider {\n\n    event AssetVotingWeightProviderSet(address indexed setter, IAssetVotingWeightProvider  assetVotingWeightProvider);\n    event PropositionPowerThresholdSet(address indexed setter, uint256  propositionPowerThreshold);\n    event PropositionPowerSet(address indexed setter, IERC20 propositionPower);\n\n    /// @notice Address of the smart contract providing the weight of the whitelisted assets\n    IAssetVotingWeightProvider private assetVotingWeightProvider;\n\n    /// @notice Used to get the percentage of the supply of propositionPower needed to register a proposal\n    uint256 private propositionPowerThreshold;\n\n    /// @notice Address of the asset to control who can register new proposals\n    IERC20 private propositionPower;\n\n    constructor(\n        uint256 _propositionPowerThreshold,\n        IERC20 _propositionPower,\n        IAssetVotingWeightProvider _assetVotingWeightProvider\n    ) public {\n        internalSetPropositionPowerThreshold(_propositionPowerThreshold);\n        internalSetPropositionPower(_propositionPower);\n        internalSetAssetVotingWeightProvider(_assetVotingWeightProvider);\n    }\n\n    /// @notice Sets the propositionPowerThreshold\n    /// @param _propositionPowerThreshold The address of the propositionPowerThreshold\n    function setPropositionPowerThreshold(uint256 _propositionPowerThreshold) external onlyOwner {\n        internalSetPropositionPowerThreshold(_propositionPowerThreshold);\n    }\n\n    /// @notice Sets the propositionPower\n    /// @param _propositionPower The address of the propositionPower\n    function setPropositionPower(IERC20 _propositionPower) external onlyOwner {\n        internalSetPropositionPower(_propositionPower);\n    }\n\n    /// @notice Sets the assetVotingWeightProvider\n    /// @param _assetVotingWeightProvider The address of the assetVotingWeightProvider\n    function setAssetVotingWeightProvider(IAssetVotingWeightProvider _assetVotingWeightProvider) external onlyOwner {\n        internalSetAssetVotingWeightProvider(_assetVotingWeightProvider);\n    }\n\n    /// @notice Sets the propositionPowerThreshold\n    /// @param _propositionPowerThreshold The numeric propositionPowerThreshold\n    function internalSetPropositionPowerThreshold(uint256 _propositionPowerThreshold) internal {\n        propositionPowerThreshold = _propositionPowerThreshold;\n        emit PropositionPowerThresholdSet(msg.sender, _propositionPowerThreshold);\n    }\n\n    /// @notice Sets the propositionPower\n    /// @param _propositionPower The address of the propositionPower\n    function internalSetPropositionPower(IERC20 _propositionPower) internal {\n        propositionPower = _propositionPower;\n        emit PropositionPowerSet(msg.sender, _propositionPower);\n    }\n\n    /// @notice Sets the assetVotingWeightProvider\n    /// @param _assetVotingWeightProvider The address of the assetVotingWeightProvider\n    function internalSetAssetVotingWeightProvider(IAssetVotingWeightProvider _assetVotingWeightProvider) internal {\n        assetVotingWeightProvider = _assetVotingWeightProvider;\n        emit AssetVotingWeightProviderSet(msg.sender, _assetVotingWeightProvider);\n    }\n\n    /// @notice Return the address of the propositionPower\n    /// @return The address of the propositionPower\n    function getPropositionPower() external view returns(IERC20) {\n        return propositionPower;\n    }\n\n    /// @notice Returns the propositionPowerThreshold\n    /// @return The propositionPowerThreshold\n    function getPropositionPowerThreshold() external view returns(uint256) {\n        return propositionPowerThreshold;\n    }\n\n    /// @notice Returns the assetVotingWeightProvider address\n    /// @return The address of the assetVotingWeightProvider\n    function getAssetVotingWeightProvider() external view returns(IAssetVotingWeightProvider) {\n        return assetVotingWeightProvider;\n    }\n}"
    },
    "contracts/interfaces/ILendingPoolAddressesProvider.sol": {
      "content": "pragma solidity ^0.5.16;\n\n/**\n@title ILendingPoolAddressesProvider interface\n@notice provides the interface to fetch the LendingPoolCore address\n */\n\ncontract ILendingPoolAddressesProvider {\n\n    function getLendingPool() public view returns (address);\n    function setLendingPoolImpl(address _pool) public;\n\n    function getLendingPoolCore() public view returns (address payable);\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public;\n\n    function getLendingPoolConfigurator() public view returns (address);\n    function setLendingPoolConfiguratorImpl(address _configurator) public;\n\n    function getLendingPoolDataProvider() public view returns (address);\n    function setLendingPoolDataProviderImpl(address _provider) public;\n\n    function getLendingPoolParametersProvider() public view returns (address);\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public;\n\n    function getTokenDistributor() public view returns (address);\n    function setTokenDistributor(address _tokenDistributor) public;\n\n\n    function getFeeProvider() public view returns (address);\n    function setFeeProviderImpl(address _feeProvider) public;\n\n    function getLendingPoolLiquidationManager() public view returns (address);\n    function setLendingPoolLiquidationManager(address _manager) public;\n\n    function getLendingPoolManager() public view returns (address);\n    function setLendingPoolManager(address _lendingPoolManager) public;\n\n    function getPriceOracle() public view returns (address);\n    function setPriceOracle(address _priceOracle) public;\n\n    function getLendingRateOracle() public view returns (address);\n    function setLendingRateOracle(address _lendingRateOracle) public;\n\n}"
    },
    "contracts/libraries/openzeppelin-upgradeability/AdminUpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./BaseAdminUpgradeabilityProxy.sol\";\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \n * initializing the implementation, admin, and init data.\n */\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\n    /**\n   * Contract constructor.\n   * @param _logic address of the initial implementation.\n   * @param _admin Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n    constructor(address _logic, address _admin, bytes memory _data) public payable UpgradeabilityProxy(_logic, _data) {\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(_admin);\n    }\n}\n"
    },
    "contracts/libraries/openzeppelin-upgradeability/BaseAdminUpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./UpgradeabilityProxy.sol\";\n\n/**\n * @title BaseAdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n    /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n   * @return The address of the proxy admin.\n   */\n    function admin() external ifAdmin returns (address) {\n        return _admin();\n    }\n\n    /**\n   * @return The address of the implementation.\n   */\n    function implementation() external ifAdmin returns (address) {\n        return _implementation();\n    }\n\n    /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n    function changeAdmin(address newAdmin) external ifAdmin {\n        require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeTo(newImplementation);\n        (bool success, ) = newImplementation.delegatecall(data);\n        require(success);\n    }\n\n    /**\n   * @return The admin slot.\n   */\n    function _admin() internal view returns (address adm) {\n        bytes32 slot = ADMIN_SLOT;\n        //solium-disable-next-line\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n    function _setAdmin(address newAdmin) internal {\n        bytes32 slot = ADMIN_SLOT;\n        //solium-disable-next-line\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n    function _willFallback() internal {\n        require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n        super._willFallback();\n    }\n}\n"
    },
    "contracts/libraries/openzeppelin-upgradeability/UpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./BaseUpgradeabilityProxy.sol\";\n\n/**\n * @title UpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\n * implementation and init data.\n */\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n    /**\n   * @dev Contract constructor.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n    constructor(address _logic, bytes memory _data) public payable {\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n    }\n}\n"
    },
    "contracts/libraries/openzeppelin-upgradeability/BaseUpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./Proxy.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title BaseUpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract BaseUpgradeabilityProxy is Proxy {\n    /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n    event Upgraded(address indexed implementation);\n\n    /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n   * @dev Returns the current implementation.\n   * @return Address of the current implementation\n   */\n    function _implementation() internal view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        //solium-disable-next-line\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n    function _setImplementation(address newImplementation) internal {\n        require(\n            Address.isContract(newImplementation),\n            \"Cannot set a proxy implementation to a non-contract address\"\n        );\n\n        bytes32 slot = IMPLEMENTATION_SLOT;\n\n        //solium-disable-next-line\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "contracts/libraries/openzeppelin-upgradeability/Proxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\ncontract Proxy {\n    /**\n   * @dev Fallback function.\n   * Implemented entirely in `_fallback`.\n   */\n    function() external payable {\n        _fallback();\n    }\n\n    /**\n   * @return The Address of the implementation.\n   */\n    function _implementation() internal view returns (address);\n\n    /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n    function _delegate(address implementation) internal {\n        //solium-disable-next-line\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize)\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize)\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize)\n                }\n                default {\n                    return(0, returndatasize)\n                }\n        }\n    }\n\n    /**\n   * @dev Function that is run as the first thing in the fallback function.\n   * Can be redefined in derived contracts to add functionality.\n   * Redefinitions must call super._willFallback().\n   */\n    function _willFallback() internal {}\n\n    /**\n   * @dev fallback implementation.\n   * Extracted to enable manual triggering.\n   */\n    function _fallback() internal {\n        _willFallback();\n        _delegate(_implementation());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "contracts/libraries/openzeppelin-upgradeability/Initializable.sol": {
      "content": "pragma solidity >=0.4.24 <0.6.0;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n    /**\n   * @dev Indicates that the contract has been initialized.\n   */\n    bool private initialized;\n\n    /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n    bool private initializing;\n\n    /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n    modifier initializer() {\n        require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        uint256 cs;\n        //solium-disable-next-line\n        assembly {\n            cs := extcodesize(address)\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/libraries/openzeppelin-upgradeability/InitializableAdminUpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./BaseAdminUpgradeabilityProxy.sol\";\nimport \"./InitializableUpgradeabilityProxy.sol\";\n\n/**\n * @title InitializableAdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for \n * initializing the implementation, admin, and init data.\n */\ncontract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {\n    /**\n   * Contract initializer.\n   * @param _logic address of the initial implementation.\n   * @param _admin Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n    function initialize(address _logic, address _admin, bytes memory _data) public payable {\n        require(_implementation() == address(0));\n        InitializableUpgradeabilityProxy.initialize(_logic, _data);\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(_admin);\n    }\n}\n"
    },
    "contracts/libraries/openzeppelin-upgradeability/InitializableUpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./BaseUpgradeabilityProxy.sol\";\n\n/**\n * @title InitializableUpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\n * implementation and init data.\n */\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\n    /**\n   * @dev Contract initializer.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n    function initialize(address _logic, bytes memory _data) public payable {\n        require(_implementation() == address(0));\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n    }\n}\n"
    },
    "contracts/libraries/openzeppelin-upgradeability/VersionedInitializable.sol": {
      "content": "pragma solidity >=0.4.24 <0.6.0;\n\n/**\n * @title VersionedInitializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n *\n * @author Aave, inspired by the OpenZeppelin Initializable contract\n */\ncontract VersionedInitializable {\n    /**\n   * @dev Indicates that the contract has been initialized.\n   */\n    uint256 private lastInitializedRevision = 0;\n\n    /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n    bool private initializing;\n\n    /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n    modifier initializer() {\n        uint256 revision = getRevision();\n        require(initializing || isConstructor() || revision > lastInitializedRevision, \"Contract instance has already been initialized\");\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            lastInitializedRevision = revision;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /// @dev returns the revision number of the contract.\n    /// Needs to be defined in the inherited class as a constant.\n    function getRevision() internal pure returns(uint256);\n\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        uint256 cs;\n        //solium-disable-next-line\n        assembly {\n            cs := extcodesize(address)\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/mocks/AddressStorage.sol": {
      "content": "pragma solidity ^0.5.16;\n\ncontract AddressStorage {\n    mapping(bytes32 => address) private addresses;\n\n    function getAddress(bytes32 _key) public view returns (address) {\n        return addresses[_key];\n    }\n\n    function _setAddress(bytes32 _key, address _value) internal {\n        addresses[_key] = _value;\n    }\n\n}\n"
    },
    "contracts/mocks/FailingProposalExecutor.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"../interfaces/IProposalExecutor.sol\";\n\ncontract FailingProposalExecutor is IProposalExecutor {\n\n    /// @notice Fallback function, not allowing transfer of ETH\n    function() external payable {\n        revert(\"ETH_TRANSFER_NOT_ALLOWED\");\n    }\n\n    function execute() external {\n        require(false, \"FORCED_REVERT\");\n    }\n\n}"
    },
    "contracts/mocks/LendingPoolAddressesProvider.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"../libraries/openzeppelin-upgradeability/InitializableAdminUpgradeabilityProxy.sol\";\n\nimport \"./AddressStorage.sol\";\nimport \"../interfaces/ILendingPoolAddressesProvider.sol\";\n\n/**\n* @title LendingPoolAddressesProvider contract\n* @notice Is the main registry of the protocol. All the different components of the protocol are accessible\n* through the addresses provider.\n* @author Aave\n**/\n\ncontract LendingPoolAddressesProvider is Ownable, ILendingPoolAddressesProvider, AddressStorage {\n    //events\n    event LendingPoolUpdated(address indexed newAddress);\n    event LendingPoolCoreUpdated(address indexed newAddress);\n    event LendingPoolParametersProviderUpdated(address indexed newAddress);\n    event LendingPoolManagerUpdated(address indexed newAddress);\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\n    event LendingPoolLiquidationManagerUpdated(address indexed newAddress);\n    event LendingPoolDataProviderUpdated(address indexed newAddress);\n    event EthereumAddressUpdated(address indexed newAddress);\n    event PriceOracleUpdated(address indexed newAddress);\n    event LendingRateOracleUpdated(address indexed newAddress);\n    event FeeProviderUpdated(address indexed newAddress);\n    event TokenDistributorUpdated(address indexed newAddress);\n\n    event ProxyCreated(bytes32 id, address indexed newAddress);\n\n    bytes32 private constant LENDING_POOL = \"LENDING_POOL\";\n    bytes32 private constant LENDING_POOL_CORE = \"LENDING_POOL_CORE\";\n    bytes32 private constant LENDING_POOL_CONFIGURATOR = \"LENDING_POOL_CONFIGURATOR\";\n    bytes32 private constant LENDING_POOL_PARAMETERS_PROVIDER = \"PARAMETERS_PROVIDER\";\n    bytes32 private constant LENDING_POOL_MANAGER = \"LENDING_POOL_MANAGER\";\n    bytes32 private constant LENDING_POOL_LIQUIDATION_MANAGER = \"LIQUIDATION_MANAGER\";\n    bytes32 private constant LENDING_POOL_FLASHLOAN_PROVIDER = \"FLASHLOAN_PROVIDER\";\n    bytes32 private constant DATA_PROVIDER = \"DATA_PROVIDER\";\n    bytes32 private constant ETHEREUM_ADDRESS = \"ETHEREUM_ADDRESS\";\n    bytes32 private constant PRICE_ORACLE = \"PRICE_ORACLE\";\n    bytes32 private constant LENDING_RATE_ORACLE = \"LENDING_RATE_ORACLE\";\n    bytes32 private constant FEE_PROVIDER = \"FEE_PROVIDER\";\n    bytes32 private constant WALLET_BALANCE_PROVIDER = \"WALLET_BALANCE_PROVIDER\";\n    bytes32 private constant TOKEN_DISTRIBUTOR = \"TOKEN_DISTRIBUTOR\";\n\n\n    /**\n    * @dev returns the address of the LendingPool proxy\n    * @return the lending pool proxy address\n    **/\n    function getLendingPool() public view returns (address) {\n        return getAddress(LENDING_POOL);\n    }\n\n\n    /**\n    * @dev updates the implementation of the lending pool\n    * @param _pool the new lending pool implementation\n    **/\n    function setLendingPoolImpl(address _pool) public onlyOwner {\n        updateImplInternal(LENDING_POOL, _pool);\n        emit LendingPoolUpdated(_pool);\n    }\n\n    /**\n    * @dev returns the address of the LendingPoolCore proxy\n    * @return the lending pool core proxy address\n     */\n    function getLendingPoolCore() public view returns (address payable) {\n        address payable core = address(uint160(getAddress(LENDING_POOL_CORE)));\n        return core;\n    }\n\n    /**\n    * @dev updates the implementation of the lending pool core\n    * @param _lendingPoolCore the new lending pool core implementation\n    **/\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public onlyOwner {\n        updateImplInternal(LENDING_POOL_CORE, _lendingPoolCore);\n        emit LendingPoolCoreUpdated(_lendingPoolCore);\n    }\n\n    /**\n    * @dev returns the address of the LendingPoolConfigurator proxy\n    * @return the lending pool configurator proxy address\n    **/\n    function getLendingPoolConfigurator() public view returns (address) {\n        return getAddress(LENDING_POOL_CONFIGURATOR);\n    }\n\n    /**\n    * @dev updates the implementation of the lending pool configurator\n    * @param _configurator the new lending pool configurator implementation\n    **/\n    function setLendingPoolConfiguratorImpl(address _configurator) public onlyOwner {\n        updateImplInternal(LENDING_POOL_CONFIGURATOR, _configurator);\n        emit LendingPoolConfiguratorUpdated(_configurator);\n    }\n\n    /**\n    * @dev returns the address of the LendingPoolDataProvider proxy\n    * @return the lending pool data provider proxy address\n     */\n    function getLendingPoolDataProvider() public view returns (address) {\n        return getAddress(DATA_PROVIDER);\n    }\n\n    /**\n    * @dev updates the implementation of the lending pool data provider\n    * @param _provider the new lending pool data provider implementation\n    **/\n    function setLendingPoolDataProviderImpl(address _provider) public onlyOwner {\n        updateImplInternal(DATA_PROVIDER, _provider);\n        emit LendingPoolDataProviderUpdated(_provider);\n    }\n\n    /**\n    * @dev returns the address of the LendingPoolParametersProvider proxy\n    * @return the address of the Lending pool parameters provider proxy\n    **/\n    function getLendingPoolParametersProvider() public view returns (address) {\n        return getAddress(LENDING_POOL_PARAMETERS_PROVIDER);\n    }\n\n    /**\n    * @dev updates the implementation of the lending pool parameters provider\n    * @param _parametersProvider the new lending pool parameters provider implementation\n    **/\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public onlyOwner {\n        updateImplInternal(LENDING_POOL_PARAMETERS_PROVIDER, _parametersProvider);\n        emit LendingPoolParametersProviderUpdated(_parametersProvider);\n    }\n\n    /**\n    * @dev returns the address of the FeeProvider proxy\n    * @return the address of the Fee provider proxy\n    **/\n    function getFeeProvider() public view returns (address) {\n        return getAddress(FEE_PROVIDER);\n    }\n\n    /**\n    * @dev updates the implementation of the FeeProvider proxy\n    * @param _feeProvider the new lending pool fee provider implementation\n    **/\n    function setFeeProviderImpl(address _feeProvider) public {\n        updateImplInternal(FEE_PROVIDER, _feeProvider);\n        emit FeeProviderUpdated(_feeProvider);\n    }\n\n    /**\n    * @dev returns the address of the LendingPoolLiquidationManager. Since the manager is used\n    * through delegateCall within the LendingPool contract, the proxy contract pattern does not work properly hence\n    * the addresses are changed directly.\n    * @return the address of the Lending pool liquidation manager\n    **/\n\n    function getLendingPoolLiquidationManager() public view returns (address) {\n        return getAddress(LENDING_POOL_LIQUIDATION_MANAGER);\n    }\n\n    /**\n    * @dev updates the address of the Lending pool liquidation manager\n    * @param _manager the new lending pool liquidation manager address\n    **/\n    function setLendingPoolLiquidationManager(address _manager) public onlyOwner {\n        _setAddress(LENDING_POOL_LIQUIDATION_MANAGER, _manager);\n        emit LendingPoolLiquidationManagerUpdated(_manager);\n    }\n\n    /**\n    * @dev the functions below are storing specific addresses that are outside the context of the protocol\n    * hence the upgradable proxy pattern is not used\n    **/\n\n\n    function getLendingPoolManager() public view returns (address) {\n        return getAddress(LENDING_POOL_MANAGER);\n    }\n\n    function setLendingPoolManager(address _lendingPoolManager) public {\n        _setAddress(LENDING_POOL_MANAGER, _lendingPoolManager);\n        emit LendingPoolManagerUpdated(_lendingPoolManager);\n    }\n\n    function getPriceOracle() public view returns (address) {\n        return getAddress(PRICE_ORACLE);\n    }\n\n    function setPriceOracle(address _priceOracle) public onlyOwner {\n        _setAddress(PRICE_ORACLE, _priceOracle);\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    function getLendingRateOracle() public view returns (address) {\n        return getAddress(LENDING_RATE_ORACLE);\n    }\n\n    function setLendingRateOracle(address _lendingRateOracle) public onlyOwner {\n        _setAddress(LENDING_RATE_ORACLE, _lendingRateOracle);\n        emit LendingRateOracleUpdated(_lendingRateOracle);\n    }\n\n\n    function getTokenDistributor() public view returns (address) {\n        return getAddress(TOKEN_DISTRIBUTOR);\n    }\n\n    function setTokenDistributor(address _tokenDistributor) public onlyOwner {\n        _setAddress(TOKEN_DISTRIBUTOR, _tokenDistributor);\n        emit TokenDistributorUpdated(_tokenDistributor);\n    }\n\n\n    /**\n    * @dev internal function to update the implementation of a specific component of the protocol\n    * @param _id the id of the contract to be updated\n    * @param _newAddress the address of the new implementation\n    **/\n    function updateImplInternal(bytes32 _id, address _newAddress) internal {\n        address payable proxyAddress = address(uint160(getAddress(_id)));\n\n        InitializableAdminUpgradeabilityProxy proxy = InitializableAdminUpgradeabilityProxy(proxyAddress);\n        bytes memory params = abi.encodeWithSignature(\"initialize(address)\", address(this));\n\n        if (proxyAddress == address(0)) {\n            proxy = new InitializableAdminUpgradeabilityProxy();\n            proxy.initialize(_newAddress, address(this), params);\n            _setAddress(_id, address(proxy));\n            emit ProxyCreated(_id, address(proxy));\n        } else {\n            proxy.upgradeToAndCall(_newAddress, params);\n        }\n\n    }\n}\n"
    },
    "contracts/mocks/ProposalExecutor.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"../interfaces/IProposalExecutor.sol\";\nimport \"./LendingPoolAddressesProvider.sol\";\n\ncontract ProposalExecutor is IProposalExecutor {\n\n    event ProposalExecuted(\n        address indexed executor,\n        address indexed lendingPoolAddressesProvider,\n        address indexed newAddress\n    );\n\n    /// @notice Fallback function, not allowing transfer of ETH\n    function() external payable {\n        revert(\"ETH_TRANSFER_NOT_ALLOWED\");\n    }\n\n    function execute() external {\n        // Hardcoded address because of the determinism on buidlerevm\n        address _addressesProvider = 0x7c2C195CD6D34B8F845992d380aADB2730bB9C6F;\n        address _newLendingPoolManager = 0x0000000000000000000000000000000000000001;\n        LendingPoolAddressesProvider(_addressesProvider).setLendingPoolManager(_newLendingPoolManager);\n        emit ProposalExecuted(address(this), _addressesProvider, _newLendingPoolManager);\n    }\n\n}"
    },
    "contracts/mocks/TestVotingAssetA.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Mintable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\n\n/// @title TestVotingAssetA\n/// @author Aave\n/// @notice An ERC20 mintable and burnable token to use as whitelisted\n///  voting asset on proposals\ncontract TestVotingAssetA is ERC20Burnable, ERC20Mintable, ERC20Detailed {\n\n    /// @notice Constructor\n    /// @param name Asset name\n    /// @param symbol Asset symbol\n    /// @param decimals Asset decimals\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    )\n    public ERC20Detailed(name, symbol, decimals) {}\n}"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\ncontract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev See {ERC20-_burnFrom}.\n     */\n    function burnFrom(address account, uint256 amount) public {\n        _burnFrom(account, amount);\n    }\n}\n"
    },
    "contracts/mocks/TestVotingAssetB.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Mintable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\n\n/// @title TestVotingAssetB\n/// @author Aave\n/// @notice An ERC20 mintable and burnable token to use as whitelisted\n///  voting asset on proposals\ncontract TestVotingAssetB is ERC20Burnable, ERC20Mintable, ERC20Detailed {\n\n    /// @notice Constructor\n    /// @param name Asset name\n    /// @param symbol Asset symbol\n    /// @param decimals Asset decimals\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    )\n    public ERC20Detailed(name, symbol, decimals) {}\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "istanbul",
    "libraries": {}
  }
}}