{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "berlin",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "src/Delegator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./interfaces/IGovernanceToken.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\n\n/**\n * @title Delegator Contract\n * @author Cryptex.Finance\n * @notice Contract in charge of handling delegations.\n */\n\ncontract Delegator is Ownable {\n   /* ========== STATE VARIABLES ========== */\n\n   /// @notice Address of the staking governance token\n   address public immutable token;\n\n   /// @notice Tracks the amount of staked tokens per user\n   mapping(address => uint256) public stakerBalance;\n\n   /* ========== CONSTRUCTOR ========== */\n\n   /**\n    * @notice Constructor\n    * @param delegatee_ address\n    * @param token_ address\n    * @dev when created delegates all it's power to delegatee_ and can't be changed later\n    * @dev sets delegator factory as owner\n    */\n   constructor(address delegatee_, address token_) {\n      require(\n         delegatee_ != address(0) && token_ != address(0),\n         \"Address can't be 0\"\n      );\n      require(IGovernanceToken(token_).decimals() == 18, \"Decimals must be 18\");\n      token = token_;\n      IGovernanceToken(token_).delegate(delegatee_);\n   }\n\n   /* ========== MUTATIVE FUNCTIONS ========== */\n\n   /**\n    * @notice Increases the balance of the staker\n    * @param staker_ caller of the stake function\n    * @param amount_ uint to be staked and delegated\n    * @dev Only delegatorFactory can call it\n    * @dev after the balance is updated the amount is transferred from the user to this contract\n    */\n   function stake(address staker_, uint256 amount_) external onlyOwner {\n      stakerBalance[staker_] += amount_;\n   }\n\n   /**\n    * @notice Decreases the balance of the staker\n    * @param staker_ caller of the stake function\n    * @param amount_ uint to be withdrawn and undelegated\n    * @dev Only delegatorFactory can call it\n    * @dev after the balance is updated the amount is transferred back to the user from this contract\n    */\n   function removeStake(address staker_, uint256 amount_) external onlyOwner {\n      stakerBalance[staker_] -= amount_;\n      require(\n         IGovernanceToken(token).transfer(staker_, amount_),\n         \"Transfer failed\"\n      );\n   }\n\n   /* ========== VIEWS ========== */\n\n   /// @notice returns the delegatee of this contract\n   function delegatee() external returns (address) {\n      return IGovernanceToken(token).delegates(address(this));\n   }\n}\n"
    },
    "src/DelegatorFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./interfaces/IGovernanceToken.sol\";\nimport \"./Delegator.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\n/**\n * @title Delegator Contract Factory\n * @author Cryptex.Finance\n * @notice Contract in charge of generating Delegator contracts, handling delegations and CTX balance map, rewards.\n */\n\ncontract DelegatorFactory is Ownable, ReentrancyGuard {\n   /* ========== STATE VARIABLES ========== */\n\n   /// @notice Address of the staking governance token\n   address public immutable stakingToken;\n\n   /// @notice Address of the reward token\n   address public immutable rewardsToken;\n\n   /// @notice Minimum wait time before removing stake\n   uint256 public waitTime;\n\n   /// @notice Tracks the period where users stop earning rewards\n   uint256 public periodFinish = 0;\n   uint256 public rewardRate = 0;\n\n   /// @notice How long the rewards lasts, it updates when more rewards are added\n   uint256 public rewardsDuration = 186 days;\n\n   /// @notice Last time rewards were updated\n   uint256 public lastUpdateTime;\n\n   /// @notice Amount of reward calculated per token stored\n   uint256 public rewardPerTokenStored;\n\n   /// @notice Track the rewards paid to users\n   mapping(address => uint256) public userRewardPerTokenPaid;\n\n   /// @notice Tracks the user rewards\n   mapping(address => uint256) public rewards;\n\n   /// @notice Tracks the address of a delegatee with a delegator contract address\n   mapping(address => address) public delegatorToDelegatee;\n\n   /// @notice Tracks the delegator contract address from delegatee address\n   mapping(address => address) public delegateeToDelegator;\n\n   /// @notice Tracks if address is an official delegator\n   mapping(address => bool) public delegators;\n\n   /// @notice Tracks minimum wait time the account has to wait before removing stake\n   mapping(address => mapping(address => uint256)) public stakerWaitTime;\n\n   /// @dev Tracks the total supply of staked tokens\n   uint256 private _totalSupply;\n\n   /// @dev Tracks the amount of staked tokens per user\n   mapping(address => uint256) private _balances;\n\n   /* ========== EVENTS ========== */\n\n   /// @notice An event emitted when a Delegator is created\n   event DelegatorCreated(address indexed delegator, address indexed delegatee);\n\n   /// @notice An event emitted when an user has staked and delegated\n   event Staked(\n      address indexed delegator,\n      address indexed delegatee,\n      uint256 amount\n   );\n\n   /// @notice An event emitted when an user removes stake and undelegated\n   event Withdrawn(\n      address indexed delegator,\n      address indexed delegatee,\n      uint256 amount\n   );\n\n   /// @notice An event emitted when the minimum wait time is updated\n   event WaitTimeUpdated(uint256 waitTime);\n\n   /// @notice An event emitted when a reward is added\n   event RewardAdded(uint256 reward);\n\n   /// @notice An event emitted when reward is paid to a user\n   event RewardPaid(address indexed user, uint256 reward);\n\n   /// @notice An event emitted when the rewards duration is updated\n   event RewardsDurationUpdated(uint256 newDuration);\n\n   /* ========== CONSTRUCTOR ========== */\n\n   /**\n    * @notice Constructor\n    * @param stakingToken_ address\n    * @param rewardsToken_ address\n    * @param waitTime_ uint256\n    * @param timelock_ address\n    * @dev transfers ownership to timelock\n    */\n   constructor(\n      address stakingToken_,\n      address rewardsToken_,\n      uint256 waitTime_,\n      address timelock_\n   ) {\n      require(\n         stakingToken_ != address(0) &&\n            rewardsToken_ != address(0) &&\n            timelock_ != address(0),\n         \"Address can't be 0\"\n      );\n      require(\n         IGovernanceToken(stakingToken_).decimals() == 18 &&\n            IGovernanceToken(rewardsToken_).decimals() == 18,\n         \"Decimals must be 18\"\n      );\n      stakingToken = stakingToken_;\n      rewardsToken = rewardsToken_;\n      waitTime = waitTime_;\n      transferOwnership(timelock_);\n   }\n\n   /* ========== MUTATIVE FUNCTIONS ========== */\n\n   /**\n    * @notice Updates the reward and time on call.\n    * @param account_ address\n    */\n   function updateReward(address account_) private {\n      rewardPerTokenStored = rewardPerToken();\n      lastUpdateTime = lastTimeRewardApplicable();\n\n      if (account_ != address(0)) {\n         rewards[account_] = currentEarned(account_);\n         userRewardPerTokenPaid[account_] = rewardPerTokenStored;\n      }\n   }\n\n   /**\n    * @notice Notifies the contract that reward has been added to be given.\n    * @param reward_ uint\n    * @dev Only owner  can call it\n    * @dev Increases duration of rewards\n    */\n   function notifyRewardAmount(uint256 reward_) external onlyOwner {\n      updateReward(address(0));\n      if (block.timestamp >= periodFinish) {\n         rewardRate = reward_ / rewardsDuration;\n      } else {\n         uint256 remaining = periodFinish - block.timestamp;\n         uint256 leftover = remaining * rewardRate;\n         rewardRate = (reward_ + leftover) / rewardsDuration;\n      }\n\n      lastUpdateTime = block.timestamp;\n      periodFinish = block.timestamp + rewardsDuration;\n\n      // Ensure the provided reward amount is not more than the balance in the contract.\n      // This keeps the reward rate in the right range, preventing overflows due to\n      // very high values of rewardRate in the earned and rewardsPerToken functions;\n      // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n      uint256 balance = IGovernanceToken(rewardsToken).balanceOf(address(this));\n      require(\n         rewardRate <= balance / rewardsDuration,\n         \"Provided reward too high\"\n      );\n      emit RewardAdded(reward_);\n   }\n\n   /**\n    * @notice  Updates the reward duration\n    * @param rewardsDuration_ uint\n    * @dev Only owner can call it\n    * @dev Previous rewards must be complete\n    */\n   function setRewardsDuration(uint256 rewardsDuration_) external onlyOwner {\n      require(\n         block.timestamp > periodFinish,\n         \"Previous rewards period must be complete before changing the duration for the new period\"\n      );\n      rewardsDuration = rewardsDuration_;\n      emit RewardsDurationUpdated(rewardsDuration);\n   }\n\n   /**\n    * @notice Transfers to the caller the current amount of rewards tokens earned.\n    * @dev updates rewards on call\n    */\n   function getReward() external nonReentrant {\n      updateReward(msg.sender);\n      uint256 reward = rewards[msg.sender];\n      if (reward > 0) {\n         rewards[msg.sender] = 0;\n         require(\n            IGovernanceToken(rewardsToken).transfer(msg.sender, reward),\n            \"Transfer Failed\"\n         );\n         emit RewardPaid(msg.sender, reward);\n      }\n   }\n\n   /**\n    * @notice Creates a new delegator contract that delegates all votes to delegatee_\n    * @param delegatee_ address that will be receiving all votes\n    * @dev only one delegator contract pointing to the same delegatee can exist\n    */\n   function createDelegator(address delegatee_) external {\n      require(delegatee_ != address(0), \"Delegatee can't be 0\");\n      require(\n         delegateeToDelegator[delegatee_] == address(0),\n         \"Delegator already created\"\n      );\n      Delegator delegator = new Delegator(delegatee_, stakingToken);\n      delegateeToDelegator[delegatee_] = address(delegator);\n      delegatorToDelegatee[address(delegator)] = delegatee_;\n      delegators[address(delegator)] = true;\n      emit DelegatorCreated(address(delegator), delegatee_);\n   }\n\n   /**\n    * @notice Stakes to delegator_ the amount_ specified\n    * @param delegator_ contract address where to send the amount_\n    * @param amount_ uint to be staked and delegated\n    * @dev Delegator must be valid and amount has to be greater than 0\n    * @dev amount_ is transferred to the delegator contract and staker starts earning rewards if active\n    * @dev updates rewards on call\n    */\n   function stake(address delegator_, uint256 amount_) external nonReentrant {\n      require(delegators[delegator_], \"Not a valid delegator\");\n      require(amount_ > 0, \"Amount must be greater than 0\");\n      updateReward(msg.sender);\n      _totalSupply = _totalSupply + amount_;\n      _balances[msg.sender] = _balances[msg.sender] + amount_;\n      Delegator d = Delegator(delegator_);\n      d.stake(msg.sender, amount_);\n      stakerWaitTime[msg.sender][delegator_] = block.timestamp + waitTime;\n      require(\n         IGovernanceToken(stakingToken).transferFrom(\n            msg.sender,\n            delegator_,\n            amount_\n         ),\n         \"Transfer Failed\"\n      );\n      emit Staked(delegator_, msg.sender, amount_);\n   }\n\n   /**\n    * @notice Removes amount_ from delegator_\n    * @param delegator_ contract address where to remove the stake from\n    * @param amount_ uint to be removed from stake and undelegated\n    * @dev Delegator must be valid and amount has to be greater than 0\n    * @dev amount_ must be <= that current user stake\n    * @dev amount_ is transferred from the  delegator contract to the staker\n    * @dev updates rewards on call\n    * @dev requires that at least waitTime has passed since delegation to unDelegate\n    */\n   function withdraw(address delegator_, uint256 amount_)\n      external\n      nonReentrant\n   {\n      require(delegators[delegator_], \"Not a valid delegator\");\n      require(amount_ > 0, \"Amount must be greater than 0\");\n      require(\n         block.timestamp >= stakerWaitTime[msg.sender][delegator_],\n         \"Need to wait the minimum staking period\"\n      );\n      updateReward(msg.sender);\n      _totalSupply = _totalSupply - amount_;\n      _balances[msg.sender] = _balances[msg.sender] - amount_;\n      Delegator d = Delegator(delegator_);\n      d.removeStake(msg.sender, amount_);\n      emit Withdrawn(delegator_, msg.sender, amount_);\n   }\n\n   /**\n    * @notice updates the min wait time between delegation and unDelegation\n    * @param waitTime_ uint new wait time\n    * @dev only the owner can call it\n    */\n   function updateWaitTime(uint256 waitTime_) external onlyOwner {\n      waitTime = waitTime_;\n      emit WaitTimeUpdated(waitTime_);\n   }\n\n   /* ========== VIEWS ========== */\n\n   /**\n    * @notice Returns the amount of reward tokens a user has earned.\n    * @param account_ address\n    */\n   function currentEarned(address account_) private view returns (uint256) {\n      return\n         (_balances[account_] *\n            (rewardPerTokenStored - userRewardPerTokenPaid[account_])) /\n         1e18 +\n         rewards[account_];\n   }\n\n   /// @notice Returns the total amount of staked tokens.\n   function totalSupply() external view returns (uint256) {\n      return _totalSupply;\n   }\n\n   /**\n    * @notice Returns the amount of staked tokens from specific user\n    * @param account_ address\n    */\n   function balanceOf(address account_) external view returns (uint256) {\n      return _balances[account_];\n   }\n\n   /// @notice Returns reward rate for a duration\n   function getRewardForDuration() external view returns (uint256) {\n      return rewardRate * rewardsDuration;\n   }\n\n   /// @notice Returns the minimum between current block timestamp or the finish period of rewards.\n   function lastTimeRewardApplicable() public view returns (uint256) {\n      return min(block.timestamp, periodFinish);\n   }\n\n   /// @notice Returns the calculated reward per token deposited.\n   function rewardPerToken() public view returns (uint256) {\n      if (_totalSupply == 0) {\n         return rewardPerTokenStored;\n      }\n\n      return\n         rewardPerTokenStored +\n         ((lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18) /\n         _totalSupply;\n   }\n\n   /**\n    * @notice Returns the amount of reward tokens a user has earned.\n    * @param account_ address\n    */\n   function earned(address account_) public view returns (uint256) {\n      return\n         (_balances[account_] *\n            (rewardPerToken() - userRewardPerTokenPaid[account_])) /\n         1e18 +\n         rewards[account_];\n   }\n\n   /**\n    * @notice Returns the minimum between two variables\n    * @param a_ uint\n    * @param b_ uint\n    */\n   function min(uint256 a_, uint256 b_) public pure returns (uint256) {\n      return a_ < b_ ? a_ : b_;\n   }\n}\n"
    },
    "src/interfaces/IGovernanceToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface IGovernanceToken {\n   function delegate(address delegatee) external;\n\n   function delegates(address delegator) external returns (address);\n\n   function transfer(address dst, uint256 rawAmount) external returns (bool);\n\n   function transferFrom(\n      address src,\n      address dst,\n      uint256 rawAmount\n   ) external returns (bool);\n\n   function balanceOf(address src) external returns (uint256);\n\n   function decimals() external returns (uint8);\n}\n"
    }
  }
}}