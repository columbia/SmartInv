{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "details": {
        "constantOptimizer": true,
        "cse": true,
        "deduplicate": true,
        "jumpdestRemover": true,
        "orderLiterals": true,
        "peephole": true,
        "yul": false
      },
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/persistent/dispatcher/IDispatcher.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IDispatcher Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IDispatcher {\n    function cancelMigration(address _vaultProxy, bool _bypassFailure) external;\n\n    function claimOwnership() external;\n\n    function deployVaultProxy(\n        address _vaultLib,\n        address _owner,\n        address _vaultAccessor,\n        string calldata _fundName\n    ) external returns (address vaultProxy_);\n\n    function executeMigration(address _vaultProxy, bool _bypassFailure) external;\n\n    function getCurrentFundDeployer() external view returns (address currentFundDeployer_);\n\n    function getFundDeployerForVaultProxy(address _vaultProxy)\n        external\n        view\n        returns (address fundDeployer_);\n\n    function getMigrationRequestDetailsForVaultProxy(address _vaultProxy)\n        external\n        view\n        returns (\n            address nextFundDeployer_,\n            address nextVaultAccessor_,\n            address nextVaultLib_,\n            uint256 executableTimestamp_\n        );\n\n    function getMigrationTimelock() external view returns (uint256 migrationTimelock_);\n\n    function getNominatedOwner() external view returns (address nominatedOwner_);\n\n    function getOwner() external view returns (address owner_);\n\n    function getSharesTokenSymbol() external view returns (string memory sharesTokenSymbol_);\n\n    function getTimelockRemainingForMigrationRequest(address _vaultProxy)\n        external\n        view\n        returns (uint256 secondsRemaining_);\n\n    function hasExecutableMigrationRequest(address _vaultProxy)\n        external\n        view\n        returns (bool hasExecutableRequest_);\n\n    function hasMigrationRequest(address _vaultProxy)\n        external\n        view\n        returns (bool hasMigrationRequest_);\n\n    function removeNominatedOwner() external;\n\n    function setCurrentFundDeployer(address _nextFundDeployer) external;\n\n    function setMigrationTimelock(uint256 _nextTimelock) external;\n\n    function setNominatedOwner(address _nextNominatedOwner) external;\n\n    function setSharesTokenSymbol(string calldata _nextSymbol) external;\n\n    function signalMigration(\n        address _vaultProxy,\n        address _nextVaultAccessor,\n        address _nextVaultLib,\n        bool _bypassFailure\n    ) external;\n}\n"
    },
    "contracts/persistent/utils/IMigratableVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IMigratableVault Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @dev DO NOT EDIT CONTRACT\ninterface IMigratableVault {\n    function canMigrate(address _who) external view returns (bool canMigrate_);\n\n    function init(\n        address _owner,\n        address _accessor,\n        string calldata _fundName\n    ) external;\n\n    function setAccessor(address _nextAccessor) external;\n\n    function setVaultLib(address _nextVaultLib) external;\n}\n"
    },
    "contracts/release/core/fund-deployer/IFundDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IFundDeployer Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IFundDeployer {\n    enum ReleaseStatus {PreLaunch, Live, Paused}\n\n    function getOwner() external view returns (address);\n\n    function getReleaseStatus() external view returns (ReleaseStatus);\n\n    function isRegisteredVaultCall(address, bytes4) external view returns (bool);\n}\n"
    },
    "contracts/release/core/fund/comptroller/ComptrollerLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../../../persistent/dispatcher/IDispatcher.sol\";\nimport \"../../../extensions/IExtension.sol\";\nimport \"../../../extensions/fee-manager/IFeeManager.sol\";\nimport \"../../../extensions/policy-manager/IPolicyManager.sol\";\nimport \"../../../infrastructure/price-feeds/primitives/IPrimitivePriceFeed.sol\";\nimport \"../../../infrastructure/value-interpreter/IValueInterpreter.sol\";\nimport \"../../../utils/AddressArrayLib.sol\";\nimport \"../../../utils/AssetFinalityResolver.sol\";\nimport \"../../fund-deployer/IFundDeployer.sol\";\nimport \"../vault/IVault.sol\";\nimport \"./IComptroller.sol\";\n\n/// @title ComptrollerLib Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice The core logic library shared by all funds\ncontract ComptrollerLib is IComptroller, AssetFinalityResolver {\n    using AddressArrayLib for address[];\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    event MigratedSharesDuePaid(uint256 sharesDue);\n\n    event OverridePauseSet(bool indexed overridePause);\n\n    event PreRedeemSharesHookFailed(\n        bytes failureReturnData,\n        address redeemer,\n        uint256 sharesQuantity\n    );\n\n    event SharesBought(\n        address indexed caller,\n        address indexed buyer,\n        uint256 investmentAmount,\n        uint256 sharesIssued,\n        uint256 sharesReceived\n    );\n\n    event SharesRedeemed(\n        address indexed redeemer,\n        uint256 sharesQuantity,\n        address[] receivedAssets,\n        uint256[] receivedAssetQuantities\n    );\n\n    event VaultProxySet(address vaultProxy);\n\n    // Constants and immutables - shared by all proxies\n    uint256 private constant SHARES_UNIT = 10**18;\n    address private immutable DISPATCHER;\n    address private immutable FUND_DEPLOYER;\n    address private immutable FEE_MANAGER;\n    address private immutable INTEGRATION_MANAGER;\n    address private immutable PRIMITIVE_PRICE_FEED;\n    address private immutable POLICY_MANAGER;\n    address private immutable VALUE_INTERPRETER;\n\n    // Pseudo-constants (can only be set once)\n\n    address internal denominationAsset;\n    address internal vaultProxy;\n    // True only for the one non-proxy\n    bool internal isLib;\n\n    // Storage\n\n    // Allows a fund owner to override a release-level pause\n    bool internal overridePause;\n    // A reverse-mutex, granting atomic permission for particular contracts to make vault calls\n    bool internal permissionedVaultActionAllowed;\n    // A mutex to protect against reentrancy\n    bool internal reentranceLocked;\n    // A timelock between any \"shares actions\" (i.e., buy and redeem shares), per-account\n    uint256 internal sharesActionTimelock;\n    mapping(address => uint256) internal acctToLastSharesAction;\n\n    ///////////////\n    // MODIFIERS //\n    ///////////////\n\n    modifier allowsPermissionedVaultAction {\n        __assertPermissionedVaultActionNotAllowed();\n        permissionedVaultActionAllowed = true;\n        _;\n        permissionedVaultActionAllowed = false;\n    }\n\n    modifier locksReentrance() {\n        __assertNotReentranceLocked();\n        reentranceLocked = true;\n        _;\n        reentranceLocked = false;\n    }\n\n    modifier onlyActive() {\n        __assertIsActive(vaultProxy);\n        _;\n    }\n\n    modifier onlyNotPaused() {\n        __assertNotPaused();\n        _;\n    }\n\n    modifier onlyFundDeployer() {\n        __assertIsFundDeployer(msg.sender);\n        _;\n    }\n\n    modifier onlyOwner() {\n        __assertIsOwner(msg.sender);\n        _;\n    }\n\n    modifier timelockedSharesAction(address _account) {\n        __assertSharesActionNotTimelocked(_account);\n        _;\n        acctToLastSharesAction[_account] = block.timestamp;\n    }\n\n    // ASSERTION HELPERS\n\n    // Modifiers are inefficient in terms of contract size,\n    // so we use helper functions to prevent repetitive inlining of expensive string values.\n\n    /// @dev Since vaultProxy is set during activate(),\n    /// we can check that var rather than storing additional state\n    function __assertIsActive(address _vaultProxy) private pure {\n        require(_vaultProxy != address(0), \"Fund not active\");\n    }\n\n    function __assertIsFundDeployer(address _who) private view {\n        require(_who == FUND_DEPLOYER, \"Only FundDeployer callable\");\n    }\n\n    function __assertIsOwner(address _who) private view {\n        require(_who == IVault(vaultProxy).getOwner(), \"Only fund owner callable\");\n    }\n\n    function __assertLowLevelCall(bool _success, bytes memory _returnData) private pure {\n        require(_success, string(_returnData));\n    }\n\n    function __assertNotPaused() private view {\n        require(!__fundIsPaused(), \"Fund is paused\");\n    }\n\n    function __assertNotReentranceLocked() private view {\n        require(!reentranceLocked, \"Re-entrance\");\n    }\n\n    function __assertPermissionedVaultActionNotAllowed() private view {\n        require(!permissionedVaultActionAllowed, \"Vault action re-entrance\");\n    }\n\n    function __assertSharesActionNotTimelocked(address _account) private view {\n        require(\n            block.timestamp.sub(acctToLastSharesAction[_account]) >= sharesActionTimelock,\n            \"Shares action timelocked\"\n        );\n    }\n\n    constructor(\n        address _dispatcher,\n        address _fundDeployer,\n        address _valueInterpreter,\n        address _feeManager,\n        address _integrationManager,\n        address _policyManager,\n        address _primitivePriceFeed,\n        address _synthetixPriceFeed,\n        address _synthetixAddressResolver\n    ) public AssetFinalityResolver(_synthetixPriceFeed, _synthetixAddressResolver) {\n        DISPATCHER = _dispatcher;\n        FEE_MANAGER = _feeManager;\n        FUND_DEPLOYER = _fundDeployer;\n        INTEGRATION_MANAGER = _integrationManager;\n        PRIMITIVE_PRICE_FEED = _primitivePriceFeed;\n        POLICY_MANAGER = _policyManager;\n        VALUE_INTERPRETER = _valueInterpreter;\n        isLib = true;\n    }\n\n    /////////////\n    // GENERAL //\n    /////////////\n\n    /// @notice Calls a specified action on an Extension\n    /// @param _extension The Extension contract to call (e.g., FeeManager)\n    /// @param _actionId An ID representing the action to take on the extension (see extension)\n    /// @param _callArgs The encoded data for the call\n    /// @dev Used to route arbitrary calls, so that msg.sender is the ComptrollerProxy\n    /// (for access control). Uses a mutex of sorts that allows \"permissioned vault actions\"\n    /// during calls originating from this function.\n    function callOnExtension(\n        address _extension,\n        uint256 _actionId,\n        bytes calldata _callArgs\n    ) external override onlyNotPaused onlyActive locksReentrance allowsPermissionedVaultAction {\n        require(\n            _extension == FEE_MANAGER || _extension == INTEGRATION_MANAGER,\n            \"callOnExtension: _extension invalid\"\n        );\n\n        IExtension(_extension).receiveCallFromComptroller(msg.sender, _actionId, _callArgs);\n    }\n\n    /// @notice Sets or unsets an override on a release-wide pause\n    /// @param _nextOverridePause True if the pause should be overrode\n    function setOverridePause(bool _nextOverridePause) external onlyOwner {\n        require(_nextOverridePause != overridePause, \"setOverridePause: Value already set\");\n\n        overridePause = _nextOverridePause;\n\n        emit OverridePauseSet(_nextOverridePause);\n    }\n\n    /// @notice Makes an arbitrary call with the VaultProxy contract as the sender\n    /// @param _contract The contract to call\n    /// @param _selector The selector to call\n    /// @param _encodedArgs The encoded arguments for the call\n    function vaultCallOnContract(\n        address _contract,\n        bytes4 _selector,\n        bytes calldata _encodedArgs\n    ) external onlyNotPaused onlyActive onlyOwner {\n        require(\n            IFundDeployer(FUND_DEPLOYER).isRegisteredVaultCall(_contract, _selector),\n            \"vaultCallOnContract: Unregistered\"\n        );\n\n        IVault(vaultProxy).callOnContract(_contract, abi.encodePacked(_selector, _encodedArgs));\n    }\n\n    /// @dev Helper to check whether the release is paused, and that there is no local override\n    function __fundIsPaused() private view returns (bool) {\n        return\n            IFundDeployer(FUND_DEPLOYER).getReleaseStatus() ==\n            IFundDeployer.ReleaseStatus.Paused &&\n            !overridePause;\n    }\n\n    ////////////////////////////////\n    // PERMISSIONED VAULT ACTIONS //\n    ////////////////////////////////\n\n    /// @notice Makes a permissioned, state-changing call on the VaultProxy contract\n    /// @param _action The enum representing the VaultAction to perform on the VaultProxy\n    /// @param _actionData The call data for the action to perform\n    function permissionedVaultAction(VaultAction _action, bytes calldata _actionData)\n        external\n        override\n        onlyNotPaused\n        onlyActive\n    {\n        __assertPermissionedVaultAction(msg.sender, _action);\n\n        if (_action == VaultAction.AddTrackedAsset) {\n            __vaultActionAddTrackedAsset(_actionData);\n        } else if (_action == VaultAction.ApproveAssetSpender) {\n            __vaultActionApproveAssetSpender(_actionData);\n        } else if (_action == VaultAction.BurnShares) {\n            __vaultActionBurnShares(_actionData);\n        } else if (_action == VaultAction.MintShares) {\n            __vaultActionMintShares(_actionData);\n        } else if (_action == VaultAction.RemoveTrackedAsset) {\n            __vaultActionRemoveTrackedAsset(_actionData);\n        } else if (_action == VaultAction.TransferShares) {\n            __vaultActionTransferShares(_actionData);\n        } else if (_action == VaultAction.WithdrawAssetTo) {\n            __vaultActionWithdrawAssetTo(_actionData);\n        }\n    }\n\n    /// @dev Helper to assert that a caller is allowed to perform a particular VaultAction\n    function __assertPermissionedVaultAction(address _caller, VaultAction _action) private view {\n        require(\n            permissionedVaultActionAllowed,\n            \"__assertPermissionedVaultAction: No action allowed\"\n        );\n\n        if (_caller == INTEGRATION_MANAGER) {\n            require(\n                _action == VaultAction.ApproveAssetSpender ||\n                    _action == VaultAction.AddTrackedAsset ||\n                    _action == VaultAction.RemoveTrackedAsset ||\n                    _action == VaultAction.WithdrawAssetTo,\n                \"__assertPermissionedVaultAction: Not valid for IntegrationManager\"\n            );\n        } else if (_caller == FEE_MANAGER) {\n            require(\n                _action == VaultAction.BurnShares ||\n                    _action == VaultAction.MintShares ||\n                    _action == VaultAction.TransferShares,\n                \"__assertPermissionedVaultAction: Not valid for FeeManager\"\n            );\n        } else {\n            revert(\"__assertPermissionedVaultAction: Not a valid actor\");\n        }\n    }\n\n    /// @dev Helper to add a tracked asset to the fund\n    function __vaultActionAddTrackedAsset(bytes memory _actionData) private {\n        address asset = abi.decode(_actionData, (address));\n        IVault(vaultProxy).addTrackedAsset(asset);\n    }\n\n    /// @dev Helper to grant a spender an allowance for a fund's asset\n    function __vaultActionApproveAssetSpender(bytes memory _actionData) private {\n        (address asset, address target, uint256 amount) = abi.decode(\n            _actionData,\n            (address, address, uint256)\n        );\n        IVault(vaultProxy).approveAssetSpender(asset, target, amount);\n    }\n\n    /// @dev Helper to burn fund shares for a particular account\n    function __vaultActionBurnShares(bytes memory _actionData) private {\n        (address target, uint256 amount) = abi.decode(_actionData, (address, uint256));\n        IVault(vaultProxy).burnShares(target, amount);\n    }\n\n    /// @dev Helper to mint fund shares to a particular account\n    function __vaultActionMintShares(bytes memory _actionData) private {\n        (address target, uint256 amount) = abi.decode(_actionData, (address, uint256));\n        IVault(vaultProxy).mintShares(target, amount);\n    }\n\n    /// @dev Helper to remove a tracked asset from the fund\n    function __vaultActionRemoveTrackedAsset(bytes memory _actionData) private {\n        address asset = abi.decode(_actionData, (address));\n\n        // Allowing this to fail silently makes it cheaper and simpler\n        // for Extensions to not query for the denomination asset\n        if (asset != denominationAsset) {\n            IVault(vaultProxy).removeTrackedAsset(asset);\n        }\n    }\n\n    /// @dev Helper to transfer fund shares from one account to another\n    function __vaultActionTransferShares(bytes memory _actionData) private {\n        (address from, address to, uint256 amount) = abi.decode(\n            _actionData,\n            (address, address, uint256)\n        );\n        IVault(vaultProxy).transferShares(from, to, amount);\n    }\n\n    /// @dev Helper to withdraw an asset from the VaultProxy to a given account\n    function __vaultActionWithdrawAssetTo(bytes memory _actionData) private {\n        (address asset, address target, uint256 amount) = abi.decode(\n            _actionData,\n            (address, address, uint256)\n        );\n        IVault(vaultProxy).withdrawAssetTo(asset, target, amount);\n    }\n\n    ///////////////\n    // LIFECYCLE //\n    ///////////////\n\n    /// @notice Initializes a fund with its core config\n    /// @param _denominationAsset The asset in which the fund's value should be denominated\n    /// @param _sharesActionTimelock The minimum number of seconds between any two \"shares actions\"\n    /// (buying or selling shares) by the same user\n    /// @dev Pseudo-constructor per proxy.\n    /// No need to assert access because this is called atomically on deployment,\n    /// and once it's called, it cannot be called again.\n    function init(address _denominationAsset, uint256 _sharesActionTimelock) external override {\n        require(denominationAsset == address(0), \"init: Already initialized\");\n        require(\n            IPrimitivePriceFeed(PRIMITIVE_PRICE_FEED).isSupportedAsset(_denominationAsset),\n            \"init: Bad denomination asset\"\n        );\n\n        denominationAsset = _denominationAsset;\n        sharesActionTimelock = _sharesActionTimelock;\n    }\n\n    /// @notice Configure the extensions of a fund\n    /// @param _feeManagerConfigData Encoded config for fees to enable\n    /// @param _policyManagerConfigData Encoded config for policies to enable\n    /// @dev No need to assert anything beyond FundDeployer access.\n    /// Called atomically with init(), but after ComptrollerLib has been deployed,\n    /// giving access to its state and interface\n    function configureExtensions(\n        bytes calldata _feeManagerConfigData,\n        bytes calldata _policyManagerConfigData\n    ) external override onlyFundDeployer {\n        if (_feeManagerConfigData.length > 0) {\n            IExtension(FEE_MANAGER).setConfigForFund(_feeManagerConfigData);\n        }\n        if (_policyManagerConfigData.length > 0) {\n            IExtension(POLICY_MANAGER).setConfigForFund(_policyManagerConfigData);\n        }\n    }\n\n    /// @notice Activates the fund by attaching a VaultProxy and activating all Extensions\n    /// @param _vaultProxy The VaultProxy to attach to the fund\n    /// @param _isMigration True if a migrated fund is being activated\n    /// @dev No need to assert anything beyond FundDeployer access.\n    function activate(address _vaultProxy, bool _isMigration) external override onlyFundDeployer {\n        vaultProxy = _vaultProxy;\n\n        emit VaultProxySet(_vaultProxy);\n\n        if (_isMigration) {\n            // Distribute any shares in the VaultProxy to the fund owner.\n            // This is a mechanism to ensure that even in the edge case of a fund being unable\n            // to payout fee shares owed during migration, these shares are not lost.\n            uint256 sharesDue = ERC20(_vaultProxy).balanceOf(_vaultProxy);\n            if (sharesDue > 0) {\n                IVault(_vaultProxy).transferShares(\n                    _vaultProxy,\n                    IVault(_vaultProxy).getOwner(),\n                    sharesDue\n                );\n\n                emit MigratedSharesDuePaid(sharesDue);\n            }\n        }\n\n        // Note: a future release could consider forcing the adding of a tracked asset here,\n        // just in case a fund is migrating from an old configuration where they are not able\n        // to remove an asset to get under the tracked assets limit\n        IVault(_vaultProxy).addTrackedAsset(denominationAsset);\n\n        // Activate extensions\n        IExtension(FEE_MANAGER).activateForFund(_isMigration);\n        IExtension(INTEGRATION_MANAGER).activateForFund(_isMigration);\n        IExtension(POLICY_MANAGER).activateForFund(_isMigration);\n    }\n\n    /// @notice Remove the config for a fund\n    /// @dev No need to assert anything beyond FundDeployer access.\n    /// Calling onlyNotPaused here rather than in the FundDeployer allows\n    /// the owner to potentially override the pause and rescue unpaid fees.\n    function destruct()\n        external\n        override\n        onlyFundDeployer\n        onlyNotPaused\n        allowsPermissionedVaultAction\n    {\n        // Failsafe to protect the libs against selfdestruct\n        require(!isLib, \"destruct: Only delegate callable\");\n\n        // Deactivate the extensions\n        IExtension(FEE_MANAGER).deactivateForFund();\n        IExtension(INTEGRATION_MANAGER).deactivateForFund();\n        IExtension(POLICY_MANAGER).deactivateForFund();\n\n        // Delete storage of ComptrollerProxy\n        // There should never be ETH in the ComptrollerLib, so no need to waste gas\n        // to get the fund owner\n        selfdestruct(address(0));\n    }\n\n    ////////////////\n    // ACCOUNTING //\n    ////////////////\n\n    /// @notice Calculates the gross asset value (GAV) of the fund\n    /// @param _requireFinality True if all assets must have exact final balances settled\n    /// @return gav_ The fund GAV\n    /// @return isValid_ True if the conversion rates used to derive the GAV are all valid\n    function calcGav(bool _requireFinality) public override returns (uint256 gav_, bool isValid_) {\n        address vaultProxyAddress = vaultProxy;\n        address[] memory assets = IVault(vaultProxyAddress).getTrackedAssets();\n        if (assets.length == 0) {\n            return (0, true);\n        }\n\n        uint256[] memory balances = new uint256[](assets.length);\n        for (uint256 i; i < assets.length; i++) {\n            balances[i] = __finalizeIfSynthAndGetAssetBalance(\n                vaultProxyAddress,\n                assets[i],\n                _requireFinality\n            );\n        }\n\n        (gav_, isValid_) = IValueInterpreter(VALUE_INTERPRETER).calcCanonicalAssetsTotalValue(\n            assets,\n            balances,\n            denominationAsset\n        );\n\n        return (gav_, isValid_);\n    }\n\n    /// @notice Calculates the gross value of 1 unit of shares in the fund's denomination asset\n    /// @param _requireFinality True if all assets must have exact final balances settled\n    /// @return grossShareValue_ The amount of the denomination asset per share\n    /// @return isValid_ True if the conversion rates to derive the value are all valid\n    /// @dev Does not account for any fees outstanding.\n    function calcGrossShareValue(bool _requireFinality)\n        external\n        override\n        returns (uint256 grossShareValue_, bool isValid_)\n    {\n        uint256 gav;\n        (gav, isValid_) = calcGav(_requireFinality);\n\n        grossShareValue_ = __calcGrossShareValue(\n            gav,\n            ERC20(vaultProxy).totalSupply(),\n            10**uint256(ERC20(denominationAsset).decimals())\n        );\n\n        return (grossShareValue_, isValid_);\n    }\n\n    /// @dev Helper for calculating the gross share value\n    function __calcGrossShareValue(\n        uint256 _gav,\n        uint256 _sharesSupply,\n        uint256 _denominationAssetUnit\n    ) private pure returns (uint256 grossShareValue_) {\n        if (_sharesSupply == 0) {\n            return _denominationAssetUnit;\n        }\n\n        return _gav.mul(SHARES_UNIT).div(_sharesSupply);\n    }\n\n    ///////////////////\n    // PARTICIPATION //\n    ///////////////////\n\n    // BUY SHARES\n\n    /// @notice Buys shares in the fund for multiple sets of criteria\n    /// @param _buyers The accounts for which to buy shares\n    /// @param _investmentAmounts The amounts of the fund's denomination asset\n    /// with which to buy shares for the corresponding _buyers\n    /// @param _minSharesQuantities The minimum quantities of shares to buy\n    /// with the corresponding _investmentAmounts\n    /// @return sharesReceivedAmounts_ The actual amounts of shares received\n    /// by the corresponding _buyers\n    /// @dev Param arrays have indexes corresponding to individual __buyShares() orders.\n    function buyShares(\n        address[] calldata _buyers,\n        uint256[] calldata _investmentAmounts,\n        uint256[] calldata _minSharesQuantities\n    )\n        external\n        onlyNotPaused\n        locksReentrance\n        allowsPermissionedVaultAction\n        returns (uint256[] memory sharesReceivedAmounts_)\n    {\n        require(_buyers.length > 0, \"buyShares: Empty _buyers\");\n        require(\n            _buyers.length == _investmentAmounts.length &&\n                _buyers.length == _minSharesQuantities.length,\n            \"buyShares: Unequal arrays\"\n        );\n\n        address vaultProxyCopy = vaultProxy;\n        __assertIsActive(vaultProxyCopy);\n        require(\n            !IDispatcher(DISPATCHER).hasMigrationRequest(vaultProxyCopy),\n            \"buyShares: Pending migration\"\n        );\n\n        (uint256 gav, bool gavIsValid) = calcGav(true);\n        require(gavIsValid, \"buyShares: Invalid GAV\");\n\n        __buySharesSetupHook(msg.sender, _investmentAmounts, gav);\n\n        address denominationAssetCopy = denominationAsset;\n        uint256 sharePrice = __calcGrossShareValue(\n            gav,\n            ERC20(vaultProxyCopy).totalSupply(),\n            10**uint256(ERC20(denominationAssetCopy).decimals())\n        );\n\n        sharesReceivedAmounts_ = new uint256[](_buyers.length);\n        for (uint256 i; i < _buyers.length; i++) {\n            sharesReceivedAmounts_[i] = __buyShares(\n                _buyers[i],\n                _investmentAmounts[i],\n                _minSharesQuantities[i],\n                vaultProxyCopy,\n                sharePrice,\n                gav,\n                denominationAssetCopy\n            );\n\n            gav = gav.add(_investmentAmounts[i]);\n        }\n\n        __buySharesCompletedHook(msg.sender, sharesReceivedAmounts_, gav);\n\n        return sharesReceivedAmounts_;\n    }\n\n    /// @dev Helper to buy shares\n    function __buyShares(\n        address _buyer,\n        uint256 _investmentAmount,\n        uint256 _minSharesQuantity,\n        address _vaultProxy,\n        uint256 _sharePrice,\n        uint256 _preBuySharesGav,\n        address _denominationAsset\n    ) private timelockedSharesAction(_buyer) returns (uint256 sharesReceived_) {\n        require(_investmentAmount > 0, \"__buyShares: Empty _investmentAmount\");\n\n        // Gives Extensions a chance to run logic prior to the minting of bought shares\n        __preBuySharesHook(_buyer, _investmentAmount, _minSharesQuantity, _preBuySharesGav);\n\n        // Calculate the amount of shares to issue with the investment amount\n        uint256 sharesIssued = _investmentAmount.mul(SHARES_UNIT).div(_sharePrice);\n\n        // Mint shares to the buyer\n        uint256 prevBuyerShares = ERC20(_vaultProxy).balanceOf(_buyer);\n        IVault(_vaultProxy).mintShares(_buyer, sharesIssued);\n\n        // Transfer the investment asset to the fund.\n        // Does not follow the checks-effects-interactions pattern, but it is preferred\n        // to have the final state of the VaultProxy prior to running __postBuySharesHook().\n        ERC20(_denominationAsset).safeTransferFrom(msg.sender, _vaultProxy, _investmentAmount);\n\n        // Gives Extensions a chance to run logic after shares are issued\n        __postBuySharesHook(_buyer, _investmentAmount, sharesIssued, _preBuySharesGav);\n\n        // The number of actual shares received may differ from shares issued due to\n        // how the PostBuyShares hooks are invoked by Extensions (i.e., fees)\n        sharesReceived_ = ERC20(_vaultProxy).balanceOf(_buyer).sub(prevBuyerShares);\n        require(\n            sharesReceived_ >= _minSharesQuantity,\n            \"__buyShares: Shares received < _minSharesQuantity\"\n        );\n\n        emit SharesBought(msg.sender, _buyer, _investmentAmount, sharesIssued, sharesReceived_);\n\n        return sharesReceived_;\n    }\n\n    /// @dev Helper for Extension actions after all __buyShares() calls are made\n    function __buySharesCompletedHook(\n        address _caller,\n        uint256[] memory _sharesReceivedAmounts,\n        uint256 _gav\n    ) private {\n        IPolicyManager(POLICY_MANAGER).validatePolicies(\n            address(this),\n            IPolicyManager.PolicyHook.BuySharesCompleted,\n            abi.encode(_caller, _sharesReceivedAmounts, _gav)\n        );\n\n        IFeeManager(FEE_MANAGER).invokeHook(\n            IFeeManager.FeeHook.BuySharesCompleted,\n            abi.encode(_caller, _sharesReceivedAmounts),\n            _gav\n        );\n    }\n\n    /// @dev Helper for Extension actions before any __buyShares() calls are made\n    function __buySharesSetupHook(\n        address _caller,\n        uint256[] memory _investmentAmounts,\n        uint256 _gav\n    ) private {\n        IPolicyManager(POLICY_MANAGER).validatePolicies(\n            address(this),\n            IPolicyManager.PolicyHook.BuySharesSetup,\n            abi.encode(_caller, _investmentAmounts, _gav)\n        );\n\n        IFeeManager(FEE_MANAGER).invokeHook(\n            IFeeManager.FeeHook.BuySharesSetup,\n            abi.encode(_caller, _investmentAmounts),\n            _gav\n        );\n    }\n\n    /// @dev Helper for Extension actions immediately prior to issuing shares.\n    /// This could be cleaned up so both Extensions take the same encoded args and handle GAV\n    /// in the same way, but there is not the obvious need for gas savings of recycling\n    /// the GAV value for the current policies as there is for the fees.\n    function __preBuySharesHook(\n        address _buyer,\n        uint256 _investmentAmount,\n        uint256 _minSharesQuantity,\n        uint256 _gav\n    ) private {\n        IFeeManager(FEE_MANAGER).invokeHook(\n            IFeeManager.FeeHook.PreBuyShares,\n            abi.encode(_buyer, _investmentAmount, _minSharesQuantity),\n            _gav\n        );\n\n        IPolicyManager(POLICY_MANAGER).validatePolicies(\n            address(this),\n            IPolicyManager.PolicyHook.PreBuyShares,\n            abi.encode(_buyer, _investmentAmount, _minSharesQuantity, _gav)\n        );\n    }\n\n    /// @dev Helper for Extension actions immediately after issuing shares.\n    /// Same comment applies from __preBuySharesHook() above.\n    function __postBuySharesHook(\n        address _buyer,\n        uint256 _investmentAmount,\n        uint256 _sharesIssued,\n        uint256 _preBuySharesGav\n    ) private {\n        uint256 gav = _preBuySharesGav.add(_investmentAmount);\n        IFeeManager(FEE_MANAGER).invokeHook(\n            IFeeManager.FeeHook.PostBuyShares,\n            abi.encode(_buyer, _investmentAmount, _sharesIssued),\n            gav\n        );\n\n        IPolicyManager(POLICY_MANAGER).validatePolicies(\n            address(this),\n            IPolicyManager.PolicyHook.PostBuyShares,\n            abi.encode(_buyer, _investmentAmount, _sharesIssued, gav)\n        );\n    }\n\n    // REDEEM SHARES\n\n    /// @notice Redeem all of the sender's shares for a proportionate slice of the fund's assets\n    /// @return payoutAssets_ The assets paid out to the redeemer\n    /// @return payoutAmounts_ The amount of each asset paid out to the redeemer\n    /// @dev See __redeemShares() for further detail\n    function redeemShares()\n        external\n        returns (address[] memory payoutAssets_, uint256[] memory payoutAmounts_)\n    {\n        return\n            __redeemShares(\n                msg.sender,\n                ERC20(vaultProxy).balanceOf(msg.sender),\n                new address[](0),\n                new address[](0)\n            );\n    }\n\n    /// @notice Redeem a specified quantity of the sender's shares for a proportionate slice of\n    /// the fund's assets, optionally specifying additional assets and assets to skip.\n    /// @param _sharesQuantity The quantity of shares to redeem\n    /// @param _additionalAssets Additional (non-tracked) assets to claim\n    /// @param _assetsToSkip Tracked assets to forfeit\n    /// @return payoutAssets_ The assets paid out to the redeemer\n    /// @return payoutAmounts_ The amount of each asset paid out to the redeemer\n    /// @dev Any claim to passed _assetsToSkip will be forfeited entirely. This should generally\n    /// only be exercised if a bad asset is causing redemption to fail.\n    function redeemSharesDetailed(\n        uint256 _sharesQuantity,\n        address[] calldata _additionalAssets,\n        address[] calldata _assetsToSkip\n    ) external returns (address[] memory payoutAssets_, uint256[] memory payoutAmounts_) {\n        return __redeemShares(msg.sender, _sharesQuantity, _additionalAssets, _assetsToSkip);\n    }\n\n    /// @dev Helper to parse an array of payout assets during redemption, taking into account\n    /// additional assets and assets to skip. _assetsToSkip ignores _additionalAssets.\n    /// All input arrays are assumed to be unique.\n    function __parseRedemptionPayoutAssets(\n        address[] memory _trackedAssets,\n        address[] memory _additionalAssets,\n        address[] memory _assetsToSkip\n    ) private pure returns (address[] memory payoutAssets_) {\n        address[] memory trackedAssetsToPayout = _trackedAssets.removeItems(_assetsToSkip);\n        if (_additionalAssets.length == 0) {\n            return trackedAssetsToPayout;\n        }\n\n        // Add additional assets. Duplicates of trackedAssets are ignored.\n        bool[] memory indexesToAdd = new bool[](_additionalAssets.length);\n        uint256 additionalItemsCount;\n        for (uint256 i; i < _additionalAssets.length; i++) {\n            if (!trackedAssetsToPayout.contains(_additionalAssets[i])) {\n                indexesToAdd[i] = true;\n                additionalItemsCount++;\n            }\n        }\n        if (additionalItemsCount == 0) {\n            return trackedAssetsToPayout;\n        }\n\n        payoutAssets_ = new address[](trackedAssetsToPayout.length.add(additionalItemsCount));\n        for (uint256 i; i < trackedAssetsToPayout.length; i++) {\n            payoutAssets_[i] = trackedAssetsToPayout[i];\n        }\n        uint256 payoutAssetsIndex = trackedAssetsToPayout.length;\n        for (uint256 i; i < _additionalAssets.length; i++) {\n            if (indexesToAdd[i]) {\n                payoutAssets_[payoutAssetsIndex] = _additionalAssets[i];\n                payoutAssetsIndex++;\n            }\n        }\n\n        return payoutAssets_;\n    }\n\n    /// @dev Helper for system actions immediately prior to redeeming shares.\n    /// Policy validation is not currently allowed on redemption, to ensure continuous redeemability.\n    function __preRedeemSharesHook(address _redeemer, uint256 _sharesQuantity)\n        private\n        allowsPermissionedVaultAction\n    {\n        try\n            IFeeManager(FEE_MANAGER).invokeHook(\n                IFeeManager.FeeHook.PreRedeemShares,\n                abi.encode(_redeemer, _sharesQuantity),\n                0\n            )\n         {} catch (bytes memory reason) {\n            emit PreRedeemSharesHookFailed(reason, _redeemer, _sharesQuantity);\n        }\n    }\n\n    /// @dev Helper to redeem shares.\n    /// This function should never fail without a way to bypass the failure, which is assured\n    /// through two mechanisms:\n    /// 1. The FeeManager is called with the try/catch pattern to assure that calls to it\n    /// can never block redemption.\n    /// 2. If a token fails upon transfer(), that token can be skipped (and its balance forfeited)\n    /// by explicitly specifying _assetsToSkip.\n    /// Because of these assurances, shares should always be redeemable, with the exception\n    /// of the timelock period on shares actions that must be respected.\n    function __redeemShares(\n        address _redeemer,\n        uint256 _sharesQuantity,\n        address[] memory _additionalAssets,\n        address[] memory _assetsToSkip\n    )\n        private\n        locksReentrance\n        returns (address[] memory payoutAssets_, uint256[] memory payoutAmounts_)\n    {\n        require(_sharesQuantity > 0, \"__redeemShares: _sharesQuantity must be >0\");\n        require(\n            _additionalAssets.isUniqueSet(),\n            \"__redeemShares: _additionalAssets contains duplicates\"\n        );\n        require(_assetsToSkip.isUniqueSet(), \"__redeemShares: _assetsToSkip contains duplicates\");\n\n        IVault vaultProxyContract = IVault(vaultProxy);\n\n        // Only apply the sharesActionTimelock when a migration is not pending\n        if (!IDispatcher(DISPATCHER).hasMigrationRequest(address(vaultProxyContract))) {\n            __assertSharesActionNotTimelocked(_redeemer);\n            acctToLastSharesAction[_redeemer] = block.timestamp;\n        }\n\n        // When a fund is paused, settling fees will be skipped\n        if (!__fundIsPaused()) {\n            // Note that if a fee with `SettlementType.Direct` is charged here (i.e., not `Mint`),\n            // then those fee shares will be transferred from the user's balance rather\n            // than reallocated from the sharesQuantity being redeemed.\n            __preRedeemSharesHook(_redeemer, _sharesQuantity);\n        }\n\n        // Check the shares quantity against the user's balance after settling fees\n        ERC20 sharesContract = ERC20(address(vaultProxyContract));\n        require(\n            _sharesQuantity <= sharesContract.balanceOf(_redeemer),\n            \"__redeemShares: Insufficient shares\"\n        );\n\n        // Parse the payout assets given optional params to add or skip assets.\n        // Note that there is no validation that the _additionalAssets are known assets to\n        // the protocol. This means that the redeemer could specify a malicious asset,\n        // but since all state-changing, user-callable functions on this contract share the\n        // non-reentrant modifier, there is nowhere to perform a reentrancy attack.\n        payoutAssets_ = __parseRedemptionPayoutAssets(\n            vaultProxyContract.getTrackedAssets(),\n            _additionalAssets,\n            _assetsToSkip\n        );\n        require(payoutAssets_.length > 0, \"__redeemShares: No payout assets\");\n\n        // Destroy the shares.\n        // Must get the shares supply before doing so.\n        uint256 sharesSupply = sharesContract.totalSupply();\n        vaultProxyContract.burnShares(_redeemer, _sharesQuantity);\n\n        // Calculate and transfer payout asset amounts due to redeemer\n        payoutAmounts_ = new uint256[](payoutAssets_.length);\n        address denominationAssetCopy = denominationAsset;\n        for (uint256 i; i < payoutAssets_.length; i++) {\n            uint256 assetBalance = __finalizeIfSynthAndGetAssetBalance(\n                address(vaultProxyContract),\n                payoutAssets_[i],\n                true\n            );\n\n            // If all remaining shares are being redeemed, the logic changes slightly\n            if (_sharesQuantity == sharesSupply) {\n                payoutAmounts_[i] = assetBalance;\n                // Remove every tracked asset, except the denomination asset\n                if (payoutAssets_[i] != denominationAssetCopy) {\n                    vaultProxyContract.removeTrackedAsset(payoutAssets_[i]);\n                }\n            } else {\n                payoutAmounts_[i] = assetBalance.mul(_sharesQuantity).div(sharesSupply);\n            }\n\n            // Transfer payout asset to redeemer\n            if (payoutAmounts_[i] > 0) {\n                vaultProxyContract.withdrawAssetTo(payoutAssets_[i], _redeemer, payoutAmounts_[i]);\n            }\n        }\n\n        emit SharesRedeemed(_redeemer, _sharesQuantity, payoutAssets_, payoutAmounts_);\n\n        return (payoutAssets_, payoutAmounts_);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `denominationAsset` variable\n    /// @return denominationAsset_ The `denominationAsset` variable value\n    function getDenominationAsset() external view override returns (address denominationAsset_) {\n        return denominationAsset;\n    }\n\n    /// @notice Gets the routes for the various contracts used by all funds\n    /// @return dispatcher_ The `DISPATCHER` variable value\n    /// @return feeManager_ The `FEE_MANAGER` variable value\n    /// @return fundDeployer_ The `FUND_DEPLOYER` variable value\n    /// @return integrationManager_ The `INTEGRATION_MANAGER` variable value\n    /// @return policyManager_ The `POLICY_MANAGER` variable value\n    /// @return primitivePriceFeed_ The `PRIMITIVE_PRICE_FEED` variable value\n    /// @return valueInterpreter_ The `VALUE_INTERPRETER` variable value\n    function getLibRoutes()\n        external\n        view\n        returns (\n            address dispatcher_,\n            address feeManager_,\n            address fundDeployer_,\n            address integrationManager_,\n            address policyManager_,\n            address primitivePriceFeed_,\n            address valueInterpreter_\n        )\n    {\n        return (\n            DISPATCHER,\n            FEE_MANAGER,\n            FUND_DEPLOYER,\n            INTEGRATION_MANAGER,\n            POLICY_MANAGER,\n            PRIMITIVE_PRICE_FEED,\n            VALUE_INTERPRETER\n        );\n    }\n\n    /// @notice Gets the `overridePause` variable\n    /// @return overridePause_ The `overridePause` variable value\n    function getOverridePause() external view returns (bool overridePause_) {\n        return overridePause;\n    }\n\n    /// @notice Gets the `sharesActionTimelock` variable\n    /// @return sharesActionTimelock_ The `sharesActionTimelock` variable value\n    function getSharesActionTimelock() external view returns (uint256 sharesActionTimelock_) {\n        return sharesActionTimelock;\n    }\n\n    /// @notice Gets the `vaultProxy` variable\n    /// @return vaultProxy_ The `vaultProxy` variable value\n    function getVaultProxy() external view override returns (address vaultProxy_) {\n        return vaultProxy;\n    }\n}\n"
    },
    "contracts/release/core/fund/comptroller/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IComptroller Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IComptroller {\n    enum VaultAction {\n        None,\n        BurnShares,\n        MintShares,\n        TransferShares,\n        ApproveAssetSpender,\n        WithdrawAssetTo,\n        AddTrackedAsset,\n        RemoveTrackedAsset\n    }\n\n    function activate(address, bool) external;\n\n    function calcGav(bool) external returns (uint256, bool);\n\n    function calcGrossShareValue(bool) external returns (uint256, bool);\n\n    function callOnExtension(\n        address,\n        uint256,\n        bytes calldata\n    ) external;\n\n    function configureExtensions(bytes calldata, bytes calldata) external;\n\n    function destruct() external;\n\n    function getDenominationAsset() external view returns (address);\n\n    function getVaultProxy() external view returns (address);\n\n    function init(address, uint256) external;\n\n    function permissionedVaultAction(VaultAction, bytes calldata) external;\n}\n"
    },
    "contracts/release/core/fund/vault/IVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../persistent/utils/IMigratableVault.sol\";\n\n/// @title IVault Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IVault is IMigratableVault {\n    function addTrackedAsset(address) external;\n\n    function approveAssetSpender(\n        address,\n        address,\n        uint256\n    ) external;\n\n    function burnShares(address, uint256) external;\n\n    function callOnContract(address, bytes calldata) external;\n\n    function getAccessor() external view returns (address);\n\n    function getOwner() external view returns (address);\n\n    function getTrackedAssets() external view returns (address[] memory);\n\n    function isTrackedAsset(address) external view returns (bool);\n\n    function mintShares(address, uint256) external;\n\n    function removeTrackedAsset(address) external;\n\n    function transferShares(\n        address,\n        address,\n        uint256\n    ) external;\n\n    function withdrawAssetTo(\n        address,\n        address,\n        uint256\n    ) external;\n}\n"
    },
    "contracts/release/extensions/IExtension.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IExtension Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Interface for all extensions\ninterface IExtension {\n    function activateForFund(bool _isMigration) external;\n\n    function deactivateForFund() external;\n\n    function receiveCallFromComptroller(\n        address _comptrollerProxy,\n        uint256 _actionId,\n        bytes calldata _callArgs\n    ) external;\n\n    function setConfigForFund(bytes calldata _configData) external;\n}\n"
    },
    "contracts/release/extensions/fee-manager/FeeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"../../core/fund/comptroller/IComptroller.sol\";\nimport \"../../core/fund/vault/IVault.sol\";\nimport \"../../utils/AddressArrayLib.sol\";\nimport \"../utils/ExtensionBase.sol\";\nimport \"../utils/FundDeployerOwnerMixin.sol\";\nimport \"../utils/PermissionedVaultActionMixin.sol\";\nimport \"./IFee.sol\";\nimport \"./IFeeManager.sol\";\n\n/// @title FeeManager Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Manages fees for funds\ncontract FeeManager is\n    IFeeManager,\n    ExtensionBase,\n    FundDeployerOwnerMixin,\n    PermissionedVaultActionMixin\n{\n    using AddressArrayLib for address[];\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeMath for uint256;\n\n    event AllSharesOutstandingForcePaidForFund(\n        address indexed comptrollerProxy,\n        address payee,\n        uint256 sharesDue\n    );\n\n    event FeeDeregistered(address indexed fee, string indexed identifier);\n\n    event FeeEnabledForFund(\n        address indexed comptrollerProxy,\n        address indexed fee,\n        bytes settingsData\n    );\n\n    event FeeRegistered(\n        address indexed fee,\n        string indexed identifier,\n        FeeHook[] implementedHooksForSettle,\n        FeeHook[] implementedHooksForUpdate,\n        bool usesGavOnSettle,\n        bool usesGavOnUpdate\n    );\n\n    event FeeSettledForFund(\n        address indexed comptrollerProxy,\n        address indexed fee,\n        SettlementType indexed settlementType,\n        address payer,\n        address payee,\n        uint256 sharesDue\n    );\n\n    event SharesOutstandingPaidForFund(\n        address indexed comptrollerProxy,\n        address indexed fee,\n        uint256 sharesDue\n    );\n\n    event FeesRecipientSetForFund(\n        address indexed comptrollerProxy,\n        address prevFeesRecipient,\n        address nextFeesRecipient\n    );\n\n    EnumerableSet.AddressSet private registeredFees;\n    mapping(address => bool) private feeToUsesGavOnSettle;\n    mapping(address => bool) private feeToUsesGavOnUpdate;\n    mapping(address => mapping(FeeHook => bool)) private feeToHookToImplementsSettle;\n    mapping(address => mapping(FeeHook => bool)) private feeToHookToImplementsUpdate;\n\n    mapping(address => address[]) private comptrollerProxyToFees;\n    mapping(address => mapping(address => uint256))\n        private comptrollerProxyToFeeToSharesOutstanding;\n\n    constructor(address _fundDeployer) public FundDeployerOwnerMixin(_fundDeployer) {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Activate already-configured fees for use in the calling fund\n    function activateForFund(bool) external override {\n        address vaultProxy = __setValidatedVaultProxy(msg.sender);\n\n        address[] memory enabledFees = comptrollerProxyToFees[msg.sender];\n        for (uint256 i; i < enabledFees.length; i++) {\n            IFee(enabledFees[i]).activateForFund(msg.sender, vaultProxy);\n        }\n    }\n\n    /// @notice Deactivate fees for a fund\n    /// @dev msg.sender is validated during __invokeHook()\n    function deactivateForFund() external override {\n        // Settle continuous fees one last time, but without calling Fee.update()\n        __invokeHook(msg.sender, IFeeManager.FeeHook.Continuous, \"\", 0, false);\n\n        // Force payout of remaining shares outstanding\n        __forcePayoutAllSharesOutstanding(msg.sender);\n\n        // Clean up storage\n        __deleteFundStorage(msg.sender);\n    }\n\n    /// @notice Receives a dispatched `callOnExtension` from a fund's ComptrollerProxy\n    /// @param _actionId An ID representing the desired action\n    /// @param _callArgs Encoded arguments specific to the _actionId\n    /// @dev This is the only way to call a function on this contract that updates VaultProxy state.\n    /// For both of these actions, any caller is allowed, so we don't use the caller param.\n    function receiveCallFromComptroller(\n        address,\n        uint256 _actionId,\n        bytes calldata _callArgs\n    ) external override {\n        if (_actionId == 0) {\n            // Settle and update all continuous fees\n            __invokeHook(msg.sender, IFeeManager.FeeHook.Continuous, \"\", 0, true);\n        } else if (_actionId == 1) {\n            __payoutSharesOutstandingForFees(msg.sender, _callArgs);\n        } else {\n            revert(\"receiveCallFromComptroller: Invalid _actionId\");\n        }\n    }\n\n    /// @notice Enable and configure fees for use in the calling fund\n    /// @param _configData Encoded config data\n    /// @dev Caller is expected to be a valid ComptrollerProxy, but there isn't a need to validate.\n    /// The order of `fees` determines the order in which fees of the same FeeHook will be applied.\n    /// It is recommended to run ManagementFee before PerformanceFee in order to achieve precise\n    /// PerformanceFee calcs.\n    function setConfigForFund(bytes calldata _configData) external override {\n        (address[] memory fees, bytes[] memory settingsData) = abi.decode(\n            _configData,\n            (address[], bytes[])\n        );\n\n        // Sanity checks\n        require(\n            fees.length == settingsData.length,\n            \"setConfigForFund: fees and settingsData array lengths unequal\"\n        );\n        require(fees.isUniqueSet(), \"setConfigForFund: fees cannot include duplicates\");\n\n        // Enable each fee with settings\n        for (uint256 i; i < fees.length; i++) {\n            require(isRegisteredFee(fees[i]), \"setConfigForFund: Fee is not registered\");\n\n            // Set fund config on fee\n            IFee(fees[i]).addFundSettings(msg.sender, settingsData[i]);\n\n            // Enable fee for fund\n            comptrollerProxyToFees[msg.sender].push(fees[i]);\n\n            emit FeeEnabledForFund(msg.sender, fees[i], settingsData[i]);\n        }\n    }\n\n    /// @notice Allows all fees for a particular FeeHook to implement settle() and update() logic\n    /// @param _hook The FeeHook to invoke\n    /// @param _settlementData The encoded settlement parameters specific to the FeeHook\n    /// @param _gav The GAV for a fund if known in the invocating code, otherwise 0\n    function invokeHook(\n        FeeHook _hook,\n        bytes calldata _settlementData,\n        uint256 _gav\n    ) external override {\n        __invokeHook(msg.sender, _hook, _settlementData, _gav, true);\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to destroy local storage to get gas refund,\n    /// and to prevent further calls to fee manager\n    function __deleteFundStorage(address _comptrollerProxy) private {\n        delete comptrollerProxyToFees[_comptrollerProxy];\n        delete comptrollerProxyToVaultProxy[_comptrollerProxy];\n    }\n\n    /// @dev Helper to force the payout of shares outstanding across all fees.\n    /// For the current release, all shares in the VaultProxy are assumed to be\n    /// shares outstanding from fees. If not, then they were sent there by mistake\n    /// and are otherwise unrecoverable. We can therefore take the VaultProxy's\n    /// shares balance as the totalSharesOutstanding to payout to the fund owner.\n    function __forcePayoutAllSharesOutstanding(address _comptrollerProxy) private {\n        address vaultProxy = getVaultProxyForFund(_comptrollerProxy);\n\n        uint256 totalSharesOutstanding = ERC20(vaultProxy).balanceOf(vaultProxy);\n        if (totalSharesOutstanding == 0) {\n            return;\n        }\n\n        // Destroy any shares outstanding storage\n        address[] memory fees = comptrollerProxyToFees[_comptrollerProxy];\n        for (uint256 i; i < fees.length; i++) {\n            delete comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][fees[i]];\n        }\n\n        // Distribute all shares outstanding to the fees recipient\n        address payee = IVault(vaultProxy).getOwner();\n        __transferShares(_comptrollerProxy, vaultProxy, payee, totalSharesOutstanding);\n\n        emit AllSharesOutstandingForcePaidForFund(\n            _comptrollerProxy,\n            payee,\n            totalSharesOutstanding\n        );\n    }\n\n    /// @dev Helper to get the canonical value of GAV if not yet set and required by fee\n    function __getGavAsNecessary(\n        address _comptrollerProxy,\n        address _fee,\n        uint256 _gavOrZero\n    ) private returns (uint256 gav_) {\n        if (_gavOrZero == 0 && feeUsesGavOnUpdate(_fee)) {\n            // Assumes that any fee that requires GAV would need to revert if invalid or not final\n            bool gavIsValid;\n            (gav_, gavIsValid) = IComptroller(_comptrollerProxy).calcGav(true);\n            require(gavIsValid, \"__getGavAsNecessary: Invalid GAV\");\n        } else {\n            gav_ = _gavOrZero;\n        }\n\n        return gav_;\n    }\n\n    /// @dev Helper to run settle() on all enabled fees for a fund that implement a given hook, and then to\n    /// optionally run update() on the same fees. This order allows fees an opportunity to update\n    /// their local state after all VaultProxy state transitions (i.e., minting, burning,\n    /// transferring shares) have finished. To optimize for the expensive operation of calculating\n    /// GAV, once one fee requires GAV, we recycle that `gav` value for subsequent fees.\n    /// Assumes that _gav is either 0 or has already been validated.\n    function __invokeHook(\n        address _comptrollerProxy,\n        FeeHook _hook,\n        bytes memory _settlementData,\n        uint256 _gavOrZero,\n        bool _updateFees\n    ) private {\n        address[] memory fees = comptrollerProxyToFees[_comptrollerProxy];\n        if (fees.length == 0) {\n            return;\n        }\n\n        address vaultProxy = getVaultProxyForFund(_comptrollerProxy);\n\n        // This check isn't strictly necessary, but its cost is insignificant,\n        // and helps to preserve data integrity.\n        require(vaultProxy != address(0), \"__invokeHook: Fund is not active\");\n\n        // First, allow all fees to implement settle()\n        uint256 gav = __settleFees(\n            _comptrollerProxy,\n            vaultProxy,\n            fees,\n            _hook,\n            _settlementData,\n            _gavOrZero\n        );\n\n        // Second, allow fees to implement update()\n        // This function does not allow any further altering of VaultProxy state\n        // (i.e., burning, minting, or transferring shares)\n        if (_updateFees) {\n            __updateFees(_comptrollerProxy, vaultProxy, fees, _hook, _settlementData, gav);\n        }\n    }\n\n    /// @dev Helper to payout the shares outstanding for the specified fees.\n    /// Does not call settle() on fees.\n    /// Only callable via ComptrollerProxy.callOnExtension().\n    function __payoutSharesOutstandingForFees(address _comptrollerProxy, bytes memory _callArgs)\n        private\n    {\n        address[] memory fees = abi.decode(_callArgs, (address[]));\n        address vaultProxy = getVaultProxyForFund(msg.sender);\n\n        uint256 sharesOutstandingDue;\n        for (uint256 i; i < fees.length; i++) {\n            if (!IFee(fees[i]).payout(_comptrollerProxy, vaultProxy)) {\n                continue;\n            }\n\n\n                uint256 sharesOutstandingForFee\n             = comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][fees[i]];\n            if (sharesOutstandingForFee == 0) {\n                continue;\n            }\n\n            sharesOutstandingDue = sharesOutstandingDue.add(sharesOutstandingForFee);\n\n            // Delete shares outstanding and distribute from VaultProxy to the fees recipient\n            comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][fees[i]] = 0;\n\n            emit SharesOutstandingPaidForFund(_comptrollerProxy, fees[i], sharesOutstandingForFee);\n        }\n\n        if (sharesOutstandingDue > 0) {\n            __transferShares(\n                _comptrollerProxy,\n                vaultProxy,\n                IVault(vaultProxy).getOwner(),\n                sharesOutstandingDue\n            );\n        }\n    }\n\n    /// @dev Helper to settle a fee\n    function __settleFee(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        address _fee,\n        FeeHook _hook,\n        bytes memory _settlementData,\n        uint256 _gav\n    ) private {\n        (SettlementType settlementType, address payer, uint256 sharesDue) = IFee(_fee).settle(\n            _comptrollerProxy,\n            _vaultProxy,\n            _hook,\n            _settlementData,\n            _gav\n        );\n        if (settlementType == SettlementType.None) {\n            return;\n        }\n\n        address payee;\n        if (settlementType == SettlementType.Direct) {\n            payee = IVault(_vaultProxy).getOwner();\n            __transferShares(_comptrollerProxy, payer, payee, sharesDue);\n        } else if (settlementType == SettlementType.Mint) {\n            payee = IVault(_vaultProxy).getOwner();\n            __mintShares(_comptrollerProxy, payee, sharesDue);\n        } else if (settlementType == SettlementType.Burn) {\n            __burnShares(_comptrollerProxy, payer, sharesDue);\n        } else if (settlementType == SettlementType.MintSharesOutstanding) {\n            comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee] = comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee]\n                .add(sharesDue);\n\n            payee = _vaultProxy;\n            __mintShares(_comptrollerProxy, payee, sharesDue);\n        } else if (settlementType == SettlementType.BurnSharesOutstanding) {\n            comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee] = comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee]\n                .sub(sharesDue);\n\n            payer = _vaultProxy;\n            __burnShares(_comptrollerProxy, payer, sharesDue);\n        } else {\n            revert(\"__settleFee: Invalid SettlementType\");\n        }\n\n        emit FeeSettledForFund(_comptrollerProxy, _fee, settlementType, payer, payee, sharesDue);\n    }\n\n    /// @dev Helper to settle fees that implement a given fee hook\n    function __settleFees(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        address[] memory _fees,\n        FeeHook _hook,\n        bytes memory _settlementData,\n        uint256 _gavOrZero\n    ) private returns (uint256 gav_) {\n        gav_ = _gavOrZero;\n\n        for (uint256 i; i < _fees.length; i++) {\n            if (!feeSettlesOnHook(_fees[i], _hook)) {\n                continue;\n            }\n\n            gav_ = __getGavAsNecessary(_comptrollerProxy, _fees[i], gav_);\n\n            __settleFee(_comptrollerProxy, _vaultProxy, _fees[i], _hook, _settlementData, gav_);\n        }\n\n        return gav_;\n    }\n\n    /// @dev Helper to update fees that implement a given fee hook\n    function __updateFees(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        address[] memory _fees,\n        FeeHook _hook,\n        bytes memory _settlementData,\n        uint256 _gavOrZero\n    ) private {\n        uint256 gav = _gavOrZero;\n\n        for (uint256 i; i < _fees.length; i++) {\n            if (!feeUpdatesOnHook(_fees[i], _hook)) {\n                continue;\n            }\n\n            gav = __getGavAsNecessary(_comptrollerProxy, _fees[i], gav);\n\n            IFee(_fees[i]).update(_comptrollerProxy, _vaultProxy, _hook, _settlementData, gav);\n        }\n    }\n\n    ///////////////////\n    // FEES REGISTRY //\n    ///////////////////\n\n    /// @notice Remove fees from the list of registered fees\n    /// @param _fees Addresses of fees to be deregistered\n    function deregisterFees(address[] calldata _fees) external onlyFundDeployerOwner {\n        require(_fees.length > 0, \"deregisterFees: _fees cannot be empty\");\n\n        for (uint256 i; i < _fees.length; i++) {\n            require(isRegisteredFee(_fees[i]), \"deregisterFees: fee is not registered\");\n\n            registeredFees.remove(_fees[i]);\n\n            emit FeeDeregistered(_fees[i], IFee(_fees[i]).identifier());\n        }\n    }\n\n    /// @notice Add fees to the list of registered fees\n    /// @param _fees Addresses of fees to be registered\n    /// @dev Stores the hooks that a fee implements and whether each implementation uses GAV,\n    /// which fronts the gas for calls to check if a hook is implemented, and guarantees\n    /// that these hook implementation return values do not change post-registration.\n    function registerFees(address[] calldata _fees) external onlyFundDeployerOwner {\n        require(_fees.length > 0, \"registerFees: _fees cannot be empty\");\n\n        for (uint256 i; i < _fees.length; i++) {\n            require(!isRegisteredFee(_fees[i]), \"registerFees: fee already registered\");\n\n            registeredFees.add(_fees[i]);\n\n            IFee feeContract = IFee(_fees[i]);\n            (\n                FeeHook[] memory implementedHooksForSettle,\n                FeeHook[] memory implementedHooksForUpdate,\n                bool usesGavOnSettle,\n                bool usesGavOnUpdate\n            ) = feeContract.implementedHooks();\n\n            // Stores the hooks for which each fee implements settle() and update()\n            for (uint256 j; j < implementedHooksForSettle.length; j++) {\n                feeToHookToImplementsSettle[_fees[i]][implementedHooksForSettle[j]] = true;\n            }\n            for (uint256 j; j < implementedHooksForUpdate.length; j++) {\n                feeToHookToImplementsUpdate[_fees[i]][implementedHooksForUpdate[j]] = true;\n            }\n\n            // Stores whether each fee requires GAV during its implementations for settle() and update()\n            if (usesGavOnSettle) {\n                feeToUsesGavOnSettle[_fees[i]] = true;\n            }\n            if (usesGavOnUpdate) {\n                feeToUsesGavOnUpdate[_fees[i]] = true;\n            }\n\n            emit FeeRegistered(\n                _fees[i],\n                feeContract.identifier(),\n                implementedHooksForSettle,\n                implementedHooksForUpdate,\n                usesGavOnSettle,\n                usesGavOnUpdate\n            );\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Get a list of enabled fees for a given fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @return enabledFees_ An array of enabled fee addresses\n    function getEnabledFeesForFund(address _comptrollerProxy)\n        external\n        view\n        returns (address[] memory enabledFees_)\n    {\n        return comptrollerProxyToFees[_comptrollerProxy];\n    }\n\n    /// @notice Get the amount of shares outstanding for a particular fee for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _fee The fee address\n    /// @return sharesOutstanding_ The amount of shares outstanding\n    function getFeeSharesOutstandingForFund(address _comptrollerProxy, address _fee)\n        external\n        view\n        returns (uint256 sharesOutstanding_)\n    {\n        return comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee];\n    }\n\n    /// @notice Get all registered fees\n    /// @return registeredFees_ A list of all registered fee addresses\n    function getRegisteredFees() external view returns (address[] memory registeredFees_) {\n        registeredFees_ = new address[](registeredFees.length());\n        for (uint256 i; i < registeredFees_.length; i++) {\n            registeredFees_[i] = registeredFees.at(i);\n        }\n\n        return registeredFees_;\n    }\n\n    /// @notice Checks if a fee implements settle() on a particular hook\n    /// @param _fee The address of the fee to check\n    /// @param _hook The FeeHook to check\n    /// @return settlesOnHook_ True if the fee settles on the given hook\n    function feeSettlesOnHook(address _fee, FeeHook _hook)\n        public\n        view\n        returns (bool settlesOnHook_)\n    {\n        return feeToHookToImplementsSettle[_fee][_hook];\n    }\n\n    /// @notice Checks if a fee implements update() on a particular hook\n    /// @param _fee The address of the fee to check\n    /// @param _hook The FeeHook to check\n    /// @return updatesOnHook_ True if the fee updates on the given hook\n    function feeUpdatesOnHook(address _fee, FeeHook _hook)\n        public\n        view\n        returns (bool updatesOnHook_)\n    {\n        return feeToHookToImplementsUpdate[_fee][_hook];\n    }\n\n    /// @notice Checks if a fee uses GAV in its settle() implementation\n    /// @param _fee The address of the fee to check\n    /// @return usesGav_ True if the fee uses GAV during settle() implementation\n    function feeUsesGavOnSettle(address _fee) public view returns (bool usesGav_) {\n        return feeToUsesGavOnSettle[_fee];\n    }\n\n    /// @notice Checks if a fee uses GAV in its update() implementation\n    /// @param _fee The address of the fee to check\n    /// @return usesGav_ True if the fee uses GAV during update() implementation\n    function feeUsesGavOnUpdate(address _fee) public view returns (bool usesGav_) {\n        return feeToUsesGavOnUpdate[_fee];\n    }\n\n    /// @notice Check whether a fee is registered\n    /// @param _fee The address of the fee to check\n    /// @return isRegisteredFee_ True if the fee is registered\n    function isRegisteredFee(address _fee) public view returns (bool isRegisteredFee_) {\n        return registeredFees.contains(_fee);\n    }\n}\n"
    },
    "contracts/release/extensions/fee-manager/IFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./IFeeManager.sol\";\n\n/// @title Fee Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Interface for all fees\ninterface IFee {\n    function activateForFund(address _comptrollerProxy, address _vaultProxy) external;\n\n    function addFundSettings(address _comptrollerProxy, bytes calldata _settingsData) external;\n\n    function identifier() external pure returns (string memory identifier_);\n\n    function implementedHooks()\n        external\n        view\n        returns (\n            IFeeManager.FeeHook[] memory implementedHooksForSettle_,\n            IFeeManager.FeeHook[] memory implementedHooksForUpdate_,\n            bool usesGavOnSettle_,\n            bool usesGavOnUpdate_\n        );\n\n    function payout(address _comptrollerProxy, address _vaultProxy)\n        external\n        returns (bool isPayable_);\n\n    function settle(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        IFeeManager.FeeHook _hook,\n        bytes calldata _settlementData,\n        uint256 _gav\n    )\n        external\n        returns (\n            IFeeManager.SettlementType settlementType_,\n            address payer_,\n            uint256 sharesDue_\n        );\n\n    function update(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        IFeeManager.FeeHook _hook,\n        bytes calldata _settlementData,\n        uint256 _gav\n    ) external;\n}\n"
    },
    "contracts/release/extensions/fee-manager/IFeeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n/// @title FeeManager Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Interface for the FeeManager\ninterface IFeeManager {\n    // No fees for the current release are implemented post-redeemShares\n    enum FeeHook {\n        Continuous,\n        BuySharesSetup,\n        PreBuyShares,\n        PostBuyShares,\n        BuySharesCompleted,\n        PreRedeemShares\n    }\n    enum SettlementType {None, Direct, Mint, Burn, MintSharesOutstanding, BurnSharesOutstanding}\n\n    function invokeHook(\n        FeeHook,\n        bytes calldata,\n        uint256\n    ) external;\n}\n"
    },
    "contracts/release/extensions/policy-manager/IPolicyManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n/// @title PolicyManager Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Interface for the PolicyManager\ninterface IPolicyManager {\n    enum PolicyHook {\n        BuySharesSetup,\n        PreBuyShares,\n        PostBuyShares,\n        BuySharesCompleted,\n        PreCallOnIntegration,\n        PostCallOnIntegration\n    }\n\n    function validatePolicies(\n        address,\n        PolicyHook,\n        bytes calldata\n    ) external;\n}\n"
    },
    "contracts/release/extensions/utils/ExtensionBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../core/fund/comptroller/IComptroller.sol\";\nimport \"../../core/fund/vault/IVault.sol\";\nimport \"../IExtension.sol\";\n\n/// @title ExtensionBase Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Base class for an extension\nabstract contract ExtensionBase is IExtension {\n    mapping(address => address) internal comptrollerProxyToVaultProxy;\n\n    /// @notice Allows extension to run logic during fund activation\n    /// @dev Unimplemented by default, may be overridden.\n    function activateForFund(bool) external virtual override {\n        return;\n    }\n\n    /// @notice Allows extension to run logic during fund deactivation (destruct)\n    /// @dev Unimplemented by default, may be overridden.\n    function deactivateForFund() external virtual override {\n        return;\n    }\n\n    /// @notice Receives calls from ComptrollerLib.callOnExtension()\n    /// and dispatches the appropriate action\n    /// @dev Unimplemented by default, may be overridden.\n    function receiveCallFromComptroller(\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual override {\n        revert(\"receiveCallFromComptroller: Unimplemented for Extension\");\n    }\n\n    /// @notice Allows extension to run logic during fund configuration\n    /// @dev Unimplemented by default, may be overridden.\n    function setConfigForFund(bytes calldata) external virtual override {\n        return;\n    }\n\n    /// @dev Helper to validate a ComptrollerProxy-VaultProxy relation, which we store for both\n    /// gas savings and to guarantee a spoofed ComptrollerProxy does not change getVaultProxy().\n    /// Will revert without reason if the expected interfaces do not exist.\n    function __setValidatedVaultProxy(address _comptrollerProxy)\n        internal\n        returns (address vaultProxy_)\n    {\n        require(\n            comptrollerProxyToVaultProxy[_comptrollerProxy] == address(0),\n            \"__setValidatedVaultProxy: Already set\"\n        );\n\n        vaultProxy_ = IComptroller(_comptrollerProxy).getVaultProxy();\n        require(vaultProxy_ != address(0), \"__setValidatedVaultProxy: Missing vaultProxy\");\n\n        require(\n            _comptrollerProxy == IVault(vaultProxy_).getAccessor(),\n            \"__setValidatedVaultProxy: Not the VaultProxy accessor\"\n        );\n\n        comptrollerProxyToVaultProxy[_comptrollerProxy] = vaultProxy_;\n\n        return vaultProxy_;\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the verified VaultProxy for a given ComptrollerProxy\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @return vaultProxy_ The VaultProxy of the fund\n    function getVaultProxyForFund(address _comptrollerProxy)\n        public\n        view\n        returns (address vaultProxy_)\n    {\n        return comptrollerProxyToVaultProxy[_comptrollerProxy];\n    }\n}\n"
    },
    "contracts/release/extensions/utils/FundDeployerOwnerMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../core/fund-deployer/IFundDeployer.sol\";\n\n/// @title FundDeployerOwnerMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A mixin contract that defers ownership to the owner of FundDeployer\nabstract contract FundDeployerOwnerMixin {\n    address internal immutable FUND_DEPLOYER;\n\n    modifier onlyFundDeployerOwner() {\n        require(\n            msg.sender == getOwner(),\n            \"onlyFundDeployerOwner: Only the FundDeployer owner can call this function\"\n        );\n        _;\n    }\n\n    constructor(address _fundDeployer) public {\n        FUND_DEPLOYER = _fundDeployer;\n    }\n\n    /// @notice Gets the owner of this contract\n    /// @return owner_ The owner\n    /// @dev Ownership is deferred to the owner of the FundDeployer contract\n    function getOwner() public view returns (address owner_) {\n        return IFundDeployer(FUND_DEPLOYER).getOwner();\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `FUND_DEPLOYER` variable\n    /// @return fundDeployer_ The `FUND_DEPLOYER` variable value\n    function getFundDeployer() external view returns (address fundDeployer_) {\n        return FUND_DEPLOYER;\n    }\n}\n"
    },
    "contracts/release/extensions/utils/PermissionedVaultActionMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../core/fund/comptroller/IComptroller.sol\";\n\n/// @title PermissionedVaultActionMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A mixin contract for extensions that can make permissioned vault calls\nabstract contract PermissionedVaultActionMixin {\n    /// @notice Adds a tracked asset to the fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _asset The asset to add\n    function __addTrackedAsset(address _comptrollerProxy, address _asset) internal {\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IComptroller.VaultAction.AddTrackedAsset,\n            abi.encode(_asset)\n        );\n    }\n\n    /// @notice Grants an allowance to a spender to use a fund's asset\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _asset The asset for which to grant an allowance\n    /// @param _target The spender of the allowance\n    /// @param _amount The amount of the allowance\n    function __approveAssetSpender(\n        address _comptrollerProxy,\n        address _asset,\n        address _target,\n        uint256 _amount\n    ) internal {\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IComptroller.VaultAction.ApproveAssetSpender,\n            abi.encode(_asset, _target, _amount)\n        );\n    }\n\n    /// @notice Burns fund shares for a particular account\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _target The account for which to burn shares\n    /// @param _amount The amount of shares to burn\n    function __burnShares(\n        address _comptrollerProxy,\n        address _target,\n        uint256 _amount\n    ) internal {\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IComptroller.VaultAction.BurnShares,\n            abi.encode(_target, _amount)\n        );\n    }\n\n    /// @notice Mints fund shares to a particular account\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _target The account to which to mint shares\n    /// @param _amount The amount of shares to mint\n    function __mintShares(\n        address _comptrollerProxy,\n        address _target,\n        uint256 _amount\n    ) internal {\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IComptroller.VaultAction.MintShares,\n            abi.encode(_target, _amount)\n        );\n    }\n\n    /// @notice Removes a tracked asset from the fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _asset The asset to remove\n    function __removeTrackedAsset(address _comptrollerProxy, address _asset) internal {\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IComptroller.VaultAction.RemoveTrackedAsset,\n            abi.encode(_asset)\n        );\n    }\n\n    /// @notice Transfers fund shares from one account to another\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _from The account from which to transfer shares\n    /// @param _to The account to which to transfer shares\n    /// @param _amount The amount of shares to transfer\n    function __transferShares(\n        address _comptrollerProxy,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IComptroller.VaultAction.TransferShares,\n            abi.encode(_from, _to, _amount)\n        );\n    }\n\n    /// @notice Withdraws an asset from the VaultProxy to a given account\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _asset The asset to withdraw\n    /// @param _target The account to which to withdraw the asset\n    /// @param _amount The amount of asset to withdraw\n    function __withdrawAssetTo(\n        address _comptrollerProxy,\n        address _asset,\n        address _target,\n        uint256 _amount\n    ) internal {\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IComptroller.VaultAction.WithdrawAssetTo,\n            abi.encode(_asset, _target, _amount)\n        );\n    }\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/IDerivativePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IDerivativePriceFeed Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Simple interface for derivative price source oracle implementations\ninterface IDerivativePriceFeed {\n    function calcUnderlyingValues(address, uint256)\n        external\n        returns (address[] memory, uint256[] memory);\n\n    function isSupportedAsset(address) external view returns (bool);\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/SynthetixPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../../../extensions/utils/FundDeployerOwnerMixin.sol\";\nimport \"../../../../interfaces/ISynthetix.sol\";\nimport \"../../../../interfaces/ISynthetixAddressResolver.sol\";\nimport \"../../../../interfaces/ISynthetixExchangeRates.sol\";\nimport \"../../../../interfaces/ISynthetixProxyERC20.sol\";\nimport \"../../../../interfaces/ISynthetixSynth.sol\";\nimport \"../IDerivativePriceFeed.sol\";\n\n/// @title SynthetixPriceFeed Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A price feed that uses Synthetix oracles as price sources\ncontract SynthetixPriceFeed is IDerivativePriceFeed, FundDeployerOwnerMixin {\n    using SafeMath for uint256;\n\n    event SynthAdded(address indexed synth, bytes32 currencyKey);\n\n    event SynthCurrencyKeyUpdated(\n        address indexed synth,\n        bytes32 prevCurrencyKey,\n        bytes32 nextCurrencyKey\n    );\n\n    uint256 private constant SYNTH_UNIT = 10**18;\n    address private immutable ADDRESS_RESOLVER;\n    address private immutable SUSD;\n\n    mapping(address => bytes32) private synthToCurrencyKey;\n\n    constructor(\n        address _fundDeployer,\n        address _addressResolver,\n        address _sUSD,\n        address[] memory _synths\n    ) public FundDeployerOwnerMixin(_fundDeployer) {\n        ADDRESS_RESOLVER = _addressResolver;\n        SUSD = _sUSD;\n\n        address[] memory sUSDSynths = new address[](1);\n        sUSDSynths[0] = _sUSD;\n\n        __addSynths(sUSDSynths);\n        __addSynths(_synths);\n    }\n\n    /// @notice Converts a given amount of a derivative to its underlying asset values\n    /// @param _derivative The derivative to convert\n    /// @param _derivativeAmount The amount of the derivative to convert\n    /// @return underlyings_ The underlying assets for the _derivative\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\n        external\n        override\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\n    {\n        underlyings_ = new address[](1);\n        underlyings_[0] = SUSD;\n        underlyingAmounts_ = new uint256[](1);\n\n        bytes32 currencyKey = getCurrencyKeyForSynth(_derivative);\n        require(currencyKey != 0, \"calcUnderlyingValues: _derivative is not supported\");\n\n        address exchangeRates = ISynthetixAddressResolver(ADDRESS_RESOLVER).requireAndGetAddress(\n            \"ExchangeRates\",\n            \"calcUnderlyingValues: Missing ExchangeRates\"\n        );\n\n        (uint256 rate, bool isInvalid) = ISynthetixExchangeRates(exchangeRates).rateAndInvalid(\n            currencyKey\n        );\n        require(!isInvalid, \"calcUnderlyingValues: _derivative rate is not valid\");\n\n        underlyingAmounts_[0] = _derivativeAmount.mul(rate).div(SYNTH_UNIT);\n\n        return (underlyings_, underlyingAmounts_);\n    }\n\n    /// @notice Checks whether an asset is a supported primitive of the price feed\n    /// @param _asset The asset to check\n    /// @return isSupported_ True if the asset is a supported primitive\n    function isSupportedAsset(address _asset) public view override returns (bool isSupported_) {\n        return getCurrencyKeyForSynth(_asset) != 0;\n    }\n\n    /////////////////////\n    // SYNTHS REGISTRY //\n    /////////////////////\n\n    /// @notice Adds Synths to the price feed\n    /// @param _synths Synths to add\n    function addSynths(address[] calldata _synths) external onlyFundDeployerOwner {\n        require(_synths.length > 0, \"addSynths: Empty _synths\");\n\n        __addSynths(_synths);\n    }\n\n    /// @notice Updates the cached currencyKey value for specified Synths\n    /// @param _synths Synths to update\n    /// @dev Anybody can call this function\n    function updateSynthCurrencyKeys(address[] calldata _synths) external {\n        require(_synths.length > 0, \"updateSynthCurrencyKeys: Empty _synths\");\n\n        for (uint256 i; i < _synths.length; i++) {\n            bytes32 prevCurrencyKey = synthToCurrencyKey[_synths[i]];\n            require(prevCurrencyKey != 0, \"updateSynthCurrencyKeys: Synth not set\");\n\n            bytes32 nextCurrencyKey = __getCurrencyKey(_synths[i]);\n            require(\n                nextCurrencyKey != prevCurrencyKey,\n                \"updateSynthCurrencyKeys: Synth has correct currencyKey\"\n            );\n\n            synthToCurrencyKey[_synths[i]] = nextCurrencyKey;\n\n            emit SynthCurrencyKeyUpdated(_synths[i], prevCurrencyKey, nextCurrencyKey);\n        }\n    }\n\n    /// @dev Helper to add Synths\n    function __addSynths(address[] memory _synths) private {\n        for (uint256 i; i < _synths.length; i++) {\n            require(synthToCurrencyKey[_synths[i]] == 0, \"__addSynths: Value already set\");\n\n            bytes32 currencyKey = __getCurrencyKey(_synths[i]);\n            require(currencyKey != 0, \"__addSynths: No currencyKey\");\n\n            synthToCurrencyKey[_synths[i]] = currencyKey;\n\n            emit SynthAdded(_synths[i], currencyKey);\n        }\n    }\n\n    /// @dev Helper to query a currencyKey from Synthetix\n    function __getCurrencyKey(address _synthProxy) private view returns (bytes32 currencyKey_) {\n        return ISynthetixSynth(ISynthetixProxyERC20(_synthProxy).target()).currencyKey();\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `ADDRESS_RESOLVER` variable\n    /// @return addressResolver_ The `ADDRESS_RESOLVER` variable value\n    function getAddressResolver() external view returns (address) {\n        return ADDRESS_RESOLVER;\n    }\n\n    /// @notice Gets the currencyKey for multiple given Synths\n    /// @return currencyKeys_ The currencyKey values\n    function getCurrencyKeysForSynths(address[] calldata _synths)\n        external\n        view\n        returns (bytes32[] memory currencyKeys_)\n    {\n        currencyKeys_ = new bytes32[](_synths.length);\n        for (uint256 i; i < _synths.length; i++) {\n            currencyKeys_[i] = synthToCurrencyKey[_synths[i]];\n        }\n\n        return currencyKeys_;\n    }\n\n    /// @notice Gets the `SUSD` variable\n    /// @return susd_ The `SUSD` variable value\n    function getSUSD() external view returns (address susd_) {\n        return SUSD;\n    }\n\n    /// @notice Gets the currencyKey for a given Synth\n    /// @return currencyKey_ The currencyKey value\n    function getCurrencyKeyForSynth(address _synth) public view returns (bytes32 currencyKey_) {\n        return synthToCurrencyKey[_synth];\n    }\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/primitives/IPrimitivePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IPrimitivePriceFeed Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Interface for primitive price feeds\ninterface IPrimitivePriceFeed {\n    function calcCanonicalValue(\n        address,\n        uint256,\n        address\n    ) external view returns (uint256, bool);\n\n    function calcLiveValue(\n        address,\n        uint256,\n        address\n    ) external view returns (uint256, bool);\n\n    function isSupportedAsset(address) external view returns (bool);\n}\n"
    },
    "contracts/release/infrastructure/value-interpreter/IValueInterpreter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IValueInterpreter interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Interface for ValueInterpreter\ninterface IValueInterpreter {\n    function calcCanonicalAssetValue(\n        address,\n        uint256,\n        address\n    ) external returns (uint256, bool);\n\n    function calcCanonicalAssetsTotalValue(\n        address[] calldata,\n        uint256[] calldata,\n        address\n    ) external returns (uint256, bool);\n\n    function calcLiveAssetValue(\n        address,\n        uint256,\n        address\n    ) external returns (uint256, bool);\n\n    function calcLiveAssetsTotalValue(\n        address[] calldata,\n        uint256[] calldata,\n        address\n    ) external returns (uint256, bool);\n}\n"
    },
    "contracts/release/interfaces/ISynthetix.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ISynthetix Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ISynthetix {\n    function exchangeOnBehalfWithTracking(\n        address,\n        bytes32,\n        uint256,\n        bytes32,\n        address,\n        bytes32\n    ) external returns (uint256);\n}\n"
    },
    "contracts/release/interfaces/ISynthetixAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ISynthetixAddressResolver Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ISynthetixAddressResolver {\n    function requireAndGetAddress(bytes32, string calldata) external view returns (address);\n}\n"
    },
    "contracts/release/interfaces/ISynthetixExchangeRates.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ISynthetixExchangeRates Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ISynthetixExchangeRates {\n    function rateAndInvalid(bytes32) external view returns (uint256, bool);\n}\n"
    },
    "contracts/release/interfaces/ISynthetixExchanger.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ISynthetixExchanger Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ISynthetixExchanger {\n    function getAmountsForExchange(\n        uint256,\n        bytes32,\n        bytes32\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function settle(address, bytes32)\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n}\n"
    },
    "contracts/release/interfaces/ISynthetixProxyERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ISynthetixProxyERC20 Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ISynthetixProxyERC20 {\n    function target() external view returns (address);\n}\n"
    },
    "contracts/release/interfaces/ISynthetixSynth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ISynthetixSynth Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ISynthetixSynth {\n    function currencyKey() external view returns (bytes32);\n}\n"
    },
    "contracts/release/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title WETH Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/release/peripheral/FundActionsWrapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../core/fund/comptroller/ComptrollerLib.sol\";\nimport \"../extensions/fee-manager/FeeManager.sol\";\n\n/// @title FundActionsWrapper Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Logic related to wrapping fund actions, not necessary in the core protocol\ncontract FundActionsWrapper {\n    using SafeERC20 for ERC20;\n\n    address private immutable FEE_MANAGER;\n    address private immutable WETH_TOKEN;\n\n    mapping(address => bool) private accountToHasMaxWethAllowance;\n\n    constructor(address _feeManager, address _weth) public {\n        FEE_MANAGER = _feeManager;\n        WETH_TOKEN = _weth;\n    }\n\n    /// @dev Needed in case WETH not fully used during exchangeAndBuyShares,\n    /// to unwrap into ETH and refund\n    receive() external payable {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Calculates the net value of 1 unit of shares in the fund's denomination asset\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @return netShareValue_ The amount of the denomination asset per share\n    /// @return isValid_ True if the conversion rates to derive the value are all valid\n    /// @dev Accounts for fees outstanding. This is a convenience function for external consumption\n    /// that can be used to determine the cost of purchasing shares at any given point in time.\n    /// It essentially just bundles settling all fees that implement the Continuous hook and then\n    /// looking up the gross share value.\n    function calcNetShareValueForFund(address _comptrollerProxy)\n        external\n        returns (uint256 netShareValue_, bool isValid_)\n    {\n        ComptrollerLib comptrollerProxyContract = ComptrollerLib(_comptrollerProxy);\n        comptrollerProxyContract.callOnExtension(FEE_MANAGER, 0, \"\");\n\n        return comptrollerProxyContract.calcGrossShareValue(false);\n    }\n\n    /// @notice Exchanges ETH into a fund's denomination asset and then buys shares\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _buyer The account for which to buy shares\n    /// @param _minSharesQuantity The minimum quantity of shares to buy with the sent ETH\n    /// @param _exchange The exchange on which to execute the swap to the denomination asset\n    /// @param _exchangeApproveTarget The address that should be given an allowance of WETH\n    /// for the given _exchange\n    /// @param _exchangeData The data with which to call the exchange to execute the swap\n    /// to the denomination asset\n    /// @param _minInvestmentAmount The minimum amount of the denomination asset\n    /// to receive in the trade for investment (not necessary for WETH)\n    /// @return sharesReceivedAmount_ The actual amount of shares received\n    /// @dev Use a reasonable _minInvestmentAmount always, in case the exchange\n    /// does not perform as expected (low incoming asset amount, blend of assets, etc).\n    /// If the fund's denomination asset is WETH, _exchange, _exchangeApproveTarget, _exchangeData,\n    /// and _minInvestmentAmount will be ignored.\n    function exchangeAndBuyShares(\n        address _comptrollerProxy,\n        address _denominationAsset,\n        address _buyer,\n        uint256 _minSharesQuantity,\n        address _exchange,\n        address _exchangeApproveTarget,\n        bytes calldata _exchangeData,\n        uint256 _minInvestmentAmount\n    ) external payable returns (uint256 sharesReceivedAmount_) {\n        // Wrap ETH into WETH\n        IWETH(payable(WETH_TOKEN)).deposit{value: msg.value}();\n\n        // If denominationAsset is WETH, can just buy shares directly\n        if (_denominationAsset == WETH_TOKEN) {\n            __approveMaxWethAsNeeded(_comptrollerProxy);\n            return __buyShares(_comptrollerProxy, _buyer, msg.value, _minSharesQuantity);\n        }\n\n        // Exchange ETH to the fund's denomination asset\n        __approveMaxWethAsNeeded(_exchangeApproveTarget);\n        (bool success, bytes memory returnData) = _exchange.call(_exchangeData);\n        require(success, string(returnData));\n\n        // Confirm the amount received in the exchange is above the min acceptable amount\n        uint256 investmentAmount = ERC20(_denominationAsset).balanceOf(address(this));\n        require(\n            investmentAmount >= _minInvestmentAmount,\n            \"exchangeAndBuyShares: _minInvestmentAmount not met\"\n        );\n\n        // Give the ComptrollerProxy max allowance for its denomination asset as necessary\n        __approveMaxAsNeeded(_denominationAsset, _comptrollerProxy, investmentAmount);\n\n        // Buy fund shares\n        sharesReceivedAmount_ = __buyShares(\n            _comptrollerProxy,\n            _buyer,\n            investmentAmount,\n            _minSharesQuantity\n        );\n\n        // Unwrap and refund any remaining WETH not used in the exchange\n        uint256 remainingWeth = ERC20(WETH_TOKEN).balanceOf(address(this));\n        if (remainingWeth > 0) {\n            IWETH(payable(WETH_TOKEN)).withdraw(remainingWeth);\n            (success, returnData) = msg.sender.call{value: remainingWeth}(\"\");\n            require(success, string(returnData));\n        }\n\n        return sharesReceivedAmount_;\n    }\n\n    /// @notice Invokes the Continuous fee hook on all specified fees, and then attempts to payout\n    /// any shares outstanding on those fees\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _fees The fees for which to run these actions\n    /// @dev This is just a wrapper to execute two callOnExtension() actions atomically, in sequence.\n    /// The caller must pass in the fees that they want to run this logic on.\n    function invokeContinuousFeeHookAndPayoutSharesOutstandingForFund(\n        address _comptrollerProxy,\n        address[] calldata _fees\n    ) external {\n        ComptrollerLib comptrollerProxyContract = ComptrollerLib(_comptrollerProxy);\n\n        comptrollerProxyContract.callOnExtension(FEE_MANAGER, 0, \"\");\n        comptrollerProxyContract.callOnExtension(FEE_MANAGER, 1, abi.encode(_fees));\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Gets all fees that implement the `Continuous` fee hook for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @return continuousFees_ The fees that implement the `Continuous` fee hook\n    function getContinuousFeesForFund(address _comptrollerProxy)\n        public\n        view\n        returns (address[] memory continuousFees_)\n    {\n        FeeManager feeManagerContract = FeeManager(FEE_MANAGER);\n\n        address[] memory fees = feeManagerContract.getEnabledFeesForFund(_comptrollerProxy);\n\n        // Count the continuous fees\n        uint256 continuousFeesCount;\n        bool[] memory implementsContinuousHook = new bool[](fees.length);\n        for (uint256 i; i < fees.length; i++) {\n            if (feeManagerContract.feeSettlesOnHook(fees[i], IFeeManager.FeeHook.Continuous)) {\n                continuousFeesCount++;\n                implementsContinuousHook[i] = true;\n            }\n        }\n\n        // Return early if no continuous fees\n        if (continuousFeesCount == 0) {\n            return new address[](0);\n        }\n\n        // Create continuous fees array\n        continuousFees_ = new address[](continuousFeesCount);\n        uint256 continuousFeesIndex;\n        for (uint256 i; i < fees.length; i++) {\n            if (implementsContinuousHook[i]) {\n                continuousFees_[continuousFeesIndex] = fees[i];\n                continuousFeesIndex++;\n            }\n        }\n\n        return continuousFees_;\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to approve a target with the max amount of an asset, only when necessary\n    function __approveMaxAsNeeded(\n        address _asset,\n        address _target,\n        uint256 _neededAmount\n    ) internal {\n        if (ERC20(_asset).allowance(address(this), _target) < _neededAmount) {\n            ERC20(_asset).safeApprove(_target, type(uint256).max);\n        }\n    }\n\n    /// @dev Helper to approve a target with the max amount of weth, only when necessary.\n    /// Since WETH does not decrease the allowance if it uint256(-1), only ever need to do this\n    /// once per target.\n    function __approveMaxWethAsNeeded(address _target) internal {\n        if (!accountHasMaxWethAllowance(_target)) {\n            ERC20(WETH_TOKEN).safeApprove(_target, type(uint256).max);\n            accountToHasMaxWethAllowance[_target] = true;\n        }\n    }\n\n    /// @dev Helper for buying shares\n    function __buyShares(\n        address _comptrollerProxy,\n        address _buyer,\n        uint256 _investmentAmount,\n        uint256 _minSharesQuantity\n    ) private returns (uint256 sharesReceivedAmount_) {\n        address[] memory buyers = new address[](1);\n        buyers[0] = _buyer;\n        uint256[] memory investmentAmounts = new uint256[](1);\n        investmentAmounts[0] = _investmentAmount;\n        uint256[] memory minSharesQuantities = new uint256[](1);\n        minSharesQuantities[0] = _minSharesQuantity;\n\n        return\n            ComptrollerLib(_comptrollerProxy).buyShares(\n                buyers,\n                investmentAmounts,\n                minSharesQuantities\n            )[0];\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `FEE_MANAGER` variable\n    /// @return feeManager_ The `FEE_MANAGER` variable value\n    function getFeeManager() external view returns (address feeManager_) {\n        return FEE_MANAGER;\n    }\n\n    /// @notice Gets the `WETH_TOKEN` variable\n    /// @return wethToken_ The `WETH_TOKEN` variable value\n    function getWethToken() external view returns (address wethToken_) {\n        return WETH_TOKEN;\n    }\n\n    /// @notice Checks whether an account has the max allowance for WETH\n    /// @param _who The account to check\n    /// @return hasMaxWethAllowance_ True if the account has the max allowance\n    function accountHasMaxWethAllowance(address _who)\n        public\n        view\n        returns (bool hasMaxWethAllowance_)\n    {\n        return accountToHasMaxWethAllowance[_who];\n    }\n}\n"
    },
    "contracts/release/utils/AddressArrayLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title AddressArray Library\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A library to extend the address array data type\nlibrary AddressArrayLib {\n    /// @dev Helper to add an item to an array. Does not assert uniqueness of the new item.\n    function addItem(address[] memory _self, address _itemToAdd)\n        internal\n        pure\n        returns (address[] memory nextArray_)\n    {\n        nextArray_ = new address[](_self.length + 1);\n        for (uint256 i; i < _self.length; i++) {\n            nextArray_[i] = _self[i];\n        }\n        nextArray_[_self.length] = _itemToAdd;\n\n        return nextArray_;\n    }\n\n    /// @dev Helper to add an item to an array, only if it is not already in the array.\n    function addUniqueItem(address[] memory _self, address _itemToAdd)\n        internal\n        pure\n        returns (address[] memory nextArray_)\n    {\n        if (contains(_self, _itemToAdd)) {\n            return _self;\n        }\n\n        return addItem(_self, _itemToAdd);\n    }\n\n    /// @dev Helper to verify if an array contains a particular value\n    function contains(address[] memory _self, address _target)\n        internal\n        pure\n        returns (bool doesContain_)\n    {\n        for (uint256 i; i < _self.length; i++) {\n            if (_target == _self[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @dev Helper to reassign all items in an array with a specified value\n    function fill(address[] memory _self, address _value)\n        internal\n        pure\n        returns (address[] memory nextArray_)\n    {\n        nextArray_ = new address[](_self.length);\n        for (uint256 i; i < nextArray_.length; i++) {\n            nextArray_[i] = _value;\n        }\n\n        return nextArray_;\n    }\n\n    /// @dev Helper to verify if array is a set of unique values.\n    /// Does not assert length > 0.\n    function isUniqueSet(address[] memory _self) internal pure returns (bool isUnique_) {\n        if (_self.length <= 1) {\n            return true;\n        }\n\n        uint256 arrayLength = _self.length;\n        for (uint256 i; i < arrayLength; i++) {\n            for (uint256 j = i + 1; j < arrayLength; j++) {\n                if (_self[i] == _self[j]) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /// @dev Helper to remove items from an array. Removes all matching occurrences of each item.\n    /// Does not assert uniqueness of either array.\n    function removeItems(address[] memory _self, address[] memory _itemsToRemove)\n        internal\n        pure\n        returns (address[] memory nextArray_)\n    {\n        if (_itemsToRemove.length == 0) {\n            return _self;\n        }\n\n        bool[] memory indexesToRemove = new bool[](_self.length);\n        uint256 remainingItemsCount = _self.length;\n        for (uint256 i; i < _self.length; i++) {\n            if (contains(_itemsToRemove, _self[i])) {\n                indexesToRemove[i] = true;\n                remainingItemsCount--;\n            }\n        }\n\n        if (remainingItemsCount == _self.length) {\n            nextArray_ = _self;\n        } else if (remainingItemsCount > 0) {\n            nextArray_ = new address[](remainingItemsCount);\n            uint256 nextArrayIndex;\n            for (uint256 i; i < _self.length; i++) {\n                if (!indexesToRemove[i]) {\n                    nextArray_[nextArrayIndex] = _self[i];\n                    nextArrayIndex++;\n                }\n            }\n        }\n\n        return nextArray_;\n    }\n}\n"
    },
    "contracts/release/utils/AssetFinalityResolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../infrastructure/price-feeds/derivatives/feeds/SynthetixPriceFeed.sol\";\nimport \"../interfaces/ISynthetixAddressResolver.sol\";\nimport \"../interfaces/ISynthetixExchanger.sol\";\n\n/// @title AssetFinalityResolver Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A contract that helps achieve asset finality\nabstract contract AssetFinalityResolver {\n    address internal immutable SYNTHETIX_ADDRESS_RESOLVER;\n    address internal immutable SYNTHETIX_PRICE_FEED;\n\n    constructor(address _synthetixPriceFeed, address _synthetixAddressResolver) public {\n        SYNTHETIX_ADDRESS_RESOLVER = _synthetixAddressResolver;\n        SYNTHETIX_PRICE_FEED = _synthetixPriceFeed;\n    }\n\n    /// @dev Helper to finalize a Synth balance at a given target address and return its balance\n    function __finalizeIfSynthAndGetAssetBalance(\n        address _target,\n        address _asset,\n        bool _requireFinality\n    ) internal returns (uint256 assetBalance_) {\n        bytes32 currencyKey = SynthetixPriceFeed(SYNTHETIX_PRICE_FEED).getCurrencyKeyForSynth(\n            _asset\n        );\n        if (currencyKey != 0) {\n            address synthetixExchanger = ISynthetixAddressResolver(SYNTHETIX_ADDRESS_RESOLVER)\n                .requireAndGetAddress(\n                \"Exchanger\",\n                \"finalizeAndGetAssetBalance: Missing Exchanger\"\n            );\n            try ISynthetixExchanger(synthetixExchanger).settle(_target, currencyKey)  {} catch {\n                require(!_requireFinality, \"finalizeAndGetAssetBalance: Cannot settle Synth\");\n            }\n        }\n\n        return ERC20(_asset).balanceOf(_target);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `SYNTHETIX_ADDRESS_RESOLVER` variable\n    /// @return synthetixAddressResolver_ The `SYNTHETIX_ADDRESS_RESOLVER` variable value\n    function getSynthetixAddressResolver()\n        external\n        view\n        returns (address synthetixAddressResolver_)\n    {\n        return SYNTHETIX_ADDRESS_RESOLVER;\n    }\n\n    /// @notice Gets the `SYNTHETIX_PRICE_FEED` variable\n    /// @return synthetixPriceFeed_ The `SYNTHETIX_PRICE_FEED` variable value\n    function getSynthetixPriceFeed() external view returns (address synthetixPriceFeed_) {\n        return SYNTHETIX_PRICE_FEED;\n    }\n}\n"
    }
  }
}}