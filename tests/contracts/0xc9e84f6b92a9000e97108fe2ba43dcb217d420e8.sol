{{
  "language": "Solidity",
  "sources": {
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` â†’ `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "src/AmplifiAmplifierV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"openzeppelin-contracts/access/Ownable.sol\";\nimport \"openzeppelin-contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IAmplifi.sol\";\nimport \"./interfaces/IAmplifiNode.sol\";\nimport \"./interfaces/IUniswap.sol\";\nimport {IAmplifierV2} from \"./interfaces/IAmplifierV2.sol\";\nimport \"./FusePoolV2.sol\";\nimport \"./Types.sol\";\nimport \"./Events.sol\";\n\n/**\n * Amplifi\n * Website: https://perpetualyield.io/\n * Telegram: https://t.me/Amplifi_ERC\n * Twitter: https://twitter.com/amplifidefi\n */\ncontract AmplifiAmplifierV2 is Ownable, ReentrancyGuard, IAmplifierV2 {\n    uint16 public maxMonths = 6;\n    uint16 public maxAmplifiersPerMinter = 96;\n    uint256 public gracePeriod = 30 days;\n    uint256 public gammaPeriod = 72 days;\n    uint256 public fuseWaitPeriod = 90 days;\n\n    uint256 public totalAmplifiers = 0;\n    mapping(uint256 => Types.AmplifierV2) private _amplifiers;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(uint256 => uint256)) public ownedAmplifiers;\n    mapping(uint256 => uint256) public ownedAmplifiersIndex;\n    mapping(uint256 => bool) public migratedAmplifiers;\n\n    mapping(Types.FuseProduct => uint256) public fuseLockDurations;\n    mapping(Types.FuseProduct => FusePoolV2) public fusePools;\n    mapping(Types.FuseProduct => uint256) public boosts;\n\n    uint256 public creationFee = 0.008 ether;\n    uint256 public renewalFee = 0.008 ether;\n    uint256 public fuseFee = 0.008 ether;\n    uint256 public mintPrice = 20e18;\n\n    uint256[20] public rates = [\n        1009000000000,\n        857650000000,\n        729002500000,\n        619652125000,\n        526704306250,\n        447698660313,\n        380543861266,\n        323462282076,\n        274942939764,\n        233701498800,\n        198646273980,\n        168849332883,\n        143521932950,\n        121993643008,\n        103694596557,\n        88140407073,\n        74919346012,\n        63681444110,\n        54129227494,\n        46009843370\n    ];\n\n    IAmplifi public immutable amplifi;\n    IAmplifiNode public immutable oldAmplifiNode;\n    IUniswapV2Router02 public immutable router;\n    IERC20 public immutable USDC;\n\n    Types.AmplifierFeeRecipients public feeRecipients;\n\n    uint16 public claimFee = 750;\n    // Basis for above fee values\n    uint16 public constant bps = 10_000;\n\n    constructor(IAmplifi _amplifi, IAmplifiNode _oldAmplifiNode, IUniswapV2Router02 _router, IERC20 _usdc) {\n        amplifi = _amplifi;\n        oldAmplifiNode = _oldAmplifiNode;\n        router = _router;\n        USDC = _usdc;\n\n        feeRecipients = Types.AmplifierFeeRecipients(\n            0xc766B8c9741BC804FCc378FdE75560229CA3AB1E,\n            0x58c5a97c717cA3A7969F82D670A9b9FF16545C6F,\n            0x454cD1e89df17cDB61D868C6D3dBC02bC2c38a17\n        );\n\n        fuseLockDurations[Types.FuseProduct.OneYear] = 365 days;\n        fuseLockDurations[Types.FuseProduct.ThreeYears] = 365 days * 3;\n        fuseLockDurations[Types.FuseProduct.FiveYears] = 365 days * 5;\n\n        fusePools[Types.FuseProduct.OneYear] = new FusePoolV2(msg.sender, this, 365 days);\n        fusePools[Types.FuseProduct.ThreeYears] = new FusePoolV2(msg.sender, this, 365 days * 3);\n        fusePools[Types.FuseProduct.FiveYears] = new FusePoolV2(msg.sender, this, 365 days * 5);\n\n        boosts[Types.FuseProduct.OneYear] = 2e18;\n        boosts[Types.FuseProduct.ThreeYears] = 12e18;\n        boosts[Types.FuseProduct.FiveYears] = 36e18;\n    }\n\n    function createAmplifier(uint256 _months) external payable nonReentrant returns (uint256) {\n        uint256 payment = getRenewalFeeForMonths(_months) + creationFee;\n        require(msg.value == payment, \"Invalid Ether value provided\");\n        require(balanceOf[msg.sender] < maxAmplifiersPerMinter, \"Too many amplifiers\");\n        require(amplifi.burnForAmplifier(msg.sender, mintPrice), \"Not able to burn\");\n\n        uint256 id = _createAmplifier(_months);\n\n        (bool success,) = feeRecipients.validatorAcquisition.call{value: payment}(\"\");\n        require(success, \"Could not send ETH\");\n\n        return id;\n    }\n\n    function createAmplifierBatch(uint256 _amount, uint256 _months)\n        external\n        payable\n        nonReentrant\n        returns (uint256[] memory ids)\n    {\n        uint256 payment = (getRenewalFeeForMonths(_months) + creationFee) * _amount;\n        require(msg.value == payment, \"Invalid Ether value provided\");\n        require(balanceOf[msg.sender] + _amount <= maxAmplifiersPerMinter, \"Too many amplifiers\");\n        require(amplifi.burnForAmplifier(msg.sender, mintPrice * _amount), \"Not able to burn\");\n\n        ids = new uint256[](_amount);\n        for (uint256 i = 0; i < _amount;) {\n            ids[i] = _createAmplifier(_months);\n            unchecked {\n                ++i;\n            }\n        }\n\n        (bool success,) = feeRecipients.validatorAcquisition.call{value: payment}(\"\");\n        require(success, \"Could not send ETH\");\n\n        return ids;\n    }\n\n    function _createAmplifier(uint256 _months) internal returns (uint256) {\n        require(_months > 0 && _months <= maxMonths, \"Must be 1-6 months\");\n\n        uint256 id;\n        unchecked {\n            id = totalAmplifiers++;\n        }\n\n        _amplifiers[id] = Types.AmplifierV2({\n            fuseProduct: Types.FuseProduct.None,\n            minter: msg.sender,\n            numClaims: 0,\n            created: uint48(block.timestamp),\n            expires: uint48(block.timestamp + 30 days * _months),\n            lastClaimed: 0,\n            fused: 0,\n            unlocks: 0\n        });\n\n        uint256 length;\n        unchecked {\n            length = balanceOf[msg.sender]++;\n        }\n        ownedAmplifiers[msg.sender][length] = id;\n        ownedAmplifiersIndex[id] = length;\n\n        emit Events.AmplifierCreated(id, msg.sender, _months);\n\n        return id;\n    }\n\n    function renewAmplifier(uint256 _id, uint256 _months) external payable nonReentrant {\n        uint256 payment = getRenewalFeeForMonths(_months);\n        require(msg.value == payment, \"Invalid Ether value provided\");\n\n        _renewAmplifier(_id, _months);\n\n        (bool success,) = feeRecipients.validatorAcquisition.call{value: payment}(\"\");\n        require(success, \"Could not send ETH\");\n    }\n\n    function renewAmplifierBatch(uint256[] calldata _ids, uint256 _months) external payable nonReentrant {\n        uint256 length = _ids.length;\n        uint256 payment = (getRenewalFeeForMonths(_months)) * length;\n        require(msg.value == payment, \"Invalid Ether value provided\");\n\n        for (uint256 i = 0; i < length;) {\n            _renewAmplifier(_ids[i], _months);\n            unchecked {\n                ++i;\n            }\n        }\n\n        (bool success,) = feeRecipients.validatorAcquisition.call{value: payment}(\"\");\n        require(success, \"Could not send ETH\");\n    }\n\n    function _renewAmplifier(uint256 _id, uint256 _months) internal {\n        Types.AmplifierV2 storage amplifier = _amplifiers[_id];\n\n        require(amplifier.minter == msg.sender, \"Invalid ownership\");\n        require(amplifier.expires + gracePeriod >= block.timestamp, \"Grace period expired\");\n\n        amplifier.expires += uint48(30 days * _months);\n\n        require(amplifier.expires < block.timestamp + (30 days * maxMonths), \"Too many months\");\n\n        emit Events.AmplifierRenewed(_id, msg.sender, _months);\n    }\n\n    function fuseAmplifier(uint256 _id, Types.FuseProduct fuseProduct) external payable nonReentrant {\n        Types.AmplifierV2 storage amplifier = _amplifiers[_id];\n\n        require(amplifier.minter == msg.sender, \"Invalid ownership\");\n        require(amplifier.fuseProduct == Types.FuseProduct.None, \"Already fused\");\n        require(amplifier.expires > block.timestamp, \"Amplifier expired\");\n\n        require(msg.value == fuseFee, \"Invalid Ether value provided\");\n\n        uint48 unlocks = fusePools[fuseProduct].enter(_id);\n\n        amplifier.fuseProduct = fuseProduct;\n        amplifier.fused = uint48(block.timestamp);\n        amplifier.unlocks = unlocks;\n\n        emit Events.AmplifierFused(_id, msg.sender, fuseProduct);\n\n        (bool success,) = feeRecipients.validatorAcquisition.call{value: msg.value}(\"\");\n        require(success, \"Could not send ETH\");\n    }\n\n    function claimAMPLIFI(uint256 _id) external nonReentrant {\n        uint256 amount = _claimAMPLIFI(_id);\n\n        amount = takeClaimFee(amount);\n        require(amplifi.transfer(msg.sender, amount));\n\n        emit Events.AMPLIFIClaimed(msg.sender, amount);\n    }\n\n    function claimAMPLIFIBatch(uint256[] calldata _ids) external nonReentrant {\n        uint256 amount;\n        uint256 length = _ids.length;\n        for (uint256 i = 0; i < length;) {\n            amount += _claimAMPLIFI(_ids[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        amount = takeClaimFee(amount);\n        require(amplifi.transfer(msg.sender, amount));\n\n        emit Events.AMPLIFIClaimed(msg.sender, amount);\n    }\n\n    function _claimAMPLIFI(uint256 _id) internal returns (uint256 amount) {\n        Types.AmplifierV2 storage amplifier = _amplifiers[_id];\n        require(amplifier.minter == msg.sender, \"Invalid ownership\");\n        require(amplifier.fuseProduct == Types.FuseProduct.None, \"Must be unfused\");\n        require(amplifier.expires > block.timestamp, \"Amplifier expired\");\n\n        amount = getPendingAMPLIFI(_id);\n\n        amplifier.numClaims++;\n        amplifier.lastClaimed = uint48(block.timestamp);\n    }\n\n    function claimETH(uint256 _id, uint256[] calldata _blockNumbers) external nonReentrant {\n        _claimETH(_id, _blockNumbers);\n    }\n\n    function claimETHBatch(uint256[] calldata _ids, uint256[] calldata _blockNumbers) external nonReentrant {\n        uint256 length = _ids.length;\n        for (uint256 i = 0; i < length;) {\n            _claimETH(_ids[i], _blockNumbers);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _claimETH(uint256 _id, uint256[] calldata _blockNumbers) internal {\n        Types.AmplifierV2 storage amplifier = _amplifiers[_id];\n        require(amplifier.fuseProduct != Types.FuseProduct.None, \"Must be fused\");\n        require(block.timestamp - amplifier.fused > fuseWaitPeriod, \"Cannot claim ETH yet\");\n\n        if (_blockNumbers.length != 0) {\n            require(amplifier.expires > block.timestamp, \"Amplifier expired\");\n            uint256 amount = fusePools[amplifier.fuseProduct].claim(_id, _blockNumbers);\n\n            emit Events.ETHClaimed(_id, amplifier.minter, msg.sender, amount);\n        }\n\n        if (amplifier.unlocks <= block.timestamp) {\n            if (amplifier.expires > block.timestamp) {\n                require(amplifi.transfer(amplifier.minter, boosts[amplifier.fuseProduct]));\n            }\n            fusePools[amplifier.fuseProduct].exit(_id);\n            amplifier.fuseProduct = Types.FuseProduct.None;\n            amplifier.fused = 0;\n            amplifier.unlocks = 0;\n        }\n    }\n\n    function getPendingAMPLIFI(uint256 _id) public view returns (uint256) {\n        Types.AmplifierV2 memory amplifier = _amplifiers[_id];\n\n        uint256 rate = amplifier.numClaims >= rates.length ? rates[rates.length - 1] : rates[amplifier.numClaims];\n        uint256 amount =\n            (block.timestamp - (amplifier.numClaims > 0 ? amplifier.lastClaimed : amplifier.created)) * (rate);\n        if (amplifier.created < block.timestamp + gammaPeriod) {\n            uint256 _seconds = (block.timestamp + gammaPeriod) - amplifier.created;\n            uint256 _percent = 100;\n            if (_seconds >= 4838400) {\n                _percent = 900;\n            } else if (_seconds >= 4233600) {\n                _percent = 800;\n            } else if (_seconds >= 3628800) {\n                _percent = 700;\n            } else if (_seconds >= 3024000) {\n                _percent = 600;\n            } else if (_seconds >= 2419200) {\n                _percent = 500;\n            } else if (_seconds >= 1814400) {\n                _percent = 400;\n            } else if (_seconds >= 1209600) {\n                _percent = 300;\n            } else if (_seconds >= 604800) {\n                _percent = 200;\n            }\n            uint256 _divisor = amount * _percent;\n            (, uint256 result) = tryDiv(_divisor, 10000);\n            amount -= result;\n        }\n\n        return amount;\n    }\n\n    function takeClaimFee(uint256 amount) internal returns (uint256) {\n        uint256 fee = (amount * claimFee) / bps;\n\n        address[] memory path = new address[](2);\n        path[0] = address(amplifi);\n        path[1] = address(USDC);\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(fee, 0, path, address(this), block.timestamp);\n\n        uint256 usdcToSend = USDC.balanceOf(address(this)) / 2;\n\n        USDC.transfer(feeRecipients.operations, usdcToSend);\n        USDC.transfer(feeRecipients.developers, usdcToSend);\n\n        return amount - fee;\n    }\n\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) {\n                return (false, 0);\n            }\n            return (true, a / b);\n        }\n    }\n\n    function getRenewalFeeForMonths(uint256 _months) public view returns (uint256) {\n        return renewalFee * _months;\n    }\n\n    function amplifiers(uint256 _id) public view override returns (Types.AmplifierV2 memory) {\n        return _amplifiers[_id];\n    }\n\n    function airdropAmplifiers(\n        address[] calldata _users,\n        uint256[] calldata _months,\n        Types.FuseProduct[] calldata _fuseProducts\n    ) external onlyOwner returns (uint256[] memory ids) {\n        require(_users.length == _months.length && _months.length == _fuseProducts.length, \"Lengths not aligned\");\n\n        uint256 length = _users.length;\n        ids = new uint256[](length);\n        for (uint256 i = 0; i < length;) {\n            ids[i] = _airdropAmplifier(_users[i], _months[i], _fuseProducts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        return ids;\n    }\n\n    function _airdropAmplifier(address _user, uint256 _months, Types.FuseProduct _fuseProduct)\n        internal\n        returns (uint256)\n    {\n        require(_months <= maxMonths, \"Too many months\");\n\n        uint256 id;\n        uint256 length;\n        unchecked {\n            id = totalAmplifiers++;\n            length = balanceOf[_user]++;\n        }\n\n        uint48 fused;\n        uint48 unlocks;\n\n        if (_fuseProduct != Types.FuseProduct.None) {\n            fused = uint48(block.timestamp);\n\n            unlocks = fusePools[_fuseProduct].enter(id);\n        }\n\n        _amplifiers[id] = Types.AmplifierV2({\n            fuseProduct: _fuseProduct,\n            minter: _user,\n            numClaims: 0,\n            created: uint48(block.timestamp),\n            expires: uint48(block.timestamp + 30 days * _months),\n            lastClaimed: 0,\n            fused: fused,\n            unlocks: unlocks\n        });\n\n        ownedAmplifiers[_user][length] = id;\n        ownedAmplifiersIndex[id] = length;\n\n        return id;\n    }\n\n    function removeAmplifier(uint256 _id) external onlyOwner {\n        uint256 lastAmplifierIndex = balanceOf[_amplifiers[_id].minter];\n        uint256 amplifierIndex = ownedAmplifiersIndex[_id];\n\n        if (amplifierIndex != lastAmplifierIndex) {\n            uint256 lastAmplifierId = ownedAmplifiers[_amplifiers[_id].minter][lastAmplifierIndex];\n\n            ownedAmplifiers[_amplifiers[_id].minter][amplifierIndex] = lastAmplifierId; // Move the last amplifier to the slot of the to-delete token\n            ownedAmplifiersIndex[lastAmplifierId] = amplifierIndex; // Update the moved amplifier's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete ownedAmplifiersIndex[_id];\n        delete ownedAmplifiers[_amplifiers[_id].minter][lastAmplifierIndex];\n\n        balanceOf[_amplifiers[_id].minter]--;\n        totalAmplifiers--;\n\n        delete _amplifiers[_id];\n    }\n\n    function setRates(uint256[] calldata _rates) external onlyOwner {\n        require(_rates.length == rates.length, \"Invalid length\");\n\n        uint256 length = _rates.length;\n        for (uint256 i = 0; i < length;) {\n            rates[i] = _rates[i];\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function migrateV1Amplifiers(uint256[] calldata _ids) external returns (uint256[] memory) {\n        uint256 length = _ids.length;\n        uint256[] memory migratedIds = new uint256[](length);\n        for (uint256 i = 0; i < length;) {\n            uint256 id = _ids[i];\n            require(!migratedAmplifiers[id], \"Amplifier already migrated\");\n\n            Types.Amplifier memory v1Amplifier = oldAmplifiNode.amplifiers(id);\n            require(v1Amplifier.created != 0, \"Amplifier doesn't exist\");\n            require(v1Amplifier.expires + gracePeriod >= block.timestamp, \"Grace period expired\");\n            require(msg.sender == v1Amplifier.minter, \"Amplifier can only be migrated by the minter\");\n\n            migratedAmplifiers[id] = true;\n            migratedIds[i] = _createMigratedAmplifier(v1Amplifier, id);\n\n            unchecked {\n                ++i;\n            }\n        }\n        return migratedIds;\n    }\n\n    function _createMigratedAmplifier(Types.Amplifier memory _v1Amplifier, uint256 _v1AmplifierId)\n        internal\n        returns (uint256)\n    {\n        uint256 id;\n        unchecked {\n            id = totalAmplifiers++;\n        }\n\n        _amplifiers[id] = Types.AmplifierV2({\n            fuseProduct: _v1Amplifier.fuseProduct,\n            minter: _v1Amplifier.minter,\n            numClaims: uint16(_v1Amplifier.numClaims),\n            created: uint48(_v1Amplifier.created),\n            expires: uint48(_v1Amplifier.expires),\n            lastClaimed: uint48(_v1Amplifier.lastClaimed),\n            fused: uint48(_v1Amplifier.fused),\n            unlocks: uint48(_v1Amplifier.unlocks)\n        });\n\n        if (_v1Amplifier.fuseProduct != Types.FuseProduct.None) {\n            fusePools[_v1Amplifier.fuseProduct].migrateShare(id, uint48(_v1Amplifier.unlocks), false);\n        }\n\n        uint256 length;\n        unchecked {\n            length = balanceOf[_v1Amplifier.minter]++;\n        }\n        ownedAmplifiers[_v1Amplifier.minter][length] = id;\n        ownedAmplifiersIndex[id] = length;\n\n        emit Events.AmplifierMigrated(_v1AmplifierId, id, _v1Amplifier.minter);\n\n        return id;\n    }\n\n    function setMintPrice(uint256 _mintPrice) external onlyOwner {\n        mintPrice = _mintPrice;\n    }\n\n    function setMaxMonths(uint16 _maxMonths) external onlyOwner {\n        maxMonths = _maxMonths;\n    }\n\n    function setFees(uint256 _creationFee, uint256 _renewalFee, uint256 _fuseFee, uint16 _claimFee)\n        external\n        onlyOwner\n    {\n        creationFee = _creationFee;\n        renewalFee = _renewalFee;\n        fuseFee = _fuseFee;\n        claimFee = _claimFee;\n    }\n\n    function setFuseLockDurations(Types.FuseProduct _fuseProduct, uint256 _duration) external onlyOwner {\n        fuseLockDurations[_fuseProduct] = _duration;\n    }\n\n    function setFusePool(Types.FuseProduct _fuseProduct, FusePoolV2 _fusePool) external onlyOwner {\n        fusePools[_fuseProduct] = _fusePool;\n    }\n\n    function setBoosts(Types.FuseProduct _fuseProduct, uint256 _boost) external onlyOwner {\n        boosts[_fuseProduct] = _boost;\n    }\n\n    function setFeeRecipients(Types.AmplifierFeeRecipients calldata _feeRecipients) external onlyOwner {\n        feeRecipients = _feeRecipients;\n    }\n\n    function setPeriods(uint256 _gracePeriod, uint256 _gammaPeriod, uint256 _fuseWaitPeriod) external onlyOwner {\n        gracePeriod = _gracePeriod;\n        gammaPeriod = _gammaPeriod;\n        fuseWaitPeriod = _fuseWaitPeriod;\n    }\n\n    function approveRouter() external onlyOwner {\n        amplifi.approve(address(router), type(uint256).max);\n    }\n\n    function withdrawETH(address _recipient) external onlyOwner {\n        (bool success,) = _recipient.call{value: address(this).balance}(\"\");\n        require(success, \"Could not send ETH\");\n    }\n\n    function withdrawToken(IERC20 _token, address _recipient) external onlyOwner {\n        _token.transfer(_recipient, _token.balanceOf(address(this)));\n    }\n\n    receive() external payable {}\n}\n"
    },
    "src/Events.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./Types.sol\";\n\nlibrary Events {\n    event AmplifierCreated(uint256 indexed id, address indexed owner, uint256 months);\n\n    event AmplifierRenewed(uint256 indexed id, address indexed owner, uint256 months);\n\n    event AmplifierFused(uint256 indexed id, address indexed owner, Types.FuseProduct indexed fuseProduct);\n\n    event AmplifierMigrated(uint256 indexed v1AmplifierId, uint256 indexed v2AmplifierId, address indexed owner);\n\n    event AMPLIFIClaimed(address indexed owner, uint256 amount);\n\n    event ETHClaimed(uint256 indexed id, address indexed owner, address indexed claimer, uint256 amount);\n}\n"
    },
    "src/FusePoolV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"openzeppelin-contracts/access/Ownable.sol\";\nimport \"openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/utils/math/Math.sol\";\nimport \"openzeppelin-contracts/utils/math/SafeCast.sol\";\nimport \"./interfaces/IUniswap.sol\";\nimport \"./interfaces/INetworkV2.sol\";\nimport {IAmplifierV2} from \"./interfaces/IAmplifierV2.sol\";\nimport \"./Types.sol\";\n\n/**\n * Amplifi\n * Website: https://perpetualyield.io/\n * Telegram: https://t.me/Amplifi_ERC\n * Twitter: https://twitter.com/amplifidefi\n */\ncontract FusePoolV2 is INetworkV2, Ownable {\n    uint256 immutable duration;\n\n    IAmplifierV2 public amplifierContract;\n\n    mapping(uint256 => mapping(uint256 => bool)) public hasClaimedPeriod;\n    mapping(uint256 => Types.Pot) public potPerPeriod;\n    mapping(uint256 => uint256) public fuseUnlocks;\n    uint256 public totalSupply;\n\n    mapping(uint256 => Types.Checkpoint[]) private _checkpoints;\n    Types.Checkpoint[] private _totalSupplyCheckpoints;\n\n    event PotAccrued(uint256 potAmount);\n    event Claimed(uint256 indexed id, uint256 indexed potBlock, uint256 amount);\n\n    modifier onlyAmplifier() {\n        require(msg.sender == address(amplifierContract), \"Only Amplifier\");\n        _;\n    }\n\n    constructor(address _owner, IAmplifierV2 _amplifierContract, uint256 _duration) {\n        _transferOwnership(_owner);\n\n        amplifierContract = _amplifierContract;\n        duration = _duration;\n    }\n\n    function enter(uint256 _id) external onlyAmplifier returns (uint48) {\n        require(fuseUnlocks[_id] == 0, \"Share already exists\");\n\n        _checkpoints[_id].push(Types.Checkpoint({fromBlock: uint32(block.number), shares: 1}));\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, 1);\n        totalSupply++;\n\n        uint256 unlocks = duration + block.timestamp;\n        fuseUnlocks[_id] = unlocks;\n\n        return uint48(unlocks);\n    }\n\n    function exit(uint256 _id) external onlyAmplifier {\n        require(fuseUnlocks[_id] <= block.timestamp, \"Cannot exit yet\");\n\n        _checkpoints[_id].push(Types.Checkpoint({fromBlock: uint32(block.number), shares: 0}));\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, 1);\n        totalSupply--;\n        fuseUnlocks[_id] = 0;\n    }\n\n    function migrateShare(uint256 _id, uint48 _unlocks, bool _allowOverwrite) external override onlyAmplifier {\n        require(fuseUnlocks[_id] == 0 || _allowOverwrite, \"Share already exists\");\n\n        _checkpoints[_id].push(Types.Checkpoint({fromBlock: uint32(block.number), shares: 1}));\n\n        fuseUnlocks[_id] = _unlocks;\n\n        unchecked {\n            totalSupply++;\n        }\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, 1);\n    }\n\n    function pot() external payable onlyOwner {\n        potPerPeriod[block.number] =\n            Types.Pot({timestamp: uint48(block.timestamp), value: SafeCast.toUint208(msg.value)});\n        emit PotAccrued(msg.value);\n    }\n\n    function claim(uint256 _id, uint256[] calldata _blockNumbers) external onlyAmplifier returns (uint256) {\n        uint256 owed;\n\n        uint256 length = _blockNumbers.length;\n        for (uint256 i = 0; i < length;) {\n            uint256 claimAmount = _claim(_blockNumbers[i], _id);\n            emit Claimed(_id, _blockNumbers[i], claimAmount);\n            owed += claimAmount;\n            unchecked {\n                ++i;\n            }\n        }\n\n        _claimPayments(owed, _id);\n\n        return owed;\n    }\n\n    function _claim(uint256 _blockNumber, uint256 _id) internal returns (uint256) {\n        require(!hasClaimedPeriod[_id][_blockNumber], \"Already claimied this period\");\n        require(fuseUnlocks[_id] > potPerPeriod[_blockNumber].timestamp, \"Period after unlock time\");\n        hasClaimedPeriod[_id][_blockNumber] = true;\n        return getClaimAmount(_blockNumber, _id);\n    }\n\n    function _claimPayments(uint256 owed, uint256 _id) internal {\n        require(owed > 0, \"No ETH claimable\");\n\n        Types.AmplifierV2 memory amplifier = amplifierContract.amplifiers(_id);\n\n        (bool success,) = amplifier.minter.call{value: owed}(\"\");\n        require(success, \"Could not send ETH\");\n    }\n\n    function _writeCheckpoint(\n        Types.Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) internal returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].shares;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].shares = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(\n                Types.Checkpoint({fromBlock: uint32(block.number), shares: SafeCast.toUint224(newWeight)})\n            );\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n\n    function getClaimAmount(uint256 _blockNumber, uint256 _id) public view returns (uint256) {\n        return\n            (getPastShares(_id, _blockNumber) * potPerPeriod[_blockNumber].value) / (getPastTotalSupply(_blockNumber));\n    }\n\n    function ETHOwed(uint256[] memory _blockNumbers, uint256 _id) public view returns (uint256) {\n        uint256 owed = 0;\n        for (uint256 i = 0; i < _blockNumbers.length;) {\n            uint256 blockNumber = _blockNumbers[i];\n            if (!hasClaimedPeriod[_id][blockNumber]) {\n                owed += (getPastShares(_id, blockNumber) * potPerPeriod[blockNumber].value)\n                    / (getPastTotalSupply(blockNumber));\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        return owed;\n    }\n\n    function getPastShares(uint256 id, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"block not yet mined\");\n        return _checkpointsLookup(_checkpoints[id], blockNumber);\n    }\n\n    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    function _checkpointsLookup(Types.Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].shares;\n    }\n\n    function withdrawETH(address _recipient) external onlyOwner {\n        (bool success,) = _recipient.call{value: address(this).balance}(\"\");\n        require(success, \"Could not send ETH\");\n    }\n\n    function withdrawToken(IERC20 _token, address _recipient) external onlyOwner {\n        _token.transfer(_recipient, _token.balanceOf(address(this)));\n    }\n\n    function emergencyDeposit() external payable onlyOwner {}\n}\n"
    },
    "src/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nlibrary Types {\n    struct FeeRecipients {\n        address operations;\n        address validatorAcquisition;\n        address PCR;\n        address yield;\n        address xChainValidatorAcquisition;\n        address indexFundPools;\n        address gAMPRewardsPool;\n        address OTCSwap;\n        address rescueFund;\n        address protocolImprovement;\n        address developers;\n    }\n\n    struct Fees {\n        uint16 operations;\n        uint16 validatorAcquisition;\n        uint16 PCR;\n        uint16 yield;\n        uint16 xChainValidatorAcquisition;\n        uint16 indexFundPools;\n        uint16 gAMPRewardsPool;\n        uint16 OTCSwap;\n        uint16 rescueFund;\n        uint16 protocolImprovement;\n        uint16 developers;\n    }\n\n    struct Share {\n        uint256 amount;\n        uint256 totalExcluded;\n        uint256 totalRealised;\n        uint256 started;\n        uint256 unlocks;\n    }\n\n    enum FuseProduct {\n        None,\n        OneYear,\n        ThreeYears,\n        FiveYears\n    }\n\n    struct Amplifier {\n        FuseProduct fuseProduct;\n        address minter;\n        uint256 created;\n        uint256 expires;\n        uint256 numClaims;\n        uint256 lastClaimed;\n        uint256 fused;\n        uint256 unlocks;\n        uint256 lastFuseClaimed;\n    }\n\n    struct AmplifierV2 {\n        FuseProduct fuseProduct;\n        address minter;\n        uint16 numClaims;\n        uint48 lastClaimed;\n        uint48 created;\n        uint48 expires;\n        uint48 fused;\n        uint48 unlocks;\n    }\n\n    struct AmplifierFeeRecipients {\n        address operations;\n        address validatorAcquisition;\n        address developers;\n    }\n\n    struct Transistor {\n        address minter;\n        uint256 created;\n        uint256 expires;\n        uint256 numClaims;\n        uint256 lastClaimed;\n    }\n\n    struct TransistorFeeRecipients {\n        address creationFee;\n        address creationTax;\n        address renewalFee;\n        address reverseFee;\n        address claimFeeOperations;\n        address claimFeeDevelopers;\n    }\n\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 shares;\n    }\n\n    struct Pot {\n        uint48 timestamp;\n        uint208 value;\n    }\n}\n"
    },
    "src/interfaces/IAmplifi.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"openzeppelin-contracts/token/ERC20/IERC20.sol\";\n\ninterface IAmplifi is IERC20 {\n    function burnForAmplifier(address _burnee, uint256 _amount) external returns (bool);\n}\n"
    },
    "src/interfaces/IAmplifiNode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {Types} from \"../Types.sol\";\n\ninterface IAmplifiNode {\n    function amplifiers(uint256) external view returns (Types.Amplifier memory);\n}\n"
    },
    "src/interfaces/IAmplifierV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {Types} from \"../Types.sol\";\n\ninterface IAmplifierV2 {\n    function amplifiers(uint256) external view returns (Types.AmplifierV2 memory);\n}\n"
    },
    "src/interfaces/INetworkV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface INetworkV2 {\n    function enter(uint256 _id) external returns (uint48);\n\n    function exit(uint256 _id) external;\n\n    function migrateShare(uint256 _id, uint48 _unlocks, bool _allowOverwrite) external;\n\n    function pot() external payable;\n\n    function claim(uint256 _id, uint256[] calldata _blockNumbers) external returns (uint256);\n}\n"
    },
    "src/interfaces/IUniswap.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.13;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/",
      "solmate/=lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}}