{{
  "language": "Solidity",
  "sources": {
    "genwealh.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n,-. ,-.\n( \\ Gen Wealth / )\n\\ | Website: | /\n\\ | http://genwealth.vip | /\n| Telegram: |/\n----' https://t.me/GenWealthGateway\n/| Twitter: |\\\n/ | https://twitter.com/GenWealthToken\n/ | | \\\n( / \\ )\n-' -'\n*/\n\n\npragma solidity 0.8.9;\n\ninterface IUniswapV2Factory {\n function createPair(address tokenA, address tokenB) external returns(address pair);\n}\n\ninterface IERC20 {\n\n function totalSupply() external view returns(uint256);\n\n function balanceOf(address account) external view returns(uint256);\n\n function transfer(address recipient, uint256 amount) external returns(bool);\n\n function allowance(address owner, address spender) external view returns(uint256);\n\n function approve(address spender, uint256 amount) external returns(bool);\n\n function transferFrom(\n address sender,\n address recipient,\n uint256 amount\n ) external returns(bool);\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n function name() external view returns(string memory);\n\n function symbol() external view returns(string memory);\n\n function decimals() external view returns(uint8);\n}\n\nabstract contract Context {\n function _msgSender() internal view virtual returns(address) {\n return msg.sender;\n }\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n using SafeMath for uint256;\n\n mapping(address => uint256) private _balances;\n mapping(address => mapping(address => uint256)) private _allowances;\n uint256 private _totalSupply;\n \n string private _name;\n string private _symbol;\n\n constructor(string memory name_, string memory symbol_) {\n _name = name_;\n _symbol = symbol_;\n }\n\n function name() public view virtual override returns(string memory) {\n return _name;\n }\n\n function symbol() public view virtual override returns(string memory) {\n return _symbol;\n }\n\n function decimals() public view virtual override returns(uint8) {\n return 18;\n }\n\n function totalSupply() public view virtual override returns(uint256) {\n return _totalSupply;\n }\n\n function balanceOf(address account) public view virtual override returns(uint256) {\n return _balances[account];\n }\n\n function transfer(address recipient, uint256 amount) public virtual override returns(bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n function allowance(address owner, address spender) public view virtual override returns(uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public virtual override returns(bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n function transferFrom(\n address sender,\n address recipient,\n uint256 amount\n ) public virtual override returns(bool) {\n _transfer(sender, recipient, amount);\n _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n return true;\n }\n\n function increaseAllowance(address spender, uint256 addedValue) public virtual returns(bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n return true;\n }\n\n function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns(bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased cannot be below zero\"));\n return true;\n }\n\n function _transfer(\n address sender,\n address recipient,\n uint256 amount\n ) internal virtual {\n \n _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n _balances[recipient] = _balances[recipient].add(amount);\n emit Transfer(sender, recipient, amount);\n }\n\n function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: mint to the zero address\");\n\n _totalSupply = _totalSupply.add(amount);\n _balances[account] = _balances[account].add(amount);\n emit Transfer(address(0), account, amount);\n }\n\n function _approve(\n address owner,\n address spender,\n uint256 amount\n ) internal virtual {\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n}\n \nlibrary SafeMath {\n \n function add(uint256 a, uint256 b) internal pure returns(uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n \n if (a == 0) {\n return 0;\n }\n \n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns(uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n\n return c;\n }\n}\n \ncontract Ownable is Context {\n address private _owner;\n \n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n constructor() {\n address msgSender = _msgSender();\n _owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns(address) {\n return _owner;\n }\n\n modifier onlyOwner() {\n require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n _;\n }\n\n function renounceOwnership() public virtual onlyOwner {\n emit OwnershipTransferred(_owner, address(0));\n _owner = address(0);\n }\n\n function transferOwnership(address newOwner) public virtual onlyOwner {\n require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n emit OwnershipTransferred(_owner, newOwner);\n _owner = newOwner;\n }\n}\n \nlibrary SafeMathInt {\n int256 private constant MIN_INT256 = int256(1) << 255;\n int256 private constant MAX_INT256 = ~(int256(1) << 255);\n\n function mul(int256 a, int256 b) internal pure returns(int256) {\n int256 c = a * b;\n\n require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\n require((b == 0) || (c / b == a));\n return c;\n }\n\n function div(int256 a, int256 b) internal pure returns(int256) {\n require(b != -1 || a != MIN_INT256);\n\n return a / b;\n }\n\n function sub(int256 a, int256 b) internal pure returns(int256) {\n int256 c = a - b;\n require((b >= 0 && c <= a) || (b < 0 && c > a));\n return c;\n }\n\n function add(int256 a, int256 b) internal pure returns(int256) {\n int256 c = a + b;\n require((b >= 0 && c >= a) || (b < 0 && c < a));\n return c;\n }\n\n function abs(int256 a) internal pure returns(int256) {\n require(a != MIN_INT256);\n return a < 0 ? -a : a;\n }\n\n function toUint256Safe(int256 a) internal pure returns(uint256) {\n require(a >= 0);\n return uint256(a);\n }\n}\n \nlibrary SafeMathUint {\n function toInt256Safe(uint256 a) internal pure returns(int256) {\n int256 b = int256(a);\n require(b >= 0);\n return b;\n }\n}\n\ninterface IUniswapV2Router01 {\n function factory() external pure returns(address);\n function WETH() external pure returns(address);\n\n function addLiquidity(\n address tokenA,\n address tokenB,\n uint amountADesired,\n uint amountBDesired,\n uint amountAMin,\n uint amountBMin,\n address to,\n uint deadline\n ) external returns(uint amountA, uint amountB, uint liquidity);\n function addLiquidityETH(\n address token,\n uint amountTokenDesired,\n uint amountTokenMin,\n uint amountETHMin,\n address to,\n uint deadline\n ) external payable returns(uint amountToken, uint amountETH, uint liquidity);\n function removeLiquidity(\n address tokenA,\n address tokenB,\n uint liquidity,\n uint amountAMin,\n uint amountBMin,\n address to,\n uint deadline\n ) external returns(uint amountA, uint amountB);\n function removeLiquidityETH(\n address token,\n uint liquidity,\n uint amountTokenMin,\n uint amountETHMin,\n address to,\n uint deadline\n ) external returns(uint amountToken, uint amountETH);\n function removeLiquidityWithPermit(\n address tokenA,\n address tokenB,\n uint liquidity,\n uint amountAMin,\n uint amountBMin,\n address to,\n uint deadline,\n bool approveMax, uint8 v, bytes32 r, bytes32 s\n ) external returns(uint amountA, uint amountB);\n function removeLiquidityETHWithPermit(\n address token,\n uint liquidity,\n uint amountTokenMin,\n uint amountETHMin,\n address to,\n uint deadline,\n bool approveMax, uint8 v, bytes32 r, bytes32 s\n ) external returns(uint amountToken, uint amountETH);\n function swapExactTokensForTokens(\n uint amountIn,\n uint amountOutMin,\n address[] calldata path,\n address to,\n uint deadline\n ) external returns(uint[] memory amounts);\n function swapTokensForExactTokens(\n uint amountOut,\n uint amountInMax,\n address[] calldata path,\n address to,\n uint deadline\n ) external returns(uint[] memory amounts);\n function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n external\n payable\n returns(uint[] memory amounts);\n function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n external\n returns(uint[] memory amounts);\n function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n external\n returns(uint[] memory amounts);\n function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n external\n payable\n returns(uint[] memory amounts);\n\n function quote(uint amountA, uint reserveA, uint reserveB) external pure returns(uint amountB);\n function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns(uint amountOut);\n function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns(uint amountIn);\n function getAmountsOut(uint amountIn, address[] calldata path) external view returns(uint[] memory amounts);\n function getAmountsIn(uint amountOut, address[] calldata path) external view returns(uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n function removeLiquidityETHSupportingFeeOnTransferTokens(\n address token,\n uint liquidity,\n uint amountTokenMin,\n uint amountETHMin,\n address to,\n uint deadline\n ) external returns(uint amountETH);\n function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n address token,\n uint liquidity,\n uint amountTokenMin,\n uint amountETHMin,\n address to,\n uint deadline,\n bool approveMax, uint8 v, bytes32 r, bytes32 s\n ) external returns(uint amountETH);\n\n function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n uint amountIn,\n uint amountOutMin,\n address[] calldata path,\n address to,\n uint deadline\n ) external;\n function swapExactETHForTokensSupportingFeeOnTransferTokens(\n uint amountOutMin,\n address[] calldata path,\n address to,\n uint deadline\n ) external payable;\n function swapExactTokensForETHSupportingFeeOnTransferTokens(\n uint amountIn,\n uint amountOutMin,\n address[] calldata path,\n address to,\n uint deadline\n ) external;\n}\n \ncontract GENW is ERC20, Ownable {\n using SafeMath for uint256;\n\n IUniswapV2Router02 public immutable router;\n address public immutable uniswapV2Pair;\n\n // addresses\n address public devWallet;\n address private marketingWallet;\n\n // limits \n uint256 private maxBuyAmount;\n uint256 private maxSellAmount; \n uint256 private maxWalletAmount;\n \n uint256 private thresholdSwapAmount;\n\n // status flags\n bool private isTrading = false;\n bool public swapEnabled = false;\n bool public isSwapping;\n\n struct Fees {\n uint8 buyTotalFees;\n uint8 buyMarketingFee;\n uint8 buyDevFee;\n uint8 buyLiquidityFee;\n\n uint8 sellTotalFees;\n uint8 sellMarketingFee;\n uint8 sellDevFee;\n uint8 sellLiquidityFee;\n } \n\n Fees public _fees = Fees({\n sellTotalFees: 0,\n sellMarketingFee: 0,\n sellDevFee:0,\n sellLiquidityFee: 0,\n\n buyTotalFees: 0,\n buyMarketingFee: 0,\n buyDevFee:0,\n buyLiquidityFee: 0\n });\n \n mapping(address => bool) private _isExcludedFromFees;\n mapping(address => bool) public _isExcludedMaxTransactionAmount;\n mapping(address => bool) public _isExcludedMaxWalletAmount;\n\n uint256 public tokensForMarketing;\n uint256 public tokensForLiquidity;\n uint256 public tokensForDev;\n uint256 private taxTill;\n\n mapping(address => bool) public marketPair;\n mapping(address => bool) public _isBlacklisted;\n \n event SwapAndLiquify(\n uint256 tokensSwapped,\n uint256 ethReceived\n );\n\n constructor() ERC20(\"Gen Wealth\", \"GENW\") {\n \n router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n uniswapV2Pair = IUniswapV2Factory(router.factory()).createPair(address(this), router.WETH());\n\n //Wallets\n devWallet = address(0x7423b20B032046af0B95789D23beC7633480B2E3);\n marketingWallet = address(0xd8231A422E90a185A3882BF51B25E74a418b06c5);\n\n//Fees\n _fees.buyMarketingFee = 15;\n _fees.buyLiquidityFee = 0;\n _fees.buyDevFee = 5;\n _fees.buyTotalFees = _fees.buyMarketingFee + _fees.buyLiquidityFee + _fees.buyDevFee;\n\n _fees.sellMarketingFee = 15;\n _fees.sellLiquidityFee = 0;\n _fees.sellDevFee = 5;\n _fees.sellTotalFees = _fees.sellMarketingFee + _fees.sellLiquidityFee + _fees.sellDevFee;\n\n// Lists\n _isExcludedMaxWalletAmount[owner()] = true;\n _isExcludedMaxWalletAmount[address(this)] = true;\n _isExcludedMaxWalletAmount[address(uniswapV2Pair)] = true;\n \n _isExcludedMaxTransactionAmount[address(router)] = true;\n _isExcludedMaxTransactionAmount[address(uniswapV2Pair)] = true; \n _isExcludedMaxTransactionAmount[owner()] = true;\n _isExcludedMaxTransactionAmount[address(this)] = true;\n\n _isExcludedFromFees[owner()] = true;\n _isExcludedFromFees[address(this)] = true;\n\n marketPair[address(uniswapV2Pair)] = true;\n approve(address(router), type(uint256).max);\n \n //Supply\n uint256 totalSupply = 420690000000 * 10**18;\n\n//Limits\n maxBuyAmount = totalSupply * 1 / 100;\n maxSellAmount = totalSupply * 1 / 100;\n maxWalletAmount = totalSupply * 2 / 100;\n thresholdSwapAmount = totalSupply * 2 / 10000;\n\n _mint(msg.sender, totalSupply);\n }\n\n receive() external payable {\n }\n\n function swapTrading() external onlyOwner {\n isTrading = true;\n swapEnabled = true;\n taxTill = block.number + 2;\n }\n\n function updateThresholdSwapAmount(uint256 newAmount) external onlyOwner returns(bool){\n thresholdSwapAmount = newAmount;\n return true;\n }\n\n function updateMaxTxnAmount(uint256 newMaxBuy, uint256 newMaxSell) external onlyOwner {\n require(((totalSupply() * newMaxBuy) / 1000) >= (totalSupply() / 100), \"maxBuyAmount must be higher than 1%\");\n require(((totalSupply() * newMaxSell) / 1000) >= (totalSupply() / 100), \"maxSellAmount must be higher than 1%\");\n maxBuyAmount = (totalSupply() * newMaxBuy) / 1000;\n maxSellAmount = (totalSupply() * newMaxSell) / 1000;\n }\n\n function updateMaxWalletAmount(uint256 newPercentage) external onlyOwner {\n require(((totalSupply() * newPercentage) / 1000) >= (totalSupply() / 100), \"Cannot set maxWallet lower than 1%\");\n maxWalletAmount = (totalSupply() * newPercentage) / 1000;\n }\n\n function toggleSwapEnabled(bool enabled) external onlyOwner(){\n swapEnabled = enabled;\n }\n\n function blacklistAddress(address account, bool value) external onlyOwner{\n _isBlacklisted[account] = value;\n }\n\n function updateFees(uint8 _marketingFeeBuy, uint8 _liquidityFeeBuy,uint8 _devFeeBuy,uint8 _marketingFeeSell, uint8 _liquidityFeeSell,uint8 _devFeeSell) external onlyOwner{\n _fees.buyMarketingFee = _marketingFeeBuy;\n _fees.buyLiquidityFee = _liquidityFeeBuy;\n _fees.buyDevFee = _devFeeBuy;\n _fees.buyTotalFees = _fees.buyMarketingFee + _fees.buyLiquidityFee + _fees.buyDevFee;\n\n _fees.sellMarketingFee = _marketingFeeSell;\n _fees.sellLiquidityFee = _liquidityFeeSell;\n _fees.sellDevFee = _devFeeSell;\n _fees.sellTotalFees = _fees.sellMarketingFee + _fees.sellLiquidityFee + _fees.sellDevFee;\n require(_fees.buyTotalFees <= 40, \"Must keep fees at 40% or less\"); \n require(_fees.sellTotalFees <= 40, \"Must keep fees at 40% or less\");\n \n }\n \n function excludeFromFees(address account, bool excluded) public onlyOwner {\n _isExcludedFromFees[account] = excluded;\n }\n function excludeFromWalletLimit(address account, bool excluded) public onlyOwner {\n _isExcludedMaxWalletAmount[account] = excluded;\n }\n function excludeFromMaxTransaction(address updAds, bool isEx) public onlyOwner {\n _isExcludedMaxTransactionAmount[updAds] = isEx;\n }\n\n function setMarketPair(address pair, bool value) public onlyOwner {\n require(pair != uniswapV2Pair, \"Must keep uniswapV2Pair\");\n marketPair[pair] = value;\n }\n\n function setWallets(address _marketingWallet,address _devWallet) external onlyOwner{\n marketingWallet = _marketingWallet;\n devWallet = _devWallet;\n }\n\n function isExcludedFromFees(address account) public view returns(bool) {\n return _isExcludedFromFees[account];\n }\n\n function _transfer(\n address sender,\n address recipient,\n uint256 amount\n \n ) internal override {\n \n if (amount == 0) {\n super._transfer(sender, recipient, 0);\n return;\n }\n\n if (\n sender != owner() &&\n recipient != owner() &&\n !isSwapping\n ) {\n\n if (!isTrading) {\n require(_isExcludedFromFees[sender] || _isExcludedFromFees[recipient], \"Trading is not active.\");\n }\n if (marketPair[sender] && !_isExcludedMaxTransactionAmount[recipient]) {\n require(amount <= maxBuyAmount, \"buy transfer over max amount\");\n } \n else if (marketPair[recipient] && !_isExcludedMaxTransactionAmount[sender]) {\n require(amount <= maxSellAmount, \"Sell transfer over max amount\");\n }\n\n if (!_isExcludedMaxWalletAmount[recipient]) {\n require(amount + balanceOf(recipient) <= maxWalletAmount, \"Max wallet exceeded\");\n }\n require(!_isBlacklisted[sender] && !_isBlacklisted[recipient], \"Blacklisted address\");\n }\n \n uint256 contractTokenBalance = balanceOf(address(this));\n \n bool canSwap = contractTokenBalance >= thresholdSwapAmount;\n\n if (\n canSwap &&\n swapEnabled &&\n !isSwapping &&\n marketPair[recipient] &&\n !_isExcludedFromFees[sender] &&\n !_isExcludedFromFees[recipient]\n ) {\n isSwapping = true;\n swapBack();\n isSwapping = false;\n }\n \n bool takeFee = !isSwapping;\n\n if (_isExcludedFromFees[sender] || _isExcludedFromFees[recipient]) {\n takeFee = false;\n }\n \n if (takeFee) {\n uint256 fees = 0;\n if(block.number < taxTill) {\n fees = amount.mul(99).div(100);\n tokensForMarketing += (fees * 94) / 99;\n tokensForDev += (fees * 5) / 99;\n } else if (marketPair[recipient] && _fees.sellTotalFees > 0) {\n fees = amount.mul(_fees.sellTotalFees).div(100);\n tokensForLiquidity += fees * _fees.sellLiquidityFee / _fees.sellTotalFees;\n tokensForMarketing += fees * _fees.sellMarketingFee / _fees.sellTotalFees;\n tokensForDev += fees * _fees.sellDevFee / _fees.sellTotalFees;\n }\n // on buy\n else if (marketPair[sender] && _fees.buyTotalFees > 0) {\n fees = amount.mul(_fees.buyTotalFees).div(100);\n tokensForLiquidity += fees * _fees.buyLiquidityFee / _fees.buyTotalFees;\n tokensForMarketing += fees * _fees.buyMarketingFee / _fees.buyTotalFees;\n tokensForDev += fees * _fees.buyDevFee / _fees.buyTotalFees;\n }\n\n if (fees > 0) {\n super._transfer(sender, address(this), fees);\n }\n\n amount -= fees;\n\n }\n\n super._transfer(sender, recipient, amount);\n }\n\n function swapTokensForEth(uint256 tAmount) private {\n\n address[] memory path = new address[](2);\n path[0] = address(this);\n path[1] = router.WETH();\n\n _approve(address(this), address(router), tAmount);\n\n router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n tAmount,\n 0, // accept any amount of ETH!\n path,\n address(this),\n block.timestamp\n );\n }\n\n function addLiquidity(uint256 tAmount, uint256 ethAmount) private {\n _approve(address(this), address(router), tAmount);\n\n router.addLiquidityETH{ value: ethAmount } (address(this), tAmount, 0, 0 , address(this), block.timestamp);\n }\n\n function swapBack() private {\n uint256 contractTokenBalance = balanceOf(address(this));\n uint256 toSwap = tokensForLiquidity + tokensForMarketing + tokensForDev;\n bool success;\n\n if (contractTokenBalance == 0 || toSwap == 0) { return; }\n\n if (contractTokenBalance > thresholdSwapAmount * 20) {\n contractTokenBalance = thresholdSwapAmount * 20;\n }\n\n uint256 liquidityTokens = contractTokenBalance * tokensForLiquidity / toSwap / 2;\n uint256 amountToSwapForETH = contractTokenBalance.sub(liquidityTokens);\n \n uint256 initialETHBalance = address(this).balance;\n\n swapTokensForEth(amountToSwapForETH); \n \n uint256 newBalance = address(this).balance.sub(initialETHBalance);\n \n uint256 ethForMarketing = newBalance.mul(tokensForMarketing).div(toSwap);\n uint256 ethForDev = newBalance.mul(tokensForDev).div(toSwap);\n uint256 ethForLiquidity = newBalance - (ethForMarketing + ethForDev);\n\n tokensForLiquidity = 0;\n tokensForMarketing = 0;\n tokensForDev = 0;\n\n if (liquidityTokens > 0 && ethForLiquidity > 0) {\n addLiquidity(liquidityTokens, ethForLiquidity);\n emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity);\n }\n\n (success,) = address(devWallet).call{ value: (address(this).balance - ethForMarketing) } (\"\");\n (success,) = address(marketingWallet).call{ value: address(this).balance } (\"\");\n }\n\n// That is all\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}