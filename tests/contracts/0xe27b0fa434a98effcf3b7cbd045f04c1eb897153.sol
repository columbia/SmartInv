{{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/Approvable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"./Ownable.sol\";\nimport \"./Nameable.sol\";\nimport { TokenNonOwner } from \"./SetOwnerEnumerable.sol\";\nimport { OwnerEnumerable } from \"./OwnerEnumerable.sol\";\nimport { SetApprovable, ApprovableData, TokenNonExistent } from \"./SetApprovable.sol\";\n\nabstract contract Approvable is OwnerEnumerable {  \n    using SetApprovable for ApprovableData; \n    ApprovableData approvable;\n    uint256 tokenCount;\n\n    function _checkTokenOwner(uint256 tokenId) internal view virtual {\n        if (ownerOf(tokenId) != msg.sender) {\n            revert TokenNonOwner(msg.sender, tokenId);\n        }\n    }    \n \n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return approvable.isApprovedForAll(owner,operator);\n    }  \n\n    function approve(address to, uint256 tokenId) public virtual override {  \n        _checkTokenOwner(tokenId);      \n        approvable.approveForToken(to, tokenId);\n        emit Approval(ownerOf(tokenId), to, tokenId);        \n    }  \n\n    function setApprovalForAll(address operator, bool approved) public virtual override {   \n        approved ? approvable.approveForContract(operator): approvable.revokeApprovalForContract(operator, msg.sender);\n    }       \n\n    function validateApprovedOrOwner(address spender, uint256 tokenId) internal view {        \n        if (!(spender == ownerOf(tokenId) || isApprovedForAll(ownerOf(tokenId), spender) || approvable.getApproved(tokenId) == spender)) {\n            revert TokenNonOwner(spender, tokenId);\n        }\n    }  \n\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        requireMinted(tokenId);\n        return approvable.tokens[tokenId].approval;\n    }       \n\n    function revokeTokenApproval(uint256 tokenId) internal {\n        approvable.revokeTokenApproval(tokenId);\n    }\n\n    function revokeApprovals(address holder) internal {\n        approvable.revokeApprovals(holder,tokensOwnedBy(holder));                    \n    }\n\n    function requireMinted(uint256 tokenId) internal view virtual {\n        if (tokenId <= tokenCount) {\n            revert TokenNonExistent(tokenId);\n        }\n    }\n}"
    },
    "contracts/Assignable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport { SetAssignable, AssignableData, NotTokenOwner, NotAssigned } from \"./SetAssignable.sol\";\nimport { OwnerEnumerable } from \"./OwnerEnumerable.sol\";\nimport \"./Phaseable.sol\";\n\n\nabstract contract Assignable is Phaseable {  \n    using SetAssignable for AssignableData;\n    AssignableData assignables;\n    \n    function assignColdStorage(uint256 tokenId) external {        \n        if (msg.sender != ownerOf(tokenId)) {\n            revert NotTokenOwner();\n        }\n        assignables.addAssignment(msg.sender,tokenId);\n    }\n    \n    function revokeColdStorage(uint256 tokenId) external {        \n        if (assignables.findAssignment(msg.sender) != tokenId) {\n            revert NotAssigned(msg.sender);\n        }\n        assignables.removeAssignment(msg.sender);\n    }   \n    \n    function revokeAssignments(uint256 tokenId) external {        \n        if (msg.sender != ownerOf(tokenId)) {\n            revert NotTokenOwner();\n        }\n        assignables.revokeAll(tokenId);\n    }    \n    \n    function findAssignments(uint256 tokenId) external view returns (address[] memory){        \n        return assignables.findAssignees(tokenId);\n    }        \n\n    function balanceOf(address seekingContract, address owner) external view returns (uint256) {        \n        uint256 guardianBalance = balanceOf(owner);\n        if (guardianBalance > 0) {\n            uint256[] memory guardians = tokensOwnedBy(owner);\n            return assignables.iterateGuardiansBalance(guardians, seekingContract, 0);\n        }\n        return 0;\n    }     \n}"
    },
    "contracts/EIP712Allowlisting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./EIP712Listable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nbytes32 constant ALLOW_MINT_TYPE =\n    keccak256(\"Minter(address wallet)\");\n\nbytes32 constant INITIATE_MINT_TYPE =\n    keccak256(\"Minter(string initiateAddress)\");\n\nbytes32 constant FREE_MINT_TYPE =\n    keccak256(\"Minter(string elderAddress)\");    \n\n\nabstract contract EIP712Allowlisting is EIP712Listable {\n    using ECDSA for bytes32;\n    using Strings for uint256;\n    using Strings for uint160;\n    using Strings for address;\n    string constant invalid = \"invalid signature\";\n    function isValid(address recovery, address recip) private view {\n        require(recovery == sigKey, invalid);\n        require(msg.sender == recip, invalid);\n    }\n    modifier requiresAllowSig(bytes calldata sig, address recip) {\n        require(sigKey != address(0), \"allowlist not enabled\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOM_SEP,\n                keccak256(abi.encode(ALLOW_MINT_TYPE, recip))\n            )\n        );\n        isValid(digest.recover(sig),recip);\n        _;\n    }\n       \n    modifier requiresClaimSig(bytes calldata sig, address recip, uint256[] memory bag) {\n        require(sigKey != address(0), \"not enabled\");\n        uint total = uint(uint160(recip));\n        for (uint i; i < bag.length; i++) {\n            total += bag[i];\n        }\n   \n        string memory bagged = total.toString();\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOM_SEP,\n                keccak256(abi.encode(FREE_MINT_TYPE,keccak256(abi.encodePacked(bagged))))\n            )\n        );\n        \n        isValid(digest.recover(sig),recip);\n        _;\n    }    \n}"
    },
    "contracts/EIP712Listable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport \"./Assignable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nabstract contract EIP712Listable is Assignable {\n    using ECDSA for bytes32;\n\n    address internal sigKey = address(0);\n\n    bytes32 internal DOM_SEP;    \n\n    uint256 chainid = 420;\n\n    function setDomainSeparator(string memory _name, string memory _version) internal {\n        DOM_SEP = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(_name)),\n                keccak256(bytes(_version)),\n                chainid,\n                address(this)\n            )\n        );\n    }\n\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(DOM_SEP, structHash);\n    }    \n\n    function getSigningAddress() public view returns (address) {\n        return sigKey;\n    }\n\n    function setSigningAddress(address _sigKey) public onlyOwner {\n        sigKey = _sigKey;\n    }\n  \n}"
    },
    "contracts/FlexibleMetadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"./Ownable.sol\";\nimport \"./Nameable.sol\";\nimport { DEFAULT, FLAG, PRE, Supplement, SetFlexibleMetadata, FlexibleMetadataData } from \"./SetFlexibleMetadata.sol\";\n\nabstract contract FlexibleMetadata is Ownable, Context, ERC165, IERC721, Nameable {  \n    using SetFlexibleMetadata for FlexibleMetadataData;\n    FlexibleMetadataData flexible;   \n\n    constructor(string memory _name, string memory _symbol) Nameable(_name,_symbol) {\n    }   \n    \n    function setContractUri(string memory uri) external onlyOwner {\n        flexible.setContractMetadataURI(uri);\n    }\n\n    function reveal(bool _reveal) external onlyOwner {\n        flexible.reveal(_reveal);\n    }\n\n    function setTokenUri(string memory uri, uint256 tokenType) external onlyOwner {\n        tokenType == FLAG ?\n            flexible.setFlaggedTokenMetadataURI(uri):\n            (tokenType == PRE) ?\n                flexible.setPrerevealTokenMetadataURI(uri):\n                    flexible.setDefaultTokenMetadataURI(uri);\n    }\n\n    function setSupplementalTokenUri(uint256 key, string memory uri) external onlyOwner {\n        flexible.setSupplementalTokenMetadataURI(key,uri);\n    }\n\n    function flagToken(uint256 tokenId, bool isFlagged) external onlyOwner {\n        flexible.flagToken(tokenId,isFlagged);\n    }\n\n    function setSupplemental(uint256 tokenId, bool isSupplemental, uint256 key) internal {\n        if (isSupplemental) {\n            flexible.supplemental[tokenId] = Supplement(key,true);\n        } else {\n            delete flexible.supplemental[tokenId];\n        }\n    }    \n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165,IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }   \n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {        \n        return flexible.getTokenMetadata(tokenId);\n    }          \n    function contractURI() external view returns (string memory) {\n        return flexible.getContractMetadata();\n    }    \n}"
    },
    "contracts/Lockable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport \"./Approvable.sol\";\nimport { SetLockable, LockableStatus,  LockableData, WalletLockedByOwner } from \"./SetLockable.sol\";\nabstract contract Lockable is Approvable {    \n    using SetLockable for LockableData; \n    LockableData lockable;\n\n    function custodianOf(uint256 id)\n        public\n        view\n        returns (address)\n    {             \n        return lockable.findCustodian(ownerOf(id));\n    }     \n\n    function lockWallet(uint256 id) public {           \n        revokeApprovals(ownerOf(id));\n        lockable.lockWallet(ownerOf(id));\n    }\n\n    function unlockWallet(uint256 id) public {              \n        lockable.unlockWallet(ownerOf(id));\n    }    \n\n    function _forceUnlock(uint256 id) internal {  \n        lockable.forceUnlock(ownerOf(id));\n    }    \n\n    function setCustodian(uint256 id, address custodianAddress) public {       \n        lockable.setCustodian(custodianAddress,ownerOf(id));\n    }\n\n    function isLocked(uint256 id) public view returns (bool) {     \n        return lockable.lockableStatus[ownerOf(id)].isLocked;\n    } \n\n    function lockedSince(uint256 id) public view returns (uint256) {     \n        return lockable.lockableStatus[ownerOf(id)].lockedAt;\n    }     \n\n    function validateLock(uint256 tokenId) internal view {\n        if (isLocked(tokenId)) {\n            revert WalletLockedByOwner();\n        }\n    }\n}"
    },
    "contracts/LockableTransferrable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./Lockable.sol\";\nimport { LockableStatus,InvalidTransferRecipient,ContractIsNot721Receiver } from \"./SetLockable.sol\";\n\n\n\nabstract contract LockableTransferrable is Lockable {  \n    using Address for address;\n\n    function approve(address to, uint256 tokenId) public virtual override {  \n        validateLock(tokenId);\n        super.approve(to,tokenId);      \n    }  \n\n    function setApprovalForAll(address operator, bool approved) public virtual override {           \n        validateLock(tokensOwnedBy(msg.sender)[0]);\n        super.setApprovalForAll(operator,approved);     \n    }        \n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {        \n        validateApprovedOrOwner(msg.sender, tokenId);\n        validateLock(tokenId);\n        _transfer(from,to,tokenId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n                \n        if(to == address(0)) {\n            revert InvalidTransferRecipient();\n        }\n\n        revokeTokenApproval(tokenId);   \n\n        if (enumerationExists(tokenId)) {\n            swapOwner(from,to,tokenId);\n        }\n        \n        packedTransferFrom(from, to, tokenId);\n\n        completeTransfer(from,to,tokenId);    \n    }   \n\n    function completeTransfer(\n        address from,\n        address to,\n        uint256 tokenId) internal {\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }    \n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        validateApprovedOrOwner(msg.sender, tokenId);\n        validateLock(tokenId);\n        _safeTransfer(from, to, tokenId, data);\n    }     \n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        if (!_checkOnERC721Received(from, to, tokenId, data)) {\n            revert ContractIsNot721Receiver();\n        }        \n        _transfer(from, to, tokenId);\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert InvalidTransferRecipient();\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }    \n\n}"
    },
    "contracts/Mintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport \"./LockableTransferrable.sol\";\nimport { TokenOwnership } from \"./SetOwnerEnumerable.sol\";\nerror InvalidRecipient(address zero);\nerror TokenAlreadyMinted(uint256 tokenId);\nerror InvalidToken(uint256 tokenId);\nerror MintIsNotLive();\n\nabstract contract Mintable is LockableTransferrable {  \n\n    mapping(address => mapping(uint256 => bool)) claimed; \n\n    bool isLive;\n\n    function setMintLive(bool _isLive) public onlyOwner {\n        isLive = _isLive;\n    }\n\n    function hasBeenClaimed(uint256 tokenId, address addressed) public view returns (bool) {\n        return claimed[addressed][tokenId];\n    }\n\n    function claim(uint256 tokenId, address addressed) internal {\n        claimed[addressed][tokenId] = true;\n    }\n\n    function getSenderMints() internal view returns (uint256) {\n        return numberMinted(msg.sender);\n    }\n\n    function _mint(address to, uint256 quantity, bool enumerate) internal virtual returns (uint256) {\n        if (!isLive) {\n            revert MintIsNotLive();\n        }\n        if (to == address(0)) {\n            revert InvalidRecipient(to);\n        }\n        \n        return enumerate ? enumerateMint(to, quantity) : packedMint(to, quantity);\n    }\n}"
    },
    "contracts/Nameable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\n\nabstract contract Nameable is IERC721Metadata {   \n    string named;\n    string symbolic;\n\n    constructor(string memory _name, string memory _symbol) {\n        named = _name;\n        symbolic = _symbol;\n    }\n\n    function name() public virtual override view returns (string memory) {\n        return named;\n    }  \n\n    function symbol() public virtual override view returns (string memory) {\n        return symbolic;\n    }          \n      \n}"
    },
    "contracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    error CallerIsNotOwner(address caller);\n    error OwnerCannotBeZeroAddress();\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(msg.sender);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != msg.sender) {\n            revert CallerIsNotOwner(msg.sender);\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if(newOwner == address(0)) {\n            revert OwnerCannotBeZeroAddress();\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    \n}\n"
    },
    "contracts/OwnerEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport { SetOwnerEnumerable, OwnerEnumerableData, TokenNonOwner, InvalidOwner, TokenOwnership } from \"./SetOwnerEnumerable.sol\";\nimport { PackableOwnership } from \"./PackableOwnership.sol\";\n\n\nabstract contract OwnerEnumerable is PackableOwnership {  \n    using SetOwnerEnumerable for OwnerEnumerableData;\n    OwnerEnumerableData enumerable;      \n\n    function tokensOwnedBy(address holder) public view returns (uint256[] memory) {\n        return enumerable.findTokensOwned(holder);\n    }\n\n    function enumeratedBalanceOf(address owner) public view virtual returns (uint256) {\n        validateNonZeroAddress(owner);\n        return enumerable.ownedTokens[owner].length;\n    }   \n\n    function validateNonZeroAddress(address owner) internal pure {\n        if(owner == address(0)) {\n            revert InvalidOwner();\n        }\n    }\n    \n    function enumerateToken(address to, uint256 tokenId) internal {\n        enumerable.addTokenToEnumeration(to, tokenId);\n    }\n\n    function enumerateMint(address to, uint256 quantity) internal returns (uint256) {\n        uint256 start = minted()+1;\n        uint256 end = packedMint(to,quantity);\n        for (uint256 i = start; i <= end; i++) {\n            enumerateToken(to, i);\n        }\n        return end;\n    }\n\n    function enumerateBurn(address from, uint256 tokenId) internal {\n        enumerable.addBurnToEnumeration(from, tokenId);\n        enumerable.removeTokenFromEnumeration(from, tokenId);\n    }\n\n    function swapOwner(address from, address to, uint256 tokenId) internal {\n        enumerable.removeTokenFromEnumeration(from, tokenId);\n        enumerable.addTokenToEnumeration(to, tokenId);\n    }\n    \n    function enumerationExists(uint256 tokenId) internal view virtual returns (bool) {\n        return enumerable.tokens[tokenId].exists;\n    }    \n\n    function selfDestruct(uint256 tokenId) internal {\n        delete enumerable.tokens[tokenId];\n    }    \n}"
    },
    "contracts/PackableOwnership.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport { FlexibleMetadata } from \"./FlexibleMetadata.sol\";\nimport { PackableData, SetPackable } from \"./SetPackable.sol\";\n\n\nstruct TokenApproval {\n    address approval;\n    bool exists;\n}\n\nabstract contract PackableOwnership is FlexibleMetadata {\n    using SetPackable for PackableData;\n    PackableData packable;\n\n    constructor() {\n        packable._currentIndex = packable._startTokenId();     \n    } \n     \n\n\n    function numberMinted(address minter) public view returns (uint256) {\n        return packable._numberMinted(minter);\n    }\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        return packable.ownerOf(tokenId);\n    }\n\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        return packable.balanceOf(owner);\n    }         \n       \n    function totalSupply() public view virtual returns (uint256) {\n        return packable.totalSupply();\n    }    \n       \n    function minted() internal view virtual returns (uint256) {\n        return packable._currentIndex;\n    }\n    function exists(uint256 tokenId) internal view returns (bool) {\n        return packable._exists(tokenId);\n    }\n    function packedTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        packable.transferFrom(from,to,tokenId);\n    }\n    function packedMint(address to, uint256 quantity) internal returns (uint256) {\n        return packable._mint(to,quantity);\n    }\n    function packedBurn(uint256 tokenId) internal  {\n        packable._burn(tokenId);\n    }\n    /**\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    // function getAux(address owner) public view returns (uint32[2] memory) {\n    //     return packable.unpack64(packable._getAux(owner));\n    // }\n\n    function getAux16(address owner) internal view returns (uint16[4] memory) {\n        return packable.getAux16(owner);\n    }    \n    // function getAux8(address owner) public view returns (uint8[8] memory) {\n\n    //     uint32[2] memory pack32 = packable.unpack64(packable._getAux(owner));\n        \n    //     uint16[2] memory pack16a = packable.unpack32(pack32[0]);\n        \n    //     uint8[2] memory pack8a1 = packable.unpack16(pack16a[0]);\n    //     uint8[2] memory pack8a2 = packable.unpack16(pack16a[1]);\n        \n    //     uint16[2] memory pack16b = packable.unpack32(pack32[1]);\n        \n    //     uint8[2] memory pack8b1 = packable.unpack16(pack16b[0]);\n    //     uint8[2] memory pack8b2 = packable.unpack16(pack16b[1]);\n\n    //     return [pack8a1[0],pack8a1[1],pack8a2[0],pack8a2[1],pack8b1[0],pack8b1[1],pack8b2[0],pack8b2[1]];\n    // }    \n\n    /**\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    // function setAux(address owner, uint32[2] memory aux) internal {\n    //     packable._setAux(owner,packable.pack64(aux[0],aux[1]));\n    // }    \n\n    function setAux32(address owner, uint16[4] memory aux) internal {\n        packable._setAux(owner,packable.pack64(packable.pack32(aux[0],aux[1]),packable.pack32(aux[2],aux[3])));\n    }       \n    \n    // function setAux16(address owner, uint8[8] memory aux) internal {\n    //     packable._setAux(owner,packable.pack64(\n    //         packable.pack32(\n    //             packable.pack16(aux[0],aux[1]),\n    //             packable.pack16(aux[2],aux[3])\n    //         ),\n    //         packable.pack32(\n    //             packable.pack16(aux[4],aux[5]),\n    //             packable.pack16(aux[6],aux[7])\n    //         )\n    //     ));\n    // }        \n\n}\n"
    },
    "contracts/Phaseable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport { SetPhaseable, PhaseableData, MintIsNotAllowedRightNow, ExceedsMaxSupply, Phase } from \"./SetPhaseable.sol\";\nimport { OwnerEnumerable } from \"./OwnerEnumerable.sol\";\nimport \"./Mintable.sol\";\n\n\nabstract contract Phaseable is Mintable {  \n    using SetPhaseable for PhaseableData;\n    PhaseableData phaseables;    \n    \n    function canMint(uint256 phase, uint256 quantity) internal virtual returns(bool);\n\n    function initialize(Phase[] storage phases, uint256 maxSupply) internal {\n        phaseables.initialize(phases,maxSupply);\n    }\n\n    function phasedMint(uint256 phase, uint256 quantity, bool enumerate) internal returns (uint256) {\n        if (!canMint(phase, quantity)) {\n            revert MintIsNotAllowedRightNow();\n        }        \n        if (minted()+quantity > phaseables.getMaxSupply()) {\n            revert ExceedsMaxSupply();\n        }        \n        return _mint(msg.sender,quantity,enumerate);        \n    }\n\n    function airdrop(address recipient, uint256 quantity, bool enumerate) public onlyOwner {        \n        if (minted()+quantity > phaseables.getMaxSupply()) {\n            revert ExceedsMaxSupply();\n        }\n        _mint(recipient,quantity, enumerate);\n    }\n\n    function activePhase() internal view returns (uint256) {\n        return phaseables.getActivePhase();\n    }\n\n    function nextPhase() public onlyOwner {\n        phaseables.startNextPhase();\n    }\n\n    function previousPhase() public onlyOwner {\n        phaseables.revertPhase();\n    }    \n\n    function getPhases() internal view returns (Phase[] storage) {\n        return phaseables.getPhases();\n    }\n\n    function findPhase(uint256 phaseId) internal view returns (Phase memory) {\n        return phaseables.findPhase(phaseId);\n    }\n\n    function updatePhase(uint256 phaseId, Phase memory phase) internal {\n        Phase[] storage existing = phaseables.getPhases();\n        existing[phaseId] = phase;\n    }    \n\n    function getMaxSupply() internal view returns (uint256) {\n        return phaseables.getMaxSupply();\n    }  \n\n    function setMaxSupply(uint256 newMax) internal {\n        phaseables.setMaxSupply(newMax);\n    }    \n\n}"
    },
    "contracts/RiteOfTheGuardian.sol": {
      "content": "/**\n *   .......................................';,..'lkOxxxkOx:'..:;........................................\n *   ....................,xl.................';..:KMMMMMMMW0,.,,..................,;.....................\n *   ..................;cxkkl:;...............';..lXMMMMMMK:.;,..............''..,:c;....................\n *   .................lxlxKOoxx,...............,:..:0WMMWO,.;:...............,;ccclldl,,.................\n *   .................';,lKx;,'...............',',..,ONNx'.',;,...............,o0000OOd;..,;.............\n *   ..................':kxxd::;.............,'......'co;......;'.........';cd0XNNNNNXKxlc;..............\n *   ...............,odooxxxxodkxc..........',.......:kKOc......,........,,'c0XNNWWWNNXXOl;,;'...........\n *   ..............;kOx,.;OKc..dOx;.......';........lOl'l0o......;,....'.';cd0XNWMWWMWXKOl:,,............\n *   ..............':cl:.,0Nl.;c;,........,'......'dk;';';kx,.....''........cKNNNWWWWNXNOc...............\n *   .................';.:XMk'..........;;.......,xd':0NO;'dk;.....;;....';;cdOKKXXXXXNKc,;,'............\n *   ....................dNNX:..........'.......:kl.:dk0xo:.lOl......,'......:dkkxOO0Odkc................\n *   ...................;kocko'.......;,.......lO:.cl:okxcll.:Od......;'....',;;;,;',:.,:................\n *   ...........''....';xklc,'......',.......'dk;'lc:o;.,occl',kk,.....,,...'.....;c:,;......',,,'.......\n *   ......,;;:ooc::lclol0Nd'.......;'......,kx''oc:o,...'lcco'.dO:.....,........,dXXdc:,,::::ldl:::,....\n *   ....,ll:;,c:',:ldd;:o;.......,,.......cOo.,o:co,......ll:o;.lOl.....';........,dd;cxdl::,:o;':llc,..\n *   ...:c:cl;.:;.,co::xl........''.......ok:.;o;l0c.......,Od;o:.:Od'....''.........''::'::c:co''cl::o;.\n *   ..;c,;'.,;ol;'.':;oc.......;,......,xx,.:l;lodc.......;dol:oc.,kk,.....;'........,l;;'.,lkkc;'.:;lo.\n *   ..cdc:;;;cOk:,,;lcoc.....',.......:Oo.'ll:oc.ll.......:l.:o:ll,,dOc.....,'.......;dc::;;ck0d:;;llod'\n *   ..;c',,.',cc,'.,;;l,....';....,;:dKk:lkl:o;..cl.......cl..;o:lklc0Xdcc;..,,......'l;';.''cl,,.':;cl.\n *   ...c:'cdc':;.:l:;c;....,'.....cXWXd,:o::o,...co. .....ll...,o::l,cKWWKc...',......,locc:.:l';lc:cc..\n *   ....,ccc:;lc;::::'....,;......cKXdlxOlcl'....lkl:::::ckl....'lloOdlkXk;.....;,......clll;lo:cccc,...\n *   ......';;;cc;;,.....,;.......cOocccloOOl..'ccokc.....ckdc:..'lOklo:;:lOc.....,'.......,;;::;;;......\n *   ...................';.......oOc..lo,ll;cloo:..o:.....:o'.:ool;,lc,o:..:Oo.....;;....................\n *   ..................:,......'xO;..lc,ll...:d'...ll.....lc...,d:...cc,lc..;kd'.....'...................\n *   .................''......,kx,.'dd:dx;;,ckd;:::dOdodoxOo;;;;dkc;:lkolOl..,xk,....';'.................\n *   ...............',.......;Od..;odk0d:;;;lkl;;;;;oXMMMXo,,,,,cxl,:dxkkcol..'xO;.....',................\n *   ..............,........:Oo..:o,'kO'....'o;......lXMNl......;d,..;o:lc.:o'..oOc.....,,...............\n *   .............,,.......lOc..:o'.l0d......co.......oXx'.....'o:....o:.oc.:o,..cOl......;,.............\n *   ...........,;........dk;..ll..lcco'......co,.....:ko.....:o:.....lc..ol.;o,..:Od'.....''............\n *   ...........'.......'xx,..ll..ll..oc.......,cc:,..:ko'.;clc'.....,o;...ol.;d;..,kk,.....;;...........\n *   .........;;.......,kd'.'oc..ol...:ko........';:::d0kc::,........dk;....ll.,o:..'xO;......''.........\n *   .......','.......:Oo..,o:..oc..:cc:cl:...........cOo..........,lc;:c:,..co.'oc...oOc.....';.........\n *   ......':,.......lOc..;o;.'do:oxd:,,,:dxo;,;,,,,,,o0d;,,,;;;,cdko::;cdOxlcxd..ol...cOl.......,.......\n *   .....;:........dk;..:o,.'kKdllc:::::::clclkko:::;d0x:;;cokxlc::;;;;;;;::lxx:..ll...:Od......,,......\n *   ....;;.......'xx,..co'.:oo;................,'....:Ol....;;................,:c:,co,..,kx'......,,....\n *   ...:;.......;kd...lxlloc,.................''.....l0d,.'.''''''...''''''''''',codkk:..'xk,......;,...\n *   .':,.......:kl...;oddoc:::::::::::::::::::::::clcdKklol::::::::::::cccccccccccclooc....oO:......;:..\n *   ,:'.......:00xddddddddoooooooooooooooooloolloldkk0NKOOxlllllllllllllllllllllllllllloollo0Kc......''.\n *   :.........',,,,,,,,,,'','''','','',,,,,,,,,,;,,,oXMNx;,;;;;;:;;;;::::::::::::::::ccccccccc;........,\n *   ,.','.',..';,'.;;..;,..,.''.'.''.''.'.''.'.',....:xl....''.',.','''.'.''.''.,.''.'.',.'''..,,..''..;\n *   ...........,d:.l:.ol.......................,'...........,...........................................\n *   ...........'ol:kx:oc.................;dl::c00l;:ldxl:;ckKo::cxx,.................'coddolc'..........\n *   ............c::Ox,::..................ld,.lxkd'.:KMk'.lkkd'.cd;.................;kKkocldOOc.........\n *   ............cc:kd;l;...................cddccx0kclddxlokxddddl'..................xKk:.;',d0k,........\n *   ...............oc......................,k0:,llkXo. ;00:;llO0;..................;OOc:;';;cOO:........\n *   ...............oc.....................;xl;dl.:odxoldooo,cxccx:.................:Kk',:;;.;O0:........\n *   ...............oc....................c0x:;lO0Ol;dXWk;:kK0o;:d0c................:Kk;lO0kcl0x'........\n *   ...............oc....................;c:::::dOodOdokxoOxc:c::c;.................d0xdxkxdx0l.........\n *   ...............ox:ld,........................cxd;..'dkl.........................'lxkOOOkd:..........\n *   ...............oxcdx;.........................ll....;l'............................;clc,............\n\n */\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"./RitualBindings.sol\";\n\nerror MarkedByGuardian(uint256 tokenId);\nerror ReachingBeyondAbility();\nerror Unphased();\nerror Impostor();\nerror AlreadyInscribed();\nerror UnacceptableOffering(uint256 cost, uint256 amount);\nerror ElderAlreadyClaimed(uint256 elder);\n\n\ncontract RiteOfTheGuardian is RitualBindings {    \n\n    uint256 constant UNDEAD_KEY = 0;\n    uint256 constant MORTAL_KEY = 1;\n\n    uint256 inscriptionCost = .05 ether;\n\n    mapping(string => uint256[]) scribe;\n\n    constructor(string memory invocation, string memory seal) RitualBindings(invocation,seal) {}\n\n    function pactWithCharun(address pact) external onlyOwner {\n        invokeCharun(pact);        \n    }        \n\n    function pactWithElders(address pact) external onlyOwner {\n        consumeElders(pact);\n    }\n\n    function pactOfSustenance(address pact) external onlyOwner {\n        consumeBrainz(pact);\n    }\n\n    function bestowBountyOfCharun(address recipient, uint256 quantity) internal {\n        \n        uint256 bounty = quantity * 1000 * (10**18);\n        if (ResidualBrainz(seekBrainz()).balanceOf(address(this)) > bounty) {\n            ResidualBrainz(seekBrainz()).transfer(recipient,bounty);\n        }\n    }\n\n    function elderRitual(uint64 quantity, uint256[] memory elders, bytes calldata sigil) external \n    requiresClaimSig(sigil,msg.sender,elders) {\n        for (uint i = 0; i < elders.length; i++) {\n            if (hasBeenClaimed(elders[i], findElders())) {\n                revert ElderAlreadyClaimed(elders[i]);\n            }\n            \n            claim(elders[i], findElders());\n        }\n        \n        phasedMint(ELDER, quantity, false);\n        \n        bestowBountyOfCharun(msg.sender,quantity);\n\n        markGuardian(ELDER,quantity);\n    }  \n\n    function initiateRitual(uint256 quantity, bytes calldata sigil) external \n    requiresAllowSig(sigil,msg.sender) {\n        Phase memory phased = findPhase(INITIATE);\n        \n        giveCharunHisBrainz(phased.cost, quantity);\n        \n        phasedMint(INITIATE, quantity, false);\n\n        markGuardian(INITIATE,quantity);\n    }      \n\n    function acolyteRitual(uint256 quantity, bytes calldata sigil) external payable\n    requiresAllowSig(sigil,msg.sender) {\n        Phase memory phased = findPhase(ACOLYTE);\n        \n        giveCharunHisCoin(phased.cost, quantity);\n        \n        phasedMint(ACOLYTE, quantity, false);\n\n        bestowBountyOfCharun(msg.sender,quantity);\n\n        markGuardian(ACOLYTE,quantity);\n    }   \n\n    function ritualPhase(uint256 quantity, uint256 phase) external payable {\n\n        Phase memory phased = findPhase(phase);\n\n        giveCharunHisCoin(phased.cost, quantity);\n\n        phasedMint(phase, quantity, false);\n\n        bestowBountyOfCharun(msg.sender,quantity);\n\n        markGuardian(phase,quantity);  \n    }  \n\n    function necrophize(uint256 tokenId) public {\n        if (!canTransform(NECRO)) {\n            revert ReachingBeyondAbility();\n        }\n        validateApprovedOrOwner(msg.sender, tokenId);  \n\n        setSupplemental(tokenId, true, UNDEAD_KEY);\n\n        if (!enumerationExists(tokenId)) {\n            enumerateToken(msg.sender, tokenId);\n        }\n    }\n    function judgement(uint256 scriptClass,uint256 tokenId) private view {\n        if (!canInscribe(scriptClass,tokenId)) {\n            revert ReachingBeyondAbility();\n        }\n        if (inscriptionRequestExists(scriptClass,tokenId)) {\n            revert AlreadyInscribed();\n        }  \n    }\n    function necroscribe(uint256 tokenId, string memory btcAddress) external payable {\n        judgement(NECRO,tokenId);\n        necrophize(tokenId);\n      \n        \n        giveCharunHisCoin(inscriptionCost,1);\n\n        script(NECRO,tokenId,btcAddress);    \n    }  \n\n    function vitalize(uint256 tokenId) public {\n        if (!canTransform(MORTAL)) {\n            revert ReachingBeyondAbility();\n        }\n        validateApprovedOrOwner(msg.sender, tokenId);  \n\n        setSupplemental(tokenId, false, UNDEAD_KEY);\n    }   \n\n    function vitascribe(uint256 tokenId, string memory btcAddress) external payable {\n        judgement(MORTAL,tokenId);\n\n        vitalize(tokenId);\n\n        giveCharunHisCoin(inscriptionCost,1);\n\n        script(MORTAL,tokenId,btcAddress);    \n    }  \n\n\n    function inscribe(string memory inscription, uint256 inscriptionClass, uint256 tokenId) external onlyOwner {\n        inscript(inscription,inscriptionClass,tokenId);\n    }\n\n    function sacrifice(uint256 tokenId) external {\n\n        validateApprovedOrOwner(msg.sender, tokenId);\n        \n        validateLock(tokenId);   \n\n        if (enumerationExists(tokenId)) {\n            enumerateBurn(msg.sender,tokenId);\n            selfDestruct(tokenId);\n        }\n\n        packedBurn(tokenId);\n    }  \n\n    function isWorthyOffering(uint256 cost, uint256 quantity) internal view {        \n        if (msg.value != (cost*quantity)) {\n            revert UnacceptableOffering(cost*quantity, msg.value);\n        }\n    } \n\n    function giveCharunHisCoin(uint256 cost, uint256 quantity) internal {   \n        isWorthyOffering(cost,quantity);           \n        (summonCharun()).transfer(cost*quantity);\n    }      \n    function giveCharunHisBrainz(uint256 cost, uint256 quantity) internal {   \n        ResidualBrainz(seekBrainz()).transferFrom(msg.sender, summonCharun(), quantity*cost*(10**18));          \n    }\n}\n\n/**\n * Ordo Signum Machina - 2023\n */"
    },
    "contracts/RitualBindings.sol": {
      "content": "/**\n                                               cNX:                                                  \n                                             ;0Xkdd,                                                \n                                            :kOOxdxx:                                               \n                                          .cooc.ckddxc.                                             \n                                         .llcl.  ;xxxOd.                                            \n                                        .oc;l'     :KK0x'                                           \n                                       .dc,o;    .,ldxxxk;                                          \n                                      'd:.oc    .lOl..odokc                                         \n                                     ,d:.ll.  ..dx:,...ldoOo.                                       \n                                    ,d:.o0d::::l0Oolcc:cOOdOx.                                      \n                                   ;0kc::,..    'lll:.  .,;lOk;.                                    \n                                 ,loc.    ..';;:codxxc'.    .,coc.                                  \n                              .;oc.  .';:::::,;ccc:c:;:::::'.  .;ol.                                \n                             ;dc. .;cc:;.     .colc;.    .'::cc'  ;d:.                              \n                           .lx'.,ll:.     .',:ddlllol:,.     .;ll:..oo.                             \n                          .od',ol'    .;cccc:cko.,:xx:cccc:.    .co:'od.                            \n                          ck:od'   .;ol:.     .dKOd:.    .:ol,    .ldcxo.                           \n                         'OOxc   .:oc.    .';:ododxoc:,.    ,lo,    'dO0:                           \n                      .. cN0;   .ol.    ,lcc;,dxcdkc';:cl:.   'ol.   .dNx...                        \n                     ,Ox'oX:   'xc    'ol'    .,:'.     .co;   .ld.   .O0lk0,                       \n                    :kdk0Ko   .dl    ;x;                  .dl.  .oo.   cXNxdO:                      \n                  .ok:lkK0,   :kl;' ,x;       '::::,       ,k:   :0:   ,0Xx,;ko.                    \n                 .dd;ox,ck;,::do:oxdxklc.   ,ol;,;:ld,   'co0x;clxXk:ccd0olk,'dx'                   \n                'dkldd. ,Okl:l0kxklokockl  'x:      lx.  lxoko,dkd0k'..dXc ckc;xk;                  \n               ;o,:0O;  .kx.  lkl:..o0o,.  .dl.    .dd.  .,x0; ,:;x:   cO, .dXx.,xc                 \n              :o''o:':c' ck'  ;x'   'x:     .clclccl:.    .od.   :x.  .ko.;l;:ko..do.               \n            .ll.;d;   'lc,do.  ld.   ;x;       .'..      .od.   'x:  .dOol;.  .xd..ox'              \n           .o:.:d'      'cxKd. .ld.   'ol'      .      .:oc.   .dl  .oXO:.     .dx'.cx,             \n          ,o,.co.         ,xXO;  ;d:.   ,ccc::llcodl;;cc:.    ,d:  .x0l.        .lk; ;x:            \n        .co'.oo.            ;0Ko, .co:.   ..,o0: lNO;..     ,lo' .c00;            :Oc 'xl.          \n       .oo.'xx,.......'''''',o0Okdc..:ll;.    :xkxd,    .':ol,.,lok0c..............l0l..do.         \n      .okookOkkkxxxkOOOOkkkxxxxxdxOxlc;:cccclld0OOOdccccccc::ldKKk0KOOOOOOkkkxkkO000XXkox0d.        \n          .................         .;lllccllldkcd0xllllclllc'..'''''''''.......''''''.....         \n                                        .';cccokkkkdllc:,.                                          \n                                         .,ccclokxllc;,,'.                                          \n                                      .,c:;,....:,    .';cc,.                                       \n                                    .;c;.  ''   ..    .. .'cl'                                      \n                                   .cl.  .':x:       ;c'.   :d;                                     \n                                  .:c.   .,;lkd::;;ckOl;,.   ;l'                                    \n                                  ;o'        ;x, ..lk'       .l;                                    \n                                  :l.        .ol .:xc        .:c.                                   \n                                  :o.         ld.;kk;        .:o'                                   \n                                  'o:        .ol 'ox;        .lc.                                   \n                                   ,l'    .''oOl;clkd,'..   .;;.                                    \n                                    'c,  .''lx;....'l:...  'l;                                      \n                                     .cl,  ';.  .    .  .'cl;.                                      \n                                       .;;::;,.:d:..'',::,..                                        \n                                         ..':od:,cdo:...                                            \n                                           .,cxl;ok:                                                \n                                            ,:';;,,;.                                               \n                                           ',. ',   ,,                                              \n                                         .'.  .lo'   .;;:'                                          \n                                      .,lc. .;l0Kdl;. .x0o.                                         \n                                      .cd;.'cd0NXOOxl. 'l;                                          \n                                     .,'cl;:oxxKKddlc:;c:',.                                        \n                                    ',. ;o:,;cdKXko:'':o; .,.                                       \n                                  .;'   .;cc:xKNN0xd:;c:.   ''                                      \n                                 .oo;;;. ...c0XxxO0Kd,'...  .,;.                                    \n                                ,okkkdllll:..od..o0d',oollocldl;.                                   \n                              .:dkkxxoodllkl .:..,,..;lloddlcl:.',.                                 \n                             ,;.:kxl;:o:ckk:.':;;;,. 'oddoodxd:. .,.                                \n                           .::..,c;..'ccld:'.,;ll,,'..::;;'',,....,:.                               \n                           .'..........'''...',:c'..             ...:,                              \n\n */\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport \"./EIP712Allowlisting.sol\";\nimport \"./Phaseable.sol\";\nimport \"./FlexibleMetadata.sol\";\nimport \"./Nameable.sol\";\nimport { Phase, PhaseNotActiveYet, PhaseExhausted, WalletMintsFilled } from \"./SetPhaseable.sol\";\nimport { SetInscribable, InscribableData, Script } from \"./SetInscribable.sol\";\n\ninterface ElderBond {    \n    function ownerOf(uint256 tokenId) external view returns (address);\n}\n\ninterface ResidualBrainz {    \n    function balanceOf(address account) external view returns (uint256);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function transfer(address to, uint256 amount) external;\n}     \ncontract RitualBindings is EIP712Allowlisting {  \n    using SetInscribable for InscribableData;      \n    InscribableData inscribable;\n\n    address payable treasury;\n    address currency;\n    address legacy;\n\n    uint64 constant ELDER = 0;\n    uint64 constant INITIATE = 1;\n    uint64 constant ACOLYTE = 2;\n    uint64 constant OPEN = 3;\n    uint256 constant NECRO = 0;\n    uint256 constant MORTAL = 1; \n  \n\n    constructor(string memory name, string memory symbol) FlexibleMetadata(name,symbol) {\n        setSigningAddress(msg.sender);\n        setDomainSeparator(name, symbol);\n        Phase[] storage phases = getPhases();\n                          \n        phases.push(Phase(ELDER, 32, 381, 0));\n        phases.push(Phase(INITIATE, 2, 441, 2500)); // BRAINZ\n        phases.push(Phase(ACOLYTE, 3, 891, .02 ether)); // eth (480 after phases 1 & 2)\n        phases.push(Phase(OPEN, 4, 1002, .04 ether)); // eth (111 after phases 1, 2, 3)\n        \n        initialize(phases,1002);\n    }\n\n    function isOsmRegisted(uint256 tokenId) external view returns (bool) {\n      return enumerationExists(tokenId);\n    }\n\n    function summonCharun() internal view returns (address payable) {\n      return treasury;\n    }\n    function invokeCharun(address charun) internal {\n      treasury = payable(charun);\n    }\n    function seekBrainz() internal view returns (address) {\n      return currency;\n    }\n    function consumeBrainz(address brainz) internal {\n      currency = brainz;\n    }\n    function findElders() internal view returns (address) {\n      return legacy;\n    }\n    function consumeElders(address elders) internal {\n       legacy = elders;\n    }\n\n    function markGuardian(uint256 phase, uint256 quantity) internal {\n      uint16[4] memory aux = getAux16(msg.sender);\n      aux[phase] = uint16(quantity);\n      setAux32(msg.sender,aux);\n    }\n\n    function canMint(uint256 phase, uint256 quantity) internal override virtual returns(bool) {\n        uint256 activePhase = activePhase();\n        if (phase > activePhase) {\n            revert PhaseNotActiveYet();\n        }\n        uint256 requestedSupply = minted()+quantity;\n        Phase memory requestedPhase = findPhase(phase);\n        if (requestedSupply > requestedPhase.highestSupply) {\n            revert PhaseExhausted();\n        }\n        uint16[4] memory aux = getAux16(msg.sender);\n        uint256 requestedMints = quantity + aux[phase];\n\n        if (requestedMints > requestedPhase.maxPerWallet) {\n            revert WalletMintsFilled(requestedMints);\n        }\n        return true;\n    }\n\n    function script(uint256 scriptClass, uint256 tokenId, string memory btcAddress) internal {\n      inscribable.script(scriptClass,tokenId,btcAddress);\n    }    \n    function retrieveRequests(uint256 scriptClass) external view returns (Script[] memory) {\n      return inscribable.retrieveRequests(scriptClass);\n    }    \n    function inscript(string memory inscription, uint256 scriptClass, uint256 tokenId) internal {\n      inscribable.inscribe(scriptClass,inscription,tokenId);\n    }\n    function findInscription(uint256 scriptClass, uint256 tokenId) public view returns (string memory) {\n      return inscribable.findInscription(scriptClass,tokenId);\n    }\n    function inscriptionRequestExists(uint256 scriptClass, uint256 tokenId) public view returns (bool) {\n      return inscribable.inscriptionRequestExists(scriptClass,tokenId);\n    }\n    function openInscription(uint256 scriptClass) public onlyOwner {\n      inscribable.setInscribable(scriptClass,true);\n    }\n    function canInscribe(uint256 scriptClass, uint256 tokenId) public view returns (bool) {\n      return (inscribable.inscribable(scriptClass) &&! inscribable.inscriptionRequestExists(scriptClass,tokenId));\n    }\n    function canTransform(uint256 scriptClass) internal view returns (bool) {\n      return (inscribable.inscribable(scriptClass));\n    }\n}\n\n/**\n * Ordo Signum Machina - 2023\n */"
    },
    "contracts/SetApprovable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nstruct ApprovableData { \n\n    mapping(address => uint256) contractApprovals;\n    mapping(address => address[]) approvedForAll;\n    mapping(address => mapping(address => uint256)) approvedForAllIndex;\n\n    mapping(uint256 => uint256) tokenApprovals;\n    mapping(uint256 => TokenApproval[]) approvedForToken;\n    mapping(uint256 => mapping(address => uint256)) approvedForTokenIndex;\n\n    mapping(uint256 => TokenApproval) tokens;\n\n    bool exists;\n}    \n\nstruct TokenApproval {\n    address approval;\n    bool exists;\n}\n\nerror AlreadyApproved(address operator, uint256 tokenId);\nerror AlreadyApprovedContract(address operator);\nerror AlreadyRevoked(address operator, uint256 tokenId);\nerror AlreadyRevokedContract(address operator);\nerror TokenNonExistent(uint256 tokenId);\n\n\nlibrary SetApprovable {     \n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);    \n\n    function isApprovedForAll(ApprovableData storage self, address owner, address operator) public view returns (bool) {        \n        return self.approvedForAll[owner].length > self.approvedForAllIndex[owner][operator] ? \n            (self.approvedForAll[owner][self.approvedForAllIndex[owner][operator]] != address(0)) :\n            false;\n    }   \n\n    function revokeApprovals(ApprovableData storage self, address owner, uint256[] memory ownedTokens) public {            \n        \n        for (uint256 i = 0; i < ownedTokens.length; i++) {\n            revokeTokenApproval(self,ownedTokens[i]);\n        }\n        \n        address[] memory contractApprovals = self.approvedForAll[owner];\n        for (uint256 i = 0; i < contractApprovals.length; i++) {\n            address approved = contractApprovals[i];    \n            revokeApprovalForContract(self, approved, owner);             \n        }\n    }   \n\n    function revokeTokenApproval(ApprovableData storage self, uint256 token) public {            \n        TokenApproval[] memory approvals = self.approvedForToken[token];\n        for (uint256 j = 0; j < approvals.length; j++) {\n            revokeApprovalForToken(self, approvals[j].approval, token);\n        }         \n    }       \n\n    function getApproved(ApprovableData storage self, uint256 tokenId) public view returns (address) {\n        return self.approvedForToken[tokenId].length > 0 ? self.approvedForToken[tokenId][0].approval : address(0);\n    }     \n\n    function approveForToken(ApprovableData storage self, address operator, uint256 tokenId) public {\n        uint256 index = self.approvedForTokenIndex[tokenId][operator];\n        if (index < self.approvedForToken[tokenId].length) {\n            if (self.approvedForToken[tokenId][index].exists) {\n                revert AlreadyApproved(operator, tokenId);\n            }            \n        }\n   \n        self.approvedForToken[tokenId].push(TokenApproval(operator,true));\n        self.approvedForTokenIndex[tokenId][operator] = self.approvedForToken[tokenId].length-1;\n        self.tokenApprovals[tokenId]++;\n        \n        emit Approval(msg.sender, operator, tokenId); \n    } \n\n    function revokeApprovalForToken(ApprovableData storage self, address revoked, uint256 tokenId) public {\n        uint256 index = self.approvedForTokenIndex[tokenId][revoked];\n        if (!self.approvedForToken[tokenId][index].exists) {\n            revert AlreadyRevoked(revoked,tokenId);\n        }\n        \n        // When the token to delete is not the last token, the swap operation is unnecessary\n        if (index != self.approvedForToken[tokenId].length - 1) {\n            TokenApproval storage tmp = self.approvedForToken[tokenId][self.approvedForToken[tokenId].length - 1];\n            self.approvedForToken[tokenId][self.approvedForToken[tokenId].length - 1] = self.approvedForToken[tokenId][index];\n            self.approvedForToken[tokenId][index] = tmp;\n            self.approvedForTokenIndex[tokenId][tmp.approval] = index;            \n        }\n\n        // This also deletes the contents at the last position of the array\n        delete self.approvedForTokenIndex[tokenId][revoked];\n        self.approvedForToken[tokenId].pop();\n\n        self.tokenApprovals[tokenId]--;\n    }\n\n    function approveForContract(ApprovableData storage self, address operator) public {\n        uint256 index = self.approvedForAllIndex[msg.sender][operator];\n        if (self.approvedForAll[msg.sender].length > index) {\n            if (self.approvedForAll[msg.sender][index] != address(0)) {\n                revert AlreadyApprovedContract(self.approvedForAll[msg.sender][index]);\n            }\n        }\n   \n        self.approvedForAll[msg.sender].push(operator);\n        self.approvedForAllIndex[msg.sender][operator] = self.approvedForAll[msg.sender].length-1;\n        self.contractApprovals[msg.sender]++;\n\n        emit ApprovalForAll(msg.sender, operator, true); \n    } \n\n    function revokeApprovalForContract(ApprovableData storage self, address revoked, address owner) public {\n        uint256 index = self.approvedForAllIndex[owner][revoked];\n        address revokee = self.approvedForAll[owner][index];\n        if (revokee != revoked) {\n            revert AlreadyRevokedContract(revoked);\n        }\n        \n        // When the token to delete is not the last token, the swap operation is unnecessary\n        if (index != self.approvedForAll[owner].length - 1) {\n            address tmp = self.approvedForAll[owner][self.approvedForAll[owner].length - 1];\n            self.approvedForAll[owner][self.approvedForAll[owner].length - 1] = self.approvedForAll[owner][index];\n            self.approvedForAll[owner][index] = tmp;\n            self.approvedForAllIndex[owner][tmp] = index;            \n        }\n        // This also deletes the contents at the last position of the array\n        delete self.approvedForAllIndex[owner][revoked];\n        self.approvedForAll[owner].pop();\n\n        self.contractApprovals[owner]--;\n\n        emit ApprovalForAll(owner, revoked, false); \n    }    \n\n}"
    },
    "contracts/SetAssignable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nstruct AssignableData { \n    mapping(uint256 => address[]) assignments;\n\n    mapping(address => mapping(uint256 => uint256)) assignmentIndex; \n\n    mapping(address => uint256) assigned;\n}    \n\nerror AlreadyAssigned(uint256 tokenId);\nerror NotAssigned(address to);\nerror NotTokenOwner();\n\ninterface Supportable {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n    function balanceOf(address owner) external view returns (uint256);\n    function ownerOf(uint256 tokenId) external view returns (address);\n    function balanceOf(address owner, uint256 tokenId) external view returns (uint256);\n}\n\nlibrary SetAssignable {\n\n    function findAssignees(AssignableData storage self, uint256 tokenId) public view returns (address[] memory) {\n        return self.assignments[tokenId];\n    }\n\n    function revokeAll(AssignableData storage self, uint256 tokenId) public {        \n        for (uint256 iterator = 0; iterator < self.assignments[tokenId].length; iterator++) {\n            address target = self.assignments[tokenId][iterator];\n            delete self.assignmentIndex[target][tokenId];\n            delete self.assigned[target];\n        }\n        while ( self.assignments[tokenId].length > 0) {\n            self.assignments[tokenId].pop();\n        }        \n    }\n\n    function iterateGuardiansBalance(AssignableData storage self, uint256[] memory guardians, address seeking, uint256 tokenId) public view returns (uint256)  {\n        uint256 balance = 0;\n        for (uint256 iterator = 0; iterator < guardians.length; iterator++) {\n            uint256 guardian = guardians[iterator];\n            balance += iterateAssignmentsBalance(self,guardian,seeking,tokenId);\n        }\n        return balance;\n    }\n\n    function iterateAssignmentsBalance(AssignableData storage self, uint256 guardian, address seeking, uint256 tokenId) public view returns (uint256)  {\n        uint256 balance = 0;\n        for (uint256 iterator = 0; iterator < self.assignments[guardian].length; iterator++) {\n            address assignment =self.assignments[guardian][iterator];\n            Supportable supporting = Supportable(seeking);\n            if (supporting.supportsInterface(type(IERC721).interfaceId)) {\n                balance += supporting.balanceOf(assignment); \n            }            \n            if (supporting.supportsInterface(type(IERC1155).interfaceId)) {\n                balance += supporting.balanceOf(assignment, tokenId); \n            }               \n        }       \n        return balance; \n    } \n\n    function addAssignment(AssignableData storage self, address to, uint256 tokenId) public {\n        uint256 assigned = findAssignment(self, to);\n        if (assigned > 0) {\n            revert AlreadyAssigned(assigned);\n        }\n        \n        self.assignments[tokenId].push(to);     \n        uint256 length = self.assignments[tokenId].length;\n        self.assignmentIndex[to][tokenId] = length-1;\n        self.assigned[to] = tokenId;\n    }    \n\n    function removeAssignment(AssignableData storage self, address to) public {\n        uint256 assigned = findAssignment(self, to);\n        if (assigned > 0) {\n            uint256 existingAddressIndex = self.assignmentIndex[to][assigned];\n            uint256 lastAssignmentIndex = self.assignments[assigned].length-1;\n            \n            if (existingAddressIndex != lastAssignmentIndex) {\n                address lastAssignment = self.assignments[assigned][lastAssignmentIndex];\n                self.assignments[assigned][existingAddressIndex] = lastAssignment; \n                self.assignmentIndex[lastAssignment][assigned] = existingAddressIndex;\n            }\n            delete self.assignmentIndex[to][assigned];\n            self.assignments[assigned].pop();\n        } else {\n            revert NotAssigned(to);\n        }\n    }\n\n    function findAssignment(AssignableData storage self, address to) public view returns (uint256) {\n        return self.assigned[to];\n    }     \n}"
    },
    "contracts/SetFlexibleMetadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nstruct FlexibleMetadataData { \n    string defaultTokenMetadata;\n    string prerevealTokenMetadata;\n    string flaggedTokenMetadata;\n    mapping(uint256 => string) supplementalTokenMetadata;\n    string contractMetadata;\n    mapping(uint256 => bool) tokenFlag;\n    mapping(uint256 => Supplement) supplemental;\n    bool tokenReveal; \n}    \nstruct Supplement {\n    uint256 key;\n    bool exists;\n}\nbytes16 constant _SYMBOLS = \"0123456789abcdef\";\nuint256 constant DEFAULT = 1;\nuint256 constant FLAG = 2;\nuint256 constant PRE = 3;\nlibrary SetFlexibleMetadata {\n    function setDefaultTokenMetadataURI(FlexibleMetadataData storage self, string memory uri) public {\n        self.defaultTokenMetadata = uri;\n    }  \n    function setPrerevealTokenMetadataURI(FlexibleMetadataData storage self, string memory uri) public {\n        self.prerevealTokenMetadata = uri;\n    }  \n    function setFlaggedTokenMetadataURI(FlexibleMetadataData storage self, string memory uri) public {\n        self.flaggedTokenMetadata = uri;\n    }  \n    function setSupplementalTokenMetadataURI(FlexibleMetadataData storage self, uint256 key, string memory uri) public {\n        self.supplementalTokenMetadata[key] = uri;\n    }      \n    function setContractMetadataURI(FlexibleMetadataData storage self, string memory uri) public {\n        self.contractMetadata = uri;\n    }  \n    function reveal(FlexibleMetadataData storage self, bool revealed) public {\n        self.tokenReveal = revealed;\n    }\n\n    function flagToken(FlexibleMetadataData storage self, uint256 tokenId, bool flagged) public {\n        self.tokenFlag[tokenId] = flagged;\n    }\n\n    function getTokenMetadata(FlexibleMetadataData storage self, uint256 tokenId) public view returns (string memory) {\n        if (self.tokenFlag[tokenId]) {\n            return encodeURI(self.flaggedTokenMetadata,tokenId);\n        } \n        if (!self.tokenReveal) {\n            return encodeURI(self.prerevealTokenMetadata,tokenId);\n        }\n        if (self.supplemental[tokenId].exists) {\n            return encodeURI(self.supplementalTokenMetadata[self.supplemental[tokenId].key],tokenId);\n        }\n        return encodeURI(self.defaultTokenMetadata,tokenId);\n    }\n\n    function getContractMetadata(FlexibleMetadataData storage self) public view returns (string memory) { \n        return self.contractMetadata;\n    }    \n\n    function encodeURI(string storage uri, uint256 tokenId) public pure returns (string memory) {\n        return string(abi.encodePacked(uri, \"/\", toString(tokenId)));\n    }\n\n    function toString(uint256 value) public pure returns (string memory) {\n        unchecked {\n            uint256 length = log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    function log10(uint256 value) public pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }        \n}"
    },
    "contracts/SetInscribable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nstruct InscribableData {\n    mapping(uint256 => mapping(uint256 => Inscription)) inscriptions;\n    mapping(uint256 => Script[]) scribe;\n    mapping(uint256 => bool) canInscribe;\n}\nstruct Script {\n    uint256 tokenId;\n    string btcAddress;\n}\nstruct Inscription {\n    string inscription;\n    string btcAddress;\n    uint256 inscriptix;\n    bool inscriptionRequestExists;\n    bool inscriptionRequested;\n}  \n\nerror AlreadyInscribed();\nerror AlreadyRequested();\n\nlibrary SetInscribable {    \n    function script(InscribableData storage self, uint256 inscriptionClass, uint256 tokenId, string memory btcAddress) public {  \n\n        if (self.inscriptions[inscriptionClass][tokenId].inscriptionRequested) {\n            revert AlreadyRequested();\n        }\n\n        self.inscriptions[inscriptionClass][tokenId] = Inscription(\"\",btcAddress,self.scribe[inscriptionClass].length,false,true);\n\n        self.scribe[inscriptionClass].push(Script(tokenId,btcAddress));  \n    }  \n\n    function inscribe(InscribableData storage self, uint256 inscriptionClass, string memory inscription, uint256 tokenId) public {\n        if (self.inscriptions[inscriptionClass][tokenId].inscriptionRequestExists) {\n            revert AlreadyInscribed();\n        }\n        if ((self.scribe[inscriptionClass].length - 1) > self.inscriptions[inscriptionClass][tokenId].inscriptix) {            \n            self.scribe[inscriptionClass][self.inscriptions[inscriptionClass][tokenId].inscriptix] = self.scribe[inscriptionClass][self.scribe[inscriptionClass].length - 1];            \n        }\n        self.scribe[inscriptionClass].pop();\n\n        delete self.inscriptions[inscriptionClass][tokenId].inscriptix;\n\n        self.inscriptions[inscriptionClass][tokenId].inscription = inscription;\n\n        self.inscriptions[inscriptionClass][tokenId].inscriptionRequestExists = true;\n    }\n\n    function retrieveRequests(InscribableData storage self, uint256 inscriptionClass) public view returns (Script[] memory) {\n        return self.scribe[inscriptionClass];\n    }\n\n    function findInscription(InscribableData storage self, uint256 inscriptionClass, uint256 tokenId) public view returns (string memory) {\n        return self.inscriptions[inscriptionClass][tokenId].inscription;\n    }\n\n    function inscriptionRequestExists(InscribableData storage self, uint256 inscriptionClass, uint256 tokenId) public view returns (bool) {\n        return self.inscriptions[inscriptionClass][tokenId].inscriptionRequestExists;\n    }\n\n    function inscribable(InscribableData storage self, uint256 inscriptionClass) public view returns (bool) {\n        return self.canInscribe[inscriptionClass];\n    }\n\n    function setInscribable(InscribableData storage self, uint256 inscriptionClass, bool _canInscribe) public {\n        self.canInscribe[inscriptionClass] = _canInscribe;\n    }\n\n}    "
    },
    "contracts/SetLockable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { InvalidOwner } from \"./SetOwnerEnumerable.sol\";\nstruct LockableData { \n\n    mapping(address => uint256) lockableStatusIndex; \n\n    mapping(address => LockableStatus) lockableStatus;  \n} \n\n\n\n\nstruct LockableStatus {\n    bool isLocked;\n    uint256 lockedAt;\n    address custodian;\n    uint256 balance;\n    address[] approvedAll;\n    bool exists;\n}\n\nuint64 constant MAX_INT = 2**64 - 1;\n\nerror OnlyCustodianCanLock();\n\nerror OnlyOwnerCanSetCustodian();\n\nerror WalletLockedByOwner();\n\nerror InvalidTransferRecipient();\n\nerror NotApprovedOrOwner();\n\nerror ContractIsNot721Receiver();\n\nlibrary SetLockable {           \n\n    function lockWallet(LockableData storage self, address holder) public {\n        LockableStatus storage status = self.lockableStatus[holder];    \n        if (msg.sender != status.custodian) {\n            revert OnlyCustodianCanLock();\n        }       \n        status.isLocked = true;\n        status.lockedAt = block.timestamp;\n    }\n\n    function unlockWallet(LockableData storage self, address holder) public {        \n        LockableStatus storage status = self.lockableStatus[holder];\n        if (msg.sender != status.custodian) {\n            revert OnlyCustodianCanLock();\n        }                   \n        \n        status.isLocked = false;\n        status.lockedAt = MAX_INT;\n    }\n\n    function setCustodian(LockableData storage self, address custodianAddress,  address holder) public {\n        if (msg.sender != holder) {\n            revert OnlyOwnerCanSetCustodian();\n        }    \n        LockableStatus storage status = self.lockableStatus[holder];\n        status.custodian = custodianAddress;\n    }\n\n    function findCustodian(LockableData storage self, address wallet) public view returns (address) {\n        return self.lockableStatus[wallet].custodian;\n    }\n\n    function forceUnlock(LockableData storage self, address owner) public {        \n        LockableStatus storage status = self.lockableStatus[owner];\n        status.isLocked = false;\n        status.lockedAt = MAX_INT;\n    }\n            \n}"
    },
    "contracts/SetOwnerEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nstruct OwnerEnumerableData { \n    mapping(uint256 => TokenOwnership) tokens;\n    mapping(address => uint256[]) ownedTokens;\n\n    mapping(address => mapping(uint256 => uint256)) ownedTokensIndex; \n\n    mapping(address => uint256[]) burnedTokens;\n\n    mapping(address => mapping(uint256 => uint256)) burnedTokensIndex; \n} \n\n\n\nstruct TokenOwnership {\n    address ownedBy;\n    bool exists;\n}\n\nerror TokenNonOwner(address requester, uint256 tokenId); \nerror InvalidOwner();\n\nlibrary SetOwnerEnumerable {\n    function addTokenToEnumeration(OwnerEnumerableData storage self, address to, uint256 tokenId) public {       \n        self.ownedTokens[to].push(tokenId);        \n        uint256 length = self.ownedTokens[to].length;\n        self.ownedTokensIndex[to][tokenId] = length-1;\n        self.tokens[tokenId] = TokenOwnership(to,true);\n    }\n\n    function addBurnToEnumeration(OwnerEnumerableData storage self, address to, uint256 tokenId) public {       \n        self.burnedTokens[to].push(tokenId);        \n        uint256 length = self.burnedTokens[to].length;\n        self.burnedTokensIndex[to][tokenId] = length-1;        \n    }    \n\n    function removeTokenFromEnumeration(OwnerEnumerableData storage self, address to, uint256 tokenId) public {\n\n        uint256 length = self.ownedTokens[to].length;\n        if (self.ownedTokensIndex[to][tokenId] > 0) {\n            if (self.ownedTokensIndex[to][tokenId] != length - 1) {\n                uint256 lastTokenId = self.ownedTokens[to][length - 1];\n                self.ownedTokens[to][self.ownedTokensIndex[to][tokenId]] = lastTokenId; \n                self.ownedTokensIndex[to][lastTokenId] = self.ownedTokensIndex[to][tokenId];\n            }\n        }\n\n        delete self.ownedTokensIndex[to][tokenId];\n        if (self.ownedTokens[to].length > 0) {\n            self.ownedTokens[to].pop();\n        }\n    }    \n\n    function findTokensOwned(OwnerEnumerableData storage self, address wallet) public view returns (uint256[] storage) {\n        return self.ownedTokens[wallet];\n    }  \n\n    function tokenIndex(OwnerEnumerableData storage self, address wallet, uint256 index) public view returns (uint256) {\n        return self.ownedTokens[wallet][index];\n    }    \n\n    function ownerOf(OwnerEnumerableData storage self, uint256 tokenId) public view returns (address) {\n        address owner = self.tokens[tokenId].ownedBy;\n        if (owner == address(0)) {\n            revert TokenNonOwner(owner,tokenId);\n        }\n        return owner;\n    }      \n}"
    },
    "contracts/SetPackable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n\n/**\n    * The caller must own the token or be an approved operator.\n    */\nerror ApprovalCallerNotOwnerNorApproved();\n\n/**\n    * The token does not exist.\n    */\nerror ApprovalQueryForNonexistentToken();\n\n/**\n    * Cannot query the balance for the zero address.\n    */\nerror BalanceQueryForZeroAddress();\n\n/**\n    * Cannot mint to the zero address.\n    */\nerror MintToZeroAddress();\n\n/**\n    * The quantity of tokens minted must be more than zero.\n    */\nerror MintZeroQuantity();\n\n/**\n    * The token does not exist.\n    */\nerror OwnerQueryForNonexistentToken();\n\n/**\n    * The caller must own the token or be an approved operator.\n    */\nerror TransferCallerNotOwnerNorApproved();\n\n/**\n    * The token must be owned by `from`.\n    */\nerror TransferFromIncorrectOwner();\n\n/**\n    * Cannot safely transfer to a contract that does not implement the\n    * ERC721Receiver interface.\n    */\nerror TransferToNonERC721ReceiverImplementer();\n\n/**\n    * Cannot transfer to the zero address.\n    */\nerror TransferToZeroAddress();\n\n/**\n    * The token does not exist.\n    */\nerror URIQueryForNonexistentToken();\n\n/**\n    * The `quantity` minted with ERC2309 exceeds the safety limit.\n    */\nerror MintERC2309QuantityExceedsLimit();\n\n/**\n    * The `extraData` cannot be set on an unintialized ownership slot.\n    */\nerror OwnershipNotInitializedForExtraData();\n\n// =============================================================\n//                            STRUCTS\n// =============================================================\n\nstruct TokenOwnership {\n    // The address of the owner.\n    address addr;\n    // Stores the start time of ownership with minimal overhead for tokenomics.\n    uint64 startTimestamp;\n    // Whether the token has been burned.\n    bool burned;\n    // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n    uint24 extraData;\n}    \n\n\nstruct DualAuxData {\n    uint32 data1;\n    uint32 data2;\n}\n\nstruct QuadAuxData {\n    uint16 data1;\n    uint16 data2;\n    uint16 data3;\n    uint16 data4;\n}\nstruct OctAuxData {\n    uint8 data1;\n    uint8 data2;\n    uint8 data3;\n    uint8 data4;\n    uint8 data5;\n    uint8 data6;\n    uint8 data7;\n    uint8 data8;\n}\n\n// Mapping from token ID to ownership details\n// An empty struct value does not necessarily mean the token is unowned.\n// See {_packedOwnershipOf} implementation for details.\n//\n// Bits Layout:\n// - [0..159]   `addr`\n// - [160..223] `startTimestamp`\n// - [224]      `burned`\n// - [225]      `nextInitialized`\n// - [232..255] `extraData`\n\n// Mapping owner address to address data.\n//\n// Bits Layout:\n// - [0..63]    `balance`\n// - [64..127]  `numberMinted`\n// - [128..191] `numberBurned`\n// - [192..255] `aux`\nstruct PackableData {\n    mapping(uint256 => uint256) _packedOwnerships;\n    mapping(address => uint256) _packedAddressData;\n    uint256 _currentIndex;\n    uint256 _burnCounter;\n}\n\nlibrary SetPackable {\n\n    \n\n    // =============================================================\n    //                           CONSTANTS\n    // =============================================================\n\n    // Mask of an entry in packed address data.\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\n\n    // The bit position of `numberMinted` in packed address data.\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\n\n    // The bit position of `numberBurned` in packed address data.\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\n\n    // The bit position of `aux` in packed address data.\n    uint256 private constant _BITPOS_AUX = 192;\n\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\n\n    // The bit position of `startTimestamp` in packed ownership.\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\n\n    // The bit mask of the `burned` bit in packed ownership.\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\n\n    // The bit position of the `nextInitialized` bit in packed ownership.\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\n\n    // The bit mask of the `nextInitialized` bit in packed ownership.\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\n\n    // The bit position of `extraData` in packed ownership.\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\n\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\n\n    // The mask of the lower 160 bits for addresses.\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\n\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\n    // This limit is to prevent overflows on the address data entries.\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\n    // is required to cause an overflow, which is unrealistic.\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\n\n    // The `Transfer` event signature is given by:\n    // `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n\n    // =============================================================\n    //                    ADDRESS DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(PackableData storage self, address owner) public view returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return self._packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(PackableData storage self,address owner) public view returns (uint256) {\n        return (self._packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(PackableData storage self,address owner) public view returns (uint256) {\n        return (self._packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(PackableData storage self,address owner) public view returns (uint64 aux) {\n        return uint64(self._packedAddressData[owner] >> _BITPOS_AUX);\n    }\n\n    /**\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(PackableData storage self, address owner, uint64 aux) public {\n        uint256 packed = self._packedAddressData[owner];\n        uint256 auxCasted;\n        // Cast `aux` with assembly to avoid redundant masking.\n        assembly {\n            auxCasted := aux\n        }\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\n        self._packedAddressData[owner] = packed;\n    }\n\n    function getAux16(PackableData storage self, address owner) internal view returns (uint16[4] memory) {\n        \n        uint32[2] memory packed32 = unpack64(self,_getAux(self,owner));\n        uint16[2] memory pack16a = unpack32(self,packed32[0]);\n        uint16[2] memory pack16b = unpack32(self,packed32[1]);\n        \n        return [pack16a[0],pack16a[1],pack16b[0],pack16b[1]];\n    }   \n\n    function pack16(PackableData storage, uint8 pack1, uint8 pack2) public pure returns (uint16) {\n        return (uint16(pack2) << 8) | pack1;\n    }\n\n    function pack32(PackableData storage, uint16 pack1, uint16 pack2) public pure returns (uint32) {\n        return (uint32(pack2) << 16) | pack1;\n    }    \n\n    function pack64(PackableData storage, uint32 pack1, uint32 pack2) public pure returns (uint64) {\n        return (uint64(pack2) << 32) | pack1;\n    }        \n\n    function unpack64(PackableData storage, uint64 packed) public pure returns (uint32[2] memory unpacked){\n        uint32 pack2 = uint32(packed >> 32); \n        uint32 pack1 = uint32(packed);       \n        return [pack1, pack2];\n    }       \n\n    function unpack32(PackableData storage, uint32 packed) public pure returns (uint16[2] memory unpacked){\n        uint16 pack2 = uint16(packed >> 16); \n        uint16 pack1 = uint16(packed);       \n        return [pack1, pack2];\n    }        \n\n    function unpack16(PackableData storage, uint16 packed) public pure returns (uint8[2] memory unpacked){\n        uint8 pack2 = uint8(packed >> 8); \n        uint8 pack1 = uint8(packed);       \n        return [pack1, pack2];\n    }    \n\n    // =============================================================\n    //                     OWNERSHIPS OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(PackableData storage self, uint256 tokenId) public view returns (address) {\n        return address(uint160(_packedOwnershipOf(self,tokenId)));\n    }\n\n    /**\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around over time.\n     */\n    function _ownershipOf(PackableData storage self, uint256 tokenId) internal view returns (TokenOwnership memory) {\n        return _unpackedOwnership(_packedOwnershipOf(self,tokenId));\n    }\n\n    /**\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\n     */\n    function _ownershipAt(PackableData storage self, uint256 index) internal view returns (TokenOwnership memory) {\n        return _unpackedOwnership(self._packedOwnerships[index]);\n    }\n\n    /**\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\n     */\n    function _initializeOwnershipAt(PackableData storage self, uint256 index) internal {\n        if (self._packedOwnerships[index] == 0) {\n            self._packedOwnerships[index] = _packedOwnershipOf(self,index);\n        }\n    }\n\n    /**\n     * Returns the packed ownership data of `tokenId`.\n     */\n    function _packedOwnershipOf(PackableData storage self, uint256 tokenId) private view returns (uint256) {\n        uint256 curr = tokenId;\n\n        unchecked {\n            if (_startTokenId(self) <= curr)\n                if (curr < self._currentIndex) {\n                    uint256 packed = self._packedOwnerships[curr];\n                    // If not burned.\n                    if (packed & _BITMASK_BURNED == 0) {\n                        // Invariant:\n                        // There will always be an initialized ownership slot\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\n                        // before an unintialized ownership slot\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\n                        // Hence, `curr` will not underflow.\n                        //\n                        // We can directly compare the packed value.\n                        // If the address is zero, packed will be zero.\n                        while (packed == 0) {\n                            packed = self._packedOwnerships[--curr];\n                        }\n                        return packed;\n                    }\n                }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\n     */\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\n        ownership.addr = address(uint160(packed));\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\n        ownership.burned = packed & _BITMASK_BURNED != 0;\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\n    }\n\n    /**\n     * @dev Packs ownership data into a single uint256.\n     */\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\n        assembly {\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            owner := and(owner, _BITMASK_ADDRESS)\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\n        }\n    }\n\n\n\n    /**\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\n     */\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\n        // For branchless setting of the `nextInitialized` flag.\n        assembly {\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\n        }\n    }    \n\n    /**\n     * @dev Returns the starting token ID.\n     * To change the starting token ID, please override this function.\n     */\n    function _startTokenId(PackableData storage) internal pure returns (uint256) {\n        return 1;\n    }  \n\n/**\n     * @dev Returns the next token ID to be minted.\n     */\n    function _nextTokenId(PackableData storage self) public view returns (uint256) {\n        return self._currentIndex;\n    }\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply(PackableData storage self) public view returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than `_currentIndex - _startTokenId()` times.\n        unchecked {\n            return self._currentIndex - self._burnCounter;\n        }\n    }\n\n    /**\n     * @dev Returns the total amount of tokens minted in the contract.\n     */\n    function _totalMinted(PackableData storage self) public view returns (uint256) {\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\n        // and it is initialized to `_startTokenId()`.\n        unchecked {\n            return self._currentIndex;\n        }\n    }\n\n    /**\n     * @dev Returns the total number of tokens burned.\n     */\n    function _totalBurned(PackableData storage self) public view returns (uint256) {\n        return self._burnCounter;\n    }      \n\n/**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted. See {_mint}.\n     */\n    function _exists(PackableData storage self, uint256 tokenId) public view returns (bool) {\n        return\n            _startTokenId(self) <= tokenId &&\n            tokenId < self._currentIndex && // If within bounds,\n            self._packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\n    }\n\n    // =============================================================\n    //                      TRANSFER OPERATIONS\n    // =============================================================\n\n    function transferFrom(\n        PackableData storage self,\n        address from,\n        address to,\n        uint256 tokenId\n    ) public {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(self,tokenId);\n\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();        \n\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // We can directly increment and decrement the balances.\n            --self._packedAddressData[from]; // Updates: `balance -= 1`.\n            ++self._packedAddressData[to]; // Updates: `balance += 1`.\n\n            // Updates:\n            // - `address` to the next owner.\n            // - `startTimestamp` to the timestamp of transfering.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `true`.\n            self._packedOwnerships[tokenId] = _packOwnershipData(\n                to,\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (self._packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != self._currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        self._packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n    }\n\n    \n\n    // =============================================================\n    //                        MINT OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event for each mint.\n     */\n    function _mint(PackableData storage self, address to, uint256 quantity) public returns (uint256) {\n        uint256 startTokenId = self._currentIndex;\n        if (quantity == 0) revert MintZeroQuantity();        \n\n        // Overflows are incredibly unrealistic.\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\n        // `tokenId` has a maximum limit of 2**256.\n        unchecked {\n            // Updates:\n            // - `balance += quantity`.\n            // - `numberMinted += quantity`.\n            //\n            // We can directly add to the `balance` and `numberMinted`.\n            self._packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\n\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `quantity == 1`.\n            self._packedOwnerships[startTokenId] = _packOwnershipData(\n                to,\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\n            );\n\n            uint256 toMasked;\n            uint256 end = startTokenId + quantity;\n\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\n            // The assembly, together with the surrounding Solidity code, have been\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\n            assembly {\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\n                toMasked := and(to, _BITMASK_ADDRESS)\n                // Emit the `Transfer` event.\n                log4(\n                    0, // Start of data (0, since no data).\n                    0, // End of data (0, since no data).\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\n                    0, // `address(0)`.\n                    toMasked, // `to`.\n                    startTokenId // `tokenId`.\n                )\n\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\n                // that overflows uint256 will make the loop run out of gas.\n                // The compiler will optimize the `iszero` away for performance.\n                for {\n                    let tokenId := add(startTokenId, 1)\n                } iszero(eq(tokenId, end)) {\n                    tokenId := add(tokenId, 1)\n                } {\n                    // Emit the `Transfer` event. Similar to above.\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\n                }\n            }\n            if (toMasked == 0) revert MintToZeroAddress();\n\n            self._currentIndex = end;\n        }     \n        return self._currentIndex;\n    }\n\n    \n\n    // =============================================================\n    //                        BURN OPERATIONS\n    // =============================================================\n\n    function _burn(PackableData storage self, uint256 tokenId) public {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(self,tokenId);\n\n        address from = address(uint160(prevOwnershipPacked));\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // Updates:\n            // - `balance -= 1`.\n            // - `numberBurned += 1`.\n            //\n            // We can directly decrement the balance, and increment the number burned.\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\n            self._packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\n\n            // Updates:\n            // - `address` to the last owner.\n            // - `startTimestamp` to the timestamp of burning.\n            // - `burned` to `true`.\n            // - `nextInitialized` to `true`.\n            self._packedOwnerships[tokenId] = _packOwnershipData(\n                from,\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (self._packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != self._currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        self._packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n        unchecked {\n            self._burnCounter++;\n        }\n    }\n\n    // =============================================================\n    //                     EXTRA DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Directly sets the extra data for the ownership data `index`.\n     */\n    function _setExtraDataAt(PackableData storage self, uint256 index, uint24 extraData) public {\n        uint256 packed = self._packedOwnerships[index];\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\n        uint256 extraDataCasted;\n        // Cast `extraData` with assembly to avoid redundant masking.\n        assembly {\n            extraDataCasted := extraData\n        }\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\n        self._packedOwnerships[index] = packed;\n    }\n\n    /**\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\n     * Intended to be overridden by the cosumer contract.\n     *\n     * `previousExtraData` - the value of `extraData` before transfer.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _extraData(\n        address from,\n        address to,\n        uint24 previousExtraData\n    ) public view returns (uint24) {}\n\n    /**\n     * @dev Returns the next extra data for the packed ownership data.\n     * The returned result is shifted into position.\n     */\n    function _nextExtraData(\n        address from,\n        address to,\n        uint256 prevOwnershipPacked\n    ) private view returns (uint256) {\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\n    }\n\n    // =============================================================\n    //                       OTHER OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Converts a uint256 to its ASCII string decimal representation.\n     */\n    function _toString(uint256 value) public pure returns (string memory str) {\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\n            let m := add(mload(0x40), 0xa0)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 1)\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }    \n\n}    "
    },
    "contracts/SetPhaseable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nstruct PhaseableData { \n    Phase[] phases;\n    uint256 activePhase;\n    uint256 maxSupply;\n}    \n\nstruct Phase {\n    uint64 name;\n    uint64 maxPerWallet;\n    uint64 highestSupply;\n    uint64 cost;\n}\n\nerror MintIsNotAllowedRightNow();\nerror ExceedsMaxSupply();\nerror PhaseNotActiveYet();\nerror PhaseExhausted();\nerror WalletMintsFilled(uint256 requested);\n\nlibrary SetPhaseable {\n    function initialize(PhaseableData storage self, Phase[] storage phases, uint256 maxSupply) public {\n        self.phases = phases;\n        self.activePhase = 0;\n        self.maxSupply = maxSupply;\n    }\n    function getMaxSupply(PhaseableData storage self) public view returns (uint256) {\n        return self.maxSupply;\n    }\n    function setMaxSupply(PhaseableData storage self, uint256 newMax) public {\n        self.maxSupply = newMax;\n    }\n    function getPhases(PhaseableData storage self) public view returns (Phase[] storage) {\n        return self.phases;\n    }\n    function getActivePhase(PhaseableData storage self) public view returns (uint256) {\n        return self.activePhase;\n    }\n    function findPhase(PhaseableData storage self, uint256 phaseId) public view returns (Phase memory) {\n        return self.phases[phaseId];\n    }\n    function startNextPhase(PhaseableData storage self) public {\n        self.activePhase += 1;\n    }\n    function revertPhase(PhaseableData storage self) public {\n        self.activePhase -= 1;\n    }\n    function addPhase(PhaseableData storage self,Phase calldata nextPhase) public {\n        self.phases.push(nextPhase);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "contracts/SetApprovable.sol": {
        "SetApprovable": "0x5beb03b964115906ae157be77debc55fec6d47d5"
      },
      "contracts/SetAssignable.sol": {
        "SetAssignable": "0xfc3b49b6257d7eba30a5a1d81f99d6c896ec3568"
      },
      "contracts/SetFlexibleMetadata.sol": {
        "SetFlexibleMetadata": "0xc2dc8b9b633a6a8b00058cd0dc74732182cd58e3"
      },
      "contracts/SetInscribable.sol": {
        "SetInscribable": "0xd7703437ed73f49fb6183caf673a534ae8fd7fd7"
      },
      "contracts/SetLockable.sol": {
        "SetLockable": "0x2d65c58e6106660eddbd6cbbbf25d154ba105137"
      },
      "contracts/SetOwnerEnumerable.sol": {
        "SetOwnerEnumerable": "0x3b6b80eca0a8f524ac43365ac5c1c67f24806d72"
      },
      "contracts/SetPackable.sol": {
        "SetPackable": "0x1b2868f3a937a3a9e6dedb33e0804c00fc6bd6c4"
      },
      "contracts/SetPhaseable.sol": {
        "SetPhaseable": "0xffd2d5be009c0f9257523f62856639a26db10875"
      }
    }
  }
}}