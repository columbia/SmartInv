{{
  "language": "Solidity",
  "sources": {
    "contracts/farm/AGLDFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/math/Math.sol';\nimport '@solidstate/contracts/token/ERC20/IERC20.sol';\nimport '@solidstate/contracts/utils/SafeERC20.sol';\n\nimport '../token/IMagic.sol';\n\ncontract AGLDFarm {\n    using SafeERC20 for IERC20;\n\n    address private immutable MAGIC;\n    address private immutable ADVENTURE_GOLD;\n    uint256 public immutable EXPIRATION;\n    uint256 private immutable RATE;\n\n    mapping(address => uint256) public depositBalances;\n    mapping(address => uint256) public depositBlocks;\n\n    constructor(\n        address magic,\n        address adventureGold,\n        uint256 rate,\n        uint256 expiration\n    ) {\n        MAGIC = magic;\n        ADVENTURE_GOLD = adventureGold;\n        RATE = rate;\n        EXPIRATION = block.number + expiration;\n    }\n\n    function calculateRewards(address account)\n        public\n        view\n        returns (uint256 reward)\n    {\n        reward =\n            (RATE *\n                depositBalances[account] *\n                (Math.min(block.number, EXPIRATION) - depositBlocks[account])) /\n            (1 ether);\n    }\n\n    function claimRewards() public {\n        uint256 reward = calculateRewards(msg.sender);\n\n        if (reward > 0) {\n            IMagic(MAGIC).mint(msg.sender, reward);\n        }\n\n        depositBlocks[msg.sender] = Math.min(block.number, EXPIRATION);\n    }\n\n    function deposit(uint256 amount) external {\n        require(\n            IERC20(ADVENTURE_GOLD).balanceOf(address(this)) + amount <=\n                50e6 ether,\n            'AGLDFarm: deposit cap reached'\n        );\n        claimRewards();\n        IERC20(ADVENTURE_GOLD).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n        depositBalances[msg.sender] += amount;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(\n            depositBalances[msg.sender] >= amount,\n            'AGLDFarm: insufficient balance'\n        );\n\n        claimRewards();\n\n        unchecked {\n            depositBalances[msg.sender] -= amount;\n        }\n\n        IERC20(ADVENTURE_GOLD).safeTransfer(msg.sender, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IERC20Internal} from './IERC20Internal.sol';\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 is IERC20Internal {\n  /**\n   * @notice query the total minted token supply\n   * @return token supply\n   */\n  function totalSupply () external view returns (uint256);\n\n  /**\n   * @notice query the token balance of given account\n   * @param account address to query\n   * @return token balance\n   */\n  function balanceOf (\n    address account\n  ) external view returns (uint256);\n\n  /**\n   * @notice query the allowance granted from given holder to given spender\n   * @param holder approver of allowance\n   * @param spender recipient of allowance\n   * @return token allowance\n   */\n  function allowance (\n    address holder,\n    address spender\n  ) external view returns (uint256);\n\n  /**\n   * @notice grant approval to spender to spend tokens\n   * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n   * @param spender recipient of allowance\n   * @param amount quantity of tokens approved for spending\n   * @return success status (always true; otherwise function should revert)\n   */\n  function approve (\n    address spender,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @notice transfer tokens to given recipient\n   * @param recipient beneficiary of token transfer\n   * @param amount quantity of tokens to transfer\n   * @return success status (always true; otherwise function should revert)\n   */\n  function transfer (\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @notice transfer tokens to given recipient on behalf of given holder\n   * @param holder holder of tokens prior to transfer\n   * @param recipient beneficiary of token transfer\n   * @param amount quantity of tokens to transfer\n   * @return success status (always true; otherwise function should revert)\n   */\n  function transferFrom (\n    address holder,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n}\n"
    },
    "@solidstate/contracts/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from '../token/ERC20/IERC20.sol';\nimport {AddressUtils} from './AddressUtils.sol';\n\n/**\n * @title Safe ERC20 interaction library\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary SafeERC20 {\n    using AddressUtils for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev safeApprove (like approve) should only be called when setting an initial allowance or when resetting it to zero; otherwise prefer safeIncreaseAllowance and safeDecreaseAllowance\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @notice send transaction data and check validity of return value, if present\n     * @param token ERC20 token interface\n     * @param data transaction data\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/token/IMagic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@solidstate/contracts/token/ERC20/IERC20.sol';\n\ninterface IMagic is IERC20 {\n    function mint(address account, uint256 amount) external;\n}\n"
    },
    "@solidstate/contracts/token/ERC20/IERC20Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial ERC20 interface needed by internal functions\n */\ninterface IERC20Internal {\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary AddressUtils {\n  function toString (address account) internal pure returns (string memory) {\n    bytes32 value = bytes32(uint256(uint160(account)));\n    bytes memory alphabet = '0123456789abcdef';\n    bytes memory chars = new bytes(42);\n\n    chars[0] = '0';\n    chars[1] = 'x';\n\n    for (uint256 i = 0; i < 20; i++) {\n      chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n      chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n    }\n\n    return string(chars);\n  }\n\n  function isContract (address account) internal view returns (bool) {\n    uint size;\n    assembly { size := extcodesize(account) }\n    return size > 0;\n  }\n\n  function sendValue (address payable account, uint amount) internal {\n    (bool success, ) = account.call{ value: amount }('');\n    require(success, 'AddressUtils: failed to send value');\n  }\n\n  function functionCall (address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, 'AddressUtils: failed low-level call');\n  }\n\n  function functionCall (address target, bytes memory data, string memory error) internal returns (bytes memory) {\n    return _functionCallWithValue(target, data, 0, error);\n  }\n\n  function functionCallWithValue (address target, bytes memory data, uint value) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, 'AddressUtils: failed low-level call with value');\n  }\n\n  function functionCallWithValue (address target, bytes memory data, uint value, string memory error) internal returns (bytes memory) {\n    require(address(this).balance >= value, 'AddressUtils: insufficient balance for call');\n    return _functionCallWithValue(target, data, value, error);\n  }\n\n  function _functionCallWithValue (address target, bytes memory data, uint value, string memory error) private returns (bytes memory) {\n    require(isContract(target), 'AddressUtils: function call to non-contract');\n\n    (bool success, bytes memory returnData) = target.call{ value: value }(data);\n\n    if (success) {\n      return returnData;\n    } else if (returnData.length > 0) {\n      assembly {\n        let returnData_size := mload(returnData)\n        revert(add(32, returnData), returnData_size)\n      }\n    } else {\n      revert(error);\n    }\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}