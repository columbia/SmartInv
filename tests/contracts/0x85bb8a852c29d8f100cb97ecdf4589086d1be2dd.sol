{"ABIResolver.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ResolverBase.sol\";\n\ncontract ABIResolver is ResolverBase {\n    bytes4 constant private ABI_INTERFACE_ID = 0x2203ab56;\n\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n\n    mapping(bytes32=\u003emapping(uint256=\u003ebytes)) abis;\n\n    /**\n     * Sets the ABI associated with an ENS node.\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\n     * the empty string.\n     * @param node The node to update.\n     * @param contentType The content type of the ABI\n     * @param data The ABI data.\n     */\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external authorised(node) {\n        // Content types must be powers of 2\n        require(((contentType - 1) \u0026 contentType) == 0);\n\n        abis[node][contentType] = data;\n        emit ABIChanged(node, contentType);\n    }\n\n    /**\n     * Returns the ABI associated with an ENS node.\n     * Defined in EIP205.\n     * @param node The ENS node to query\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n     * @return contentType The content type of the return value\n     * @return data The ABI data\n     */\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory) {\n        mapping(uint256=\u003ebytes) storage abiset = abis[node];\n\n        for (uint256 contentType = 1; contentType \u003c= contentTypes; contentType \u003c\u003c= 1) {\n            if ((contentType \u0026 contentTypes) != 0 \u0026\u0026 abiset[contentType].length \u003e 0) {\n                return (contentType, abiset[contentType]);\n            }\n        }\n\n        return (0, bytes(\"\"));\n    }\n\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\n        return interfaceID == ABI_INTERFACE_ID || super.supportsInterface(interfaceID);\n    }\n}\n"},"Address.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Collection of functions related to the address type,\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract\u0027s constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * \u003e It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n}\n"},"AddrResolver.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ResolverBase.sol\";\n\ncontract AddrResolver is ResolverBase {\n    bytes4 constant private ADDR_INTERFACE_ID = 0x3b3b57de;\n\n    event AddrChanged(bytes32 indexed node, address a);\n\n    mapping(bytes32=\u003eaddress) addresses;\n\n    /**\n     * Sets the address associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param addr The address to set.\n     */\n    function setAddr(bytes32 node, address addr) external authorised(node) {\n        addresses[node] = addr;\n        emit AddrChanged(node, addr);\n    }\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) public view returns (address) {\n        return addresses[node];\n    }\n\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\n        return interfaceID == ADDR_INTERFACE_ID || super.supportsInterface(interfaceID);\n    }\n}\n"},"balanceable.sol":{"content":"/**\n *  Balanceable - The Consumer Contract Wallet\n *  Copyright (C) 2019 The Contract Wallet Company Limited\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n */\n\npragma solidity ^0.5.10;\n\nimport \"./ERC20.sol\";\n\n\n/// @title Balanceable - This is a contract used to get a balance\ncontract Balanceable {\n\n    /// @dev This function is used to get a balance\n    /// @param _address of which balance we are trying to ascertain\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\n    /// @return balance associated with an address, for any token, in the wei equivalent\n    function _balance(address _address, address _asset) internal view returns (uint) {\n        if (_asset != address(0)) {\n            return ERC20(_asset).balanceOf(_address);\n        } else {\n            return _address.balance;\n        }\n    }\n}\n"},"bytesUtils.sol":{"content":"/**\n *  BytesUtils - The Consumer Contract Wallet\n *  Copyright (C) 2019 The Contract Wallet Company Limited\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n */\n\npragma solidity ^0.5.10;\n\nimport \"./SafeMath.sol\";\n\n/// @title BytesUtils provides basic byte slicing and casting functionality.\nlibrary BytesUtils {\n\n    using SafeMath for uint256;\n\n    /// @dev This function converts to an address\n    /// @param _bts bytes\n    /// @param _from start position\n    function _bytesToAddress(bytes memory _bts, uint _from) internal pure returns (address) {\n\n        require(_bts.length \u003e= _from.add(20), \"slicing out of range\");\n\n        bytes20 convertedAddress;\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\n\n        assembly {\n            convertedAddress := mload(add(_bts, startByte))\n        }\n\n        return address(convertedAddress);\n    }\n\n    /// @dev This function slices bytes into bytes4\n    /// @param _bts some bytes\n    /// @param _from start position\n    function _bytesToBytes4(bytes memory _bts, uint _from) internal pure returns (bytes4) {\n        require(_bts.length \u003e= _from.add(4), \"slicing out of range\");\n\n        bytes4 slicedBytes4;\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\n\n        assembly {\n            slicedBytes4 := mload(add(_bts, startByte))\n        }\n\n        return slicedBytes4;\n\n    }\n\n    /// @dev This function slices a uint\n    /// @param _bts some bytes\n    /// @param _from start position\n    // credit to https://ethereum.stackexchange.com/questions/51229/how-to-convert-bytes-to-uint-in-solidity\n    // and Nick Johnson https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity/4177#4177\n    function _bytesToUint256(bytes memory _bts, uint _from) internal pure returns (uint) {\n        require(_bts.length \u003e= _from.add(32), \"slicing out of range\");\n\n        uint convertedUint256;\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\n        \n        assembly {\n            convertedUint256 := mload(add(_bts, startByte))\n        }\n\n        return convertedUint256;\n    }\n}\n"},"ContentHashResolver.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ResolverBase.sol\";\n\ncontract ContentHashResolver is ResolverBase {\n    bytes4 constant private CONTENT_HASH_INTERFACE_ID = 0xbc1c58d1;\n\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n\n    mapping(bytes32=\u003ebytes) hashes;\n\n    /**\n     * Sets the contenthash associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param hash The contenthash to set\n     */\n    function setContenthash(bytes32 node, bytes calldata hash) external authorised(node) {\n        hashes[node] = hash;\n        emit ContenthashChanged(node, hash);\n    }\n\n    /**\n     * Returns the contenthash associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function contenthash(bytes32 node) external view returns (bytes memory) {\n        return hashes[node];\n    }\n\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\n        return interfaceID == CONTENT_HASH_INTERFACE_ID || super.supportsInterface(interfaceID);\n    }\n}\n"},"controllable.sol":{"content":"/**\n *  Controllable - The Consumer Contract Wallet\n *  Copyright (C) 2019 The Contract Wallet Company Limited\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n */\n\npragma solidity ^0.5.10;\n\nimport \"./controller.sol\";\nimport \"./ensResolvable.sol\";\n\n\n/// @title Controllable implements access control functionality of the Controller found via ENS.\ncontract Controllable is ENSResolvable {\n    /// @dev Is the registered ENS node identifying the controller contract.\n    bytes32 private _controllerNode;\n\n    /// @notice Constructor initializes the controller contract object.\n    /// @param _controllerNode_ is the ENS node of the Controller.\n    constructor(bytes32 _controllerNode_) internal {\n        _controllerNode = _controllerNode_;\n    }\n\n    /// @notice Checks if message sender is a controller.\n    modifier onlyController() {\n        require(_isController(msg.sender), \"sender is not a controller\");\n        _;\n    }\n\n    /// @notice Checks if message sender is an admin.\n    modifier onlyAdmin() {\n        require(_isAdmin(msg.sender), \"sender is not an admin\");\n        _;\n    }\n\n    /// @return the controller node registered in ENS.\n    function controllerNode() external view returns (bytes32) {\n        return _controllerNode;\n    }\n\n    /// @return true if the provided account is a controller.\n    function _isController(address _account) internal view returns (bool) {\n        return IController(_ensResolve(_controllerNode)).isController(_account);\n    }\n\n    /// @return true if the provided account is an admin.\n    function _isAdmin(address _account) internal view returns (bool) {\n        return IController(_ensResolve(_controllerNode)).isAdmin(_account);\n    }\n\n}\n"},"controller.sol":{"content":"/**\n *  Controller - The Consumer Contract Wallet\n *  Copyright (C) 2019 The Contract Wallet Company Limited\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n */\n\npragma solidity ^0.5.10;\n\nimport \"./ownable.sol\";\nimport \"./transferrable.sol\";\n\n/// @title The IController interface provides access to the isController and isAdmin checks.\ninterface IController {\n    function isController(address) external view returns (bool);\n    function isAdmin(address) external view returns (bool);\n}\n\n\n/// @title Controller stores a list of controller addresses that can be used for authentication in other contracts.\n/// @notice The Controller implements a hierarchy of concepts, Owner, Admin, and the Controllers.\n/// @dev Owner can change the Admins\n/// @dev Admins and can the Controllers\n/// @dev Controllers are used by the application.\ncontract Controller is IController, Ownable, Transferrable {\n\n    event AddedController(address _sender, address _controller);\n    event RemovedController(address _sender, address _controller);\n\n    event AddedAdmin(address _sender, address _admin);\n    event RemovedAdmin(address _sender, address _admin);\n\n    event Claimed(address _to, address _asset, uint _amount);\n\n    event Stopped(address _sender);\n    event Started(address _sender);\n\n    mapping (address =\u003e bool) private _isAdmin;\n    uint private _adminCount;\n\n    mapping (address =\u003e bool) private _isController;\n    uint private _controllerCount;\n\n    bool private _stopped;\n\n    /// @notice Constructor initializes the owner with the provided address.\n    /// @param _ownerAddress_ address of the owner.\n    constructor(address payable _ownerAddress_) Ownable(_ownerAddress_, false) public {}\n\n    /// @notice Checks if message sender is an admin.\n    modifier onlyAdmin() {\n        require(isAdmin(msg.sender), \"sender is not an admin\");\n        _;\n    }\n\n    /// @notice Check if Owner or Admin\n    modifier onlyAdminOrOwner() {\n        require(_isOwner(msg.sender) || isAdmin(msg.sender), \"sender is not an admin\");\n        _;\n    }\n\n    /// @notice Check if controller is stopped\n    modifier notStopped() {\n        require(!isStopped(), \"controller is stopped\");\n        _;\n    }\n\n    /// @notice Add a new admin to the list of admins.\n    /// @param _account address to add to the list of admins.\n    function addAdmin(address _account) external onlyOwner notStopped {\n        _addAdmin(_account);\n    }\n\n    /// @notice Remove a admin from the list of admins.\n    /// @param _account address to remove from the list of admins.\n    function removeAdmin(address _account) external onlyOwner {\n        _removeAdmin(_account);\n    }\n\n    /// @return the current number of admins.\n    function adminCount() external view returns (uint) {\n        return _adminCount;\n    }\n\n    /// @notice Add a new controller to the list of controllers.\n    /// @param _account address to add to the list of controllers.\n    function addController(address _account) external onlyAdminOrOwner notStopped {\n        _addController(_account);\n    }\n\n    /// @notice Remove a controller from the list of controllers.\n    /// @param _account address to remove from the list of controllers.\n    function removeController(address _account) external onlyAdminOrOwner {\n        _removeController(_account);\n    }\n\n    /// @notice count the Controllers\n    /// @return the current number of controllers.\n    function controllerCount() external view returns (uint) {\n        return _controllerCount;\n    }\n\n    /// @notice is an address an Admin?\n    /// @return true if the provided account is an admin.\n    function isAdmin(address _account) public view notStopped returns (bool) {\n        return _isAdmin[_account];\n    }\n\n    /// @notice is an address a Controller?\n    /// @return true if the provided account is a controller.\n    function isController(address _account) public view notStopped returns (bool) {\n        return _isController[_account];\n    }\n\n    /// @notice this function can be used to see if the controller has been stopped\n    /// @return true is the Controller has been stopped\n    function isStopped() public view returns (bool) {\n        return _stopped;\n    }\n\n    /// @notice Internal-only function that adds a new admin.\n    function _addAdmin(address _account) private {\n        require(!_isAdmin[_account], \"provided account is already an admin\");\n        require(!_isController[_account], \"provided account is already a controller\");\n        require(!_isOwner(_account), \"provided account is already the owner\");\n        require(_account != address(0), \"provided account is the zero address\");\n        _isAdmin[_account] = true;\n        _adminCount++;\n        emit AddedAdmin(msg.sender, _account);\n    }\n\n    /// @notice Internal-only function that removes an existing admin.\n    function _removeAdmin(address _account) private {\n        require(_isAdmin[_account], \"provided account is not an admin\");\n        _isAdmin[_account] = false;\n        _adminCount--;\n        emit RemovedAdmin(msg.sender, _account);\n    }\n\n    /// @notice Internal-only function that adds a new controller.\n    function _addController(address _account) private {\n        require(!_isAdmin[_account], \"provided account is already an admin\");\n        require(!_isController[_account], \"provided account is already a controller\");\n        require(!_isOwner(_account), \"provided account is already the owner\");\n        require(_account != address(0), \"provided account is the zero address\");\n        _isController[_account] = true;\n        _controllerCount++;\n        emit AddedController(msg.sender, _account);\n    }\n\n    /// @notice Internal-only function that removes an existing controller.\n    function _removeController(address _account) private {\n        require(_isController[_account], \"provided account is not a controller\");\n        _isController[_account] = false;\n        _controllerCount--;\n        emit RemovedController(msg.sender, _account);\n    }\n\n    /// @notice stop our controllers and admins from being useable\n    function stop() external onlyAdminOrOwner {\n        _stopped = true;\n        emit Stopped(msg.sender);\n    }\n\n    /// @notice start our controller again\n    function start() external onlyOwner {\n        _stopped = false;\n        emit Started(msg.sender);\n    }\n\n    //// @notice Withdraw tokens from the smart contract to the specified account.\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin notStopped {\n        _safeTransfer(_to, _asset, _amount);\n        emit Claimed(_to, _asset, _amount);\n    }\n}\n"},"ENS.sol":{"content":"/**\n * BSD 2-Clause License\n *\n * Copyright (c) 2018, True Names Limited\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\npragma solidity ^0.5.0;\n\ninterface ENS {\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n    function setResolver(bytes32 node, address resolver) external;\n    function setOwner(bytes32 node, address owner) external;\n    function setTTL(bytes32 node, uint64 ttl) external;\n    function owner(bytes32 node) external view returns (address);\n    function resolver(bytes32 node) external view returns (address);\n    function ttl(bytes32 node) external view returns (uint64);\n\n}\n"},"ensResolvable.sol":{"content":"/**\n *  ENSResolvable - The Consumer Contract Wallet\n *  Copyright (C) 2019 The Contract Wallet Company Limited\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n */\n\npragma solidity ^0.5.10;\n\nimport \"./ENS.sol\";\nimport \"./PublicResolver.sol\";\n\n\n///@title ENSResolvable - Ethereum Name Service Resolver\n///@notice contract should be used to get an address for an ENS node\ncontract ENSResolvable {\n    /// @notice _ens is an instance of ENS\n    ENS private _ens;\n\n    /// @notice _ensRegistry points to the ENS registry smart contract.\n    address private _ensRegistry;\n\n    /// @param _ensReg_ is the ENS registry used\n    constructor(address _ensReg_) internal {\n        _ensRegistry = _ensReg_;\n        _ens = ENS(_ensRegistry);\n    }\n\n    /// @notice this is used to that one can observe which ENS registry is being used\n    function ensRegistry() external view returns (address) {\n        return _ensRegistry;\n    }\n\n    /// @notice helper function used to get the address of a node\n    /// @param _node of the ENS entry that needs resolving\n    /// @return the address of the said node\n    function _ensResolve(bytes32 _node) internal view returns (address) {\n        return PublicResolver(_ens.resolver(_node)).addr(_node);\n    }\n\n}\n"},"ERC165.sol":{"content":"pragma solidity ^0.5.10;\n\n/// @title ERC165 interface specifies a standard way of querying if a contract implements an interface.\ninterface ERC165 {\n    function supportsInterface(bytes4) external view returns (bool);\n}\n"},"ERC20.sol":{"content":"pragma solidity ^0.5.10;\n\n/// @title ERC20 interface is a subset of the ERC20 specification.\n/// @notice see https://github.com/ethereum/EIPs/issues/20\ninterface ERC20 {\n    function allowance(address _owner, address _spender) external view returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function balanceOf(address _who) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n}\n"},"InterfaceResolver.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ResolverBase.sol\";\nimport \"./AddrResolver.sol\";\n\ncontract InterfaceResolver is ResolverBase, AddrResolver {\n    bytes4 constant private INTERFACE_INTERFACE_ID = bytes4(keccak256(\"interfaceImplementer(bytes32,bytes4)\"));\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\n\n    event InterfaceChanged(bytes32 indexed node, bytes4 indexed interfaceID, address implementer);\n\n    mapping(bytes32=\u003emapping(bytes4=\u003eaddress)) interfaces;\n\n    /**\n     * Sets an interface associated with a name.\n     * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\n     * @param node The node to update.\n     * @param interfaceID The EIP 168 interface ID.\n     * @param implementer The address of a contract that implements this interface for this node.\n     */\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external authorised(node) {\n        interfaces[node][interfaceID] = implementer;\n        emit InterfaceChanged(node, interfaceID, implementer);\n    }\n\n    /**\n     * Returns the address of a contract that implements the specified interface for this name.\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\n     * contract implements EIP168 and returns `true` for the specified interfaceID, its address\n     * will be returned.\n     * @param node The ENS node to query.\n     * @param interfaceID The EIP 168 interface ID to check for.\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\n     */\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address) {\n        address implementer = interfaces[node][interfaceID];\n        if(implementer != address(0)) {\n            return implementer;\n        }\n\n        address a = addr(node);\n        if(a == address(0)) {\n            return address(0);\n        }\n\n        (bool success, bytes memory returnData) = a.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\", INTERFACE_META_ID));\n        if(!success || returnData.length \u003c 32 || returnData[31] == 0) {\n            // EIP 168 not supported by target\n            return address(0);\n        }\n\n        (success, returnData) = a.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\", interfaceID));\n        if(!success || returnData.length \u003c 32 || returnData[31] == 0) {\n            // Specified interface not supported by target\n            return address(0);\n        }\n\n        return a;\n    }\n\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\n        return interfaceID == INTERFACE_INTERFACE_ID || super.supportsInterface(interfaceID);\n    }\n}\n"},"licence.sol":{"content":"/**\n *  Licence - The Consumer Contract Wallet\n *  Copyright (C) 2019 The Contract Wallet Company Limited\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n */\n\npragma solidity ^0.5.10;\n\nimport \"./SafeMath.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./controllable.sol\";\nimport \"./ensResolvable.sol\";\nimport \"./transferrable.sol\";\n\n/// @title ILicence interface describes methods for loading a TokenCard and updating licence amount.\ninterface ILicence {\n    function load(address, uint) external payable;\n    function updateLicenceAmount(uint) external;\n}\n\n\n/// @title Licence loads the TokenCard and transfers the licence amout to the TKN Holder Contract.\n/// @notice the rest of the amount gets sent to the CryptoFloat\ncontract Licence is Transferrable, ENSResolvable, Controllable {\n\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    /*******************/\n    /*     Events     */\n    /*****************/\n\n    event UpdatedLicenceDAO(address _newDAO);\n    event UpdatedCryptoFloat(address _newFloat);\n    event UpdatedTokenHolder(address _newHolder);\n    event UpdatedTKNContractAddress(address _newTKN);\n    event UpdatedLicenceAmount(uint _newAmount);\n\n    event TransferredToTokenHolder(address _from, address _to, address _asset, uint _amount);\n    event TransferredToCryptoFloat(address _from, address _to, address _asset, uint _amount);\n\n    event Claimed(address _to, address _asset, uint _amount);\n\n    /// @notice This is 100% scaled up by a factor of 10 to give us an extra 1 decimal place of precision\n    uint constant public MAX_AMOUNT_SCALE = 1000;\n    uint constant public MIN_AMOUNT_SCALE = 1;\n\n    address private _tknContractAddress = 0xaAAf91D9b90dF800Df4F55c205fd6989c977E73a; // solium-disable-line uppercase\n\n    address payable private _cryptoFloat;\n    address payable private _tokenHolder;\n    address private _licenceDAO;\n\n    bool private _lockedCryptoFloat;\n    bool private _lockedTokenHolder;\n    bool private _lockedLicenceDAO;\n    bool private _lockedTKNContractAddress;\n\n    /// @notice This is the _licenceAmountScaled by a factor of 10\n    /// @dev i.e. 1% is 10 _licenceAmountScaled, 0.1% is 1 _licenceAmountScaled\n    uint private _licenceAmountScaled;\n\n    /// @notice Reverts if called by any address other than the DAO contract.\n    modifier onlyDAO() {\n        require(msg.sender == _licenceDAO, \"the sender isn\u0027t the DAO\");\n        _;\n    }\n\n    /// @notice Constructor initializes the card licence contract.\n    /// @param _licence_ is the initial card licence amount. this number is scaled 10 = 1%, 9 = 0.9%\n    /// @param _float_ is the address of the multi-sig cryptocurrency float contract.\n    /// @param _holder_ is the address of the token holder contract\n    /// @param _tknAddress_ is the address of the TKN ERC20 contract\n    /// @param _ens_ is the address of the ENS Registry\n    /// @param _controllerNode_ is the ENS node corresponding to the controller\n    constructor(uint _licence_, address payable _float_, address payable _holder_, address _tknAddress_, address _ens_, bytes32 _controllerNode_) ENSResolvable(_ens_) Controllable(_controllerNode_) public {\n        require(MIN_AMOUNT_SCALE \u003c= _licence_ \u0026\u0026 _licence_ \u003c= MAX_AMOUNT_SCALE, \"licence amount out of range\");\n        _licenceAmountScaled = _licence_;\n        _cryptoFloat = _float_;\n        _tokenHolder = _holder_;\n        if (_tknAddress_ != address(0)) {\n            _tknContractAddress = _tknAddress_;\n        }\n    }\n\n    /// @notice Ether can be deposited from any source, so this contract should be payable by anyone.\n    function() external payable {}\n\n    /// @notice this allows for people to see the scaled licence amount\n    /// @return the scaled licence amount, used to calculate the split when loading.\n    function licenceAmountScaled() external view returns (uint) {\n        return _licenceAmountScaled;\n    }\n\n    /// @notice allows one to see the address of the CryptoFloat\n    /// @return the address of the multi-sig cryptocurrency float contract.\n    function cryptoFloat() external view returns (address) {\n        return _cryptoFloat;\n    }\n\n    /// @notice allows one to see the address TKN holder contract\n    /// @return the address of the token holder contract.\n    function tokenHolder() external view returns (address) {\n        return _tokenHolder;\n    }\n\n    /// @notice allows one to see the address of the DAO\n    /// @return the address of the DAO contract.\n    function licenceDAO() external view returns (address) {\n        return _licenceDAO;\n    }\n\n    /// @notice The address of the TKN token\n    /// @return the address of the TKN contract.\n    function tknContractAddress() external view returns (address) {\n        return _tknContractAddress;\n    }\n\n    /// @notice This locks the cryptoFloat address\n    /// @dev so that it can no longer be updated\n    function lockFloat() external onlyAdmin {\n        _lockedCryptoFloat = true;\n    }\n\n    /// @notice This locks the TokenHolder address\n    /// @dev so that it can no longer be updated\n    function lockHolder() external onlyAdmin {\n        _lockedTokenHolder = true;\n    }\n\n    /// @notice This locks the DAO address\n    /// @dev so that it can no longer be updated\n    function lockLicenceDAO() external onlyAdmin {\n        _lockedLicenceDAO = true;\n    }\n\n    /// @notice This locks the TKN address\n    /// @dev so that it can no longer be updated\n    function lockTKNContractAddress() external onlyAdmin {\n        _lockedTKNContractAddress = true;\n    }\n\n    /// @notice Updates the address of the cyptoFloat.\n    /// @param _newFloat This is the new address for the CryptoFloat\n    function updateFloat(address payable _newFloat) external onlyAdmin {\n        require(!floatLocked(), \"float is locked\");\n        _cryptoFloat = _newFloat;\n        emit UpdatedCryptoFloat(_newFloat);\n    }\n\n    /// @notice Updates the address of the Holder contract.\n    /// @param _newHolder This is the new address for the TokenHolder\n    function updateHolder(address payable _newHolder) external onlyAdmin {\n        require(!holderLocked(), \"holder contract is locked\");\n        _tokenHolder = _newHolder;\n        emit UpdatedTokenHolder(_newHolder);\n    }\n\n    /// @notice Updates the address of the DAO contract.\n    /// @param _newDAO This is the new address for the Licence DAO\n    function updateLicenceDAO(address _newDAO) external onlyAdmin {\n        require(!licenceDAOLocked(), \"DAO is locked\");\n        _licenceDAO = _newDAO;\n        emit UpdatedLicenceDAO(_newDAO);\n    }\n\n    /// @notice Updates the address of the TKN contract.\n    /// @param _newTKN This is the new address for the TKN contract\n    function updateTKNContractAddress(address _newTKN) external onlyAdmin {\n        require(!tknContractAddressLocked(), \"TKN is locked\");\n        _tknContractAddress = _newTKN;\n        emit UpdatedTKNContractAddress(_newTKN);\n    }\n\n    /// @notice Updates the TKN licence amount\n    /// @param _newAmount is a number between MIN_AMOUNT_SCALE (1) and MAX_AMOUNT_SCALE\n    function updateLicenceAmount(uint _newAmount) external onlyDAO {\n        require(MIN_AMOUNT_SCALE \u003c= _newAmount \u0026\u0026 _newAmount \u003c= MAX_AMOUNT_SCALE, \"licence amount out of range\");\n        _licenceAmountScaled = _newAmount;\n        emit UpdatedLicenceAmount(_newAmount);\n    }\n\n    /// @notice Load the holder and float contracts based on the licence amount and asset amount.\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\n    /// @param _amount is the amount of assets to be transferred including the licence amount.\n    function load(address _asset, uint _amount) external payable {\n        uint loadAmount = _amount;\n        // If TKN then no licence to be paid\n        if (_asset == _tknContractAddress) {\n            ERC20(_asset).safeTransferFrom(msg.sender, _cryptoFloat, loadAmount);\n        } else {\n            loadAmount = _amount.mul(MAX_AMOUNT_SCALE).div(_licenceAmountScaled + MAX_AMOUNT_SCALE);\n            uint licenceAmount = _amount.sub(loadAmount);\n\n            if (_asset != address(0)) {\n                ERC20(_asset).safeTransferFrom(msg.sender, _tokenHolder, licenceAmount);\n                ERC20(_asset).safeTransferFrom(msg.sender, _cryptoFloat, loadAmount);\n            } else {\n                require(msg.value == _amount, \"ETH sent is not equal to amount\");\n                _tokenHolder.transfer(licenceAmount);\n                _cryptoFloat.transfer(loadAmount);\n            }\n\n            emit TransferredToTokenHolder(msg.sender, _tokenHolder, _asset, licenceAmount);\n        }\n\n        emit TransferredToCryptoFloat(msg.sender, _cryptoFloat, _asset, loadAmount);\n    }\n\n    //// @notice Withdraw tokens from the smart contract to the specified account.\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin {\n        _safeTransfer(_to, _asset, _amount);\n        emit Claimed(_to, _asset, _amount);\n    }\n\n    /// @notice returns whether or not the CryptoFloat address is locked\n    function floatLocked() public view returns (bool) {\n        return _lockedCryptoFloat;\n    }\n\n    /// @notice returns whether or not the TokenHolder address is locked\n    function holderLocked() public view returns (bool) {\n        return _lockedTokenHolder;\n    }\n\n    /// @notice returns whether or not the Licence DAO address is locked\n    function licenceDAOLocked() public view returns (bool) {\n        return _lockedLicenceDAO;\n    }\n\n    /// @notice returns whether or not the TKN address is locked\n    function tknContractAddressLocked() public view returns (bool) {\n        return _lockedTKNContractAddress;\n    }\n}\n"},"NameResolver.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ResolverBase.sol\";\n\ncontract NameResolver is ResolverBase {\n    bytes4 constant private NAME_INTERFACE_ID = 0x691f3431;\n\n    event NameChanged(bytes32 indexed node, string name);\n\n    mapping(bytes32=\u003estring) names;\n\n    /**\n     * Sets the name associated with an ENS node, for reverse records.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param name The name to set.\n     */\n    function setName(bytes32 node, string calldata name) external authorised(node) {\n        names[node] = name;\n        emit NameChanged(node, name);\n    }\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node) external view returns (string memory) {\n        return names[node];\n    }\n\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\n        return interfaceID == NAME_INTERFACE_ID || super.supportsInterface(interfaceID);\n    }\n}\n"},"ownable.sol":{"content":"/**\n *  Ownable - The Consumer Contract Wallet\n *  Copyright (C) 2019 The Contract Wallet Company Limited\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n */\n\npragma solidity ^0.5.10;\n\n\n/// @title Ownable has an owner address and provides basic authorization control functions.\n/// This contract is modified version of the MIT OpenZepplin Ownable contract\n/// This contract allows for the transferOwnership operation to be made impossible\n/// https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\ncontract Ownable {\n    event TransferredOwnership(address _from, address _to);\n    event LockedOwnership(address _locked);\n\n    address payable private _owner;\n    bool private _isTransferable;\n\n    /// @notice Constructor sets the original owner of the contract and whether or not it is one time transferable.\n    constructor(address payable _account_, bool _transferable_) internal {\n        _owner = _account_;\n        _isTransferable = _transferable_;\n        // Emit the LockedOwnership event if no longer transferable.\n        if (!_isTransferable) {\n            emit LockedOwnership(_account_);\n        }\n        emit TransferredOwnership(address(0), _account_);\n    }\n\n    /// @notice Reverts if called by any account other than the owner.\n    modifier onlyOwner() {\n        require(_isOwner(msg.sender), \"sender is not an owner\");\n        _;\n    }\n\n    /// @notice Allows the current owner to transfer control of the contract to a new address.\n    /// @param _account address to transfer ownership to.\n    /// @param _transferable indicates whether to keep the ownership transferable.\n    function transferOwnership(address payable _account, bool _transferable) external onlyOwner {\n        // Require that the ownership is transferable.\n        require(_isTransferable, \"ownership is not transferable\");\n        // Require that the new owner is not the zero address.\n        require(_account != address(0), \"owner cannot be set to zero address\");\n        // Set the transferable flag to the value _transferable passed in.\n        _isTransferable = _transferable;\n        // Emit the LockedOwnership event if no longer transferable.\n        if (!_transferable) {\n            emit LockedOwnership(_account);\n        }\n        // Emit the ownership transfer event.\n        emit TransferredOwnership(_owner, _account);\n        // Set the owner to the provided address.\n        _owner = _account;\n    }\n\n    /// @notice check if the ownership is transferable.\n    /// @return true if the ownership is transferable.\n    function isTransferable() external view returns (bool) {\n        return _isTransferable;\n    }\n\n    /// @notice Allows the current owner to relinquish control of the contract.\n    /// @dev Renouncing to ownership will leave the contract without an owner and unusable.\n    /// @dev It will not be possible to call the functions with the `onlyOwner` modifier anymore.\n    function renounceOwnership() external onlyOwner {\n        // Require that the ownership is transferable.\n        require(_isTransferable, \"ownership is not transferable\");\n        // note that this could be terminal\n        _owner = address(0);\n\n        emit TransferredOwnership(_owner, address(0));\n    }\n\n    /// @notice Find out owner address\n    /// @return address of the owner.\n    function owner() public view returns (address payable) {\n        return _owner;\n    }\n\n    /// @notice Check if owner address\n    /// @return true if sender is the owner of the contract.\n    function _isOwner(address _address) internal view returns (bool) {\n        return _address == _owner;\n    }\n}\n"},"PubkeyResolver.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ResolverBase.sol\";\n\ncontract PubkeyResolver is ResolverBase {\n    bytes4 constant private PUBKEY_INTERFACE_ID = 0xc8690233;\n\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n\n    struct PublicKey {\n        bytes32 x;\n        bytes32 y;\n    }\n\n    mapping(bytes32=\u003ePublicKey) pubkeys;\n\n    /**\n     * Sets the SECP256k1 public key associated with an ENS node.\n     * @param node The ENS node to query\n     * @param x the X coordinate of the curve point for the public key.\n     * @param y the Y coordinate of the curve point for the public key.\n     */\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external authorised(node) {\n        pubkeys[node] = PublicKey(x, y);\n        emit PubkeyChanged(node, x, y);\n    }\n\n    /**\n     * Returns the SECP256k1 public key associated with an ENS node.\n     * Defined in EIP 619.\n     * @param node The ENS node to query\n     * @return x, y the X and Y coordinates of the curve point for the public key.\n     */\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y) {\n        return (pubkeys[node].x, pubkeys[node].y);\n    }\n\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\n        return interfaceID == PUBKEY_INTERFACE_ID || super.supportsInterface(interfaceID);\n    }\n}\n"},"PublicResolver.sol":{"content":"/**\n * BSD 2-Clause License\n *\n * Copyright (c) 2018, True Names Limited\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\npragma solidity ^0.5.0;\n\nimport \"./ENS.sol\";\nimport \"./ABIResolver.sol\";\nimport \"./AddrResolver.sol\";\nimport \"./ContentHashResolver.sol\";\nimport \"./InterfaceResolver.sol\";\nimport \"./NameResolver.sol\";\nimport \"./PubkeyResolver.sol\";\nimport \"./TextResolver.sol\";\n\n/**\n * A simple resolver anyone can use; only allows the owner of a node to set its\n * address.\n */\ncontract PublicResolver is ABIResolver, AddrResolver, ContentHashResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver {\n    ENS ens;\n\n    /**\n     * A mapping of authorisations. An address that is authorised for a name\n     * may make any changes to the name that the owner could, but may not update\n     * the set of authorisations.\n     * (node, owner, caller) =\u003e isAuthorised\n     */\n    mapping(bytes32=\u003emapping(address=\u003emapping(address=\u003ebool))) public authorisations;\n\n    event AuthorisationChanged(bytes32 indexed node, address indexed owner, address indexed target, bool isAuthorised);\n\n    constructor(ENS _ens) public {\n        ens = _ens;\n    }\n\n    /**\n     * @dev Sets or clears an authorisation.\n     * Authorisations are specific to the caller. Any account can set an authorisation\n     * for any name, but the authorisation that is checked will be that of the\n     * current owner of a name. Thus, transferring a name effectively clears any\n     * existing authorisations, and new authorisations can be set in advance of\n     * an ownership transfer if desired.\n     *\n     * @param node The name to change the authorisation on.\n     * @param target The address that is to be authorised or deauthorised.\n     * @param isAuthorised True if the address should be authorised, or false if it should be deauthorised.\n     */\n    function setAuthorisation(bytes32 node, address target, bool isAuthorised) external {\n        authorisations[node][msg.sender][target] = isAuthorised;\n        emit AuthorisationChanged(node, msg.sender, target, isAuthorised);\n    }\n\n    function isAuthorised(bytes32 node) internal view returns(bool) {\n        address owner = ens.owner(node);\n        return owner == msg.sender || authorisations[node][owner][msg.sender];\n    }\n}\n"},"ResolverBase.sol":{"content":"pragma solidity ^0.5.0;\n\ncontract ResolverBase {\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\n\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\n        return interfaceID == INTERFACE_META_ID;\n    }\n\n    function isAuthorised(bytes32 node) internal view returns(bool);\n\n    modifier authorised(bytes32 node) {\n        require(isAuthorised(node));\n        _;\n    }\n}\n"},"SafeERC20.sol":{"content":"/**\n * The MIT License (MIT)\n *\n * Copyright (c) 2016-2019 zOS Global Limited\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(ERC20 token, bytes memory data) internal {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length \u003e 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"},"strings.sol":{"content":"/*\n * Copyright 2016 Nick Johnson\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * @title String \u0026 slice utility library for Solidity contracts.\n * @author Nick Johnson \u003carachnid@notdot.net\u003e\n *\n * @dev Functionality in this library is largely implemented using an\n *      abstraction called a \u0027slice\u0027. A slice represents a part of a string -\n *      anything from the entire string to a single character, or even no\n *      characters at all (a 0-length slice). Since a slice only has to specify\n *      an offset and a length, copying and manipulating slices is a lot less\n *      expensive than copying and manipulating the strings they reference.\n *\n *      To further reduce gas costs, most functions on slice that need to return\n *      a slice modify the original one instead of allocating a new one; for\n *      instance, `s.split(\".\")` will return the text up to the first \u0027.\u0027,\n *      modifying s to only contain the remainder of the string after the \u0027.\u0027.\n *      In situations where you do not want to modify the original slice, you\n *      can make a copy first with `.copy()`, for example:\n *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since\n *      Solidity has no memory management, it will result in allocating many\n *      short-lived slices that are later discarded.\n *\n *      Functions that return two slices come in two versions: a non-allocating\n *      version that takes the second slice as an argument, modifying it in\n *      place, and an allocating version that allocates and returns the second\n *      slice; see `nextRune` for example.\n *\n *      Functions that have to copy string data will return strings rather than\n *      slices; these can be cast back to slices for further processing if\n *      required.\n *\n *      For convenience, some functions are provided with non-modifying\n *      variants that create a new slice and return both; for instance,\n *      `s.splitNew(\u0027.\u0027)` leaves s unmodified, and returns two values\n *      corresponding to the left and right parts of the string.\n */\n\npragma solidity ^0.5.0;\n\nlibrary strings {\n    struct slice {\n        uint _len;\n        uint _ptr;\n    }\n\n    function memcpy(uint dest, uint src, uint len) private pure {\n        // Copy word-length chunks while possible\n        for(; len \u003e= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /*\n     * @dev Returns a slice containing the entire string.\n     * @param self The string to make a slice from.\n     * @return A newly allocated slice containing the entire string.\n     */\n    function toSlice(string memory self) internal pure returns (slice memory) {\n        uint ptr;\n        assembly {\n            ptr := add(self, 0x20)\n        }\n        return slice(bytes(self).length, ptr);\n    }\n\n    /*\n     * @dev Returns the length of a null-terminated bytes32 string.\n     * @param self The value to find the length of.\n     * @return The length of the string, from 0 to 32.\n     */\n    function len(bytes32 self) internal pure returns (uint) {\n        uint ret;\n        if (self == 0)\n            return 0;\n        if (uint(self) \u0026 0xffffffffffffffffffffffffffffffff == 0) {\n            ret += 16;\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n        }\n        if (uint(self) \u0026 0xffffffffffffffff == 0) {\n            ret += 8;\n            self = bytes32(uint(self) / 0x10000000000000000);\n        }\n        if (uint(self) \u0026 0xffffffff == 0) {\n            ret += 4;\n            self = bytes32(uint(self) / 0x100000000);\n        }\n        if (uint(self) \u0026 0xffff == 0) {\n            ret += 2;\n            self = bytes32(uint(self) / 0x10000);\n        }\n        if (uint(self) \u0026 0xff == 0) {\n            ret += 1;\n        }\n        return 32 - ret;\n    }\n\n    /*\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\n     *      null-terminated utf-8 string.\n     * @param self The bytes32 value to convert to a slice.\n     * @return A new slice containing the value of the input argument up to the\n     *         first null.\n     */\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n        assembly {\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, 0x20))\n            mstore(ptr, self)\n            mstore(add(ret, 0x20), ptr)\n        }\n        ret._len = len(self);\n    }\n\n    /*\n     * @dev Returns a new slice containing the same data as the current slice.\n     * @param self The slice to copy.\n     * @return A new slice containing the same data as `self`.\n     */\n    function copy(slice memory self) internal pure returns (slice memory) {\n        return slice(self._len, self._ptr);\n    }\n\n    /*\n     * @dev Copies a slice to a new string.\n     * @param self The slice to copy.\n     * @return A newly allocated string containing the slice\u0027s text.\n     */\n    function toString(slice memory self) internal pure returns (string memory) {\n        string memory ret = new string(self._len);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n        return ret;\n    }\n\n    /*\n     * @dev Returns the length in runes of the slice. Note that this operation\n     *      takes time proportional to the length of the slice; avoid using it\n     *      in loops, and call `slice.empty()` if you only need to know whether\n     *      the slice is empty or not.\n     * @param self The slice to operate on.\n     * @return The length of the slice in runes.\n     */\n    function len(slice memory self) internal pure returns (uint l) {\n        // Starting at ptr-31 means the LSB will be the byte we care about\n        uint ptr = self._ptr - 31;\n        uint end = ptr + self._len;\n        for (l = 0; ptr \u003c end; l++) {\n            uint8 b;\n            assembly { b := and(mload(ptr), 0xFF) }\n            if (b \u003c 0x80) {\n                ptr += 1;\n            } else if (b \u003c 0xE0) {\n                ptr += 2;\n            } else if (b \u003c 0xF0) {\n                ptr += 3;\n            } else if (b \u003c 0xF8) {\n                ptr += 4;\n            } else if (b \u003c 0xFC) {\n                ptr += 5;\n            } else {\n                ptr += 6;\n            }\n        }\n    }\n\n    /*\n     * @dev Returns true if the slice is empty (has a length of 0).\n     * @param self The slice to operate on.\n     * @return True if the slice is empty, False otherwise.\n     */\n    function empty(slice memory self) internal pure returns (bool) {\n        return self._len == 0;\n    }\n\n    /*\n     * @dev Returns a positive number if `other` comes lexicographically after\n     *      `self`, a negative number if it comes before, or zero if the\n     *      contents of the two slices are equal. Comparison is done per-rune,\n     *      on unicode codepoints.\n     * @param self The first slice to compare.\n     * @param other The second slice to compare.\n     * @return The result of the comparison.\n     */\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\n        uint shortest = self._len;\n        if (other._len \u003c self._len)\n            shortest = other._len;\n\n        uint selfptr = self._ptr;\n        uint otherptr = other._ptr;\n        for (uint idx = 0; idx \u003c shortest; idx += 32) {\n            uint a;\n            uint b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint256 mask = uint256(-1); // 0xffff...\n                if (shortest \u003c 32) {\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                }\n                uint256 diff = (a \u0026 mask) - (b \u0026 mask);\n                if (diff != 0)\n                    return int(diff);\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n        return int(self._len) - int(other._len);\n    }\n\n    /*\n     * @dev Returns true if the two slices contain the same text.\n     * @param self The first slice to compare.\n     * @param self The second slice to compare.\n     * @return True if the slices are equal, false otherwise.\n     */\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\n        return compare(self, other) == 0;\n    }\n\n    /*\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\n     *      slice to point to the next rune and returning `self`.\n     * @param self The slice to operate on.\n     * @param rune The slice that will contain the first rune.\n     * @return `rune`.\n     */\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n        rune._ptr = self._ptr;\n\n        if (self._len == 0) {\n            rune._len = 0;\n            return rune;\n        }\n\n        uint l;\n        uint b;\n        // Load the first byte of the rune into the LSBs of b\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n        if (b \u003c 0x80) {\n            l = 1;\n        } else if (b \u003c 0xE0) {\n            l = 2;\n        } else if (b \u003c 0xF0) {\n            l = 3;\n        } else {\n            l = 4;\n        }\n\n        // Check for truncated codepoints\n        if (l \u003e self._len) {\n            rune._len = self._len;\n            self._ptr += self._len;\n            self._len = 0;\n            return rune;\n        }\n\n        self._ptr += l;\n        self._len -= l;\n        rune._len = l;\n        return rune;\n    }\n\n    /*\n     * @dev Returns the first rune in the slice, advancing the slice to point\n     *      to the next rune.\n     * @param self The slice to operate on.\n     * @return A slice containing only the first rune from `self`.\n     */\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\n        nextRune(self, ret);\n    }\n\n    /*\n     * @dev Returns the number of the first codepoint in the slice.\n     * @param self The slice to operate on.\n     * @return The number of the first codepoint in the slice.\n     */\n    function ord(slice memory self) internal pure returns (uint ret) {\n        if (self._len == 0) {\n            return 0;\n        }\n\n        uint word;\n        uint length;\n        uint divisor = 2 ** 248;\n\n        // Load the rune into the MSBs of b\n        assembly { word:= mload(mload(add(self, 32))) }\n        uint b = word / divisor;\n        if (b \u003c 0x80) {\n            ret = b;\n            length = 1;\n        } else if (b \u003c 0xE0) {\n            ret = b \u0026 0x1F;\n            length = 2;\n        } else if (b \u003c 0xF0) {\n            ret = b \u0026 0x0F;\n            length = 3;\n        } else {\n            ret = b \u0026 0x07;\n            length = 4;\n        }\n\n        // Check for truncated codepoints\n        if (length \u003e self._len) {\n            return 0;\n        }\n\n        for (uint i = 1; i \u003c length; i++) {\n            divisor = divisor / 256;\n            b = (word / divisor) \u0026 0xFF;\n            if (b \u0026 0xC0 != 0x80) {\n                // Invalid UTF-8 sequence\n                return 0;\n            }\n            ret = (ret * 64) | (b \u0026 0x3F);\n        }\n\n        return ret;\n    }\n\n    /*\n     * @dev Returns the keccak-256 hash of the slice.\n     * @param self The slice to hash.\n     * @return The hash of the slice.\n     */\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n        assembly {\n            ret := keccak256(mload(add(self, 32)), mload(self))\n        }\n    }\n\n    /*\n     * @dev Returns true if `self` starts with `needle`.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return True if the slice starts with the provided text, false otherwise.\n     */\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n        if (self._len \u003c needle._len) {\n            return false;\n        }\n\n        if (self._ptr == needle._ptr) {\n            return true;\n        }\n\n        bool equal;\n        assembly {\n            let length := mload(needle)\n            let selfptr := mload(add(self, 0x20))\n            let needleptr := mload(add(needle, 0x20))\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n        }\n        return equal;\n    }\n\n    /*\n     * @dev If `self` starts with `needle`, `needle` is removed from the\n     *      beginning of `self`. Otherwise, `self` is unmodified.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return `self`\n     */\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n        if (self._len \u003c needle._len) {\n            return self;\n        }\n\n        bool equal = true;\n        if (self._ptr != needle._ptr) {\n            assembly {\n                let length := mload(needle)\n                let selfptr := mload(add(self, 0x20))\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n            }\n        }\n\n        if (equal) {\n            self._len -= needle._len;\n            self._ptr += needle._len;\n        }\n\n        return self;\n    }\n\n    /*\n     * @dev Returns true if the slice ends with `needle`.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return True if the slice starts with the provided text, false otherwise.\n     */\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n        if (self._len \u003c needle._len) {\n            return false;\n        }\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        if (selfptr == needle._ptr) {\n            return true;\n        }\n\n        bool equal;\n        assembly {\n            let length := mload(needle)\n            let needleptr := mload(add(needle, 0x20))\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n        }\n\n        return equal;\n    }\n\n    /*\n     * @dev If `self` ends with `needle`, `needle` is removed from the\n     *      end of `self`. Otherwise, `self` is unmodified.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return `self`\n     */\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n        if (self._len \u003c needle._len) {\n            return self;\n        }\n\n        uint selfptr = self._ptr + self._len - needle._len;\n        bool equal = true;\n        if (selfptr != needle._ptr) {\n            assembly {\n                let length := mload(needle)\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n            }\n        }\n\n        if (equal) {\n            self._len -= needle._len;\n        }\n\n        return self;\n    }\n\n    // Returns the memory address of the first byte of the first occurrence of\n    // `needle` in `self`, or the first byte after `self` if not found.\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n        uint ptr = selfptr;\n        uint idx;\n\n        if (needlelen \u003c= selflen) {\n            if (needlelen \u003c= 32) {\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n                bytes32 needledata;\n                assembly { needledata := and(mload(needleptr), mask) }\n\n                uint end = selfptr + selflen - needlelen;\n                bytes32 ptrdata;\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n                while (ptrdata != needledata) {\n                    if (ptr \u003e= end)\n                        return selfptr + selflen;\n                    ptr++;\n                    assembly { ptrdata := and(mload(ptr), mask) }\n                }\n                return ptr;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                for (idx = 0; idx \u003c= selflen - needlelen; idx++) {\n                    bytes32 testHash;\n                    assembly { testHash := keccak256(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr;\n                    ptr += 1;\n                }\n            }\n        }\n        return selfptr + selflen;\n    }\n\n    // Returns the memory address of the first byte after the last occurrence of\n    // `needle` in `self`, or the address of `self` if not found.\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n        uint ptr;\n\n        if (needlelen \u003c= selflen) {\n            if (needlelen \u003c= 32) {\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n                bytes32 needledata;\n                assembly { needledata := and(mload(needleptr), mask) }\n\n                ptr = selfptr + selflen - needlelen;\n                bytes32 ptrdata;\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n                while (ptrdata != needledata) {\n                    if (ptr \u003c= selfptr)\n                        return selfptr;\n                    ptr--;\n                    assembly { ptrdata := and(mload(ptr), mask) }\n                }\n                return ptr + needlelen;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := keccak256(needleptr, needlelen) }\n                ptr = selfptr + (selflen - needlelen);\n                while (ptr \u003e= selfptr) {\n                    bytes32 testHash;\n                    assembly { testHash := keccak256(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr + needlelen;\n                    ptr -= 1;\n                }\n            }\n        }\n        return selfptr;\n    }\n\n    /*\n     * @dev Modifies `self` to contain everything from the first occurrence of\n     *      `needle` to the end of the slice. `self` is set to the empty slice\n     *      if `needle` is not found.\n     * @param self The slice to search and modify.\n     * @param needle The text to search for.\n     * @return `self`.\n     */\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n        self._len -= ptr - self._ptr;\n        self._ptr = ptr;\n        return self;\n    }\n\n    /*\n     * @dev Modifies `self` to contain the part of the string from the start of\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\n     *      is not found, `self` is set to the empty slice.\n     * @param self The slice to search and modify.\n     * @param needle The text to search for.\n     * @return `self`.\n     */\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n        self._len = ptr - self._ptr;\n        return self;\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything after the first\n     *      occurrence of `needle`, and `token` to everything before it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and `token` is set to the entirety of `self`.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @param token An output parameter to which the first token is written.\n     * @return `token`.\n     */\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n        token._ptr = self._ptr;\n        token._len = ptr - self._ptr;\n        if (ptr == self._ptr + self._len) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n            self._ptr = ptr + needle._len;\n        }\n        return token;\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything after the first\n     *      occurrence of `needle`, and returning everything before it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and the entirety of `self` is returned.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @return The part of `self` up to the first occurrence of `delim`.\n     */\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n        split(self, needle, token);\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything before the last\n     *      occurrence of `needle`, and `token` to everything after it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and `token` is set to the entirety of `self`.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @param token An output parameter to which the first token is written.\n     * @return `token`.\n     */\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n        token._ptr = ptr;\n        token._len = self._len - (ptr - self._ptr);\n        if (ptr == self._ptr) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n        }\n        return token;\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything before the last\n     *      occurrence of `needle`, and returning everything after it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and the entirety of `self` is returned.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @return The part of `self` after the last occurrence of `delim`.\n     */\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n        rsplit(self, needle, token);\n    }\n\n    /*\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n     * @param self The slice to search.\n     * @param needle The text to search for in `self`.\n     * @return The number of occurrences of `needle` found in `self`.\n     */\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n        while (ptr \u003c= self._ptr + self._len) {\n            cnt++;\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n        }\n    }\n\n    /*\n     * @dev Returns True if `self` contains `needle`.\n     * @param self The slice to search.\n     * @param needle The text to search for in `self`.\n     * @return True if `needle` is found in `self`, false otherwise.\n     */\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n    }\n\n    /*\n     * @dev Returns a newly allocated string containing the concatenation of\n     *      `self` and `other`.\n     * @param self The first slice to concatenate.\n     * @param other The second slice to concatenate.\n     * @return The concatenation of the two strings.\n     */\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n        string memory ret = new string(self._len + other._len);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n        memcpy(retptr, self._ptr, self._len);\n        memcpy(retptr + self._len, other._ptr, other._len);\n        return ret;\n    }\n\n    /*\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\n     *      newly allocated string.\n     * @param self The delimiter to use.\n     * @param parts A list of slices to join.\n     * @return A newly allocated string containing all the slices in `parts`,\n     *         joined with `self`.\n     */\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n        if (parts.length == 0)\n            return \"\";\n\n        uint length = self._len * (parts.length - 1);\n        for (uint i = 0; i \u003c parts.length; i++) {\n            length += parts[i]._len;\n        }\n\n        string memory ret = new string(length);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n\n        for (uint i = 0; i \u003c parts.length; i++) {\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n            retptr += parts[i]._len;\n            if (i \u003c parts.length - 1) {\n                memcpy(retptr, self._ptr, self._len);\n                retptr += self._len;\n            }\n        }\n\n        return ret;\n    }\n}\n"},"TextResolver.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ResolverBase.sol\";\n\ncontract TextResolver is ResolverBase {\n    bytes4 constant private TEXT_INTERFACE_ID = 0x59d1d43c;\n\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\n\n    mapping(bytes32=\u003emapping(string=\u003estring)) texts;\n\n    /**\n     * Sets the text data associated with an ENS node and key.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param key The key to set.\n     * @param value The text data value to set.\n     */\n    function setText(bytes32 node, string calldata key, string calldata value) external authorised(node) {\n        texts[node][key] = value;\n        emit TextChanged(node, key, key);\n    }\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(bytes32 node, string calldata key) external view returns (string memory) {\n        return texts[node][key];\n    }\n\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\n        return interfaceID == TEXT_INTERFACE_ID || super.supportsInterface(interfaceID);\n    }\n}\n"},"tokenWhitelist.sol":{"content":"/**\n *  TokenWhitelist - The Consumer Contract Wallet\n *  Copyright (C) 2019 The Contract Wallet Company Limited\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n */\n\npragma solidity ^0.5.10;\n\nimport \"./controllable.sol\";\nimport \"./transferrable.sol\";\nimport \"./bytesUtils.sol\";\nimport \"./strings.sol\";\nimport \"./SafeMath.sol\";\n\n/// @title The ITokenWhitelist interface provides access to a whitelist of tokens.\ninterface ITokenWhitelist {\n    function getTokenInfo(address) external view returns (string memory, uint256, uint256, bool, bool, bool, uint256);\n    function getStablecoinInfo() external view returns (string memory, uint256, uint256, bool, bool, bool, uint256);\n    function tokenAddressArray() external view returns (address[] memory);\n    function redeemableTokens() external view returns (address[] memory);\n    function methodIdWhitelist(bytes4) external view returns (bool);\n    function getERC20RecipientAndAmount(address, bytes calldata) external view returns (address, uint);\n    function stablecoin() external view returns (address);\n    function updateTokenRate(address, uint, uint) external;\n}\n\n\n/// @title TokenWhitelist stores a list of tokens used by the Consumer Contract Wallet, the Oracle, the TKN Holder and the TKN Licence Contract\ncontract TokenWhitelist is ENSResolvable, Controllable, Transferrable {\n    using strings for *;\n    using SafeMath for uint256;\n    using BytesUtils for bytes;\n\n    event UpdatedTokenRate(address _sender, address _token, uint _rate);\n\n    event UpdatedTokenLoadable(address _sender, address _token, bool _loadable);\n    event UpdatedTokenRedeemable(address _sender, address _token, bool _redeemable);\n\n    event AddedToken(address _sender, address _token, string _symbol, uint _magnitude, bool _loadable, bool _redeemable);\n    event RemovedToken(address _sender, address _token);\n\n    event AddedMethodId(bytes4 _methodId);\n    event RemovedMethodId(bytes4 _methodId);\n    event AddedExclusiveMethod(address _token, bytes4 _methodId);\n    event RemovedExclusiveMethod(address _token, bytes4 _methodId);\n\n    event Claimed(address _to, address _asset, uint _amount);\n\n    /// @dev these are the methods whitelisted by default in executeTransaction() for protected tokens\n    bytes4 private constant _APPROVE = 0x095ea7b3; // keccak256(approve(address,uint256)) =\u003e 0x095ea7b3\n    bytes4 private constant _BURN = 0x42966c68; // keccak256(burn(uint256)) =\u003e 0x42966c68\n    bytes4 private constant _TRANSFER= 0xa9059cbb; // keccak256(transfer(address,uint256)) =\u003e 0xa9059cbb\n    bytes4 private constant _TRANSFER_FROM = 0x23b872dd; // keccak256(transferFrom(address,address,uint256)) =\u003e 0x23b872dd\n\n    struct Token {\n        string symbol;    // Token symbol\n        uint magnitude;   // 10^decimals\n        uint rate;        // Token exchange rate in wei\n        bool available;   // Flags if the token is available or not\n        bool loadable;    // Flags if token is loadable to the TokenCard\n        bool redeemable;    // Flags if token is redeemable in the TKN Holder contract\n        uint lastUpdate;  // Time of the last rate update\n    }\n\n    mapping(address =\u003e Token) private _tokenInfoMap;\n\n    // @notice specifies whitelisted methodIds for protected tokens in wallet\u0027s excuteTranaction() e.g. keccak256(transfer(address,uint256)) =\u003e 0xa9059cbb\n    mapping(bytes4 =\u003e bool) private _methodIdWhitelist;\n\n    address[] private _tokenAddressArray;\n\n    /// @notice keeping track of how many redeemable tokens are in the tokenWhitelist\n    uint private _redeemableCounter;\n\n    /// @notice Address of the stablecoin.\n    address private _stablecoin;\n\n    /// @notice is registered ENS node identifying the oracle contract.\n    bytes32 private _oracleNode;\n\n    /// @notice Constructor initializes ENSResolvable, and Controllable.\n    /// @param _ens_ is the ENS registry address.\n    /// @param _oracleNode_ is the ENS node of the Oracle.\n    /// @param _controllerNode_ is our Controllers node.\n    /// @param _stablecoinAddress_ is the address of the stablecoint used by the wallet for the card load limit.\n    constructor(address _ens_, bytes32 _oracleNode_, bytes32 _controllerNode_, address _stablecoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNode_) public {\n        _oracleNode = _oracleNode_;\n        _stablecoin = _stablecoinAddress_;\n        //a priori ERC20 whitelisted methods\n        _methodIdWhitelist[_APPROVE] = true;\n        _methodIdWhitelist[_BURN] = true;\n        _methodIdWhitelist[_TRANSFER] = true;\n        _methodIdWhitelist[_TRANSFER_FROM] = true;\n    }\n\n    modifier onlyAdminOrOracle() {\n        address oracleAddress = _ensResolve(_oracleNode);\n        require (_isAdmin(msg.sender) || msg.sender == oracleAddress, \"either oracle or admin\");\n        _;\n    }\n\n    /// @notice Add ERC20 tokens to the list of whitelisted tokens.\n    /// @param _tokens ERC20 token contract addresses.\n    /// @param _symbols ERC20 token names.\n    /// @param _magnitude 10 to the power of number of decimal places used by each ERC20 token.\n    /// @param _loadable is a bool that states whether or not a token is loadable to the TokenCard.\n    /// @param _redeemable is a bool that states whether or not a token is redeemable in the TKN Holder Contract.\n    /// @param _lastUpdate is a unit representing an ISO datetime e.g. 20180913153211.\n    function addTokens(address[] calldata _tokens, bytes32[] calldata _symbols, uint[] calldata _magnitude, bool[] calldata _loadable, bool[] calldata _redeemable, uint _lastUpdate) external onlyAdmin {\n        // Require that all parameters have the same length.\n        require(_tokens.length == _symbols.length \u0026\u0026 _tokens.length == _magnitude.length \u0026\u0026 _tokens.length == _loadable.length \u0026\u0026 _tokens.length == _loadable.length, \"parameter lengths do not match\");\n        // Add each token to the list of supported tokens.\n        for (uint i = 0; i \u003c _tokens.length; i++) {\n            // Require that the token isn\u0027t already available.\n            require(!_tokenInfoMap[_tokens[i]].available, \"token already available\");\n            // Store the intermediate values.\n            string memory symbol = _symbols[i].toSliceB32().toString();\n            // Add the token to the token list.\n            _tokenInfoMap[_tokens[i]] = Token({\n                symbol : symbol,\n                magnitude : _magnitude[i],\n                rate : 0,\n                available : true,\n                loadable : _loadable[i],\n                redeemable: _redeemable[i],\n                lastUpdate : _lastUpdate\n                });\n            // Add the token address to the address list.\n            _tokenAddressArray.push(_tokens[i]);\n            //if the token is redeemable increase the redeemableCounter\n            if (_redeemable[i]){\n                _redeemableCounter = _redeemableCounter.add(1);\n            }\n            // Emit token addition event.\n            emit AddedToken(msg.sender, _tokens[i], symbol, _magnitude[i], _loadable[i], _redeemable[i]);\n        }\n    }\n\n    /// @notice Remove ERC20 tokens from the whitelist of tokens.\n    /// @param _tokens ERC20 token contract addresses.\n    function removeTokens(address[] calldata _tokens) external onlyAdmin {\n        // Delete each token object from the list of supported tokens based on the addresses provided.\n        for (uint i = 0; i \u003c _tokens.length; i++) {\n            // Store the token address.\n            address token = _tokens[i];\n            //token must be available, reverts on duplicates as well\n            require(_tokenInfoMap[token].available, \"token is not available\");\n            //if the token is redeemable decrease the redeemableCounter\n            if (_tokenInfoMap[token].redeemable){\n                _redeemableCounter = _redeemableCounter.sub(1);\n            }\n            // Delete the token object.\n            delete _tokenInfoMap[token];\n            // Remove the token address from the address list.\n            for (uint j = 0; j \u003c _tokenAddressArray.length.sub(1); j++) {\n                if (_tokenAddressArray[j] == token) {\n                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n                    break;\n                }\n            }\n            _tokenAddressArray.length--;\n            // Emit token removal event.\n            emit RemovedToken(msg.sender, token);\n        }\n    }\n\n    /// @notice based on the method it returns the recipient address and amount/value, ERC20 specific.\n    /// @param _data is the transaction payload.\n    function getERC20RecipientAndAmount(address _token, bytes calldata _data) external view returns (address, uint) {\n        // Require that there exist enough bytes for encoding at least a method signature + data in the transaction payload:\n        // 4 (signature)  + 32(address or uint256)\n        require(_data.length \u003e= 4 + 32, \"not enough method-encoding bytes\");\n        // Get the method signature\n        bytes4 signature = _data._bytesToBytes4(0);\n        // Check if method Id is supported\n        require(isERC20MethodSupported(_token, signature), \"unsupported method\");\n        // returns the recipient\u0027s address and amount is the value to be transferred\n        if (signature == _BURN) {\n            // 4 (signature) + 32(uint256)\n            return (_token, _data._bytesToUint256(4));\n        } else if (signature == _TRANSFER_FROM) {\n            // 4 (signature) + 32(address) + 32(address) + 32(uint256)\n            require(_data.length \u003e= 4 + 32 + 32 + 32, \"not enough data for transferFrom\");\n            return ( _data._bytesToAddress(4 + 32 + 12), _data._bytesToUint256(4 + 32 + 32));\n        } else { //transfer or approve\n            // 4 (signature) + 32(address) + 32(uint)\n            require(_data.length \u003e= 4 + 32 + 32, \"not enough data for transfer/appprove\");\n            return (_data._bytesToAddress(4 + 12), _data._bytesToUint256(4 + 32));\n        }\n    }\n\n    /// @notice Toggles whether or not a token is loadable or not.\n    function setTokenLoadable(address _token, bool _loadable) external onlyAdmin {\n        // Require that the token exists.\n        require(_tokenInfoMap[_token].available, \"token is not available\");\n\n        // this sets the loadable flag to the value passed in\n        _tokenInfoMap[_token].loadable = _loadable;\n\n        emit UpdatedTokenLoadable(msg.sender, _token, _loadable);\n    }\n\n    /// @notice Toggles whether or not a token is redeemable or not.\n    function setTokenRedeemable(address _token, bool _redeemable) external onlyAdmin {\n        // Require that the token exists.\n        require(_tokenInfoMap[_token].available, \"token is not available\");\n\n        // this sets the redeemable flag to the value passed in\n        _tokenInfoMap[_token].redeemable = _redeemable;\n\n        emit UpdatedTokenRedeemable(msg.sender, _token, _redeemable);\n    }\n\n    /// @notice Update ERC20 token exchange rate.\n    /// @param _token ERC20 token contract address.\n    /// @param _rate ERC20 token exchange rate in wei.\n    /// @param _updateDate date for the token updates. This will be compared to when oracle updates are received.\n    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyAdminOrOracle {\n        // Require that the token exists.\n        require(_tokenInfoMap[_token].available, \"token is not available\");\n        // Update the token\u0027s rate.\n        _tokenInfoMap[_token].rate = _rate;\n        // Update the token\u0027s last update timestamp.\n        _tokenInfoMap[_token].lastUpdate = _updateDate;\n        // Emit the rate update event.\n        emit UpdatedTokenRate(msg.sender, _token, _rate);\n    }\n\n    //// @notice Withdraw tokens from the smart contract to the specified account.\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin {\n        _safeTransfer(_to, _asset, _amount);\n        emit Claimed(_to, _asset, _amount);\n    }\n\n    /// @notice This returns all of the fields for a given token.\n    /// @param _a is the address of a given token.\n    /// @return string of the token\u0027s symbol.\n    /// @return uint of the token\u0027s magnitude.\n    /// @return uint of the token\u0027s exchange rate to ETH.\n    /// @return bool whether the token is available.\n    /// @return bool whether the token is loadable to the TokenCard.\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\n    /// @return uint of the lastUpdated time of the token\u0027s exchange rate.\n    function getTokenInfo(address _a) external view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\n        Token storage tokenInfo = _tokenInfoMap[_a];\n        return (tokenInfo.symbol, tokenInfo.magnitude, tokenInfo.rate, tokenInfo.available, tokenInfo.loadable, tokenInfo.redeemable, tokenInfo.lastUpdate);\n    }\n\n    /// @notice This returns all of the fields for our StableCoin.\n    /// @return string of the token\u0027s symbol.\n    /// @return uint of the token\u0027s magnitude.\n    /// @return uint of the token\u0027s exchange rate to ETH.\n    /// @return bool whether the token is available.\n    /// @return bool whether the token is loadable to the TokenCard.\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\n    /// @return uint of the lastUpdated time of the token\u0027s exchange rate.\n    function getStablecoinInfo() external view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\n        Token storage stablecoinInfo = _tokenInfoMap[_stablecoin];\n        return (stablecoinInfo.symbol, stablecoinInfo.magnitude, stablecoinInfo.rate, stablecoinInfo.available, stablecoinInfo.loadable, stablecoinInfo.redeemable, stablecoinInfo.lastUpdate);\n    }\n\n    /// @notice This returns an array of all whitelisted token addresses.\n    /// @return address[] of whitelisted tokens.\n    function tokenAddressArray() external view returns (address[] memory) {\n        return _tokenAddressArray;\n    }\n\n    /// @notice This returns an array of all redeemable token addresses.\n    /// @return address[] of redeemable tokens.\n    function redeemableTokens() external view returns (address[] memory) {\n        address[] memory redeemableAddresses = new address[](_redeemableCounter);\n        uint redeemableIndex = 0;\n        for (uint i = 0; i \u003c _tokenAddressArray.length; i++) {\n            address token = _tokenAddressArray[i];\n            if (_tokenInfoMap[token].redeemable){\n                redeemableAddresses[redeemableIndex] = token;\n                redeemableIndex += 1;\n            }\n        }\n        return redeemableAddresses;\n    }\n\n\n    /// @notice This returns true if a method Id is supported for the specific token.\n    /// @return true if _methodId is supported in general or just for the specific token.\n    function isERC20MethodSupported(address _token, bytes4 _methodId) public view returns (bool) {\n        require(_tokenInfoMap[_token].available, \"non-existing token\");\n        return (_methodIdWhitelist[_methodId]);\n    }\n\n    /// @notice This returns true if the method is supported for all protected tokens.\n    /// @return true if _methodId is in the method whitelist.\n    function isERC20MethodWhitelisted(bytes4 _methodId) external view returns (bool) {\n        return (_methodIdWhitelist[_methodId]);\n    }\n\n    /// @notice This returns the number of redeemable tokens.\n    /// @return current # of redeemables.\n    function redeemableCounter() external view returns (uint) {\n        return _redeemableCounter;\n    }\n\n    /// @notice This returns the address of our stablecoin of choice.\n    /// @return the address of the stablecoin contract.\n    function stablecoin() external view returns (address) {\n        return _stablecoin;\n    }\n\n    /// @notice this returns the node hash of our Oracle.\n    /// @return the oracle node registered in ENS.\n    function oracleNode() external view returns (bytes32) {\n        return _oracleNode;\n    }\n}\n"},"tokenWhitelistable.sol":{"content":"/**\n *  TokenWhitelistable - The Consumer Contract Wallet\n *  Copyright (C) 2019 The Contract Wallet Company Limited\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n */\n\npragma solidity ^0.5.10;\n\nimport \"./tokenWhitelist.sol\";\nimport \"./ensResolvable.sol\";\n\n\n/// @title TokenWhitelistable implements access to the TokenWhitelist located behind ENS.\ncontract TokenWhitelistable is ENSResolvable {\n\n    /// @notice Is the registered ENS node identifying the tokenWhitelist contract\n    bytes32 private _tokenWhitelistNode;\n\n    /// @notice Constructor initializes the TokenWhitelistable object.\n    /// @param _tokenWhitelistNode_ is the ENS node of the TokenWhitelist.\n    constructor(bytes32 _tokenWhitelistNode_) internal {\n        _tokenWhitelistNode = _tokenWhitelistNode_;\n    }\n\n    /// @notice This shows what TokenWhitelist is being used\n    /// @return TokenWhitelist\u0027s node registered in ENS.\n    function tokenWhitelistNode() external view returns (bytes32) {\n        return _tokenWhitelistNode;\n    }\n\n    /// @notice This returns all of the fields for a given token.\n    /// @param _a is the address of a given token.\n    /// @return string of the token\u0027s symbol.\n    /// @return uint of the token\u0027s magnitude.\n    /// @return uint of the token\u0027s exchange rate to ETH.\n    /// @return bool whether the token is available.\n    /// @return bool whether the token is loadable to the TokenCard.\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\n    /// @return uint of the lastUpdated time of the token\u0027s exchange rate.\n    function _getTokenInfo(address _a) internal view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getTokenInfo(_a);\n    }\n\n    /// @notice This returns all of the fields for our stablecoin token.\n    /// @return string of the token\u0027s symbol.\n    /// @return uint of the token\u0027s magnitude.\n    /// @return uint of the token\u0027s exchange rate to ETH.\n    /// @return bool whether the token is available.\n    /// @return bool whether the token is loadable to the TokenCard.\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\n    /// @return uint of the lastUpdated time of the token\u0027s exchange rate.\n    function _getStablecoinInfo() internal view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getStablecoinInfo();\n    }\n\n    /// @notice This returns an array of our whitelisted addresses.\n    /// @return address[] of our whitelisted tokens.\n    function _tokenAddressArray() internal view returns (address[] memory) {\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).tokenAddressArray();\n    }\n\n    /// @notice This returns an array of all redeemable token addresses.\n    /// @return address[] of redeemable tokens.\n    function _redeemableTokens() internal view returns (address[] memory) {\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).redeemableTokens();\n    }\n\n    /// @notice Update ERC20 token exchange rate.\n    /// @param _token ERC20 token contract address.\n    /// @param _rate ERC20 token exchange rate in wei.\n    /// @param _updateDate date for the token updates. This will be compared to when oracle updates are received.\n    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n        ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).updateTokenRate(_token, _rate, _updateDate);\n    }\n\n    /// @notice based on the method it returns the recipient address and amount/value, ERC20 specific.\n    /// @param _data is the transaction payload.\n    function _getERC20RecipientAndAmount(address _destination, bytes memory _data) internal view returns (address, uint) {\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getERC20RecipientAndAmount(_destination, _data);\n    }\n\n    /// @notice Checks whether a token is available.\n    /// @return bool available or not.\n    function _isTokenAvailable(address _a) internal view returns (bool) {\n        ( , , , bool available, , , ) = _getTokenInfo(_a);\n        return available;\n    }\n\n    /// @notice Checks whether a token is redeemable.\n    /// @return bool redeemable or not.\n    function _isTokenRedeemable(address _a) internal view returns (bool) {\n        ( , , , , , bool redeemable, ) = _getTokenInfo(_a);\n        return redeemable;\n    }\n\n    /// @notice Checks whether a token is loadable.\n    /// @return bool loadable or not.\n    function _isTokenLoadable(address _a) internal view returns (bool) {\n        ( , , , , bool loadable, , ) = _getTokenInfo(_a);\n        return loadable;\n    }\n\n    /// @notice This gets the address of the stablecoin.\n    /// @return the address of the stablecoin contract.\n    function _stablecoin() internal view returns (address) {\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).stablecoin();\n    }\n\n}\n"},"transferrable.sol":{"content":"/**\n *  Transferrable - The Consumer Contract Wallet\n *  Copyright (C) 2019 The Contract Wallet Company Limited\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n */\n\npragma solidity ^0.5.10;\n\nimport \"./ERC20.sol\";\nimport \"./SafeERC20.sol\";\n\n\n/// @title SafeTransfer, allowing contract to withdraw tokens accidentally sent to itself\ncontract Transferrable {\n\n    using SafeERC20 for ERC20;\n\n\n    /// @dev This function is used to move tokens sent accidentally to this contract method.\n    /// @dev The owner can chose the new destination address\n    /// @param _to is the recipient\u0027s address.\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\n    /// @param _amount is the amount to be transferred in base units.\n    function _safeTransfer(address payable _to, address _asset, uint _amount) internal {\n        // address(0) is used to denote ETH\n        if (_asset == address(0)) {\n            _to.transfer(_amount);\n        } else {\n            ERC20(_asset).safeTransfer(_to, _amount);\n        }\n    }\n}\n"},"wallet.sol":{"content":"/**\n *  The Consumer Contract Wallet\n *  Copyright (C) 2019 The Contract Wallet Company Limited\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n */\n\npragma solidity ^0.5.10;\n\nimport \"./licence.sol\";\nimport \"./ownable.sol\";\nimport \"./controllable.sol\";\nimport \"./balanceable.sol\";\nimport \"./transferrable.sol\";\nimport \"./ensResolvable.sol\";\nimport \"./tokenWhitelistable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\nimport \"./ERC20.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./ERC165.sol\";\n\n\n/// @title ControllableOwnable combines Controllable and Ownable\n/// @dev providing an additional modifier to check if Owner or Controller\ncontract ControllableOwnable is Controllable, Ownable {\n    /// @dev Check if the sender is the Owner or one of the Controllers\n    modifier onlyOwnerOrController() {\n        require (_isOwner(msg.sender) || _isController(msg.sender), \"either owner or controller\");\n        _;\n    }\n}\n\n\n/// @title AddressWhitelist provides payee-whitelist functionality.\n/// @dev This contract will allow the user to maintain a whitelist of addresses\n/// @dev These addresses will live outside of the various spend limits\ncontract AddressWhitelist is ControllableOwnable {\n    using SafeMath for uint256;\n\n    event AddedToWhitelist(address _sender, address[] _addresses);\n    event SubmittedWhitelistAddition(address[] _addresses, bytes32 _hash);\n    event CancelledWhitelistAddition(address _sender, bytes32 _hash);\n\n    event RemovedFromWhitelist(address _sender, address[] _addresses);\n    event SubmittedWhitelistRemoval(address[] _addresses, bytes32 _hash);\n    event CancelledWhitelistRemoval(address _sender, bytes32 _hash);\n\n    mapping(address =\u003e bool) public whitelistMap;\n    address[] public whitelistArray;\n    address[] private _pendingWhitelistAddition;\n    address[] private _pendingWhitelistRemoval;\n    bool public submittedWhitelistAddition;\n    bool public submittedWhitelistRemoval;\n    bool public isSetWhitelist;\n\n    /// @dev Check if the provided addresses contain the owner or the zero-address address.\n    modifier hasNoOwnerOrZeroAddress(address[] memory _addresses) {\n        for (uint i = 0; i \u003c _addresses.length; i++) {\n            require(!_isOwner(_addresses[i]), \"provided whitelist contains the owner address\");\n            require(_addresses[i] != address(0), \"provided whitelist contains the zero address\");\n        }\n        _;\n    }\n\n    /// @dev Check that neither addition nor removal operations have already been submitted.\n    modifier noActiveSubmission() {\n        require(!submittedWhitelistAddition \u0026\u0026 !submittedWhitelistRemoval, \"whitelist operation has already been submitted\");\n        _;\n    }\n\n    /// @dev Getter for pending addition array.\n    function pendingWhitelistAddition() external view returns (address[] memory) {\n        return _pendingWhitelistAddition;\n    }\n\n    /// @dev Getter for pending removal array.\n    function pendingWhitelistRemoval() external view returns (address[] memory) {\n        return _pendingWhitelistRemoval;\n    }\n\n    /// @dev Add initial addresses to the whitelist.\n    /// @param _addresses are the Ethereum addresses to be whitelisted.\n    function setWhitelist(address[] calldata _addresses) external onlyOwner hasNoOwnerOrZeroAddress(_addresses) {\n        // Require that the whitelist has not been initialized.\n        require(!isSetWhitelist, \"whitelist has already been initialized\");\n        // Add each of the provided addresses to the whitelist.\n        for (uint i = 0; i \u003c _addresses.length; i++) {\n            // adds to the whitelist mapping\n            whitelistMap[_addresses[i]] = true;\n            // adds to the whitelist array\n            whitelistArray.push(_addresses[i]);\n        }\n        isSetWhitelist = true;\n        // Emit the addition event.\n        emit AddedToWhitelist(msg.sender, _addresses);\n    }\n\n    /// @dev Add addresses to the whitelist.\n    /// @param _addresses are the Ethereum addresses to be whitelisted.\n    function submitWhitelistAddition(address[] calldata _addresses) external onlyOwner noActiveSubmission hasNoOwnerOrZeroAddress(_addresses) {\n        // Require that the whitelist has been initialized.\n        require(isSetWhitelist, \"whitelist has not been initialized\");\n        // Require this array of addresses not empty\n        require(_addresses.length \u003e 0, \"pending whitelist addition is empty\");\n        // Set the provided addresses to the pending addition addresses.\n        _pendingWhitelistAddition = _addresses;\n        // Flag the operation as submitted.\n        submittedWhitelistAddition = true;\n        // Emit the submission event.\n        emit SubmittedWhitelistAddition(_addresses, calculateHash(_addresses));\n    }\n\n    /// @dev Confirm pending whitelist addition.\n    /// @dev This will only ever be applied post 2FA, by one of the Controllers\n    /// @param _hash is the hash of the pending whitelist array, a form of lamport lock\n    function confirmWhitelistAddition(bytes32 _hash) external onlyController {\n        // Require that the whitelist addition has been submitted.\n        require(submittedWhitelistAddition, \"whitelist addition has not been submitted\");\n        // Require that confirmation hash and the hash of the pending whitelist addition match\n        require(_hash == calculateHash(_pendingWhitelistAddition), \"hash of the pending whitelist addition do not match\");\n        // Whitelist pending addresses.\n        for (uint i = 0; i \u003c _pendingWhitelistAddition.length; i++) {\n            // check if it doesn\u0027t exist already.\n            if (!whitelistMap[_pendingWhitelistAddition[i]]) {\n                // add to the Map and the Array\n                whitelistMap[_pendingWhitelistAddition[i]] = true;\n                whitelistArray.push(_pendingWhitelistAddition[i]);\n            }\n        }\n        // Emit the addition event.\n        emit AddedToWhitelist(msg.sender, _pendingWhitelistAddition);\n        // Reset pending addresses.\n        delete _pendingWhitelistAddition;\n        // Reset the submission flag.\n        submittedWhitelistAddition = false;\n    }\n\n    /// @dev Cancel pending whitelist addition.\n    function cancelWhitelistAddition(bytes32 _hash) external onlyOwnerOrController {\n        // Check if operation has been submitted.\n        require(submittedWhitelistAddition, \"whitelist addition has not been submitted\");\n        // Require that confirmation hash and the hash of the pending whitelist addition match\n        require(_hash == calculateHash(_pendingWhitelistAddition), \"hash of the pending whitelist addition does not match\");\n        // Reset pending addresses.\n        delete _pendingWhitelistAddition;\n        // Reset the submitted operation flag.\n        submittedWhitelistAddition = false;\n        // Emit the cancellation event.\n        emit CancelledWhitelistAddition(msg.sender, _hash);\n    }\n\n    /// @dev Remove addresses from the whitelist.\n    /// @param _addresses are the Ethereum addresses to be removed.\n    function submitWhitelistRemoval(address[] calldata _addresses) external onlyOwner noActiveSubmission {\n        // Require that the whitelist has been initialized.\n        require(isSetWhitelist, \"whitelist has not been initialized\");\n        // Require that the array of addresses is not empty\n        require(_addresses.length \u003e 0, \"pending whitelist removal is empty\");\n        // Add the provided addresses to the pending addition list.\n        _pendingWhitelistRemoval = _addresses;\n        // Flag the operation as submitted.\n        submittedWhitelistRemoval = true;\n        // Emit the submission event.\n        emit SubmittedWhitelistRemoval(_addresses, calculateHash(_addresses));\n    }\n\n    /// @dev Confirm pending removal of whitelisted addresses.\n    function confirmWhitelistRemoval(bytes32 _hash) external onlyController {\n        // Require that the pending whitelist is not empty and the operation has been submitted.\n        require(submittedWhitelistRemoval, \"whitelist removal has not been submitted\");\n        // Require that confirmation hash and the hash of the pending whitelist removal match\n        require(_hash == calculateHash(_pendingWhitelistRemoval), \"hash of the pending whitelist removal does not match the confirmed hash\");\n        // Remove pending addresses.\n        for (uint i = 0; i \u003c _pendingWhitelistRemoval.length; i++) {\n            // check if it exists\n            if (whitelistMap[_pendingWhitelistRemoval[i]]) {\n                whitelistMap[_pendingWhitelistRemoval[i]] = false;\n                for (uint j = 0; j \u003c whitelistArray.length.sub(1); j++) {\n                    if (whitelistArray[j] == _pendingWhitelistRemoval[i]) {\n                        whitelistArray[j] = whitelistArray[whitelistArray.length - 1];\n                        break;\n                    }\n                }\n                whitelistArray.length--;\n            }\n        }\n        // Emit the removal event.\n        emit RemovedFromWhitelist(msg.sender, _pendingWhitelistRemoval);\n        // Reset pending addresses.\n        delete _pendingWhitelistRemoval;\n        // Reset the submission flag.\n        submittedWhitelistRemoval = false;\n    }\n\n    /// @dev Cancel pending removal of whitelisted addresses.\n    function cancelWhitelistRemoval(bytes32 _hash) external onlyOwnerOrController {\n        // Check if operation has been submitted.\n        require(submittedWhitelistRemoval, \"whitelist removal has not been submitted\");\n        // Require that confirmation hash and the hash of the pending whitelist removal match\n        require(_hash == calculateHash(_pendingWhitelistRemoval), \"hash of the pending whitelist removal do not match\");\n        // Reset pending addresses.\n        delete _pendingWhitelistRemoval;\n        // Reset pending addresses.\n        submittedWhitelistRemoval = false;\n        // Emit the cancellation event.\n        emit CancelledWhitelistRemoval(msg.sender, _hash);\n    }\n\n    /// @dev Method used to hash our whitelist address arrays.\n    function calculateHash(address[] memory _addresses) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_addresses));\n    }\n}\n\n/// @title DailyLimitTrait This trait allows for daily limits to be included in other contracts.\n/// This contract will allow for a DailyLimit object to be instantiated and used.\nlibrary DailyLimitTrait {\n    using SafeMath for uint256;\n\n    event UpdatedAvailableLimit();\n\n    struct DailyLimit {\n        uint value;\n        uint available;\n        uint limitTimestamp;\n        uint pending;\n        bool updateable;\n    }\n\n    /// @dev Returns the available daily balance - accounts for daily limit reset.\n    /// @return amount of available to spend within the current day in base units.\n    function _getAvailableLimit(DailyLimit storage self) internal view returns (uint) {\n        if (now \u003e self.limitTimestamp.add(24 hours)) {\n            return self.value;\n        } else {\n            return self.available;\n        }\n    }\n\n    /// @dev Use up amount within the daily limit. Will fail if amount is larger than daily limit.\n    function _enforceLimit(DailyLimit storage self, uint _amount) internal {\n        // Account for the spend limit daily reset.\n        _updateAvailableLimit(self);\n        require(self.available \u003e= _amount, \"available has to be greater or equal to use amount\");\n        self.available = self.available.sub(_amount);\n    }\n\n    /// @dev Set the daily limit.\n    /// @param _amount is the daily limit amount in base units.\n    function _setLimit(DailyLimit storage self, uint _amount) internal {\n        // Require that the spend limit has not been set yet.\n        require(!self.updateable, \"daily limit not updateable\");\n        // Modify spend limit based on the provided value.\n        _modifyLimit(self, _amount);\n        // Flag the operation as set.\n        self.updateable = true;\n    }\n\n    /// @dev Submit a daily limit update, needs to be confirmed.\n    /// @param _amount is the daily limit amount in base units.\n    function _submitLimitUpdate(DailyLimit storage self, uint _amount) internal {\n        // Require that the spend limit has been set.\n        require(self.updateable, \"daily limit is still updateable\");\n        // Assign the provided amount to pending daily limit.\n        self.pending = _amount;\n    }\n\n    /// @dev Confirm pending set daily limit operation.\n    function _confirmLimitUpdate(DailyLimit storage self, uint _amount) internal {\n        // Require that pending and confirmed spend limit are the same\n        require(self.pending == _amount, \"confirmed and submitted limits dont match\");\n        // Modify spend limit based on the pending value.\n        _modifyLimit(self, self.pending);\n    }\n\n    /// @dev Update available spend limit based on the daily reset.\n    function _updateAvailableLimit(DailyLimit storage self) private {\n        if (now \u003e self.limitTimestamp.add(24 hours)) {\n            // Update the current timestamp.\n            self.limitTimestamp = now;\n            // Set the available limit to the current spend limit.\n            self.available = self.value;\n            emit UpdatedAvailableLimit();\n        }\n    }\n\n    /// @dev Modify the spend limit and spend available based on the provided value.\n    /// @dev _amount is the daily limit amount in wei.\n    function _modifyLimit(DailyLimit storage self, uint _amount) private {\n        // Account for the spend limit daily reset.\n        _updateAvailableLimit(self);\n        // Set the daily limit to the provided amount.\n        self.value = _amount;\n        // Lower the available limit if it\u0027s higher than the new daily limit.\n        if (self.available \u003e self.value) {\n            self.available = self.value;\n        }\n    }\n}\n\n\n/// @title  it provides daily spend limit functionality.\ncontract SpendLimit is ControllableOwnable {\n    event SetSpendLimit(address _sender, uint _amount);\n    event SubmittedSpendLimitUpdate(uint _amount);\n\n    using DailyLimitTrait for DailyLimitTrait.DailyLimit;\n\n    DailyLimitTrait.DailyLimit internal _spendLimit;\n\n    /// @dev Constructor initializes the daily spend limit in wei.\n    constructor(uint _limit_) internal {\n        _spendLimit = DailyLimitTrait.DailyLimit(_limit_, _limit_, now, 0, false);\n    }\n\n    /// @dev Sets the initial daily spend (aka transfer) limit for non-whitelisted addresses.\n    /// @param _amount is the daily limit amount in wei.\n    function setSpendLimit(uint _amount) external onlyOwner {\n        _spendLimit._setLimit(_amount);\n        emit SetSpendLimit(msg.sender, _amount);\n    }\n\n    /// @dev Submit a daily transfer limit update for non-whitelisted addresses.\n    /// @param _amount is the daily limit amount in wei.\n    function submitSpendLimitUpdate(uint _amount) external onlyOwner {\n        _spendLimit._submitLimitUpdate(_amount);\n        emit SubmittedSpendLimitUpdate(_amount);\n    }\n\n    /// @dev Confirm pending set daily limit operation.\n    function confirmSpendLimitUpdate(uint _amount) external onlyController {\n        _spendLimit._confirmLimitUpdate(_amount);\n        emit SetSpendLimit(msg.sender, _amount);\n    }\n\n    function spendLimitAvailable() external view returns (uint) {\n        return _spendLimit._getAvailableLimit();\n    }\n\n    function spendLimitValue() external view returns (uint) {\n        return _spendLimit.value;\n    }\n\n    function spendLimitUpdateable() external view returns (bool) {\n        return _spendLimit.updateable;\n    }\n\n    function spendLimitPending() external view returns (uint) {\n        return _spendLimit.pending;\n    }\n}\n\n\n//// @title GasTopUpLimit provides daily limit functionality.\ncontract GasTopUpLimit is ControllableOwnable {\n\n    event SetGasTopUpLimit(address _sender, uint _amount);\n    event SubmittedGasTopUpLimitUpdate(uint _amount);\n\n    uint constant private _MINIMUM_GAS_TOPUP_LIMIT = 1 finney;\n    uint constant private _MAXIMUM_GAS_TOPUP_LIMIT = 500 finney;\n\n    using DailyLimitTrait for DailyLimitTrait.DailyLimit;\n\n    DailyLimitTrait.DailyLimit internal _gasTopUpLimit;\n\n    /// @dev Constructor initializes the daily gas topup limit in wei.\n    constructor() internal {\n        _gasTopUpLimit = DailyLimitTrait.DailyLimit(_MAXIMUM_GAS_TOPUP_LIMIT, _MAXIMUM_GAS_TOPUP_LIMIT, now, 0, false);\n    }\n\n    /// @dev Sets the daily gas top up limit.\n    /// @param _amount is the gas top up amount in wei.\n    function setGasTopUpLimit(uint _amount) external onlyOwner {\n        require(_MINIMUM_GAS_TOPUP_LIMIT \u003c= _amount \u0026\u0026 _amount \u003c= _MAXIMUM_GAS_TOPUP_LIMIT, \"gas top up amount is outside the min/max range\");\n        _gasTopUpLimit._setLimit(_amount);\n        emit SetGasTopUpLimit(msg.sender, _amount);\n    }\n\n    /// @dev Submit a daily gas top up limit update.\n    /// @param _amount is the daily top up gas limit amount in wei.\n    function submitGasTopUpLimitUpdate(uint _amount) external onlyOwner {\n        require(_MINIMUM_GAS_TOPUP_LIMIT \u003c= _amount \u0026\u0026 _amount \u003c= _MAXIMUM_GAS_TOPUP_LIMIT, \"gas top up amount is outside the min/max range\");\n        _gasTopUpLimit._submitLimitUpdate(_amount);\n        emit SubmittedGasTopUpLimitUpdate(_amount);\n    }\n\n    /// @dev Confirm pending set top up gas limit operation.\n    function confirmGasTopUpLimitUpdate(uint _amount) external onlyController {\n        _gasTopUpLimit._confirmLimitUpdate(_amount);\n        emit SetGasTopUpLimit(msg.sender, _amount);\n    }\n\n    function gasTopUpLimitAvailable() external view returns (uint) {\n        return _gasTopUpLimit._getAvailableLimit();\n    }\n\n    function gasTopUpLimitValue() external view returns (uint) {\n        return _gasTopUpLimit.value;\n    }\n\n    function gasTopUpLimitUpdateable() external view returns (bool) {\n        return _gasTopUpLimit.updateable;\n    }\n\n    function gasTopUpLimitPending() external view returns (uint) {\n        return _gasTopUpLimit.pending;\n    }\n}\n\n\n/// @title LoadLimit provides daily load limit functionality.\ncontract LoadLimit is ControllableOwnable {\n\n    event SetLoadLimit(address _sender, uint _amount);\n    event SubmittedLoadLimitUpdate(uint _amount);\n\n    uint constant private _MINIMUM_LOAD_LIMIT = 1 finney;\n    uint private _maximumLoadLimit;\n\n    using DailyLimitTrait for DailyLimitTrait.DailyLimit;\n\n    DailyLimitTrait.DailyLimit internal _loadLimit;\n\n    /// @dev Sets a daily card load limit.\n    /// @param _amount is the card load amount in current stablecoin base units.\n    function setLoadLimit(uint _amount) external onlyOwner {\n        require(_MINIMUM_LOAD_LIMIT \u003c= _amount \u0026\u0026 _amount \u003c= _maximumLoadLimit, \"card load amount is outside the min/max range\");\n        _loadLimit._setLimit(_amount);\n        emit SetLoadLimit(msg.sender, _amount);\n    }\n\n    /// @dev Submit a daily load limit update.\n    /// @param _amount is the daily load limit amount in wei.\n    function submitLoadLimitUpdate(uint _amount) external onlyOwner {\n        require(_MINIMUM_LOAD_LIMIT \u003c= _amount \u0026\u0026 _amount \u003c= _maximumLoadLimit, \"card load amount is outside the min/max range\");\n        _loadLimit._submitLimitUpdate(_amount);\n        emit SubmittedLoadLimitUpdate(_amount);\n    }\n\n    /// @dev Confirm pending set load limit operation.\n    function confirmLoadLimitUpdate(uint _amount) external onlyController {\n        _loadLimit._confirmLimitUpdate(_amount);\n        emit SetLoadLimit(msg.sender, _amount);\n    }\n\n    function loadLimitAvailable() external view returns (uint) {\n        return _loadLimit._getAvailableLimit();\n    }\n\n    function loadLimitValue() external view returns (uint) {\n        return _loadLimit.value;\n    }\n\n    function loadLimitUpdateable() external view returns (bool) {\n        return _loadLimit.updateable;\n    }\n\n    function loadLimitPending() external view returns (uint) {\n        return _loadLimit.pending;\n    }\n\n    /// @dev initializes the daily load limit.\n    /// @param _maxLimit is the maximum load limit amount in stablecoin base units.\n    function _initializeLoadLimit(uint _maxLimit) internal {\n        _maximumLoadLimit = _maxLimit;\n        _loadLimit = DailyLimitTrait.DailyLimit(_maximumLoadLimit, _maximumLoadLimit, now, 0, false);\n    }\n}\n\n\n//// @title Asset store with extra security features.\ncontract Vault is AddressWhitelist, SpendLimit, ERC165, Transferrable, Balanceable, TokenWhitelistable {\n\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    event Received(address _from, uint _amount);\n    event Transferred(address _to, address _asset, uint _amount);\n    event BulkTransferred(address _to, address[] _assets);\n\n    /// @dev Supported ERC165 interface ID.\n    bytes4 private constant _ERC165_INTERFACE_ID = 0x01ffc9a7; // solium-disable-line uppercase\n\n    /// @dev Constructor initializes the vault with an owner address and spend limit. It also sets up the controllable and tokenWhitelist contracts with the right name registered in ENS.\n    /// @param _owner_ is the owner account of the wallet contract.\n    /// @param _transferable_ indicates whether the contract ownership can be transferred.\n    /// @param _tokenWhitelistNode_ is the ENS node of the Token whitelist.\n    /// @param _controllerNode_ is the ENS name node of the controller.\n    /// @param _spendLimit_ is the initial spend limit.\n    constructor(address payable _owner_, bool _transferable_, bytes32 _tokenWhitelistNode_, bytes32 _controllerNode_, uint _spendLimit_) SpendLimit(_spendLimit_) Ownable(_owner_, _transferable_) Controllable(_controllerNode_) TokenWhitelistable(_tokenWhitelistNode_) public {}\n\n    /// @dev Checks if the value is not zero.\n    modifier isNotZero(uint _value) {\n        require(_value != 0, \"provided value cannot be zero\");\n        _;\n    }\n\n    /// @dev Ether can be deposited from any source, so this contract must be payable by anyone.\n    function() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n\n    /// @dev Checks for interface support based on ERC165.\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n        return _interfaceID == _ERC165_INTERFACE_ID;\n    }\n\n    /// @dev This is a bulk transfer convenience function, used to migrate contracts.\n    /// @notice If any of the transfers fail, this will revert.\n    /// @param _to is the recipient\u0027s address, can\u0027t be the zero (0x0) address: transfer() will revert.\n    /// @param _assets is an array of addresses of ERC20 tokens or 0x0 for ether.\n    function bulkTransfer(address payable _to, address[] calldata _assets) external onlyOwner {\n        // check to make sure that _assets isn\u0027t empty\n        require(_assets.length != 0, \"asset array should be non-empty\");\n        // This loops through all of the transfers to be made\n        for (uint i = 0; i \u003c _assets.length; i++) {\n            uint amount = _balance(address(this), _assets[i]);\n            // use our safe, daily limit protected transfer\n            transfer(_to, _assets[i], amount);\n        }\n\n        emit BulkTransferred(_to, _assets);\n    }\n\n    /// @dev Transfers the specified asset to the recipient\u0027s address.\n    /// @param _to is the recipient\u0027s address.\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\n    /// @param _amount is the amount of assets to be transferred in base units.\n    function transfer(address payable _to, address _asset, uint _amount) public onlyOwner isNotZero(_amount) {\n        // Checks if the _to address is not the zero-address\n        require(_to != address(0), \"_to address cannot be set to 0x0\");\n\n        // If address is not whitelisted, take daily limit into account.\n        if (!whitelistMap[_to]) {\n            // initialize ether value in case the asset is ETH\n            uint etherValue = _amount;\n            // Convert token amount to ether value if asset is an ERC20 token.\n            if (_asset != address(0)) {\n                etherValue = convertToEther(_asset, _amount);\n            }\n            // Check against the daily spent limit and update accordingly\n            // Check against the daily spent limit and update accordingly, require that the value is under remaining limit.\n            _spendLimit._enforceLimit(etherValue);\n        }\n        // Transfer token or ether based on the provided address.\n        _safeTransfer(_to, _asset, _amount);\n        // Emit the transfer event.\n        emit Transferred(_to, _asset, _amount);\n    }\n\n    /// @dev Convert ERC20 token amount to the corresponding ether amount.\n    /// @param _token ERC20 token contract address.\n    /// @param _amount amount of token in base units.\n    function convertToEther(address _token, uint _amount) public view returns (uint) {\n        // Store the token in memory to save map entry lookup gas.\n        (,uint256 magnitude, uint256 rate, bool available, , , ) = _getTokenInfo(_token);\n        // If the token exists require that its rate is not zero.\n        if (available) {\n            require(rate != 0, \"token rate is 0\");\n            // Safely convert the token amount to ether based on the exchange rate.\n            return _amount.mul(rate).div(magnitude);\n        }\n        return 0;\n    }\n}\n\n\n//// @title Asset wallet with extra security features, gas top up management and card integration.\ncontract Wallet is ENSResolvable, Vault, GasTopUpLimit, LoadLimit {\n\n    using SafeERC20 for ERC20;\n    using Address for address;\n\n    event ToppedUpGas(address _sender, address _owner, uint _amount);\n    event LoadedTokenCard(address _asset, uint _amount);\n    event ExecutedTransaction(address _destination, uint _value, bytes _data, bytes _returndata);\n    event UpdatedAvailableLimit();\n\n    string constant public WALLET_VERSION = \"2.2.0\";\n    uint constant private _DEFAULT_MAX_STABLECOIN_LOAD_LIMIT = 10000; //10,000 USD\n\n    /// @dev Is the registered ENS node identifying the licence contract.\n    bytes32 private _licenceNode;\n\n    /// @dev Constructor initializes the wallet top up limit and the vault contract.\n    /// @param _owner_ is the owner account of the wallet contract.\n    /// @param _transferable_ indicates whether the contract ownership can be transferred.\n    /// @param _ens_ is the address of the ENS registry.\n    /// @param _tokenWhitelistNode_ is the ENS name node of the Token whitelist.\n    /// @param _controllerNode_ is the ENS name node of the Controller contract.\n    /// @param _licenceNode_ is the ENS name node of the Licence contract.\n    /// @param _spendLimit_ is the initial spend limit.\n    constructor(address payable _owner_, bool _transferable_, address _ens_, bytes32 _tokenWhitelistNode_, bytes32 _controllerNode_, bytes32 _licenceNode_, uint _spendLimit_) ENSResolvable(_ens_) Vault(_owner_, _transferable_, _tokenWhitelistNode_, _controllerNode_, _spendLimit_) public {\n        // Get the stablecoin\u0027s magnitude.\n        ( ,uint256 stablecoinMagnitude, , , , , ) = _getStablecoinInfo();\n        require(stablecoinMagnitude \u003e 0, \"stablecoin not set\");\n        _initializeLoadLimit(_DEFAULT_MAX_STABLECOIN_LOAD_LIMIT * stablecoinMagnitude);\n        _licenceNode = _licenceNode_;\n    }\n\n    /// @dev Refill owner\u0027s gas balance, revert if the transaction amount is too large\n    /// @param _amount is the amount of ether to transfer to the owner account in wei.\n    function topUpGas(uint _amount) external isNotZero(_amount) onlyOwnerOrController {\n        // Check against the daily spent limit and update accordingly, require that the value is under remaining limit.\n        _gasTopUpLimit._enforceLimit(_amount);\n        // Then perform the transfer\n        owner().transfer(_amount);\n        // Emit the gas top up event.\n        emit ToppedUpGas(msg.sender, owner(), _amount);\n    }\n\n    /// @dev Load a token card with the specified asset amount.\n    /// @dev the amount send should be inclusive of the percent licence.\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\n    /// @param _amount is the amount of assets to be transferred in base units.\n    function loadTokenCard(address _asset, uint _amount) external payable onlyOwner {\n        // check if token is allowed to be used for loading the card\n        require(_isTokenLoadable(_asset), \"token not loadable\");\n        // Convert token amount to stablecoin value.\n        uint stablecoinValue = convertToStablecoin(_asset, _amount);\n        // Check against the daily spent limit and update accordingly, require that the value is under remaining limit.\n        _loadLimit._enforceLimit(stablecoinValue);\n        // Get the TKN licenceAddress from ENS\n        address licenceAddress = _ensResolve(_licenceNode);\n        if (_asset != address(0)) {\n            ERC20(_asset).safeApprove(licenceAddress, _amount);\n            ILicence(licenceAddress).load(_asset, _amount);\n        } else {\n            ILicence(licenceAddress).load.value(_amount)(_asset, _amount);\n        }\n\n        emit LoadedTokenCard(_asset, _amount);\n\n    }\n\n    /// @dev This function allows for the owner to send transaction from the Wallet to arbitrary addresses\n    /// @param _destination address of the transaction\n    /// @param _value ETH amount in wei\n    /// @param _data transaction payload binary\n    function executeTransaction(address _destination, uint _value, bytes calldata _data) external onlyOwner returns (bytes memory) {\n        // If value is send across as a part of this executeTransaction, this will be sent to any payable\n        // destination. As a result enforceLimit if destination is not whitelisted.\n        if (!whitelistMap[_destination]) {\n            _spendLimit._enforceLimit(_value);\n        }\n        // Check if the destination is a Contract and it is one of our supported tokens\n        if (address(_destination).isContract() \u0026\u0026 _isTokenAvailable(_destination)) {\n            // to is the recipient\u0027s address and amount is the value to be transferred\n            address to;\n            uint amount;\n            (to, amount) = _getERC20RecipientAndAmount(_destination, _data);\n            if (!whitelistMap[to]) {\n                // If the address (of the token contract, e.g) is not in the TokenWhitelist used by the convert method...\n                // ...then etherValue will be zero\n                uint etherValue = convertToEther(_destination, amount);\n                _spendLimit._enforceLimit(etherValue);\n            }\n            // use callOptionalReturn provided in SafeERC20 in case the ERC20 method\n            // returns flase instead of reverting!\n            ERC20(_destination).callOptionalReturn(_data);\n\n            // if ERC20 call completes, return a boolean \"true\" as bytes emulating ERC20\n            bytes memory b = new bytes(32);\n            b[31] = 0x01;\n\n            emit ExecutedTransaction(_destination, _value, _data, b);\n            return b;\n        }\n\n        (bool success, bytes memory returndata) = _destination.call.value(_value)(_data);\n        require(success, \"low-level call failed\");\n\n        emit ExecutedTransaction(_destination, _value, _data, returndata);\n        // returns all of the bytes returned by _destination contract\n        return returndata;\n    }\n\n    /// @return licence contract node registered in ENS.\n    function licenceNode() external view returns (bytes32) {\n        return _licenceNode;\n    }\n\n    /// @dev Convert ether or ERC20 token amount to the corresponding stablecoin amount.\n    /// @param _token ERC20 token contract address.\n    /// @param _amount amount of token in base units.\n    function convertToStablecoin(address _token, uint _amount) public view returns (uint) {\n        // avoid the unnecessary calculations if the token to be loaded is the stablecoin itself\n        if (_token == _stablecoin()) {\n            return _amount;\n        }\n        uint amountToSend = _amount;\n\n        // 0x0 represents ether\n        if (_token != address(0)) {\n            // convert to eth first, same as convertToEther()\n            // Store the token in memory to save map entry lookup gas.\n            (,uint256 magnitude, uint256 rate, bool available, , , ) = _getTokenInfo(_token);\n            // require that token both exists in the whitelist and its rate is not zero.\n            require(available, \"token is not available\");\n            require(rate != 0, \"token rate is 0\");\n            // Safely convert the token amount to ether based on the exchange rate.\n            amountToSend = _amount.mul(rate).div(magnitude);\n        }\n        // _amountToSend now is in ether\n        // Get the stablecoin\u0027s magnitude and its current rate.\n        ( ,uint256 stablecoinMagnitude, uint256 stablecoinRate, bool stablecoinAvailable, , , ) = _getStablecoinInfo();\n        // Check if the stablecoin rate is set.\n        require(stablecoinAvailable, \"token is not available\");\n        require(stablecoinRate != 0, \"stablecoin rate is 0\");\n        // Safely convert the token amount to stablecoin based on its exchange rate and the stablecoin exchange rate.\n        return amountToSend.mul(stablecoinMagnitude).div(stablecoinRate);\n    }\n\n}\n"},"walletDeployer.sol":{"content":"/**\n *  The Consumer Contract Wallet Deployer\n *  Copyright (C) 2019 The Contract Wallet Company Limited\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n */\n\npragma solidity ^0.5.10;\n\nimport \"./wallet.sol\";\nimport \"./controllable.sol\";\nimport \"./ensResolvable.sol\";\n\n//// @title Wallet deployer with pre-caching if wallets functionality.\ncontract WalletDeployer is ENSResolvable, Controllable {\n\n    event CachedWallet(Wallet _wallet);\n    event DeployedWallet(Wallet _wallet, address _owner);\n    event MigratedWallet(Wallet _wallet, Wallet _oldWallet, address _owner);\n\n    /*****   Constants   *****/\n    bytes32 public constant controllerNode = 0x7f2ce995617d2816b426c5c8698c5ec2952f7a34bb10f38326f74933d5893697;\n    bytes32 public constant licenceNode = 0xd0ff8bd67f6e25e4e4b010df582a36a0ee9b78e49afe6cc1cff5dd5a83040330;\n    bytes32 public constant tokenWhitelistNode = 0xe84f90570f13fe09f288f2411ff9cf50da611ed0c7db7f73d48053ffc974d396;\n\n    mapping(address =\u003e address) public deployedWallets;\n    Wallet[] public cachedWallets;\n\n    address public ens;\n    uint public defaultSpendLimit;\n\n    /// @notice parameters are passed in so that they can be used to construct new instances of the wallet\n    constructor(address _ens, uint _defaultSpendLimit) ENSResolvable(_ens) Controllable(controllerNode) public {\n        ens = _ens;\n        defaultSpendLimit = _defaultSpendLimit;\n    }\n\n    /// @dev This contract must be payable by anyone, as the Wallet Owner needs to be payable\n    function() external payable {}\n\n    /// @notice This public method allows anyone to pre-cache wallets\n    function cacheWallet() public {\n        Wallet wallet = new Wallet(address(this), true, ens, tokenWhitelistNode, controllerNode, licenceNode, defaultSpendLimit);\n        cachedWallets.push(wallet);\n        emit CachedWallet(wallet);\n    }\n\n    /// @notice This function is used to deploy a Wallet for a given owner address\n    /// @param _owner is the owner address for the new Wallet to be\n    function deployWallet(address payable _owner) external onlyController {\n        if (cachedWallets.length \u003c 1) {\n            cacheWallet();\n        }\n        Wallet wallet = cachedWallets[cachedWallets.length-1];\n        cachedWallets.pop();\n        wallet.transferOwnership(_owner, false);\n        deployedWallets[_owner] = address(wallet);\n        emit DeployedWallet(wallet, _owner);\n    }\n\n    /// @notice This function is used to migrate an owner\u0027s security settings from a previous version of the wallet\n    /// @param _owner is the owner address for the new Wallet to be\n    /// @param _spendLimit is the user\u0027s set daily spend limit\n    /// @param _gasTopUpLimit is the user\u0027s set daily gas top-up limit\n    /// @param _whitelistedAddresses is the set of the user\u0027s whitelisted addresses\n    function migrateWallet(address payable _owner, Wallet _oldWallet, bool _initializedSpendLimit, bool _initializedGasTopUpLimit, bool _initializedWhitelist, uint _spendLimit, uint _gasTopUpLimit, address[] calldata _whitelistedAddresses) external onlyController {\n        if (cachedWallets.length \u003c 1) {\n            cacheWallet();\n    \t}\n\n        Wallet  wallet = cachedWallets[cachedWallets.length-1];\n        cachedWallets.pop();\n\n        if (_initializedSpendLimit) {\n            wallet.setSpendLimit(_spendLimit);\n        }\n        if (_initializedGasTopUpLimit) {\n            wallet.setGasTopUpLimit(_gasTopUpLimit);\n        }\n        if (_initializedWhitelist) {\n            wallet.setWhitelist(_whitelistedAddresses);\n        }\n\n        wallet.transferOwnership(_owner, false);\n        deployedWallets[_owner] = address(wallet);\n\n        emit MigratedWallet(wallet, _oldWallet, _owner);\n    }\n\n    /// @notice returns the number of pre-cached wallets\n    function cachedWalletsCount() external view returns (uint) {\n        return cachedWallets.length;\n    }\n\n}\n"}}