{"Hash.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.4;\n\n/**\n  @notice Encapsulation of the logic to produce EIP712 hashed domain and messages.\n  Also to produce / verify hashed and signed Orders.\n  See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md\n  See/attribute https://github.com/0xProject/0x-monorepo/blob/development/contracts/utils/contracts/src/LibEIP712.sol\n*/\n\nlibrary Hash {\n  /// @dev struct represents the attributes of an offchain Swivel.Order\n  struct Order {\n    bytes32 key;\n    address maker;\n    address underlying;\n    bool vault;\n    bool exit;\n    uint256 principal;\n    uint256 premium;\n    uint256 maturity;\n    uint256 expiry;\n  }\n\n  // EIP712 Domain Separator typeHash\n  // keccak256(abi.encodePacked(\n  //     \u0027EIP712Domain(\u0027,\n  //     \u0027string name,\u0027,\n  //     \u0027string version,\u0027,\n  //     \u0027uint256 chainId,\u0027,\n  //     \u0027address verifyingContract\u0027,\n  //     \u0027)\u0027\n  // ));\n  bytes32 constant internal DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n  // EIP712 typeHash of an Order \n  // keccak256(abi.encodePacked(\n  //     \u0027Order(\u0027,\n  //     \u0027bytes32 key,\u0027,\n  //     \u0027address maker,\u0027,\n  //     \u0027address underlying,\u0027,\n  //     \u0027bool vault,\u0027,\n  //     \u0027bool exit,\u0027,\n  //     \u0027uint256 principal,\u0027,\n  //     \u0027uint256 premium,\u0027,\n  //     \u0027uint256 maturity,\u0027,\n  //     \u0027uint256 expiry\u0027,\n  //     \u0027)\u0027\n  // ));\n  bytes32 constant internal ORDER_TYPEHASH = 0x7ddd38ab5ed1c16b61ca90eeb9579e29da1ba821cf42d8cdef8f30a31a6a4146;\n\n  /// @param n EIP712 domain name\n  /// @param version EIP712 semantic version string\n  /// @param i Chain ID\n  /// @param verifier address of the verifying contract\n  function domain(string memory n, string memory version, uint256 i, address verifier) internal pure returns (bytes32) {\n    bytes32 hash;\n\n    assembly {\n      let nameHash := keccak256(add(n, 32), mload(n))\n      let versionHash := keccak256(add(version, 32), mload(version))\n      let pointer := mload(64)\n      mstore(pointer, DOMAIN_TYPEHASH)\n      mstore(add(pointer, 32), nameHash)\n      mstore(add(pointer, 64), versionHash)\n      mstore(add(pointer, 96), i)\n      mstore(add(pointer, 128), verifier)\n      hash := keccak256(pointer, 160)\n    }\n\n    return hash;\n  }\n\n  /// @param d Type hash of the domain separator (see Hash.domain)\n  /// @param h EIP712 hash struct (order for example)\n  function message(bytes32 d, bytes32 h) internal pure returns (bytes32) {\n    bytes32 hash;\n\n    assembly {\n      let pointer := mload(64)\n      mstore(pointer, 0x1901000000000000000000000000000000000000000000000000000000000000)\n      mstore(add(pointer, 2), d)\n      mstore(add(pointer, 34), h)\n      hash := keccak256(pointer, 66)\n    }\n\n    return hash;\n  }\n\n  /// @param o A Swivel Order\n  function order(Order calldata o) internal pure returns (bytes32) {\n    // TODO assembly\n    return keccak256(abi.encode(\n      ORDER_TYPEHASH,\n      o.key,\n      o.maker,\n      o.underlying,\n      o.vault,\n      o.exit,\n      o.principal,\n      o.premium,\n      o.maturity,\n      o.expiry\n    ));\n  }\n}\n"},"Interfaces.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.4;\n\ninterface Erc20 {\n\tfunction approve(address, uint256) external returns (bool);\n\tfunction transfer(address, uint256) external returns (bool);\n\tfunction balanceOf(address) external returns (uint256);\n\tfunction transferFrom(address, address, uint256) external returns (bool);\n}\n\ninterface CErc20 {\n\tfunction mint(uint256) external returns (uint256);\n\tfunction redeemUnderlying(uint256) external returns (uint256);\n}\n\ninterface MarketPlace {\n  // adds notional and mints zctokens\n  function mintZcTokenAddingNotional(address, uint256, address, uint256) external returns (bool);\n  // removes notional and burns zctokens\n  function burnZcTokenRemovingNotional(address, uint256, address, uint256) external returns (bool);\n  // returns the amount of underlying principal to send\n  function redeemZcToken(address, uint256, address, uint256) external returns (uint256);\n  // returns the amount of underlying interest to send\n  function redeemVaultInterest(address, uint256, address) external returns (uint256);\n  // returns the cToken address for a given market\n  function cTokenAddress(address, uint256) external returns (address);\n  // EVFZE FF EZFVE call this which would then burn zctoken and remove notional\n  function custodialExit(address, uint256, address, address, uint256) external returns (bool);\n  // IVFZI \u0026\u0026 IZFVI call this which would then mint zctoken and add notional\n  function custodialInitiate(address, uint256, address, address, uint256) external returns (bool);\n  // IZFZE \u0026\u0026 EZFZI call this, tranferring zctoken from one party to another\n  function p2pZcTokenExchange(address, uint256, address, address, uint256) external returns (bool);\n  // IVFVE \u0026\u0026 EVFVI call this, removing notional from one party and adding to the other\n  function p2pVaultExchange(address, uint256, address, address, uint256) external returns (bool);\n  // IVFZI \u0026\u0026 IVFVE call this which then transfers notional from msg.sender (taker) to swivel\n  function transferVaultNotionalFee(address, uint256, address, uint256) external returns (bool);\n}\n"},"Safe.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n// Adapted from: https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol\npragma solidity 0.8.4;\n\nimport {Erc20} from \"./Interfaces.sol\";\n/**\n  @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n  @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\n  @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n*/\n\nlibrary Safe {\n  /// @param e Erc20 token to execute the call with\n  /// @param t To address\n  /// @param a Amount being transferred\n  function approve(Erc20 e, address t, uint256 a) internal {\n    bool result;\n\n    assembly {\n      // Get a pointer to some free memory.\n      let pointer := mload(0x40)\n\n      // Write the abi-encoded calldata to memory piece by piece:\n      mstore(pointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n      mstore(add(pointer, 4), and(t, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n      mstore(add(pointer, 36), a) // Finally append the \"amount\" argument. No mask as it\u0027s a full 32 byte value.\n\n      // Call the token and store if it succeeded or not.\n      // We use 68 because the calldata length is 4 + 32 * 2.\n      result := call(gas(), e, 0, pointer, 68, 0, 0)\n    }\n\n    require(success(result), \"approve failed\");\n  }\n\n  /// @param e Erc20 token to execute the call with\n  /// @param t To address\n  /// @param a Amount being transferred\n  function transfer(Erc20 e, address t, uint256 a) internal {\n    bool result;\n\n    assembly {\n      // Get a pointer to some free memory.\n      let pointer := mload(0x40)\n\n      // Write the abi-encoded calldata to memory piece by piece:\n      mstore(pointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n      mstore(add(pointer, 4), and(t, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n      mstore(add(pointer, 36), a) // Finally append the \"amount\" argument. No mask as it\u0027s a full 32 byte value.\n\n      // Call the token and store if it succeeded or not.\n      // We use 68 because the calldata length is 4 + 32 * 2.\n      result := call(gas(), e, 0, pointer, 68, 0, 0)\n    }\n\n    require(success(result), \"transfer failed\");\n  }\n\n  /// @param e Erc20 token to execute the call with\n  /// @param f From address\n  /// @param t To address\n  /// @param a Amount being transferred\n  function transferFrom(Erc20 e, address f, address t, uint256 a) internal {\n    bool result;\n\n    assembly {\n      // Get a pointer to some free memory.\n      let pointer := mload(0x40)\n\n      // Write the abi-encoded calldata to memory piece by piece:\n      mstore(pointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n      mstore(add(pointer, 4), and(f, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\n      mstore(add(pointer, 36), and(t, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n      mstore(add(pointer, 68), a) // Finally append the \"amount\" argument. No mask as it\u0027s a full 32 byte value.\n\n      // Call the token and store if it succeeded or not.\n      // We use 100 because the calldata length is 4 + 32 * 3.\n      result := call(gas(), e, 0, pointer, 100, 0, 0)\n    }\n\n    require(success(result), \"transfer from failed\");\n  }\n\n  /// @notice normalize the acceptable values of true or null vs the unacceptable value of false (or something malformed)\n  /// @param r Return value from the assembly `call()` to Erc20[\u0027selector\u0027]\n  function success(bool r) private pure returns (bool) {\n    bool result;\n\n    assembly {\n      // Get how many bytes the call returned.\n      let returnDataSize := returndatasize()\n\n      // If the call reverted:\n      if iszero(r) {\n        // Copy the revert message into memory.\n        returndatacopy(0, 0, returnDataSize)\n\n        // Revert with the same message.\n        revert(0, returnDataSize)\n      }\n\n      switch returnDataSize\n      case 32 {\n        // Copy the return data into memory.\n        returndatacopy(0, 0, returnDataSize)\n\n        // Set success to whether it returned true.\n        result := iszero(iszero(mload(0)))\n      }\n      case 0 {\n        // There was no return data.\n        result := 1\n      }\n      default {\n        // It returned some malformed input.\n        result := 0\n      }\n    }\n\n    return result;\n  }\n}\n"},"Sig.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.4;\n\nlibrary Sig {\n  /// @dev ECDSA V,R and S components encapsulated here as we may not always be able to accept a bytes signature\n  struct Components {\n    uint8 v;  \n    bytes32 r;\n    bytes32 s;\n  }\n\n  /// @param h Hashed data which was originally signed\n  /// @param c signature struct containing V,R and S\n  /// @return The recovered address\n  function recover(bytes32 h, Components calldata c) internal pure returns (address) {\n    // EIP-2 and malleable signatures...\n    // see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\n    require(uint256(c.s) \u003c= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \u0027invalid signature \"s\" value\u0027);\n    require(c.v == 27 || c.v == 28, \u0027invalid signature \"v\" value\u0027);\n\n    return ecrecover(h, c.v, c.r, c.s);\n  }\n\n  /// @param h Hashed data which was originally signed\n  /// @param sig Valid ECDSA signature\n  /// @dev splitAndRecover should only be used if it is known that the resulting \n  /// verifying bit (V) will be 27 || 28. Otherwise use recover, possibly calling split first.\n  /// @return The recovered address\n  function splitAndRecover(bytes32 h, bytes memory sig) internal pure returns (address) {\n    (uint8 v, bytes32 r, bytes32 s) = split(sig);\n\n    return ecrecover(h, v, r, s);\n  }\n\n  /// @param sig Valid ECDSA signature\n  /// @return v The verification bit\n  /// @return r First 32 bytes\n  /// @return s Next 32 bytes\n  function split(bytes memory sig) internal pure returns (uint8, bytes32, bytes32) {\n    require(sig.length == 65, \u0027invalid signature length\u0027);\n\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n\n    assembly {\n      r := mload(add(sig, 32))\n      s := mload(add(sig, 64))\n      v := byte(0, mload(add(sig, 96)))\n    }\n\n    return (v, r, s);\n  }\n}\n"},"Swivel.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.4;\n\nimport \u0027./Interfaces.sol\u0027;\nimport \u0027./Hash.sol\u0027;\nimport \u0027./Sig.sol\u0027;\nimport \u0027./Safe.sol\u0027;\n\ncontract Swivel {\n  /// @dev maps the key of an order to a boolean indicating if an order was cancelled\n  mapping (bytes32 =\u003e bool) public cancelled;\n  /// @dev maps the key of an order to an amount representing its taken volume\n  mapping (bytes32 =\u003e uint256) public filled;\n  /// @dev maps a token address to a point in time, a hold, after which a withdrawal can be made\n  mapping (address =\u003e uint256) public withdrawals;\n\n  string constant public NAME = \u0027Swivel Finance\u0027;\n  string constant public VERSION = \u00272.0.0\u0027;\n  uint256 constant public HOLD = 3 days;\n  bytes32 public immutable domain;\n  address public immutable marketPlace;\n  address public admin;\n  uint16 constant public MIN_FEENOMINATOR = 33;\n  /// @dev holds the fee demoninators for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit]\n  uint16[4] public feenominators;\n\n  /// @notice Emitted on order cancellation\n  event Cancel (bytes32 indexed key, bytes32 hash);\n  /// @notice Emitted on any initiate*\n  /// @dev filled is \u0027principalFilled\u0027 when (vault:false, exit:false) \u0026\u0026 (vault:true, exit:true)\n  /// @dev filled is \u0027premiumFilled\u0027 when (vault:true, exit:false) \u0026\u0026 (vault:false, exit:true)\n  event Initiate(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\n  /// @notice Emitted on any exit*\n  /// @dev filled is \u0027principalFilled\u0027 when (vault:false, exit:false) \u0026\u0026 (vault:true, exit:true)\n  /// @dev filled is \u0027premiumFilled\u0027 when (vault:true, exit:false) \u0026\u0026 (vault:false, exit:true)\n  event Exit(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\n  /// @notice Emitted on token withdrawal scheduling\n  event ScheduleWithdrawal(address indexed token, uint256 hold);\n  /// @notice Emitted on token withdrawal blocking\n  event BlockWithdrawal(address indexed token);\n  /// @notice Emitted on a change to the feenominators array\n  event SetFee(uint256 indexed index, uint256 indexed feenominator);\n\n  /// @param m deployed MarketPlace contract address\n  constructor(address m) {\n    admin = msg.sender;\n    domain = Hash.domain(NAME, VERSION, block.chainid, address(this));\n    marketPlace = m;\n    feenominators = [200, 600, 400, 200];\n  }\n\n  // ********* INITIATING *************\n\n  /// @notice Allows a user to initiate a position\n  /// @param o Array of offline Swivel.Orders\n  /// @param a Array of order volume (principal) amounts relative to passed orders\n  /// @param c Array of Components from valid ECDSA signatures\n  function initiate(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\n    uint256 len = o.length;\n    // for each order filled, routes the order to the right interaction depending on its params\n    for (uint256 i; i \u003c len; i++) {\n      Hash.Order memory order = o[i];\n      if (!order.exit) {\n        if (!order.vault) {\n          initiateVaultFillingZcTokenInitiate(o[i], a[i], c[i]);\n        } else {\n          initiateZcTokenFillingVaultInitiate(o[i], a[i], c[i]);\n        }\n      } else {\n        if (!order.vault) {\n          initiateZcTokenFillingZcTokenExit(o[i], a[i], c[i]);\n        } else {\n          initiateVaultFillingVaultExit(o[i], a[i], c[i]);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /// @notice Allows a user to initiate a Vault by filling an offline zcToken initiate order\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.custodialInitiate\n  /// @param o Order being filled\n  /// @param a Amount of volume (premium) being filled by the taker\u0027s initiate\n  /// @param c Components of a valid ECDSA signature\n  function initiateVaultFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    // checks order signature, order cancellation and order expiry\n    bytes32 hash = validOrderHash(o, c);\n\n    // checks the side, and the amount compared to available\n    require((a + filled[hash]) \u003c= o.premium, \u0027taker amount \u003e available volume\u0027);\n    \n    filled[hash] += a;\n\n    // transfer underlying tokens\n    Erc20 uToken = Erc20(o.underlying);\n    Safe.transferFrom(uToken, msg.sender, o.maker, a);\n\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    Safe.transferFrom(uToken, o.maker, address(this), principalFilled);\n\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    // mint tokens\n    require(CErc20(mPlace.cTokenAddress(o.underlying, o.maturity)).mint(principalFilled) == 0, \u0027minting CToken failed\u0027);\n    // alert marketplace\n    require(mPlace.custodialInitiate(o.underlying, o.maturity, o.maker, msg.sender, principalFilled), \u0027custodial initiate failed\u0027);\n\n    // transfer fee in vault notional to swivel (from msg.sender)\n    uint256 fee = principalFilled / feenominators[2];\n    require(mPlace.transferVaultNotionalFee(o.underlying, o.maturity, msg.sender, fee), \u0027notional fee transfer failed\u0027);\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker\u0027s initiate\n  /// @param c Components of a valid ECDSA signature\n  function initiateZcTokenFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) \u003c= o.principal, \u0027taker amount \u003e available volume\u0027);\n\n    filled[hash] += a;\n\n    Erc20 uToken = Erc20(o.underlying);\n\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transferFrom(uToken, o.maker, msg.sender, premiumFilled);\n\n    // transfer principal + fee in underlying to swivel (from sender)\n    uint256 fee = premiumFilled / feenominators[0];\n    Safe.transferFrom(uToken, msg.sender, address(this), (a + fee));\n\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    // mint tokens\n    require(CErc20(mPlace.cTokenAddress(o.underlying, o.maturity)).mint(a) == 0, \u0027minting CToken Failed\u0027);\n    // alert marketplace \n    require(mPlace.custodialInitiate(o.underlying, o.maturity, msg.sender, o.maker, a), \u0027custodial initiate failed\u0027);\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to initiate zcToken? by filling an offline zcToken exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.p2pZcTokenExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker\u0027s initiate \n  /// @param c Components of a valid ECDSA signature\n  function initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) \u003c= o.principal, \u0027taker amount \u003e available volume\u0027);\n\n    filled[hash] += a;\n\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n\n    Erc20 uToken = Erc20(o.underlying);\n    // transfer underlying tokens, then take fee\n    Safe.transferFrom(uToken, msg.sender, o.maker, a - premiumFilled);\n\n    uint256 fee = premiumFilled / feenominators[0];\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\n\n    // alert marketplace\n    require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), \u0027zcToken exchange failed\u0027);\n            \n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to initiate a Vault by filling an offline vault exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.p2pVaultExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker\u0027s exit\n  /// @param c Components of a valid ECDSA signature\n  function initiateVaultFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) \u003c= o.premium, \u0027taker amount \u003e available volume\u0027);\n\n    filled[hash] += a;\n\n    Safe.transferFrom(Erc20(o.underlying), msg.sender, o.maker, a);\n\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    // alert marketplace\n    require(mPlace.p2pVaultExchange(o.underlying, o.maturity, o.maker, msg.sender, principalFilled), \u0027vault exchange failed\u0027);\n\n    // transfer fee (in vault notional) to swivel\n    uint256 fee = principalFilled / feenominators[2];\n    require(mPlace.transferVaultNotionalFee(o.underlying, o.maturity, msg.sender, fee), \"notional fee transfer failed\");\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  // ********* EXITING ***************\n\n  /// @notice Allows a user to exit (sell) a currently held position to the marketplace.\n  /// @param o Array of offline Swivel.Orders\n  /// @param a Array of order volume (principal) amounts relative to passed orders\n  /// @param c Components of a valid ECDSA signature\n  function exit(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\n    uint256 len = o.length;\n    // for each order filled, routes the order to the right interaction depending on its params\n    for (uint256 i; i \u003c len; i++) {\n      Hash.Order memory order = o[i];\n      // if the order being filled is not an exit\n      if (!order.exit) {\n        // if the order being filled is a vault initiate or a zcToken initiate\n          if (!order.vault) {\n            // if filling a zcToken initiate with an exit, one is exiting zcTokens\n            exitZcTokenFillingZcTokenInitiate(o[i], a[i], c[i]);\n          } else {\n            // if filling a vault initiate with an exit, one is exiting vault notional\n            exitVaultFillingVaultInitiate(o[i], a[i], c[i]);\n          }\n      } else {\n        // if the order being filled is a vault exit or a zcToken exit\n        if (!order.vault) {\n          // if filling a zcToken exit with an exit, one is exiting vault\n          exitVaultFillingZcTokenExit(o[i], a[i], c[i]);\n        } else {\n          // if filling a vault exit with an exit, one is exiting zcTokens\n          exitZcTokenFillingVaultExit(o[i], a[i], c[i]);\n        }   \n      }   \n    }\n\n    return true;\n  }\n\n  /// @notice Allows a user to exit their zcTokens by filling an offline zcToken initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.p2pZcTokenExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker\u0027s exit\n  /// @param c Components of a valid ECDSA signature\n  function exitZcTokenFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) \u003c= o.premium, \u0027taker amount \u003e available volume\u0027);\n\n    filled[hash] += a;       \n\n    Erc20 uToken = Erc20(o.underlying);\n\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    // transfer underlying from initiating party to exiting party, minus the price the exit party pays for the exit (premium), and the fee.\n    Safe.transferFrom(uToken, o.maker, msg.sender, principalFilled - a);\n\n    // transfer fee in underlying to swivel\n    uint256 fee = principalFilled / feenominators[1];\n    Safe.transferFrom(uToken, o.maker, address(this), fee);\n\n    // alert marketplace\n    require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, msg.sender, o.maker, principalFilled), \u0027zcToken exchange failed\u0027);\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n  \n  /// @notice Allows a user to exit their Vault by filling an offline vault initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.p2pVaultExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker\u0027s exit\n  /// @param c Components of a valid ECDSA signature\n  function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) \u003c= o.principal, \u0027taker amount \u003e available volume\u0027);\n    \n    filled[hash] += a;\n        \n    Erc20 uToken = Erc20(o.underlying);\n\n    // transfer premium from maker to sender\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transferFrom(uToken, o.maker, msg.sender, premiumFilled);\n\n    uint256 fee = premiumFilled / feenominators[3];\n    // transfer fee in underlying to swivel from sender\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\n\n    // transfer \u003ca\u003e notional from sender to maker\n    require(MarketPlace(marketPlace).p2pVaultExchange(o.underlying, o.maturity, msg.sender, o.maker, a), \u0027vault exchange failed\u0027);\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to exit their Vault filling an offline zcToken exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.exitFillingExit\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker\u0027s exit\n  /// @param c Components of a valid ECDSA signature\n  function exitVaultFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) \u003c= o.principal, \u0027taker amount \u003e available volume\u0027);\n\n    filled[hash] += a;\n\n    // redeem underlying on Compound and burn cTokens\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);\n    require((CErc20(cTokenAddr).redeemUnderlying(a) == 0), \"compound redemption error\");\n\n    Erc20 uToken = Erc20(o.underlying);\n    // transfer principal-premium  back to fixed exit party now that the interest coupon and zcb have been redeemed\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transfer(uToken, o.maker, a - premiumFilled);\n\n    // transfer premium-fee to floating exit party\n    uint256 fee = premiumFilled / feenominators[3];\n    Safe.transfer(uToken, msg.sender, premiumFilled - fee);\n\n    // burn zcTokens + nTokens from o.maker and msg.sender respectively\n    require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), \u0027custodial exit failed\u0027);\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to exit their zcTokens by filling an offline vault exit order\n  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.exitFillingExit\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker\u0027s exit\n  /// @param c Components of a valid ECDSA signature\n  function exitZcTokenFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) \u003c= o.premium, \u0027taker amount \u003e available volume\u0027);\n    \n    filled[hash] += a;\n\n    // redeem underlying on Compound and burn cTokens\n    MarketPlace mPlace = MarketPlace(marketPlace);\n\n    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    require((CErc20(cTokenAddr).redeemUnderlying(principalFilled) == 0), \"compound redemption error\");\n\n    Erc20 uToken = Erc20(o.underlying);\n    // transfer principal-premium-fee back to fixed exit party now that the interest coupon and zcb have been redeemed\n    uint256 fee = principalFilled / feenominators[1];\n    Safe.transfer(uToken, msg.sender, principalFilled - a - fee);\n    Safe.transfer(uToken, o.maker, a);\n\n    // burn \u003cprincipalFilled\u003e zcTokens + nTokens from msg.sender and o.maker respectively\n    require(mPlace.custodialExit(o.underlying, o.maturity, msg.sender, o.maker, principalFilled), \u0027custodial exit failed\u0027);\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  /// @notice Allows a user to cancel an order, preventing it from being filled in the future\n  /// @param o Order being cancelled\n  /// @param c Components of a valid ECDSA signature\n  function cancel(Hash.Order calldata o, Sig.Components calldata c) external returns (bool) {\n    bytes32 hash = validOrderHash(o, c);\n\n    require(msg.sender == o.maker, \u0027sender must be maker\u0027);\n\n    cancelled[hash] = true;\n\n    emit Cancel(o.key, hash);\n\n    return true;\n  }\n\n  // ********* ADMINISTRATIVE ***************\n\n  /// @param a Address of a new admin\n  function transferAdmin(address a) external authorized(admin) returns (bool) {\n    admin = a;\n\n    return true;\n  }\n\n  /// @notice Allows the admin to schedule the withdrawal of tokens\n  /// @param e Address of (erc20) token to withdraw\n  function scheduleWithdrawal(address e) external authorized(admin) returns (bool) {\n    uint256 when = block.timestamp + HOLD;\n    withdrawals[e] = when;\n\n    emit ScheduleWithdrawal(e, when);\n\n    return true;\n  }\n\n  /// @notice Emergency function to block unplanned withdrawals\n  /// @param e Address of token withdrawal to block\n  function blockWithdrawal(address e) external authorized(admin) returns (bool) {\n      withdrawals[e] = 0;\n\n      emit BlockWithdrawal(e);\n\n      return true;\n  }\n\n  /// @notice Allows the admin to withdraw the given token, provided the holding period has been observed\n  /// @param e Address of token to withdraw\n  function withdraw(address e) external authorized(admin) returns (bool) {\n    uint256 when = withdrawals[e];\n    require (when != 0, \u0027no withdrawal scheduled\u0027);\n\n    require (block.timestamp \u003e= when, \u0027withdrawal still on hold\u0027);\n\n    withdrawals[e] = 0;\n\n    Erc20 token = Erc20(e);\n    Safe.transfer(token, admin, token.balanceOf(address(this)));\n\n    return true;\n  }\n\n  /// @notice Allows the admin to set a new fee denominator\n  /// @param i The index of the new fee denominator\n  /// @param d The new fee denominator\n  function setFee(uint16 i, uint16 d) external authorized(admin) returns (bool) {\n    require(d \u003e= MIN_FEENOMINATOR, \u0027fee too high\u0027);\n\n    feenominators[i] = d;\n\n    emit SetFee(i, d);\n\n    return true;\n  }\n\n  /// @notice Allows the admin to bulk approve given compound addresses at the underlying token, saving marginal approvals\n  /// @param u array of underlying token addresses\n  /// @param c array of compound token addresses\n  function approveUnderlying(address[] calldata u, address[] calldata c) external authorized(admin) returns (bool) {\n    uint256 len = u.length;\n    require (len == c.length, \u0027array length mismatch\u0027);\n\n    uint256 max = 2**256 - 1;\n\n    for (uint256 i; i \u003c len; i++) {\n      Erc20 uToken = Erc20(u[i]);\n      Safe.approve(uToken, c[i], max);\n    }\n\n    return true;\n  }\n\n  // ********* PROTOCOL UTILITY ***************\n\n  /// @notice Allows users to deposit underlying and in the process split it into/mint \n  /// zcTokens and vault notional. Calls mPlace.mintZcTokenAddingNotional\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of underlying being deposited\n  function splitUnderlying(address u, uint256 m, uint256 a) external returns (bool) {\n    Erc20 uToken = Erc20(u);\n    Safe.transferFrom(uToken, msg.sender, address(this), a);\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    require(CErc20(mPlace.cTokenAddress(u, m)).mint(a) == 0, \u0027minting CToken Failed\u0027);\n    require(mPlace.mintZcTokenAddingNotional(u, m, msg.sender, a), \u0027mint ZcToken adding Notional failed\u0027);\n\n    return true;\n  }\n\n  /// @notice Allows users deposit/burn 1-1 amounts of both zcTokens and vault notional,\n  /// in the process \"combining\" the two, and redeeming underlying. Calls mPlace.burnZcTokenRemovingNotional.\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of zcTokens being redeemed\n  function combineTokens(address u, uint256 m, uint256 a) external returns (bool) {\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    require(mPlace.burnZcTokenRemovingNotional(u, m, msg.sender, a), \u0027burn ZcToken removing Notional failed\u0027);\n    address cTokenAddr = mPlace.cTokenAddress(u, m);\n    require((CErc20(cTokenAddr).redeemUnderlying(a) == 0), \"compound redemption error\");\n    Safe.transfer(Erc20(u), msg.sender, a);\n\n    return true;\n  }\n\n  /// @notice Allows zcToken holders to redeem their tokens for underlying tokens after maturity has been reached (via MarketPlace).\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of zcTokens being redeemed\n  function redeemZcToken(address u, uint256 m, uint256 a) external returns (bool) {\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    // call marketplace to determine the amount redeemed\n    uint256 redeemed = mPlace.redeemZcToken(u, m, msg.sender, a);\n    // redeem underlying from compound\n    require(CErc20(mPlace.cTokenAddress(u, m)).redeemUnderlying(redeemed) == 0, \u0027compound redemption failed\u0027);\n    // transfer underlying back to msg.sender\n    Safe.transfer(Erc20(u), msg.sender, redeemed);\n\n    return true;\n  }\n\n  /// @notice Allows Vault owners to redeem any currently accrued interest (via MarketPlace)\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function redeemVaultInterest(address u, uint256 m) external returns (bool) {\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    // call marketplace to determine the amount redeemed\n    uint256 redeemed = mPlace.redeemVaultInterest(u, m, msg.sender);\n    // redeem underlying from compound\n    require(CErc20(mPlace.cTokenAddress(u, m)).redeemUnderlying(redeemed) == 0, \u0027compound redemption failed\u0027);\n    // transfer underlying back to msg.sender\n    Safe.transfer(Erc20(u), msg.sender, redeemed);\n\n    return true;\n  }\n\n  /// @notice Varifies the validity of an order and it\u0027s signature.\n  /// @param o An offline Swivel.Order\n  /// @param c Components of a valid ECDSA signature\n  /// @return the hashed order.\n  function validOrderHash(Hash.Order calldata o, Sig.Components calldata c) internal view returns (bytes32) {\n    bytes32 hash = Hash.order(o);\n\n    require(!cancelled[hash], \u0027order cancelled\u0027);\n    require(o.expiry \u003e= block.timestamp, \u0027order expired\u0027);\n    require(o.maker == Sig.recover(Hash.message(domain, hash), c), \u0027invalid signature\u0027);\n\n    return hash;\n  }\n\n  modifier authorized(address a) {\n    require(msg.sender == a, \u0027sender must be authorized\u0027);\n    _;\n  }\n}\n"}}