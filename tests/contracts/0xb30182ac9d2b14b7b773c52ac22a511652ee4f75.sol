{{
  "language": "Solidity",
  "sources": {
    "contracts/core/ChonkyProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC721MetadataStorage} from \"@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol\";\nimport {IERC721} from \"@solidstate/contracts/token/ERC721/IERC721.sol\";\nimport {Proxy} from \"@solidstate/contracts/proxy/Proxy.sol\";\nimport {SafeOwnable, OwnableStorage} from \"@solidstate/contracts/access/SafeOwnable.sol\";\nimport {IERC165} from \"@solidstate/contracts/introspection/IERC165.sol\";\n\nimport {ERC165Storage} from \"@solidstate/contracts/introspection/ERC165Storage.sol\";\n\nimport {ChonkyNFTStorage} from \"../ChonkyNFTStorage.sol\";\n\ncontract ChonkyProxy is Proxy, SafeOwnable {\n    using ChonkyNFTStorage for ChonkyNFTStorage.Layout;\n    using OwnableStorage for OwnableStorage.Layout;\n    using ERC165Storage for ERC165Storage.Layout;\n\n    event Upgraded(\n        address indexed oldImplementation,\n        address indexed newImplementation\n    );\n\n    constructor(\n        address implementation,\n        address chonkyAttributes,\n        address chonkyMetadata,\n        address chonkySet\n    ) {\n        OwnableStorage.layout().setOwner(msg.sender);\n        ChonkyNFTStorage.layout().implementation = implementation;\n\n        {\n            ERC721MetadataStorage.Layout storage l = ERC721MetadataStorage\n                .layout();\n            l.name = \"Chonkys\";\n            l.symbol = \"CK\";\n        }\n\n        {\n            ChonkyNFTStorage.Layout storage l = ChonkyNFTStorage.layout();\n            l.chonkyAttributes = chonkyAttributes;\n            l.chonkyMetadata = chonkyMetadata;\n            l.chonkySet = chonkySet;\n        }\n\n        {\n            ERC165Storage.Layout storage l = ERC165Storage.layout();\n            l.setSupportedInterface(type(IERC165).interfaceId, true);\n            l.setSupportedInterface(type(IERC721).interfaceId, true);\n        }\n    }\n\n    receive() external payable {}\n\n    function _getImplementation() internal view override returns (address) {\n        return ChonkyNFTStorage.layout().implementation;\n    }\n\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    function setImplementation(address implementation) external onlyOwner {\n        address oldImplementation = ChonkyNFTStorage.layout().implementation;\n        ChonkyNFTStorage.layout().implementation = implementation;\n        emit Upgraded(oldImplementation, implementation);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC721MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC721Metadata');\n\n    struct Layout {\n        string name;\n        string symbol;\n        string baseURI;\n        mapping(uint256 => string) tokenURIs;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from '../../introspection/IERC165.sol';\nimport { IERC721Internal } from './IERC721Internal.sol';\n\n/**\n * @notice ERC721 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721 is IERC721Internal, IERC165 {\n    /**\n     * @notice query the balance of given address\n     * @return balance quantity of tokens held\n     */\n    function balanceOf(address account) external view returns (uint256 balance);\n\n    /**\n     * @notice query the owner of given token\n     * @param tokenId token to query\n     * @return owner token owner\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @notice transfer token between given addresses, without checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @notice grant approval to given account to spend token\n     * @param operator address to be approved\n     * @param tokenId token to approve\n     */\n    function approve(address operator, uint256 tokenId) external payable;\n\n    /**\n     * @notice get approval status for given token\n     * @param tokenId token to query\n     * @return operator address approved to spend token\n     */\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n\n    /**\n     * @notice grant approval to or revoke approval from given account to spend all tokens held by sender\n     * @param operator address to be approved\n     * @param status approval status\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return status whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(address account, address operator)\n        external\n        view\n        returns (bool status);\n}\n"
    },
    "@solidstate/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { AddressUtils } from '../utils/AddressUtils.sol';\n\n/**\n * @title Base proxy contract\n */\nabstract contract Proxy {\n    using AddressUtils for address;\n\n    /**\n     * @notice delegate all calls to implementation contract\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\n     * @dev memory location in use by assembly may be unsafe in other contexts\n     */\n    fallback() external payable virtual {\n        address implementation = _getImplementation();\n\n        require(\n            implementation.isContract(),\n            'Proxy: implementation must be contract'\n        );\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice get logic implementation address\n     * @return implementation address\n     */\n    function _getImplementation() internal virtual returns (address);\n}\n"
    },
    "@solidstate/contracts/access/SafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Ownable, OwnableStorage } from './Ownable.sol';\nimport { SafeOwnableInternal } from './SafeOwnableInternal.sol';\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\n\n/**\n * @title Ownership access control based on ERC173 with ownership transfer safety check\n */\nabstract contract SafeOwnable is Ownable, SafeOwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\n\n    function nomineeOwner() public view virtual returns (address) {\n        return SafeOwnableStorage.layout().nomineeOwner;\n    }\n\n    /**\n     * @inheritdoc Ownable\n     * @dev ownership transfer must be accepted by beneficiary before transfer is complete\n     */\n    function transferOwnership(address account)\n        public\n        virtual\n        override\n        onlyOwner\n    {\n        SafeOwnableStorage.layout().setNomineeOwner(account);\n    }\n\n    /**\n     * @notice accept transfer of contract ownership\n     */\n    function acceptOwnership() public virtual onlyNomineeOwner {\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\n        emit OwnershipTransferred(l.owner, msg.sender);\n        l.setOwner(msg.sender);\n        SafeOwnableStorage.layout().setNomineeOwner(address(0));\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC165Storage {\n    struct Layout {\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC165');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function isSupportedInterface(Layout storage l, bytes4 interfaceId)\n        internal\n        view\n        returns (bool)\n    {\n        return l.supportedInterfaces[interfaceId];\n    }\n\n    function setSupportedInterface(\n        Layout storage l,\n        bytes4 interfaceId,\n        bool status\n    ) internal {\n        require(interfaceId != 0xffffffff, 'ERC165: invalid interface id');\n        l.supportedInterfaces[interfaceId] = status;\n    }\n}\n"
    },
    "contracts/ChonkyNFTStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"@solidstate/contracts/utils/EnumerableSet.sol\";\n\nlibrary ChonkyNFTStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256(\"chonky.contracts.storage.ChonkyNFT\");\n\n    struct Layout {\n        address implementation;\n        uint256 currentId;\n        uint256[] genomes;\n        // Offset IDs to randomize distribution when revealing\n        uint256 offset;\n        // Address of chonkyAttributes contract\n        address chonkyAttributes;\n        // Address of chonkyMetadata contract\n        address chonkyMetadata;\n        // Address of chonkySet contract\n        address chonkySet;\n        // Timestamp at which minting starts\n        uint256 startTimestamp;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/IERC721Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @notice Partial ERC721 interface needed by internal functions\n */\ninterface IERC721Internal {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed operator,\n        uint256 indexed tokenId\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary AddressUtils {\n    function toString(address account) internal pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(account)));\n        bytes memory alphabet = '0123456789abcdef';\n        bytes memory chars = new bytes(42);\n\n        chars[0] = '0';\n        chars[1] = 'x';\n\n        for (uint256 i = 0; i < 20; i++) {\n            chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n\n        return string(chars);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        require(success, 'AddressUtils: failed to send value');\n    }\n\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            'AddressUtils: insufficient balance for call'\n        );\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        require(\n            isContract(target),\n            'AddressUtils: function call to non-contract'\n        );\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC173 } from './IERC173.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\nimport { OwnableStorage } from './OwnableStorage.sol';\n\n/**\n * @title Ownership access control based on ERC173\n */\nabstract contract Ownable is IERC173, OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function owner() public view virtual override returns (address) {\n        return OwnableStorage.layout().owner;\n    }\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function transferOwnership(address account)\n        public\n        virtual\n        override\n        onlyOwner\n    {\n        OwnableStorage.layout().setOwner(account);\n        emit OwnershipTransferred(msg.sender, account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/SafeOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\n\nabstract contract SafeOwnableInternal {\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\n\n    modifier onlyNomineeOwner() {\n        require(\n            msg.sender == SafeOwnableStorage.layout().nomineeOwner,\n            'SafeOwnable: sender must be nominee owner'\n        );\n        _;\n    }\n}\n"
    },
    "@solidstate/contracts/access/SafeOwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary SafeOwnableStorage {\n    struct Layout {\n        address nomineeOwner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.SafeOwnable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setNomineeOwner(Layout storage l, address nomineeOwner) internal {\n        l.nomineeOwner = nomineeOwner;\n    }\n}\n"
    },
    "@solidstate/contracts/access/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Contract ownership standard interface\n * @dev see https://eips.ethereum.org/EIPS/eip-173\n */\ninterface IERC173 {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @notice get the ERC173 contract owner\n     * @return conract owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice transfer contract ownership to new account\n     * @param account address of new owner\n     */\n    function transferOwnership(address account) external;\n}\n"
    },
    "@solidstate/contracts/access/OwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { OwnableStorage } from './OwnableStorage.sol';\n\nabstract contract OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == OwnableStorage.layout().owner,\n            'Ownable: sender must be owner'\n        );\n        _;\n    }\n}\n"
    },
    "@solidstate/contracts/access/OwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Ownable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setOwner(Layout storage l, address owner) internal {\n        l.owner = owner;\n    }\n}\n"
    },
    "@solidstate/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n    struct Set {\n        bytes32[] _values;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function at(Bytes32Set storage set, uint256 index)\n        internal\n        view\n        returns (bytes32)\n    {\n        return _at(set._inner, index);\n    }\n\n    function at(AddressSet storage set, uint256 index)\n        internal\n        view\n        returns (address)\n    {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function at(UintSet storage set, uint256 index)\n        internal\n        view\n        returns (uint256)\n    {\n        return uint256(_at(set._inner, index));\n    }\n\n    function contains(Bytes32Set storage set, bytes32 value)\n        internal\n        view\n        returns (bool)\n    {\n        return _contains(set._inner, value);\n    }\n\n    function contains(AddressSet storage set, address value)\n        internal\n        view\n        returns (bool)\n    {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(UintSet storage set, uint256 value)\n        internal\n        view\n        returns (bool)\n    {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function indexOf(Bytes32Set storage set, bytes32 value)\n        internal\n        view\n        returns (uint256)\n    {\n        return _indexOf(set._inner, value);\n    }\n\n    function indexOf(AddressSet storage set, address value)\n        internal\n        view\n        returns (uint256)\n    {\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function indexOf(UintSet storage set, uint256 value)\n        internal\n        view\n        returns (uint256)\n    {\n        return _indexOf(set._inner, bytes32(value));\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function add(Bytes32Set storage set, bytes32 value)\n        internal\n        returns (bool)\n    {\n        return _add(set._inner, value);\n    }\n\n    function add(AddressSet storage set, address value)\n        internal\n        returns (bool)\n    {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(Bytes32Set storage set, bytes32 value)\n        internal\n        returns (bool)\n    {\n        return _remove(set._inner, value);\n    }\n\n    function remove(AddressSet storage set, address value)\n        internal\n        returns (bool)\n    {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(UintSet storage set, uint256 value)\n        internal\n        returns (bool)\n    {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function _at(Set storage set, uint256 index)\n        private\n        view\n        returns (bytes32)\n    {\n        require(\n            set._values.length > index,\n            'EnumerableSet: index out of bounds'\n        );\n        return set._values[index];\n    }\n\n    function _contains(Set storage set, bytes32 value)\n        private\n        view\n        returns (bool)\n    {\n        return set._indexes[value] != 0;\n    }\n\n    function _indexOf(Set storage set, bytes32 value)\n        private\n        view\n        returns (uint256)\n    {\n        unchecked {\n            return set._indexes[value] - 1;\n        }\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            uint256 index = valueIndex - 1;\n            bytes32 last = set._values[set._values.length - 1];\n\n            // move last value to now-vacant index\n\n            set._values[index] = last;\n            set._indexes[last] = index + 1;\n\n            // clear last index\n\n            set._values.pop();\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}