{"address-utils.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev Utility library of inline functions on addresses.\r\n * @notice Based on:\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n * Requires EIP-1052.\r\n */\r\nlibrary AddressUtils\r\n{\r\n\r\n  /**\r\n   * @dev Returns whether the target address is a contract.\r\n   * @param _addr Address to check.\r\n   * @return addressCheck True if _addr is a contract, false if not.\r\n   */\r\n  function isContract(\r\n    address _addr\r\n  )\r\n    internal\r\n    view\r\n    returns (bool addressCheck)\r\n  {\r\n    // This method relies in extcodesize, which returns 0 for contracts in\r\n    // construction, since the code is only stored at the end of the\r\n    // constructor execution.\r\n\r\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n    // for accounts without code, i.e. `keccak256(\u0027\u0027)`\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    assembly { codehash := extcodehash(_addr) } // solhint-disable-line\r\n    addressCheck = (codehash != 0x0 \u0026\u0026 codehash != accountHash);\r\n  }\r\n\r\n}\r\n"},"cmk-utils.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.4;\r\n\r\ncontract CmkUtils {\r\n    function getMin(uint256 a,uint256 b) internal pure returns(uint256){\r\n        if(a\u003eb) return b;\r\n        else return a;\r\n    }\r\n\r\n    function uint2str(uint256 _i) internal pure returns (string memory str) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 j = _i;\r\n        uint256 length;\r\n        while (j != 0) {\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint256 k = length;\r\n        j = _i;\r\n        while (j != 0) {\r\n            bstr[--k] = bytes1(uint8(48 + (j % 10)));\r\n            j /= 10;\r\n        }\r\n        str = string(bstr);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b)\r\n        internal\r\n        pure\r\n        returns (string memory _concatenatedString)\r\n    {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    function strConcat(\r\n        string memory _a,\r\n        string memory _b,\r\n        string memory _c\r\n    ) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(\r\n        string memory _a,\r\n        string memory _b,\r\n        string memory _c,\r\n        string memory _d\r\n    ) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(\r\n        string memory _a,\r\n        string memory _b,\r\n        string memory _c,\r\n        string memory _d,\r\n        string memory _e\r\n    ) internal pure returns (string memory _concatenatedString) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(\r\n            _ba.length + _bb.length + _bc.length + _bd.length + _be.length\r\n        );\r\n        bytes memory babcde = bytes(abcde);\r\n        uint256 k = 0;\r\n        uint256 i = 0;\r\n        for (i = 0; i \u003c _ba.length; i++) {\r\n            babcde[k++] = _ba[i];\r\n        }\r\n        for (i = 0; i \u003c _bb.length; i++) {\r\n            babcde[k++] = _bb[i];\r\n        }\r\n        for (i = 0; i \u003c _bc.length; i++) {\r\n            babcde[k++] = _bc[i];\r\n        }\r\n        for (i = 0; i \u003c _bd.length; i++) {\r\n            babcde[k++] = _bd[i];\r\n        }\r\n        for (i = 0; i \u003c _be.length; i++) {\r\n            babcde[k++] = _be[i];\r\n        }\r\n        return string(babcde);\r\n    }\r\n}\r\n"},"crypto-monkey-king.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./erc721-metadata.sol\";\r\nimport \"./nf-token-enumerable.sol\";\r\nimport \"./ownable.sol\";\r\nimport \"./address-utils.sol\";\r\nimport \"./cmk-utils.sol\";\r\nimport \"./datetime-library.sol\";\r\n\r\ncontract CryptoMonkeyKing is\r\n    NFTokenEnumerable,\r\n    Ownable,\r\n    CmkUtils,\r\n    ERC721Metadata\r\n{\r\n    using AddressUtils for address;\r\n\r\n    /************************************struct********************************/\r\n    struct NFT {\r\n        uint256 id;\r\n        bool isSelling;\r\n        uint256 priceInWei;\r\n        address owner;\r\n    }\r\n\r\n    struct MintedInfo {\r\n        uint256 lastYear;\r\n        uint256 lastMonth;\r\n        uint256 lastDay;\r\n        uint256 lastCount;\r\n        uint256 minted;\r\n    }\r\n\r\n    /************************************error********************************/\r\n    string constant NOT_VALID_NFT_ID = \"004001\";\r\n    string constant NOT_RESERVE = \"004002\";\r\n    string constant NOT_NORMAL = \"004003\";\r\n    string constant IN_SELLING = \"004004\";\r\n    string constant NO_SELLING = \"004005\";\r\n    string constant NFT_HAS_NO_OWNER = \"004006\";\r\n    string constant NFT_HAS_OWNER = \"004007\";\r\n    string constant IS_NFT_OWNER = \"004008\";\r\n    string constant NOT_NFT_OWNER = \"004009\";\r\n    string constant NOT_AIRDROP_ACCOUNT = \"004010\";\r\n    string constant NOT_ENOUGH_BALANCE = \"004011\";\r\n    string constant OUT_OF_MAX_PAGE_SIZE = \"004012\";\r\n    string constant OUT_OF_MINT_MAX_PER_TIME = \"004013\";\r\n    string constant OUT_OF_MINT_MAX_PER_DAY = \"004014\";\r\n    string constant SENDER_MINTED = \"004015\";\r\n\r\n    /************************************variable********************************/\r\n    string private baseURI;\r\n    address private airdropAccount;\r\n    uint256 private maxSupply;\r\n    uint256 private maxPageSize;\r\n    uint256 private maxMintPerTime;\r\n    uint256 private mintMaxPerDay;\r\n    uint256 private mintPrice;\r\n    MintedInfo mintedInfo;\r\n    mapping(address =\u003e bool) private addressToMinted;\r\n\r\n    /************************************validator********************************/\r\n    modifier onlyAirdrop() {\r\n        require(msg.sender == airdropAccount, NOT_AIRDROP_ACCOUNT);\r\n        _;\r\n    }\r\n\r\n    modifier validNFTId(uint256 _id) {\r\n        require(_id \u003e= 0 \u0026\u0026 _id \u003c= maxSupply - 1, NOT_VALID_NFT_ID);\r\n        _;\r\n    }\r\n\r\n    /************************************helps********************************/\r\n    function isReserve(uint256 _id) internal pure returns (bool) {\r\n        return _id \u003e= 7000 \u0026\u0026 _id \u003c 10000;\r\n    }\r\n\r\n    function isNormal(uint256 _id) internal pure returns (bool) {\r\n        return _id \u003e= 0 \u0026\u0026 _id \u003c 7000;\r\n    }\r\n\r\n    /************************************business********************************/\r\n    /***contructor***/\r\n    constructor() {\r\n        baseURI = \"https://cryptomonkeyking.com/token\";\r\n        airdropAccount = 0x251d42b900973eD14D7Ea82Ce9310D34534f75EC;\r\n        maxSupply = 10000;\r\n        maxPageSize = 1000;\r\n        maxMintPerTime = 5;\r\n        mintMaxPerDay = 200;\r\n    }\r\n\r\n    /***ERC721Metadata***/\r\n    function name() external pure override returns (string memory _name) {\r\n        return \"Crypto Monkey King\";\r\n    }\r\n\r\n    function symbol() external pure override returns (string memory _symbol) {\r\n        return \"CMK\";\r\n    }\r\n\r\n    function tokenURI(uint256 _id)\r\n        external\r\n        view\r\n        override\r\n        returns (string memory)\r\n    {\r\n        return strConcat(baseURI, \"/\", uint2str(_id));\r\n    }\r\n\r\n    /***onlyOwner***/\r\n    function setBaseURI(string memory _baseURI) public onlyOwner {\r\n        baseURI = _baseURI;\r\n    }\r\n\r\n    function getBaseURI() public view onlyOwner returns (string memory) {\r\n        return baseURI;\r\n    }\r\n\r\n    function setAirdropAccount(address _airdropAccount) public onlyOwner {\r\n        airdropAccount = _airdropAccount;\r\n    }\r\n\r\n    function getAirdropAccount() public view onlyOwner returns (address) {\r\n        return airdropAccount;\r\n    }\r\n\r\n    function setMintPrice(uint256 _mintPrice) public onlyOwner {\r\n        mintPrice = _mintPrice;\r\n    }\r\n\r\n    function getMintPrice() public view returns (uint256) {\r\n        return mintPrice;\r\n    }\r\n\r\n    function setMaxMintPerTime(uint256 _maxMintPerTime) public onlyOwner {\r\n        maxMintPerTime = _maxMintPerTime;\r\n    }\r\n\r\n    function getMaxMintPerTime() public view returns (uint256) {\r\n        return maxMintPerTime;\r\n    }\r\n\r\n    function setMintMaxPerDay(uint256 _mintMaxPerDay) public onlyOwner {\r\n        mintMaxPerDay = _mintMaxPerDay;\r\n    }\r\n\r\n    function getMintMaxPerDay() public view returns (uint256) {\r\n        return mintMaxPerDay;\r\n    }\r\n\r\n    /***business***/\r\n    function getMaxSupply() public view returns (uint256) {\r\n        return maxSupply;\r\n    }\r\n\r\n    function getMaxPageSize() public view returns (uint256) {\r\n        return maxPageSize;\r\n    }\r\n\r\n    function getMintableRemaining() public view returns (uint256) {\r\n        return 7000 - mintedInfo.minted;\r\n    }\r\n\r\n    function getPagedNFTs(uint256 pageSize, uint256 pageIndex)\r\n        public\r\n        view\r\n        returns (NFT[] memory)\r\n    {\r\n        require(pageSize \u003c= maxPageSize, OUT_OF_MAX_PAGE_SIZE);\r\n\r\n        uint256 start = pageSize * pageIndex;\r\n        uint256 end = start + pageSize - 1;\r\n\r\n        if (start \u003e maxSupply - 1) {\r\n            start = maxSupply - 1;\r\n        }\r\n\r\n        if (end \u003e maxSupply - 1) {\r\n            end = maxSupply - 1;\r\n        }\r\n\r\n        NFT[] memory NFTs = new NFT[](pageSize);\r\n        for (uint256 i = start; i \u003c= end; i++) {\r\n            address owner = idToOwner[i];\r\n            NFT memory nft = NFT(i, false, 0, owner);\r\n            NFTs[i - start] = nft;\r\n        }\r\n        return NFTs;\r\n    }\r\n\r\n    function getMintedCountToday() public view returns(uint256){\r\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary\r\n            .timestampToDate(block.timestamp);\r\n        uint count=0;\r\n        if (\r\n            mintedInfo.lastYear == year \u0026\u0026\r\n            mintedInfo.lastMonth == month \u0026\u0026\r\n            mintedInfo.lastDay == day\r\n        ) {\r\n            count = mintedInfo.lastCount;\r\n        } else {\r\n            count = 0;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    function getMintableCountToday() public view returns (uint256) {\r\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary\r\n            .timestampToDate(block.timestamp);\r\n\r\n        uint256 count = 0;\r\n        uint256 remainToday = CmkUtils.getMin(7000 - mintedInfo.minted, mintMaxPerDay);\r\n        if (\r\n            mintedInfo.lastYear == year \u0026\u0026\r\n            mintedInfo.lastMonth == month \u0026\u0026\r\n            mintedInfo.lastDay == day\r\n        ) {\r\n            count = remainToday - mintedInfo.lastCount;\r\n        } else {\r\n            count = remainToday;\r\n        }\r\n\r\n        if (count \u003c 0) {\r\n            count = 0;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    function isMinted(address _addr) public view returns (bool) {\r\n        return addressToMinted[_addr];\r\n    }\r\n\r\n    function mintNFTs(uint256[] memory _ids) public payable {\r\n        // 需要未领过\r\n        require(!addressToMinted[msg.sender], SENDER_MINTED);\r\n        // 不要超过当日可领上限\r\n        require(\r\n            _ids.length \u003c= getMintableCountToday(),\r\n            OUT_OF_MINT_MAX_PER_DAY\r\n        );\r\n        // 不要超过每次可领上限\r\n        require(_ids.length \u003c= maxMintPerTime, OUT_OF_MINT_MAX_PER_TIME);\r\n\r\n        uint256 total = _ids.length * mintPrice;\r\n        require(total \u003c= msg.value, NOT_ENOUGH_BALANCE);\r\n\r\n        for (uint256 i = 0; i \u003c _ids.length; i++) {\r\n            uint256 _id = _ids[i];\r\n            require(isNormal(_id), NOT_NORMAL);\r\n            require(idToOwner[_id] == address(0), NFT_HAS_OWNER);\r\n\r\n            _mint(msg.sender, _id);\r\n        }\r\n\r\n        // 更新当日领取数\r\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary\r\n            .timestampToDate(block.timestamp);\r\n\r\n        if (\r\n            mintedInfo.lastYear == year \u0026\u0026\r\n            mintedInfo.lastMonth == month \u0026\u0026\r\n            mintedInfo.lastDay == day\r\n        ) {\r\n            mintedInfo.lastCount += _ids.length;\r\n        } else {\r\n            mintedInfo.lastCount = _ids.length;\r\n        }\r\n\r\n        // 更新最近领取时间\r\n        mintedInfo.lastYear = year;\r\n        mintedInfo.lastMonth = month;\r\n        mintedInfo.lastDay = day;\r\n\r\n        // 更新累计已领\r\n        mintedInfo.minted += _ids.length;\r\n\r\n        // 标记已领取\r\n        addressToMinted[msg.sender] = true;\r\n\r\n        // 收款\r\n        if (mintPrice \u003e 0) {\r\n            payable(owner).transfer(msg.value);\r\n        }\r\n    }\r\n\r\n    function airdropNFT(address _to, uint256 _id)\r\n        public\r\n        onlyAirdrop\r\n        validNFTId(_id)\r\n    {\r\n        require(isReserve(_id), NOT_RESERVE);\r\n        require(idToOwner[_id] == address(0), NFT_HAS_OWNER);\r\n\r\n        _mint(_to, _id);\r\n    }\r\n\r\n    function airdropNFTs(address _to, uint256[] memory _ids) public {\r\n        for (uint256 i = 0; i \u003c _ids.length; i++) {\r\n            uint256 id = _ids[i];\r\n            airdropNFT(_to, id);\r\n        }\r\n    }\r\n\r\n    function giveNFT(address _to, uint256 _id) public validNFTId(_id) {\r\n        require(this.ownerOf(_id) == msg.sender, NOT_NFT_OWNER);\r\n\r\n        _transfer(_to, _id);\r\n    }\r\n\r\n    function giveNFTs(address _to, uint256[] memory _ids) public {\r\n        for (uint256 i = 0; i \u003c _ids.length; i++) {\r\n            uint256 id = _ids[i];\r\n            giveNFT(_to, id);\r\n        }\r\n    }\r\n}\r\n"},"datetime-library.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n// ----------------------------------------------------------------------------\r\n// BokkyPooBah\u0027s DateTime Library v1.01\r\n//\r\n// A gas-efficient Solidity date and time library\r\n//\r\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\r\n//\r\n// Tested date range 1970/01/01 to 2345/12/31\r\n//\r\n// Conventions:\r\n// Unit      | Range         | Notes\r\n// :-------- |:-------------:|:-----\r\n// timestamp | \u003e= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\r\n// year      | 1970 ... 2345 |\r\n// month     | 1 ... 12      |\r\n// day       | 1 ... 31      |\r\n// hour      | 0 ... 23      |\r\n// minute    | 0 ... 59      |\r\n// second    | 0 ... 59      |\r\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\r\n//\r\n//\r\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n\r\nlibrary BokkyPooBahsDateTimeLibrary {\r\n\r\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n    uint constant SECONDS_PER_HOUR = 60 * 60;\r\n    uint constant SECONDS_PER_MINUTE = 60;\r\n    int constant OFFSET19700101 = 2440588;\r\n\r\n    uint constant DOW_MON = 1;\r\n    uint constant DOW_TUE = 2;\r\n    uint constant DOW_WED = 3;\r\n    uint constant DOW_THU = 4;\r\n    uint constant DOW_FRI = 5;\r\n    uint constant DOW_SAT = 6;\r\n    uint constant DOW_SUN = 7;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate the number of days from 1970/01/01 to year/month/day using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // days = day\r\n    //      - 32075\r\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\r\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\r\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\r\n    //      - offset\r\n    // ------------------------------------------------------------------------\r\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\r\n        require(year \u003e= 1970);\r\n        int _year = int(year);\r\n        int _month = int(month);\r\n        int _day = int(day);\r\n\r\n        int __days = _day\r\n          - 32075\r\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\r\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\r\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\r\n          - OFFSET19700101;\r\n\r\n        _days = uint(__days);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate year/month/day from the number of days since 1970/01/01 using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // int L = days + 68569 + offset\r\n    // int N = 4 * L / 146097\r\n    // L = L - (146097 * N + 3) / 4\r\n    // year = 4000 * (L + 1) / 1461001\r\n    // L = L - 1461 * year / 4 + 31\r\n    // month = 80 * L / 2447\r\n    // dd = L - 2447 * month / 80\r\n    // L = month / 11\r\n    // month = month + 2 - 12 * L\r\n    // year = 100 * (N - 49) + year + L\r\n    // ------------------------------------------------------------------------\r\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\r\n        int __days = int(_days);\r\n\r\n        int L = __days + 68569 + OFFSET19700101;\r\n        int N = 4 * L / 146097;\r\n        L = L - (146097 * N + 3) / 4;\r\n        int _year = 4000 * (L + 1) / 1461001;\r\n        L = L - 1461 * _year / 4 + 31;\r\n        int _month = 80 * L / 2447;\r\n        int _day = L - 2447 * _month / 80;\r\n        L = _month / 11;\r\n        _month = _month + 2 - 12 * L;\r\n        _year = 100 * (N - 49) + _year + L;\r\n\r\n        year = uint(_year);\r\n        month = uint(_month);\r\n        day = uint(_day);\r\n    }\r\n\r\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\r\n    }\r\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\r\n    }\r\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n        secs = secs % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n        second = secs % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\r\n        if (year \u003e= 1970 \u0026\u0026 month \u003e 0 \u0026\u0026 month \u003c= 12) {\r\n            uint daysInMonth = _getDaysInMonth(year, month);\r\n            if (day \u003e 0 \u0026\u0026 day \u003c= daysInMonth) {\r\n                valid = true;\r\n            }\r\n        }\r\n    }\r\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\r\n        if (isValidDate(year, month, day)) {\r\n            if (hour \u003c 24 \u0026\u0026 minute \u003c 60 \u0026\u0026 second \u003c 60) {\r\n                valid = true;\r\n            }\r\n        }\r\n    }\r\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\r\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        leapYear = _isLeapYear(year);\r\n    }\r\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\r\n        leapYear = ((year % 4 == 0) \u0026\u0026 (year % 100 != 0)) || (year % 400 == 0);\r\n    }\r\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\r\n        weekDay = getDayOfWeek(timestamp) \u003c= DOW_FRI;\r\n    }\r\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\r\n        weekEnd = getDayOfWeek(timestamp) \u003e= DOW_SAT;\r\n    }\r\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\r\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        daysInMonth = _getDaysInMonth(year, month);\r\n    }\r\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n            daysInMonth = 31;\r\n        } else if (month != 2) {\r\n            daysInMonth = 30;\r\n        } else {\r\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\r\n        }\r\n    }\r\n    // 1 = Monday, 7 = Sunday\r\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\r\n        uint _days = timestamp / SECONDS_PER_DAY;\r\n        dayOfWeek = (_days + 3) % 7 + 1;\r\n    }\r\n\r\n    function getYear(uint timestamp) internal pure returns (uint year) {\r\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getMonth(uint timestamp) internal pure returns (uint month) {\r\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getDay(uint timestamp) internal pure returns (uint day) {\r\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getHour(uint timestamp) internal pure returns (uint hour) {\r\n        uint secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n    }\r\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\r\n        uint secs = timestamp % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n    }\r\n    function getSecond(uint timestamp) internal pure returns (uint second) {\r\n        second = timestamp % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        year += _years;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day \u003e daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp \u003e= timestamp);\r\n    }\r\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        month += _months;\r\n        year += (month - 1) / 12;\r\n        month = (month - 1) % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day \u003e daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp \u003e= timestamp);\r\n    }\r\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\r\n        require(newTimestamp \u003e= timestamp);\r\n    }\r\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\r\n        require(newTimestamp \u003e= timestamp);\r\n    }\r\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\r\n        require(newTimestamp \u003e= timestamp);\r\n    }\r\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _seconds;\r\n        require(newTimestamp \u003e= timestamp);\r\n    }\r\n\r\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        year -= _years;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day \u003e daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp \u003c= timestamp);\r\n    }\r\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint yearMonth = year * 12 + (month - 1) - _months;\r\n        year = yearMonth / 12;\r\n        month = yearMonth % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day \u003e daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp \u003c= timestamp);\r\n    }\r\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\r\n        require(newTimestamp \u003c= timestamp);\r\n    }\r\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\r\n        require(newTimestamp \u003c= timestamp);\r\n    }\r\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\r\n        require(newTimestamp \u003c= timestamp);\r\n    }\r\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _seconds;\r\n        require(newTimestamp \u003c= timestamp);\r\n    }\r\n\r\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\r\n        require(fromTimestamp \u003c= toTimestamp);\r\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _years = toYear - fromYear;\r\n    }\r\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\r\n        require(fromTimestamp \u003c= toTimestamp);\r\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\r\n    }\r\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\r\n        require(fromTimestamp \u003c= toTimestamp);\r\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\r\n    }\r\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\r\n        require(fromTimestamp \u003c= toTimestamp);\r\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\r\n    }\r\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\r\n        require(fromTimestamp \u003c= toTimestamp);\r\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\r\n    }\r\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\r\n        require(fromTimestamp \u003c= toTimestamp);\r\n        _seconds = toTimestamp - fromTimestamp;\r\n    }\r\n}"},"erc165.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev A standard for detecting smart contract interfaces. \r\n * See: https://eips.ethereum.org/EIPS/eip-165.\r\n */\r\ninterface ERC165\r\n{\r\n\r\n  /**\r\n   * @dev Checks if the smart contract includes a specific interface.\r\n   * This function uses less than 30,000 gas.\r\n   * @param _interfaceID The interface identifier, as specified in ERC-165.\r\n   * @return True if _interfaceID is supported, false otherwise.\r\n   */\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n    \r\n}\r\n"},"erc721-enumerable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721Enumerable\r\n{\r\n\r\n  /**\r\n   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\r\n   * assigned and queryable owner not equal to the zero address.\r\n   * @return Total supply of NFTs.\r\n   */\r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\r\n   * @param _index A counter less than `totalSupply()`.\r\n   * @return Token id.\r\n   */\r\n  function tokenByIndex(\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\r\n   * not specified. It throws if `_index` \u003e= `balanceOf(_owner)` or if `_owner` is the zero address,\r\n   * representing invalid NFTs.\r\n   * @param _owner An address where we are interested in NFTs owned by them.\r\n   * @param _index A counter less than `balanceOf(_owner)`.\r\n   * @return Token id.\r\n   */\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n}\r\n"},"erc721-metadata.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev Optional metadata extension for ERC-721 non-fungible token standard.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721Metadata\r\n{\r\n\r\n  /**\r\n   * @dev Returns a descriptive name for a collection of NFTs in this contract.\r\n   * @return _name Representing name.\r\n   */\r\n  function name()\r\n    external\r\n    view\r\n    returns (string memory _name);\r\n\r\n  /**\r\n   * @dev Returns a abbreviated name for a collection of NFTs in this contract.\r\n   * @return _symbol Representing symbol.\r\n   */\r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string memory _symbol);\r\n\r\n  /**\r\n   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\r\n   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\r\n   * that conforms to the \"ERC721 Metadata JSON Schema\".\r\n   * @return URI of _tokenId.\r\n   */\r\n  function tokenURI(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (string memory);\r\n\r\n}\r\n"},"erc721-token-receiver.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev ERC-721 interface for accepting safe transfers.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721TokenReceiver\r\n{\r\n\r\n  /**\r\n   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\r\n   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n   * of other than the magic value MUST result in the transaction being reverted.\r\n   * Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` unless throwing.\r\n   * @notice The contract address is always the message sender. A wallet/broker/auction application\r\n   * MUST implement the wallet interface if it will accept safe transfers.\r\n   * @param _operator The address which called `safeTransferFrom` function.\r\n   * @param _from The address which previously owned the token.\r\n   * @param _tokenId The NFT identifier which is being transferred.\r\n   * @param _data Additional data with no specified format.\r\n   * @return Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n   */\r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    returns(bytes4);\r\n\r\n}\r\n"},"erc721.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev ERC-721 non-fungible token standard.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721\r\n{\r\n\r\n  /**\r\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\r\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\r\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\r\n   * transfer, the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\r\n   * address indicates there is no approved address. When a Transfer event emits, this also\r\n   * indicates that the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\r\n   * all NFTs of the owner.\r\n   */\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n   * function checks if `_to` is a smart contract (code size \u003e 0). If so, it calls\r\n   * `onERC721Received` on `_to` and throws if the return value is not\r\n   * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice This works identically to the other function with an extra data parameter, except this\r\n   * function just sets data to \"\"\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n   * address. Throws if `_tokenId` is not a valid NFT.\r\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n   * they may be permanently lost.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Set or reaffirm the approved address for an NFT.\r\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n   * the current NFT owner, or an authorized operator of the current owner.\r\n   * @param _approved The new approved NFT controller.\r\n   * @param _tokenId The NFT to approve.\r\n   */\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n   * `msg.sender`\u0027s assets. It also emits the ApprovalForAll event.\r\n   * @notice The contract MUST allow multiple operators per owner.\r\n   * @param _operator Address to add to the set of authorized operators.\r\n   * @param _approved True if the operators is approved, false to revoke approval.\r\n   */\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @param _owner Address for whom to query the balance.\r\n   * @return Balance of _owner.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\r\n   * considered invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   * @return Address of _tokenId owner.\r\n   */\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  /**\r\n   * @dev Get the approved address for a single NFT.\r\n   * @notice Throws if `_tokenId` is not a valid NFT.\r\n   * @param _tokenId The NFT to find the approved address for.\r\n   * @return Address that _tokenId is approved for.\r\n   */\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  /**\r\n   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\r\n   * @param _owner The address that owns the NFTs.\r\n   * @param _operator The address that acts on behalf of the owner.\r\n   * @return True if approved for all, false otherwise.\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n"},"Migrations.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity \u003e=0.4.22 \u003c0.9.0;\r\n\r\ncontract Migrations {\r\n  address public owner = msg.sender;\r\n  uint public last_completed_migration;\r\n\r\n  modifier restricted() {\r\n    require(\r\n      msg.sender == owner,\r\n      \"This function is restricted to the contract\u0027s owner\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  function setCompleted(uint completed) public restricted {\r\n    last_completed_migration = completed;\r\n  }\r\n}\r\n"},"nf-token-enumerable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./nf-token.sol\";\r\nimport \"./erc721-enumerable.sol\";\r\n\r\n/**\r\n * @dev Optional enumeration implementation for ERC-721 non-fungible token standard.\r\n */\r\ncontract NFTokenEnumerable is\r\n  NFToken,\r\n  ERC721Enumerable\r\n{\r\n\r\n  /**\r\n   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\r\n   * Based on 0xcert framework error codes.\r\n   */\r\n  string constant INVALID_INDEX = \"005007\";\r\n\r\n  /**\r\n   * @dev Array of all NFT IDs.\r\n   */\r\n  uint256[] internal tokens;\r\n\r\n  /**\r\n   * @dev Mapping from token ID to its index in global tokens array.\r\n   */\r\n  mapping(uint256 =\u003e uint256) internal idToIndex;\r\n\r\n  /**\r\n   * @dev Mapping from owner to list of owned NFT IDs.\r\n   */\r\n  mapping(address =\u003e uint256[]) internal ownerToIds;\r\n\r\n  /**\r\n   * @dev Mapping from NFT ID to its index in the owner tokens list.\r\n   */\r\n  mapping(uint256 =\u003e uint256) internal idToOwnerIndex;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n  {\r\n    supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the count of all existing NFTokens.\r\n   * @return Total supply of NFTs.\r\n   */\r\n  function totalSupply()\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return tokens.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns NFT ID by its index.\r\n   * @param _index A counter less than `totalSupply()`.\r\n   * @return Token id.\r\n   */\r\n  function tokenByIndex(\r\n    uint256 _index\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_index \u003c tokens.length, INVALID_INDEX);\r\n    return tokens[_index];\r\n  }\r\n\r\n  /**\r\n   * @dev returns the n-th NFT ID from a list of owner\u0027s tokens.\r\n   * @param _owner Token owner\u0027s address.\r\n   * @param _index Index number representing n-th token in owner\u0027s list of tokens.\r\n   * @return Token id.\r\n   */\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_index \u003c ownerToIds[_owner].length, INVALID_INDEX);\r\n    return ownerToIds[_owner][_index];\r\n  }\r\n\r\n  /**\r\n   * @dev Mints a new NFT.\r\n   * @notice This is an internal function which should be called from user-implemented external\r\n   * mint function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _to The address that will own the minted NFT.\r\n   * @param _tokenId of the NFT to be minted by the msg.sender.\r\n   */\r\n  function _mint(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    override\r\n    virtual\r\n  {\r\n    super._mint(_to, _tokenId);\r\n    tokens.push(_tokenId);\r\n    idToIndex[_tokenId] = tokens.length - 1;\r\n  }\r\n\r\n  /**\r\n   * @dev Burns a NFT.\r\n   * @notice This is an internal function which should be called from user-implemented external\r\n   * burn function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\r\n   * NFT.\r\n   * @param _tokenId ID of the NFT to be burned.\r\n   */\r\n  function _burn(\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    override\r\n    virtual\r\n  {\r\n    super._burn(_tokenId);\r\n\r\n    uint256 tokenIndex = idToIndex[_tokenId];\r\n    uint256 lastTokenIndex = tokens.length - 1;\r\n    uint256 lastToken = tokens[lastTokenIndex];\r\n\r\n    tokens[tokenIndex] = lastToken;\r\n\r\n    tokens.pop();\r\n    // This wastes gas if you are burning the last token but saves a little gas if you are not.\r\n    idToIndex[lastToken] = tokenIndex;\r\n    idToIndex[_tokenId] = 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a NFT from an address.\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @param _from Address from wich we want to remove the NFT.\r\n   * @param _tokenId Which NFT we want to remove.\r\n   */\r\n  function _removeNFToken(\r\n    address _from,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    override\r\n    virtual\r\n  {\r\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\r\n    delete idToOwner[_tokenId];\r\n\r\n    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n    uint256 lastTokenIndex = ownerToIds[_from].length - 1;\r\n\r\n    if (lastTokenIndex != tokenToRemoveIndex)\r\n    {\r\n      uint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n      ownerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n      idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n    }\r\n\r\n    ownerToIds[_from].pop();\r\n  }\r\n\r\n  /**\r\n   * @dev Assigns a new NFT to an address.\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @param _to Address to wich we want to add the NFT.\r\n   * @param _tokenId Which NFT we want to add.\r\n   */\r\n  function _addNFToken(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    override\r\n    virtual\r\n  {\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n    idToOwner[_tokenId] = _to;\r\n\r\n    ownerToIds[_to].push(_tokenId);\r\n    idToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;\r\n  }\r\n\r\n  /**\r\n   * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\r\n   * extension to remove double storage(gas optimization) of owner NFT count.\r\n   * @param _owner Address for whom to query the count.\r\n   * @return Number of _owner NFTs.\r\n   */\r\n  function _getOwnerNFTCount(\r\n    address _owner\r\n  )\r\n    internal\r\n    override\r\n    virtual\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return ownerToIds[_owner].length;\r\n  }\r\n}\r\n"},"nf-token-metadata.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./nf-token.sol\";\r\nimport \"./erc721-metadata.sol\";\r\n\r\n/**\r\n * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\r\n */\r\ncontract NFTokenMetadata is\r\n  NFToken,\r\n  ERC721Metadata\r\n{\r\n\r\n  /**\r\n   * @dev A descriptive name for a collection of NFTs.\r\n   */\r\n  string internal nftName;\r\n\r\n  /**\r\n   * @dev An abbreviated name for NFTokens.\r\n   */\r\n  string internal nftSymbol;\r\n\r\n  /**\r\n   * @dev Mapping from NFT ID to metadata uri.\r\n   */\r\n  mapping (uint256 =\u003e string) internal idToUri;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   * @notice When implementing this contract don\u0027t forget to set nftName and nftSymbol.\r\n   */\r\n  constructor()\r\n  {\r\n    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\r\n  }\r\n\r\n  /**\r\n   * @dev Returns a descriptive name for a collection of NFTokens.\r\n   * @return _name Representing name.\r\n   */\r\n  function name()\r\n    external\r\n    override\r\n    view\r\n    returns (string memory _name)\r\n  {\r\n    _name = nftName;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an abbreviated name for NFTokens.\r\n   * @return _symbol Representing symbol.\r\n   */\r\n  function symbol()\r\n    external\r\n    override\r\n    view\r\n    returns (string memory _symbol)\r\n  {\r\n    _symbol = nftSymbol;\r\n  }\r\n\r\n  /**\r\n   * @dev A distinct URI (RFC 3986) for a given NFT.\r\n   * @param _tokenId Id for which we want uri.\r\n   * @return URI of _tokenId.\r\n   */\r\n  function tokenURI(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    validNFToken(_tokenId)\r\n    returns (string memory)\r\n  {\r\n    return idToUri[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Burns a NFT.\r\n   * @notice This is an internal function which should be called from user-implemented external\r\n   * burn function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\r\n   * NFT.\r\n   * @param _tokenId ID of the NFT to be burned.\r\n   */\r\n  function _burn(\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    override\r\n    virtual\r\n  {\r\n    super._burn(_tokenId);\r\n\r\n    if (bytes(idToUri[_tokenId]).length != 0)\r\n    {\r\n      delete idToUri[_tokenId];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Set a distinct URI (RFC 3986) for a given NFT ID.\r\n   * @notice This is an internal function which should be called from user-implemented external\r\n   * function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _tokenId Id for which we want URI.\r\n   * @param _uri String representing RFC 3986 URI.\r\n   */\r\n  function _setTokenUri(\r\n    uint256 _tokenId,\r\n    string memory _uri\r\n  )\r\n    internal\r\n    validNFToken(_tokenId)\r\n  {\r\n    idToUri[_tokenId] = _uri;\r\n  }\r\n\r\n}\r\n"},"nf-token.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./erc721.sol\";\r\nimport \"./erc721-token-receiver.sol\";\r\nimport \"./supports-interface.sol\";\r\nimport \"./address-utils.sol\";\r\n\r\n/**\r\n * @dev Implementation of ERC-721 non-fungible token standard.\r\n */\r\ncontract NFToken is\r\n  ERC721,\r\n  SupportsInterface\r\n{\r\n  using AddressUtils for address;\r\n\r\n  /**\r\n   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\r\n   * Based on 0xcert framework error codes.\r\n   */\r\n  string constant ZERO_ADDRESS = \"003001\";\r\n  string constant NOT_VALID_NFT = \"003002\";\r\n  string constant NOT_OWNER_OR_OPERATOR = \"003003\";\r\n  string constant NOT_OWNER_APPROVED_OR_OPERATOR = \"003004\";\r\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\r\n  string constant NFT_ALREADY_EXISTS = \"003006\";\r\n  string constant NOT_OWNER = \"003007\";\r\n  string constant IS_OWNER = \"003008\";\r\n\r\n  /**\r\n   * @dev Magic value of a smart contract that can receive NFT.\r\n   * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\r\n   */\r\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  /**\r\n   * @dev A mapping from NFT ID to the address that owns it.\r\n   */\r\n  mapping (uint256 =\u003e address) internal idToOwner;\r\n\r\n  /**\r\n   * @dev Mapping from NFT ID to approved address.\r\n   */\r\n  mapping (uint256 =\u003e address) internal idToApproval;\r\n\r\n   /**\r\n   * @dev Mapping from owner address to count of his tokens.\r\n   */\r\n  mapping (address =\u003e uint256) private ownerToNFTokenCount;\r\n\r\n  /**\r\n   * @dev Mapping from owner address to mapping of operator addresses.\r\n   */\r\n  mapping (address =\u003e mapping (address =\u003e bool)) internal ownerToOperators;\r\n\r\n  /**\r\n   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\r\n   * @param _tokenId ID of the NFT to validate.\r\n   */\r\n  modifier canOperate(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_OR_OPERATOR\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Guarantees that the msg.sender is allowed to transfer NFT.\r\n   * @param _tokenId ID of the NFT to transfer.\r\n   */\r\n  modifier canTransfer(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender\r\n      || idToApproval[_tokenId] == msg.sender\r\n      || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_APPROVED_OR_OPERATOR\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Guarantees that _tokenId is a valid Token.\r\n   * @param _tokenId ID of the NFT to validate.\r\n   */\r\n  modifier validNFToken(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n  {\r\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n   * be changed to payable.\r\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n   * function checks if `_to` is a smart contract (code size \u003e 0). If so, it calls\r\n   * `onERC721Received` on `_to` and throws if the return value is not\r\n   * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, _data);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n   * be changed to payable.\r\n   * @notice This works identically to the other function with an extra data parameter, except this\r\n   * function just sets data to \"\"\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n   * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\r\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n   * they may be permanently lost.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, NOT_OWNER);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    _transfer(_to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\r\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n   * the current NFT owner, or an authorized operator of the current owner.\r\n   * @param _approved Address to be approved for the given NFT ID.\r\n   * @param _tokenId ID of the token to be approved.\r\n   */\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    canOperate(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(_approved != tokenOwner, IS_OWNER);\r\n\r\n    idToApproval[_tokenId] = _approved;\r\n    emit Approval(tokenOwner, _approved, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n   * `msg.sender`\u0027s assets. It also emits the ApprovalForAll event.\r\n   * @notice This works even if sender doesn\u0027t own any tokens at the time.\r\n   * @param _operator Address to add to the set of authorized operators.\r\n   * @param _approved True if the operators is approved, false to revoke approval.\r\n   */\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external\r\n    override\r\n  {\r\n    ownerToOperators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @param _owner Address for whom to query the balance.\r\n   * @return Balance of _owner.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_owner != address(0), ZERO_ADDRESS);\r\n    return _getOwnerNFTCount(_owner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\r\n   * considered invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   * @return _owner Address of _tokenId owner.\r\n   */\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (address _owner)\r\n  {\r\n    _owner = idToOwner[_tokenId];\r\n    require(_owner != address(0), NOT_VALID_NFT);\r\n  }\r\n\r\n  /**\r\n   * @dev Get the approved address for a single NFT.\r\n   * @notice Throws if `_tokenId` is not a valid NFT.\r\n   * @param _tokenId ID of the NFT to query the approval of.\r\n   * @return Address that _tokenId is approved for.\r\n   */\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    validNFToken(_tokenId)\r\n    returns (address)\r\n  {\r\n    return idToApproval[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if `_operator` is an approved operator for `_owner`.\r\n   * @param _owner The address that owns the NFTs.\r\n   * @param _operator The address that acts on behalf of the owner.\r\n   * @return True if approved for all, false otherwise.\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return ownerToOperators[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Actually performs the transfer.\r\n   * @notice Does NO checks.\r\n   * @param _to Address of a new owner.\r\n   * @param _tokenId The NFT that is being transferred.\r\n   */\r\n  function _transfer(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    address from = idToOwner[_tokenId];\r\n    _clearApproval(_tokenId);\r\n\r\n    _removeNFToken(from, _tokenId);\r\n    _addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Mints a new NFT.\r\n   * @notice This is an internal function which should be called from user-implemented external\r\n   * mint function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _to The address that will own the minted NFT.\r\n   * @param _tokenId of the NFT to be minted by the msg.sender.\r\n   */\r\n  function _mint(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n    _addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Burns a NFT.\r\n   * @notice This is an internal function which should be called from user-implemented external burn\r\n   * function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\r\n   * NFT.\r\n   * @param _tokenId ID of the NFT to be burned.\r\n   */\r\n  function _burn(\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    _clearApproval(_tokenId);\r\n    _removeNFToken(tokenOwner, _tokenId);\r\n    emit Transfer(tokenOwner, address(0), _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a NFT from owner.\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @param _from Address from which we want to remove the NFT.\r\n   * @param _tokenId Which NFT we want to remove.\r\n   */\r\n  function _removeNFToken(\r\n    address _from,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\r\n    ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\r\n    delete idToOwner[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Assigns a new NFT to owner.\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @param _to Address to which we want to add the NFT.\r\n   * @param _tokenId Which NFT we want to add.\r\n   */\r\n  function _addNFToken(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n    idToOwner[_tokenId] = _to;\r\n    ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to] + 1;\r\n  }\r\n\r\n  /**\r\n   * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\r\n   * extension to remove double storage (gas optimization) of owner NFT count.\r\n   * @param _owner Address for whom to query the count.\r\n   * @return Number of _owner NFTs.\r\n   */\r\n  function _getOwnerNFTCount(\r\n    address _owner\r\n  )\r\n    internal\r\n    virtual\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return ownerToNFTokenCount[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Actually perform the safeTransferFrom.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function _safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes memory _data\r\n  )\r\n    private\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, NOT_OWNER);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    _transfer(_to, _tokenId);\r\n\r\n    if (_to.isContract())\r\n    {\r\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Clears the current approval of a given NFT ID.\r\n   * @param _tokenId ID of the NFT to be transferred.\r\n   */\r\n  function _clearApproval(\r\n    uint256 _tokenId\r\n  )\r\n    private\r\n  {\r\n    if (idToApproval[_tokenId] != address(0))\r\n    {\r\n      delete idToApproval[_tokenId];\r\n    }\r\n  }\r\n\r\n}\r\n"},"ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev The contract has an owner address, and provides basic authorization control whitch\r\n * simplifies the implementation of user permissions. This contract is based on the source code at:\r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\r\n */\r\ncontract Ownable\r\n{\r\n\r\n  /**\r\n   * @dev Error constants.\r\n   */\r\n  string public constant NOT_CURRENT_OWNER = \"018001\";\r\n  string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = \"018002\";\r\n\r\n  /**\r\n   * @dev Current owner address.\r\n   */\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev An event which is triggered when the owner is changed.\r\n   * @param previousOwner The address of the previous owner.\r\n   * @param newOwner The address of the new owner.\r\n   */\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The constructor sets the original `owner` of the contract to the sender account.\r\n   */\r\n  constructor()\r\n  {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner()\r\n  {\r\n    require(msg.sender == owner, NOT_CURRENT_OWNER);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(\r\n    address _newOwner\r\n  )\r\n    public\r\n    onlyOwner\r\n  {\r\n    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n\r\n}\r\n"},"supports-interface.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./erc165.sol\";\r\n\r\n/**\r\n * @dev Implementation of standard for detect smart contract interfaces.\r\n */\r\ncontract SupportsInterface is\r\n  ERC165\r\n{\r\n\r\n  /**\r\n   * @dev Mapping of supported intefraces. You must not set element 0xffffffff to true.\r\n   */\r\n  mapping(bytes4 =\u003e bool) internal supportedInterfaces;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n  {\r\n    supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check which interfaces are suported by this contract.\r\n   * @param _interfaceID Id of the interface.\r\n   * @return True if _interfaceID is supported, false otherwise.\r\n   */\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceID];\r\n  }\r\n\r\n}\r\n"}}