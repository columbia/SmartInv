{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Interface Imports */\nimport { iOVM_ECDSAContractAccount } from \"../../iOVM/accounts/iOVM_ECDSAContractAccount.sol\";\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\nimport { Lib_ECDSAUtils } from \"../../libraries/utils/Lib_ECDSAUtils.sol\";\nimport { Lib_SafeExecutionManagerWrapper } from \"../../libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\";\nimport { Lib_SafeMathWrapper } from \"../../libraries/wrappers/Lib_SafeMathWrapper.sol\";\n\n/**\n * @title OVM_ECDSAContractAccount\n * @dev The ECDSA Contract Account can be used as the implementation for a ProxyEOA deployed by the\n * ovmCREATEEOA operation. It enables backwards compatibility with Ethereum's Layer 1, by \n * providing eth_sign and EIP155 formatted transaction encodings.\n *\n * Compiler used: solc\n * Runtime target: OVM\n */\ncontract OVM_ECDSAContractAccount is iOVM_ECDSAContractAccount {\n\n    /*************\n     * Constants *\n     *************/\n\n    // TODO: should be the amount sufficient to cover the gas costs of all of the transactions up\n    // to and including the CALL/CREATE which forms the entrypoint of the transaction.\n    uint256 constant EXECUTION_VALIDATION_GAS_OVERHEAD = 25000;\n    address constant ETH_ERC20_ADDRESS = 0x4200000000000000000000000000000000000006;\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Executes a signed transaction.\n     * @param _transaction Signed EOA transaction.\n     * @param _signatureType Hashing scheme used for the transaction (e.g., ETH signed message).\n     * @param _v Signature `v` parameter.\n     * @param _r Signature `r` parameter.\n     * @param _s Signature `s` parameter.\n     * @return Whether or not the call returned (rather than reverted).\n     * @return Data returned by the call.\n     */\n    function execute(\n        bytes memory _transaction,\n        Lib_OVMCodec.EOASignatureType _signatureType,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        override\n        public\n        returns (\n            bool,\n            bytes memory\n        )\n    {\n        bool isEthSign = _signatureType == Lib_OVMCodec.EOASignatureType.ETH_SIGNED_MESSAGE;\n\n        // Address of this contract within the ovm (ovmADDRESS) should be the same as the\n        // recovered address of the user who signed this message. This is how we manage to shim\n        // account abstraction even though the user isn't a contract.\n        // Need to make sure that the transaction nonce is right and bump it if so.\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            Lib_ECDSAUtils.recover(\n                _transaction,\n                isEthSign,\n                _v,\n                _r,\n                _s\n            ) == Lib_SafeExecutionManagerWrapper.safeADDRESS(),\n            \"Signature provided for EOA transaction execution is invalid.\"\n        );\n\n        Lib_OVMCodec.EIP155Transaction memory decodedTx = Lib_OVMCodec.decodeEIP155Transaction(_transaction, isEthSign);\n\n        // Need to make sure that the transaction chainId is correct.\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            decodedTx.chainId == Lib_SafeExecutionManagerWrapper.safeCHAINID(),\n            \"Transaction chainId does not match expected OVM chainId.\"\n        );\n\n        // Need to make sure that the transaction nonce is right.\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            decodedTx.nonce == Lib_SafeExecutionManagerWrapper.safeGETNONCE(),\n            \"Transaction nonce does not match the expected nonce.\"\n        );\n\n        // TEMPORARY: Disable gas checks for mainnet.\n        // // Need to make sure that the gas is sufficient to execute the transaction.\n        // Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n        //    gasleft() >= Lib_SafeMathWrapper.add(decodedTx.gasLimit, EXECUTION_VALIDATION_GAS_OVERHEAD),\n        //    \"Gas is not sufficient to execute the transaction.\"\n        // );\n\n        // Transfer fee to relayer.\n        address relayer = Lib_SafeExecutionManagerWrapper.safeCALLER();\n        uint256 fee = Lib_SafeMathWrapper.mul(decodedTx.gasLimit, decodedTx.gasPrice);\n        (bool success, ) = Lib_SafeExecutionManagerWrapper.safeCALL(\n            gasleft(),\n            ETH_ERC20_ADDRESS,\n            abi.encodeWithSignature(\"transfer(address,uint256)\", relayer, fee)\n        );\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            success == true,\n            \"Fee was not transferred to relayer.\"\n        );\n\n        // Contract creations are signalled by sending a transaction to the zero address.\n        if (decodedTx.to == address(0)) {\n            (address created, bytes memory revertData) = Lib_SafeExecutionManagerWrapper.safeCREATE(\n                gasleft(),\n                decodedTx.data\n            );\n\n            // Return true if the contract creation succeeded, false w/ revertData otherwise.\n            if (created != address(0)) {\n                return (true, abi.encode(created));\n            } else {\n                return (false, revertData);\n            }\n        } else {\n            // We only want to bump the nonce for `ovmCALL` because `ovmCREATE` automatically bumps\n            // the nonce of the calling account. Normally an EOA would bump the nonce for both\n            // cases, but since this is a contract we'd end up bumping the nonce twice.\n            Lib_SafeExecutionManagerWrapper.safeINCREMENTNONCE();\n\n            return Lib_SafeExecutionManagerWrapper.safeCALL(\n                gasleft(),\n                decodedTx.to,\n                decodedTx.data\n            );\n        }\n    }\n}\n"
    },
    "contracts/optimistic-ethereum/OVM/accounts/OVM_ProxyEOA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/* Library Imports */\nimport { Lib_Bytes32Utils } from \"../../libraries/utils/Lib_Bytes32Utils.sol\";\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\nimport { Lib_ECDSAUtils } from \"../../libraries/utils/Lib_ECDSAUtils.sol\";\nimport { Lib_SafeExecutionManagerWrapper } from \"../../libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\";\n\n/**\n * @title OVM_ProxyEOA\n * @dev The Proxy EOA contract uses a delegate call to execute the logic in an implementation contract.\n * In combination with the logic implemented in the ECDSA Contract Account, this enables a form of upgradable \n * 'account abstraction' on layer 2. \n * \n * Compiler used: solc\n * Runtime target: OVM\n */\ncontract OVM_ProxyEOA {\n\n    /*************\n     * Constants *\n     *************/\n\n    bytes32 constant IMPLEMENTATION_KEY = 0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead;\n\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _implementation Address of the initial implementation contract.\n     */\n    constructor(\n        address _implementation\n    )\n    {\n        _setImplementation(_implementation);\n    }\n\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    fallback()\n        external\n    {\n        (bool success, bytes memory returndata) = Lib_SafeExecutionManagerWrapper.safeDELEGATECALL(\n            gasleft(),\n            getImplementation(),\n            msg.data\n        );\n\n        if (success) {\n            assembly {\n                return(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            Lib_SafeExecutionManagerWrapper.safeREVERT(\n                string(returndata)\n            );\n        }\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Changes the implementation address.\n     * @param _implementation New implementation address.\n     */\n    function upgrade(\n        address _implementation\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            Lib_SafeExecutionManagerWrapper.safeADDRESS() == Lib_SafeExecutionManagerWrapper.safeCALLER(),\n            \"EOAs can only upgrade their own EOA implementation\"\n        );\n\n        _setImplementation(_implementation);\n    }\n\n    /**\n     * Gets the address of the current implementation.\n     * @return Current implementation address.\n     */\n    function getImplementation()\n        public\n        returns (\n            address\n        )\n    {\n        return Lib_Bytes32Utils.toAddress(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                IMPLEMENTATION_KEY\n            )\n        );\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _setImplementation(\n        address _implementation\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            IMPLEMENTATION_KEY,\n            Lib_Bytes32Utils.fromAddress(_implementation)\n        );\n    }\n}\n"
    },
    "contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// @unsupported: ovm\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\nimport { Lib_MerkleTree } from \"../../libraries/utils/Lib_MerkleTree.sol\";\nimport { Lib_Math } from \"../../libraries/utils/Lib_Math.sol\";\n\n/* Interface Imports */\nimport { iOVM_CanonicalTransactionChain } from \"../../iOVM/chain/iOVM_CanonicalTransactionChain.sol\";\nimport { iOVM_ChainStorageContainer } from \"../../iOVM/chain/iOVM_ChainStorageContainer.sol\";\n\n/* Contract Imports */\nimport { OVM_ExecutionManager } from \"../execution/OVM_ExecutionManager.sol\";\n\n\n/**\n * @title OVM_CanonicalTransactionChain\n * @dev The Canonical Transaction Chain (CTC) contract is an append-only log of transactions\n * which must be applied to the rollup state. It defines the ordering of rollup transactions by\n * writing them to the 'CTC:batches' instance of the Chain Storage Container.\n * The CTC also allows any account to 'enqueue' an L2 transaction, which will require that the Sequencer\n * will eventually append it to the rollup state.\n * If the Sequencer does not include an enqueued transaction within the 'force inclusion period',\n * then any account may force it to be included by calling appendQueueBatch().\n *\n * Compiler used: solc\n * Runtime target: EVM\n */\ncontract OVM_CanonicalTransactionChain is iOVM_CanonicalTransactionChain, Lib_AddressResolver {\n\n    /*************\n     * Constants *\n     *************/\n\n    // L2 tx gas-related\n    uint256 constant public MIN_ROLLUP_TX_GAS = 100000;\n    uint256 constant public MAX_ROLLUP_TX_SIZE = 50000;\n    uint256 constant public L2_GAS_DISCOUNT_DIVISOR = 32;\n\n    // Encoding-related (all in bytes)\n    uint256 constant internal BATCH_CONTEXT_SIZE = 16;\n    uint256 constant internal BATCH_CONTEXT_LENGTH_POS = 12;\n    uint256 constant internal BATCH_CONTEXT_START_POS = 15;\n    uint256 constant internal TX_DATA_HEADER_SIZE = 3;\n    uint256 constant internal BYTES_TILL_TX_DATA = 65;\n\n\n    /*************\n     * Variables *\n     *************/\n\n    uint256 public forceInclusionPeriodSeconds;\n    uint256 public forceInclusionPeriodBlocks;\n    uint256 public maxTransactionGasLimit;\n\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _libAddressManager,\n        uint256 _forceInclusionPeriodSeconds,\n        uint256 _forceInclusionPeriodBlocks,\n        uint256 _maxTransactionGasLimit\n    )\n        Lib_AddressResolver(_libAddressManager)\n    {\n        forceInclusionPeriodSeconds = _forceInclusionPeriodSeconds;\n        forceInclusionPeriodBlocks = _forceInclusionPeriodBlocks;\n        maxTransactionGasLimit = _maxTransactionGasLimit;\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Accesses the batch storage container.\n     * @return Reference to the batch storage container.\n     */\n    function batches()\n        override\n        public\n        view\n        returns (\n            iOVM_ChainStorageContainer\n        )\n    {\n        return iOVM_ChainStorageContainer(\n            resolve(\"OVM_ChainStorageContainer:CTC:batches\")\n        );\n    }\n\n    /**\n     * Accesses the queue storage container.\n     * @return Reference to the queue storage container.\n     */\n    function queue()\n        override\n        public\n        view\n        returns (\n            iOVM_ChainStorageContainer\n        )\n    {\n        return iOVM_ChainStorageContainer(\n            resolve(\"OVM_ChainStorageContainer:CTC:queue\")\n        );\n    }\n\n    /**\n     * Retrieves the total number of elements submitted.\n     * @return _totalElements Total submitted elements.\n     */\n    function getTotalElements()\n        override\n        public\n        view\n        returns (\n            uint256 _totalElements\n        )\n    {\n        (uint40 totalElements,,,) = _getBatchExtraData();\n        return uint256(totalElements);\n    }\n\n    /**\n     * Retrieves the total number of batches submitted.\n     * @return _totalBatches Total submitted batches.\n     */\n    function getTotalBatches()\n        override\n        public\n        view\n        returns (\n            uint256 _totalBatches\n        )\n    {\n        return batches().length();\n    }\n\n    /**\n     * Returns the index of the next element to be enqueued.\n     * @return Index for the next queue element.\n     */\n    function getNextQueueIndex()\n        override\n        public\n        view\n        returns (\n            uint40\n        )\n    {\n        (,uint40 nextQueueIndex,,) = _getBatchExtraData();\n        return nextQueueIndex;\n    }\n\n    /**\n     * Returns the timestamp of the last transaction.\n     * @return Timestamp for the last transaction.\n     */\n    function getLastTimestamp()\n        override\n        public\n        view\n        returns (\n            uint40\n        )\n    {\n        (,,uint40 lastTimestamp,) = _getBatchExtraData();\n        return lastTimestamp;\n    }\n\n    /**\n     * Returns the blocknumber of the last transaction.\n     * @return Blocknumber for the last transaction.\n     */\n    function getLastBlockNumber()\n        override\n        public\n        view\n        returns (\n            uint40\n        )\n    {\n        (,,,uint40 lastBlockNumber) = _getBatchExtraData();\n        return lastBlockNumber;\n    }\n\n    /**\n     * Gets the queue element at a particular index.\n     * @param _index Index of the queue element to access.\n     * @return _element Queue element at the given index.\n     */\n    function getQueueElement(\n        uint256 _index\n    )\n        override\n        public\n        view\n        returns (\n            Lib_OVMCodec.QueueElement memory _element\n        )\n    {\n        return _getQueueElement(\n            _index,\n            queue()\n        );\n    }\n\n    /**\n     * Get the number of queue elements which have not yet been included.\n     * @return Number of pending queue elements.\n     */\n    function getNumPendingQueueElements()\n        override\n        public\n        view\n        returns (\n            uint40\n        )\n    {\n        return getQueueLength() - getNextQueueIndex();\n    }\n\n   /**\n     * Retrieves the length of the queue, including\n     * both pending and canonical transactions.\n     * @return Length of the queue.\n     */\n    function getQueueLength()\n        override\n        public\n        view\n        returns (\n            uint40\n        )\n    {\n        return _getQueueLength(\n            queue()\n        );\n    }\n\n    /**\n     * Adds a transaction to the queue.\n     * @param _target Target L2 contract to send the transaction to.\n     * @param _gasLimit Gas limit for the enqueued L2 transaction.\n     * @param _data Transaction data.\n     */\n    function enqueue(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    )\n        override\n        public\n    {\n        require(\n            _data.length <= MAX_ROLLUP_TX_SIZE,\n            \"Transaction data size exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit <= maxTransactionGasLimit,\n            \"Transaction gas limit exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit >= MIN_ROLLUP_TX_GAS,\n            \"Transaction gas limit too low to enqueue.\"\n        );\n\n        // We need to consume some amount of L1 gas in order to rate limit transactions going into\n        // L2. However, L2 is cheaper than L1 so we only need to burn some small proportion of the\n        // provided L1 gas.\n        uint256 gasToConsume = _gasLimit/L2_GAS_DISCOUNT_DIVISOR;\n        uint256 startingGas = gasleft();\n\n        // Although this check is not necessary (burn below will run out of gas if not true), it\n        // gives the user an explicit reason as to why the enqueue attempt failed.\n        require(\n            startingGas > gasToConsume,\n            \"Insufficient gas for L2 rate limiting burn.\"\n        );\n\n        // Here we do some \"dumb\" work in order to burn gas, although we should probably replace\n        // this with something like minting gas token later on.\n        uint256 i;\n        while(startingGas - gasleft() < gasToConsume) {\n            i++;\n        }\n\n        bytes32 transactionHash = keccak256(\n            abi.encode(\n                msg.sender,\n                _target,\n                _gasLimit,\n                _data\n            )\n        );\n\n        bytes32 timestampAndBlockNumber;\n        assembly {\n            timestampAndBlockNumber := timestamp()\n            timestampAndBlockNumber := or(timestampAndBlockNumber, shl(40, number()))\n        }\n\n        iOVM_ChainStorageContainer queueRef = queue();\n\n        queueRef.push(transactionHash);\n        queueRef.push(timestampAndBlockNumber);\n\n        // The underlying queue data structure stores 2 elements\n        // per insertion, so to get the real queue length we need\n        // to divide by 2 and subtract 1.\n        uint256 queueIndex = queueRef.length() / 2 - 1;\n        emit TransactionEnqueued(\n            msg.sender,\n            _target,\n            _gasLimit,\n            _data,\n            queueIndex,\n            block.timestamp\n        );\n    }\n\n    /**\n     * Appends a given number of queued transactions as a single batch.\n     * param _numQueuedTransactions Number of transactions to append.\n     */\n    function appendQueueBatch(\n        uint256 // _numQueuedTransactions\n    )\n        override\n        public\n        pure\n    {\n        // TEMPORARY: Disable `appendQueueBatch` for minnet\n        revert(\"appendQueueBatch is currently disabled.\");\n\n        // _numQueuedTransactions = Lib_Math.min(_numQueuedTransactions, getNumPendingQueueElements());\n        // require(\n        //     _numQueuedTransactions > 0,\n        //     \"Must append more than zero transactions.\"\n        // );\n\n        // bytes32[] memory leaves = new bytes32[](_numQueuedTransactions);\n        // uint40 nextQueueIndex = getNextQueueIndex();\n\n        // for (uint256 i = 0; i < _numQueuedTransactions; i++) {\n        //     if (msg.sender != resolve(\"OVM_Sequencer\")) {\n        //         Lib_OVMCodec.QueueElement memory el = getQueueElement(nextQueueIndex);\n        //         require(\n        //             el.timestamp + forceInclusionPeriodSeconds < block.timestamp,\n        //             \"Queue transactions cannot be submitted during the sequencer inclusion period.\"\n        //         );\n        //     }\n        //     leaves[i] = _getQueueLeafHash(nextQueueIndex);\n        //     nextQueueIndex++;\n        // }\n\n        // Lib_OVMCodec.QueueElement memory lastElement = getQueueElement(nextQueueIndex - 1);\n\n        // _appendBatch(\n        //     Lib_MerkleTree.getMerkleRoot(leaves),\n        //     _numQueuedTransactions,\n        //     _numQueuedTransactions,\n        //     lastElement.timestamp,\n        //     lastElement.blockNumber\n        // );\n\n        // emit QueueBatchAppended(\n        //     nextQueueIndex - _numQueuedTransactions,\n        //     _numQueuedTransactions,\n        //     getTotalElements()\n        // );\n    }\n\n    /**\n     * Allows the sequencer to append a batch of transactions.\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\n     * .param _contexts Array of batch contexts.\n     * .param _transactionDataFields Array of raw transaction data.\n     */\n    function appendSequencerBatch()\n        override\n        public\n    {\n        uint40 shouldStartAtElement;\n        uint24 totalElementsToAppend;\n        uint24 numContexts;\n        assembly {\n            shouldStartAtElement  := shr(216, calldataload(4))\n            totalElementsToAppend := shr(232, calldataload(9))\n            numContexts           := shr(232, calldataload(12))\n        }\n\n        require(\n            shouldStartAtElement == getTotalElements(),\n            \"Actual batch start index does not match expected start index.\"\n        );\n\n        require(\n            msg.sender == resolve(\"OVM_Sequencer\"),\n            \"Function can only be called by the Sequencer.\"\n        );\n\n        require(\n            numContexts > 0,\n            \"Must provide at least one batch context.\"\n        );\n\n        require(\n            totalElementsToAppend > 0,\n            \"Must append at least one element.\"\n        );\n\n        uint40 nextTransactionPtr = uint40(BATCH_CONTEXT_START_POS + BATCH_CONTEXT_SIZE * numContexts);\n\n        require(\n            msg.data.length >= nextTransactionPtr,\n            \"Not enough BatchContexts provided.\"\n        );\n\n        // Take a reference to the queue and its length so we don't have to keep resolving it.\n        // Length isn't going to change during the course of execution, so it's fine to simply\n        // resolve this once at the start. Saves gas.\n        iOVM_ChainStorageContainer queueRef = queue();\n        uint40 queueLength = _getQueueLength(queueRef);\n\n        // Reserve some memory to save gas on hashing later on. This is a relatively safe estimate\n        // for the average transaction size that will prevent having to resize this chunk of memory\n        // later on. Saves gas.\n        bytes memory hashMemory = new bytes((msg.data.length / totalElementsToAppend) * 2);\n\n        // Initialize the array of canonical chain leaves that we will append.\n        bytes32[] memory leaves = new bytes32[](totalElementsToAppend);\n\n        // Each leaf index corresponds to a tx, either sequenced or enqueued.\n        uint32 leafIndex = 0;\n\n        // Counter for number of sequencer transactions appended so far.\n        uint32 numSequencerTransactions = 0;\n\n        // We will sequentially append leaves which are pointers to the queue.\n        // The initial queue index is what is currently in storage.\n        uint40 nextQueueIndex = getNextQueueIndex();\n\n        BatchContext memory curContext;\n        for (uint32 i = 0; i < numContexts; i++) {\n            BatchContext memory nextContext = _getBatchContext(i);\n\n            if (i == 0) {\n                // Execute a special check for the first batch.\n                _validateFirstBatchContext(nextContext);\n            }\n\n            // Execute this check on every single batch, including the first one.\n            _validateNextBatchContext(\n                curContext,\n                nextContext,\n                nextQueueIndex,\n                queueRef\n            );\n\n            // Now we can update our current context.\n            curContext = nextContext;\n\n            // Process sequencer transactions first.\n            for (uint32 j = 0; j < curContext.numSequencedTransactions; j++) {\n                uint256 txDataLength;\n                assembly {\n                    txDataLength := shr(232, calldataload(nextTransactionPtr))\n                }\n                require(\n                    txDataLength <= MAX_ROLLUP_TX_SIZE,\n                    \"Transaction data size exceeds maximum for rollup transaction.\"\n                );\n\n                leaves[leafIndex] = _getSequencerLeafHash(\n                    curContext,\n                    nextTransactionPtr,\n                    txDataLength,\n                    hashMemory\n                );\n\n                nextTransactionPtr += uint40(TX_DATA_HEADER_SIZE + txDataLength);\n                numSequencerTransactions++;\n                leafIndex++;\n            }\n\n            // Now process any subsequent queue transactions.\n            for (uint32 j = 0; j < curContext.numSubsequentQueueTransactions; j++) {\n                require(\n                    nextQueueIndex < queueLength,\n                    \"Not enough queued transactions to append.\"\n                );\n\n                leaves[leafIndex] = _getQueueLeafHash(nextQueueIndex);\n                nextQueueIndex++;\n                leafIndex++;\n            }\n        }\n\n        _validateFinalBatchContext(\n            curContext,\n            nextQueueIndex,\n            queueLength,\n            queueRef\n        );\n\n        require(\n            msg.data.length == nextTransactionPtr,\n            \"Not all sequencer transactions were processed.\"\n        );\n\n        require(\n            leafIndex == totalElementsToAppend,\n            \"Actual transaction index does not match expected total elements to append.\"\n        );\n\n        // Generate the required metadata that we need to append this batch\n        uint40 numQueuedTransactions = totalElementsToAppend - numSequencerTransactions;\n        uint40 blockTimestamp;\n        uint40 blockNumber;\n        if (curContext.numSubsequentQueueTransactions == 0) {\n            // The last element is a sequencer tx, therefore pull timestamp and block number from the last context.\n            blockTimestamp = uint40(curContext.timestamp);\n            blockNumber = uint40(curContext.blockNumber);\n        } else {\n            // The last element is a queue tx, therefore pull timestamp and block number from the queue element.\n            // curContext.numSubsequentQueueTransactions > 0 which means that we've processed at least one queue element.\n            // We increment nextQueueIndex after processing each queue element,\n            // so the index of the last element we processed is nextQueueIndex - 1.\n            Lib_OVMCodec.QueueElement memory lastElement = _getQueueElement(\n                nextQueueIndex - 1,\n                queueRef\n            );\n\n            blockTimestamp = lastElement.timestamp;\n            blockNumber = lastElement.blockNumber;\n        }\n\n        // For efficiency reasons getMerkleRoot modifies the `leaves` argument in place\n        // while calculating the root hash therefore any arguments passed to it must not\n        // be used again afterwards\n        _appendBatch(\n            Lib_MerkleTree.getMerkleRoot(leaves),\n            totalElementsToAppend,\n            numQueuedTransactions,\n            blockTimestamp,\n            blockNumber\n        );\n\n        emit SequencerBatchAppended(\n            nextQueueIndex - numQueuedTransactions,\n            numQueuedTransactions,\n            getTotalElements()\n        );\n    }\n\n    /**\n     * Verifies whether a transaction is included in the chain.\n     * @param _transaction Transaction to verify.\n     * @param _txChainElement Transaction chain element corresponding to the transaction.\n     * @param _batchHeader Header of the batch the transaction was included in.\n     * @param _inclusionProof Inclusion proof for the provided transaction chain element.\n     * @return True if the transaction exists in the CTC, false if not.\n     */\n    function verifyTransaction(\n        Lib_OVMCodec.Transaction memory _transaction,\n        Lib_OVMCodec.TransactionChainElement memory _txChainElement,\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _inclusionProof\n    )\n        override\n        public\n        view\n        returns (\n            bool\n        )\n    {\n        if (_txChainElement.isSequenced == true) {\n            return _verifySequencerTransaction(\n                _transaction,\n                _txChainElement,\n                _batchHeader,\n                _inclusionProof\n            );\n        } else {\n            return _verifyQueueTransaction(\n                _transaction,\n                _txChainElement.queueIndex,\n                _batchHeader,\n                _inclusionProof\n            );\n        }\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Returns the BatchContext located at a particular index.\n     * @param _index The index of the BatchContext\n     * @return The BatchContext at the specified index.\n     */\n    function _getBatchContext(\n        uint256 _index\n    )\n        internal\n        pure\n        returns (\n            BatchContext memory\n        )\n    {\n        uint256 contextPtr = 15 + _index * BATCH_CONTEXT_SIZE;\n        uint256 numSequencedTransactions;\n        uint256 numSubsequentQueueTransactions;\n        uint256 ctxTimestamp;\n        uint256 ctxBlockNumber;\n\n        assembly {\n            numSequencedTransactions       := shr(232, calldataload(contextPtr))\n            numSubsequentQueueTransactions := shr(232, calldataload(add(contextPtr, 3)))\n            ctxTimestamp                   := shr(216, calldataload(add(contextPtr, 6)))\n            ctxBlockNumber                 := shr(216, calldataload(add(contextPtr, 11)))\n        }\n\n        return BatchContext({\n            numSequencedTransactions: numSequencedTransactions,\n            numSubsequentQueueTransactions: numSubsequentQueueTransactions,\n            timestamp: ctxTimestamp,\n            blockNumber: ctxBlockNumber\n        });\n    }\n\n    /**\n     * Parses the batch context from the extra data.\n     * @return Total number of elements submitted.\n     * @return Index of the next queue element.\n     */\n    function _getBatchExtraData()\n        internal\n        view\n        returns (\n            uint40,\n            uint40,\n            uint40,\n            uint40\n        )\n    {\n        bytes27 extraData = batches().getGlobalMetadata();\n\n        uint40 totalElements;\n        uint40 nextQueueIndex;\n        uint40 lastTimestamp;\n        uint40 lastBlockNumber;\n        assembly {\n            extraData       :=  shr(40, extraData)\n            totalElements   :=  and(extraData, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)\n            nextQueueIndex  :=  shr(40, and(extraData, 0x00000000000000000000000000000000000000000000FFFFFFFFFF0000000000))\n            lastTimestamp   :=  shr(80, and(extraData, 0x0000000000000000000000000000000000FFFFFFFFFF00000000000000000000))\n            lastBlockNumber :=  shr(120, and(extraData, 0x000000000000000000000000FFFFFFFFFF000000000000000000000000000000))\n        }\n\n        return (\n            totalElements,\n            nextQueueIndex,\n            lastTimestamp,\n            lastBlockNumber\n        );\n    }\n\n    /**\n     * Encodes the batch context for the extra data.\n     * @param _totalElements Total number of elements submitted.\n     * @param _nextQueueIndex Index of the next queue element.\n     * @param _timestamp Timestamp for the last batch.\n     * @param _blockNumber Block number of the last batch.\n     * @return Encoded batch context.\n     */\n    function _makeBatchExtraData(\n        uint40 _totalElements,\n        uint40 _nextQueueIndex,\n        uint40 _timestamp,\n        uint40 _blockNumber\n    )\n        internal\n        pure\n        returns (\n            bytes27\n        )\n    {\n        bytes27 extraData;\n        assembly {\n            extraData := _totalElements\n            extraData := or(extraData, shl(40, _nextQueueIndex))\n            extraData := or(extraData, shl(80, _timestamp))\n            extraData := or(extraData, shl(120, _blockNumber))\n            extraData := shl(40, extraData)\n        }\n\n        return extraData;\n    }\n\n    /**\n     * Retrieves the hash of a queue element.\n     * @param _index Index of the queue element to retrieve a hash for.\n     * @return Hash of the queue element.\n     */\n    function _getQueueLeafHash(\n        uint256 _index\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return _hashTransactionChainElement(\n            Lib_OVMCodec.TransactionChainElement({\n                isSequenced: false,\n                queueIndex: _index,\n                timestamp: 0,\n                blockNumber: 0,\n                txData: hex\"\"\n            })\n        );\n    }\n\n    /**\n     * Gets the queue element at a particular index.\n     * @param _index Index of the queue element to access.\n     * @return _element Queue element at the given index.\n     */\n    function _getQueueElement(\n        uint256 _index,\n        iOVM_ChainStorageContainer _queueRef\n    )\n        internal\n        view\n        returns (\n            Lib_OVMCodec.QueueElement memory _element\n        )\n    {\n        // The underlying queue data structure stores 2 elements\n        // per insertion, so to get the actual desired queue index\n        // we need to multiply by 2.\n        uint40 trueIndex = uint40(_index * 2);\n        bytes32 transactionHash = _queueRef.get(trueIndex);\n        bytes32 timestampAndBlockNumber = _queueRef.get(trueIndex + 1);\n\n        uint40 elementTimestamp;\n        uint40 elementBlockNumber;\n        assembly {\n            elementTimestamp   :=         and(timestampAndBlockNumber, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)\n            elementBlockNumber := shr(40, and(timestampAndBlockNumber, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000))\n        }\n\n        return Lib_OVMCodec.QueueElement({\n            transactionHash: transactionHash,\n            timestamp: elementTimestamp,\n            blockNumber: elementBlockNumber\n        });\n    }\n\n    /**\n     * Retrieves the length of the queue.\n     * @return Length of the queue.\n     */\n    function _getQueueLength(\n        iOVM_ChainStorageContainer _queueRef\n    )\n        internal\n        view\n        returns (\n            uint40\n        )\n    {\n        // The underlying queue data structure stores 2 elements\n        // per insertion, so to get the real queue length we need\n        // to divide by 2.\n        return uint40(_queueRef.length() / 2);\n    }\n\n    /**\n     * Retrieves the hash of a sequencer element.\n     * @param _context Batch context for the given element.\n     * @param _nextTransactionPtr Pointer to the next transaction in the calldata.\n     * @param _txDataLength Length of the transaction item.\n     * @return Hash of the sequencer element.\n     */\n    function _getSequencerLeafHash(\n        BatchContext memory _context,\n        uint256 _nextTransactionPtr,\n        uint256 _txDataLength,\n        bytes memory _hashMemory\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        // Only allocate more memory if we didn't reserve enough to begin with.\n        if (BYTES_TILL_TX_DATA + _txDataLength > _hashMemory.length) {\n            _hashMemory = new bytes(BYTES_TILL_TX_DATA + _txDataLength);\n        }\n\n        uint256 ctxTimestamp = _context.timestamp;\n        uint256 ctxBlockNumber = _context.blockNumber;\n\n        bytes32 leafHash;\n        assembly {\n            let chainElementStart := add(_hashMemory, 0x20)\n\n            // Set the first byte equal to `1` to indicate this is a sequencer chain element.\n            // This distinguishes sequencer ChainElements from queue ChainElements because\n            // all queue ChainElements are ABI encoded and the first byte of ABI encoded\n            // elements is always zero\n            mstore8(chainElementStart, 1)\n\n            mstore(add(chainElementStart, 1), ctxTimestamp)\n            mstore(add(chainElementStart, 33), ctxBlockNumber)\n\n            calldatacopy(add(chainElementStart, BYTES_TILL_TX_DATA), add(_nextTransactionPtr, 3), _txDataLength)\n\n            leafHash := keccak256(chainElementStart, add(BYTES_TILL_TX_DATA, _txDataLength))\n        }\n\n        return leafHash;\n    }\n\n    /**\n     * Retrieves the hash of a sequencer element.\n     * @param _txChainElement The chain element which is hashed to calculate the leaf.\n     * @return Hash of the sequencer element.\n     */\n    function _getSequencerLeafHash(\n        Lib_OVMCodec.TransactionChainElement memory _txChainElement\n    )\n        internal\n        view\n        returns(\n            bytes32\n        )\n    {\n        bytes memory txData = _txChainElement.txData;\n        uint256 txDataLength = _txChainElement.txData.length;\n\n        bytes memory chainElement = new bytes(BYTES_TILL_TX_DATA + txDataLength);\n        uint256 ctxTimestamp = _txChainElement.timestamp;\n        uint256 ctxBlockNumber = _txChainElement.blockNumber;\n\n        bytes32 leafHash;\n        assembly {\n            let chainElementStart := add(chainElement, 0x20)\n\n            // Set the first byte equal to `1` to indicate this is a sequencer chain element.\n            // This distinguishes sequencer ChainElements from queue ChainElements because\n            // all queue ChainElements are ABI encoded and the first byte of ABI encoded\n            // elements is always zero\n            mstore8(chainElementStart, 1)\n\n            mstore(add(chainElementStart, 1), ctxTimestamp)\n            mstore(add(chainElementStart, 33), ctxBlockNumber)\n\n            pop(staticcall(gas(), 0x04, add(txData, 0x20), txDataLength, add(chainElementStart, BYTES_TILL_TX_DATA), txDataLength))\n\n            leafHash := keccak256(chainElementStart, add(BYTES_TILL_TX_DATA, txDataLength))\n        }\n\n        return leafHash;\n    }\n\n    /**\n     * Inserts a batch into the chain of batches.\n     * @param _transactionRoot Root of the transaction tree for this batch.\n     * @param _batchSize Number of elements in the batch.\n     * @param _numQueuedTransactions Number of queue transactions in the batch.\n     * @param _timestamp The latest batch timestamp.\n     * @param _blockNumber The latest batch blockNumber.\n     */\n    function _appendBatch(\n        bytes32 _transactionRoot,\n        uint256 _batchSize,\n        uint256 _numQueuedTransactions,\n        uint40 _timestamp,\n        uint40 _blockNumber\n    )\n        internal\n    {\n        iOVM_ChainStorageContainer batchesRef = batches();\n        (uint40 totalElements, uint40 nextQueueIndex,,) = _getBatchExtraData();\n\n        Lib_OVMCodec.ChainBatchHeader memory header = Lib_OVMCodec.ChainBatchHeader({\n            batchIndex: batchesRef.length(),\n            batchRoot: _transactionRoot,\n            batchSize: _batchSize,\n            prevTotalElements: totalElements,\n            extraData: hex\"\"\n        });\n\n        emit TransactionBatchAppended(\n            header.batchIndex,\n            header.batchRoot,\n            header.batchSize,\n            header.prevTotalElements,\n            header.extraData\n        );\n\n        bytes32 batchHeaderHash = Lib_OVMCodec.hashBatchHeader(header);\n        bytes27 latestBatchContext = _makeBatchExtraData(\n            totalElements + uint40(header.batchSize),\n            nextQueueIndex + uint40(_numQueuedTransactions),\n            _timestamp,\n            _blockNumber\n        );\n\n        batchesRef.push(batchHeaderHash, latestBatchContext);\n    }\n\n    /**\n     * Checks that the first batch context in a sequencer submission is valid\n     * @param _firstContext The batch context to validate.\n     */\n    function _validateFirstBatchContext(\n        BatchContext memory _firstContext\n    )\n        internal\n        view\n    {\n        // If there are existing elements, this batch must have the same context\n        // or a later timestamp and block number.\n        if (getTotalElements() > 0) {\n            (,, uint40 lastTimestamp, uint40 lastBlockNumber) = _getBatchExtraData();\n\n            require(\n                _firstContext.blockNumber >= lastBlockNumber,\n                \"Context block number is lower than last submitted.\"\n            );\n\n            require(\n                _firstContext.timestamp >= lastTimestamp,\n                \"Context timestamp is lower than last submitted.\"\n            );\n        }\n\n        // Sequencer cannot submit contexts which are more than the force inclusion period old.\n        require(\n            _firstContext.timestamp + forceInclusionPeriodSeconds >= block.timestamp,\n            \"Context timestamp too far in the past.\"\n        );\n\n        require(\n            _firstContext.blockNumber + forceInclusionPeriodBlocks >= block.number,\n            \"Context block number too far in the past.\"\n        );\n    }\n\n    /**\n     * Checks that a given batch context has a time context which is below a given que element\n     * @param _context The batch context to validate has values lower.\n     * @param _queueIndex Index of the queue element we are validating came later than the context.\n     * @param _queueRef The storage container for the queue.\n     */\n    function _validateContextBeforeEnqueue(\n        BatchContext memory _context,\n        uint40 _queueIndex,\n        iOVM_ChainStorageContainer _queueRef\n    )\n        internal\n        view\n    {\n            Lib_OVMCodec.QueueElement memory nextQueueElement = _getQueueElement(\n                _queueIndex,\n                _queueRef\n            );\n\n            // If the force inclusion period has passed for an enqueued transaction, it MUST be the next chain element.\n            require(\n                block.timestamp < nextQueueElement.timestamp + forceInclusionPeriodSeconds,\n                \"Previously enqueued batches have expired and must be appended before a new sequencer batch.\"\n            );\n\n            // Just like sequencer transaction times must be increasing relative to each other,\n            // We also require that they be increasing relative to any interspersed queue elements.\n            require(\n                _context.timestamp <= nextQueueElement.timestamp,\n                \"Sequencer transaction timestamp exceeds that of next queue element.\"\n            );\n\n            require(\n                _context.blockNumber <= nextQueueElement.blockNumber,\n                \"Sequencer transaction blockNumber exceeds that of next queue element.\"\n            );\n    }\n\n    /**\n     * Checks that a given batch context is valid based on its previous context, and the next queue elemtent.\n     * @param _prevContext The previously validated batch context.\n     * @param _nextContext The batch context to validate with this call.\n     * @param _nextQueueIndex Index of the next queue element to process for the _nextContext's subsequentQueueElements.\n     * @param _queueRef The storage container for the queue.\n     */\n    function _validateNextBatchContext(\n        BatchContext memory _prevContext,\n        BatchContext memory _nextContext,\n        uint40 _nextQueueIndex,\n        iOVM_ChainStorageContainer _queueRef\n    )\n        internal\n        view\n    {\n        // All sequencer transactions' times must be greater than or equal to the previous ones.\n        require(\n            _nextContext.timestamp >= _prevContext.timestamp,\n            \"Context timestamp values must monotonically increase.\"\n        );\n\n        require(\n            _nextContext.blockNumber >= _prevContext.blockNumber,\n            \"Context blockNumber values must monotonically increase.\"\n        );\n\n        // If there is going to be a queue element pulled in from this context:\n        if (_nextContext.numSubsequentQueueTransactions > 0) {\n            _validateContextBeforeEnqueue(\n                _nextContext,\n                _nextQueueIndex,\n                _queueRef\n            );\n        }\n    }\n\n    /**\n     * Checks that the final batch context in a sequencer submission is valid.\n     * @param _finalContext The batch context to validate.\n     * @param _queueLength The length of the queue at the start of the batchAppend call.\n     * @param _nextQueueIndex The next element in the queue that will be pulled into the CTC.\n     * @param _queueRef The storage container for the queue.\n     */\n    function _validateFinalBatchContext(\n        BatchContext memory _finalContext,\n        uint40 _nextQueueIndex,\n        uint40 _queueLength,\n        iOVM_ChainStorageContainer _queueRef\n    )\n        internal\n        view\n    {\n        // If the queue is not now empty, check the mononoticity of whatever the next batch that will come in is.\n        if (_queueLength - _nextQueueIndex > 0 && _finalContext.numSubsequentQueueTransactions == 0) {\n            _validateContextBeforeEnqueue(\n                _finalContext,\n                _nextQueueIndex,\n                _queueRef\n            );\n        }\n        // Batches cannot be added from the future, or subsequent enqueue() contexts would violate monotonicity.\n        require(_finalContext.timestamp <= block.timestamp, \"Context timestamp is from the future.\");\n        require(_finalContext.blockNumber <= block.number, \"Context block number is from the future.\");\n    }\n\n    /**\n     * Hashes a transaction chain element.\n     * @param _element Chain element to hash.\n     * @return Hash of the chain element.\n     */\n    function _hashTransactionChainElement(\n        Lib_OVMCodec.TransactionChainElement memory _element\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return keccak256(\n            abi.encode(\n                _element.isSequenced,\n                _element.queueIndex,\n                _element.timestamp,\n                _element.blockNumber,\n                _element.txData\n            )\n        );\n    }\n\n    /**\n     * Verifies a sequencer transaction, returning true if it was indeed included in the CTC\n     * @param _transaction The transaction we are verifying inclusion of.\n     * @param _txChainElement The chain element that the transaction is claimed to be a part of.\n     * @param _batchHeader Header of the batch the transaction was included in.\n     * @param _inclusionProof An inclusion proof into the CTC at a particular index.\n     * @return True if the transaction was included in the specified location, else false.\n     */\n    function _verifySequencerTransaction(\n        Lib_OVMCodec.Transaction memory _transaction,\n        Lib_OVMCodec.TransactionChainElement memory _txChainElement,\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _inclusionProof\n    )\n        internal\n        view\n        returns (\n            bool\n        )\n    {\n        OVM_ExecutionManager ovmExecutionManager = OVM_ExecutionManager(resolve(\"OVM_ExecutionManager\"));\n        uint256 gasLimit = ovmExecutionManager.getMaxTransactionGasLimit();\n        bytes32 leafHash = _getSequencerLeafHash(_txChainElement);\n\n        require(\n            _verifyElement(\n                leafHash,\n                _batchHeader,\n                _inclusionProof\n            ),\n            \"Invalid Sequencer transaction inclusion proof.\"\n        );\n\n        require(\n            _transaction.blockNumber        == _txChainElement.blockNumber\n            && _transaction.timestamp       == _txChainElement.timestamp\n            && _transaction.entrypoint      == resolve(\"OVM_DecompressionPrecompileAddress\")\n            && _transaction.gasLimit        == gasLimit\n            && _transaction.l1TxOrigin      == address(0)\n            && _transaction.l1QueueOrigin   == Lib_OVMCodec.QueueOrigin.SEQUENCER_QUEUE\n            && keccak256(_transaction.data) == keccak256(_txChainElement.txData),\n            \"Invalid Sequencer transaction.\"\n        );\n\n        return true;\n    }\n\n    /**\n     * Verifies a queue transaction, returning true if it was indeed included in the CTC\n     * @param _transaction The transaction we are verifying inclusion of.\n     * @param _queueIndex The queueIndex of the queued transaction.\n     * @param _batchHeader Header of the batch the transaction was included in.\n     * @param _inclusionProof An inclusion proof into the CTC at a particular index (should point to queue tx).\n     * @return True if the transaction was included in the specified location, else false.\n     */\n    function _verifyQueueTransaction(\n        Lib_OVMCodec.Transaction memory _transaction,\n        uint256 _queueIndex,\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _inclusionProof\n    )\n        internal\n        view\n        returns (\n            bool\n        )\n    {\n        bytes32 leafHash = _getQueueLeafHash(_queueIndex);\n\n        require(\n            _verifyElement(\n                leafHash,\n                _batchHeader,\n                _inclusionProof\n            ),\n            \"Invalid Queue transaction inclusion proof.\"\n        );\n\n        bytes32 transactionHash = keccak256(\n            abi.encode(\n                _transaction.l1TxOrigin,\n                _transaction.entrypoint,\n                _transaction.gasLimit,\n                _transaction.data\n            )\n        );\n\n        Lib_OVMCodec.QueueElement memory el = getQueueElement(_queueIndex);\n        require(\n            el.transactionHash      == transactionHash\n            && el.timestamp   == _transaction.timestamp\n            && el.blockNumber == _transaction.blockNumber,\n            \"Invalid Queue transaction.\"\n        );\n\n        return true;\n    }\n\n    /**\n     * Verifies a batch inclusion proof.\n     * @param _element Hash of the element to verify a proof for.\n     * @param _batchHeader Header of the batch in which the element was included.\n     * @param _proof Merkle inclusion proof for the element.\n     */\n    function _verifyElement(\n        bytes32 _element,\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _proof\n    )\n        internal\n        view\n        returns (\n            bool\n        )\n    {\n        require(\n            Lib_OVMCodec.hashBatchHeader(_batchHeader) == batches().get(uint32(_batchHeader.batchIndex)),\n            \"Invalid batch header.\"\n        );\n\n        require(\n            Lib_MerkleTree.verify(\n                _batchHeader.batchRoot,\n                _element,\n                _proof.index,\n                _proof.siblings,\n                _batchHeader.batchSize\n            ),\n            \"Invalid inclusion proof.\"\n        );\n\n        return true;\n    }\n}\n"
    },
    "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// @unsupported: ovm\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\nimport { Lib_EthUtils } from \"../../libraries/utils/Lib_EthUtils.sol\";\nimport { Lib_ErrorUtils } from \"../../libraries/utils/Lib_ErrorUtils.sol\";\n\n/* Interface Imports */\nimport { iOVM_ExecutionManager } from \"../../iOVM/execution/iOVM_ExecutionManager.sol\";\nimport { iOVM_StateManager } from \"../../iOVM/execution/iOVM_StateManager.sol\";\nimport { iOVM_SafetyChecker } from \"../../iOVM/execution/iOVM_SafetyChecker.sol\";\n\n/* Contract Imports */\nimport { OVM_ECDSAContractAccount } from \"../accounts/OVM_ECDSAContractAccount.sol\";\nimport { OVM_ProxyEOA } from \"../accounts/OVM_ProxyEOA.sol\";\nimport { OVM_DeployerWhitelist } from \"../predeploys/OVM_DeployerWhitelist.sol\";\n\n/**\n * @title OVM_ExecutionManager\n * @dev The Execution Manager (EM) is the core of our OVM implementation, and provides a sandboxed\n * environment allowing us to execute OVM transactions deterministically on either Layer 1 or\n * Layer 2.\n * The EM's run() function is the first function called during the execution of any\n * transaction on L2.\n * For each context-dependent EVM operation the EM has a function which implements a corresponding\n * OVM operation, which will read state from the State Manager contract.\n * The EM relies on the Safety Checker to verify that code deployed to Layer 2 does not contain any\n * context-dependent operations.\n *\n * Compiler used: solc\n * Runtime target: EVM\n */\ncontract OVM_ExecutionManager is iOVM_ExecutionManager, Lib_AddressResolver {\n\n    /********************************\n     * External Contract References *\n     ********************************/\n\n    iOVM_SafetyChecker internal ovmSafetyChecker;\n    iOVM_StateManager internal ovmStateManager;\n\n\n    /*******************************\n     * Execution Context Variables *\n     *******************************/\n\n    GasMeterConfig internal gasMeterConfig;\n    GlobalContext internal globalContext;\n    TransactionContext internal transactionContext;\n    MessageContext internal messageContext;\n    TransactionRecord internal transactionRecord;\n    MessageRecord internal messageRecord;\n\n\n    /**************************\n     * Gas Metering Constants *\n     **************************/\n\n    address constant GAS_METADATA_ADDRESS = 0x06a506A506a506A506a506a506A506A506A506A5;\n    uint256 constant NUISANCE_GAS_SLOAD = 20000;\n    uint256 constant NUISANCE_GAS_SSTORE = 20000;\n    uint256 constant MIN_NUISANCE_GAS_PER_CONTRACT = 30000;\n    uint256 constant NUISANCE_GAS_PER_CONTRACT_BYTE = 100;\n    uint256 constant MIN_GAS_FOR_INVALID_STATE_ACCESS = 30000;\n\n    /**************************\n     * Default Context Values *\n     **************************/\n\n    uint256 constant DEFAULT_UINT256 = 0xdefa017defa017defa017defa017defa017defa017defa017defa017defa017d;\n    address constant DEFAULT_ADDRESS = 0xdEfa017defA017DeFA017DEfa017DeFA017DeFa0;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Address Manager.\n     */\n    constructor(\n        address _libAddressManager,\n        GasMeterConfig memory _gasMeterConfig,\n        GlobalContext memory _globalContext\n    )\n        Lib_AddressResolver(_libAddressManager)\n    {\n        ovmSafetyChecker = iOVM_SafetyChecker(resolve(\"OVM_SafetyChecker\"));\n        gasMeterConfig = _gasMeterConfig;\n        globalContext = _globalContext;\n        _resetContext();\n    }\n\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Applies dynamically-sized refund to a transaction to account for the difference in execution\n     * between L1 and L2, so that the overall cost of the ovmOPCODE is fixed.\n     * @param _cost Desired gas cost for the function after the refund.\n     */\n    modifier netGasCost(\n        uint256 _cost\n    ) {\n        uint256 gasProvided = gasleft();\n        _;\n        uint256 gasUsed = gasProvided - gasleft();\n\n        // We want to refund everything *except* the specified cost.\n        if (_cost < gasUsed) {\n            transactionRecord.ovmGasRefund += gasUsed - _cost;\n        }\n    }\n\n    /**\n     * Applies a fixed-size gas refund to a transaction to account for the difference in execution\n     * between L1 and L2, so that the overall cost of an ovmOPCODE can be lowered.\n     * @param _discount Amount of gas cost to refund for the ovmOPCODE.\n     */\n    modifier fixedGasDiscount(\n        uint256 _discount\n    ) {\n        uint256 gasProvided = gasleft();\n        _;\n        uint256 gasUsed = gasProvided - gasleft();\n\n        // We want to refund the specified _discount, unless this risks underflow.\n        if (_discount < gasUsed) {\n            transactionRecord.ovmGasRefund += _discount;\n        } else {\n            // refund all we can without risking underflow.\n            transactionRecord.ovmGasRefund += gasUsed;\n        }\n    }\n\n    /**\n     * Makes sure we're not inside a static context.\n     */\n    modifier notStatic() {\n        if (messageContext.isStatic == true) {\n            _revertWithFlag(RevertFlag.STATIC_VIOLATION);\n        }\n        _;\n    }\n\n\n    /************************************\n     * Transaction Execution Entrypoint *\n     ************************************/\n\n    /**\n     * Starts the execution of a transaction via the OVM_ExecutionManager.\n     * @param _transaction Transaction data to be executed.\n     * @param _ovmStateManager iOVM_StateManager implementation providing account state.\n     */\n    function run(\n        Lib_OVMCodec.Transaction memory _transaction,\n        address _ovmStateManager\n    )\n        override\n        public\n    {\n        // Make sure that run() is not re-enterable.  This condition should awlways be satisfied\n        // Once run has been called once, due to the behvaior of _isValidInput().\n        if (transactionContext.ovmNUMBER != DEFAULT_UINT256) {\n            return;\n        }\n\n        // Store our OVM_StateManager instance (significantly easier than attempting to pass the\n        // address around in calldata).\n        ovmStateManager = iOVM_StateManager(_ovmStateManager);\n\n        // Make sure this function can't be called by anyone except the owner of the\n        // OVM_StateManager (expected to be an OVM_StateTransitioner). We can revert here because\n        // this would make the `run` itself invalid.\n        require(\n            // This method may return false during fraud proofs, but always returns true in L2 nodes' State Manager precompile.\n            ovmStateManager.isAuthenticated(msg.sender),\n            \"Only authenticated addresses in ovmStateManager can call this function\"\n        );\n\n        // Initialize the execution context, must be initialized before we perform any gas metering\n        // or we'll throw a nuisance gas error.\n        _initContext(_transaction);\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Check whether we need to start a new epoch, do so if necessary.\n        // _checkNeedsNewEpoch(_transaction.timestamp);\n\n        // Make sure the transaction's gas limit is valid. We don't revert here because we reserve\n        // reverts for INVALID_STATE_ACCESS.\n        if (_isValidInput(_transaction) == false) {\n            _resetContext();\n            return;\n        }\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Check gas right before the call to get total gas consumed by OVM transaction.\n        // uint256 gasProvided = gasleft();\n\n        // Run the transaction, make sure to meter the gas usage.\n        ovmCALL(\n            _transaction.gasLimit - gasMeterConfig.minTransactionGasLimit,\n            _transaction.entrypoint,\n            _transaction.data\n        );\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Update the cumulative gas based on the amount of gas used.\n        // uint256 gasUsed = gasProvided - gasleft();\n        // _updateCumulativeGas(gasUsed, _transaction.l1QueueOrigin);\n\n        // Wipe the execution context.\n        _resetContext();\n    }\n\n\n    /******************************\n     * Opcodes: Execution Context *\n     ******************************/\n\n    /**\n     * @notice Overrides CALLER.\n     * @return _CALLER Address of the CALLER within the current message context.\n     */\n    function ovmCALLER()\n        override\n        public\n        view\n        returns (\n            address _CALLER\n        )\n    {\n        return messageContext.ovmCALLER;\n    }\n\n    /**\n     * @notice Overrides ADDRESS.\n     * @return _ADDRESS Active ADDRESS within the current message context.\n     */\n    function ovmADDRESS()\n        override\n        public\n        view\n        returns (\n            address _ADDRESS\n        )\n    {\n        return messageContext.ovmADDRESS;\n    }\n\n    /**\n     * @notice Overrides TIMESTAMP.\n     * @return _TIMESTAMP Value of the TIMESTAMP within the transaction context.\n     */\n    function ovmTIMESTAMP()\n        override\n        public\n        view\n        returns (\n            uint256 _TIMESTAMP\n        )\n    {\n        return transactionContext.ovmTIMESTAMP;\n    }\n\n    /**\n     * @notice Overrides NUMBER.\n     * @return _NUMBER Value of the NUMBER within the transaction context.\n     */\n    function ovmNUMBER()\n        override\n        public\n        view\n        returns (\n            uint256 _NUMBER\n        )\n    {\n        return transactionContext.ovmNUMBER;\n    }\n\n    /**\n     * @notice Overrides GASLIMIT.\n     * @return _GASLIMIT Value of the block's GASLIMIT within the transaction context.\n     */\n    function ovmGASLIMIT()\n        override\n        public\n        view\n        returns (\n            uint256 _GASLIMIT\n        )\n    {\n        return transactionContext.ovmGASLIMIT;\n    }\n\n    /**\n     * @notice Overrides CHAINID.\n     * @return _CHAINID Value of the chain's CHAINID within the global context.\n     */\n    function ovmCHAINID()\n        override\n        public\n        view\n        returns (\n            uint256 _CHAINID\n        )\n    {\n        return globalContext.ovmCHAINID;\n    }\n\n    /*********************************\n     * Opcodes: L2 Execution Context *\n     *********************************/\n\n    /**\n     * @notice Specifies from which L1 rollup queue this transaction originated from.\n     * @return _queueOrigin Address of the ovmL1QUEUEORIGIN within the current message context.\n     */\n    function ovmL1QUEUEORIGIN()\n        override\n        public\n        view\n        returns (\n            Lib_OVMCodec.QueueOrigin _queueOrigin\n        )\n    {\n        return transactionContext.ovmL1QUEUEORIGIN;\n    }\n\n    /**\n     * @notice Specifies which L1 account, if any, sent this transaction by calling enqueue().\n     * @return _l1TxOrigin Address of the account which sent the tx into L2 from L1.\n     */\n    function ovmL1TXORIGIN()\n        override\n        public\n        view\n        returns (\n            address _l1TxOrigin\n        )\n    {\n        return transactionContext.ovmL1TXORIGIN;\n    }\n\n    /********************\n     * Opcodes: Halting *\n     ********************/\n\n    /**\n     * @notice Overrides REVERT.\n     * @param _data Bytes data to pass along with the REVERT.\n     */\n    function ovmREVERT(\n        bytes memory _data\n    )\n        override\n        public\n    {\n        _revertWithFlag(RevertFlag.INTENTIONAL_REVERT, _data);\n    }\n\n\n    /******************************\n     * Opcodes: Contract Creation *\n     ******************************/\n\n    /**\n     * @notice Overrides CREATE.\n     * @param _bytecode Code to be used to CREATE a new contract.\n     * @return Address of the created contract.\n     * @return Revert data, if and only if the creation threw an exception.\n     */\n    function ovmCREATE(\n        bytes memory _bytecode\n    )\n        override\n        public\n        notStatic\n        fixedGasDiscount(40000)\n        returns (\n            address,\n            bytes memory\n        )\n    {\n        // Creator is always the current ADDRESS.\n        address creator = ovmADDRESS();\n\n        // Check that the deployer is whitelisted, or\n        // that arbitrary contract deployment has been enabled.\n        _checkDeployerAllowed(creator);\n\n        // Generate the correct CREATE address.\n        address contractAddress = Lib_EthUtils.getAddressForCREATE(\n            creator,\n            _getAccountNonce(creator)\n        );\n\n        return _createContract(\n            contractAddress,\n            _bytecode\n        );\n    }\n\n    /**\n     * @notice Overrides CREATE2.\n     * @param _bytecode Code to be used to CREATE2 a new contract.\n     * @param _salt Value used to determine the contract's address.\n     * @return Address of the created contract.\n     * @return Revert data, if and only if the creation threw an exception.\n     */\n    function ovmCREATE2(\n        bytes memory _bytecode,\n        bytes32 _salt\n    )\n        override\n        public\n        notStatic\n        fixedGasDiscount(40000)\n        returns (\n            address,\n            bytes memory\n        )\n    {\n        // Creator is always the current ADDRESS.\n        address creator = ovmADDRESS();\n\n        // Check that the deployer is whitelisted, or\n        // that arbitrary contract deployment has been enabled.\n        _checkDeployerAllowed(creator);\n\n        // Generate the correct CREATE2 address.\n        address contractAddress = Lib_EthUtils.getAddressForCREATE2(\n            creator,\n            _bytecode,\n            _salt\n        );\n\n        return _createContract(\n            contractAddress,\n            _bytecode\n        );\n    }\n\n\n    /*******************************\n     * Account Abstraction Opcodes *\n     ******************************/\n\n    /**\n     * Retrieves the nonce of the current ovmADDRESS.\n     * @return _nonce Nonce of the current contract.\n     */\n    function ovmGETNONCE()\n        override\n        public\n        returns (\n            uint256 _nonce\n        )\n    {\n        return _getAccountNonce(ovmADDRESS());\n    }\n\n    /**\n     * Bumps the nonce of the current ovmADDRESS by one.\n     */\n    function ovmINCREMENTNONCE()\n        override\n        public\n        notStatic\n    {\n        address account = ovmADDRESS();\n        uint256 nonce = _getAccountNonce(account);\n\n        // Prevent overflow.\n        if (nonce + 1 > nonce) {\n            _setAccountNonce(account, nonce + 1);\n        }\n    }\n\n    /**\n     * Creates a new EOA contract account, for account abstraction.\n     * @dev Essentially functions like ovmCREATE or ovmCREATE2, but we can bypass a lot of checks\n     *      because the contract we're creating is trusted (no need to do safety checking or to\n     *      handle unexpected reverts). Doesn't need to return an address because the address is\n     *      assumed to be the user's actual address.\n     * @param _messageHash Hash of a message signed by some user, for verification.\n     * @param _v Signature `v` parameter.\n     * @param _r Signature `r` parameter.\n     * @param _s Signature `s` parameter.\n     */\n    function ovmCREATEEOA(\n        bytes32 _messageHash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        override\n        public\n        notStatic\n    {\n        // Recover the EOA address from the message hash and signature parameters. Since we do the\n        // hashing in advance, we don't have handle different message hashing schemes. Even if this\n        // function were to return the wrong address (rather than explicitly returning the zero\n        // address), the rest of the transaction would simply fail (since there's no EOA account to\n        // actually execute the transaction).\n        address eoa = ecrecover(\n            _messageHash,\n            _v + 27,\n            _r,\n            _s\n        );\n\n        // Invalid signature is a case we proactively handle with a revert. We could alternatively\n        // have this function return a `success` boolean, but this is just easier.\n        if (eoa == address(0)) {\n            ovmREVERT(bytes(\"Signature provided for EOA contract creation is invalid.\"));\n        }\n\n        // If the user already has an EOA account, then there's no need to perform this operation.\n        if (_hasEmptyAccount(eoa) == false) {\n            return;\n        }\n\n        // We always need to initialize the contract with the default account values.\n        _initPendingAccount(eoa);\n\n        // Temporarily set the current address so it's easier to access on L2.\n        address prevADDRESS = messageContext.ovmADDRESS;\n        messageContext.ovmADDRESS = eoa;\n\n        // Now actually create the account and get its bytecode. We're not worried about reverts\n        // (other than out of gas, which we can't capture anyway) because this contract is trusted.\n        OVM_ProxyEOA proxyEOA = new OVM_ProxyEOA(0x4200000000000000000000000000000000000003);\n\n        // Reset the address now that we're done deploying.\n        messageContext.ovmADDRESS = prevADDRESS;\n\n        // Commit the account with its final values.\n        _commitPendingAccount(\n            eoa,\n            address(proxyEOA),\n            keccak256(Lib_EthUtils.getCode(address(proxyEOA)))\n        );\n\n        _setAccountNonce(eoa, 0);\n    }\n\n\n    /*********************************\n     * Opcodes: Contract Interaction *\n     *********************************/\n\n    /**\n     * @notice Overrides CALL.\n     * @param _gasLimit Amount of gas to be passed into this call.\n     * @param _address Address of the contract to call.\n     * @param _calldata Data to send along with the call.\n     * @return _success Whether or not the call returned (rather than reverted).\n     * @return _returndata Data returned by the call.\n     */\n    function ovmCALL(\n        uint256 _gasLimit,\n        address _address,\n        bytes memory _calldata\n    )\n        override\n        public\n        fixedGasDiscount(100000)\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        // CALL updates the CALLER and ADDRESS.\n        MessageContext memory nextMessageContext = messageContext;\n        nextMessageContext.ovmCALLER = nextMessageContext.ovmADDRESS;\n        nextMessageContext.ovmADDRESS = _address;\n\n        return _callContract(\n            nextMessageContext,\n            _gasLimit,\n            _address,\n            _calldata\n        );\n    }\n\n    /**\n     * @notice Overrides STATICCALL.\n     * @param _gasLimit Amount of gas to be passed into this call.\n     * @param _address Address of the contract to call.\n     * @param _calldata Data to send along with the call.\n     * @return _success Whether or not the call returned (rather than reverted).\n     * @return _returndata Data returned by the call.\n     */\n    function ovmSTATICCALL(\n        uint256 _gasLimit,\n        address _address,\n        bytes memory _calldata\n    )\n        override\n        public\n        fixedGasDiscount(80000)\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        // STATICCALL updates the CALLER, updates the ADDRESS, and runs in a static context.\n        MessageContext memory nextMessageContext = messageContext;\n        nextMessageContext.ovmCALLER = nextMessageContext.ovmADDRESS;\n        nextMessageContext.ovmADDRESS = _address;\n        nextMessageContext.isStatic = true;\n\n        return _callContract(\n            nextMessageContext,\n            _gasLimit,\n            _address,\n            _calldata\n        );\n    }\n\n    /**\n     * @notice Overrides DELEGATECALL.\n     * @param _gasLimit Amount of gas to be passed into this call.\n     * @param _address Address of the contract to call.\n     * @param _calldata Data to send along with the call.\n     * @return _success Whether or not the call returned (rather than reverted).\n     * @return _returndata Data returned by the call.\n     */\n    function ovmDELEGATECALL(\n        uint256 _gasLimit,\n        address _address,\n        bytes memory _calldata\n    )\n        override\n        public\n        fixedGasDiscount(40000)\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        // DELEGATECALL does not change anything about the message context.\n        MessageContext memory nextMessageContext = messageContext;\n\n        return _callContract(\n            nextMessageContext,\n            _gasLimit,\n            _address,\n            _calldata\n        );\n    }\n\n\n    /************************************\n     * Opcodes: Contract Storage Access *\n     ************************************/\n\n    /**\n     * @notice Overrides SLOAD.\n     * @param _key 32 byte key of the storage slot to load.\n     * @return _value 32 byte value of the requested storage slot.\n     */\n    function ovmSLOAD(\n        bytes32 _key\n    )\n        override\n        public\n        netGasCost(40000)\n        returns (\n            bytes32 _value\n        )\n    {\n        // We always SLOAD from the storage of ADDRESS.\n        address contractAddress = ovmADDRESS();\n\n        return _getContractStorage(\n            contractAddress,\n            _key\n        );\n    }\n\n    /**\n     * @notice Overrides SSTORE.\n     * @param _key 32 byte key of the storage slot to set.\n     * @param _value 32 byte value for the storage slot.\n     */\n    function ovmSSTORE(\n        bytes32 _key,\n        bytes32 _value\n    )\n        override\n        public\n        notStatic\n        netGasCost(60000)\n    {\n        // We always SSTORE to the storage of ADDRESS.\n        address contractAddress = ovmADDRESS();\n\n        _putContractStorage(\n            contractAddress,\n            _key,\n            _value\n        );\n    }\n\n\n    /*********************************\n     * Opcodes: Contract Code Access *\n     *********************************/\n\n    /**\n     * @notice Overrides EXTCODECOPY.\n     * @param _contract Address of the contract to copy code from.\n     * @param _offset Offset in bytes from the start of contract code to copy beyond.\n     * @param _length Total number of bytes to copy from the contract's code.\n     * @return _code Bytes of code copied from the requested contract.\n     */\n    function ovmEXTCODECOPY(\n        address _contract,\n        uint256 _offset,\n        uint256 _length\n    )\n        override\n        public\n        returns (\n            bytes memory _code\n        )\n    {\n        // `ovmEXTCODECOPY` is the only overridden opcode capable of producing exactly one byte of\n        // return data. By blocking reads of one byte, we're able to use the condition that an\n        // OVM_ExecutionManager function return value having a length of exactly one byte indicates\n        // an error without an explicit revert. If users were able to read a single byte, they\n        // could forcibly trigger behavior that should only be available to this contract.\n        uint256 length = _length == 1 ? 2 : _length;\n\n        return Lib_EthUtils.getCode(\n            _getAccountEthAddress(_contract),\n            _offset,\n            length\n        );\n    }\n\n    /**\n     * @notice Overrides EXTCODESIZE.\n     * @param _contract Address of the contract to query the size of.\n     * @return _EXTCODESIZE Size of the requested contract in bytes.\n     */\n    function ovmEXTCODESIZE(\n        address _contract\n    )\n        override\n        public\n        returns (\n            uint256 _EXTCODESIZE\n        )\n    {\n        return Lib_EthUtils.getCodeSize(\n            _getAccountEthAddress(_contract)\n        );\n    }\n\n    /**\n     * @notice Overrides EXTCODEHASH.\n     * @param _contract Address of the contract to query the hash of.\n     * @return _EXTCODEHASH Hash of the requested contract.\n     */\n    function ovmEXTCODEHASH(\n        address _contract\n    )\n        override\n        public\n        returns (\n            bytes32 _EXTCODEHASH\n        )\n    {\n        return Lib_EthUtils.getCodeHash(\n            _getAccountEthAddress(_contract)\n        );\n    }\n\n    /***************************************\n     * Public Functions: Execution Context *\n     ***************************************/\n\n    function getMaxTransactionGasLimit()\n        external\n        view\n        override\n        returns (\n            uint256 _maxTransactionGasLimit\n        )\n    {\n        return gasMeterConfig.maxTransactionGasLimit;\n    }\n\n    /********************************************\n     * Public Functions: Deployment Whitelisting *\n     ********************************************/\n\n    /**\n     * Checks whether the given address is on the whitelist to ovmCREATE/ovmCREATE2, and reverts if not.\n     * @param _deployerAddress Address attempting to deploy a contract.\n     */\n    function _checkDeployerAllowed(\n        address _deployerAddress\n    )\n        internal\n    {\n        // From an OVM semantics perspective, this will appear identical to\n        // the deployer ovmCALLing the whitelist.  This is fine--in a sense, we are forcing them to.\n        (bool success, bytes memory data) = ovmCALL(\n            gasleft(),\n            0x4200000000000000000000000000000000000002,\n            abi.encodeWithSignature(\"isDeployerAllowed(address)\", _deployerAddress)\n        );\n        bool isAllowed = abi.decode(data, (bool));\n\n        if (!isAllowed || !success) {\n            _revertWithFlag(RevertFlag.CREATOR_NOT_ALLOWED);\n        }\n    }\n\n    /********************************************\n     * Internal Functions: Contract Interaction *\n     ********************************************/\n\n    /**\n     * Creates a new contract and associates it with some contract address.\n     * @param _contractAddress Address to associate the created contract with.\n     * @param _bytecode Bytecode to be used to create the contract.\n     * @return Final OVM contract address.\n     * @return Revertdata, if and only if the creation threw an exception.\n     */\n    function _createContract(\n        address _contractAddress,\n        bytes memory _bytecode\n    )\n        internal\n        returns (\n            address,\n            bytes memory\n        )\n    {\n        // We always update the nonce of the creating account, even if the creation fails.\n        _setAccountNonce(ovmADDRESS(), _getAccountNonce(ovmADDRESS()) + 1);\n\n        // We're stepping into a CREATE or CREATE2, so we need to update ADDRESS to point\n        // to the contract's associated address and CALLER to point to the previous ADDRESS.\n        MessageContext memory nextMessageContext = messageContext;\n        nextMessageContext.ovmCALLER = messageContext.ovmADDRESS;\n        nextMessageContext.ovmADDRESS = _contractAddress;\n\n        // Run the common logic which occurs between call-type and create-type messages,\n        // passing in the creation bytecode and `true` to trigger create-specific logic.\n        (bool success, bytes memory data) = _handleExternalMessage(\n            nextMessageContext,\n            gasleft(),\n            _contractAddress,\n            _bytecode,\n            true\n        );\n\n        // Yellow paper requires that address returned is zero if the contract deployment fails.\n        return (\n            success ? _contractAddress : address(0),\n            data\n        );\n    }\n\n    /**\n     * Calls the deployed contract associated with a given address.\n     * @param _nextMessageContext Message context to be used for the call.\n     * @param _gasLimit Amount of gas to be passed into this call.\n     * @param _contract OVM address to be called.\n     * @param _calldata Data to send along with the call.\n     * @return _success Whether or not the call returned (rather than reverted).\n     * @return _returndata Data returned by the call.\n     */\n    function _callContract(\n        MessageContext memory _nextMessageContext,\n        uint256 _gasLimit,\n        address _contract,\n        bytes memory _calldata\n    )\n        internal\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        // We reserve addresses of the form 0xdeaddeaddead...NNNN for the container contracts in L2 geth.\n        // So, we block calls to these addresses since they are not safe to run as an OVM contract itself.\n        if (\n            (uint256(_contract) & uint256(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000))\n            == uint256(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000)\n        ) {\n            // EVM does not return data in the success case, see: https://github.com/ethereum/go-ethereum/blob/aae7660410f0ef90279e14afaaf2f429fdc2a186/core/vm/instructions.go#L600-L604\n            return (true, hex'');\n        }\n\n        // Both 0x0000... and the EVM precompiles have the same address on L1 and L2 --> no trie lookup needed.\n        address codeContractAddress =\n            uint(_contract) < 100\n            ? _contract\n            : _getAccountEthAddress(_contract);\n\n        return _handleExternalMessage(\n            _nextMessageContext,\n            _gasLimit,\n            codeContractAddress,\n            _calldata,\n            false\n        );\n    }\n\n    /**\n     * Handles all interactions which involve the execution manager calling out to untrusted code (both calls and creates).\n     * Ensures that OVM-related measures are enforced, including L2 gas refunds, nuisance gas, and flagged reversions.\n     *\n     * @param _nextMessageContext Message context to be used for the external message.\n     * @param _gasLimit Amount of gas to be passed into this message.\n     * @param _contract OVM address being called or deployed to\n     * @param _data Data for the message (either calldata or creation code)\n     * @param _isCreate Whether this is a create-type message.\n     * @return Whether or not the message (either a call or deployment) succeeded.\n     * @return Data returned by the message.\n     */\n    function _handleExternalMessage(\n        MessageContext memory _nextMessageContext,\n        uint256 _gasLimit,\n        address _contract,\n        bytes memory _data,\n        bool _isCreate\n    )\n        internal\n        returns (\n            bool,\n            bytes memory\n        )\n    {\n        // We need to switch over to our next message context for the duration of this call.\n        MessageContext memory prevMessageContext = messageContext;\n        _switchMessageContext(prevMessageContext, _nextMessageContext);\n\n        // Nuisance gas is a system used to bound the ability for an attacker to make fraud proofs\n        // expensive by touching a lot of different accounts or storage slots. Since most contracts\n        // only use a few storage slots during any given transaction, this shouldn't be a limiting\n        // factor.\n        uint256 prevNuisanceGasLeft = messageRecord.nuisanceGasLeft;\n        uint256 nuisanceGasLimit = _getNuisanceGasLimit(_gasLimit);\n        messageRecord.nuisanceGasLeft = nuisanceGasLimit;\n\n        // Make the call and make sure to pass in the gas limit. Another instance of hidden\n        // complexity. `_contract` is guaranteed to be a safe contract, meaning its return/revert\n        // behavior can be controlled. In particular, we enforce that flags are passed through\n        // revert data as to retrieve execution metadata that would normally be reverted out of\n        // existence.\n\n        bool success; \n        bytes memory returndata;\n\n        if (_isCreate) {\n            // safeCREATE() is a function which replicates a CREATE message, but uses return values\n            // Which match that of CALL (i.e. bool, bytes).  This allows many security checks to be\n            // to be shared between untrusted call and create call frames.\n            (success, returndata) = address(this).call(\n                abi.encodeWithSelector(\n                    this.safeCREATE.selector,\n                    _gasLimit,\n                    _data,\n                    _contract\n                )\n            );\n        } else {\n            (success, returndata) = _contract.call{gas: _gasLimit}(_data);\n        }\n\n        // Switch back to the original message context now that we're out of the call.\n        _switchMessageContext(_nextMessageContext, prevMessageContext);\n\n        // Assuming there were no reverts, the message record should be accurate here. We'll update\n        // this value in the case of a revert.\n        uint256 nuisanceGasLeft = messageRecord.nuisanceGasLeft;\n\n        // Reverts at this point are completely OK, but we need to make a few updates based on the\n        // information passed through the revert.\n        if (success == false) {\n            (\n                RevertFlag flag,\n                uint256 nuisanceGasLeftPostRevert,\n                uint256 ovmGasRefund,\n                bytes memory returndataFromFlag\n            ) = _decodeRevertData(returndata);\n\n            // INVALID_STATE_ACCESS is the only flag that triggers an immediate abort of the\n            // parent EVM message. This behavior is necessary because INVALID_STATE_ACCESS must\n            // halt any further transaction execution that could impact the execution result.\n            if (flag == RevertFlag.INVALID_STATE_ACCESS) {\n                _revertWithFlag(flag);\n            }\n\n            // INTENTIONAL_REVERT, UNSAFE_BYTECODE, STATIC_VIOLATION, and CREATOR_NOT_ALLOWED aren't\n            // dependent on the input state, so we can just handle them like standard reverts. Our only change here\n            // is to record the gas refund reported by the call (enforced by safety checking).\n            if (\n                flag == RevertFlag.INTENTIONAL_REVERT\n                || flag == RevertFlag.UNSAFE_BYTECODE\n                || flag == RevertFlag.STATIC_VIOLATION\n                || flag == RevertFlag.CREATOR_NOT_ALLOWED\n            ) {\n                transactionRecord.ovmGasRefund = ovmGasRefund;\n            }\n\n            // INTENTIONAL_REVERT needs to pass up the user-provided return data encoded into the\n            // flag, *not* the full encoded flag. All other revert types return no data.\n            if (\n                flag == RevertFlag.INTENTIONAL_REVERT\n                || _isCreate\n            ) {\n                returndata = returndataFromFlag;\n            } else {\n                returndata = hex'';\n            }\n\n            // Reverts mean we need to use up whatever \"nuisance gas\" was used by the call.\n            // EXCEEDS_NUISANCE_GAS explicitly reduces the remaining nuisance gas for this message\n            // to zero. OUT_OF_GAS is a \"pseudo\" flag given that messages return no data when they\n            // run out of gas, so we have to treat this like EXCEEDS_NUISANCE_GAS. All other flags\n            // will simply pass up the remaining nuisance gas.\n            nuisanceGasLeft = nuisanceGasLeftPostRevert;\n        }\n\n        // We need to reset the nuisance gas back to its original value minus the amount used here.\n        messageRecord.nuisanceGasLeft = prevNuisanceGasLeft - (nuisanceGasLimit - nuisanceGasLeft);\n\n        return (\n            success,\n            returndata\n        );\n    }\n\n    /**\n     * Handles the creation-specific safety measures required for OVM contract deployment.\n     * This function sanitizes the return types for creation messages to match calls (bool, bytes),\n     * by being an external function which the EM can call, that mimics the success/fail case of the CREATE.\n     * This allows for consistent handling of both types of messages in _handleExternalMessage().\n     * Having this step occur as a separate call frame also allows us to easily revert the \n     * contract deployment in the event that the code is unsafe.\n     * \n     * @param _gasLimit Amount of gas to be passed into this creation.\n     * @param _creationCode Code to pass into CREATE for deployment.\n     * @param _address OVM address being deployed to.\n     */\n    function safeCREATE(\n        uint _gasLimit,\n        bytes memory _creationCode,\n        address _address\n    )\n        external\n    {\n        // The only way this should callable is from within _createContract(),\n        // and it should DEFINITELY not be callable by a non-EM code contract.\n        if (msg.sender != address(this)) {\n            return;\n        }\n        // Check that there is not already code at this address.\n        if (_hasEmptyAccount(_address) == false) {\n            // Note: in the EVM, this case burns all allotted gas.  For improved\n            // developer experience, we do return the remaining gas.\n            _revertWithFlag(\n                RevertFlag.CREATE_COLLISION,\n                Lib_ErrorUtils.encodeRevertString(\"A contract has already been deployed to this address\")\n            );\n        }\n\n        // Check the creation bytecode against the OVM_SafetyChecker.\n        if (ovmSafetyChecker.isBytecodeSafe(_creationCode) == false) {\n            _revertWithFlag(\n                RevertFlag.UNSAFE_BYTECODE,\n                Lib_ErrorUtils.encodeRevertString(\"Contract creation code contains unsafe opcodes. Did you use the right compiler or pass an unsafe constructor argument?\")\n            );\n        }\n\n        // We always need to initialize the contract with the default account values.\n        _initPendingAccount(_address);\n\n        // Actually execute the EVM create message.\n        // NOTE: The inline assembly below means we can NOT make any evm calls between here and then.\n        address ethAddress = Lib_EthUtils.createContract(_creationCode);\n\n        if (ethAddress == address(0)) {\n            // If the creation fails, the EVM lets us grab its revert data. This may contain a revert flag\n            // to be used above in _handleExternalMessage, so we pass the revert data back up unmodified.\n            assembly { \n                returndatacopy(0,0,returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // Again simply checking that the deployed code is safe too. Contracts can generate\n        // arbitrary deployment code, so there's no easy way to analyze this beforehand.\n        bytes memory deployedCode = Lib_EthUtils.getCode(ethAddress);\n        if (ovmSafetyChecker.isBytecodeSafe(deployedCode) == false) {\n            _revertWithFlag(\n                RevertFlag.UNSAFE_BYTECODE,\n                Lib_ErrorUtils.encodeRevertString(\"Constructor attempted to deploy unsafe bytecode.\")\n            );\n        }\n\n        // Contract creation didn't need to be reverted and the bytecode is safe. We finish up by\n        // associating the desired address with the newly created contract's code hash and address.\n        _commitPendingAccount(\n            _address,\n            ethAddress,\n            Lib_EthUtils.getCodeHash(ethAddress)\n        );\n    }\n\n    /******************************************\n     * Internal Functions: State Manipulation *\n     ******************************************/\n\n    /**\n     * Checks whether an account exists within the OVM_StateManager.\n     * @param _address Address of the account to check.\n     * @return _exists Whether or not the account exists.\n     */\n    function _hasAccount(\n        address _address\n    )\n        internal\n        returns (\n            bool _exists\n        )\n    {\n        _checkAccountLoad(_address);\n        return ovmStateManager.hasAccount(_address);\n    }\n\n    /**\n     * Checks whether a known empty account exists within the OVM_StateManager.\n     * @param _address Address of the account to check.\n     * @return _exists Whether or not the account empty exists.\n     */\n    function _hasEmptyAccount(\n        address _address\n    )\n        internal\n        returns (\n            bool _exists\n        )\n    {\n        _checkAccountLoad(_address);\n        return ovmStateManager.hasEmptyAccount(_address);\n    }\n\n    /**\n     * Sets the nonce of an account.\n     * @param _address Address of the account to modify.\n     * @param _nonce New account nonce.\n     */\n    function _setAccountNonce(\n        address _address,\n        uint256 _nonce\n    )\n        internal\n    {\n        _checkAccountChange(_address);\n        ovmStateManager.setAccountNonce(_address, _nonce);\n    }\n\n    /**\n     * Gets the nonce of an account.\n     * @param _address Address of the account to access.\n     * @return _nonce Nonce of the account.\n     */\n    function _getAccountNonce(\n        address _address\n    )\n        internal\n        returns (\n            uint256 _nonce\n        )\n    {\n        _checkAccountLoad(_address);\n        return ovmStateManager.getAccountNonce(_address);\n    }\n\n    /**\n     * Retrieves the Ethereum address of an account.\n     * @param _address Address of the account to access.\n     * @return _ethAddress Corresponding Ethereum address.\n     */\n    function _getAccountEthAddress(\n        address _address\n    )\n        internal\n        returns (\n            address _ethAddress\n        )\n    {\n        _checkAccountLoad(_address);\n        return ovmStateManager.getAccountEthAddress(_address);\n    }\n\n    /**\n     * Creates the default account object for the given address.\n     * @param _address Address of the account create.\n     */\n    function _initPendingAccount(\n        address _address\n    )\n        internal\n    {\n        // Although it seems like `_checkAccountChange` would be more appropriate here, we don't\n        // actually consider an account \"changed\" until it's inserted into the state (in this case\n        // by `_commitPendingAccount`).\n        _checkAccountLoad(_address);\n        ovmStateManager.initPendingAccount(_address);\n    }\n\n    /**\n     * Stores additional relevant data for a new account, thereby \"committing\" it to the state.\n     * This function is only called during `ovmCREATE` and `ovmCREATE2` after a successful contract\n     * creation.\n     * @param _address Address of the account to commit.\n     * @param _ethAddress Address of the associated deployed contract.\n     * @param _codeHash Hash of the code stored at the address.\n     */\n    function _commitPendingAccount(\n        address _address,\n        address _ethAddress,\n        bytes32 _codeHash\n    )\n        internal\n    {\n        _checkAccountChange(_address);\n        ovmStateManager.commitPendingAccount(\n            _address,\n            _ethAddress,\n            _codeHash\n        );\n    }\n\n    /**\n     * Retrieves the value of a storage slot.\n     * @param _contract Address of the contract to query.\n     * @param _key 32 byte key of the storage slot.\n     * @return _value 32 byte storage slot value.\n     */\n    function _getContractStorage(\n        address _contract,\n        bytes32 _key\n    )\n        internal\n        returns (\n            bytes32 _value\n        )\n    {\n        _checkContractStorageLoad(_contract, _key);\n        return ovmStateManager.getContractStorage(_contract, _key);\n    }\n\n    /**\n     * Sets the value of a storage slot.\n     * @param _contract Address of the contract to modify.\n     * @param _key 32 byte key of the storage slot.\n     * @param _value 32 byte storage slot value.\n     */\n    function _putContractStorage(\n        address _contract,\n        bytes32 _key,\n        bytes32 _value\n    )\n        internal\n    {\n        // We don't set storage if the value didn't change. Although this acts as a convenient\n        // optimization, it's also necessary to avoid the case in which a contract with no storage\n        // attempts to store the value \"0\" at any key. Putting this value (and therefore requiring\n        // that the value be committed into the storage trie after execution) would incorrectly\n        // modify the storage root.\n        if (_getContractStorage(_contract, _key) == _value) {\n            return;\n        }\n\n        _checkContractStorageChange(_contract, _key);\n        ovmStateManager.putContractStorage(_contract, _key, _value);\n    }\n\n    /**\n     * Validation whenever a contract needs to be loaded. Checks that the account exists, charges\n     * nuisance gas if the account hasn't been loaded before.\n     * @param _address Address of the account to load.\n     */\n    function _checkAccountLoad(\n        address _address\n    )\n        internal\n    {\n        // See `_checkContractStorageLoad` for more information.\n        if (gasleft() < MIN_GAS_FOR_INVALID_STATE_ACCESS) {\n            _revertWithFlag(RevertFlag.OUT_OF_GAS);\n        }\n\n        // See `_checkContractStorageLoad` for more information.\n        if (ovmStateManager.hasAccount(_address) == false) {\n            _revertWithFlag(RevertFlag.INVALID_STATE_ACCESS);\n        }\n\n        // Check whether the account has been loaded before and mark it as loaded if not. We need\n        // this because \"nuisance gas\" only applies to the first time that an account is loaded.\n        (\n            bool _wasAccountAlreadyLoaded\n        ) = ovmStateManager.testAndSetAccountLoaded(_address);\n\n        // If we hadn't already loaded the account, then we'll need to charge \"nuisance gas\" based\n        // on the size of the contract code.\n        if (_wasAccountAlreadyLoaded == false) {\n            _useNuisanceGas(\n                (Lib_EthUtils.getCodeSize(_getAccountEthAddress(_address)) * NUISANCE_GAS_PER_CONTRACT_BYTE) + MIN_NUISANCE_GAS_PER_CONTRACT\n            );\n        }\n    }\n\n    /**\n     * Validation whenever a contract needs to be changed. Checks that the account exists, charges\n     * nuisance gas if the account hasn't been changed before.\n     * @param _address Address of the account to change.\n     */\n    function _checkAccountChange(\n        address _address\n    )\n        internal\n    {\n        // Start by checking for a load as we only want to charge nuisance gas proportional to\n        // contract size once.\n        _checkAccountLoad(_address);\n\n        // Check whether the account has been changed before and mark it as changed if not. We need\n        // this because \"nuisance gas\" only applies to the first time that an account is changed.\n        (\n            bool _wasAccountAlreadyChanged\n        ) = ovmStateManager.testAndSetAccountChanged(_address);\n\n        // If we hadn't already loaded the account, then we'll need to charge \"nuisance gas\" based\n        // on the size of the contract code.\n        if (_wasAccountAlreadyChanged == false) {\n            ovmStateManager.incrementTotalUncommittedAccounts();\n            _useNuisanceGas(\n                (Lib_EthUtils.getCodeSize(_getAccountEthAddress(_address)) * NUISANCE_GAS_PER_CONTRACT_BYTE) + MIN_NUISANCE_GAS_PER_CONTRACT\n            );\n        }\n    }\n\n    /**\n     * Validation whenever a slot needs to be loaded. Checks that the account exists, charges\n     * nuisance gas if the slot hasn't been loaded before.\n     * @param _contract Address of the account to load from.\n     * @param _key 32 byte key to load.\n     */\n    function _checkContractStorageLoad(\n        address _contract,\n        bytes32 _key\n    )\n        internal\n    {\n        // Another case of hidden complexity. If we didn't enforce this requirement, then a\n        // contract could pass in just enough gas to cause the INVALID_STATE_ACCESS check to fail\n        // on L1 but not on L2. A contract could use this behavior to prevent the\n        // OVM_ExecutionManager from detecting an invalid state access. Reverting with OUT_OF_GAS\n        // allows us to also charge for the full message nuisance gas, because you deserve that for\n        // trying to break the contract in this way.\n        if (gasleft() < MIN_GAS_FOR_INVALID_STATE_ACCESS) {\n            _revertWithFlag(RevertFlag.OUT_OF_GAS);\n        }\n\n        // We need to make sure that the transaction isn't trying to access storage that hasn't\n        // been provided to the OVM_StateManager. We'll immediately abort if this is the case.\n        // We know that we have enough gas to do this check because of the above test.\n        if (ovmStateManager.hasContractStorage(_contract, _key) == false) {\n            _revertWithFlag(RevertFlag.INVALID_STATE_ACCESS);\n        }\n\n        // Check whether the slot has been loaded before and mark it as loaded if not. We need\n        // this because \"nuisance gas\" only applies to the first time that a slot is loaded.\n        (\n            bool _wasContractStorageAlreadyLoaded\n        ) = ovmStateManager.testAndSetContractStorageLoaded(_contract, _key);\n\n        // If we hadn't already loaded the account, then we'll need to charge some fixed amount of\n        // \"nuisance gas\".\n        if (_wasContractStorageAlreadyLoaded == false) {\n            _useNuisanceGas(NUISANCE_GAS_SLOAD);\n        }\n    }\n\n    /**\n     * Validation whenever a slot needs to be changed. Checks that the account exists, charges\n     * nuisance gas if the slot hasn't been changed before.\n     * @param _contract Address of the account to change.\n     * @param _key 32 byte key to change.\n     */\n    function _checkContractStorageChange(\n        address _contract,\n        bytes32 _key\n    )\n        internal\n    {\n        // Start by checking for load to make sure we have the storage slot and that we charge the\n        // \"nuisance gas\" necessary to prove the storage slot state.\n        _checkContractStorageLoad(_contract, _key);\n\n        // Check whether the slot has been changed before and mark it as changed if not. We need\n        // this because \"nuisance gas\" only applies to the first time that a slot is changed.\n        (\n            bool _wasContractStorageAlreadyChanged\n        ) = ovmStateManager.testAndSetContractStorageChanged(_contract, _key);\n\n        // If we hadn't already changed the account, then we'll need to charge some fixed amount of\n        // \"nuisance gas\".\n        if (_wasContractStorageAlreadyChanged == false) {\n            // Changing a storage slot means that we're also going to have to change the\n            // corresponding account, so do an account change check.\n            _checkAccountChange(_contract);\n\n            ovmStateManager.incrementTotalUncommittedContractStorage();\n            _useNuisanceGas(NUISANCE_GAS_SSTORE);\n        }\n    }\n\n\n    /************************************\n     * Internal Functions: Revert Logic *\n     ************************************/\n\n    /**\n     * Simple encoding for revert data.\n     * @param _flag Flag to revert with.\n     * @param _data Additional user-provided revert data.\n     * @return _revertdata Encoded revert data.\n     */\n    function _encodeRevertData(\n        RevertFlag _flag,\n        bytes memory _data\n    )\n        internal\n        view\n        returns (\n            bytes memory _revertdata\n        )\n    {\n        // Out of gas and create exceptions will fundamentally return no data, so simulating it shouldn't either.\n        if (\n            _flag == RevertFlag.OUT_OF_GAS\n        ) {\n            return bytes('');\n        }\n\n        // INVALID_STATE_ACCESS doesn't need to return any data other than the flag.\n        if (_flag == RevertFlag.INVALID_STATE_ACCESS) {\n            return abi.encode(\n                _flag,\n                0,\n                0,\n                bytes('')\n            );\n        }\n\n        // Just ABI encode the rest of the parameters.\n        return abi.encode(\n            _flag,\n            messageRecord.nuisanceGasLeft,\n            transactionRecord.ovmGasRefund,\n            _data\n        );\n    }\n\n    /**\n     * Simple decoding for revert data.\n     * @param _revertdata Revert data to decode.\n     * @return _flag Flag used to revert.\n     * @return _nuisanceGasLeft Amount of nuisance gas unused by the message.\n     * @return _ovmGasRefund Amount of gas refunded during the message.\n     * @return _data Additional user-provided revert data.\n     */\n    function _decodeRevertData(\n        bytes memory _revertdata\n    )\n        internal\n        pure\n        returns (\n            RevertFlag _flag,\n            uint256 _nuisanceGasLeft,\n            uint256 _ovmGasRefund,\n            bytes memory _data\n        )\n    {\n        // A length of zero means the call ran out of gas, just return empty data.\n        if (_revertdata.length == 0) {\n            return (\n                RevertFlag.OUT_OF_GAS,\n                0,\n                0,\n                bytes('')\n            );\n        }\n\n        // ABI decode the incoming data.\n        return abi.decode(_revertdata, (RevertFlag, uint256, uint256, bytes));\n    }\n\n    /**\n     * Causes a message to revert or abort.\n     * @param _flag Flag to revert with.\n     * @param _data Additional user-provided data.\n     */\n    function _revertWithFlag(\n        RevertFlag _flag,\n        bytes memory _data\n    )\n        internal\n        view\n    {\n        bytes memory revertdata = _encodeRevertData(\n            _flag,\n            _data\n        );\n\n        assembly {\n            revert(add(revertdata, 0x20), mload(revertdata))\n        }\n    }\n\n    /**\n     * Causes a message to revert or abort.\n     * @param _flag Flag to revert with.\n     */\n    function _revertWithFlag(\n        RevertFlag _flag\n    )\n        internal\n    {\n        _revertWithFlag(_flag, bytes(''));\n    }\n\n\n    /******************************************\n     * Internal Functions: Nuisance Gas Logic *\n     ******************************************/\n\n    /**\n     * Computes the nuisance gas limit from the gas limit.\n     * @dev This function is currently using a naive implementation whereby the nuisance gas limit\n     *      is set to exactly equal the lesser of the gas limit or remaining gas. It's likely that\n     *      this implementation is perfectly fine, but we may change this formula later.\n     * @param _gasLimit Gas limit to compute from.\n     * @return _nuisanceGasLimit Computed nuisance gas limit.\n     */\n    function _getNuisanceGasLimit(\n        uint256 _gasLimit\n    )\n        internal\n        view\n        returns (\n            uint256 _nuisanceGasLimit\n        )\n    {\n        return _gasLimit < gasleft() ? _gasLimit : gasleft();\n    }\n\n    /**\n     * Uses a certain amount of nuisance gas.\n     * @param _amount Amount of nuisance gas to use.\n     */\n    function _useNuisanceGas(\n        uint256 _amount\n    )\n        internal\n    {\n        // Essentially the same as a standard OUT_OF_GAS, except we also retain a record of the gas\n        // refund to be given at the end of the transaction.\n        if (messageRecord.nuisanceGasLeft < _amount) {\n            _revertWithFlag(RevertFlag.EXCEEDS_NUISANCE_GAS);\n        }\n\n        messageRecord.nuisanceGasLeft -= _amount;\n    }\n\n\n    /************************************\n     * Internal Functions: Gas Metering *\n     ************************************/\n\n    /**\n     * Checks whether a transaction needs to start a new epoch and does so if necessary.\n     * @param _timestamp Transaction timestamp.\n     */\n    function _checkNeedsNewEpoch(\n        uint256 _timestamp\n    )\n        internal\n    {\n        if (\n            _timestamp >= (\n                _getGasMetadata(GasMetadataKey.CURRENT_EPOCH_START_TIMESTAMP)\n                + gasMeterConfig.secondsPerEpoch\n            )\n        ) {\n            _putGasMetadata(\n                GasMetadataKey.CURRENT_EPOCH_START_TIMESTAMP,\n                _timestamp\n            );\n\n            _putGasMetadata(\n                GasMetadataKey.PREV_EPOCH_SEQUENCER_QUEUE_GAS,\n                _getGasMetadata(\n                    GasMetadataKey.CUMULATIVE_SEQUENCER_QUEUE_GAS\n                )\n            );\n\n            _putGasMetadata(\n                GasMetadataKey.PREV_EPOCH_L1TOL2_QUEUE_GAS,\n                _getGasMetadata(\n                    GasMetadataKey.CUMULATIVE_L1TOL2_QUEUE_GAS\n                )\n            );\n        }\n    }\n\n    /**\n     * Validates the input values of a transaction.\n     * @return _valid Whether or not the transaction data is valid.\n     */\n    function _isValidInput(\n        Lib_OVMCodec.Transaction memory _transaction\n    )\n        view\n        internal\n        returns (\n            bool\n        )\n    {\n        // Prevent reentrancy to run():\n        // This check prevents calling run with the default ovmNumber.\n        // Combined with the first check in run():\n        //      if (transactionContext.ovmNUMBER != DEFAULT_UINT256) { return; }\n        // It should be impossible to re-enter since run() returns before any other call frames are created.\n        // Since this value is already being written to storage, we save much gas compared to\n        // using the standard nonReentrant pattern.\n        if (_transaction.blockNumber == DEFAULT_UINT256)  {\n            return false;\n        }\n\n        if (_isValidGasLimit(_transaction.gasLimit, _transaction.l1QueueOrigin) == false) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Validates the gas limit for a given transaction.\n     * @param _gasLimit Gas limit provided by the transaction.\n     * param _queueOrigin Queue from which the transaction originated.\n     * @return _valid Whether or not the gas limit is valid.\n     */\n    function _isValidGasLimit(\n        uint256 _gasLimit,\n        Lib_OVMCodec.QueueOrigin // _queueOrigin\n    )\n        view\n        internal\n        returns (\n            bool _valid\n        )\n    {\n        // Always have to be below the maximum gas limit.\n        if (_gasLimit > gasMeterConfig.maxTransactionGasLimit) {\n            return false;\n        }\n\n        // Always have to be above the minimum gas limit.\n        if (_gasLimit < gasMeterConfig.minTransactionGasLimit) {\n            return false;\n        }\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        return true;\n        // GasMetadataKey cumulativeGasKey;\n        // GasMetadataKey prevEpochGasKey;\n        // if (_queueOrigin == Lib_OVMCodec.QueueOrigin.SEQUENCER_QUEUE) {\n        //     cumulativeGasKey = GasMetadataKey.CUMULATIVE_SEQUENCER_QUEUE_GAS;\n        //     prevEpochGasKey = GasMetadataKey.PREV_EPOCH_SEQUENCER_QUEUE_GAS;\n        // } else {\n        //     cumulativeGasKey = GasMetadataKey.CUMULATIVE_L1TOL2_QUEUE_GAS;\n        //     prevEpochGasKey = GasMetadataKey.PREV_EPOCH_L1TOL2_QUEUE_GAS;\n        // }\n\n        // return (\n        //     (\n        //         _getGasMetadata(cumulativeGasKey)\n        //         - _getGasMetadata(prevEpochGasKey)\n        //         + _gasLimit\n        //     ) < gasMeterConfig.maxGasPerQueuePerEpoch\n        // );\n    }\n\n    /**\n     * Updates the cumulative gas after a transaction.\n     * @param _gasUsed Gas used by the transaction.\n     * @param _queueOrigin Queue from which the transaction originated.\n     */\n    function _updateCumulativeGas(\n        uint256 _gasUsed,\n        Lib_OVMCodec.QueueOrigin _queueOrigin\n    )\n        internal\n    {\n        GasMetadataKey cumulativeGasKey;\n        if (_queueOrigin == Lib_OVMCodec.QueueOrigin.SEQUENCER_QUEUE) {\n            cumulativeGasKey = GasMetadataKey.CUMULATIVE_SEQUENCER_QUEUE_GAS;\n        } else {\n            cumulativeGasKey = GasMetadataKey.CUMULATIVE_L1TOL2_QUEUE_GAS;\n        }\n\n        _putGasMetadata(\n            cumulativeGasKey,\n            (\n                _getGasMetadata(cumulativeGasKey)\n                + gasMeterConfig.minTransactionGasLimit\n                + _gasUsed\n                - transactionRecord.ovmGasRefund\n            )\n        );\n    }\n\n    /**\n     * Retrieves the value of a gas metadata key.\n     * @param _key Gas metadata key to retrieve.\n     * @return _value Value stored at the given key.\n     */\n    function _getGasMetadata(\n        GasMetadataKey _key\n    )\n        internal\n        returns (\n            uint256 _value\n        )\n    {\n        return uint256(_getContractStorage(\n            GAS_METADATA_ADDRESS,\n            bytes32(uint256(_key))\n        ));\n    }\n\n    /**\n     * Sets the value of a gas metadata key.\n     * @param _key Gas metadata key to set.\n     * @param _value Value to store at the given key.\n     */\n    function _putGasMetadata(\n        GasMetadataKey _key,\n        uint256 _value\n    )\n        internal\n    {\n        _putContractStorage(\n            GAS_METADATA_ADDRESS,\n            bytes32(uint256(_key)),\n            bytes32(uint256(_value))\n        );\n    }\n\n\n    /*****************************************\n     * Internal Functions: Execution Context *\n     *****************************************/\n\n    /**\n     * Swaps over to a new message context.\n     * @param _prevMessageContext Context we're switching from.\n     * @param _nextMessageContext Context we're switching to.\n     */\n    function _switchMessageContext(\n        MessageContext memory _prevMessageContext,\n        MessageContext memory _nextMessageContext\n    )\n        internal\n    {\n        // Avoid unnecessary the SSTORE.\n        if (_prevMessageContext.ovmCALLER != _nextMessageContext.ovmCALLER) {\n            messageContext.ovmCALLER = _nextMessageContext.ovmCALLER;\n        }\n\n        // Avoid unnecessary the SSTORE.\n        if (_prevMessageContext.ovmADDRESS != _nextMessageContext.ovmADDRESS) {\n            messageContext.ovmADDRESS = _nextMessageContext.ovmADDRESS;\n        }\n\n        // Avoid unnecessary the SSTORE.\n        if (_prevMessageContext.isStatic != _nextMessageContext.isStatic) {\n            messageContext.isStatic = _nextMessageContext.isStatic;\n        }\n    }\n\n    /**\n     * Initializes the execution context.\n     * @param _transaction OVM transaction being executed.\n     */\n    function _initContext(\n        Lib_OVMCodec.Transaction memory _transaction\n    )\n        internal\n    {\n        transactionContext.ovmTIMESTAMP = _transaction.timestamp;\n        transactionContext.ovmNUMBER = _transaction.blockNumber;\n        transactionContext.ovmTXGASLIMIT = _transaction.gasLimit;\n        transactionContext.ovmL1QUEUEORIGIN = _transaction.l1QueueOrigin;\n        transactionContext.ovmL1TXORIGIN = _transaction.l1TxOrigin;\n        transactionContext.ovmGASLIMIT = gasMeterConfig.maxGasPerQueuePerEpoch;\n\n        messageRecord.nuisanceGasLeft = _getNuisanceGasLimit(_transaction.gasLimit);\n    }\n\n    /**\n     * Resets the transaction and message context.\n     */\n    function _resetContext()\n        internal\n    {\n        transactionContext.ovmL1TXORIGIN = DEFAULT_ADDRESS;\n        transactionContext.ovmTIMESTAMP = DEFAULT_UINT256;\n        transactionContext.ovmNUMBER = DEFAULT_UINT256;\n        transactionContext.ovmGASLIMIT = DEFAULT_UINT256;\n        transactionContext.ovmTXGASLIMIT = DEFAULT_UINT256;\n        transactionContext.ovmL1QUEUEORIGIN = Lib_OVMCodec.QueueOrigin.SEQUENCER_QUEUE;\n\n        transactionRecord.ovmGasRefund = DEFAULT_UINT256;\n\n        messageContext.ovmCALLER = DEFAULT_ADDRESS;\n        messageContext.ovmADDRESS = DEFAULT_ADDRESS;\n        messageContext.isStatic = false;\n\n        messageRecord.nuisanceGasLeft = DEFAULT_UINT256;\n\n        // Reset the ovmStateManager.\n        ovmStateManager = iOVM_StateManager(address(0));\n    }\n\n    /*****************************\n     * L2-only Helper Functions *\n     *****************************/\n\n    /**\n     * Unreachable helper function for simulating eth_calls with an OVM message context.\n     * This function will throw an exception in all cases other than when used as a custom entrypoint in L2 Geth to simulate eth_call.\n     * @param _transaction the message transaction to simulate.\n     * @param _from the OVM account the simulated call should be from.\n     */\n    function simulateMessage(\n        Lib_OVMCodec.Transaction memory _transaction,\n        address _from,\n        iOVM_StateManager _ovmStateManager\n    )\n        external\n        returns (\n            bool,\n            bytes memory\n        )\n    {\n        // Prevent this call from having any effect unless in a custom-set VM frame\n        require(msg.sender == address(0));\n\n        ovmStateManager = _ovmStateManager;\n        _initContext(_transaction);\n        messageRecord.nuisanceGasLeft = uint(-1);\n\n        messageContext.ovmADDRESS = _from;\n\n        bool isCreate = _transaction.entrypoint == address(0);\n        if (isCreate) {\n            (address created, bytes memory revertData) = ovmCREATE(_transaction.data);\n            if (created == address(0)) {\n                return (false, revertData);\n            } else {\n                // The eth_call RPC endpoint for to = undefined will return the deployed bytecode\n                // in the success case, differing from standard create messages.\n                return (true, Lib_EthUtils.getCode(created));\n            }\n        } else {\n            return ovmCALL(\n                _transaction.gasLimit,\n                _transaction.entrypoint,\n                _transaction.data\n            );\n        }\n    }\n}\n"
    },
    "contracts/optimistic-ethereum/OVM/predeploys/OVM_DeployerWhitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/* Library Imports */\nimport { Lib_Bytes32Utils } from \"../../libraries/utils/Lib_Bytes32Utils.sol\";\n\n/* Interface Imports */\nimport { iOVM_DeployerWhitelist } from \"../../iOVM/predeploys/iOVM_DeployerWhitelist.sol\";\nimport { Lib_SafeExecutionManagerWrapper } from \"../../libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\";\n\n/**\n * @title OVM_DeployerWhitelist\n * @dev The Deployer Whitelist is a temporary predeploy used to provide additional safety during the\n * initial phases of our mainnet roll out. It is owned by the Optimism team, and defines accounts\n * which are allowed to deploy contracts on Layer2. The Execution Manager will only allow an \n * ovmCREATE or ovmCREATE2 operation to proceed if the deployer's address whitelisted.\n * \n * Compiler used: solc\n * Runtime target: OVM\n */\ncontract OVM_DeployerWhitelist is iOVM_DeployerWhitelist {\n\n    /**********************\n     * Contract Constants *\n     **********************/\n\n    bytes32 internal constant KEY_INITIALIZED =                0x0000000000000000000000000000000000000000000000000000000000000010;\n    bytes32 internal constant KEY_OWNER =                      0x0000000000000000000000000000000000000000000000000000000000000011;\n    bytes32 internal constant KEY_ALLOW_ARBITRARY_DEPLOYMENT = 0x0000000000000000000000000000000000000000000000000000000000000012;\n\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n    \n    /**\n     * Blocks functions to anyone except the contract owner.\n     */\n    modifier onlyOwner() {\n        address owner = Lib_Bytes32Utils.toAddress(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                KEY_OWNER\n            )\n        );\n\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            Lib_SafeExecutionManagerWrapper.safeCALLER() == owner,\n            \"Function can only be called by the owner of this contract.\"\n        );\n        _;\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n    \n    /**\n     * Initializes the whitelist.\n     * @param _owner Address of the owner for this contract.\n     * @param _allowArbitraryDeployment Whether or not to allow arbitrary contract deployment.\n     */\n    function initialize(\n        address _owner,\n        bool _allowArbitraryDeployment\n    )\n        override\n        public\n    {\n        bool initialized = Lib_Bytes32Utils.toBool(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(KEY_INITIALIZED)\n        );\n\n        if (initialized == true) {\n            return;\n        }\n\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            KEY_INITIALIZED,\n            Lib_Bytes32Utils.fromBool(true)\n        );\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            KEY_OWNER,\n            Lib_Bytes32Utils.fromAddress(_owner)\n        );\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            KEY_ALLOW_ARBITRARY_DEPLOYMENT,\n            Lib_Bytes32Utils.fromBool(_allowArbitraryDeployment)\n        );\n    }\n\n    /**\n     * Gets the owner of the whitelist.\n     */\n    function getOwner()\n        override\n        public\n        returns(\n            address\n        )\n    {\n        return Lib_Bytes32Utils.toAddress(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                KEY_OWNER\n            )\n        );\n    }\n\n    /**\n     * Adds or removes an address from the deployment whitelist.\n     * @param _deployer Address to update permissions for.\n     * @param _isWhitelisted Whether or not the address is whitelisted.\n     */\n    function setWhitelistedDeployer(\n        address _deployer,\n        bool _isWhitelisted\n    )\n        override\n        public\n        onlyOwner\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            Lib_Bytes32Utils.fromAddress(_deployer),\n            Lib_Bytes32Utils.fromBool(_isWhitelisted)\n        );\n    }\n\n    /**\n     * Updates the owner of this contract.\n     * @param _owner Address of the new owner.\n     */\n    function setOwner(\n        address _owner\n    )\n        override\n        public\n        onlyOwner\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            KEY_OWNER,\n            Lib_Bytes32Utils.fromAddress(_owner)\n        );\n    }\n\n    /**\n     * Updates the arbitrary deployment flag.\n     * @param _allowArbitraryDeployment Whether or not to allow arbitrary contract deployment.\n     */\n    function setAllowArbitraryDeployment(\n        bool _allowArbitraryDeployment\n    )\n        override\n        public\n        onlyOwner\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            KEY_ALLOW_ARBITRARY_DEPLOYMENT,\n            Lib_Bytes32Utils.fromBool(_allowArbitraryDeployment)\n        );\n    }\n\n    /**\n     * Permanently enables arbitrary contract deployment and deletes the owner.\n     */\n    function enableArbitraryContractDeployment()\n        override\n        public\n        onlyOwner\n    {\n        setAllowArbitraryDeployment(true);\n        setOwner(address(0));\n    }\n\n    /**\n     * Checks whether an address is allowed to deploy contracts.\n     * @param _deployer Address to check.\n     * @return _allowed Whether or not the address can deploy contracts.\n     */\n    function isDeployerAllowed(\n        address _deployer\n    )\n        override\n        public\n        returns (\n            bool _allowed\n        )\n    {\n        bool initialized = Lib_Bytes32Utils.toBool(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(KEY_INITIALIZED)\n        );\n\n        if (initialized == false) {\n            return true;\n        }\n\n        bool allowArbitraryDeployment = Lib_Bytes32Utils.toBool(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(KEY_ALLOW_ARBITRARY_DEPLOYMENT)\n        );\n\n        if (allowArbitraryDeployment == true) {\n            return true;\n        }\n\n        bool isWhitelisted = Lib_Bytes32Utils.toBool(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                Lib_Bytes32Utils.fromAddress(_deployer)\n            )\n        );\n\n        return isWhitelisted;        \n    }\n}\n"
    },
    "contracts/optimistic-ethereum/iOVM/accounts/iOVM_ECDSAContractAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\n\n/**\n * @title iOVM_ECDSAContractAccount\n */\ninterface iOVM_ECDSAContractAccount {\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function execute(\n        bytes memory _transaction,\n        Lib_OVMCodec.EOASignatureType _signatureType,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (bool _success, bytes memory _returndata);\n}\n"
    },
    "contracts/optimistic-ethereum/iOVM/chain/iOVM_CanonicalTransactionChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\n\n/* Interface Imports */\nimport { iOVM_ChainStorageContainer } from \"./iOVM_ChainStorageContainer.sol\";\n\n/**\n * @title iOVM_CanonicalTransactionChain\n */\ninterface iOVM_CanonicalTransactionChain {\n\n    /**********\n     * Events *\n     **********/\n\n    event TransactionEnqueued(\n        address _l1TxOrigin,\n        address _target,\n        uint256 _gasLimit,\n        bytes _data,\n        uint256 _queueIndex,\n        uint256 _timestamp\n    );\n\n    event QueueBatchAppended(\n        uint256 _startingQueueIndex,\n        uint256 _numQueueElements,\n        uint256 _totalElements\n    );\n\n    event SequencerBatchAppended(\n        uint256 _startingQueueIndex,\n        uint256 _numQueueElements,\n        uint256 _totalElements\n    );\n\n    event TransactionBatchAppended(\n        uint256 indexed _batchIndex,\n        bytes32 _batchRoot,\n        uint256 _batchSize,\n        uint256 _prevTotalElements,\n        bytes _extraData\n    );\n\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct BatchContext {\n        uint256 numSequencedTransactions;\n        uint256 numSubsequentQueueTransactions;\n        uint256 timestamp;\n        uint256 blockNumber;\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n\n    /**\n     * Accesses the batch storage container.\n     * @return Reference to the batch storage container.\n     */\n    function batches()\n        external\n        view\n        returns (\n            iOVM_ChainStorageContainer\n        );\n\n    /**\n     * Accesses the queue storage container.\n     * @return Reference to the queue storage container.\n     */\n    function queue()\n        external\n        view\n        returns (\n            iOVM_ChainStorageContainer\n        );\n\n    /**\n     * Retrieves the total number of elements submitted.\n     * @return _totalElements Total submitted elements.\n     */\n    function getTotalElements()\n        external\n        view\n        returns (\n            uint256 _totalElements\n        );\n\n    /**\n     * Retrieves the total number of batches submitted.\n     * @return _totalBatches Total submitted batches.\n     */\n    function getTotalBatches()\n        external\n        view\n        returns (\n            uint256 _totalBatches\n        );\n\n    /**\n     * Returns the index of the next element to be enqueued.\n     * @return Index for the next queue element.\n     */\n    function getNextQueueIndex()\n        external\n        view\n        returns (\n            uint40\n        );\n\n    /**\n     * Gets the queue element at a particular index.\n     * @param _index Index of the queue element to access.\n     * @return _element Queue element at the given index.\n     */\n    function getQueueElement(\n        uint256 _index\n    )\n        external\n        view\n        returns (\n            Lib_OVMCodec.QueueElement memory _element\n        );\n\n    /**\n     * Returns the timestamp of the last transaction.\n     * @return Timestamp for the last transaction.\n     */\n    function getLastTimestamp()\n        external\n        view\n        returns (\n            uint40\n        );\n\n    /**\n     * Returns the blocknumber of the last transaction.\n     * @return Blocknumber for the last transaction.\n     */\n    function getLastBlockNumber()\n        external\n        view\n        returns (\n            uint40\n        );\n\n    /**\n     * Get the number of queue elements which have not yet been included.\n     * @return Number of pending queue elements.\n     */\n    function getNumPendingQueueElements()\n        external\n        view\n        returns (\n            uint40\n        );\n\n    /**\n     * Retrieves the length of the queue, including\n     * both pending and canonical transactions.\n     * @return Length of the queue.\n     */\n    function getQueueLength()\n        external\n        view\n        returns (\n            uint40\n        );\n\n\n    /**\n     * Adds a transaction to the queue.\n     * @param _target Target contract to send the transaction to.\n     * @param _gasLimit Gas limit for the given transaction.\n     * @param _data Transaction data.\n     */\n    function enqueue(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    )\n        external;\n\n    /**\n     * Appends a given number of queued transactions as a single batch.\n     * @param _numQueuedTransactions Number of transactions to append.\n     */\n    function appendQueueBatch(\n        uint256 _numQueuedTransactions\n    )\n        external;\n\n    /**\n     * Allows the sequencer to append a batch of transactions.\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\n     * .param _contexts Array of batch contexts.\n     * .param _transactionDataFields Array of raw transaction data.\n     */\n    function appendSequencerBatch(\n        // uint40 _shouldStartAtElement,\n        // uint24 _totalElementsToAppend,\n        // BatchContext[] _contexts,\n        // bytes[] _transactionDataFields\n    )\n        external;\n\n    /**\n     * Verifies whether a transaction is included in the chain.\n     * @param _transaction Transaction to verify.\n     * @param _txChainElement Transaction chain element corresponding to the transaction.\n     * @param _batchHeader Header of the batch the transaction was included in.\n     * @param _inclusionProof Inclusion proof for the provided transaction chain element.\n     * @return True if the transaction exists in the CTC, false if not.\n     */\n    function verifyTransaction(\n        Lib_OVMCodec.Transaction memory _transaction,\n        Lib_OVMCodec.TransactionChainElement memory _txChainElement,\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _inclusionProof\n    )\n        external\n        view\n        returns (\n            bool\n        );\n}\n"
    },
    "contracts/optimistic-ethereum/iOVM/chain/iOVM_ChainStorageContainer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/**\n * @title iOVM_ChainStorageContainer\n */\ninterface iOVM_ChainStorageContainer {\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sets the container's global metadata field. We're using `bytes27` here because we use five\n     * bytes to maintain the length of the underlying data structure, meaning we have an extra\n     * 27 bytes to store arbitrary data.\n     * @param _globalMetadata New global metadata to set.\n     */\n    function setGlobalMetadata(\n        bytes27 _globalMetadata\n    )\n        external;\n\n    /**\n     * Retrieves the container's global metadata field.\n     * @return Container global metadata field.\n     */\n    function getGlobalMetadata()\n        external\n        view\n        returns (\n            bytes27\n        );\n\n    /**\n     * Retrieves the number of objects stored in the container.\n     * @return Number of objects in the container.\n     */\n    function length()\n        external\n        view\n        returns (\n            uint256\n        );\n\n    /**\n     * Pushes an object into the container.\n     * @param _object A 32 byte value to insert into the container.\n     */\n    function push(\n        bytes32 _object\n    )\n        external;\n\n    /**\n     * Pushes an object into the container. Function allows setting the global metadata since\n     * we'll need to touch the \"length\" storage slot anyway, which also contains the global\n     * metadata (it's an optimization).\n     * @param _object A 32 byte value to insert into the container.\n     * @param _globalMetadata New global metadata for the container.\n     */\n    function push(\n        bytes32 _object,\n        bytes27 _globalMetadata\n    )\n        external;\n\n    /**\n     * Retrieves an object from the container.\n     * @param _index Index of the particular object to access.\n     * @return 32 byte object value.\n     */\n    function get(\n        uint256 _index\n    )\n        external\n        view\n        returns (\n            bytes32\n        );\n\n    /**\n     * Removes all objects after and including a given index.\n     * @param _index Object index to delete from.\n     */\n    function deleteElementsAfterInclusive(\n        uint256 _index\n    )\n        external;\n\n    /**\n     * Removes all objects after and including a given index. Also allows setting the global\n     * metadata field.\n     * @param _index Object index to delete from.\n     * @param _globalMetadata New global metadata for the container.\n     */\n    function deleteElementsAfterInclusive(\n        uint256 _index,\n        bytes27 _globalMetadata\n    )\n        external;\n\n    /**\n     * Marks an index as overwritable, meaing the underlying buffer can start to write values over\n     * any objects before and including the given index.\n     */\n    function setNextOverwritableIndex(\n        uint256 _index\n    )\n        external;\n}\n"
    },
    "contracts/optimistic-ethereum/iOVM/execution/iOVM_ExecutionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\n\ninterface iOVM_ExecutionManager {\n    /**********\n     * Enums *\n     *********/\n\n    enum RevertFlag {\n        OUT_OF_GAS,\n        INTENTIONAL_REVERT,\n        EXCEEDS_NUISANCE_GAS,\n        INVALID_STATE_ACCESS,\n        UNSAFE_BYTECODE,\n        CREATE_COLLISION,\n        STATIC_VIOLATION,\n        CREATOR_NOT_ALLOWED\n    }\n\n    enum GasMetadataKey {\n        CURRENT_EPOCH_START_TIMESTAMP,\n        CUMULATIVE_SEQUENCER_QUEUE_GAS,\n        CUMULATIVE_L1TOL2_QUEUE_GAS,\n        PREV_EPOCH_SEQUENCER_QUEUE_GAS,\n        PREV_EPOCH_L1TOL2_QUEUE_GAS\n    }\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct GasMeterConfig {\n        uint256 minTransactionGasLimit;\n        uint256 maxTransactionGasLimit;\n        uint256 maxGasPerQueuePerEpoch;\n        uint256 secondsPerEpoch;\n    }\n\n    struct GlobalContext {\n        uint256 ovmCHAINID;\n    }\n\n    struct TransactionContext {\n        Lib_OVMCodec.QueueOrigin ovmL1QUEUEORIGIN;\n        uint256 ovmTIMESTAMP;\n        uint256 ovmNUMBER;\n        uint256 ovmGASLIMIT;\n        uint256 ovmTXGASLIMIT;\n        address ovmL1TXORIGIN;\n    }\n\n    struct TransactionRecord {\n        uint256 ovmGasRefund;\n    }\n\n    struct MessageContext {\n        address ovmCALLER;\n        address ovmADDRESS;\n        bool isStatic;\n    }\n\n    struct MessageRecord {\n        uint256 nuisanceGasLeft;\n    }\n\n\n    /************************************\n     * Transaction Execution Entrypoint *\n     ************************************/\n\n    function run(\n        Lib_OVMCodec.Transaction calldata _transaction,\n        address _txStateManager\n    ) external;\n\n\n    /*******************\n     * Context Opcodes *\n     *******************/\n\n    function ovmCALLER() external view returns (address _caller);\n    function ovmADDRESS() external view returns (address _address);\n    function ovmTIMESTAMP() external view returns (uint256 _timestamp);\n    function ovmNUMBER() external view returns (uint256 _number);\n    function ovmGASLIMIT() external view returns (uint256 _gasLimit);\n    function ovmCHAINID() external view returns (uint256 _chainId);\n\n\n    /**********************\n     * L2 Context Opcodes *\n     **********************/\n\n    function ovmL1QUEUEORIGIN() external view returns (Lib_OVMCodec.QueueOrigin _queueOrigin);\n    function ovmL1TXORIGIN() external view returns (address _l1TxOrigin);\n\n\n    /*******************\n     * Halting Opcodes *\n     *******************/\n\n    function ovmREVERT(bytes memory _data) external;\n\n\n    /*****************************\n     * Contract Creation Opcodes *\n     *****************************/\n\n    function ovmCREATE(bytes memory _bytecode) external returns (address _contract, bytes memory _revertdata);\n    function ovmCREATE2(bytes memory _bytecode, bytes32 _salt) external returns (address _contract, bytes memory _revertdata);\n\n\n    /*******************************\n     * Account Abstraction Opcodes *\n     ******************************/\n\n    function ovmGETNONCE() external returns (uint256 _nonce);\n    function ovmINCREMENTNONCE() external;\n    function ovmCREATEEOA(bytes32 _messageHash, uint8 _v, bytes32 _r, bytes32 _s) external;\n\n\n    /****************************\n     * Contract Calling Opcodes *\n     ****************************/\n\n    function ovmCALL(uint256 _gasLimit, address _address, bytes memory _calldata) external returns (bool _success, bytes memory _returndata);\n    function ovmSTATICCALL(uint256 _gasLimit, address _address, bytes memory _calldata) external returns (bool _success, bytes memory _returndata);\n    function ovmDELEGATECALL(uint256 _gasLimit, address _address, bytes memory _calldata) external returns (bool _success, bytes memory _returndata);\n\n\n    /****************************\n     * Contract Storage Opcodes *\n     ****************************/\n\n    function ovmSLOAD(bytes32 _key) external returns (bytes32 _value);\n    function ovmSSTORE(bytes32 _key, bytes32 _value) external;\n\n\n    /*************************\n     * Contract Code Opcodes *\n     *************************/\n\n    function ovmEXTCODECOPY(address _contract, uint256 _offset, uint256 _length) external returns (bytes memory _code);\n    function ovmEXTCODESIZE(address _contract) external returns (uint256 _size);\n    function ovmEXTCODEHASH(address _contract) external returns (bytes32 _hash);\n\n\n    /***************************************\n     * Public Functions: Execution Context *\n     ***************************************/\n\n    function getMaxTransactionGasLimit() external view returns (uint _maxTransactionGasLimit);\n}\n"
    },
    "contracts/optimistic-ethereum/iOVM/execution/iOVM_SafetyChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/**\n * @title iOVM_SafetyChecker\n */\ninterface iOVM_SafetyChecker {\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function isBytecodeSafe(bytes calldata _bytecode) external pure returns (bool);\n}\n"
    },
    "contracts/optimistic-ethereum/iOVM/execution/iOVM_StateManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\n\n/**\n * @title iOVM_StateManager\n */\ninterface iOVM_StateManager {\n\n    /*******************\n     * Data Structures *\n     *******************/\n\n    enum ItemState {\n        ITEM_UNTOUCHED,\n        ITEM_LOADED,\n        ITEM_CHANGED,\n        ITEM_COMMITTED\n    }\n\n    /***************************\n     * Public Functions: Misc *\n     ***************************/\n\n    function isAuthenticated(address _address) external view returns (bool);\n\n    /***************************\n     * Public Functions: Setup *\n     ***************************/\n\n    function owner() external view returns (address _owner);\n    function ovmExecutionManager() external view returns (address _ovmExecutionManager);\n    function setExecutionManager(address _ovmExecutionManager) external;\n\n\n    /************************************\n     * Public Functions: Account Access *\n     ************************************/\n\n    function putAccount(address _address, Lib_OVMCodec.Account memory _account) external;\n    function putEmptyAccount(address _address) external;\n    function getAccount(address _address) external view returns (Lib_OVMCodec.Account memory _account);\n    function hasAccount(address _address) external view returns (bool _exists);\n    function hasEmptyAccount(address _address) external view returns (bool _exists);\n    function setAccountNonce(address _address, uint256 _nonce) external;\n    function getAccountNonce(address _address) external view returns (uint256 _nonce);\n    function getAccountEthAddress(address _address) external view returns (address _ethAddress);\n    function getAccountStorageRoot(address _address) external view returns (bytes32 _storageRoot);\n    function initPendingAccount(address _address) external;\n    function commitPendingAccount(address _address, address _ethAddress, bytes32 _codeHash) external;\n    function testAndSetAccountLoaded(address _address) external returns (bool _wasAccountAlreadyLoaded);\n    function testAndSetAccountChanged(address _address) external returns (bool _wasAccountAlreadyChanged);\n    function commitAccount(address _address) external returns (bool _wasAccountCommitted);\n    function incrementTotalUncommittedAccounts() external;\n    function getTotalUncommittedAccounts() external view returns (uint256 _total);\n    function wasAccountChanged(address _address) external view returns (bool);\n    function wasAccountCommitted(address _address) external view returns (bool);\n\n\n    /************************************\n     * Public Functions: Storage Access *\n     ************************************/\n\n    function putContractStorage(address _contract, bytes32 _key, bytes32 _value) external;\n    function getContractStorage(address _contract, bytes32 _key) external view returns (bytes32 _value);\n    function hasContractStorage(address _contract, bytes32 _key) external view returns (bool _exists);\n    function testAndSetContractStorageLoaded(address _contract, bytes32 _key) external returns (bool _wasContractStorageAlreadyLoaded);\n    function testAndSetContractStorageChanged(address _contract, bytes32 _key) external returns (bool _wasContractStorageAlreadyChanged);\n    function commitContractStorage(address _contract, bytes32 _key) external returns (bool _wasContractStorageCommitted);\n    function incrementTotalUncommittedContractStorage() external;\n    function getTotalUncommittedContractStorage() external view returns (uint256 _total);\n    function wasContractStorageChanged(address _contract, bytes32 _key) external view returns (bool);\n    function wasContractStorageCommitted(address _contract, bytes32 _key) external view returns (bool);\n}\n"
    },
    "contracts/optimistic-ethereum/iOVM/predeploys/iOVM_DeployerWhitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/**\n * @title iOVM_DeployerWhitelist\n */\ninterface iOVM_DeployerWhitelist {\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function initialize(address _owner, bool _allowArbitraryDeployment) external;\n    function getOwner() external returns (address _owner);\n    function setWhitelistedDeployer(address _deployer, bool _isWhitelisted) external;\n    function setOwner(address _newOwner) external;\n    function setAllowArbitraryDeployment(bool _allowArbitraryDeployment) external;\n    function enableArbitraryContractDeployment() external;\n    function isDeployerAllowed(address _deployer) external returns (bool _allowed);\n}\n"
    },
    "contracts/optimistic-ethereum/libraries/codec/Lib_OVMCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_RLPReader } from \"../rlp/Lib_RLPReader.sol\";\nimport { Lib_RLPWriter } from \"../rlp/Lib_RLPWriter.sol\";\nimport { Lib_BytesUtils } from \"../utils/Lib_BytesUtils.sol\";\nimport { Lib_Bytes32Utils } from \"../utils/Lib_Bytes32Utils.sol\";\nimport { Lib_SafeExecutionManagerWrapper } from \"../../libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\";\n\n/**\n * @title Lib_OVMCodec\n */\nlibrary Lib_OVMCodec {\n\n    /*********\n     * Enums *\n     *********/\n\n    enum EOASignatureType {\n        EIP155_TRANSACTION,\n        ETH_SIGNED_MESSAGE\n    }\n\n    enum QueueOrigin {\n        SEQUENCER_QUEUE,\n        L1TOL2_QUEUE\n    }\n\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct Account {\n        uint256 nonce;\n        uint256 balance;\n        bytes32 storageRoot;\n        bytes32 codeHash;\n        address ethAddress;\n        bool isFresh;\n    }\n\n    struct EVMAccount {\n        uint256 nonce;\n        uint256 balance;\n        bytes32 storageRoot;\n        bytes32 codeHash;\n    }\n\n    struct ChainBatchHeader {\n        uint256 batchIndex;\n        bytes32 batchRoot;\n        uint256 batchSize;\n        uint256 prevTotalElements;\n        bytes extraData;\n    }\n\n    struct ChainInclusionProof {\n        uint256 index;\n        bytes32[] siblings;\n    }\n\n    struct Transaction {\n        uint256 timestamp;\n        uint256 blockNumber;\n        QueueOrigin l1QueueOrigin;\n        address l1TxOrigin;\n        address entrypoint;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    struct TransactionChainElement {\n        bool isSequenced;\n        uint256 queueIndex;  // QUEUED TX ONLY\n        uint256 timestamp;   // SEQUENCER TX ONLY\n        uint256 blockNumber; // SEQUENCER TX ONLY\n        bytes txData;        // SEQUENCER TX ONLY\n    }\n\n    struct QueueElement {\n        bytes32 transactionHash;\n        uint40 timestamp;\n        uint40 blockNumber;\n    }\n\n    struct EIP155Transaction {\n        uint256 nonce;\n        uint256 gasPrice;\n        uint256 gasLimit;\n        address to;\n        uint256 value;\n        bytes data;\n        uint256 chainId;\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Decodes an EOA transaction (i.e., native Ethereum RLP encoding).\n     * @param _transaction Encoded EOA transaction.\n     * @return Transaction decoded into a struct.\n     */\n    function decodeEIP155Transaction(\n        bytes memory _transaction,\n        bool _isEthSignedMessage\n    )\n        internal\n        pure\n        returns (\n            EIP155Transaction memory\n        )\n    {\n        if (_isEthSignedMessage) {\n            (\n                uint256 _nonce,\n                uint256 _gasLimit,\n                uint256 _gasPrice,\n                uint256 _chainId,\n                address _to,\n                bytes memory _data\n            ) = abi.decode(\n                _transaction,\n                (uint256, uint256, uint256, uint256, address ,bytes)\n            );\n            return EIP155Transaction({\n                nonce: _nonce,\n                gasPrice: _gasPrice,\n                gasLimit: _gasLimit,\n                to: _to,\n                value: 0,\n                data: _data,\n                chainId: _chainId\n            });\n        } else {\n            Lib_RLPReader.RLPItem[] memory decoded = Lib_RLPReader.readList(_transaction);\n\n            return EIP155Transaction({\n                nonce: Lib_RLPReader.readUint256(decoded[0]),\n                gasPrice: Lib_RLPReader.readUint256(decoded[1]),\n                gasLimit: Lib_RLPReader.readUint256(decoded[2]),\n                to: Lib_RLPReader.readAddress(decoded[3]),\n                value: Lib_RLPReader.readUint256(decoded[4]),\n                data: Lib_RLPReader.readBytes(decoded[5]),\n                chainId:  Lib_RLPReader.readUint256(decoded[6])\n            });\n        }\n    }\n\n    /**\n     * Decompresses a compressed EIP155 transaction.\n     * @param _transaction Compressed EIP155 transaction bytes.\n     * @return Transaction parsed into a struct.\n     */\n    function decompressEIP155Transaction(\n        bytes memory _transaction\n    )\n        internal\n        returns (\n            EIP155Transaction memory\n        )\n    {\n        return EIP155Transaction({\n            gasLimit: Lib_BytesUtils.toUint24(_transaction, 0),\n            gasPrice: uint256(Lib_BytesUtils.toUint24(_transaction, 3)) * 1000000,\n            nonce: Lib_BytesUtils.toUint24(_transaction, 6),\n            to: Lib_BytesUtils.toAddress(_transaction, 9),\n            data: Lib_BytesUtils.slice(_transaction, 29),\n            chainId: Lib_SafeExecutionManagerWrapper.safeCHAINID(),\n            value: 0\n        });\n    }\n\n    /**\n     * Encodes an EOA transaction back into the original transaction.\n     * @param _transaction EIP155transaction to encode.\n     * @param _isEthSignedMessage Whether or not this was an eth signed message.\n     * @return Encoded transaction.\n     */\n    function encodeEIP155Transaction(\n        EIP155Transaction memory _transaction,\n        bool _isEthSignedMessage\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        if (_isEthSignedMessage) {\n            return abi.encode(\n                _transaction.nonce,\n                _transaction.gasLimit,\n                _transaction.gasPrice,\n                _transaction.chainId,\n                _transaction.to,\n                _transaction.data\n            );\n        } else {\n            bytes[] memory raw = new bytes[](9);\n\n            raw[0] = Lib_RLPWriter.writeUint(_transaction.nonce);\n            raw[1] = Lib_RLPWriter.writeUint(_transaction.gasPrice);\n            raw[2] = Lib_RLPWriter.writeUint(_transaction.gasLimit);\n            if (_transaction.to == address(0)) {\n                raw[3] = Lib_RLPWriter.writeBytes('');\n            } else {\n                raw[3] = Lib_RLPWriter.writeAddress(_transaction.to);\n            }\n            raw[4] = Lib_RLPWriter.writeUint(0);\n            raw[5] = Lib_RLPWriter.writeBytes(_transaction.data);\n            raw[6] = Lib_RLPWriter.writeUint(_transaction.chainId);\n            raw[7] = Lib_RLPWriter.writeBytes(bytes(''));\n            raw[8] = Lib_RLPWriter.writeBytes(bytes(''));\n\n            return Lib_RLPWriter.writeList(raw);\n        }\n    }\n\n    /**\n     * Encodes a standard OVM transaction.\n     * @param _transaction OVM transaction to encode.\n     * @return Encoded transaction bytes.\n     */\n    function encodeTransaction(\n        Transaction memory _transaction\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return abi.encodePacked(\n            _transaction.timestamp,\n            _transaction.blockNumber,\n            _transaction.l1QueueOrigin,\n            _transaction.l1TxOrigin,\n            _transaction.entrypoint,\n            _transaction.gasLimit,\n            _transaction.data\n        );\n    }\n\n    /**\n     * Hashes a standard OVM transaction.\n     * @param _transaction OVM transaction to encode.\n     * @return Hashed transaction\n     */\n    function hashTransaction(\n        Transaction memory _transaction\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return keccak256(encodeTransaction(_transaction));\n    }\n\n    /**\n     * Converts an OVM account to an EVM account.\n     * @param _in OVM account to convert.\n     * @return Converted EVM account.\n     */\n    function toEVMAccount(\n        Account memory _in\n    )\n        internal\n        pure\n        returns (\n            EVMAccount memory\n        )\n    {\n        return EVMAccount({\n            nonce: _in.nonce,\n            balance: _in.balance,\n            storageRoot: _in.storageRoot,\n            codeHash: _in.codeHash\n        });\n    }\n\n    /**\n     * @notice RLP-encodes an account state struct.\n     * @param _account Account state struct.\n     * @return RLP-encoded account state.\n     */\n    function encodeEVMAccount(\n        EVMAccount memory _account\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        bytes[] memory raw = new bytes[](4);\n\n        // Unfortunately we can't create this array outright because\n        // Lib_RLPWriter.writeList will reject fixed-size arrays. Assigning\n        // index-by-index circumvents this issue.\n        raw[0] = Lib_RLPWriter.writeBytes(\n            Lib_Bytes32Utils.removeLeadingZeros(\n                bytes32(_account.nonce)\n            )\n        );\n        raw[1] = Lib_RLPWriter.writeBytes(\n            Lib_Bytes32Utils.removeLeadingZeros(\n                bytes32(_account.balance)\n            )\n        );\n        raw[2] = Lib_RLPWriter.writeBytes(abi.encodePacked(_account.storageRoot));\n        raw[3] = Lib_RLPWriter.writeBytes(abi.encodePacked(_account.codeHash));\n\n        return Lib_RLPWriter.writeList(raw);\n    }\n\n    /**\n     * @notice Decodes an RLP-encoded account state into a useful struct.\n     * @param _encoded RLP-encoded account state.\n     * @return Account state struct.\n     */\n    function decodeEVMAccount(\n        bytes memory _encoded\n    )\n        internal\n        pure\n        returns (\n            EVMAccount memory\n        )\n    {\n        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);\n\n        return EVMAccount({\n            nonce: Lib_RLPReader.readUint256(accountState[0]),\n            balance: Lib_RLPReader.readUint256(accountState[1]),\n            storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\n            codeHash: Lib_RLPReader.readBytes32(accountState[3])\n        });\n    }\n\n    /**\n     * Calculates a hash for a given batch header.\n     * @param _batchHeader Header to hash.\n     * @return Hash of the header.\n     */\n    function hashBatchHeader(\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return keccak256(\n            abi.encode(\n                _batchHeader.batchRoot,\n                _batchHeader.batchSize,\n                _batchHeader.prevTotalElements,\n                _batchHeader.extraData\n            )\n        );\n    }\n}\n"
    },
    "contracts/optimistic-ethereum/libraries/resolver/Lib_AddressManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/* Contract Imports */\nimport { Ownable } from \"./Lib_Ownable.sol\";\n\n/**\n * @title Lib_AddressManager\n */\ncontract Lib_AddressManager is Ownable {\n\n    /**********\n     * Events *\n     **********/\n\n    event AddressSet(\n        string _name,\n        address _newAddress\n    );\n\n    /*******************************************\n     * Contract Variables: Internal Accounting *\n     *******************************************/\n\n    mapping (bytes32 => address) private addresses;\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function setAddress(\n        string memory _name,\n        address _address\n    )\n        public\n        onlyOwner\n    {\n        emit AddressSet(_name, _address);\n        addresses[_getNameHash(_name)] = _address;\n    }\n\n    function getAddress(\n        string memory _name\n    )\n        public\n        view\n        returns (address)\n    {\n        return addresses[_getNameHash(_name)];\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _getNameHash(\n        string memory _name\n    )\n        internal\n        pure\n        returns (\n            bytes32 _hash\n        )\n    {\n        return keccak256(abi.encodePacked(_name));\n    }\n}\n"
    },
    "contracts/optimistic-ethereum/libraries/resolver/Lib_AddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/* Library Imports */\nimport { Lib_AddressManager } from \"./Lib_AddressManager.sol\";\n\n/**\n * @title Lib_AddressResolver\n */\nabstract contract Lib_AddressResolver {\n\n    /*******************************************\n     * Contract Variables: Contract References *\n     *******************************************/\n\n    Lib_AddressManager public libAddressManager;\n\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Lib_AddressManager.\n     */\n    constructor(\n        address _libAddressManager\n    )  {\n        libAddressManager = Lib_AddressManager(_libAddressManager);\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function resolve(\n        string memory _name\n    )\n        public\n        view\n        returns (\n            address _contract\n        )\n    {\n        return libAddressManager.getAddress(_name);\n    }\n}\n"
    },
    "contracts/optimistic-ethereum/libraries/resolver/Lib_Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/**\n * @title Ownable\n * @dev Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n */\nabstract contract Ownable {\n\n    /*************\n     * Variables *\n     *************/\n\n    address public owner;\n\n\n    /**********\n     * Events *\n     **********/\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyOwner() {\n        require(\n            owner == msg.sender,\n            \"Ownable: caller is not the owner\"\n        );\n        _;\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function renounceOwnership()\n        public\n        virtual\n        onlyOwner\n    {\n        emit OwnershipTransferred(owner, address(0));\n        owner = address(0);\n    }\n\n    function transferOwnership(address _newOwner)\n        public\n        virtual\n        onlyOwner\n    {\n        require(\n            _newOwner != address(0),\n            \"Ownable: new owner cannot be the zero address\"\n        );\n\n        emit OwnershipTransferred(owner, _newOwner);\n        owner = _newOwner;\n    }\n}\n"
    },
    "contracts/optimistic-ethereum/libraries/rlp/Lib_RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/**\n * @title Lib_RLPReader\n * @dev Adapted from \"RLPReader\" by Hamdi Allam (hamdi.allam97@gmail.com).\n */\nlibrary Lib_RLPReader {\n\n    /*************\n     * Constants *\n     *************/\n\n    uint256 constant internal MAX_LIST_LENGTH = 32;\n\n\n    /*********\n     * Enums *\n     *********/\n\n    enum RLPItemType {\n        DATA_ITEM,\n        LIST_ITEM\n    }\n\n    \n    /***********\n     * Structs *\n     ***********/\n\n    struct RLPItem {\n        uint256 length;\n        uint256 ptr;\n    }\n    \n\n    /**********************\n     * Internal Functions *\n     **********************/\n    \n    /**\n     * Converts bytes to a reference to memory position and length.\n     * @param _in Input bytes to convert.\n     * @return Output memory reference.\n     */\n    function toRLPItem(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            RLPItem memory\n        )\n    {\n        uint256 ptr;\n        assembly {\n            ptr := add(_in, 32)\n        }\n\n        return RLPItem({\n            length: _in.length,\n            ptr: ptr\n        });\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            RLPItem[] memory\n        )\n    {\n        (\n            uint256 listOffset,\n            ,\n            RLPItemType itemType\n        ) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.LIST_ITEM,\n            \"Invalid RLP list value.\"\n        );\n\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\n        // writing to the length. Since we can't know the number of RLP items without looping over\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\n        // simply set a reasonable maximum list length and decrease the size before we finish.\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\n\n        uint256 itemCount = 0;\n        uint256 offset = listOffset;\n        while (offset < _in.length) {\n            require(\n                itemCount < MAX_LIST_LENGTH,\n                \"Provided RLP list exceeds max list length.\"\n            );\n\n            (\n                uint256 itemOffset,\n                uint256 itemLength,\n            ) = _decodeLength(RLPItem({\n                length: _in.length - offset,\n                ptr: _in.ptr + offset\n            }));\n\n            out[itemCount] = RLPItem({\n                length: itemLength + itemOffset,\n                ptr: _in.ptr + offset\n            });\n\n            itemCount += 1;\n            offset += itemOffset + itemLength;\n        }\n\n        // Decrease the array size to match the actual item count.\n        assembly {\n            mstore(out, itemCount)\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            RLPItem[] memory\n        )\n    {\n        return readList(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        (\n            uint256 itemOffset,\n            uint256 itemLength,\n            RLPItemType itemType\n        ) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.DATA_ITEM,\n            \"Invalid RLP bytes value.\"\n        );\n\n        return _copy(_in.ptr, itemOffset, itemLength);\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return readBytes(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            string memory\n        )\n    {\n        return string(readBytes(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            string memory\n        )\n    {\n        return readString(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        require(\n            _in.length <= 33,\n            \"Invalid RLP bytes32 value.\"\n        );\n\n        (\n            uint256 itemOffset,\n            uint256 itemLength,\n            RLPItemType itemType\n        ) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.DATA_ITEM,\n            \"Invalid RLP bytes32 value.\"\n        );\n\n        uint256 ptr = _in.ptr + itemOffset;\n        bytes32 out;\n        assembly {\n            out := mload(ptr)\n\n            // Shift the bytes over to match the item size.\n            if lt(itemLength, 32) {\n                out := div(out, exp(256, sub(32, itemLength)))\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return readBytes32(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            uint256\n        )\n    {\n        return uint256(readBytes32(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            uint256\n        )\n    {\n        return readUint256(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bool\n        )\n    {\n        require(\n            _in.length == 1,\n            \"Invalid RLP boolean value.\"\n        );\n\n        uint256 ptr = _in.ptr;\n        uint256 out;\n        assembly {\n            out := byte(0, mload(ptr))\n        }\n\n        require(\n            out == 0 || out == 1,\n            \"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\"\n        );\n\n        return out != 0;\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bool\n        )\n    {\n        return readBool(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            address\n        )\n    {\n        if (_in.length == 1) {\n            return address(0);\n        }\n\n        require(\n            _in.length == 21,\n            \"Invalid RLP address value.\"\n        );\n\n        return address(readUint256(_in));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            address\n        )\n    {\n        return readAddress(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads the raw bytes of an RLP item.\n     * @param _in RLP item to read.\n     * @return Raw RLP bytes.\n     */\n    function readRawBytes(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return _copy(_in);\n    }\n\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Decodes the length of an RLP item.\n     * @param _in RLP item to decode.\n     * @return Offset of the encoded data.\n     * @return Length of the encoded data.\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\n     */\n    function _decodeLength(\n        RLPItem memory _in\n    )\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            RLPItemType\n        )\n    {\n        require(\n            _in.length > 0,\n            \"RLP item cannot be null.\"\n        );\n\n        uint256 ptr = _in.ptr;\n        uint256 prefix;\n        assembly {\n            prefix := byte(0, mload(ptr))\n        }\n\n        if (prefix <= 0x7f) {\n            // Single byte.\n\n            return (0, 1, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xb7) {\n            // Short string.\n\n            uint256 strLen = prefix - 0x80;\n            \n            require(\n                _in.length > strLen,\n                \"Invalid RLP short string.\"\n            );\n\n            return (1, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xbf) {\n            // Long string.\n            uint256 lenOfStrLen = prefix - 0xb7;\n\n            require(\n                _in.length > lenOfStrLen,\n                \"Invalid RLP long string length.\"\n            );\n\n            uint256 strLen;\n            assembly {\n                // Pick out the string length.\n                strLen := div(\n                    mload(add(ptr, 1)),\n                    exp(256, sub(32, lenOfStrLen))\n                )\n            }\n\n            require(\n                _in.length > lenOfStrLen + strLen,\n                \"Invalid RLP long string.\"\n            );\n\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xf7) {\n            // Short list.\n            uint256 listLen = prefix - 0xc0;\n\n            require(\n                _in.length > listLen,\n                \"Invalid RLP short list.\"\n            );\n\n            return (1, listLen, RLPItemType.LIST_ITEM);\n        } else {\n            // Long list.\n            uint256 lenOfListLen = prefix - 0xf7;\n\n            require(\n                _in.length > lenOfListLen,\n                \"Invalid RLP long list length.\"\n            );\n\n            uint256 listLen;\n            assembly {\n                // Pick out the list length.\n                listLen := div(\n                    mload(add(ptr, 1)),\n                    exp(256, sub(32, lenOfListLen))\n                )\n            }\n\n            require(\n                _in.length > lenOfListLen + listLen,\n                \"Invalid RLP long list.\"\n            );\n\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\n        }\n    }\n\n    /**\n     * Copies the bytes from a memory location.\n     * @param _src Pointer to the location to read from.\n     * @param _offset Offset to start reading from.\n     * @param _length Number of bytes to read.\n     * @return Copied bytes.\n     */\n    function _copy(\n        uint256 _src,\n        uint256 _offset,\n        uint256 _length\n    )\n        private\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        bytes memory out = new bytes(_length);\n        if (out.length == 0) {\n            return out;\n        }\n\n        uint256 src = _src + _offset;\n        uint256 dest;\n        assembly {\n            dest := add(out, 32)\n        }\n\n        // Copy over as many complete words as we can.\n        for (uint256 i = 0; i < _length / 32; i++) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += 32;\n            dest += 32;\n        }\n\n        // Pick out the remaining bytes.\n        uint256 mask = 256 ** (32 - (_length % 32)) - 1;\n        assembly {\n            mstore(\n                dest,\n                or(\n                    and(mload(src), not(mask)),\n                    and(mload(dest), mask)\n                )\n            )\n        }\n\n        return out;\n    }\n\n    /**\n     * Copies an RLP item into bytes.\n     * @param _in RLP item to copy.\n     * @return Copied bytes.\n     */\n    function _copy(\n        RLPItem memory _in\n    )\n        private\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return _copy(_in.ptr, 0, _in.length);\n    }\n}\n"
    },
    "contracts/optimistic-ethereum/libraries/rlp/Lib_RLPWriter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_BytesUtils } from \"../utils/Lib_BytesUtils.sol\";\n\n/**\n * @title Lib_RLPWriter\n * @author Bakaoh (with modifications)\n */\nlibrary Lib_RLPWriter {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * RLP encodes a byte string.\n     * @param _in The byte string to encode.\n     * @return _out The RLP encoded string in bytes.\n     */\n    function writeBytes(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        bytes memory encoded;\n\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\n            encoded = _in;\n        } else {\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * RLP encodes a list of RLP encoded byte byte strings.\n     * @param _in The list of RLP encoded byte strings.\n     * @return _out The RLP encoded list of items in bytes.\n     */\n    function writeList(\n        bytes[] memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        bytes memory list = _flatten(_in);\n        return abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * RLP encodes a string.\n     * @param _in The string to encode.\n     * @return _out The RLP encoded string in bytes.\n     */\n    function writeString(\n        string memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        return writeBytes(bytes(_in));\n    }\n\n    /**\n     * RLP encodes an address.\n     * @param _in The address to encode.\n     * @return _out The RLP encoded address in bytes.\n     */\n    function writeAddress(\n        address _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * RLP encodes a uint.\n     * @param _in The uint256 to encode.\n     * @return _out The RLP encoded uint256 in bytes.\n     */\n    function writeUint(\n        uint256 _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        return writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * RLP encodes a bool.\n     * @param _in The bool to encode.\n     * @return _out The RLP encoded bool in bytes.\n     */\n    function writeBool(\n        bool _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\n     * @param _len The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     * @return _encoded RLP encoded bytes.\n     */\n    function _writeLength(\n        uint256 _len,\n        uint256 _offset\n    )\n        private\n        pure\n        returns (\n            bytes memory _encoded\n        )\n    {\n        bytes memory encoded;\n\n        if (_len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = byte(uint8(_len) + uint8(_offset));\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (_len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = byte(uint8(lenLen) + uint8(_offset) + 55);\n            for(i = 1; i <= lenLen; i++) {\n                encoded[i] = byte(uint8((_len / (256**(lenLen-i))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * Encode integer in big endian binary form with no leading zeroes.\n     * @notice TODO: This should be optimized with assembly to save gas costs.\n     * @param _x The integer to encode.\n     * @return _binary RLP encoded bytes.\n     */\n    function _toBinary(\n        uint256 _x\n    )\n        private\n        pure\n        returns (\n            bytes memory _binary\n        )\n    {\n        bytes memory b = abi.encodePacked(_x);\n\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n\n        return res;\n    }\n\n    /**\n     * Copies a piece of memory to another location.\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\n     * @param _dest Destination location.\n     * @param _src Source location.\n     * @param _len Length of memory to copy.\n     */\n    function _memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    )\n        private\n        pure\n    {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for(; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return _flattened The flattened byte string.\n     */\n    function _flatten(\n        bytes[] memory _list\n    )\n        private\n        pure\n        returns (\n            bytes memory _flattened\n        )\n    {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly { flattenedPtr := add(flattened, 0x20) }\n\n        for(i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly { listPtr := add(item, 0x20)}\n\n            _memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n}"
    },
    "contracts/optimistic-ethereum/libraries/utils/Lib_Bytes32Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/**\n * @title Lib_Byte32Utils\n */\nlibrary Lib_Bytes32Utils {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to \"true.\"\n     * @param _in Input bytes32 value.\n     * @return Bytes32 as a boolean.\n     */\n    function toBool(\n        bytes32 _in\n    )\n        internal\n        pure\n        returns (\n            bool\n        )\n    {\n        return _in != 0;\n    }\n\n    /**\n     * Converts a boolean to a bytes32 value.\n     * @param _in Input boolean value.\n     * @return Boolean as a bytes32.\n     */\n    function fromBool(\n        bool _in\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return bytes32(uint256(_in ? 1 : 0));\n    }\n\n    /**\n     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.\n     * @param _in Input bytes32 value.\n     * @return Bytes32 as an address.\n     */\n    function toAddress(\n        bytes32 _in\n    )\n        internal\n        pure\n        returns (\n            address\n        )\n    {\n        return address(uint160(uint256(_in)));\n    }\n\n    /**\n     * Converts an address to a bytes32.\n     * @param _in Input address value.\n     * @return Address as a bytes32.\n     */\n    function fromAddress(\n        address _in\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return bytes32(uint256(_in));\n    }\n\n    /**\n     * Removes the leading zeros from a bytes32 value and returns a new (smaller) bytes value.\n     * @param _in Input bytes32 value.\n     * @return Bytes32 without any leading zeros.\n     */\n    function removeLeadingZeros(\n        bytes32 _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        bytes memory out;\n\n        assembly {\n            // Figure out how many leading zero bytes to remove.\n            let shift := 0\n            for { let i := 0 } and(lt(i, 32), eq(byte(i, _in), 0)) { i := add(i, 1) } {\n                shift := add(shift, 1)\n            }\n\n            // Reserve some space for our output and fix the free memory pointer.\n            out := mload(0x40)\n            mstore(0x40, add(out, 0x40))\n\n            // Shift the value and store it into the output bytes.\n            mstore(add(out, 0x20), shl(mul(shift, 8), _in))\n\n            // Store the new size (with leading zero bytes removed) in the output byte size.\n            mstore(out, sub(32, shift))\n        }\n\n        return out;\n    }\n}\n"
    },
    "contracts/optimistic-ethereum/libraries/utils/Lib_BytesUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/**\n * @title Lib_BytesUtils\n */\nlibrary Lib_BytesUtils {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_start + _length >= _start, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (_bytes.length - _start == 0) {\n            return bytes('');\n        }\n\n        return slice(_bytes, _start, _bytes.length - _start);\n    }\n\n    function toBytes32PadLeft(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 ret;\n        uint256 len = _bytes.length <= 32 ? _bytes.length : 32;\n        assembly {\n            ret := shr(mul(sub(32, len), 8), mload(add(_bytes, 32)))\n        }\n        return ret;\n    }\n\n    function toBytes32(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        if (_bytes.length < 32) {\n            bytes32 ret;\n            assembly {\n                ret := mload(add(_bytes, 32))\n            }\n            return ret;\n        }\n\n        return abi.decode(_bytes,(bytes32)); // will truncate if input length > 32 bytes\n    }\n\n    function toUint256(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return uint256(toBytes32(_bytes));\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, \"toUint24_overflow\");\n        require(_bytes.length >= _start + 3 , \"toUint24_outOfBounds\");\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_start + 1 >= _start, \"toUint8_overflow\");\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, \"toAddress_overflow\");\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toNibbles(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory nibbles = new bytes(_bytes.length * 2);\n\n        for (uint256 i = 0; i < _bytes.length; i++) {\n            nibbles[i * 2] = _bytes[i] >> 4;\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\n        }\n\n        return nibbles;\n    }\n\n    function fromNibbles(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory ret = new bytes(_bytes.length / 2);\n\n        for (uint256 i = 0; i < ret.length; i++) {\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\n        }\n\n        return ret;\n    }\n\n    function equal(\n        bytes memory _bytes,\n        bytes memory _other\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        return keccak256(_bytes) == keccak256(_other);\n    }\n}\n"
    },
    "contracts/optimistic-ethereum/libraries/utils/Lib_ECDSAUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/**\n * @title Lib_ECDSAUtils\n */\nlibrary Lib_ECDSAUtils {\n\n    /**************************************\n     * Internal Functions: ECDSA Recovery *\n     **************************************/\n\n    /**\n     * Recovers a signed address given a message and signature.\n     * @param _message Message that was originally signed.\n     * @param _isEthSignedMessage Whether or not the user used the `Ethereum Signed Message` prefix.\n     * @param _v Signature `v` parameter.\n     * @param _r Signature `r` parameter.\n     * @param _s Signature `s` parameter.\n     * @return _sender Signer address.\n     */\n    function recover(\n        bytes memory _message,\n        bool _isEthSignedMessage,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        internal\n        pure\n        returns (\n            address _sender\n        )\n    {\n        bytes32 messageHash = getMessageHash(_message, _isEthSignedMessage);\n\n        return ecrecover(\n            messageHash,\n            _v + 27,\n            _r,\n            _s\n        );\n    }\n\n    function getMessageHash(\n        bytes memory _message,\n        bool _isEthSignedMessage\n    )\n        internal\n        pure\n        returns (bytes32) {\n        if (_isEthSignedMessage) {\n            return getEthSignedMessageHash(_message);\n        }\n        return getNativeMessageHash(_message);\n    }\n\n\n    /*************************************\n     * Private Functions: ECDSA Recovery *\n     *************************************/\n\n    /**\n     * Gets the native message hash (simple keccak256) for a message.\n     * @param _message Message to hash.\n     * @return _messageHash Native message hash.\n     */\n    function getNativeMessageHash(\n        bytes memory _message\n    )\n        private\n        pure\n        returns (\n            bytes32 _messageHash\n        )\n    {\n        return keccak256(_message);\n    }\n\n    /**\n     * Gets the hash of a message with the `Ethereum Signed Message` prefix.\n     * @param _message Message to hash.\n     * @return _messageHash Prefixed message hash.\n     */\n    function getEthSignedMessageHash(\n        bytes memory _message\n    )\n        private\n        pure\n        returns (\n            bytes32 _messageHash\n        )\n    {\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 messageHash = keccak256(_message);\n        return keccak256(abi.encodePacked(prefix, messageHash));\n    }\n}"
    },
    "contracts/optimistic-ethereum/libraries/utils/Lib_ErrorUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/**\n * @title Lib_ErrorUtils\n */\nlibrary Lib_ErrorUtils {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Encodes an error string into raw solidity-style revert data.\n     * (i.e. ascii bytes, prefixed with bytes4(keccak(\"Error(string))\"))\n     * Ref: https://docs.soliditylang.org/en/v0.8.2/control-structures.html?highlight=Error(string)#panic-via-assert-and-error-via-require\n     * @param _reason Reason for the reversion.\n     * @return Standard solidity revert data for the given reason.\n     */\n    function encodeRevertString(\n        string memory _reason\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return abi.encodeWithSignature(\n            \"Error(string)\",\n            _reason\n        );\n    }\n}\n"
    },
    "contracts/optimistic-ethereum/libraries/utils/Lib_EthUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// @unsupported: ovm\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_RLPWriter } from \"../rlp/Lib_RLPWriter.sol\";\nimport { Lib_Bytes32Utils } from \"./Lib_Bytes32Utils.sol\";\n\n/**\n * @title Lib_EthUtils\n */\nlibrary Lib_EthUtils {\n\n    /***********************************\n     * Internal Functions: Code Access *\n     ***********************************/\n\n    /**\n     * Gets the code for a given address.\n     * @param _address Address to get code for.\n     * @param _offset Offset to start reading from.\n     * @param _length Number of bytes to read.\n     * @return _code Code read from the contract.\n     */\n    function getCode(\n        address _address,\n        uint256 _offset,\n        uint256 _length\n    )\n        internal\n        view\n        returns (\n            bytes memory _code\n        )\n    {\n        assembly {\n            _code := mload(0x40)\n            mstore(0x40, add(_code, add(_length, 0x20)))\n            mstore(_code, _length)\n            extcodecopy(_address, add(_code, 0x20), _offset, _length)\n        }\n\n        return _code;\n    }\n\n    /**\n     * Gets the full code for a given address.\n     * @param _address Address to get code for.\n     * @return _code Full code of the contract.\n     */\n    function getCode(\n        address _address\n    )\n        internal\n        view\n        returns (\n            bytes memory _code\n        )\n    {\n        return getCode(\n            _address,\n            0,\n            getCodeSize(_address)\n        );\n    }\n\n    /**\n     * Gets the size of a contract's code in bytes.\n     * @param _address Address to get code size for.\n     * @return _codeSize Size of the contract's code in bytes.\n     */\n    function getCodeSize(\n        address _address\n    )\n        internal\n        view\n        returns (\n            uint256 _codeSize\n        )\n    {\n        assembly {\n            _codeSize := extcodesize(_address)\n        }\n\n        return _codeSize;\n    }\n\n    /**\n     * Gets the hash of a contract's code.\n     * @param _address Address to get a code hash for.\n     * @return _codeHash Hash of the contract's code.\n     */\n    function getCodeHash(\n        address _address\n    )\n        internal\n        view\n        returns (\n            bytes32 _codeHash\n        )\n    {\n        assembly {\n            _codeHash := extcodehash(_address)\n        }\n\n        return _codeHash;\n    }\n\n\n    /*****************************************\n     * Internal Functions: Contract Creation *\n     *****************************************/\n\n    /**\n     * Creates a contract with some given initialization code.\n     * @param _code Contract initialization code.\n     * @return _created Address of the created contract.\n     */\n    function createContract(\n        bytes memory _code\n    )\n        internal\n        returns (\n            address _created\n        )\n    {\n        assembly {\n            _created := create(\n                0,\n                add(_code, 0x20),\n                mload(_code)\n            )\n        }\n\n        return _created;\n    }\n\n    /**\n     * Computes the address that would be generated by CREATE.\n     * @param _creator Address creating the contract.\n     * @param _nonce Creator's nonce.\n     * @return _address Address to be generated by CREATE.\n     */\n    function getAddressForCREATE(\n        address _creator,\n        uint256 _nonce\n    )\n        internal\n        pure\n        returns (\n            address _address\n        )\n    {\n        bytes[] memory encoded = new bytes[](2);\n        encoded[0] = Lib_RLPWriter.writeAddress(_creator);\n        encoded[1] = Lib_RLPWriter.writeUint(_nonce);\n\n        bytes memory encodedList = Lib_RLPWriter.writeList(encoded);\n        return Lib_Bytes32Utils.toAddress(keccak256(encodedList));\n    }\n\n    /**\n     * Computes the address that would be generated by CREATE2.\n     * @param _creator Address creating the contract.\n     * @param _bytecode Bytecode of the contract to be created.\n     * @param _salt 32 byte salt value mixed into the hash.\n     * @return _address Address to be generated by CREATE2.\n     */\n    function getAddressForCREATE2(\n        address _creator,\n        bytes memory _bytecode,\n        bytes32 _salt\n    )\n        internal\n        pure\n        returns (address _address)\n    {\n        bytes32 hashedData = keccak256(abi.encodePacked(\n            byte(0xff),\n            _creator,\n            _salt,\n            keccak256(_bytecode)\n        ));\n\n        return Lib_Bytes32Utils.toAddress(hashedData);\n    }\n}\n"
    },
    "contracts/optimistic-ethereum/libraries/utils/Lib_Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/**\n * @title Lib_Math\n */\nlibrary Lib_Math {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Calculates the minumum of two numbers.\n     * @param _x First number to compare.\n     * @param _y Second number to compare.\n     * @return Lesser of the two numbers.\n     */\n    function min(\n        uint256 _x,\n        uint256 _y\n    )\n        internal\n        pure\n        returns (\n            uint256\n        )\n    {\n        if (_x < _y) {\n            return _x;\n        }\n\n        return _y;\n    }\n}\n"
    },
    "contracts/optimistic-ethereum/libraries/utils/Lib_MerkleTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/**\n * @title Lib_MerkleTree\n * @author River Keefer\n */\nlibrary Lib_MerkleTree {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Calculates a merkle root for a list of 32-byte leaf hashes.  WARNING: If the number\n     * of leaves passed in is not a power of two, it pads out the tree with zero hashes.\n     * If you do not know the original length of elements for the tree you are verifying,\n     * then this may allow empty leaves past _elements.length to pass a verification check down the line.\n     * Note that the _elements argument is modified, therefore it must not be used again afterwards\n     * @param _elements Array of hashes from which to generate a merkle root.\n     * @return Merkle root of the leaves, with zero hashes for non-powers-of-two (see above).\n     */\n    function getMerkleRoot(\n        bytes32[] memory _elements\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        require(\n            _elements.length > 0,\n            \"Lib_MerkleTree: Must provide at least one leaf hash.\"\n        );\n\n        if (_elements.length == 1) {\n            return _elements[0];\n        }\n\n        uint256[16] memory defaults = [\n            0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563,\n            0x633dc4d7da7256660a892f8f1604a44b5432649cc8ec5cb3ced4c4e6ac94dd1d,\n            0x890740a8eb06ce9be422cb8da5cdafc2b58c0a5e24036c578de2a433c828ff7d,\n            0x3b8ec09e026fdc305365dfc94e189a81b38c7597b3d941c279f042e8206e0bd8,\n            0xecd50eee38e386bd62be9bedb990706951b65fe053bd9d8a521af753d139e2da,\n            0xdefff6d330bb5403f63b14f33b578274160de3a50df4efecf0e0db73bcdd3da5,\n            0x617bdd11f7c0a11f49db22f629387a12da7596f9d1704d7465177c63d88ec7d7,\n            0x292c23a9aa1d8bea7e2435e555a4a60e379a5a35f3f452bae60121073fb6eead,\n            0xe1cea92ed99acdcb045a6726b2f87107e8a61620a232cf4d7d5b5766b3952e10,\n            0x7ad66c0a68c72cb89e4fb4303841966e4062a76ab97451e3b9fb526a5ceb7f82,\n            0xe026cc5a4aed3c22a58cbd3d2ac754c9352c5436f638042dca99034e83636516,\n            0x3d04cffd8b46a874edf5cfae63077de85f849a660426697b06a829c70dd1409c,\n            0xad676aa337a485e4728a0b240d92b3ef7b3c372d06d189322bfd5f61f1e7203e,\n            0xa2fca4a49658f9fab7aa63289c91b7c7b6c832a6d0e69334ff5b0a3483d09dab,\n            0x4ebfd9cd7bca2505f7bef59cc1c12ecc708fff26ae4af19abe852afe9e20c862,\n            0x2def10d13dd169f550f578bda343d9717a138562e0093b380a1120789d53cf10\n        ];\n\n        // Reserve memory space for our hashes.\n        bytes memory buf = new bytes(64);\n\n        // We'll need to keep track of left and right siblings.\n        bytes32 leftSibling;\n        bytes32 rightSibling;\n\n        // Number of non-empty nodes at the current depth.\n        uint256 rowSize = _elements.length;\n\n        // Current depth, counting from 0 at the leaves\n        uint256 depth = 0;\n\n        // Common sub-expressions\n        uint256 halfRowSize;         // rowSize / 2\n        bool rowSizeIsOdd;           // rowSize % 2 == 1\n\n        while (rowSize > 1) {\n            halfRowSize = rowSize / 2;\n            rowSizeIsOdd = rowSize % 2 == 1;\n\n            for (uint256 i = 0; i < halfRowSize; i++) {\n                leftSibling  = _elements[(2 * i)    ];\n                rightSibling = _elements[(2 * i) + 1];\n                assembly {\n                    mstore(add(buf, 32), leftSibling )\n                    mstore(add(buf, 64), rightSibling)\n                }\n\n                _elements[i] = keccak256(buf);\n            }\n\n            if (rowSizeIsOdd) {\n                leftSibling  = _elements[rowSize - 1];\n                rightSibling = bytes32(defaults[depth]);\n                assembly {\n                    mstore(add(buf, 32), leftSibling)\n                    mstore(add(buf, 64), rightSibling)\n                }\n\n                _elements[halfRowSize] = keccak256(buf);\n            }\n\n            rowSize = halfRowSize + (rowSizeIsOdd ? 1 : 0);\n            depth++;\n        }\n\n        return _elements[0];\n    }\n\n    /**\n     * Verifies a merkle branch for the given leaf hash.  Assumes the original length\n     * of leaves generated is a known, correct input, and does not return true for indices\n     * extending past that index (even if _siblings would be otherwise valid.)\n     * @param _root The Merkle root to verify against.\n     * @param _leaf The leaf hash to verify inclusion of.\n     * @param _index The index in the tree of this leaf.\n     * @param _siblings Array of sibline nodes in the inclusion proof, starting from depth 0 (bottom of the tree).\n     * @param _totalLeaves The total number of leaves originally passed into.\n     * @return Whether or not the merkle branch and leaf passes verification.\n     */\n    function verify(\n        bytes32 _root,\n        bytes32 _leaf,\n        uint256 _index,\n        bytes32[] memory _siblings,\n        uint256 _totalLeaves\n    )\n        internal\n        pure\n        returns (\n            bool\n        )\n    {\n        require(\n            _totalLeaves > 0,\n            \"Lib_MerkleTree: Total leaves must be greater than zero.\"\n        );\n\n        require(\n            _index < _totalLeaves,\n            \"Lib_MerkleTree: Index out of bounds.\"\n        );\n\n        require(\n            _siblings.length == _ceilLog2(_totalLeaves),\n            \"Lib_MerkleTree: Total siblings does not correctly correspond to total leaves.\"\n        );\n\n        bytes32 computedRoot = _leaf;\n\n        for (uint256 i = 0; i < _siblings.length; i++) {\n            if ((_index & 1) == 1) {\n                computedRoot = keccak256(\n                    abi.encodePacked(\n                        _siblings[i],\n                        computedRoot\n                    )\n                );\n            } else {\n                computedRoot = keccak256(\n                    abi.encodePacked(\n                        computedRoot,\n                        _siblings[i]\n                    )\n                );\n            }\n\n            _index >>= 1;\n        }\n\n        return _root == computedRoot;\n    }\n\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Calculates the integer ceiling of the log base 2 of an input.\n     * @param _in Unsigned input to calculate the log.\n     * @return ceil(log_base_2(_in))\n     */\n    function _ceilLog2(\n        uint256 _in\n    )\n        private\n        pure\n        returns (\n            uint256\n        )\n    {\n        require(\n            _in > 0,\n            \"Lib_MerkleTree: Cannot compute ceil(log_2) of 0.\"\n        );\n\n        if (_in == 1) {\n            return 0;\n        }\n\n        // Find the highest set bit (will be floor(log_2)).\n        // Borrowed with <3 from https://github.com/ethereum/solidity-examples\n        uint256 val = _in;\n        uint256 highest = 0;\n        for (uint256 i = 128; i >= 1; i >>= 1) {\n            if (val & (uint(1) << i) - 1 << i != 0) {\n                highest += i;\n                val >>= i;\n            }\n        }\n\n        // Increment by one if this is not a perfect logarithm.\n        if ((uint(1) << highest) != _in) {\n            highest += 1;\n        }\n\n        return highest;\n    }\n}\n"
    },
    "contracts/optimistic-ethereum/libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/* Library Imports */\nimport { Lib_ErrorUtils } from \"../utils/Lib_ErrorUtils.sol\";\n\n/**\n * @title Lib_SafeExecutionManagerWrapper\n * @dev The Safe Execution Manager Wrapper provides functions which facilitate writing OVM safe \n * code using the standard solidity compiler, by routing all its operations through the Execution \n * Manager.\n * \n * Compiler used: solc\n * Runtime target: OVM\n */\nlibrary Lib_SafeExecutionManagerWrapper {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Performs a safe ovmCALL.\n     * @param _gasLimit Gas limit for the call.\n     * @param _target Address to call.\n     * @param _calldata Data to send to the call.\n     * @return _success Whether or not the call reverted.\n     * @return _returndata Data returned by the call.\n     */\n    function safeCALL(\n        uint256 _gasLimit,\n        address _target,\n        bytes memory _calldata\n    )\n        internal\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmCALL(uint256,address,bytes)\",\n                _gasLimit,\n                _target,\n                _calldata\n            )\n        );\n\n        return abi.decode(returndata, (bool, bytes));\n    }\n\n    /**\n     * Performs a safe ovmDELEGATECALL.\n     * @param _gasLimit Gas limit for the call.\n     * @param _target Address to call.\n     * @param _calldata Data to send to the call.\n     * @return _success Whether or not the call reverted.\n     * @return _returndata Data returned by the call.\n     */\n    function safeDELEGATECALL(\n        uint256 _gasLimit,\n        address _target,\n        bytes memory _calldata\n    )\n        internal\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmDELEGATECALL(uint256,address,bytes)\",\n                _gasLimit,\n                _target,\n                _calldata\n            )\n        );\n\n        return abi.decode(returndata, (bool, bytes));\n    }\n\n    /**\n     * Performs a safe ovmCREATE call.\n     * @param _gasLimit Gas limit for the creation.\n     * @param _bytecode Code for the new contract.\n     * @return _contract Address of the created contract.\n     */\n    function safeCREATE(\n        uint256 _gasLimit,\n        bytes memory _bytecode\n    )\n        internal\n        returns (\n            address,\n            bytes memory\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            _gasLimit,\n            abi.encodeWithSignature(\n                \"ovmCREATE(bytes)\",\n                _bytecode\n            )\n        );\n\n        return abi.decode(returndata, (address, bytes));\n    }\n\n    /**\n     * Performs a safe ovmEXTCODESIZE call.\n     * @param _contract Address of the contract to query the size of.\n     * @return _EXTCODESIZE Size of the requested contract in bytes.\n     */\n    function safeEXTCODESIZE(\n        address _contract\n    )\n        internal\n        returns (\n            uint256 _EXTCODESIZE\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmEXTCODESIZE(address)\",\n                _contract\n            )\n        );\n\n        return abi.decode(returndata, (uint256));\n    }\n\n    /**\n     * Performs a safe ovmCHAINID call.\n     * @return _CHAINID Result of calling ovmCHAINID.\n     */\n    function safeCHAINID()\n        internal\n        returns (\n            uint256 _CHAINID\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmCHAINID()\"\n            )\n        );\n\n        return abi.decode(returndata, (uint256));\n    }\n\n    /**\n     * Performs a safe ovmCALLER call.\n     * @return _CALLER Result of calling ovmCALLER.\n     */\n    function safeCALLER()\n        internal\n        returns (\n            address _CALLER\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmCALLER()\"\n            )\n        );\n\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * Performs a safe ovmADDRESS call.\n     * @return _ADDRESS Result of calling ovmADDRESS.\n     */\n    function safeADDRESS()\n        internal\n        returns (\n            address _ADDRESS\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmADDRESS()\"\n            )\n        );\n\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * Performs a safe ovmGETNONCE call.\n     * @return _nonce Result of calling ovmGETNONCE.\n     */\n    function safeGETNONCE()\n        internal\n        returns (\n            uint256 _nonce\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmGETNONCE()\"\n            )\n        );\n\n        return abi.decode(returndata, (uint256));\n    }\n\n    /**\n     * Performs a safe ovmINCREMENTNONCE call.\n     */\n    function safeINCREMENTNONCE()\n        internal\n    {\n        _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmINCREMENTNONCE()\"\n            )\n        );\n    }\n\n    /**\n     * Performs a safe ovmCREATEEOA call.\n     * @param _messageHash Message hash which was signed by EOA\n     * @param _v v value of signature (0 or 1)\n     * @param _r r value of signature\n     * @param _s s value of signature\n     */\n    function safeCREATEEOA(\n        bytes32 _messageHash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        internal\n    {\n        _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmCREATEEOA(bytes32,uint8,bytes32,bytes32)\",\n                _messageHash,\n                _v,\n                _r,\n                _s\n            )\n        );\n    }\n\n    /**\n     * Performs a safe REVERT.\n     * @param _reason String revert reason to pass along with the REVERT.\n     */\n    function safeREVERT(\n        string memory _reason\n    )\n        internal\n    {\n        _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmREVERT(bytes)\",\n                Lib_ErrorUtils.encodeRevertString(\n                    _reason\n                )\n            )\n        );\n    }\n\n    /**\n     * Performs a safe \"require\".\n     * @param _condition Boolean condition that must be true or will revert.\n     * @param _reason String revert reason to pass along with the REVERT.\n     */\n    function safeREQUIRE(\n        bool _condition,\n        string memory _reason\n    )\n        internal\n    {\n        if (!_condition) {\n            safeREVERT(\n                _reason\n            );\n        }\n    }\n\n    /**\n     * Performs a safe ovmSLOAD call.\n     */\n    function safeSLOAD(\n        bytes32 _key\n    )\n        internal\n        returns (\n            bytes32\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmSLOAD(bytes32)\",\n                _key\n            )\n        );\n\n        return abi.decode(returndata, (bytes32));\n    }\n\n    /**\n     * Performs a safe ovmSSTORE call.\n     */\n    function safeSSTORE(\n        bytes32 _key,\n        bytes32 _value\n    )\n        internal\n    {\n        _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmSSTORE(bytes32,bytes32)\",\n                _key,\n                _value\n            )\n        );\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Performs an ovm interaction and the necessary safety checks.\n     * @param _gasLimit Gas limit for the interaction.\n     * @param _calldata Data to send to the OVM_ExecutionManager (encoded with sighash).\n     * @return _returndata Data sent back by the OVM_ExecutionManager.\n     */\n    function _safeExecutionManagerInteraction(\n        uint256 _gasLimit,\n        bytes memory _calldata\n    )\n        private\n        returns (\n            bytes memory _returndata\n        )\n    {\n        address ovmExecutionManager = msg.sender;\n        (\n            bool success,\n            bytes memory returndata\n        ) = ovmExecutionManager.call{gas: _gasLimit}(_calldata);\n\n        if (success == false) {\n            assembly {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else if (returndata.length == 1) {\n            assembly {\n                return(0, 1)\n            }\n        } else {\n            return returndata;\n        }\n    }\n\n    function _safeExecutionManagerInteraction(\n        bytes memory _calldata\n    )\n        private\n        returns (\n            bytes memory _returndata\n        )\n    {\n        return _safeExecutionManagerInteraction(\n            gasleft(),\n            _calldata\n        );\n    }\n}\n"
    },
    "contracts/optimistic-ethereum/libraries/wrappers/Lib_SafeMathWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Pulled from @openzeppelin/contracts/math/SafeMath.sol\n// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/* Library Imports */\nimport { Lib_SafeExecutionManagerWrapper } from \"./Lib_SafeExecutionManagerWrapper.sol\";\n\n/**\n * @title Lib_SafeMathWrapper\n */\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\n\nlibrary Lib_SafeMathWrapper {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal returns (uint256) {\n        uint256 c = a + b;\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(c >= a, \"Lib_SafeMathWrapper: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal returns (uint256) {\n        return sub(a, b, \"Lib_SafeMathWrapper: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal returns (uint256) {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(c / a == b, \"Lib_SafeMathWrapper: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal returns (uint256) {\n        return div(a, b, \"Lib_SafeMathWrapper: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal returns (uint256) {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal returns (uint256) {\n        return mod(a, b, \"Lib_SafeMathWrapper: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal returns (uint256) {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    }
  }
}}