{{
  "language": "Solidity",
  "sources": {
    "contracts/Metavaders_Mint.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/// @title: Metavaders - Mint\r\n/// @author: PxGnome\r\n/// @notice: Used to handle mint with metavaders NFT contract\r\n/// @dev: This is Version 1.0\r\n//\r\n// ███╗   ███╗███████╗████████╗ █████╗ ██╗   ██╗ █████╗ ██████╗ ███████╗██████╗ ███████╗\r\n// ████╗ ████║██╔════╝╚══██╔══╝██╔══██╗██║   ██║██╔══██╗██╔══██╗██╔════╝██╔══██╗██╔════╝\r\n// ██╔████╔██║█████╗     ██║   ███████║██║   ██║███████║██║  ██║█████╗  ██████╔╝███████╗\r\n// ██║╚██╔╝██║██╔══╝     ██║   ██╔══██║╚██╗ ██╔╝██╔══██║██║  ██║██╔══╝  ██╔══██╗╚════██║\r\n// ██║ ╚═╝ ██║███████╗   ██║   ██║  ██║ ╚████╔╝ ██║  ██║██████╔╝███████╗██║  ██║███████║\r\n// ╚═╝     ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝  ╚═══╝  ╚═╝  ╚═╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚══════╝\r\n//\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n// Abstract Contract Used for Inheriting\r\nabstract contract IMetavader_Mint {\r\n    function mint(address to, uint256 num) public virtual;\r\n    function reserveMint(address to, uint256 num) public virtual;\r\n    function balanceOf(address _owner) public virtual returns(uint256);\r\n    function totalSupply() public view virtual returns (uint256);\r\n}\r\n\r\ncontract Metavaders_Mint is \r\n    Ownable\r\n{   \r\n    using Strings for uint256;\r\n    address public metavadersAddress;\r\n\r\n    IMetavader_Mint MetavaderContract;\r\n\r\n    // Mint Info\r\n    uint256 public max_mint = 10101;\r\n    uint256 private _reserved = 200; // Reserved amount for special usage\r\n    uint256 public price = 0.07 ether;\r\n    uint256 private _max_gas = 200000000000;\r\n    uint256 public start_time = 1633363200; // start time:  Monday, October 4, 2021 4:00:00 PM UTC\r\n    uint256 public max_sale = 10;\r\n    uint256 public max_wallet = 20;\r\n    bool public _paused = true;\r\n\r\n    // Presale\r\n    uint256 private _presale_supply = 1000;\r\n    uint256 public max_presale = 5;\r\n    bool public whiteListEnd = false;\r\n\r\n    mapping(address => bool) whitelist;\r\n    mapping(address => uint256) mintPerWallet;\r\n\r\n    // -- CONSTRUCTOR FUNCTIONS -- //\r\n    // 10101 Metavaders in total\r\n    constructor(address _metavadersAddress) {\r\n        metavadersAddress = _metavadersAddress;\r\n        MetavaderContract = IMetavader_Mint(_metavadersAddress);\r\n    }\r\n\r\n    // // -- UTILITY FUNCTIONS -- //\r\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\r\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\r\n    }\r\n\r\n    // -- SMART CONTRACT OWNER ONLY FUNCTIONS -- //\r\n    // Update Metavader Address Incase There Is an Issue\r\n    function updateMetavadersAddress(address _address) public onlyOwner {\r\n        metavadersAddress = _address;\r\n    }\r\n\r\n    // Withdraw to owner addresss\r\n    function withdrawAll() public payable onlyOwner returns (uint256) {\r\n        uint256 balance = address(this).balance;\r\n        require(payable(owner()).send(balance)); \r\n        return balance;\r\n    }\r\n\r\n    function addToWhiteList(address _address) public onlyOwner {\r\n        whitelist[_address] = true;\r\n        // emit AddedToWhitelist(_address);\r\n    }\r\n\r\n    function removeFromWhitelist(address _address) public onlyOwner {\r\n        whitelist[_address] = false;\r\n        // emit RemovedFromWhitelist(_address);\r\n    }\r\n\r\n    function isWhitelisted(address _address) public view returns(bool) {\r\n        if (whiteListEnd == true) {\r\n            return true;\r\n        } else {\r\n            return whitelist[_address];\r\n        }\r\n    }\r\n\r\n\r\n    // -- MINT FUNCTIONS  --//\r\n    function public_mint(uint256 num) public payable virtual {\r\n        require( tx.gasprice < _max_gas,                                    \"Please set lower gas price and retry\"); // Set a cap on gas\r\n        require( !_paused,                                                  \"Mint is paused\" );\r\n        require( block.timestamp > start_time,                              \"Mint not yet started\"); // start time:  1633374000 = Monday, October 4, 2021 7:00:00 PM UTC\r\n        require( num <= max_sale,                                           \"Exceeded max mint per txn\");\r\n        require( (mintPerWallet[_msgSender()] + num) <= max_wallet,         \"Exceeded mint per wallet\");\r\n        // require( MetavaderContract.balanceOf(_msgSender()) < max_wallet,    \"Exceeded mint per wallet\");\r\n        uint256 supply = MetavaderContract.totalSupply();\r\n        require( supply + num < max_mint - _reserved,                       \"Exceeds maximum supply\" );\r\n        require( msg.value >= price * num,                                  \"Ether sent incorrect\");\r\n\r\n        MetavaderContract.mint(_msgSender(), num);\r\n        mintPerWallet[_msgSender()] += num;\r\n    }\r\n\r\n    // Presale Mint Function\r\n    function presale_mint(uint256 num) public payable virtual {\r\n        require(tx.gasprice < _max_gas,                                     \"Please set lower gas price and retry\"); // Set a cap on gas\r\n        require( !_paused,                                                  \"Mint is paused\" );        \r\n        require(isWhitelisted(_msgSender()) == true || whiteListEnd,        \"You are not on whitelist\");\r\n        require( num <= max_presale,                                        \"Exceeded max presale mint per txn\");\r\n        require( (mintPerWallet[_msgSender()] + num) <= max_presale,        \"Exceeded mint per wallet\");\r\n        uint256 supply = MetavaderContract.totalSupply();\r\n        require( supply + num < _presale_supply,                            \"Exceeds max presale supply\" );\r\n        require( msg.value >= price * num,                                  \"Ether sent incorrect\");\r\n\r\n        MetavaderContract.mint(_msgSender(), num);\r\n        mintPerWallet[_msgSender()] += num;\r\n    }\r\n\r\n    // Minted the reserve\r\n    function reserveMint(address _to, uint256 _amount) external onlyOwner() {\r\n        require( _amount <= _reserved, \"Exceeds reserved Metavaders supply\" );\r\n        // uint256 supply = MetavaderContract.totalSupply();\r\n        MetavaderContract.reserveMint(_to, _amount);\r\n        _reserved -= _amount;\r\n    }\r\n\r\n    // Get wallet mint numbers for troubleshooting if needed\r\n    function getWalletMinted(address checkAdd) external view returns (uint256 minted) {\r\n        return mintPerWallet[checkAdd];\r\n    }\r\n\r\n    // -- SMART CONTRACT OWNER ONLY FUNCTIONS -- //\r\n    function setPrice(uint256 _newPrice) public onlyOwner {\r\n        price = _newPrice;\r\n    }\r\n    function setGasMax(uint256 _newGasMax) public onlyOwner {\r\n        _max_gas = _newGasMax;\r\n    }\r\n    function setStartTime(uint256 new_start_time) public onlyOwner {\r\n        start_time = new_start_time;\r\n    }\r\n    function setPresaleSupply(uint256 new_presale_supply) public onlyOwner {\r\n        _presale_supply = new_presale_supply;\r\n    }\r\n    function setMaxPresale(uint256 new_max_presale) public onlyOwner {\r\n        max_presale = new_max_presale;\r\n    }\r\n    function setMaxSale(uint256 new_max_sale) public onlyOwner {\r\n        max_sale = new_max_sale;\r\n    }\r\n    function setMaxWallet(uint256 new_max_wallet) public onlyOwner {\r\n        max_wallet = new_max_wallet;\r\n    }\r\n    function setWhiteListEnd(bool new_whiteListEnd) public onlyOwner {\r\n        whiteListEnd = new_whiteListEnd;\r\n    }\r\n\r\n\r\n    // Pause sale/mint in case of special reason\r\n    function pause(bool val) public onlyOwner {\r\n        _paused = val;\r\n    }\r\n\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}}