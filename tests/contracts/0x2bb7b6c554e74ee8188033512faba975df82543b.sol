{"ERC20.sol":{"content":"pragma solidity 0.4.26;\r\n\r\n\r\ncontract ERC20Interface {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() public view returns (uint);\r\n\r\n    /// @tokenOwner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n\r\n    /// @param tokenOwner The address of the account owning tokens\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n\r\n    /// @notice send `tokens` token to `to` from `msg.sender`\r\n    /// @param to The address of the recipient\r\n    /// @param tokens The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n\r\n    /// @notice send `tokens` token to `to` from `from` on the condition it is approved by `from`\r\n    /// @param from The address of the sender\r\n    /// @param to The address of the recipient\r\n    /// @param tokens The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `spender` to spend `tokens` tokens\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @param tokens The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n\r\n    function mint(uint256 value) public returns (bool);\r\n    function mintToWallet(address to, uint256 tokens) public returns (bool);\r\n    function burn(uint256 value) public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n}\r\n"},"Ownable.sol":{"content":"pragma solidity 0.4.26;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public{\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n"},"SafeMath.sol":{"content":"pragma solidity 0.4.26;\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n * Credits go to OpenZeppelin: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003e 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n"},"SlrsToken.sol":{"content":"pragma solidity 0.4.26;\r\n\r\nimport \"./ERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\n/**\r\n * SolarStake Token\r\n */\r\n\r\n\r\ncontract SlrsToken is ERC20Interface, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n    uint256  public  totalSupply;\r\n    address public itoContract;\r\n\r\n    mapping  (address =\u003e uint256)             public          _balances;\r\n    mapping  (address =\u003e mapping (address =\u003e uint256)) public  _approvals;\r\n\r\n\r\n    string   public  name = \"SolarStake Token\";\r\n    string   public  symbol = \"SLRS\";\r\n    uint256  public  decimals = 18;\r\n\r\n    event Mint(uint256 tokens);\r\n    event MintToWallet(address indexed to, uint256 tokens);\r\n    event MintFromContract(address indexed to, uint256 tokens);\r\n    event Burn(uint256 tokens);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n\r\n    constructor () public{\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n    function balanceOf(address tokenOwner) public view returns (uint256) {\r\n        return _balances[tokenOwner];\r\n    }\r\n    function allowance(address tokenOwner, address spender) public view returns (uint256) {\r\n        return _approvals[tokenOwner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 tokens) public returns (bool) {\r\n        require(to != address(0));\r\n        require(tokens \u003e 0 \u0026\u0026 _balances[msg.sender] \u003e= tokens);\r\n        _balances[msg.sender] = _balances[msg.sender].sub(tokens);\r\n        _balances[to] = _balances[to].add(tokens);\r\n        emit Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool) {\r\n        require(from != address(0));\r\n        require(to != address(0));\r\n        require(tokens \u003e 0 \u0026\u0026 _balances[from] \u003e= tokens \u0026\u0026 _approvals[from][msg.sender] \u003e= tokens);\r\n        _approvals[from][msg.sender] = _approvals[from][msg.sender].sub(tokens);\r\n        _balances[from] = _balances[from].sub(tokens);\r\n        _balances[to] = _balances[to].add(tokens);\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 tokens) public returns (bool) {\r\n        require(spender != address(0));\r\n        require(tokens \u003e 0 \u0026\u0026 tokens \u003c= _balances[msg.sender]);\r\n        _approvals[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    // mint tokens to owner wallet\r\n    function mint(uint256 tokens) public onlyOwner returns (bool) {\r\n        require(tokens \u003e 0);\r\n        _balances[msg.sender] = _balances[msg.sender].add(tokens);\r\n        totalSupply = totalSupply.add(tokens);\r\n        emit Mint(tokens);\r\n        return true;\r\n    }\r\n\r\n    // Minting to wallets directly\r\n    function mintToWallet(address to, uint256 tokens) public onlyOwner returns (bool) {\r\n      totalSupply = totalSupply.add(tokens);\r\n      _balances[to] = _balances[to].add(tokens);\r\n      emit MintToWallet(to, tokens);\r\n      return true;\r\n    }\r\n\r\n    // Minting to wallets from ITOContract\r\n    function mintFromContract(address to, uint256 tokens) public returns (bool) {\r\n      require(msg.sender == itoContract);\r\n      totalSupply = totalSupply.add(tokens);\r\n      _balances[to] = _balances[to].add(tokens);\r\n      emit MintFromContract(to, tokens);\r\n      return true;\r\n    }\r\n\r\n    // burning tokens from owner wallet\r\n    function burn(uint256 tokens) public onlyOwner returns (bool)  {\r\n        require(tokens \u003e 0 \u0026\u0026 tokens \u003c= _balances[msg.sender]);\r\n        _balances[msg.sender] = _balances[msg.sender].sub(tokens);\r\n        totalSupply = totalSupply.sub(tokens);\r\n        emit Burn(tokens);\r\n        return true;\r\n    }\r\n\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n\r\n    // Set address of ITOContract to allow minting from ITOContract\r\n    function setItoContract(address _itoContract) public onlyOwner {\r\n      if (_itoContract != address(0)) {\r\n        itoContract = _itoContract;\r\n      }\r\n    }\r\n\r\n}\r\n"},"SlrsTokenItoContract.sol":{"content":"pragma solidity 0.4.26;\r\n\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./SlrsToken.sol\";\r\n\r\ncontract SlrsTokenItoContract  is Ownable{\r\n    using SafeMath for uint256;\r\n    SlrsToken public slrs;\r\n    uint    public  startTime;\r\n    address public vestingAddress;\r\n    address public heliosEnergy;\r\n    address public tapRootConsulting;\r\n\r\n    mapping(address =\u003e bool) public isWhitelisted;\r\n\tmapping(address =\u003e bool) public isAdminlisted;\r\n\r\n\tevent WhitelistSet(address indexed _address, bool _state);\r\n\tevent AdminlistSet(address indexed _address, bool _state);\r\n\r\n\r\n\tconstructor(address token, uint _startTime, address _vestingAddress, address _heliosEnergy, address _tapRootConsulting) public{\r\n        require(token != address(0));\r\n        require(_startTime \u003e 1564646400); // unix timestamp 1564646400 1st August 2019 09:00 am\r\n        require(_vestingAddress != address(0));\r\n        require(_heliosEnergy != address(0));\r\n        require(_tapRootConsulting != address(0));\r\n\t\tslrs = SlrsToken(token);\r\n\t\trequire(slrs.owner() == msg.sender);\r\n\t\tstartTime = _startTime;\r\n        vestingAddress = _vestingAddress; // address of teamVesting Wallet\r\n        heliosEnergy = _heliosEnergy; // address of HeliosEnergy wallet\r\n        tapRootConsulting = _tapRootConsulting; // address of TapRootConulting wallet\r\n\t}\r\n\r\n  modifier onlyOwners() {\r\n\t\trequire (isAdminlisted[msg.sender] == true || msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyWhitelisted() {\r\n\t\trequire (isWhitelisted[msg.sender] == true);\r\n\t\t_;\r\n\t}\r\n    // accept funds only from whitelisted wallets\r\n  function () public payable onlyWhitelisted{\r\n    require(now \u003e= startTime);\r\n  }\r\n\r\n    // transfer ETH from contract to predifined wallets\r\n  function transferFundsToWallet(address to, uint256 weiAmount) public onlyOwner {\r\n        require(msg.sender==owner);\r\n        require(weiAmount \u003e 0);\r\n        require(to == address(heliosEnergy) || to == address(tapRootConsulting));\r\n        to.transfer(weiAmount);\r\n    }\r\n\r\n  // minting to whitelisted investors wallets\r\n  function mintInvestorToken(address beneficiary, uint256 tokenamount) public onlyOwners {\r\n    require(isWhitelisted[beneficiary] == true);\r\n    require(tokenamount \u003e 0);\r\n    slrs.mintFromContract(beneficiary, tokenamount);\r\n  }\r\n\r\n  // minting to vesting wallet for team tokens\r\n  function mintTeamToken(address beneficiary, uint256 tokenamount) public onlyOwners {\r\n    require(beneficiary == address(vestingAddress));\r\n    require(tokenamount \u003e 0);\r\n    slrs.mintFromContract(beneficiary, tokenamount);\r\n  }\r\n\r\n    function setAdminlist(address _addr, bool _state) public onlyOwner {\r\n    require(_addr != address(0));\r\n\t\tisAdminlisted[_addr] = _state;\r\n\t\temit AdminlistSet(_addr, _state);\r\n\t}\r\n\r\n    function setWhitelist(address _addr, bool _state) public onlyOwners {\r\n        require(_addr != address(0));\r\n        isWhitelisted[_addr] = _state;\r\n        emit WhitelistSet(_addr, _state);\r\n    }\r\n\r\n    // Set whitelist state for multiple addresses\r\n    function setManyWhitelist(address[] _addr) public onlyOwners {\r\n        uint length = _addr.length;\r\n        for (uint256 i = 0; i \u003c length; i++) {\r\n            setWhitelist(_addr[i], true);\r\n        }\r\n    }\r\n\r\n\t// @return true if sale has started\r\n\tfunction hasStarted() public view returns (bool) {\r\n\t\treturn now \u003e= startTime;\r\n\t}\r\n\r\n  function checkInvestorHoldingToken(address investor) public view returns (uint256){\r\n    require(investor != address(0));\r\n    return slrs.balanceOf(investor);\r\n  }\r\n\r\n  // Owner can transfer out any accidentally sent ERC20 tokens\r\n  function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n    return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n  }\r\n\r\n\tfunction kill() public onlyOwner{\r\n    selfdestruct(owner);\r\n  }\r\n}\r\n"}}