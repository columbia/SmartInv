{"IERC20.sol":{"content":"// SPDX-License-Identifier: BCOM\n\npragma solidity =0.8.14;\n\ninterface IERC20 {\n\n    function balanceOf(\n        address _owner\n    )\n        external\n        view\n        returns (uint256);\n}\n"},"ISwapsCallee.sol":{"content":"// SPDX-License-Identifier: BCOM\n\npragma solidity =0.8.14;\n\ninterface ISwapsCallee {\n\n    function swapsCall(\n        address _sender,\n        uint256 _amount0,\n        uint256 _amount1,\n        bytes calldata _data\n    )\n        external;\n}\n"},"ISwapsERC20.sol":{"content":"// SPDX-License-Identifier: BCOM\n\npragma solidity =0.8.14;\n\ninterface ISwapsERC20 {\n\n    function name()\n        external\n        pure\n        returns (string memory);\n\n    function symbol()\n        external\n        pure\n        returns (string memory);\n\n    function decimals()\n        external\n        pure\n        returns (uint8);\n\n    function totalSupply()\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(\n        address _owner\n    )\n        external\n        view\n        returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        external\n        view\n        returns (uint256);\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        external\n        returns (bool);\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        external\n        returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        external\n        returns (bool);\n\n    function DOMAIN_SEPARATOR()\n        external\n        view\n        returns (bytes32);\n\n    function PERMIT_TYPEHASH()\n        external\n        pure\n        returns (bytes32);\n\n    function nonces(\n        address _owner\n    )\n        external\n        view\n        returns (uint256);\n\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external;\n}\n"},"ISwapsFactory.sol":{"content":"// SPDX-License-Identifier: BCOM\n\npragma solidity =0.8.14;\n\ninterface ISwapsFactory {\n\n    function feeTo()\n        external\n        view\n        returns (address);\n\n    function feeToSetter()\n        external\n        view\n        returns (address);\n\n    function getPair(\n        address _tokenA,\n        address _tokenB\n    )\n        external\n        view\n        returns (address pair);\n\n    function allPairs(uint256)\n        external\n        view\n        returns (address pair);\n\n    function allPairsLength()\n        external\n        view\n        returns (uint256);\n\n    function createPair(\n        address _tokenA,\n        address _tokenB\n    )\n        external\n        returns (address pair);\n\n    function setFeeTo(\n        address\n    )\n        external;\n\n    function setFeeToSetter(\n        address\n    )\n        external;\n\n    function cloneTarget()\n        external\n        view\n        returns (address target);\n}\n"},"ISwapsPair.sol":{"content":"// SPDX-License-Identifier: BCOM\n\npragma solidity =0.8.14;\n\nimport \"./ISwapsERC20.sol\";\n\ninterface ISwapsPair is ISwapsERC20 {\n\n    function MINIMUM_LIQUIDITY()\n        external\n        pure\n        returns (uint256);\n\n    function factory()\n        external\n        view\n        returns (address);\n\n    function token0()\n        external\n        view\n        returns (address);\n\n    function token1()\n        external\n        view\n        returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast()\n        external\n        view\n        returns (uint256);\n\n    function price1CumulativeLast()\n        external\n        view\n        returns (uint256);\n\n    function kLast()\n        external\n        view\n        returns (uint256);\n\n    function mint(\n        address _to\n    )\n        external\n        returns (uint256 liquidity);\n\n    function burn(\n        address _to\n    )\n        external\n        returns (\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    function swap(\n        uint256 _amount0Out,\n        uint256 _amount1Out,\n        address _to,\n        bytes calldata _data\n    )\n        external;\n\n    function skim()\n        external;\n\n    function initialize(\n        address,\n        address\n    )\n        external;\n}\n"},"IWETH.sol":{"content":"// SPDX-License-Identifier: BCOM\n\npragma solidity =0.8.14;\n\ninterface IWETH {\n\n    function deposit()\n        external\n        payable;\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        external\n        returns (bool);\n\n    function withdraw(\n        uint256\n    )\n        external;\n}\n"},"SwapsERC20.sol":{"content":"// SPDX-License-Identifier: BCOM\n\npragma solidity =0.8.14;\n\ncontract SwapsERC20 {\n\n    string public constant name = \"Verse Exchange\";\n    string public constant symbol = \"VERSE-X\";\n    uint8 public constant decimals = 18;\n\n    address constant ZERO_ADDRESS = address(0);\n    uint256 constant UINT256_MAX = type(uint256).max;\n\n    uint256 public totalSupply;\n\n    mapping(address =\u003e uint256) public balanceOf;\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n    mapping(address =\u003e uint256) public nonces;\n\n    bytes32 public immutable DOMAIN_SEPARATOR;\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\n        \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    constructor() {\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function _mint(\n        address _to,\n        uint256 _value\n    )\n        internal\n    {\n        totalSupply =\n        totalSupply + _value;\n\n        unchecked {\n            balanceOf[_to] =\n            balanceOf[_to] + _value;\n        }\n\n        emit Transfer(\n            ZERO_ADDRESS,\n            _to,\n            _value\n        );\n    }\n\n    function _burn(\n        address _from,\n        uint256 _value\n    )\n        internal\n    {\n        unchecked {\n            totalSupply =\n            totalSupply - _value;\n        }\n\n        balanceOf[_from] =\n        balanceOf[_from] - _value;\n\n        emit Transfer(\n            _from,\n            ZERO_ADDRESS,\n            _value\n        );\n    }\n\n    function _approve(\n        address _owner,\n        address _spender,\n        uint256 _value\n    )\n        private\n    {\n        allowance[_owner][_spender] = _value;\n\n        emit Approval(\n            _owner,\n            _spender,\n            _value\n        );\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        private\n    {\n        balanceOf[_from] =\n        balanceOf[_from] - _value;\n\n        unchecked {\n            balanceOf[_to] =\n            balanceOf[_to] + _value;\n        }\n\n        emit Transfer(\n            _from,\n            _to,\n            _value\n        );\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        external\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            _spender,\n            _value\n        );\n\n        return true;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        external\n        returns (bool)\n    {\n        _transfer(\n            msg.sender,\n            _to,\n            _value\n        );\n\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        external\n        returns (bool)\n    {\n        if (allowance[_from][msg.sender] != UINT256_MAX) {\n            allowance[_from][msg.sender] -= _value;\n        }\n\n        _transfer(\n            _from,\n            _to,\n            _value\n        );\n\n        return true;\n    }\n\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n    {\n        require(\n            _deadline \u003e= block.timestamp,\n            \"SwapsERC20: PERMIT_CALL_EXPIRED\"\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        _owner,\n                        _spender,\n                        _value,\n                        nonces[_owner]++,\n                        _deadline\n                    )\n                )\n            )\n        );\n\n        if (uint256(_s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert(\"SwapsERC20: INVALID_SIGNATURE\");\n        }\n\n        address recoveredAddress = ecrecover(\n            digest,\n            _v,\n            _r,\n            _s\n        );\n\n        require(\n            recoveredAddress != ZERO_ADDRESS \u0026\u0026\n            recoveredAddress == _owner,\n            \"SwapsERC20: INVALID_SIGNATURE\"\n        );\n\n        _approve(\n            _owner,\n            _spender,\n            _value\n        );\n    }\n}\n"},"SwapsFactory.sol":{"content":"// SPDX-License-Identifier: BCOM\n\npragma solidity =0.8.14;\n\nimport \"./ISwapsPair.sol\";\nimport \"./SwapsPair.sol\";\n\ncontract SwapsFactory {\n\n    address public feeTo;\n    address public feeToSetter;\n    address public immutable cloneTarget;\n    address constant ZERO_ADDRESS = address(0);\n\n    address[] public allPairs;\n\n    mapping(address =\u003e mapping(address =\u003e address)) public getPair;\n\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    constructor(\n        address _feeToSetter\n    ) {\n        if (_feeToSetter == ZERO_ADDRESS) {\n            revert(\"SwapsFactory: INVALID_INPUT\");\n        }\n\n        feeToSetter = _feeToSetter;\n        feeTo = _feeToSetter;\n\n        bytes32 salt;\n        address pair;\n\n        bytes memory bytecode = type(SwapsPair).creationCode;\n\n        assembly {\n            pair := create2(\n                0,\n                add(bytecode, 32),\n                mload(bytecode),\n                salt\n            )\n        }\n\n        cloneTarget = pair;\n    }\n\n    function allPairsLength()\n        external\n        view\n        returns (uint256)\n    {\n        return allPairs.length;\n    }\n\n    function createPair(\n        address _tokenA,\n        address _tokenB\n    )\n        external\n        returns (address pair)\n    {\n        require(\n            _tokenA != _tokenB,\n            \"SwapsFactory: IDENTICAL\"\n        );\n\n        (address token0, address token1) = _tokenA \u003c _tokenB\n            ? (_tokenA, _tokenB)\n            : (_tokenB, _tokenA);\n\n        require(\n            token0 != ZERO_ADDRESS,\n            \"SwapsFactory: ZERO_ADDRESS\"\n        );\n\n        require(\n            getPair[token0][token1] == ZERO_ADDRESS,\n            \"SwapsFactory: PAIR_ALREADY_EXISTS\"\n        );\n\n        bytes32 salt = keccak256(\n            abi.encodePacked(\n                token0,\n                token1\n            )\n        );\n\n        bytes20 targetBytes = bytes20(\n            cloneTarget\n        );\n\n        assembly {\n\n            let clone := mload(0x40)\n\n            mstore(\n                clone,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n\n            mstore(\n                add(clone, 0x14),\n                targetBytes\n            )\n\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n\n            pair := create2(0, clone, 0x37, salt)\n        }\n\n        ISwapsPair(pair).initialize(\n            token0,\n            token1\n        );\n\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair;\n\n        allPairs.push(pair);\n\n        emit PairCreated(\n            token0,\n            token1,\n            pair,\n            allPairs.length\n        );\n    }\n\n    function setFeeTo(\n        address _feeTo\n    )\n        external\n    {\n        require(\n            msg.sender == feeToSetter,\n            \"SwapsFactory: FORBIDDEN\"\n        );\n\n        require(\n            _feeTo != ZERO_ADDRESS,\n            \u0027SwapsFactory: ZERO_ADDRESS\u0027\n        );\n\n        feeTo = _feeTo;\n    }\n\n    function setFeeToSetter(\n        address _feeToSetter\n    )\n        external\n    {\n        require(\n            msg.sender == feeToSetter,\n            \"SwapsFactory: FORBIDDEN\"\n        );\n\n        require(\n            _feeToSetter != ZERO_ADDRESS,\n            \u0027SwapsFactory: ZERO_ADDRESS\u0027\n        );\n\n        feeToSetter = _feeToSetter;\n    }\n}\n\ncontract FactoryCodeCheck {\n\n    function factoryCodeHash()\n        external\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            type(SwapsFactory).creationCode\n        );\n    }\n\n    function pairCodeHash()\n        external\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            type(SwapsPair).creationCode\n        );\n    }\n}\n"},"SwapsHelper.sol":{"content":"// SPDX-License-Identifier: BCOM\n\npragma solidity =0.8.14;\n\ncontract SwapsHelper {\n\n    uint256 constant UINT256_MAX = type(uint256).max;\n    address constant ZERO_ADDRESS = address(0);\n\n    function sortTokens(\n        address _tokenA,\n        address _tokenB\n    )\n        internal\n        pure\n        returns (\n            address token0,\n            address token1\n        )\n    {\n        require(\n            _tokenA != _tokenB,\n            \"SwapsHelper: IDENTICAL_ADDRESSES\"\n        );\n\n        (token0, token1) = _tokenA \u003c _tokenB\n            ? (_tokenA, _tokenB)\n            : (_tokenB, _tokenA);\n\n        require(\n            token0 != ZERO_ADDRESS,\n            \"SwapsHelper: ZERO_ADDRESS\"\n        );\n    }\n\n    function quote(\n        uint256 _amountA,\n        uint256 _reserveA,\n        uint256 _reserveB\n    )\n        public\n        pure\n        returns (uint256 amountB)\n    {\n        require(\n            _amountA \u003e 0,\n            \"SwapsHelper: INSUFFICIENT_AMOUNT\"\n        );\n\n        require(\n            _reserveA \u003e 0 \u0026\u0026 _reserveB \u003e 0,\n            \"SwapsHelper: INSUFFICIENT_LIQUIDITY\"\n        );\n\n        amountB = _amountA\n            * _reserveB\n            / _reserveA;\n    }\n\n    function getAmountOut(\n        uint256 _amountIn,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    )\n        public\n        pure\n        returns (uint256 amountOut)\n    {\n        require(\n            _amountIn \u003e 0,\n            \"SwapsHelper: INSUFFICIENT_INPUT_AMOUNT\"\n        );\n\n        require(\n            _reserveIn \u003e 0 \u0026\u0026 _reserveOut \u003e 0,\n            \"SwapsHelper: INSUFFICIENT_LIQUIDITY\"\n        );\n\n        uint256 amountInWithFee = _amountIn * 997;\n        uint256 numerator = amountInWithFee * _reserveOut;\n        uint256 denominator = _reserveIn * 1000 + amountInWithFee;\n\n        amountOut = numerator / denominator;\n    }\n\n    function getAmountIn(\n        uint256 _amountOut,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    )\n        public\n        pure\n        returns (uint256 amountIn)\n    {\n        require(\n            _amountOut \u003e 0,\n            \"SwapsHelper: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n\n        require(\n            _reserveIn \u003e 0 \u0026\u0026\n            _reserveOut \u003e 0,\n            \"SwapsHelper: INSUFFICIENT_LIQUIDITY\"\n        );\n\n        uint256 numerator = _reserveIn * _amountOut * 1000;\n        uint256 denominator = (_reserveOut - _amountOut) * 997;\n\n        amountIn = numerator / denominator + 1;\n    }\n\n\n    bytes4 constant TRANSFER = bytes4(\n        keccak256(\n            bytes(\n                \"transfer(address,uint256)\"\n            )\n        )\n    );\n\n    bytes4 constant TRANSFER_FROM = bytes4(\n        keccak256(\n            bytes(\n                \"transferFrom(address,address,uint256)\"\n            )\n        )\n    );\n\n    function _safeTransfer(\n        address _token,\n        address _to,\n        uint256 _value\n    )\n        internal\n    {\n        (bool success, bytes memory data) = _token.call(\n            abi.encodeWithSelector(\n                TRANSFER,\n                _to,\n                _value\n            )\n        );\n\n        require(\n            success \u0026\u0026 (\n                data.length == 0 || abi.decode(\n                    data, (bool)\n                )\n            ),\n            \"SwapsHelper: TRANSFER_FAILED\"\n        );\n    }\n\n    function _safeTransferFrom(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        internal\n    {\n        (bool success, bytes memory data) = _token.call(\n            abi.encodeWithSelector(\n                TRANSFER_FROM,\n                _from,\n                _to,\n                _value\n            )\n        );\n\n        require(\n            success \u0026\u0026 (\n                data.length == 0 || abi.decode(\n                    data, (bool)\n                )\n            ),\n            \"SwapsHelper: TRANSFER_FROM_FAILED\"\n        );\n    }\n\n    function _safeTransferETH(\n        address to,\n        uint256 value\n    )\n        internal\n    {\n        (bool success,) = to.call{\n            value: value\n        }(new bytes(0));\n\n        require(\n            success,\n            \"SwapsHelper: ETH_TRANSFER_FAILED\"\n        );\n    }\n\n    function _pairFor(\n        address _factory,\n        address _tokenA,\n        address _tokenB,\n        address _implementation\n    )\n        internal\n        pure\n        returns (address predicted)\n    {\n        (address token0, address token1) = _tokenA \u003c _tokenB\n            ? (_tokenA, _tokenB)\n            : (_tokenB, _tokenA);\n\n        bytes32 salt = keccak256(\n            abi.encodePacked(\n                token0,\n                token1\n            )\n        );\n\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, _implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, _factory))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n}\n"},"SwapsPair.sol":{"content":"// SPDX-License-Identifier: BCOM\n\npragma solidity =0.8.14;\n\nimport \"./IERC20.sol\";\nimport \"./ISwapsFactory.sol\";\nimport \"./ISwapsCallee.sol\";\nimport \"./SwapsERC20.sol\";\n\ncontract SwapsPair is SwapsERC20 {\n\n    uint224 constant Q112 = 2 ** 112;\n    uint112 constant UINT112_MAX = type(uint112).max;\n    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;\n\n    bytes4 private constant SELECTOR = bytes4(\n        keccak256(bytes(\u0027transfer(address,uint256)\u0027))\n    );\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0;\n    uint112 private reserve1;\n    uint32  private blockTimestampLast;\n\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n\n    uint256 public kLast;\n    uint256 private unlocked;\n\n    modifier lock() {\n        require(\n            unlocked == 1,\n            \"SwapsPair: LOCKED\"\n        );\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    event Mint(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n\n    event Sync(\n        uint112 reserve0,\n        uint112 reserve1\n    );\n\n    function initialize(\n        address _token0,\n        address _token1\n    )\n        external\n    {\n        require(\n            factory == ZERO_ADDRESS,\n            \"SwapsPair: ALREADY_INITIALIZED\"\n        );\n\n        token0 = _token0;\n        token1 = _token1;\n        factory = msg.sender;\n        unlocked = 1;\n    }\n\n    function getReserves()\n        public\n        view\n        returns (\n            uint112,\n            uint112,\n            uint32\n        )\n    {\n        return (\n            reserve0,\n            reserve1,\n            blockTimestampLast\n        );\n    }\n\n    function _update(\n        uint256 _balance0,\n        uint256 _balance1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    )\n        private\n    {\n        require(\n            _balance0 \u003c= UINT112_MAX \u0026\u0026\n            _balance1 \u003c= UINT112_MAX,\n            \"SwapsPair: OVERFLOW\"\n        );\n\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n\n        unchecked {\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            if (timeElapsed \u003e 0 \u0026\u0026 _reserve0 != 0 \u0026\u0026 _reserve1 != 0) {\n                price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed;\n                price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed;\n            }\n        }\n\n        reserve0 = uint112(_balance0);\n        reserve1 = uint112(_balance1);\n\n        blockTimestampLast = blockTimestamp;\n\n        emit Sync(\n            reserve0,\n            reserve1\n        );\n    }\n\n    function _mintFee(\n        uint112 _reserve0,\n        uint112 _reserve1,\n        uint256 _kLast\n    )\n        private\n    {\n        if (_kLast == 0) return;\n\n        uint256 rootK = sqrt(uint256(_reserve0) * _reserve1);\n        uint256 rootKLast = sqrt(_kLast);\n\n        if (rootK \u003e rootKLast) {\n\n            uint256 liquidity = totalSupply\n                * (rootK - rootKLast)\n                / (rootK * 5 + rootKLast);\n\n            if (liquidity == 0) return;\n\n            _mint(\n                ISwapsFactory(factory).feeTo(),\n                liquidity\n            );\n        }\n    }\n\n    function mint(\n        address _to\n    )\n        external\n        lock\n        returns (uint256 liquidity)\n    {\n        (\n            uint112 _reserve0,\n            uint112 _reserve1,\n\n        ) = getReserves();\n\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n\n        uint256 amount0 = balance0 - _reserve0;\n        uint256 amount1 = balance1 - _reserve1;\n\n        _mintFee(\n            _reserve0,\n            _reserve1,\n            kLast\n        );\n\n        uint256 _totalSupply = totalSupply;\n\n        if (_totalSupply == 0) {\n\n            liquidity = sqrt(\n                amount0 * amount1\n            ) - MINIMUM_LIQUIDITY;\n\n            _mint(\n               ZERO_ADDRESS,\n               MINIMUM_LIQUIDITY\n            );\n\n        } else {\n\n            liquidity = min(\n                amount0 * _totalSupply / _reserve0,\n                amount1 * _totalSupply / _reserve1\n            );\n        }\n\n        require(\n            liquidity \u003e 0,\n            \"INSUFFICIENT_LIQUIDITY_MINTED\"\n        );\n\n        _mint(\n            _to,\n            liquidity\n        );\n\n        _update(\n            balance0,\n            balance1,\n            _reserve0,\n            _reserve1\n        );\n\n        kLast = uint256(reserve0) * reserve1;\n\n        emit Mint(\n            msg.sender,\n            amount0,\n            amount1\n        );\n    }\n\n    function burn(\n        address _to\n    )\n        external\n        lock\n        returns (\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        (\n            uint112 _reserve0,\n            uint112 _reserve1,\n\n        ) = getReserves();\n\n        address _token0 = token0;\n        address _token1 = token1;\n\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n\n        uint256 liquidity = balanceOf[address(this)];\n\n        _mintFee(\n            _reserve0,\n            _reserve1,\n            kLast\n        );\n\n        uint256 _totalSupply = totalSupply;\n\n        amount0 = liquidity * balance0 / _totalSupply;\n        amount1 = liquidity * balance1 / _totalSupply;\n\n        require(\n            amount0 \u003e 0 \u0026\u0026\n            amount1 \u003e 0,\n            \"INSUFFICIENT_LIQUIDITY_BURNED\"\n        );\n\n        _burn(\n            address(this),\n            liquidity\n        );\n\n        _safeTransfer(\n            _token0,\n            _to,\n            amount0\n        );\n\n        _safeTransfer(\n            _token1,\n            _to,\n            amount1\n        );\n\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(\n            balance0,\n            balance1,\n            _reserve0,\n            _reserve1\n        );\n\n        kLast = uint256(reserve0) * reserve1;\n\n        emit Burn(\n            msg.sender,\n            amount0,\n            amount1,\n            _to\n        );\n    }\n\n    function swap(\n        uint256 _amount0Out,\n        uint256 _amount1Out,\n        address _to,\n        bytes calldata _data\n    )\n        external\n        lock\n    {\n        require(\n            _amount0Out \u003e 0 ||\n            _amount1Out \u003e 0,\n            \"INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n\n        (\n            uint112 _reserve0,\n            uint112 _reserve1,\n\n        ) = getReserves();\n\n        require(\n            _amount0Out \u003c _reserve0 \u0026\u0026\n            _amount1Out \u003c _reserve1,\n            \"INSUFFICIENT_LIQUIDITY\"\n        );\n\n        uint256 balance0;\n        uint256 balance1;\n\n        {\n            address _token0 = token0;\n            address _token1 = token1;\n\n            if (_amount0Out \u003e 0) _safeTransfer(_token0, _to, _amount0Out);\n            if (_amount1Out \u003e 0) _safeTransfer(_token1, _to, _amount1Out);\n\n            if (_data.length \u003e 0) ISwapsCallee(_to).swapsCall(\n                msg.sender,\n                _amount0Out,\n                _amount1Out,\n                _data\n            );\n\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n\n        uint256 _amount0In =\n            balance0 \u003e _reserve0 - _amount0Out ?\n            balance0 - (_reserve0 - _amount0Out) : 0;\n\n        uint256 _amount1In =\n            balance1 \u003e _reserve1 - _amount1Out ?\n            balance1 - (_reserve1 - _amount1Out) : 0;\n\n        require(\n            _amount0In \u003e 0 ||\n            _amount1In \u003e 0,\n            \"INSUFFICIENT_INPUT_AMOUNT\"\n        );\n\n        {\n            uint256 balance0Adjusted = balance0 * 1000 - (_amount0In * 3);\n            uint256 balance1Adjusted = balance1 * 1000 - (_amount1In * 3);\n\n            require(\n                balance0Adjusted * balance1Adjusted \u003e=\n                uint256(_reserve0)\n                    * _reserve1\n                    * (1000 ** 2)\n            );\n        }\n\n        _update(\n            balance0,\n            balance1,\n            _reserve0,\n            _reserve1\n        );\n\n        emit Swap(\n            msg.sender,\n            _amount0In,\n            _amount1In,\n            _amount0Out,\n            _amount1Out,\n            _to\n        );\n    }\n\n    function skim()\n        external\n        lock\n    {\n        address _token0 = token0;\n        address _token1 = token1;\n        address _feesTo = ISwapsFactory(factory).feeTo();\n\n        _safeTransfer(\n            _token0,\n            _feesTo,\n            IERC20(_token0).balanceOf(address(this)) - reserve0\n        );\n\n        _safeTransfer(\n            _token1,\n            _feesTo,\n            IERC20(_token1).balanceOf(address(this)) - reserve1\n        );\n    }\n\n    function sync()\n        external\n        lock\n    {\n        _update(\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this)),\n            reserve0,\n            reserve1\n        );\n    }\n\n    function encode(\n        uint112 _y\n    )\n        pure\n        internal\n        returns (uint224 z)\n    {\n        unchecked {\n            z = uint224(_y) * Q112;\n        }\n    }\n\n    function uqdiv(\n        uint224 _x,\n        uint112 _y\n    )\n        pure\n        internal\n        returns (uint224 z)\n    {\n        unchecked {\n            z = _x / uint224(_y);\n        }\n    }\n\n    function min(\n        uint256 _x,\n        uint256 _y\n    )\n        internal\n        pure\n        returns (uint256 z)\n    {\n        z = _x \u003c _y ? _x : _y;\n    }\n\n    function sqrt(\n        uint256 _y\n    )\n        internal\n        pure\n        returns (uint256 z)\n    {\n        unchecked {\n            if (_y \u003e 3) {\n                z = _y;\n                uint256 x = _y / 2 + 1;\n                while (x \u003c z) {\n                    z = x;\n                    x = (_y / x + x) / 2;\n                }\n            } else if (_y != 0) {\n                z = 1;\n            }\n        }\n    }\n\n    function _safeTransfer(\n        address _token,\n        address _to,\n        uint256 _value\n    )\n        internal\n    {\n        (bool success, bytes memory data) = _token.call(\n            abi.encodeWithSelector(\n                SELECTOR,\n                _to,\n                _value\n            )\n        );\n\n        require(\n            success \u0026\u0026 (\n                data.length == 0 || abi.decode(\n                    data, (bool)\n                )\n            ),\n            \"SwapsPair: TRANSFER_FAILED\"\n        );\n    }\n}\n"},"SwapsRouter.sol":{"content":"// SPDX-License-Identifier: BCOM\n\npragma solidity =0.8.14;\n\nimport \"./IWETH.sol\";\nimport \"./IERC20.sol\";\nimport \"./ISwapsFactory.sol\";\nimport \"./ISwapsPair.sol\";\nimport \"./SwapsHelper.sol\";\n\ncontract SwapsRouter is SwapsHelper {\n\n    address public immutable FACTORY;\n    address public immutable WETH;\n    address public immutable PAIR;\n\n    modifier ensure(\n        uint256 _deadline\n    ) {\n        require(\n            _deadline \u003e= block.timestamp,\n            \"SwapsRouter: DEADLINE_EXPIRED\"\n        );\n        _;\n    }\n\n    constructor(\n        address _factory,\n        address _WETH\n    ) {\n        FACTORY = _factory;\n        WETH = _WETH;\n        PAIR = ISwapsFactory(_factory).cloneTarget();\n    }\n\n    receive()\n        external\n        payable\n    {\n        require(\n            msg.sender == WETH,\n            \"SwapsRouter: INVALID_SENDER\"\n        );\n    }\n\n    function _addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin\n    )\n        internal\n        returns (uint256, uint256)\n    {\n        if (ISwapsFactory(FACTORY).getPair(_tokenA, _tokenB) == ZERO_ADDRESS) {\n            ISwapsFactory(FACTORY).createPair(\n                _tokenA,\n                _tokenB\n            );\n        }\n\n        (\n            uint256 reserveA,\n            uint256 reserveB\n\n        ) = getReserves(\n            FACTORY,\n            _tokenA,\n            _tokenB\n        );\n\n        if (reserveA == 0 \u0026\u0026 reserveB == 0) {\n            return (\n                _amountADesired,\n                _amountBDesired\n            );\n        }\n\n        uint256 amountBOptimal = quote(\n            _amountADesired,\n            reserveA,\n            reserveB\n        );\n\n        if (amountBOptimal \u003c= _amountBDesired) {\n\n            require(\n                amountBOptimal \u003e= _amountBMin,\n                \"SwapsRouter: INSUFFICIENT_B_AMOUNT\"\n            );\n\n            return (\n                _amountADesired,\n                amountBOptimal\n            );\n        }\n\n        uint256 amountAOptimal = quote(\n            _amountBDesired,\n            reserveB,\n            reserveA\n        );\n\n        require(\n            amountAOptimal \u003c= _amountADesired,\n            \"SwapsRouter: INVALID_DESIRED_AMOUNT\"\n        );\n\n        require(\n            amountAOptimal \u003e= _amountAMin,\n            \"SwapsRouter: INSUFFICIENT_A_AMOUNT\"\n        );\n\n        return (\n            amountAOptimal,\n            _amountBDesired\n        );\n    }\n\n    function addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        ensure(_deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        (amountA, amountB) = _addLiquidity(\n            _tokenA,\n            _tokenB,\n            _amountADesired,\n            _amountBDesired,\n            _amountAMin,\n            _amountBMin\n        );\n\n        address pair = _pairFor(\n            FACTORY,\n            _tokenA,\n            _tokenB,\n            PAIR\n        );\n\n        _safeTransferFrom(\n            _tokenA,\n            msg.sender,\n            pair,\n            amountA\n        );\n\n        _safeTransferFrom(\n            _tokenB,\n            msg.sender,\n            pair,\n            amountB\n        );\n\n        liquidity = ISwapsPair(pair).mint(_to);\n    }\n\n    function addLiquidityETH(\n        address _token,\n        uint256 _amountTokenDesired,\n        uint256 _amountTokenMin,\n        uint256 _amountETHMin,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        ensure(_deadline)\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        (amountToken, amountETH) = _addLiquidity(\n            _token,\n            WETH,\n            _amountTokenDesired,\n            msg.value,\n            _amountTokenMin,\n            _amountETHMin\n        );\n\n        address pair = _pairFor(\n            FACTORY,\n            _token,\n            WETH,\n            PAIR\n        );\n\n        _safeTransferFrom(\n            _token,\n            msg.sender,\n            pair,\n            amountToken\n        );\n\n        IWETH(WETH).deposit{\n            value: amountETH\n        }();\n\n        require(\n            IWETH(WETH).transfer(\n                pair,\n                amountETH\n            ),\n            \"SwapsRouter: TRANSFER_FAIL\"\n        );\n\n        liquidity = ISwapsPair(pair).mint(_to);\n\n        if (msg.value \u003e amountETH) {\n            unchecked {\n                _safeTransferETH(\n                    msg.sender,\n                    msg.value - amountETH\n                );\n            }\n        }\n    }\n\n    function removeLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _liquidity,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        public\n        ensure(_deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB\n        )\n    {\n        address pair = _pairFor(\n            FACTORY,\n            _tokenA,\n            _tokenB,\n            PAIR\n        );\n\n        _safeTransferFrom(\n            pair,\n            msg.sender,\n            pair,\n            _liquidity\n        );\n\n        (\n            uint256 amount0,\n            uint256 amount1\n\n        ) = ISwapsPair(pair).burn(_to);\n\n        (address token0,) = sortTokens(\n            _tokenA,\n            _tokenB\n        );\n\n        (amountA, amountB) = _tokenA == token0\n            ? (amount0, amount1)\n            : (amount1, amount0);\n\n        require(\n            amountA \u003e= _amountAMin,\n            \"SwapsRouter: INSUFFICIENT_A_AMOUNT\"\n        );\n\n        require(\n            amountB \u003e= _amountBMin,\n            \"SwapsRouter: INSUFFICIENT_B_AMOUNT\"\n        );\n    }\n\n    function removeLiquidityETH(\n        address _token,\n        uint256 _liquidity,\n        uint256 _amountTokenMin,\n        uint256 _amountETHMin,\n        address _to,\n        uint256 _deadline\n    )\n        public\n        ensure(_deadline)\n        returns (\n            uint256 amountToken,\n            uint256 amountETH\n        )\n    {\n        (amountToken, amountETH) = removeLiquidity(\n            _token,\n            WETH,\n            _liquidity,\n            _amountTokenMin,\n            _amountETHMin,\n            address(this),\n            _deadline\n        );\n\n        _safeTransfer(\n            _token,\n            _to,\n            amountToken\n        );\n\n        IWETH(WETH).withdraw(\n            amountETH\n        );\n\n        _safeTransferETH(\n            _to,\n            amountETH\n        );\n    }\n\n    function removeLiquidityWithPermit(\n        address _tokenA,\n        address _tokenB,\n        uint256 _liquidity,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n        returns (uint256, uint256)\n    {\n        address pair = _pairFor(\n            FACTORY,\n            _tokenA,\n            _tokenB,\n            PAIR\n        );\n\n        uint256 value = _approveMax\n            ? UINT256_MAX\n            : _liquidity;\n\n        ISwapsPair(pair).permit(\n            msg.sender,\n            address(this),\n            value,\n            _deadline,\n            _v,\n            _r,\n            _s\n        );\n\n        return removeLiquidity(\n            _tokenA,\n            _tokenB,\n            _liquidity,\n            _amountAMin,\n            _amountBMin,\n            _to,\n            _deadline\n        );\n    }\n\n    function removeLiquidityETHWithPermit(\n        address _token,\n        uint256 _liquidity,\n        uint256 _amountTokenMin,\n        uint256 _amountETHMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n        returns (uint256, uint256)\n    {\n        address pair = _pairFor(\n            FACTORY,\n            _token,\n            WETH,\n            PAIR\n        );\n\n        uint256 value = _approveMax\n            ? UINT256_MAX\n            : _liquidity;\n\n        ISwapsPair(pair).permit(\n            msg.sender,\n            address(this),\n            value,\n            _deadline,\n            _v,\n            _r,\n            _s\n        );\n\n        return removeLiquidityETH(\n            _token,\n            _liquidity,\n            _amountTokenMin,\n            _amountETHMin,\n            _to,\n            _deadline\n        );\n    }\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address _token,\n        uint256 _liquidity,\n        uint256 _amountTokenMin,\n        uint256 _amountETHMin,\n        address _to,\n        uint256 _deadline\n    )\n        public\n        ensure(_deadline)\n        returns (uint256 amountETH)\n    {\n        (, amountETH) = removeLiquidity(\n            _token,\n            WETH,\n            _liquidity,\n            _amountTokenMin,\n            _amountETHMin,\n            address(this),\n            _deadline\n        );\n\n        _safeTransfer(\n            _token,\n            _to,\n            IERC20(_token).balanceOf(address(this))\n        );\n\n        IWETH(WETH).withdraw(\n            amountETH\n        );\n\n        _safeTransferETH(\n            _to,\n            amountETH\n        );\n    }\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address _token,\n        uint256 _liquidity,\n        uint256 _amountTokenMin,\n        uint256 _amountETHMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n        returns (uint256 amountETH)\n    {\n        address pair = _pairFor(\n            FACTORY,\n            _token,\n            WETH,\n            PAIR\n        );\n\n        uint256 value = _approveMax\n            ? UINT256_MAX\n            : _liquidity;\n\n        ISwapsPair(pair).permit(\n            msg.sender,\n            address(this),\n            value,\n            _deadline,\n            _v,\n            _r,\n            _s\n        );\n\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n            _token,\n            _liquidity,\n            _amountTokenMin,\n            _amountETHMin,\n            _to,\n            _deadline\n        );\n    }\n\n    function _swap(\n        uint256[] memory _amounts,\n        address[] memory _path,\n        address _to\n    )\n        internal\n    {\n        for (uint256 i; i \u003c _path.length - 1; i++) {\n\n            (address input, address output) = (\n                _path[i],\n                _path[i + 1]\n            );\n\n            (address token0,) = sortTokens(\n                input,\n                output\n            );\n\n            uint256 amountOut = _amounts[i + 1];\n\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint(0), amountOut)\n                : (amountOut, uint(0));\n\n            address to = i \u003c _path.length - 2\n                ? _pairFor(FACTORY, output, _path[i + 2], PAIR)\n                : _to;\n\n            ISwapsPair(\n                _pairFor(\n                    FACTORY,\n                    input,\n                    output,\n                    PAIR\n                )\n            ).swap(\n                amount0Out,\n                amount1Out,\n                to,\n                new bytes(0)\n            );\n        }\n    }\n\n    function swapExactTokensForTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        ensure(_deadline)\n        returns (uint256[] memory amounts)\n    {\n        amounts = _getAmountsOut(\n            FACTORY,\n            _amountIn,\n            _path\n        );\n\n        require(\n            amounts[amounts.length - 1] \u003e= _amountOutMin,\n            \"SwapsRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n\n        _safeTransferFrom(\n            _path[0],\n            msg.sender,\n            _pairFor(\n                FACTORY,\n                _path[0],\n                _path[1],\n                PAIR\n            ),\n            amounts[0]\n        );\n\n        _swap(\n            amounts,\n            _path,\n            _to\n        );\n    }\n\n    function swapTokensForExactTokens(\n        uint256 _amountOut,\n        uint256 _amountInMax,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        ensure(_deadline)\n        returns (uint256[] memory amounts)\n    {\n        amounts = _getAmountsIn(\n            FACTORY,\n            _amountOut,\n            _path\n        );\n\n        require(\n            amounts[0] \u003c= _amountInMax,\n            \"SwapsRouter: EXCESSIVE_INPUT_AMOUNT\"\n        );\n\n        _safeTransferFrom(\n            _path[0],\n            msg.sender,\n            _pairFor(\n                FACTORY,\n                _path[0],\n                _path[1],\n                PAIR\n            ),\n            amounts[0]\n        );\n\n        _swap(\n            amounts,\n            _path,\n            _to\n        );\n    }\n\n    function swapExactETHForTokens(\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        ensure(_deadline)\n        returns (uint256[] memory amounts)\n    {\n        require(\n            _path[0] == WETH,\n            \"SwapsRouter: INVALID_PATH\"\n        );\n\n        amounts = _getAmountsOut(\n            FACTORY,\n            msg.value,\n            _path\n        );\n\n        require(\n            amounts[amounts.length - 1] \u003e= _amountOutMin,\n            \"SwapsRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n\n        IWETH(WETH).deposit{\n            value: amounts[0]\n        }();\n\n        require(\n            IWETH(WETH).transfer(\n                _pairFor(\n                    FACTORY,\n                    _path[0],\n                    _path[1],\n                    PAIR\n                ),\n                amounts[0]\n            ),\n            \"SwapsRouter: TRANSFER_FAIL\"\n        );\n\n        _swap(\n            amounts,\n            _path,\n            _to\n        );\n    }\n\n    function swapTokensForExactETH(\n        uint256 _amountOut,\n        uint256 _amountInMax,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        ensure(_deadline)\n        returns (uint256[] memory amounts)\n    {\n        require(\n            _path[_path.length - 1] == WETH,\n            \"SwapsRouter: INVALID_PATH\"\n        );\n\n        amounts = _getAmountsIn(\n            FACTORY,\n            _amountOut,\n            _path\n        );\n\n        require(\n            amounts[0] \u003c= _amountInMax,\n            \"SwapsRouter: EXCESSIVE_INPUT_AMOUNT\"\n        );\n\n        _safeTransferFrom(\n            _path[0],\n            msg.sender,\n            _pairFor(\n                FACTORY,\n                _path[0],\n                _path[1],\n                PAIR\n            ),\n            amounts[0]\n        );\n\n        _swap(\n            amounts,\n            _path,\n            address(this)\n        );\n\n        IWETH(WETH).withdraw(\n            amounts[amounts.length - 1]\n        );\n\n        _safeTransferETH(\n            _to,\n            amounts[amounts.length - 1]\n        );\n    }\n\n    function swapExactTokensForETH(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        ensure(_deadline)\n        returns (uint256[] memory amounts)\n    {\n        require(\n            _path[_path.length - 1] == WETH,\n            \"SwapsRouter: INVALID_PATH\"\n        );\n\n        amounts = _getAmountsOut(\n            FACTORY,\n            _amountIn,\n            _path\n        );\n\n        require(\n            amounts[amounts.length - 1] \u003e= _amountOutMin,\n            \"SwapsRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n\n        _safeTransferFrom(\n            _path[0],\n            msg.sender,\n            _pairFor(\n                FACTORY,\n                _path[0],\n                _path[1],\n                PAIR\n            ),\n            amounts[0]\n        );\n\n        _swap(\n            amounts,\n            _path,\n            address(this)\n        );\n\n        IWETH(WETH).withdraw(\n            amounts[amounts.length - 1]\n        );\n\n        _safeTransferETH(\n            _to,\n            amounts[amounts.length - 1]\n        );\n    }\n\n    function swapETHForExactTokens(\n        uint256 _amountOut,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        ensure(_deadline)\n        returns (uint256[] memory amounts)\n    {\n        require(\n            _path[0] == WETH,\n            \"SwapsRouter: INVALID_PATH\"\n        );\n\n        amounts = _getAmountsIn(\n            FACTORY,\n            _amountOut,\n            _path\n        );\n\n        require(\n            amounts[0] \u003c= msg.value,\n            \"SwapsRouter: EXCESSIVE_INPUT_AMOUNT\"\n        );\n\n        IWETH(WETH).deposit{\n            value: amounts[0]\n        }();\n\n        require(\n            IWETH(WETH).transfer(\n                _pairFor(\n                    FACTORY,\n                    _path[0],\n                    _path[1],\n                    PAIR\n                ),\n                amounts[0]\n            ),\n            \"SwapsRouter: TRANSFER_FAIL\"\n        );\n\n        _swap(\n            amounts,\n            _path,\n            _to\n        );\n\n        if (msg.value \u003e amounts[0]) {\n            unchecked {\n                _safeTransferETH(\n                    msg.sender,\n                    msg.value - amounts[0]\n                );\n            }\n        }\n    }\n\n    function _swapSupportingFeeOnTransferTokens(\n        address[] memory _path,\n        address _to\n    )\n        internal\n    {\n        for (uint256 i; i \u003c _path.length - 1; i++) {\n\n            (address input, address output) = (\n                _path[i],\n                _path[i + 1]\n            );\n\n            (address token0,) = sortTokens(\n                input,\n                output\n            );\n\n            ISwapsPair pair = ISwapsPair(\n                _pairFor(\n                    FACTORY,\n                    input,\n                    output,\n                    PAIR\n                )\n            );\n\n            uint256 amountInput;\n            uint256 amountOutput;\n\n            {\n\n            (\n                uint256 reserve0,\n                uint256 reserve1,\n\n            ) = pair.getReserves();\n\n            (uint256 reserveInput, uint256 reserveOutput) = input == token0\n                ? (reserve0, reserve1)\n                : (reserve1, reserve0);\n\n            amountInput = IERC20(input).balanceOf(address(pair)) - reserveInput;\n            amountOutput = getAmountOut(\n                amountInput,\n                reserveInput,\n                reserveOutput\n            );\n\n            }\n\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint(0), amountOutput)\n                : (amountOutput, uint(0));\n\n            address to = i \u003c _path.length - 2\n                ? _pairFor(FACTORY, output, _path[i + 2], PAIR)\n                : _to;\n\n            pair.swap(\n                amount0Out,\n                amount1Out,\n                to,\n                new bytes(0)\n            );\n        }\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        ensure(_deadline)\n    {\n        _safeTransferFrom(\n            _path[0],\n            msg.sender,\n            _pairFor(\n                FACTORY,\n                _path[0],\n                _path[1],\n                PAIR\n            ),\n            _amountIn\n        );\n\n        uint256 balanceBefore = IERC20(_path[_path.length - 1]).balanceOf(_to);\n\n        _swapSupportingFeeOnTransferTokens(\n            _path,\n            _to\n        );\n\n        require(\n            IERC20(_path[_path.length - 1]).balanceOf(_to) - balanceBefore \u003e= _amountOutMin,\n            \"SwapsRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n    }\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        ensure(_deadline)\n    {\n        require(\n            _path[0] == WETH,\n            \"SwapsRouter: INVALID_PATH\"\n        );\n\n        uint256 amountIn = msg.value;\n\n        IWETH(WETH).deposit{\n            value: amountIn\n        }();\n\n        require(\n            IWETH(WETH).transfer(\n                _pairFor(\n                    FACTORY,\n                    _path[0],\n                    _path[1],\n                    PAIR\n                ),\n                amountIn\n            ),\n            \"SwapsRouter: TRANSFER_FAIL\"\n        );\n\n        uint256 balanceBefore = IERC20(_path[_path.length - 1]).balanceOf(_to);\n\n        _swapSupportingFeeOnTransferTokens(\n            _path,\n            _to\n        );\n\n        require(\n            IERC20(_path[_path.length - 1]).balanceOf(_to) - balanceBefore \u003e= _amountOutMin,\n            \"SwapsRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n    }\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        ensure(_deadline)\n    {\n        require(\n            _path[_path.length - 1] == WETH,\n            \"SwapsRouter: INVALID_PATH\"\n        );\n\n        _safeTransferFrom(\n            _path[0],\n            msg.sender,\n            _pairFor(\n                FACTORY,\n                _path[0],\n                _path[1],\n                PAIR\n            ),\n            _amountIn\n        );\n\n        _swapSupportingFeeOnTransferTokens(\n            _path,\n            address(this)\n        );\n\n        uint256 amountOut = IERC20(WETH).balanceOf(\n            address(this)\n        );\n\n        require(\n            amountOut \u003e= _amountOutMin,\n            \"SwapsRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n\n        IWETH(WETH).withdraw(\n            amountOut\n        );\n\n        _safeTransferETH(\n            _to,\n            amountOut\n        );\n    }\n\n    function pairFor(\n        address _factory,\n        address _tokenA,\n        address _tokenB\n    )\n        external\n        view\n        returns (address predicted)\n    {\n        predicted = _pairFor(\n            _factory,\n            _tokenA,\n            _tokenB,\n            PAIR\n        );\n    }\n\n    function getAmountsOut(\n        uint256 _amountIn,\n        address[] memory _path\n    )\n        external\n        view\n        returns (uint256[] memory amounts)\n    {\n        return _getAmountsOut(\n            FACTORY,\n            _amountIn,\n            _path\n        );\n    }\n\n    function getAmountsIn(\n        uint256 _amountOut,\n        address[] memory _path\n    )\n        external\n        view\n        returns (uint256[] memory amounts)\n    {\n        return _getAmountsIn(\n            FACTORY,\n            _amountOut,\n            _path\n        );\n    }\n\n    function getReserves(\n        address _factory,\n        address _tokenA,\n        address _tokenB\n    )\n        internal\n        view\n        returns (\n            uint256 reserveA,\n            uint256 reserveB\n        )\n    {\n        (address token0,) = sortTokens(\n            _tokenA,\n            _tokenB\n        );\n\n        (\n            uint256 reserve0,\n            uint256 reserve1,\n\n        ) = ISwapsPair(\n            _pairFor(\n                _factory,\n                _tokenA,\n                _tokenB,\n                PAIR\n            )\n        ).getReserves();\n\n        (reserveA, reserveB) = _tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    function _getAmountsOut(\n        address _factory,\n        uint256 _amountIn,\n        address[] memory _path\n    )\n        internal\n        view\n        returns (uint256[] memory amounts)\n    {\n        require(\n            _path.length \u003e= 2,\n            \"SwapsRouter: INVALID_PATH\"\n        );\n\n        amounts = new uint256[](\n            _path.length\n        );\n\n        amounts[0] = _amountIn;\n\n        for (uint256 i; i \u003c _path.length - 1; i++) {\n\n            (\n                uint256 reserveIn,\n                uint256 reserveOut\n\n            ) = getReserves(\n                _factory,\n                _path[i],\n                _path[i + 1]\n            );\n\n            amounts[i + 1] = getAmountOut(\n                amounts[i],\n                reserveIn,\n                reserveOut\n            );\n        }\n    }\n\n    function _getAmountsIn(\n        address _factory,\n        uint256 _amountOut,\n        address[] memory _path\n    )\n        internal\n        view\n        returns (uint256[] memory amounts)\n    {\n        require(\n            _path.length \u003e= 2,\n            \"SwapsRouter: INVALID_PATH\"\n        );\n\n        amounts = new uint256[](\n            _path.length\n        );\n\n        amounts[amounts.length - 1] = _amountOut;\n\n        for (uint256 i = _path.length - 1; i \u003e 0; i--) {\n\n            (\n                uint256 reserveIn,\n                uint256 reserveOut\n\n            ) = getReserves(\n                _factory,\n                _path[i - 1],\n                _path[i]\n            );\n\n            amounts[i - 1] = getAmountIn(\n                amounts[i],\n                reserveIn,\n                reserveOut\n            );\n        }\n    }\n}\n\ncontract RouterCodeCheck {\n\n    function routerCodeHash()\n        external\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            type(SwapsRouter).creationCode\n        );\n    }\n}\n"}}