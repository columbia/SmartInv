{{
  "language": "Solidity",
  "sources": {
    "StrategyZaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"SafeERC20.sol\";\nimport \"ReentrancyGuard.sol\";\nimport \"ERC20.sol\";\nimport \"UnionBase.sol\";\nimport \"IGenericVault.sol\";\nimport \"IUniV2Router.sol\";\nimport \"ICurveTriCrypto.sol\";\nimport \"IERC4626.sol\";\nimport \"IPirexCVX.sol\";\n\ncontract PCvxZaps is UnionBase, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    address private constant PIREX_CVX =\n        0x35A398425d9f1029021A92bc3d2557D42C8588D7;\n    address private constant PXCVX_TOKEN =\n        0xBCe0Cf87F513102F22232436CCa2ca49e815C3aC;\n    address private constant PXCVX_VAULT =\n        0x8659Fc767cad6005de79AF65dAfE4249C57927AF;\n    address private constant WETH_TOKEN =\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant TRICRYPTO =\n        0xD51a44d3FaE010294C616388b506AcdA1bfAAE46;\n    address private constant USDT_TOKEN =\n        0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address private constant CURVE_CVX_PCVX_POOL =\n        0xF3456E8061461e144b3f252E69DcD5b6070fdEE0;\n    IERC4626 vault = IERC4626(PXCVX_VAULT);\n    ICurveTriCrypto triCryptoSwap = ICurveTriCrypto(TRICRYPTO);\n\n    /// @notice Set approvals for the contracts used when swapping & staking\n    function setApprovals() external {\n        IERC20(PXCVX_TOKEN).safeApprove(PXCVX_VAULT, 0);\n        IERC20(PXCVX_TOKEN).safeApprove(PXCVX_VAULT, type(uint256).max);\n\n        IERC20(CVX_TOKEN).safeApprove(PIREX_CVX, 0);\n        IERC20(CVX_TOKEN).safeApprove(PIREX_CVX, type(uint256).max);\n\n        IERC20(CVX_TOKEN).safeApprove(CURVE_CVX_ETH_POOL, 0);\n        IERC20(CVX_TOKEN).safeApprove(CURVE_CVX_ETH_POOL, type(uint256).max);\n\n        IERC20(CVX_TOKEN).safeApprove(CURVE_CVX_PCVX_POOL, 0);\n        IERC20(CVX_TOKEN).safeApprove(CURVE_CVX_PCVX_POOL, type(uint256).max);\n\n        IERC20(PXCVX_TOKEN).safeApprove(CURVE_CVX_PCVX_POOL, 0);\n        IERC20(PXCVX_TOKEN).safeApprove(CURVE_CVX_PCVX_POOL, type(uint256).max);\n\n        IERC20(CVXCRV_TOKEN).safeApprove(CURVE_CVXCRV_CRV_POOL, 0);\n        IERC20(CVXCRV_TOKEN).safeApprove(\n            CURVE_CVXCRV_CRV_POOL,\n            type(uint256).max\n        );\n\n        IERC20(CRV_TOKEN).safeApprove(CURVE_CRV_ETH_POOL, 0);\n        IERC20(CRV_TOKEN).safeApprove(CURVE_CRV_ETH_POOL, type(uint256).max);\n\n        IERC20(CRV_TOKEN).safeApprove(CURVE_CVXCRV_CRV_POOL, 0);\n        IERC20(CRV_TOKEN).safeApprove(CURVE_CVXCRV_CRV_POOL, type(uint256).max);\n    }\n\n    function _deposit(\n        uint256 _amount,\n        uint256 _minAmountOut,\n        address _to\n    ) internal {\n        if (ICurveV2Pool(CURVE_CVX_PCVX_POOL).price_oracle() < 1 ether) {\n            uint256 _pxCvxAmount = ICurveV2Pool(CURVE_CVX_PCVX_POOL).exchange(\n                0,\n                1,\n                _amount,\n                _minAmountOut,\n                false,\n                address(this)\n            );\n            vault.deposit(_pxCvxAmount, _to);\n        } else {\n            require(_amount >= _minAmountOut, \"slippage\");\n            IPirexCVX(PIREX_CVX).deposit(_amount, _to, true, address(0));\n        }\n    }\n\n    /// @notice Deposit into the pounder from ETH\n    /// @param minAmountOut - min amount of pCVX tokens expected\n    /// @param to - address to stake on behalf of\n    function depositFromEth(uint256 minAmountOut, address to)\n        external\n        payable\n        notToZeroAddress(to)\n    {\n        require(msg.value > 0, \"cheap\");\n        _depositFromEth(msg.value, minAmountOut, to);\n    }\n\n    /// @notice Deposit into the pounder from CRV\n    /// @param minAmountOut - min amount of pCVX tokens expected\n    /// @param to - address to stake on behalf of\n    function depositFromCrv(\n        uint256 amount,\n        uint256 minAmountOut,\n        address to\n    ) external notToZeroAddress(to) {\n        IERC20(CRV_TOKEN).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 _ethBalance = _swapCrvToEth(amount);\n        _depositFromEth(_ethBalance, minAmountOut, to);\n    }\n\n    /// @notice Deposit into the pounder from CVX\n    /// @param minAmountOut - min amount of pCVX tokens expected\n    /// @param to - address to stake on behalf of\n    function depositFromCvx(\n        uint256 amount,\n        uint256 minAmountOut,\n        address to\n    ) external notToZeroAddress(to) {\n        IERC20(CVX_TOKEN).safeTransferFrom(msg.sender, address(this), amount);\n        _deposit(amount, minAmountOut, to);\n    }\n\n    /// @notice Deposit into the pounder from cvxCRV\n    /// @param minAmountOut - min amount of pCVX tokens expected\n    /// @param to - address to stake on behalf of\n    function depositFromCvxCrv(\n        uint256 amount,\n        uint256 minAmountOut,\n        address to\n    ) external notToZeroAddress(to) {\n        IERC20(CVXCRV_TOKEN).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n        uint256 _crvBalance = _swapCvxCrvToCrv(amount, address(this));\n        uint256 _ethBalance = _swapCrvToEth(_crvBalance);\n        _depositFromEth(_ethBalance, minAmountOut, to);\n    }\n\n    /// @notice Internal function to deposit ETH to the pounder\n    /// @param _amount - amount of ETH\n    /// @param _minAmountOut - min amount of tokens expected\n    /// @param _to - address to stake on behalf of\n    function _depositFromEth(\n        uint256 _amount,\n        uint256 _minAmountOut,\n        address _to\n    ) internal {\n        uint256 _cvxBalance = _swapEthToCvx(_amount);\n        _deposit(_cvxBalance, _minAmountOut, _to);\n    }\n\n    /// @notice Deposit into the pounder from any token via Uni interface\n    /// @notice Use at your own risk\n    /// @dev Zap contract needs approval for spending of inputToken\n    /// @param amount - min amount of input token\n    /// @param minAmountOut - min amount of cvxCRV expected\n    /// @param router - address of the router to use. e.g. 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F for Sushi\n    /// @param inputToken - address of the token to swap from, needs to have an ETH pair on router used\n    /// @param to - address to stake on behalf of\n    function depositViaUniV2EthPair(\n        uint256 amount,\n        uint256 minAmountOut,\n        address router,\n        address inputToken,\n        address to\n    ) external notToZeroAddress(to) {\n        require(router != address(0));\n\n        IERC20(inputToken).safeTransferFrom(msg.sender, address(this), amount);\n        address[] memory _path = new address[](2);\n        _path[0] = inputToken;\n        _path[1] = WETH_TOKEN;\n\n        IERC20(inputToken).safeApprove(router, 0);\n        IERC20(inputToken).safeApprove(router, amount);\n\n        IUniV2Router(router).swapExactTokensForETH(\n            amount,\n            1,\n            _path,\n            address(this),\n            block.timestamp + 1\n        );\n        _depositFromEth(address(this).balance, minAmountOut, to);\n    }\n\n    /// @notice Unstake and converts pxCVX to CVX\n    /// @param _amount - amount to withdraw\n    /// @param _minAmountOut - minimum amount of LP tokens expected\n    /// @param _to - receiver\n    /// @return amount of underlying withdrawn\n    function _claimAsCvx(\n        uint256 _amount,\n        uint256 _minAmountOut,\n        address _to\n    ) internal returns (uint256) {\n        return\n            ICurveV2Pool(CURVE_CVX_PCVX_POOL).exchange(\n                1,\n                0,\n                _amount,\n                _minAmountOut,\n                false,\n                _to\n            );\n    }\n\n    /// @notice Retrieves a user's vault shares and withdraw all\n    /// @param _amount - amount of shares to retrieve\n    function _claimAndWithdraw(uint256 _amount) internal {\n        require(\n            vault.transferFrom(msg.sender, address(this), _amount),\n            \"error\"\n        );\n        vault.redeem(_amount, address(this), address(this));\n    }\n\n    /// @notice Claim as CVX\n    /// @param amount - amount to withdraw\n    /// @param minAmountOut - minimum amount of underlying tokens expected\n    /// @param to - address to send withdrawn underlying to\n    /// @return amount of underlying withdrawn\n    function claimFromVaultAsCvx(\n        uint256 amount,\n        uint256 minAmountOut,\n        address to\n    ) public notToZeroAddress(to) returns (uint256) {\n        _claimAndWithdraw(amount);\n        return\n            _claimAsCvx(\n                IERC20(PXCVX_TOKEN).balanceOf(address(this)),\n                minAmountOut,\n                to\n            );\n    }\n\n    /// @notice Claim as native ETH\n    /// @param amount - amount to withdraw\n    /// @param minAmountOut - minimum amount of ETH expected\n    /// @param to - address to send ETH to\n    /// @return amount of ETH withdrawn\n    function claimFromVaultAsEth(\n        uint256 amount,\n        uint256 minAmountOut,\n        address to\n    ) public notToZeroAddress(to) returns (uint256) {\n        uint256 _ethAmount = _claimAsEth(amount);\n        require(_ethAmount >= minAmountOut, \"slippage\");\n        (bool success, ) = to.call{value: _ethAmount}(\"\");\n        require(success, \"ETH transfer failed\");\n        return _ethAmount;\n    }\n\n    /// @notice Withdraw as native ETH (internal)\n    /// @param _amount - amount to withdraw\n    /// @return amount of ETH withdrawn\n    function _claimAsEth(uint256 _amount)\n        public\n        nonReentrant\n        returns (uint256)\n    {\n        _claimAndWithdraw(_amount);\n        uint256 _cvxAmount = _claimAsCvx(\n            IERC20(PXCVX_TOKEN).balanceOf(address(this)),\n            0,\n            address(this)\n        );\n        return\n            cvxEthSwap.exchange_underlying(\n                CVXETH_CVX_INDEX,\n                CVXETH_ETH_INDEX,\n                _cvxAmount,\n                0\n            );\n    }\n\n    /// @notice Claim to any token via a univ2 router\n    /// @notice Use at your own risk\n    /// @param amount - amount to unstake\n    /// @param minAmountOut - min amount of output token expected\n    /// @param router - address of the router to use. e.g. 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F for Sushi\n    /// @param outputToken - address of the token to swap to\n    /// @param to - address of the final recipient of the swapped tokens\n    function claimFromVaultViaUniV2EthPair(\n        uint256 amount,\n        uint256 minAmountOut,\n        address router,\n        address outputToken,\n        address to\n    ) public notToZeroAddress(to) {\n        require(router != address(0));\n        _claimAsEth(amount);\n        address[] memory _path = new address[](2);\n        _path[0] = WETH_TOKEN;\n        _path[1] = outputToken;\n        IUniV2Router(router).swapExactETHForTokens{\n            value: address(this).balance\n        }(minAmountOut, _path, to, block.timestamp + 1);\n    }\n\n    /// @notice Claim as USDT via Tricrypto\n    /// @param amount - the amount to unstake\n    /// @param minAmountOut - the min expected amount of USDT to receive\n    /// @param to - the adress that will receive the USDT\n    /// @return amount of USDT obtained\n    function claimFromVaultAsUsdt(\n        uint256 amount,\n        uint256 minAmountOut,\n        address to\n    ) public notToZeroAddress(to) returns (uint256) {\n        uint256 _ethAmount = _claimAsEth(amount);\n        _swapEthToUsdt(_ethAmount, minAmountOut);\n        uint256 _usdtAmount = IERC20(USDT_TOKEN).balanceOf(address(this));\n        IERC20(USDT_TOKEN).safeTransfer(to, _usdtAmount);\n        return _usdtAmount;\n    }\n\n    /// @notice Withdraw as CRV (internal)\n    /// @param _amount - amount to withdraw\n    /// @param _minAmountOut - min amount received\n    /// @return amount of CRV withdrawn\n    function _claimAsCrv(uint256 _amount, uint256 _minAmountOut)\n        internal\n        returns (uint256)\n    {\n        uint256 _ethAmount = _claimAsEth(_amount);\n        return _swapEthToCrv(_ethAmount, _minAmountOut);\n    }\n\n    /// @notice Claim as CRV\n    /// @param amount - the amount to unstake\n    /// @param minAmountOut - the min expected amount received\n    /// @param to - receiver address\n    /// @return amount obtained\n    function claimFromVaultAsCrv(\n        uint256 amount,\n        uint256 minAmountOut,\n        address to\n    ) public notToZeroAddress(to) returns (uint256) {\n        uint256 _crvAmount = _claimAsCrv(amount, minAmountOut);\n        IERC20(CRV_TOKEN).safeTransfer(to, _crvAmount);\n        return _crvAmount;\n    }\n\n    /// @notice Claim as cvxCRV\n    /// @param amount - the amount to unstake\n    /// @param minAmountOut - the min expected amount received\n    /// @param to - receiver address\n    /// @return amount obtained\n    function claimFromVaultAsCvxCrv(\n        uint256 amount,\n        uint256 minAmountOut,\n        address to\n    ) public notToZeroAddress(to) returns (uint256) {\n        uint256 _crvAmount = _claimAsCrv(amount, 0);\n        return _swapCrvToCvxCrv(_crvAmount, to, minAmountOut);\n    }\n\n    /// @notice swap ETH to USDT via Curve's tricrypto\n    /// @param _amount - the amount of ETH to swap\n    /// @param _minAmountOut - the minimum amount expected\n    function _swapEthToUsdt(uint256 _amount, uint256 _minAmountOut) internal {\n        triCryptoSwap.exchange{value: _amount}(\n            2, // ETH\n            0, // USDT\n            _amount,\n            _minAmountOut,\n            true\n        );\n    }\n\n    receive() external payable {}\n}\n"
    },
    "SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"IERC20.sol\";\nimport \"Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"IERC20.sol\";\nimport \"IERC20Metadata.sol\";\nimport \"Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "UnionBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"ICurveV2Pool.sol\";\nimport \"ICurveFactoryPool.sol\";\nimport \"IBasicRewards.sol\";\n\n// Common variables and functions\ncontract UnionBase {\n    address public constant CVXCRV_STAKING_CONTRACT =\n        0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e;\n    address public constant CURVE_CRV_ETH_POOL =\n        0x8301AE4fc9c624d1D396cbDAa1ed877821D7C511;\n    address public constant CURVE_CVX_ETH_POOL =\n        0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4;\n    address public constant CURVE_CVXCRV_CRV_POOL =\n        0x9D0464996170c6B9e75eED71c68B99dDEDf279e8;\n\n    address public constant CRV_TOKEN =\n        0xD533a949740bb3306d119CC777fa900bA034cd52;\n    address public constant CVXCRV_TOKEN =\n        0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7;\n    address public constant CVX_TOKEN =\n        0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;\n\n    uint256 public constant CRVETH_ETH_INDEX = 0;\n    uint256 public constant CRVETH_CRV_INDEX = 1;\n    int128 public constant CVXCRV_CRV_INDEX = 0;\n    int128 public constant CVXCRV_CVXCRV_INDEX = 1;\n    uint256 public constant CVXETH_ETH_INDEX = 0;\n    uint256 public constant CVXETH_CVX_INDEX = 1;\n\n    IBasicRewards cvxCrvStaking = IBasicRewards(CVXCRV_STAKING_CONTRACT);\n    ICurveV2Pool cvxEthSwap = ICurveV2Pool(CURVE_CVX_ETH_POOL);\n    ICurveV2Pool crvEthSwap = ICurveV2Pool(CURVE_CRV_ETH_POOL);\n    ICurveFactoryPool crvCvxCrvSwap = ICurveFactoryPool(CURVE_CVXCRV_CRV_POOL);\n\n    /// @notice Swap CRV for cvxCRV on Curve\n    /// @param amount - amount to swap\n    /// @param recipient - where swapped tokens will be sent to\n    /// @return amount of CRV obtained after the swap\n    function _swapCrvToCvxCrv(uint256 amount, address recipient)\n        internal\n        returns (uint256)\n    {\n        return _crvToCvxCrv(amount, recipient, 0);\n    }\n\n    /// @notice Swap CRV for cvxCRV on Curve\n    /// @param amount - amount to swap\n    /// @param recipient - where swapped tokens will be sent to\n    /// @param minAmountOut - minimum expected amount of output tokens\n    /// @return amount of CRV obtained after the swap\n    function _swapCrvToCvxCrv(\n        uint256 amount,\n        address recipient,\n        uint256 minAmountOut\n    ) internal returns (uint256) {\n        return _crvToCvxCrv(amount, recipient, minAmountOut);\n    }\n\n    /// @notice Swap CRV for cvxCRV on Curve\n    /// @param amount - amount to swap\n    /// @param recipient - where swapped tokens will be sent to\n    /// @param minAmountOut - minimum expected amount of output tokens\n    /// @return amount of CRV obtained after the swap\n    function _crvToCvxCrv(\n        uint256 amount,\n        address recipient,\n        uint256 minAmountOut\n    ) internal returns (uint256) {\n        return\n            crvCvxCrvSwap.exchange(\n                CVXCRV_CRV_INDEX,\n                CVXCRV_CVXCRV_INDEX,\n                amount,\n                minAmountOut,\n                recipient\n            );\n    }\n\n    /// @notice Swap cvxCRV for CRV on Curve\n    /// @param amount - amount to swap\n    /// @param recipient - where swapped tokens will be sent to\n    /// @return amount of CRV obtained after the swap\n    function _swapCvxCrvToCrv(uint256 amount, address recipient)\n        internal\n        returns (uint256)\n    {\n        return _cvxCrvToCrv(amount, recipient, 0);\n    }\n\n    /// @notice Swap cvxCRV for CRV on Curve\n    /// @param amount - amount to swap\n    /// @param recipient - where swapped tokens will be sent to\n    /// @param minAmountOut - minimum expected amount of output tokens\n    /// @return amount of CRV obtained after the swap\n    function _swapCvxCrvToCrv(\n        uint256 amount,\n        address recipient,\n        uint256 minAmountOut\n    ) internal returns (uint256) {\n        return _cvxCrvToCrv(amount, recipient, minAmountOut);\n    }\n\n    /// @notice Swap cvxCRV for CRV on Curve\n    /// @param amount - amount to swap\n    /// @param recipient - where swapped tokens will be sent to\n    /// @param minAmountOut - minimum expected amount of output tokens\n    /// @return amount of CRV obtained after the swap\n    function _cvxCrvToCrv(\n        uint256 amount,\n        address recipient,\n        uint256 minAmountOut\n    ) internal returns (uint256) {\n        return\n            crvCvxCrvSwap.exchange(\n                CVXCRV_CVXCRV_INDEX,\n                CVXCRV_CRV_INDEX,\n                amount,\n                minAmountOut,\n                recipient\n            );\n    }\n\n    /// @notice Swap CRV for native ETH on Curve\n    /// @param amount - amount to swap\n    /// @return amount of ETH obtained after the swap\n    function _swapCrvToEth(uint256 amount) internal returns (uint256) {\n        return _crvToEth(amount, 0);\n    }\n\n    /// @notice Swap CRV for native ETH on Curve\n    /// @param amount - amount to swap\n    /// @param minAmountOut - minimum expected amount of output tokens\n    /// @return amount of ETH obtained after the swap\n    function _swapCrvToEth(uint256 amount, uint256 minAmountOut)\n        internal\n        returns (uint256)\n    {\n        return _crvToEth(amount, minAmountOut);\n    }\n\n    /// @notice Swap CRV for native ETH on Curve\n    /// @param amount - amount to swap\n    /// @param minAmountOut - minimum expected amount of output tokens\n    /// @return amount of ETH obtained after the swap\n    function _crvToEth(uint256 amount, uint256 minAmountOut)\n        internal\n        returns (uint256)\n    {\n        return\n            crvEthSwap.exchange_underlying{value: 0}(\n                CRVETH_CRV_INDEX,\n                CRVETH_ETH_INDEX,\n                amount,\n                minAmountOut\n            );\n    }\n\n    /// @notice Swap native ETH for CRV on Curve\n    /// @param amount - amount to swap\n    /// @return amount of CRV obtained after the swap\n    function _swapEthToCrv(uint256 amount) internal returns (uint256) {\n        return _ethToCrv(amount, 0);\n    }\n\n    /// @notice Swap native ETH for CRV on Curve\n    /// @param amount - amount to swap\n    /// @param minAmountOut - minimum expected amount of output tokens\n    /// @return amount of CRV obtained after the swap\n    function _swapEthToCrv(uint256 amount, uint256 minAmountOut)\n        internal\n        returns (uint256)\n    {\n        return _ethToCrv(amount, minAmountOut);\n    }\n\n    /// @notice Swap native ETH for CRV on Curve\n    /// @param amount - amount to swap\n    /// @param minAmountOut - minimum expected amount of output tokens\n    /// @return amount of CRV obtained after the swap\n    function _ethToCrv(uint256 amount, uint256 minAmountOut)\n        internal\n        returns (uint256)\n    {\n        return\n            crvEthSwap.exchange_underlying{value: amount}(\n                CRVETH_ETH_INDEX,\n                CRVETH_CRV_INDEX,\n                amount,\n                minAmountOut\n            );\n    }\n\n    /// @notice Swap native ETH for CVX on Curve\n    /// @param amount - amount to swap\n    /// @return amount of CRV obtained after the swap\n    function _swapEthToCvx(uint256 amount) internal returns (uint256) {\n        return _ethToCvx(amount, 0);\n    }\n\n    /// @notice Swap native ETH for CVX on Curve\n    /// @param amount - amount to swap\n    /// @param minAmountOut - minimum expected amount of output tokens\n    /// @return amount of CRV obtained after the swap\n    function _swapEthToCvx(uint256 amount, uint256 minAmountOut)\n        internal\n        returns (uint256)\n    {\n        return _ethToCvx(amount, minAmountOut);\n    }\n\n    /// @notice Swap native ETH for CVX on Curve\n    /// @param amount - amount to swap\n    /// @param minAmountOut - minimum expected amount of output tokens\n    /// @return amount of CRV obtained after the swap\n    function _ethToCvx(uint256 amount, uint256 minAmountOut)\n        internal\n        returns (uint256)\n    {\n        return\n            cvxEthSwap.exchange_underlying{value: amount}(\n                CVXETH_ETH_INDEX,\n                CVXETH_CVX_INDEX,\n                amount,\n                minAmountOut\n            );\n    }\n\n    modifier notToZeroAddress(address _to) {\n        require(_to != address(0), \"Invalid address!\");\n        _;\n    }\n}\n"
    },
    "ICurveV2Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface ICurveV2Pool {\n    function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function calc_token_amount(uint256[2] calldata amounts)\n        external\n        view\n        returns (uint256);\n\n    function exchange_underlying(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external payable returns (uint256);\n\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount)\n        external\n        returns (uint256);\n\n    function lp_price() external view returns (uint256);\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external payable returns (uint256);\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy,\n        bool use_eth\n    ) external payable returns (uint256);\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy,\n        bool use_eth,\n        address receiver\n    ) external payable returns (uint256);\n\n    function price_oracle() external view returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 token_amount,\n        uint256 i,\n        uint256 min_amount,\n        bool use_eth,\n        address receiver\n    ) external returns (uint256);\n}\n"
    },
    "ICurveFactoryPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface ICurveFactoryPool {\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function get_balances() external view returns (uint256[2] memory);\n\n    function add_liquidity(\n        uint256[2] memory _amounts,\n        uint256 _min_mint_amount,\n        address _receiver\n    ) external returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy,\n        address _receiver\n    ) external returns (uint256);\n}\n"
    },
    "IBasicRewards.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.9;\n\ninterface IBasicRewards {\n    function stakeFor(address, uint256) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function earned(address) external view returns (uint256);\n\n    function withdrawAll(bool) external returns (bool);\n\n    function withdraw(uint256, bool) external returns (bool);\n\n    function withdrawAndUnwrap(uint256 amount, bool claim)\n        external\n        returns (bool);\n\n    function getReward() external returns (bool);\n\n    function stake(uint256) external returns (bool);\n\n    function extraRewards(uint256) external view returns (address);\n\n    function exit() external returns (bool);\n}\n"
    },
    "IGenericVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IGenericVault {\n    function withdraw(address _to, uint256 _shares)\n        external\n        returns (uint256 withdrawn);\n\n    function withdrawAll(address _to) external returns (uint256 withdrawn);\n\n    function depositAll(address _to) external returns (uint256 _shares);\n\n    function deposit(address _to, uint256 _amount)\n        external\n        returns (uint256 _shares);\n\n    function harvest() external;\n\n    function balanceOfUnderlying(address user)\n        external\n        view\n        returns (uint256 amount);\n\n    function totalUnderlying() external view returns (uint256 total);\n\n    function totalSupply() external view returns (uint256 total);\n\n    function underlying() external view returns (address);\n\n    function strategy() external view returns (address);\n\n    function platform() external view returns (address);\n\n    function setPlatform(address _platform) external;\n\n    function setPlatformFee(uint256 _fee) external;\n\n    function setCallIncentive(uint256 _incentive) external;\n\n    function setWithdrawalPenalty(uint256 _penalty) external;\n\n    function setApprovals() external;\n\n    function callIncentive() external view returns (uint256);\n\n    function platformFee() external view returns (uint256);\n}\n"
    },
    "IUniV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IUniV2Router {\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function getAmountsOut(uint256 amountIn, address[] memory path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n"
    },
    "ICurveTriCrypto.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface ICurveTriCrypto {\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy,\n        bool use_eth\n    ) external payable;\n\n    function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256);\n}\n"
    },
    "IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\n/**\n * @title EIP 4626 specification\n * @notice Interface of EIP 4626 Interface\n * as defined in https://eips.ethereum.org/EIPS/eip-4626\n */\ninterface IERC4626 {\n    /**\n     * @notice Event indicating that `caller` exchanged `assets` for `shares`, and transferred those `shares` to `owner`\n     * @dev Emitted when tokens are deposited into the vault via {mint} and {deposit} methods\n     */\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @notice Event indicating that `caller` exchanged `shares`, owned by `owner`, for `assets`, and transferred those\n     * `assets` to `receiver`\n     * @dev Emitted when shares are withdrawn from the vault via {redeem} or {withdraw} methods\n     */\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @notice Returns the address of the underlying token used by the Vault\n     * @return assetTokenAddress The address of the underlying ERC20 Token\n     * @dev MUST be an ERC-20 token contract\n     *\n     * MUST not revert\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @notice Returns the total amount of the underlying asset managed by the Vault\n     * @return totalManagedAssets Amount of the underlying asset\n     * @dev Should include any compounding that occurs from yield.\n     *\n     * Should be inclusive of any fees that are charged against assets in the vault.\n     *\n     * Must not revert\n     *\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     *\n     * @notice Returns the amount of shares that, in an ideal scenario, the vault would exchange for the amount of assets\n     * provided\n     *\n     * @param assets Amount of assets to convert\n     * @return shares Amount of shares that would be exchanged for the provided amount of assets\n     *\n     * @dev MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     *\n     * MUST NOT show any variations depending on the caller.\n     *\n     * MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     *\n     * MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     *\n     * MUST round down towards 0.\n     *\n     * This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and from.\n     */\n    function convertToShares(uint256 assets)\n        external\n        view\n        returns (uint256 shares);\n\n    /**\n     *\n     * @notice Returns the amount of assets that the vault would exchange for the amount of shares provided\n     *\n     * @param shares Amount of vault shares to convert\n     * @return assets Amount of assets that would be exchanged for the provided amount of shares\n     *\n     * @dev MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     *\n     * MUST NOT show any variations depending on the caller.\n     *\n     * MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     *\n     * MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     *\n     * MUST round down towards 0.\n     *\n     * This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and from.\n     */\n    function convertToAssets(uint256 shares)\n        external\n        view\n        returns (uint256 assets);\n\n    /**\n     *\n     * @notice Returns the maximum amount of the underlying asset that can be deposited into the vault for the `receiver`\n     * through a {deposit} call\n     *\n     * @param receiver Address whose maximum deposit is being queries\n     * @return maxAssets\n     *\n     * @dev MUST return the maximum amount of assets {deposit} would allow to be deposited for receiver and not cause a\n     * revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if\n     *necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on {balanceOf} of asset.\n     *\n     * MUST factor in both global and user-specific limits, like if deposits are entirely disabled (even temporarily)\n     * it MUST return 0.\n     *\n     * MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     *\n     * MUST NOT revert.\n     */\n    function maxDeposit(address receiver)\n        external\n        view\n        returns (uint256 maxAssets);\n\n    /**\n     * @notice Simulate the effects of a user's deposit at the current block, given current on-chain conditions\n     * @param assets Amount of assets\n     * @return shares Amount of shares\n     * @dev MUST return as close to and no more than the exact amount of Vault shares that would be minted in a {deposit}\n     * call in the same transaction. I.e. deposit should return the same or more shares as {previewDeposit} if called in\n     * the same transaction. (I.e. {previewDeposit} should underestimate or round-down)\n     *\n     * MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     * deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     *\n     * MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     *\n     * MUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also\n     * cause deposit to revert.\n     *\n     * Note that any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage\n     * in share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets)\n        external\n        view\n        returns (uint256 shares);\n\n    /**\n     * @notice Mints `shares` Vault shares to `receiver` by depositing exactly `amount` of underlying tokens\n     * @param assets Amount of assets\n     * @param receiver Address to deposit underlying tokens into\n     * @dev Must emit the {Deposit} event\n     *\n     * MUST support ERC-20 {approve} / {transferFrom} on asset as a deposit flow. MAY support an additional flow in\n     * which the underlying tokens are owned by the Vault contract before the {deposit} execution, and are accounted for\n     * during {deposit}.\n     *\n     * MUST revert if all of `assets` cannot be deposited (due to deposit limit being reached, slippage, the user not\n     * approving enough underlying tokens to the Vault contract, etc).\n     *\n     * Note that most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver)\n        external\n        returns (uint256 shares);\n\n    /**\n     * @notice Returns the maximum amount of shares that can be minted from the vault for the `receiver``, via a `mint`\n     * call\n     * @param receiver Address to deposit minted shares into\n     * @return maxShares The maximum amount of shares\n     * @dev MUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert,\n     * which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).\n     * This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.\n     *\n     * MUST factor in both global and user-specific limits, like if mints are entirely disabled (even temporarily) it\n     *\n     * MUST return 0.\n     *\n     * MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     *\n     * MUST NOT revert.\n     */\n    function maxMint(address receiver)\n        external\n        view\n        returns (uint256 maxShares);\n\n    /**\n     * @notice Simulate the effects of a user's mint at the current block, given current on-chain conditions\n     * @param shares Amount of shares to mint\n     * @return assets Amount of assets required to mint `mint` amount of shares\n     * @dev MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     * in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the same\n     * transaction. (I.e. {previewMint} should overestimate or round-up)\n     *\n     * MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     * would be accepted, regardless if the user has enough tokens approved, etc.\n     *\n     * MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     *\n     * MUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also\n     * cause mint to revert.\n     *\n     * Note that any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @notice Mints exactly `shares` vault shares to `receiver` by depositing `amount` of underlying tokens\n     * @param shares Amount of shares to mint\n     * @param receiver Address to deposit minted shares into\n     * @return assets Amount of assets transferred to vault\n     * @dev Must emit the {Deposit} event\n     *\n     * MUST support ERC-20 {approve} / {transferFrom} on asset as a mint flow. MAY support an additional flow in\n     *  which the underlying tokens are owned by the Vault contract before the mint execution, and are accounted for\n     * during mint.\n     *\n     * MUST revert if all of `shares` cannot be minted (due to deposit limit being reached, slippage, the user not\n     * approving enough underlying tokens to the Vault contract, etc).\n     *\n     * Note that most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function mint(uint256 shares, address receiver)\n        external\n        returns (uint256 assets);\n\n    /**\n     * @notice Returns the maximum amount of the underlying asset that can be withdrawn from the `owner` balance in the\n     * vault, through a `withdraw` call.\n     * @param owner Address of the owner whose max withdrawal amount is being queries\n     * @return maxAssets Maximum amount of underlying asset that can be withdrawn\n     * @dev MUST return the maximum amount of assets that could be transferred from `owner` through {withdraw} and not\n     * cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if\n     * necessary).\n     *\n     * MUST factor in both global and user-specific limits, like if withdrawals are entirely disabled\n     * (even temporarily)  it MUST return 0.\n     *\n     * MUST NOT revert.\n     */\n    function maxWithdraw(address owner)\n        external\n        view\n        returns (uint256 maxAssets);\n\n    /**\n     * @notice Simulate the effects of a user's withdrawal at the current block, given current on-chain conditions.\n     * @param assets Amount of assets\n     * @return shares Amount of shares\n     * @dev MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a\n     * {withdraw} call in the same transaction. I.e. {withdraw} should return the same or fewer shares as\n     * {previewWithdraw} if called in the same transaction. (I.e. {previewWithdraw should overestimate or round-up})\n     *\n     * MUST NOT account for withdrawal limits like those returned from {maxWithdraw} and should always act as though\n     * the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     *\n     * MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     *\n     * MUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also\n     * cause {withdraw} to revert.\n     *\n     * Note that any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets)\n        external\n        view\n        returns (uint256 shares);\n\n    /**\n     * @notice Burns `shares` from `owner` and sends exactly `assets` of underlying tokens to `receiver`\n     * @param assets Amount of underling assets to withdraw\n     * @return shares Amount of shares that will be burned\n     * @dev Must emit the {Withdraw} event\n     *\n     * MUST support a withdraw flow where the shares are burned from `owner` directly where `owner` is `msg.sender`\n     * or `msg.sender` has ERC-20 approval over the shares of `owner`. MAY support an additional flow in which the shares\n     * are transferred to the Vault contract before the withdraw execution, and are accounted for during withdraw.\n     *\n     * MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     * not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     *  Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Returns the maximum amount of vault shares that can be redeemed from the `owner` balance in the vault, via\n     * a `redeem` call.\n     * @param owner Address of the owner whose shares are being queries\n     * @return maxShares Maximum amount of shares that can be redeemed\n     * @dev MUST return the maximum amount of shares that could be transferred from `owner` through `redeem` and not cause\n     * a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if\n     * necessary).\n     *\n     * MUST factor in both global and user-specific limits, like if redemption is entirely disabled\n     * (even temporarily) it MUST return 0.\n     *\n     * MUST NOT revert\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @notice Simulate the effects of a user's redemption at the current block, given current on-chain conditions\n     * @param shares Amount of shares that are being simulated to be redeemed\n     * @return assets Amount of underlying assets that can be redeemed\n     * @dev MUST return as close to and no more than the exact amount of `assets `that would be withdrawn in a {redeem}\n     * call in the same transaction. I.e. {redeem} should return the same or more assets as {previewRedeem} if called in\n     * the same transaction. I.e. {previewRedeem} should underestimate/round-down\n     *\n     * MUST NOT account for redemption limits like those returned from {maxRedeem} and should always act as though\n     * the redemption would be accepted, regardless if the user has enough shares, etc.\n     *\n     * MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     *\n     * MUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also\n     * cause {redeem} to revert.\n     *\n     * Note that any unfavorable discrepancy between {convertToAssets} and {previewRedeem} SHOULD be considered\n     * slippage in share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares)\n        external\n        view\n        returns (uint256 assets);\n\n    /**\n     * @notice Burns exactly `shares` from `owner` and sends `assets` of underlying tokens to `receiver`\n     * @param shares Amount of shares to burn\n     * @param receiver Address to deposit redeemed underlying tokens to\n     * @return assets Amount of underlying tokens redeemed\n     * @dev Must emit the {Withdraw} event\n     * MUST support a {redeem} flow where the shares are burned from owner directly where `owner` is `msg.sender` or\n     *\n     * `msg.sender` has ERC-20 approval over the shares of `owner`. MAY support an additional flow in which the shares\n     * are transferred to the Vault contract before the {redeem} execution, and are accounted for during {redeem}.\n     *\n     * MUST revert if all of {shares} cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     * not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n"
    },
    "IPirexCVX.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPirexCVX {\n    function deposit(\n        uint256 assets,\n        address receiver,\n        bool shouldCompound,\n        address developer\n    ) external;\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "libraries": {
      "StrategyZaps.sol": {}
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}