{{
  "language": "Solidity",
  "sources": {
    "/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/LPStaking.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.0;\n\n// OpenZeppelin contracts\nimport \"./libs/token/ERC20/IERC20.sol\";\nimport \"./libs/token/ERC20/SafeERC20.sol\";\nimport \"./libs/utils/EnumerableSet.sol\";\nimport \"./libs/math/LowGasSafeMath.sol\";\nimport \"./libs/math/FullMath.sol\";\nimport \"./libs/math/UnsafeMath.sol\";\nimport \"./libs/math/Math.sol\";\nimport \"./libs/access/Ownable.sol\";\nimport \"./libs/access/ReentrancyGuard.sol\";\n\nimport \"./staking/ILPStaking.sol\";\nimport \"./staking/AbstractLPStaking.sol\";\n\ncontract LPStaking is AbstractLPStaking, ILPStaking {\n    using LowGasSafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    function deposit(uint amount, uint8 term)\n    external\n    nonReentrant\n    stakingAllowed\n    correctTerm(term)\n    {\n        require(amount > 0, \"Cannot stake 0\");\n        address stakeholder = _msgSender();\n\n        updateRewards(stakeholder);\n\n        stakingToken.safeTransferFrom(stakeholder, address(this), amount);\n\n        totalStaked = totalStaked.add(amount);\n        uint _terms = terms(term);\n        stakedPerTerm[_terms] = stakedPerTerm[_terms].add(amount);\n\n        if (staking_amount[stakeholder] == 0) {\n            staking_length[stakeholder] = _terms;\n            staking_stakedAt[stakeholder] = block.timestamp;\n        }\n        staking_amount[stakeholder] = staking_amount[stakeholder].add(amount);\n\n        stake_holders.push(stakeholder);\n\n        emit Deposited(stakeholder, amount);\n\n    }\n\n    function withdraw(uint amount) external nonReentrant isNotLocked {\n        require(amount > 0, \"Cannot withdraw 0\");\n        require(amount >= staking_amount[msg.sender], \"Cannot withdraw more than staked\");\n        address stakeholder = _msgSender();\n\n        updateRewards(stakeholder);\n\n        totalStaked = totalStaked.sub(amount);\n\n        uint _terms = staking_length[stakeholder];\n        stakedPerTerm[_terms] = stakedPerTerm[_terms].sub(amount);\n        staking_amount[stakeholder] = staking_amount[stakeholder].sub(amount);\n\n        stakingToken.safeTransfer(stakeholder, amount);\n\n        emit Withdrawn(stakeholder, amount);\n    }\n\n    function streamRewards() external nonReentrant streaming(false) {\n        address stakeholder = _msgSender();\n        updateRewards(stakeholder);\n\n        uint reward = staking_rewards[stakeholder];\n        staking_rewards[stakeholder] = 0;\n\n        streaming_rewards[stakeholder] = reward;\n        streaming_rewards_calculated[stakeholder] = block.number;\n        streaming_rewards_per_block[stakeholder] = UnsafeMath.divRoundingUp(reward, estBlocksPerStreamingPeriod);\n\n        emit RewardStreamStarted(stakeholder, reward);\n    }\n\n    function stopStreamingRewards() external nonReentrant streaming(true) {\n        address stakeholder = _msgSender();\n\n        updateRewards(stakeholder);\n\n        uint untakenReward = streaming_rewards[stakeholder];\n        staking_rewards[stakeholder] = staking_rewards[stakeholder].add(untakenReward);\n        streaming_rewards[stakeholder] = 0;\n\n        emit RewardStreamStopped(stakeholder);\n    }\n\n    function claimRewards() external nonReentrant {\n        address stakeholder = _msgSender();\n        updateRewards(stakeholder);\n\n        uint256 reward = unlocked_rewards[stakeholder];\n        if (reward > 0) {\n            unlocked_rewards[stakeholder] = 0;\n            rewardsToken.safeTransfer(stakeholder, reward);\n\n            emit RewardPaid(stakeholder, reward);\n        }\n    }\n\n    function unlockedRewards(address stakeholder) external view returns (uint) {\n        return unlocked_rewards[stakeholder].add(_unlockedRewards(stakeholder));\n    }\n\n    function streamingRewards(address stakeholder) public view returns (uint) {\n        return streaming_rewards[stakeholder].sub(_unlockedRewards(stakeholder));\n    }\n\n    function earned(address account) public view returns (uint) {\n        uint _earned = _newEarned(account);\n\n        return UnsafeMath.divRoundingUp(_earned, 1e24).add(staking_rewards[account]);\n    }\n\n    function stakingAmount(address stakeholder) public view returns (uint) {\n        return staking_amount[stakeholder];\n    }\n\n    function __s(address stakeholder, uint blocks) external {\n        streaming_rewards_calculated[stakeholder] = block.number - blocks;\n    }\n}\n"
    },
    "/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"
    },
    "/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/access/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Helps contracts guard agains rentrancy attacks.\n * @author Remco Bloemen <remco@2π.com>\n * @notice If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n\n    /**\n     * @dev We use a single lock for the whole contract.\n     */\n    bool private rentrancy_lock = false;\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * @notice If you mark a function `nonReentrant`, you should also\n     * mark it `external`. Calling one nonReentrant function from\n     * another is not supported. Instead, you can implement a\n     * `private` function doing the actual work, and a `external`\n     * wrapper marked as `nonReentrant`.\n     */\n    modifier nonReentrant() {\n        require(!rentrancy_lock, \"Reentrancy!\");\n        rentrancy_lock = true;\n        _;\n        rentrancy_lock = false;\n    }\n\n}"
    },
    "/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/math/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0, \"FullMath: denomenator should be > 0\");\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1, \"FullMath: denomenator should be > prod1\");\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = (0-denominator) & denominator;\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max, \"FullMath: mulDivRoundingUp error\");\n            result++;\n        }\n    }\n}\n"
    },
    "/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/math/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"LowGasSafeMath: add overflow\");\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"LowGasSafeMath: sub overflow\");\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y, \"LowGasSafeMath: mul overflow\");\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0), \"LowGasSafeMath: add overflow\");\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0), \"LowGasSafeMath: sub overflow\");\n    }\n}\n"
    },
    "/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/math/UnsafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev panics if y == 0\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        // addition is safe because (type(uint256).max / 1) + (type(uint256).max % 1 > 0 ? 1 : 0) == type(uint256).max\n        z = (x / y) + (x % y > 0 ? 1 : 0);\n    }\n}\n"
    },
    "/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/LowGasSafeMath.sol\";\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract ERC20 is IERC20 {\n    using LowGasSafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() override public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address owner) override public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(\n        address owner,\n        address spender\n    )\n    override public\n    view\n    returns (uint256)\n    {\n        return _allowed[owner][spender];\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function transfer(address to, uint256 value) override public returns (bool) {\n        require(value <= _balances[msg.sender], \"ERC20: no balance\");\n        require(to != address(0), \"ERC20: to is zero\");\n\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) override public returns (bool) {\n        require(spender != address(0), \"ERC20: spender is zero\");\n\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    )\n    override public\n    returns (bool)\n    {\n        require(value <= _balances[from], \"ERC20: no balance\");\n        require(value <= _allowed[from][msg.sender], \"ERC20: not allowed\");\n        require(to != address(0), \"ERC20: to is zero\");\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    )\n    public\n    returns (bool)\n    {\n        require(spender != address(0), \"ERC20: account is zero\");\n\n        _allowed[msg.sender][spender] = (\n        _allowed[msg.sender][spender].add(addedValue));\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    )\n    public\n    returns (bool)\n    {\n        require(spender != address(0), \"ERC20: account is zero\");\n\n        _allowed[msg.sender][spender] = (\n        _allowed[msg.sender][spender].sub(subtractedValue));\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param amount The amount that will be created.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: account is zero\");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param amount The amount that will be burnt.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: account is zero\");\n        require(amount <= _balances[account], \"ERC20: no balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[account] = _balances[account].sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal burn function.\n     * @param account The account whose tokens will be burnt.\n     * @param amount The amount that will be burnt.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        require(amount <= _allowed[account][msg.sender], \"ERC20: not allowed\");\n\n        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\n        // this function needs to emit an event with the updated approval.\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n            amount);\n        _burn(account, amount);\n    }\n}"
    },
    "/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC20.sol\";\nimport \"./IERC20.sol\";\n\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    )\n    internal\n    {\n        require(token.transfer(to, value), \"SafeERC20: Cannot transfer\");\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    )\n    internal\n    {\n        require(token.transferFrom(from, to, value), \"SafeERC20: Cannot transferFrom\");\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    )\n    internal\n    {\n        require(token.approve(spender, value), \"SafeERC20: cannot approve\");\n    }\n}"
    },
    "/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}"
    },
    "/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}"
    },
    "/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/staking/AbstractLPStaking.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.0;\n\nimport \"../libs/access/Ownable.sol\";\nimport \"../libs/access/ReentrancyGuard.sol\";\nimport \"../libs/math/LowGasSafeMath.sol\";\nimport \"../libs/math/FullMath.sol\";\nimport \"../libs/math/UnsafeMath.sol\";\nimport \"../libs/math/Math.sol\";\nimport \"../libs/token/ERC20/IERC20.sol\";\n\nabstract contract AbstractLPStaking is Ownable, ReentrancyGuard {\n    using LowGasSafeMath for uint;\n\n    mapping(uint => uint) public stakedPerTerm; // how much staked per term\n    uint public totalStaked = 0; // total staked\n\n    // Stakeholders info\n    mapping(address => uint) internal staking_amount; // staking amounts\n    mapping(address => uint) internal staking_rewards; // rewards\n    mapping(address => uint) internal staking_stakedAt; // timestamp of staking\n    mapping(address => uint) internal staking_length; // staking term\n\n    mapping(address => uint) internal rewards_paid; // paid rewards\n    mapping(address => uint) internal streaming_rewards; // streaming rewards\n    mapping(address => uint) internal streaming_rewards_calculated; // when streaming calculated last time\n    mapping(address => uint) internal streaming_rewards_per_block; // how much to stream per block\n    mapping(address => uint) internal unlocked_rewards; // rewards ready to be claimed\n\n    mapping(address => uint) internal paid_rewardPerToken; // previous rewards per stake\n    mapping(address => uint) internal paid_term2AdditionalRewardPerToken; // previous rewards per stake for additional term2\n\n    address[] stake_holders; // array of stakeholders\n\n    uint constant totalRewardPool = 410400 ether; // total rewards\n    uint constant dailyRewardPool = 9120 ether; // total daily rewards\n    uint constant hourlyRewardPool = 380 ether; // hourly rewards\n    uint internal limitDays = 45 days; // how much days to pay rewards\n\n    uint internal rewardsPerStakeCalculated; // last timestamp rewards per stake calculated\n    uint internal term2AdditionalRewardsPerStakeStored; // rewards per stake for additional term2\n    uint internal rewardsPerStakeStored; // rewards per stake\n    uint internal createdAtSeconds; // when staking was created/initialized\n\n    uint internal toStopAtSeconds = 0; // when will be stopped\n\n    uint internal stoppedAtSeconds; // when staking was stopped\n    bool internal isEnded = false; // was staking ended\n\n    bool internal unlocked = false; // are all stakes are unlocked now\n\n    uint constant estBlocksPerDay = 5_760; // estimated number of blocks per day\n    uint constant estBlocksPerStreamingPeriod = 7 * estBlocksPerDay; // estimated number of blocks per streaming period\n\n    IERC20 stakingToken; // staking ERC20 token\n    IERC20 rewardsToken; // rewards ERC20 token\n\n    modifier isNotLocked() {\n        require(unlocked || staking_stakedAt[msg.sender] + staking_length[msg.sender] <= block.timestamp, \"Stake is Locked\");\n\n        _;\n    }\n\n    modifier streaming(bool active) {\n        if (active) {\n            require(streaming_rewards[msg.sender] > 0, \"Not streaming yet\");\n        } else {\n            require(streaming_rewards[msg.sender] == 0, \"Already streaming\");\n        }\n\n        _;\n    }\n\n    modifier correctTerm(uint8 term) {\n        require(term >= 0 && term <= 2, \"Incorrect term specified\");\n        require(staking_length[msg.sender] == 0 || terms(term) == staking_length[msg.sender], \"Cannot change term while stake is locked\");\n\n        _;\n    }\n\n    modifier stakingAllowed() {\n        require(createdAtSeconds > 0, \"Staking not started yet\");\n        require(block.timestamp > createdAtSeconds, \"Staking not started yet\");\n        require(block.timestamp < toStopAtSeconds, \"Staking is over\");\n\n        _;\n    }\n\n    uint constant term_0 = 15 days; // term 0 with 70% rewards\n    uint constant term_1 = 30 days; // term 1 with 100% rewards\n    uint constant term_2 = 45 days; // term 2 with additional rewards\n\n    // term idx to time\n    function terms(uint8 term) internal pure returns (uint) {\n        if (term == 0) {\n            return term_0;\n        }\n        if (term == 1) {\n            return term_1;\n        }\n        if (term == 2) {\n            return term_2;\n        }\n\n        return 0;\n    }\n\n    bool initialized = false;\n\n    // initial contract initialization\n    function initialize(\n        address _stakingToken,\n        address _rewardsToken\n    ) external onlyOwner {\n        require(!initialized, \"Already initialized!\");\n        initialized = true;\n\n        stakingToken = IERC20(_stakingToken);\n        rewardsToken = IERC20(_rewardsToken);\n\n        createdAtSeconds = block.timestamp;\n        toStopAtSeconds = createdAtSeconds + limitDays * (1 days);\n    }\n\n    // --=[ calculation methods ]=--\n    function _calcRewardsPerStake(uint staked, uint rewardsPool, uint __default) private view returns (uint) {\n        if (staked == 0 || rewardsPerStakeCalculated >= block.timestamp) {\n            return __default;\n        }\n\n        uint _hoursPassed = _calcHoursPassed(rewardsPerStakeCalculated);\n        uint _totalRewards = _hoursPassed.mul(rewardsPool);\n\n        return __default.add(\n            FullMath.mulDiv(_totalRewards, 1e24, staked)\n        );\n    }\n\n    function _calcRewardsPerStake() internal view returns (uint) {\n        return _calcRewardsPerStake(totalStaked, hourlyRewardPool, rewardsPerStakeStored);\n    }\n\n    function _calcTerm2AdditionalRewardsPerStake() internal view returns (uint) {\n        uint totalStaked_0 = stakedPerTerm[term_0];\n        (,uint nonTakenRewards) = _calcTerm0Rewards(totalStaked_0.mul(_calcRewardsPerStake().sub(paid_rewardPerToken[address(0)])));\n\n        return _calcRewardsPerStake(totalStaked_0, nonTakenRewards, term2AdditionalRewardsPerStakeStored);\n    }\n\n    function _calcTerm0Rewards(uint reward) internal pure returns (uint _earned, uint _non_taken) {\n        uint a = FullMath.mulDiv(reward, 70, 100);\n        // Staking term_0 earns 70% of the rewards\n        _non_taken = reward.sub(a);\n        // Keep the rest to spare with term_2 stakeholders\n        _earned = a;\n    }\n\n    function _calcHoursPassed(uint _lastRewardsTime) internal view returns (uint hoursPassed) {\n        if (isEnded) {\n            hoursPassed = stoppedAtSeconds.sub(_lastRewardsTime) / (1 hours);\n        } else if (limitDaysGone()) {\n            hoursPassed = toStopAtSeconds.sub(_lastRewardsTime) / (1 hours);\n        } else if (limitRewardsGone()) {\n            hoursPassed = allowedRewardHrsFrom(_lastRewardsTime);\n        } else {\n            hoursPassed = block.timestamp.sub(_lastRewardsTime) / (1 hours);\n        }\n    }\n\n    function lastCallForRewards() internal view returns (uint) {\n        if (isEnded) {\n            return stoppedAtSeconds;\n        } else if (limitDaysGone()) {\n            return toStopAtSeconds;\n        } else if (limitRewardsGone()) {\n            return createdAtSeconds.add(allowedRewardHrsFrom(rewardsPerStakeCalculated));\n        } else {\n            return block.timestamp;\n        }\n    }\n\n    function limitDaysGone() internal view returns (bool) {\n        return limitDays > 0 && block.timestamp >= toStopAtSeconds;\n    }\n\n    function limitRewardsGone() internal view returns (bool) {\n        return totalRewardPool > 0 && totalRewards() >= totalRewardPool;\n    }\n\n    function allowedRewardHrsFrom(uint _from) internal view returns (uint) {\n        uint timePassed = _from.sub(createdAtSeconds) / 1 hours;\n        uint paidRewards = FullMath.mulDiv(FullMath.mulDiv(dailyRewardPool, 1e24, 1 hours), timePassed, 1e24);\n\n        return UnsafeMath.divRoundingUp(totalRewardPool.sub(paidRewards), hourlyRewardPool);\n    }\n\n    function _newEarned(address account) internal view returns (uint _earned) {\n        uint _staked = staking_amount[account];\n        _earned = _staked.mul(_calcRewardsPerStake().sub(paid_rewardPerToken[account]));\n\n        if (staking_length[account] == term_0) {\n            (_earned,) = _calcTerm0Rewards(_earned);\n        } else if (staking_length[account] == term_2) {\n            uint term2AdditionalRewardsPerStake = UnsafeMath.divRoundingUp(_calcTerm2AdditionalRewardsPerStake(), 1e24);\n\n            _earned = _earned.add(_staked.mul(term2AdditionalRewardsPerStake.sub(paid_term2AdditionalRewardPerToken[account])));\n        }\n    }\n\n    function _unlockedRewards(address stakeholder) internal view returns (uint) {\n        uint _unlocked = 0;\n\n        if (streaming_rewards[stakeholder] > 0) {\n            uint blocksPassed = block.number.sub(streaming_rewards_calculated[stakeholder]);\n            _unlocked = Math.min(blocksPassed.mul(streaming_rewards_per_block[stakeholder]), streaming_rewards[stakeholder]);\n        }\n\n        return _unlocked;\n    }\n\n    function updateRewards(address stakeholder) internal {\n        rewardsPerStakeStored = _calcRewardsPerStake();\n        term2AdditionalRewardsPerStakeStored = _calcTerm2AdditionalRewardsPerStake();\n        rewardsPerStakeCalculated = lastCallForRewards();\n\n        staking_rewards[stakeholder] = UnsafeMath.divRoundingUp(_newEarned(stakeholder), 1e24).add(staking_rewards[stakeholder]);\n\n        paid_rewardPerToken[stakeholder] = rewardsPerStakeStored;\n        paid_rewardPerToken[address(0)] = rewardsPerStakeStored;\n        if (staking_length[stakeholder] == term_2) {\n            paid_term2AdditionalRewardPerToken[stakeholder] = term2AdditionalRewardsPerStakeStored;\n        }\n\n        if (streaming_rewards[stakeholder] > 0) {\n            uint blocksPassed = block.number.sub(streaming_rewards_calculated[stakeholder]);\n            uint _unlocked = Math.min(blocksPassed.mul(streaming_rewards_per_block[stakeholder]), streaming_rewards[stakeholder]);\n            unlocked_rewards[stakeholder] = unlocked_rewards[stakeholder].add(_unlocked);\n            streaming_rewards[stakeholder] = streaming_rewards[stakeholder].sub(_unlocked);\n            streaming_rewards_calculated[stakeholder] = block.number;\n        }\n    }\n\n    // --=[ public methods ]=--\n    function totalRewards() public view returns (uint256 total) {\n        uint256 timeEnd = block.timestamp;\n        if (isEnded) {\n            timeEnd = stoppedAtSeconds;\n        } else if (limitDays > 0 && block.timestamp > toStopAtSeconds) {\n            timeEnd = toStopAtSeconds;\n        }\n\n        uint256 timePassed = timeEnd.sub(createdAtSeconds) / 1 hours;\n        total = FullMath.mulDiv(FullMath.mulDiv(dailyRewardPool, 1e24, 1 hours), timePassed, 1e24);\n\n        if (totalRewardPool > 0 && total > totalRewardPool) {\n            total = totalRewardPool;\n        }\n    }\n\n    function finalizeEmergency() external onlyOwner {\n        // give out all stakes\n        uint _stakeholders_length = stake_holders.length;\n        for (uint s = 0; s < _stakeholders_length; s += 1) {\n            address stakeholder = stake_holders[s];\n            stakingToken.transfer(stakeholder, staking_amount[stakeholder]);\n        }\n\n        uint256 stakingTokenBalance = stakingToken.balanceOf(address(this));\n        if (stakingTokenBalance > 0) {\n            stakingToken.transfer(owner(), stakingTokenBalance);\n        }\n\n        uint256 rewardsTokenBalance = rewardsToken.balanceOf(address(this));\n        if (rewardsTokenBalance > 0) {\n            rewardsToken.transfer(owner(), rewardsTokenBalance);\n        }\n\n        selfdestruct(payable(owner()));\n    }\n}\n"
    },
    "/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/staking/ILPStaking.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\n\npragma solidity ^0.8.0;\n\ninterface ILPStaking {\n    event Deposited(address indexed user, uint amount);\n    event Withdrawn(address indexed user, uint amount);\n    event RewardStreamStarted(address indexed user, uint amount);\n    event RewardStreamStopped(address indexed user);\n    event RewardPaid(address indexed user, uint reward);\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "istanbul",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}