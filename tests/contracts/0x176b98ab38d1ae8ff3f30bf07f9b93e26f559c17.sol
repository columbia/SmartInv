{"ACOProxy.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\nimport \"./Address.sol\";\r\n\r\n/**\r\n * @title ACOProxy\r\n * @dev A proxy contract that implements delegation of calls to other contracts.\r\n */\r\ncontract ACOProxy {\r\n    \r\n    /**\r\n     * @dev Emitted when the admin address has been changed.\r\n     * @param previousAdmin Address of the previous admin.\r\n     * @param newAdmin Address of the new admin.\r\n     */\r\n    event ProxyAdminUpdated(address previousAdmin, address newAdmin);\r\n    \r\n    /**\r\n     * @dev Emitted when the proxy implementation has been changed.\r\n     * @param previousImplementation Address of the previous proxy implementation.\r\n     * @param newImplementation Address of the new proxy implementation.\r\n     */\r\n    event SetImplementation(address previousImplementation, address newImplementation);\r\n    \r\n    /**\r\n     * @dev Storage position for the admin address.\r\n     */\r\n    bytes32 private constant adminPosition = keccak256(\"acoproxy.admin\");\r\n    \r\n    /**\r\n     * @dev Storage position for the proxy implementation address.\r\n     */\r\n    bytes32 private constant implementationPosition = keccak256(\"acoproxy.implementation\");\r\n\r\n    /**\r\n     * @dev Modifier to check if the `msg.sender` is the admin.\r\n     * Only admin address can execute.\r\n     */\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin(), \"ACOProxy::onlyAdmin\");\r\n        _;\r\n    }\r\n    \r\n    constructor(address _admin, address _implementation, bytes memory _initdata) public {\r\n        _setAdmin(_admin);\r\n        _setImplementation(_implementation, _initdata);\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates the execution to the proxy implementation contract.\r\n     */\r\n    fallback() external payable {\r\n        address addr = implementation();\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let result := delegatecall(gas(), addr, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch result\r\n            case 0 { revert(0, returndatasize()) }\r\n            default { return(0, returndatasize()) }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to be compliance with EIP 897.\r\n     * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md\r\n     * It is an \"upgradable proxy\".\r\n     */\r\n    function proxyType() public pure returns(uint256) {\r\n        return 2; \r\n    }\r\n    \r\n    /**\r\n     * @dev Function to get the proxy admin address.\r\n     * @return adm The proxy admin address.\r\n     */\r\n    function admin() public view returns (address adm) {\r\n        bytes32 position = adminPosition;\r\n        assembly {\r\n            adm := sload(position)\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to get the proxy implementation address.\r\n     * @return impl The proxy implementation address.\r\n     */\r\n    function implementation() public view returns (address impl) {\r\n        bytes32 position = implementationPosition;\r\n        assembly {\r\n            impl := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Function to set the proxy admin address.\r\n     * Only can be called by the proxy admin.\r\n     * @param newAdmin Address of the new proxy admin.\r\n     */\r\n    function transferProxyAdmin(address newAdmin) external onlyAdmin {\r\n        _setAdmin(newAdmin);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the proxy implementation address.\r\n     * Only can be called by the proxy admin.\r\n     * @param newImplementation Address of the new proxy implementation.\r\n     * @param initData ABI encoded with signature data that will be delegated over the new implementation.\r\n     */\r\n    function setImplementation(address newImplementation, bytes calldata initData) external onlyAdmin {\r\n        _setImplementation(newImplementation, initData);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set the proxy admin address.\r\n     * @param newAdmin Address of the new proxy admin.\r\n     */\r\n    function _setAdmin(address newAdmin) internal {\r\n        require(newAdmin != address(0), \"ACOProxy::_setAdmin: Invalid admin\");\r\n        \r\n        emit ProxyAdminUpdated(admin(), newAdmin);\r\n        \r\n        bytes32 position = adminPosition;\r\n        assembly {\r\n            sstore(position, newAdmin)\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the proxy implementation address.\r\n     * The implementation address must be a contract.\r\n     * @param newImplementation Address of the new proxy implementation.\r\n     * @param initData ABI encoded with signature data that will be delegated over the new implementation.\r\n     */\r\n    function _setImplementation(address newImplementation, bytes memory initData) internal {\r\n        require(Address.isContract(newImplementation), \"ACOProxy::_setImplementation: Invalid implementation\");\r\n        \r\n        emit SetImplementation(implementation(), newImplementation);\r\n        \r\n        bytes32 position = implementationPosition;\r\n        assembly {\r\n            sstore(position, newImplementation)\r\n        }\r\n        if (initData.length \u003e 0) {\r\n            (bool success,) = newImplementation.delegatecall(initData);\r\n            assert(success);\r\n        }\r\n    }\r\n}\r\n"},"Address.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n"}}