{"ERC20.sol":{"content":"pragma solidity ^0.5.8;\nimport \u0027./SafeMath.sol\u0027;\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n */\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  uint256 public currentSupply;\n  address public master;\n  function balanceOf(address who) external view returns (uint256);\n  function transfer(address to, uint256 value) external;\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n  mapping(address =\u003e uint256) balances;\n\n  /**\n   * @dev Fix for the ERC20 short address attack.\n   */\n  modifier onlyPayloadSize(uint256 size) {\n     if(msg.data.length \u003c size + 4) {\n       revert();\n     }\n     _;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) external view returns (uint256 balance) {\n    return balances[_owner];\n  }\n}\n\n/**\n * @title ERC20 interface\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) external view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) external;\n  function approve(address spender, uint256 value) external;\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implemantation of the basic standart token.\n */\ncontract StandardToken is BasicToken, ERC20 {\n\n  mapping (address =\u003e mapping (address =\u003e uint256)) allowed;\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amout of tokens to be transfered\n   */\n  function transferFrom(address _from, address _to, uint256 _value) external onlyPayloadSize(3 * 32) {\n    uint256 _allowance = allowed[_from][msg.sender];\n\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n    // if (_value \u003e _allowance) throw;\n\n    balances[_to] = balances[_to].add(_value);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    emit Transfer(_from, _to, _value);\n  }\n\n  /**\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) external {\n\n    // To change the approve amount you first have to reduce the addresses`\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    if ((_value != 0) \u0026\u0026 (allowed[msg.sender][_spender] != 0)) revert();\n\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n  }\n\n  /**\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\n   */\n  function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n"},"Invitation.sol":{"content":"pragma solidity ^0.5.8;\nimport \u0027./SafeMath.sol\u0027;\n\ncontract InvitationBasic {\n    function signUp(address referrer, address addr, uint256 phase, uint256 ePhase) external;\n    function getParent(address addr) external view returns(address);\n    function getAncestors(address addr) external view returns(address[] memory);\n    function isRoot(address addr) external view returns (bool);\n    function isSignedUp(address addr) public view returns (bool);\n    function newRoot(address addr, uint256 phase) external;\n    function newSignupCount(uint256 phase) external view returns (uint);\n    function getPoints(uint256 phase, address addr) external view returns (uint256);\n    function getTop(uint256 phase) external view returns(address[] memory);\n    function distributeBonus(uint256 len) external pure returns(uint256[] memory);\n}\n\ncontract Invitation is InvitationBasic {\n    using SafeMath for uint256;\n\n    /*\n     * STATES\n     */\n    address public master;\n    address public caller;\n\n    bool public paused;\n\n    mapping (address =\u003e bool) public rootList;\n    mapping (address =\u003e address) public referenceParentList;\n    mapping (address =\u003e address[]) public referenceChildList;\n    mapping (uint256 =\u003e mapping (address =\u003e uint256)) public addressPoints;\n    mapping (uint256 =\u003e address[]) public newSignupList;\n    mapping (uint256 =\u003e address[]) public inviterList;\n    mapping (uint256 =\u003e address[]) public top;\n\n    uint maxChildrenCount = 0;\n    uint256 basePoints = 100000;\n    uint256 pointRate = 0;\n    uint256 maxPointLevel = 10;\n    uint256 winnerCount = 10;\n\n    /*\n     * MODIFIERS\n     */\n    /// only master can call the function\n    modifier onlyOwner {\n        require(master == msg.sender, \"only owner can call\");\n        _;\n    }\n\n    /// only master can call the function\n    modifier onlyCaller {\n        require(caller == msg.sender, \"only caller can call\");\n        _;\n    }\n\n    /// function not paused\n    modifier notPaused {\n        require(paused == false, \"function is paused\");\n        _;\n    }\n\n    function setPause(bool value) external onlyOwner {\n        paused = value;\n    }\n\n    function setWinnerCount(uint256 _count) external onlyOwner {\n        winnerCount = _count;\n    }\n\n    function isSignedUp(address addr) public view returns (bool) {\n        return rootList[addr] == true || referenceParentList[addr] != address(0);\n    }\n\n    function signUp(address referrer, address addr, uint256 phase, uint256 ePhase) external onlyCaller notPaused {\n        require(isSignedUp(referrer), \"invalid referrer\");\n        require(!isSignedUp(addr), \"address has signed up\");\n\n        setUpParent(referrer, addr);\n        updatePoints(referrer, addr, ePhase);\n        newSignupList[phase].push(addr);\n    }\n\n    function isRoot(address addr) external view returns (bool) {\n        return rootList[addr] == true;\n    }\n\n    function newRoot(address addr, uint256 phase) external onlyCaller notPaused {\n        require(!isSignedUp(addr), \"address has signed up\");\n        rootList[addr] = true;\n        newSignupList[phase].push(addr);\n    }\n\n    function getTop(uint256 phase) external view returns(address[] memory) {\n      return top[phase];\n    }\n\n    /*\n    function getTopInviter(uint256 phase, uint256 topN) external onlyCaller returns(address[] memory) {\n        if (inviterList[phase].length == 0 || top[phase].length \u003e 0){\n            return top[phase];\n        }\n        uint256 k = topN;\n        randomizedSelect(inviterList[phase], 0, inviterList[phase].length - 1, k, phase);\n\n        for (uint256 i = 0; i\u003c k \u0026\u0026 i \u003c inviterList[phase].length; i++){\n            top[phase].push(inviterList[phase][i]);\n        }\n        return top[phase];\n    }\n    */\n\n    function getChild(address addr) external view returns(address[] memory) {\n        return referenceChildList[addr];\n    }\n\n    function getPoints(uint256 phase, address addr) external view returns (uint256) {\n        return addressPoints[phase][addr];\n    }\n\n    function getParent(address addr) external view returns(address) {\n        return referenceParentList[addr];\n    }\n\n    function getNewSignup(uint256 phase) external view returns(address[] memory) {\n        return newSignupList[phase];\n    }\n\n    function newSignupCount(uint256 phase) external view returns (uint) {\n        return newSignupList[phase].length;\n    }\n\n    function setCaller(address who) external onlyOwner {\n        caller = who;\n    }\n\n    function setOwner(address who) external onlyOwner {\n        master = who;\n    }\n\n    constructor(uint _maxChildrenCount, uint _pointRate, uint256 _winnerCount) public {\n        master = msg.sender; // master account\n        maxChildrenCount = _maxChildrenCount;  // child node max number\n        pointRate = _pointRate;  // e.g. 618\n        winnerCount = _winnerCount;\n    }\n\n    function setUpParent(address pAddress, address addr) internal {\n        pAddress = findParent(pAddress);\n        referenceParentList[addr] = pAddress;\n        referenceChildList[pAddress].push(addr);\n    }\n\n    function updateTop(address addr, uint256 phase) internal {\n        for (uint256 k = 0; k \u003c top[phase].length; k++){\n            if (top[phase][k] == addr) {\n                for (uint256 i = k; i \u003e 0; i--){\n                    if (addressPoints[phase][top[phase][i]] \u003e addressPoints[phase][top[phase][i-1]]) {\n                        (top[phase][i], top[phase][i-1]) = (top[phase][i-1], top[phase][i]);\n                    } else {\n                        break;\n                    }\n                }\n                return;\n            }\n        }\n\n        if (top[phase].length \u003c winnerCount){\n            top[phase].push(addr);\n        } else if (addressPoints[phase][addr] \u003e addressPoints[phase][top[phase][top[phase].length - 1]]){\n            top[phase][top[phase].length - 1] = addr;\n        }\n\n        for (uint256 i = top[phase].length - 1; i \u003e 0; i--){\n            if (addressPoints[phase][top[phase][i]] \u003e addressPoints[phase][top[phase][i-1]]) {\n                (top[phase][i], top[phase][i-1]) = (top[phase][i-1], top[phase][i]);\n            } else {\n              break;\n            }\n        }\n    }\n\n    function updatePoints(address referrer, address addr, uint256 phase) internal {\n        uint256 points = basePoints;\n        if (addressPoints[phase][referrer] == 0) {\n            inviterList[phase].push(referrer);\n        }\n        addressPoints[phase][referrer] = addressPoints[phase][referrer].add(points);\n        points = points.mul(pointRate).div(1000);\n        updateTop(referrer, phase);\n\n        address parent = referenceParentList[addr];\n        uint256 level = 0;\n        while (parent != address(0) \u0026\u0026 level \u003c maxPointLevel){\n            level = level.add(1);\n            if (parent == referrer) {\n                parent = referenceParentList[parent];\n                continue;\n            }\n            if (addressPoints[phase][parent] == 0) {\n                inviterList[phase].push(parent);\n            }\n            addressPoints[phase][parent] = addressPoints[phase][parent].add(points);\n            points = points.mul(pointRate).div(1000);\n            updateTop(parent, phase);\n            parent = referenceParentList[parent];\n        }\n    }\n\n    function findParent(address root) internal view returns (address) {\n        uint len = 10000;\n        address[] memory temp = new address[](len);\n        uint startIndex = 0;\n        uint currentIndex = 0;\n        temp[startIndex] = root;\n        while (true){\n            address currentAddress = temp[startIndex];\n            startIndex++;\n            if (startIndex == len){\n                startIndex = 0;\n            }\n            if (referenceChildList[currentAddress].length \u003c maxChildrenCount){\n                return currentAddress;\n            }else {\n                for(uint i = 0; i\u003c referenceChildList[currentAddress].length; i++){\n                    currentIndex++;\n                    if (currentIndex == len){\n                        currentIndex = 0;\n                    }\n                    temp[currentIndex] = referenceChildList[currentAddress][i];\n                }\n            }\n        }\n    }\n\n    /*\n    function randomizedSelect(address[] storage addressList, uint left, uint right, uint256 k, uint256 phase) internal{\n        if (left == right) {\n            return;\n        }\n\n        if (left \u003c right) {\n            uint mid = partition(addressList, left, right, phase);\n            uint i = mid - left + 1;\n            if (i == k){\n                return;\n            }\n\n            if (k \u003c i) {\n                return randomizedSelect(addressList, left, mid - 1, k, phase);\n            } else {\n                return randomizedSelect(addressList, mid + 1, right, k - i, phase);\n            }\n        }\n    }\n\n    function partition(address[] storage addressList, uint left, uint right, uint256 phase) internal returns(uint) {\n        address tmp = addressList[left];\n\n        while (left \u003c right) {\n            while (left \u003c right \u0026\u0026 addressPoints[phase][addressList[right]] \u003c addressPoints[phase][tmp]) {\n                right--;\n            }\n            addressList[left] = addressList[right];\n            while (left \u003c right \u0026\u0026 addressPoints[phase][addressList[left]] \u003e= addressPoints[phase][tmp]) {\n                left++;\n            }\n            addressList[right] = addressList[left];\n        }\n        addressList[left] = tmp;\n        return left;\n    }\n    */\n\n    function distributeBonus(uint256 len) external pure returns(uint256[] memory) {\n        uint256[] memory factors = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; i++) {\n            if (i \u003c len.div(2)) {\n              factors[i] = len.add(len.div(2).sub(i));\n            } else {\n              if (len % 2 == 0 ) {\n                factors[i] = len.add(len.div(2)).sub(1).sub(i);\n              } else {\n                factors[i] = len.add(len.div(2)).sub(i);\n              }\n            }\n        }\n        return factors;\n    }\n\n    function getAncestors(address addr) external view returns(address[] memory) {\n        address[] memory ancestors = new address[](maxPointLevel);\n        address parent = referenceParentList[addr];\n\n        for (uint256 i = 0; parent != address(0) \u0026\u0026 i \u003c maxPointLevel; i++) {\n            ancestors[i] = parent;\n            parent = referenceParentList[parent];\n        }\n        return ancestors;\n    }\n}\n"},"LuckyDraw.sol":{"content":"pragma solidity ^0.5.8;\n\ncontract LuckyDrawBasic {\n    function buyTicket(address addr, uint256 phase) external;\n    function aggregateIcexWinners(uint256 phase) external;\n    function getWinners(uint256 phase) external view returns(address[] memory);\n}\n\ncontract LuckyDraw is LuckyDrawBasic {\n    /*\n     * STATES\n     */\n    address public master;\n    address public caller;\n\n    bool public paused;\n\n    uint winnerCount = 10;\n    mapping (uint256 =\u003e address[]) winnerList;\n    mapping (uint256 =\u003e mapping(address =\u003e bool)) playerList;\n    mapping (uint256 =\u003e uint256) playerNumbers;\n    uint nonce = 0;\n\n    /*\n     * MODIFIERS\n     */\n    /// only master can call the function\n    modifier onlyOwner {\n        require(master == msg.sender, \"only owner can call\");\n        _;\n    }\n\n    /// only master can call the function\n    modifier onlyCaller {\n        require(caller == msg.sender, \"only caller can call\");\n        _;\n    }\n\n    /// function not paused\n    modifier notPaused {\n        require(paused == false, \"function is paused\");\n        _;\n    }\n\n    constructor() public {\n        master = msg.sender;\n    }\n\n    function setCaller(address who) external onlyOwner {\n        caller = who;\n    }\n\n    function setOwner(address who) external onlyOwner {\n        master = who;\n    }\n\n    function setPause(bool value) external onlyOwner {\n        paused = value;\n    }\n\n    function buyTicket(address addr, uint256 phase) external onlyCaller notPaused {\n        if (!playerList[phase][addr]){\n            playerNumbers[phase]++;\n            if (winnerList[phase].length \u003c winnerCount){\n                winnerList[phase].push(addr);\n            }else {\n                uint index = randomIndex(addr, playerNumbers[phase]);\n                if (index \u003c winnerCount){\n                    winnerList[phase][index] = addr;\n                }\n            }\n            playerList[phase][addr] = true;\n        }\n    }\n\n    // costs a bit, but will only invoke once, and paid by operator\n    function aggregateIcexWinners(uint256 phase) external onlyCaller notPaused {\n        for(uint i = 0 ; i \u003c phase; ++i) {\n            address[] memory candidates = winnerList[i];\n            for(uint j = 0; j \u003c candidates.length; ++j) {\n                if (!playerList[phase][candidates[j]]) {\n                    if (winnerList[phase].length \u003c winnerCount) {\n                        winnerList[phase].push(candidates[j]);\n                    } else {\n                        uint index = randomIndex(candidates[j], winnerCount * (phase + 1));\n                        if (index \u003c winnerCount){\n                            winnerList[phase][index] = candidates[j];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function getWinners(uint256 phase) external view returns(address[] memory) {\n        return winnerList[phase];\n    }\n\n    function randomIndex(address addr, uint number) internal returns (uint) {\n        uint randomnumber = uint(keccak256(abi.encodePacked(now, addr, nonce))) % number;\n        nonce++;\n        return randomnumber;\n    }\n}\n"},"Migrations.sol":{"content":"pragma solidity \u003e=0.4.25 \u003c0.6.0;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.8;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"},"VDPool.sol":{"content":"pragma solidity ^0.5.8;\nimport \u0027./SafeMath.sol\u0027;\n\ncontract VDPoolBasic {\n    function price() external view returns(uint256);\n    function currentLevel() external view returns(uint256);\n    function currentLevelRemaining() external view returns(uint256);\n}\n\ncontract VDPoolThrottler {\n    function getCooldownBlocks() external view returns(uint256);\n}\n\ncontract VDPool is VDPoolBasic {\n    using SafeMath for uint256;\n    /*\n     * STATES\n     */\n    address public master;\n    address public caller;\n\n    uint256 public ethCapacity = 0;\n    uint256 public basicExchangeRate = 0;\n    uint256 public currentLevel = 0;\n    uint256 public currentLevelStartBlock = 0;\n    uint256 public cooldownBlocks = 0; // by default wait 1 block before enterring next level\n    VDPoolThrottler throttlerContract;\n    uint256 public currentPrice = 0;\n    uint256 public currentLevelRemaining = 0;\n\n    bool public paused;\n\n    /*\n     * EVENTS\n     */\n    event LevelDescend(uint256 level, uint256 price, uint256 startBlock, uint256 cooldownBlocks, uint256 currentBlock);\n\n    /*\n     * MODIFIERS\n     */\n    /// only master can call the function\n    modifier onlyOwner {\n        require(master == msg.sender, \"only owner can call\");\n        _;\n    }\n\n    /// only master can call the function\n    modifier onlyCaller {\n        require(caller == msg.sender, \"only caller can call\");\n        _;\n    }\n\n    /// function not paused\n    modifier notPaused {\n        require(paused == false, \"function is paused\");\n        _;\n    }\n\n    constructor(uint256 _ethCapacity, uint256 _currentLevel, uint256 _basicExchangeRate) public {\n        master = msg.sender;\n        ethCapacity = _ethCapacity;\n        currentLevel = _currentLevel;\n        currentPrice = (currentLevel.sub(1)).mul(10).add(_basicExchangeRate);\n        currentLevelRemaining = _ethCapacity;\n        basicExchangeRate = _basicExchangeRate;\n    }\n\n    function setPause(bool value) external onlyOwner {\n        paused = value;\n    }\n\n    function setCaller(address who) external onlyOwner {\n        caller = who;\n    }\n\n    function setOwner(address who) external onlyOwner {\n        master = who;\n    }\n\n    function setCooldownBlocks(uint256 bn) external onlyOwner {\n        cooldownBlocks = bn;\n    }\n\n    function setThrottlerContract(address contractAddress) external onlyOwner {\n        throttlerContract = VDPoolThrottler(contractAddress);\n    }\n\n    function price() external view returns (uint256) {\n        uint256 tokens = computeTokenAmount(1 ether);\n        return tokens;\n    }\n\n    function computeTokenAmount(uint256 ethAmount) public view returns (uint256) {\n        uint256 tokens = ethAmount.mul(currentPrice);\n        return tokens;\n    }\n\n    function buyToken(uint256 ethAmount) external onlyCaller notPaused returns (uint256) {\n        require(currentLevelStartBlock \u003c= block.number, \"cooling down\");\n        uint256 eth = ethAmount;\n        uint256 tokens = 0;\n        while (eth \u003e 0) {\n            if (eth \u003c= currentLevelRemaining) {\n                tokens = tokens + computeTokenAmount(eth);\n                currentLevelRemaining = currentLevelRemaining.sub(eth);\n                eth = 0;\n            }else {\n                tokens = tokens + computeTokenAmount(currentLevelRemaining);\n                eth = eth.sub(currentLevelRemaining);\n                currentLevelRemaining = 0;\n            }\n\n            if (currentLevelRemaining == 0){\n                currentLevel = currentLevel.sub(1);\n                require (currentLevel \u003e 0, \"end of levels\");\n                currentPrice = (currentLevel.sub(1)).mul(10).add(basicExchangeRate);\n                currentLevelRemaining = ethCapacity;\n                if (address(throttlerContract) != address(0)) {\n                    cooldownBlocks = throttlerContract.getCooldownBlocks();\n                }\n                if (currentLevelStartBlock \u003e block.number ) {\n                    // handling the case of desending multiple level in one tx\n                    currentLevelStartBlock = currentLevelStartBlock + cooldownBlocks;\n                } else {\n                    currentLevelStartBlock = block.number + cooldownBlocks;\n                }\n                emit LevelDescend(currentLevel, currentPrice, currentLevelStartBlock, cooldownBlocks, block.number);\n            }\n        }\n\n        return tokens;\n    }\n}\n"},"VDPoolThrottler.sol":{"content":"pragma solidity ^0.5.8;\n\n\ncontract VDPoolThrottler {\n    function getCooldownBlocks() external view returns(uint256);\n}\n\ncontract DummyThrottler is VDPoolThrottler {\n    function getCooldownBlocks() external view returns(uint256) {\n      return 1;\n  }\n}\n"},"XDS.sol":{"content":"pragma solidity ^0.5.8;\nimport \u0027./ERC20.sol\u0027;\n\nlibrary address_make_payable {\n   function make_payable(address x) internal pure returns (address payable) {\n      return address(uint160(x));\n   }\n}\n\ncontract VDPoolBasic {\n    function price() external view returns (uint256);\n    function buyToken(uint256 ethAmount) external returns (uint256);\n    function currentLevel() external view returns(uint256);\n    function currentLevelRemaining() external view returns(uint256);\n}\n\ncontract InvitationBasic {\n    function signUp(address referrer, address addr, uint256 phase, uint256 ePhase) external;\n    function isRoot(address addr) external view returns (bool);\n    function newRoot(address addr, uint256 phase) external;\n    function getParent(address addr) external view returns(address);\n    function getAncestors(address addr) external view returns(address[] memory);\n    function isSignedUp(address addr) public view returns (bool);\n    function getPoints(uint256 phase, address addr) external view returns (uint256);\n    function newSignupCount(uint256 phase) external view returns (uint256);\n    function getTop(uint256 phase) external view returns(address[] memory);\n    function distributeBonus(uint256 len) external pure returns(uint256[] memory);\n}\n\ncontract LuckyDrawBasic {\n    function buyTicket(address addr, uint256 phase) external;\n    function aggregateIcexWinners(uint256 phase) external;\n    function getWinners(uint256 phase) external view returns(address[] memory);\n}\n\ncontract XDS is StandardToken {\n    using address_make_payable for address;\n\n    /*\n     * CONSTANTS\n     */\n\n    uint16[] public bonusRate = [200, 150, 100, 50];\n\n    /*\n     * STATES\n     */\n    address public settler;\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n\n    address public reservedAccount;\n    uint256 public reservedAmount;\n    address public foundationAddr;\n\n    uint256 public firstBlock = 0;\n    uint256 public blockPerPhase = 0;\n\n    mapping (uint256 =\u003e uint256) public ethBalance;\n    mapping (uint256 =\u003e mapping (address =\u003e uint256)) public addressInvestment;\n    mapping (address =\u003e uint256) public totalInvestment;\n    mapping (address =\u003e uint256) public crBonus; // controlled release bonus\n    address[] icexInvestors;\n    mapping (uint256 =\u003e address[]) public topInvestor;\n    mapping (uint256 =\u003e bool) public settled;\n\n    InvitationBasic invitationContract;\n    LuckyDrawBasic luckydrawContract;\n    VDPoolBasic vdPoolContract;\n\n    uint256 public signUpFee = 0;\n    uint256 public rootFee = 0;\n    uint256 referrerBonus = 0;\n    uint256 ancestorBonus = 0;\n    uint16 topInvestorCounter = 0;\n    uint16 icexCRBonusRatio = 75;\n    uint256 crBonusReleasePhases = 10;\n    uint256 ethBonusReleasePhases = 20;\n\n    uint256 luckyDrawRate = 10;\n    uint256 invitationRate = 70;\n    uint256 topInvestorRate = 20;\n\n    uint256 foundationRate = 50;\n\n    uint256 icexRewardETHPool = 0;\n\n    /*\n     * EVENTS\n     */\n    /// Emitted only once after token sale starts.\n    event SaleStarted();\n\n    event Settled(uint256 phase, uint256 ethDistributed, uint256 ethToPool);\n\n    event LuckydrawSettle(uint256 phase, address indexed who, uint256 ethAmount);\n    event InvitationSettle(uint256 phase, address indexed who, uint256 ethAmount);\n    event InvestorSettle(uint256 phase, address indexed who, uint256 ethAmount);\n\n    /*\n     * MODIFIERS\n     */\n    /// only master can call the function\n    modifier onlyOwner {\n        require(master == msg.sender, \"only master can call\");\n        _;\n    }\n\n    constructor(string memory _name, string memory _symbol, uint256 _blockPerPhase, uint256 _totalSupply, uint256 _reservedAmount, address _reservedAccount, address _foundationAddr) public {\n        master = msg.sender;  // master account\n        settler = master;\n\n        name = _name;\n        symbol = _symbol;\n        totalSupply = _totalSupply;\n        currentSupply = _reservedAmount;\n\n        reservedAmount = _reservedAmount;\n        reservedAccount = _reservedAccount;\n        balances[reservedAccount] = reservedAmount;\n        emit Transfer(address(this), reservedAccount, reservedAmount);\n\n        foundationAddr = _foundationAddr; // foundation account\n\n        blockPerPhase = _blockPerPhase; // block number per phase\n    }\n\n    /*\n     * EXTERNAL FUNCTIONS\n     */\n\n    function setOwner(address newOwner) external onlyOwner {\n        master = newOwner;\n    }\n\n    function setSettler(address newSettler) external onlyOwner {\n        settler = newSettler;\n    }\n\n    function transfer(address _to, uint256 _value) external onlyPayloadSize(2 * 32) {\n        if ( _to == address(this)) {\n            require(_value == rootFee, \"only valid value is root fee for this recipient\");\n            balances[msg.sender] = balances[msg.sender].sub(_value);\n            balances[_to] = balances[_to].add(_value);\n            emit Transfer(msg.sender, _to, _value);\n            require(!isSignedUp(), \"not qulifiled as new root\");\n            invitationContract.newRoot(msg.sender, currentPhase());\n        } else if ( _value == signUpFee \u0026\u0026 invitationContract.isSignedUp(_to) \u0026\u0026 !isSignedUp()) {\n            uint256 fee = _value;\n            balances[msg.sender] = balances[msg.sender].sub(fee);\n\n            uint256 phase = currentPhase();\n            uint256 ePhase = phase;\n            if (phase \u003c bonusRate.length) {\n                ePhase = bonusRate.length - 1;\n            }\n\n            invitationContract.signUp(_to, msg.sender, phase, ePhase);\n            //direct referrer\n            balances[_to] = balances[_to].add(referrerBonus);\n            emit Transfer(msg.sender, _to, referrerBonus);\n            fee = fee.sub(referrerBonus);\n\n            // go up referrer tree\n            address[] memory ancestors = invitationContract.getAncestors(msg.sender);\n            for ( uint256 i = 0; i \u003c ancestors.length \u0026\u0026 fee \u003e= ancestorBonus; i++) {\n                if (ancestors[i] == address(0)) {\n                    break;\n                }\n                balances[ancestors[i]] = balances[ancestors[i]].add(ancestorBonus);\n                emit Transfer(msg.sender, ancestors[i], ancestorBonus);\n                fee = fee.sub(ancestorBonus);\n            }\n\n            balances[foundationAddr] = balances[foundationAddr].add(fee);\n            emit Transfer(msg.sender, foundationAddr, fee);\n        } else {\n            balances[msg.sender] = balances[msg.sender].sub(_value);\n            balances[_to] = balances[_to].add(_value);\n            emit Transfer(msg.sender, _to, _value);\n        }\n    }\n\n    function setInvitationContract(address addr, uint256 _rootFee, uint256 _signUpFee, uint256 _ancestorBonus, uint256 _referrerBonus, uint256 _invitationRate) external onlyOwner {\n        invitationContract = InvitationBasic(addr);\n\n        rootFee = _rootFee; // price to be root\n        signUpFee = _signUpFee; // sign up ticker price\n        ancestorBonus = _ancestorBonus;  // ancestor node bonus\n        referrerBonus = _referrerBonus;  // referrer node bonus\n        invitationRate = _invitationRate;\n    }\n\n    function setVdPoolContract(address addr, uint16 _topInvestorCounter, uint256 _topInvestorRate, uint256 _foundationRate) external onlyOwner {\n        vdPoolContract = VDPoolBasic(addr);\n\n        topInvestorCounter = _topInvestorCounter;  // number of top investor used during settlment\n        topInvestorRate = _topInvestorRate;  // top investor settle rate\n\n        foundationRate = _foundationRate; // foudation share\n    }\n\n    function setLuckyDrawContract(address addr, uint256 _luckyDrawRate) external onlyOwner {\n        luckydrawContract = LuckyDrawBasic(addr);\n        luckyDrawRate = _luckyDrawRate;\n    }\n\n    function settle(uint256 phase) external {\n        require(settler == address(0) || settler == msg.sender, \"only settler can call\");\n        require(phase \u003e= 0, \"invalid phase\");\n        require(phase \u003c currentPhase(), \"phase not matured yet\");\n        require (!settled[phase], \"phase already settled\");\n\n        uint256 pool = 0;\n        uint256 toPool = 0;\n        if (phase \u003c bonusRate.length) {\n            if(ethBalance[phase] \u003e 0) {\n                toPool = ethBalance[phase].mul(bonusRate.length).div(bonusRate.length + ethBonusReleasePhases);\n                icexRewardETHPool = icexRewardETHPool.add(toPool);\n                transferToFoundation(ethBalance[phase].sub(toPool));\n            }\n            // settling last phase of ICEX, combine pools\n            if (phase == bonusRate.length - 1) {\n                pool = icexRewardETHPool;\n            }\n        } else {\n            pool = ethBalance[phase];\n            distributeCRBonus(phase);\n        }\n\n        if (pool \u003e 0 ) {\n            settleLuckydraw(phase, pool, phase \u003c bonusRate.length);\n            settleTopInvestor(phase, pool);\n            settleInvitation(phase, pool);\n        }\n\n        settled[phase] = true;\n        emit Settled(phase, pool, toPool);\n    }\n\n    function start(uint256 _firstBlock) external onlyOwner {\n        require(!saleStarted(), \"Sale has not started yet\");\n        require(firstBlock == 0 , \"Resonance already started\");\n        firstBlock = _firstBlock;\n        emit SaleStarted();\n    }\n\n    /// @dev This default function allows token to be purchased by directly\n    /// sending ether to this smart contract.\n    function () external payable {\n        issueToken(msg.sender);\n    }\n\n    function price() external view returns(uint256) {\n        return vdPoolContract.price();\n    }\n\n    function currentLevel() external view returns(uint256) {\n        return vdPoolContract.currentLevel();\n    }\n\n    function currentRemainingEth() external view returns(uint256) {\n        return vdPoolContract.currentLevelRemaining();\n    }\n\n    function currentBonusRate() external view returns(uint16) {\n        uint256 phase = currentPhase();\n        if (phase \u003c bonusRate.length){\n            return bonusRate[phase];\n        }\n        return 0;\n    }\n\n    function isSignedUp() public view returns (bool) {\n        return invitationContract.isSignedUp(msg.sender);\n    }\n\n    function topInvestors(uint256 phase) external view returns (address[] memory) {\n        return topInvestor[phase];\n    }\n\n    function luckyWinners(uint256 phase) external view returns (address[] memory) {\n        return luckydrawContract.getWinners(phase);\n    }\n\n    function invitationWinners(uint256 phase) external view returns(address[] memory) {\n        return invitationContract.getTop(phase);\n    }\n\n    function drain(uint256 amount) external onlyOwner {\n        transferToFoundation(amount);\n    }\n\n    /*\n     * PUBLIC FUNCTIONS\n     */\n    function saleStarted() public view returns (bool) {\n        return (firstBlock \u003e 0 \u0026\u0026 block.number \u003e= firstBlock);\n    }\n\n    function currentPhase() public view returns(uint256) {\n        return (block.number - firstBlock).div(blockPerPhase);\n    }\n\n    function issueToken(address recipient) public payable {\n        require(saleStarted(), \"Sale is not in progress\");\n        require(msg.value \u003e= 0.1 ether, \"minimal of 0.1 eth required\");\n        uint256 phase = currentPhase();\n        uint256 totalEth = msg.value;\n\n        updateTopInvestor(recipient, msg.value, phase);\n        // ICEX\n        if (phase \u003c bonusRate.length){\n            uint256 bonus = totalEth.mul(bonusRate[phase]).div(100);\n            totalEth = totalEth.add(bonus);\n            if (crBonus[recipient] == 0 ) {\n                icexInvestors.push(recipient);\n            }\n        }\n\n        uint256 tokens = vdPoolContract.buyToken(totalEth);\n\n        totalInvestment[recipient] = totalInvestment[recipient].add(msg.value);\n        currentSupply = currentSupply.add(tokens);\n\n        require(currentSupply \u003c= totalSupply, \"exceed token supply cap\");\n\n        if (phase \u003c bonusRate.length){\n            uint256 crTokens = tokens.mul(bonusRate[phase]).div(100 + bonusRate[phase]).mul(icexCRBonusRatio).div(100);\n            require(crTokens \u003e= 0 \u0026\u0026 tokens \u003e crTokens, \u0027invalid cr bonus value\u0027);\n            crBonus[recipient] = crBonus[recipient].add(crTokens.div(crBonusReleasePhases));\n            balances[recipient] = balances[recipient].add(tokens).sub(crTokens);\n            emit Transfer(address(this), recipient, tokens.sub(crTokens));\n        } else {\n            balances[recipient] = balances[recipient].add(tokens);\n            emit Transfer(address(this), recipient, tokens);\n        }\n\n        uint256 foundation = msg.value.mul(foundationRate).div(100);\n        transferToFoundation(foundation);\n        ethBalance[phase] = ethBalance[phase].add(msg.value).sub(foundation);\n        luckydrawContract.buyTicket(recipient, phase);\n    }\n\n    /*\n     * INTERNAL FUNCTIONS\n     */\n\n    function updateTopInvestor(address addr, uint256 ethAmount, uint256 phase) internal {\n        uint256 ePhase = phase;\n        if (phase \u003c bonusRate.length) {\n            ePhase = bonusRate.length - 1; // save it for the last phase of ICEX\n        }\n        addressInvestment[ePhase][addr] = addressInvestment[ePhase][addr].add(ethAmount);\n\n        for (uint256 k = 0; k \u003c topInvestor[ePhase].length; k++){\n            if (topInvestor[ePhase][k] == addr) {\n                for (uint256 i = k; i \u003e 0; i--){\n                    if (addressInvestment[ePhase][topInvestor[ePhase][i]] \u003e addressInvestment[ePhase][topInvestor[ePhase][i-1]]) {\n                        (topInvestor[ePhase][i], topInvestor[ePhase][i-1]) = (topInvestor[ePhase][i-1], topInvestor[ePhase][i]);\n                    } else {\n                      break;\n                    }\n                }\n                return;\n            }\n        }\n\n        if (topInvestor[ePhase].length \u003c topInvestorCounter){\n            topInvestor[ePhase].push(addr);\n        } else if (addressInvestment[ePhase][addr] \u003e addressInvestment[ePhase][topInvestor[ePhase][topInvestor[ePhase].length - 1]]){\n            topInvestor[ePhase][topInvestor[ePhase].length - 1] = addr;\n        }\n\n        for (uint256 i = topInvestor[ePhase].length - 1; i \u003e 0; i--){\n            if (addressInvestment[ePhase][topInvestor[ePhase][i]] \u003e addressInvestment[ePhase][topInvestor[ePhase][i-1]]) {\n                (topInvestor[ePhase][i], topInvestor[ePhase][i-1]) = (topInvestor[ePhase][i-1], topInvestor[ePhase][i]);\n            } else {\n              break;\n            }\n        }\n    }\n\n    function transferToFoundation(uint256 ethAmount) internal {\n        address payable addr = foundationAddr.make_payable();\n        addr.transfer(ethAmount);\n    }\n\n    function settleLuckydraw(uint256 phase, uint256 ethAmount, bool isIcex) internal {\n        if (isIcex) {\n            luckydrawContract.aggregateIcexWinners(phase);\n        }\n        address[] memory winners = luckydrawContract.getWinners(phase);\n\n        uint256 bonus = ethAmount.mul(luckyDrawRate).div(100).div(winners.length);\n        if (winners.length == 0 \u0026\u0026 bonus \u003e 0){\n            transferToFoundation(bonus);\n            return;\n        }\n\n        for (uint256 i = 0; i \u003c winners.length; i++) {\n            address payable addr = winners[i].make_payable();\n            addr.transfer(bonus);\n            emit LuckydrawSettle(phase, winners[i], bonus);\n        }\n    }\n\n    function settleTopInvestor (uint256 phase, uint256 ethAmount) internal {\n        uint256 bonus = ethAmount.mul(topInvestorRate).div(100);\n        if (topInvestor[phase].length == 0 \u0026\u0026 bonus \u003e 0){\n            transferToFoundation(bonus);\n            return;\n        }\n\n        uint256 len = topInvestor[phase].length;\n        uint256[] memory factors = invitationContract.distributeBonus(len);\n        for (uint256 i = 0; i \u003c topInvestor[phase].length; i++) {\n            address payable addr = topInvestor[phase][i].make_payable();\n            uint256 iBonus = bonus.mul(factors[i]).div(len).div(len);\n            addr.transfer(iBonus);\n            emit InvestorSettle(phase, addr, iBonus);\n        }\n    }\n\n    function settleInvitation (uint256 phase, uint256 ethAmount) internal {\n        uint256 totalBonus = ethAmount.mul(invitationRate).div(100);\n        address[] memory winners = invitationContract.getTop(phase);\n        if (winners.length == 0 \u0026\u0026 totalBonus \u003e 0){\n            transferToFoundation(totalBonus);\n            return;\n        }\n\n        uint256 len = winners.length;\n        uint256[] memory factors = invitationContract.distributeBonus(len);\n        for (uint256 i = 0; i \u003c factors.length; i++) {\n            uint256 bonus = totalBonus.mul(factors[i]).div(len).div(len);\n            address payable addr = winners[i].make_payable();\n            addr.transfer(bonus);\n            emit InvitationSettle(phase, winners[i], bonus);\n        }\n    }\n\n    function distributeCRBonus(uint256 phase) internal {\n        if (phase \u003c bonusRate.length || phase \u003e= bonusRate.length + crBonusReleasePhases) {\n          return;\n        }\n\n        for (uint256 i = 0; i \u003c icexInvestors.length; i++) {\n            address addr = icexInvestors[i];\n            balances[addr] = balances[addr].add(crBonus[addr]);\n            emit Transfer(address(this), addr, crBonus[addr]);\n        }\n    }\n}\n"}}