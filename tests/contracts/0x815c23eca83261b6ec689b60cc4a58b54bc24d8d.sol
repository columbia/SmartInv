{{
  "language": "Solidity",
  "sources": {
    "src/vTHOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { ERC20Vote } from \"../lib/ERC20Vote.sol\";\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { IERC4626 } from \"./interfaces/IERC4626.sol\";\nimport { SafeTransferLib } from \"../lib/SafeTransferLib.sol\";\nimport { FixedPointMathLib } from \"../lib/FixedPointMathLib.sol\";\nimport { ReentrancyGuard } from \"../lib/ReentrancyGuard.sol\";\n\ncontract vTHOR is IERC4626, ERC20Vote, ReentrancyGuard {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    IERC20 public _asset;\n\n    constructor(IERC20 asset_) ERC20Vote(\"vTHOR\", \"vTHOR\", 18) {\n        _asset = asset_;\n    }\n\n    function asset() public view returns (address) {\n        return address(_asset);\n    }\n\n    function totalAssets() public view returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    function convertToShares(uint256 assets) public view returns (uint256) {\n        uint256 supply = totalSupply;\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view returns (uint256) {\n        uint256 supply = totalSupply;\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view returns (uint256) {\n        uint256 supply = totalSupply;\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view returns (uint256) {\n        uint256 supply = totalSupply;\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    function maxDeposit(address) public view returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    function deposit(uint256 assets, address receiver) public nonReentrant returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n        // Need to transfer before minting or ERC777s could reenter.\n        address(_asset).safeTransferFrom(msg.sender, address(this), assets);\n        _mint(receiver, shares);\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public nonReentrant returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n        // Need to transfer before minting or ERC777s could reenter.\n        address(_asset).safeTransferFrom(msg.sender, address(this), assets);\n        _mint(receiver, shares);\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public nonReentrant returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n        _burn(owner, shares);\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n        address(_asset).safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public nonReentrant returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n        _burn(owner, shares);\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n        address(_asset).safeTransfer(receiver, assets);\n    }\n}\n"
    },
    "lib/ERC20Vote.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas-optimized ERC20 + EIP-2612 implementation with COMP-style governance.\nabstract contract ERC20Vote {\n    /*///////////////////////////////////////////////////////////////\n                            EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /*///////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                            DAO STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant DELEGATION_TYPEHASH = \n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) internal _delegates;\n\n    mapping(address => mapping(uint256 => Checkpoint)) public checkpoints;\n\n    mapping(address => uint256) public numCheckpoints;\n\n    struct Checkpoint {\n        uint32 fromTimestamp;\n        uint96 votes;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // this is safe from overflow because the sum of all user\n        // balances can't exceed 'type(uint256).max'\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        \n        _moveDelegates(delegates(msg.sender), delegates(to), amount);\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) \n            allowance[from][msg.sender] -= amount;\n\n        balanceOf[from] -= amount;\n\n        // this is safe from overflow because the sum of all user\n        // balances can't exceed 'type(uint256).max'\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        \n        _moveDelegates(delegates(from), delegates(to), amount);\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            DAO LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function delegates(address delegator) public view virtual returns (address delegatee) {\n        address current = _delegates[delegator];\n        \n        delegatee = current == address(0) ? delegator : current;\n    }\n\n    function getCurrentVotes(address account) public view virtual returns (uint256 votes) {\n        // this is safe from underflow because decrement only occurs if `nCheckpoints` is positive\n        unchecked {\n            uint256 nCheckpoints = numCheckpoints[account];\n\n            votes = nCheckpoints != 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n        }\n    }\n\n    function delegate(address delegatee) public virtual {\n        _delegate(msg.sender, delegatee);\n    }\n\n    function delegateBySig(\n        address delegatee, \n        uint256 nonce, \n        uint256 expiry, \n        uint8 v, \n        bytes32 r, \n        bytes32 s\n    ) public virtual {\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), structHash));\n\n        address signatory = ecrecover(digest, v, r, s);\n\n        require(signatory != address(0), \"ZERO_ADDRESS\");\n        \n        // this is reasonably safe from overflow because incrementing `nonces` beyond\n        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits\n        unchecked {\n            require(nonce == nonces[signatory]++, \"INVALID_NONCE\");\n        }\n\n        require(block.timestamp <= expiry, \"SIGNATURE_EXPIRED\");\n\n        _delegate(signatory, delegatee);\n    }\n\n    function getPriorVotes(address account, uint256 timestamp) public view virtual returns (uint96 votes) {\n        require(block.timestamp > timestamp, \"NOT_YET_DETERMINED\");\n\n        uint256 nCheckpoints = numCheckpoints[account];\n\n        if (nCheckpoints == 0) return 0;\n        \n        // this is safe from underflow because decrement only occurs if `nCheckpoints` is positive\n        unchecked {\n            if (checkpoints[account][nCheckpoints - 1].fromTimestamp <= timestamp)\n                \n                return checkpoints[account][nCheckpoints - 1].votes;\n\n            if (checkpoints[account][0].fromTimestamp > timestamp) return 0;\n\n            uint256 lower;\n            \n            // this is safe from underflow because decrement only occurs if `nCheckpoints` is positive\n            uint256 upper = nCheckpoints - 1;\n\n            while (upper > lower) {\n                // this is safe from underflow because `upper` ceiling is provided\n                uint256 center = upper - (upper - lower) / 2;\n\n                Checkpoint memory cp = checkpoints[account][center];\n\n                if (cp.fromTimestamp == timestamp) {\n                    return cp.votes;\n                } else if (cp.fromTimestamp < timestamp) {\n                    lower = center;\n                } else {\n                    upper = center - 1;\n                }\n            }\n\n        return checkpoints[account][lower].votes;\n\n        }\n    }\n\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = _delegates[delegator];\n\n        _delegates[delegator] = delegatee;\n\n        _moveDelegates(currentDelegate, delegatee, balanceOf[delegator]);\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n    }\n\n    function _moveDelegates(\n        address srcRep, \n        address dstRep, \n        uint256 amount\n    ) internal virtual {\n        if (srcRep != dstRep && amount != 0) \n            if (srcRep != address(0)) {\n                uint256 srcRepNum = numCheckpoints[srcRep];\n                \n                uint256 srcRepOld = srcRepNum != 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n\n                uint256 srcRepNew = srcRepOld - amount;\n\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n            \n            if (dstRep != address(0)) {\n                uint256 dstRepNum = numCheckpoints[dstRep];\n\n                uint256 dstRepOld = dstRepNum != 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n\n                uint256 dstRepNew = dstRepOld + amount;\n\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n    }\n\n    function _writeCheckpoint(\n        address delegatee, \n        uint256 nCheckpoints, \n        uint256 oldVotes, \n        uint256 newVotes\n    ) internal virtual {\n        unchecked {\n            // this is safe from underflow because decrement only occurs if `nCheckpoints` is positive\n            if (nCheckpoints != 0 && checkpoints[delegatee][nCheckpoints - 1].fromTimestamp == block.timestamp) {\n                checkpoints[delegatee][nCheckpoints - 1].votes = safeCastTo96(newVotes);\n            } else {\n                checkpoints[delegatee][nCheckpoints] = Checkpoint(safeCastTo32(block.timestamp), safeCastTo96(newVotes));\n                \n                // this is reasonably safe from overflow because incrementing `nCheckpoints` beyond\n                // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits\n                numCheckpoints[delegatee] = nCheckpoints + 1;\n            }\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(block.timestamp <= deadline, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // this is reasonably safe from overflow because incrementing `nonces` beyond\n        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            \n            require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_PERMIT_SIGNATURE');\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 domainSeparator) {\n        domainSeparator = block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32 domainSeparator) {\n        domainSeparator = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // this is safe because the sum of all user\n        // balances can't exceed 'type(uint256).max'\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        _moveDelegates(address(0), delegates(to), amount);\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // this is safe because a user won't ever\n        // have a balance larger than `totalSupply`\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        _moveDelegates(delegates(from), address(0), amount);\n\n        emit Transfer(from, address(0), amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            SAFECAST LOGIC\n    //////////////////////////////////////////////////////////////*/\n    \n    function safeCastTo32(uint256 x) internal pure virtual returns (uint32 y) {\n        require(x <= type(uint32).max);\n\n        y = uint32(x);\n    }\n    \n    function safeCastTo96(uint256 x) internal pure virtual returns (uint96 y) {\n        require(x <= type(uint96).max);\n\n        y = uint96(x);\n    }\n}\n"
    },
    "src/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n"
    },
    "src/interfaces/IERC4626.sol": {
      "content": "interface IERC4626 {\n    function asset() external view returns (address assetTokenAddress);\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n    event Withdraw(address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares);\n}\n"
    },
    "lib/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\nlibrary SafeTransferLib {\n    /*///////////////////////////////////////////////////////////////\n                            ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool callStatus;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(callStatus, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 100 because the calldata length is 4 + 32 * 3.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\n        assembly {\n            // Get how many bytes the call returned.\n            let returnDataSize := returndatasize()\n\n            // If the call reverted:\n            if iszero(callStatus) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                success := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                success := 1\n            }\n            default {\n                // It returned some malformed input.\n                success := 0\n            }\n        }\n    }\n}\n"
    },
    "lib/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "lib/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}