{{
  "language": "Solidity",
  "sources": {
    "contracts/Token/DNDAOToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Lightweight token modelled after UNI-LP:\n// https://github.com/Uniswap/uniswap-v2-core/blob/v1.0.1/contracts/UniswapV2ERC20.sol\n// Adds:\n//   - An exposed `burn()` and `mint()` with minting role\n//   - ERC-3009 (`transferWithAuthorization()`)\n//   - domainSeparator is computed inside `_validateSignedData` to avoid reply-attacks due to Hardforks\n//   - to != address(this) && to != address(0); To avoid people sending tokens to this smartcontract and\n//          to distinguish burn events from transfer\n\ncontract NODE is IERC20 {\n    uint256 public initialBalance;\n\n    // bytes32 public constant PERMIT_TYPEHASH =\n    //      keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    // bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =\n    //      keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\");\n    bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =\n        0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n    // bytes32 public constant EIP712DOMAIN_HASH =\n    //      keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n    bytes32 public constant EIP712DOMAIN_HASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n    // bytes32 public constant NAME_HASH =\n    //      keccak256(\"DAppNode DAO Token\")\n    bytes32 public constant NAME_HASH =\n        0x1516f2223544938aa8c94ede78adef55df8fb03f42c0bafde0491ede41d2ade7;\n    // bytes32 public constant VERSION_HASH =\n    //      keccak256(\"1\")\n    bytes32 public constant VERSION_HASH =\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    string public constant name = \"DAppNode DAO Token\";\n    string public constant symbol = \"NODE\";\n    uint8 public constant decimals = 18;\n\n    address public minter;\n    uint256 public override totalSupply;\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    // ERC-2612, ERC-3009 state\n    mapping(address => uint256) public nonces;\n    mapping(address => mapping(bytes32 => bool)) public authorizationState;\n\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n    event ChangeMinter(address indexed minter);\n\n    modifier onlyMinter {\n        require(msg.sender == minter, \"NODE: NOT_MINTER\");\n        _;\n    }\n\n    constructor(address initialMinter) {\n        _changeMinter(initialMinter);\n    }\n\n    function _validateSignedData(\n        address signer,\n        bytes32 encodeData,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", getDomainSeparator(), encodeData)\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n        require(\n            recoveredAddress != address(0) && recoveredAddress == signer,\n            \"NODE: INVALID_SIGNATURE\"\n        );\n    }\n\n    function _changeMinter(address newMinter) internal {\n        minter = newMinter;\n        emit ChangeMinter(newMinter);\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply + value;\n        balanceOf[to] = balanceOf[to] + value;\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        // Balance is implicitly checked with solidity underflow protection\n        balanceOf[from] = balanceOf[from] - value;\n        totalSupply = totalSupply - value;\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        require(\n            to != address(this) && to != address(0),\n            \"NODE: NOT_VALID_TRANSFER\"\n        );\n        // Balance is implicitly checked with SafeMath's underflow protection\n        balanceOf[from] = balanceOf[from] - value;\n        balanceOf[to] = balanceOf[to] + value;\n        emit Transfer(from, to, value);\n    }\n\n    function getChainId() public view returns (uint256 chainId) {\n        assembly {\n            chainId := chainid()\n        }\n    }\n\n    function getDomainSeparator() public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    EIP712DOMAIN_HASH,\n                    NAME_HASH,\n                    VERSION_HASH,\n                    getChainId(),\n                    address(this)\n                )\n            );\n    }\n\n    function mint(address to, uint256 value)\n        external\n        onlyMinter\n        returns (bool)\n    {\n        _mint(to, value);\n        return true;\n    }\n\n    function changeMinter(address newMinter) external onlyMinter {\n        _changeMinter(newMinter);\n    }\n\n    function burn(uint256 value) external returns (bool) {\n        _burn(msg.sender, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value)\n        external\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value)\n        external\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external override returns (bool) {\n        uint256 fromAllowance = allowance[from][msg.sender];\n        if (fromAllowance != type(uint256).max) {\n            // Allowance is implicitly checked with solidity underflow protection\n            allowance[from][msg.sender] = fromAllowance - value;\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"NODE: AUTH_EXPIRED\");\n        bytes32 encodeData = keccak256(\n            abi.encode(\n                PERMIT_TYPEHASH,\n                owner,\n                spender,\n                value,\n                nonces[owner]++,\n                deadline\n            )\n        );\n        _validateSignedData(owner, encodeData, v, r, s);\n        _approve(owner, spender, value);\n    }\n\n    function transferWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp > validAfter, \"NODE: AUTH_NOT_YET_VALID\");\n        require(block.timestamp < validBefore, \"NODE: AUTH_EXPIRED\");\n        require(!authorizationState[from][nonce], \"NODE: AUTH_ALREADY_USED\");\n\n        bytes32 encodeData = keccak256(\n            abi.encode(\n                TRANSFER_WITH_AUTHORIZATION_TYPEHASH,\n                from,\n                to,\n                value,\n                validAfter,\n                validBefore,\n                nonce\n            )\n        );\n        _validateSignedData(from, encodeData, v, r, s);\n\n        authorizationState[from][nonce] = true;\n        emit AuthorizationUsed(from, nonce);\n\n        _transfer(from, to, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}