{"tmp3.sol":{"content":"// SPDX-License-Identifier: PRIVATE\npragma solidity \u003e=0.7.0 \u003c 0.8.0;\npragma abicoder v2;\n\nimport \"./tmp4.sol\";\n\nstruct InvestInfo {\n  address Addr;\n  uint256 ID;\n\n  uint256 restCRFI;\n  uint256 perTimeCRFI;\n  \n  uint256 nextTime;\n  uint256 duration;\n  uint256 totalNums;\n}\n\ncontract Distribution is  ReentrancyGuard {\n  //////////////////// for using\n  using SafeMath for uint256;\n\n  //////////////////// constant\n\n  ////////////////////\n  IERC20 CRFI;\n\n  //////////////////// invest\n  // invest\n  uint256 public NewInvestID;\n  mapping(uint256 =\u003e InvestInfo) Invests;\n  mapping(address =\u003e uint256) public InvestAddrID;\n\n\n  //////////////////// modifier\n  constructor(address crfiAddr){\n    CRFI = IERC20(crfiAddr);\n    NewInvestID = 1;\n  }\n  \n  //////////////////// public\n  function Charge(address to,\n                  uint256 totalCRFI,\n                  uint256 nextTime,\n                  uint256 duration,\n                  uint256 totalNums)\n    public\n    nonReentrant(){\n\n    uint256 uID = getUID(to);\n    InvestInfo storage uInfo = Invests[uID];\n    \n    withdraw(uInfo);\n    require(uInfo.restCRFI == 0, \"have rest crfi\");\n\n    require(to != address(0x0), \"user must not zero addr\");\n    require(totalCRFI \u003e 0, \"totalCRFI must \u003e 0\");\n    require(duration \u003e 0, \"duration must \u003e 0\");\n    require(totalNums \u003e 0, \"totalNums must \u003e 0\");\n    require(totalCRFI \u003e totalNums, \"totalCRFI must \u003e totalNums\");\n\n    CRFI.transferFrom(msg.sender, address(this), totalCRFI);\n\n    uInfo.restCRFI = totalCRFI;\n    uInfo.perTimeCRFI = totalCRFI / totalNums;\n    uInfo.nextTime = nextTime;\n    uInfo.duration = duration;\n    uInfo.totalNums = totalNums;\n  }\n\n  function Withdraw(address addr)\n    public\n    nonReentrant(){\n    if(addr == address(0x0)){\n      addr = msg.sender;\n    }\n    \n    uint256 uID = getUID(addr);\n    InvestInfo storage uInfo = Invests[uID];\n    \n    withdraw(uInfo);\n  }\n    \n\n  //////////////////// view\n  function GetInvestInfo(address addr)\n    public\n    view\n    returns(uint256 restCRFI,\n            uint256 perTimeCRFI,\n            uint256 nextTime,\n            uint256 duration,\n            uint256 totalNums,\n            uint256 avaiCRFI){\n    \n    uint256 uID = InvestAddrID[addr];\n    if(uID == 0){\n      return(restCRFI,\n             perTimeCRFI,\n             nextTime,\n             duration,\n             totalNums,\n             avaiCRFI);\n    }\n    \n    InvestInfo storage uInfo = Invests[uID];\n    (avaiCRFI, nextTime, totalNums) = calcNowAvaiCRFI(uInfo);\n\n    restCRFI = uInfo.restCRFI.sub(avaiCRFI);\n    return(restCRFI,\n           uInfo.perTimeCRFI,\n           nextTime,\n           uInfo.duration,\n           totalNums,\n           avaiCRFI);\n  }\n\n  //////////////////// internal\n\n  function withdraw(InvestInfo storage uInfo)\n    internal{\n    (uint256 avaiCRFI, uint256 nextTime, uint256 totalNums) = calcNowAvaiCRFI(uInfo);\n    if(avaiCRFI == 0){\n      return;\n    }\n\n    uInfo.restCRFI = uInfo.restCRFI.sub(avaiCRFI);\n    uInfo.nextTime = nextTime;\n    uInfo.totalNums = totalNums;\n\n    CRFI.transfer(uInfo.Addr, avaiCRFI);\n  }\n    \n  function calcNowAvaiCRFI(InvestInfo storage uInfo)\n    internal\n    view\n    returns(uint256 avaiCRFI, uint256 nextTime, uint256 totalNums){\n    if(block.timestamp \u003c uInfo.nextTime || uInfo.restCRFI == 0 || uInfo.totalNums == 0){\n      return (0, uInfo.nextTime, uInfo.totalNums);\n    }\n\n    uint256 times = block.timestamp.sub(uInfo.nextTime) / uInfo.duration;\n    times++;\n    if(times \u003e uInfo.totalNums){\n      times = uInfo.totalNums;\n    }\n\n    avaiCRFI = times.mul(uInfo.perTimeCRFI);\n    nextTime = uInfo.nextTime.add(uInfo.duration.mul(times));\n    \n    totalNums = uInfo.totalNums.sub(times);\n    if(totalNums == 0){\n      avaiCRFI = uInfo.restCRFI;\n    }\n\n    return(avaiCRFI, nextTime, totalNums);\n  }\n\n  function getUID(address addr) internal returns(uint256 uID){\n    uID = InvestAddrID[addr];\n    if(uID != 0){\n      return uID;\n    }\n\n    uID = NewInvestID;\n    NewInvestID++;\n\n    InvestInfo storage uInfo = Invests[uID];\n    uInfo.Addr = addr;\n    uInfo.ID = uID;\n        \n    InvestAddrID[addr] = uID;\n    return uID;\n  }\n\n}\n"},"tmp4.sol":{"content":"// SPDX-License-Identifier: PRIVATE\npragma solidity \u003e=0.6.0 \u003c 0.8.0;\n\n// import \"github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/token/ERC20/IERC20.sol\";\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\u0027s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c \u003c a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b \u003e a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n"}}