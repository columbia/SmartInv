{"LiquidityTransformer.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \u0027./provableAPI_0.6.sol\u0027;\r\n\r\n// Interfaces\r\ninterface ISwappToken {\r\n    function currentSwappDay() external view returns (uint64);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n    function mintSupply(address _investorAddress, uint256 _amount) external;\r\n    function giveStatus(address _referrer) external;\r\n}\r\n\r\ninterface UniswapRouterV2 {\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenMax,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (\r\n        uint256 amountToken,\r\n        uint256 amountETH,\r\n        uint256 liquidity\r\n    );\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (\r\n        uint256[] memory amounts\r\n    );\r\n}\r\n\r\ninterface IERC20Token {\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n}\r\n\r\nlibrary SafeMathLT {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \u0027SWAPP: addition overflow\u0027);\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003c= a, \u0027SWAPP: subtraction overflow\u0027);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0027SWAPP: multiplication overflow\u0027);\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003e 0, \u0027SWAPP: division by zero\u0027);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \u0027SWAPP: modulo by zero\u0027);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract LiquidityTransformer is usingProvable {\r\n    using SafeMathLT for uint256;\r\n    using SafeMathLT for uint128;\r\n\r\n    ISwappToken public SWAPP_CONTRACT;\r\n\r\n    UniswapRouterV2 private constant UNISWAP_ROUTER = UniswapRouterV2(\r\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n    );\r\n\r\n    address payable constant TEAM_ADDRESS = 0xde121Cc755c1D1786Dd46FfF7e373e9372FD79D8;\r\n    address public TOKEN_DEFINER = 0xF1b9ad5D49d5829A0BdC698483CcBbF2179043C2;\r\n\r\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // mainnet\r\n    uint8 constant INVESTMENT_DAYS = 30;\r\n\r\n    uint128 constant THRESHOLD_LIMIT_MIN = 1 ether;\r\n    uint128 constant THRESHOLD_LIMIT_INFLUENCER = 50 ether;\r\n    uint128 constant THRESHOLD_LIMIT_SUPPER = 150 ether;\r\n\r\n    uint128 constant TEAM_ETHER_MAX = 2000 ether;\r\n    uint128 constant MIN_INVEST = 0.05 ether;\r\n    uint128 constant DAILY_MAX_SUPPLY = 10000000;\r\n\r\n    uint256 constant TESLAS_PER_SWAPP = 10 ** uint256(18);\r\n    uint256 constant NUM_RANDOM_BYTES_REQUESTED = 7;\r\n\r\n    struct Globals {\r\n        uint64 generatedDays;\r\n        uint64 generationDayBuffer;\r\n        uint64 generationTimeout;\r\n        uint64 preparedReferrals;\r\n        uint256 totalTransferTokens;\r\n        uint256 totalWeiContributed;\r\n        uint256 totalReferralTokens;\r\n    }\r\n\r\n    Globals public g;\r\n\r\n    mapping(uint256 =\u003e uint256) dailyMinSupply;\r\n    mapping(uint256 =\u003e uint256) public dailyTotalSupply;\r\n    mapping(uint256 =\u003e uint256) public dailyTotalInvestment;\r\n\r\n    mapping(uint256 =\u003e uint256) public investorAccountCount;\r\n    mapping(uint256 =\u003e mapping(uint256 =\u003e address)) public investorAccounts;\r\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) public investorBalances;\r\n\r\n    mapping(address =\u003e uint256) public referralAmount;\r\n    mapping(address =\u003e uint256) public referralTokens;\r\n    mapping(address =\u003e uint256) public investorTotalBalance;\r\n    mapping(address =\u003e uint256) originalInvestment;\r\n\r\n    uint32 public totalInvestorCount;\r\n\r\n    uint256 public referralAccountCount;\r\n    \r\n    mapping (uint256 =\u003e address) public referralAccounts;\r\n\r\n    event GeneratedSupply(\r\n        uint256 indexed investmentDay,\r\n        uint256 supply\r\n    );\r\n\r\n    event GenerationStatus(\r\n        uint64 indexed investmentDay,\r\n        bool result\r\n    );\r\n\r\n    event LogNewProvableQuery(\r\n        string description\r\n    );\r\n\r\n    event ReferralAdded(\r\n        address indexed referral,\r\n        address indexed referee,\r\n        uint256 amount\r\n    );\r\n\r\n    event UniSwapResult(\r\n        uint256 amountToken,\r\n        uint256 amountETH,\r\n        uint256 liquidity\r\n    );\r\n\r\n    event SwappReservation(\r\n        address indexed sender,\r\n        uint256 indexed investmentDay,\r\n        uint256 amount\r\n    );\r\n\r\n    modifier afterInvestmentPhase() {\r\n        require(\r\n            _currentSwappDay() \u003e INVESTMENT_DAYS,\r\n            \u0027SWAPP: ongoing investment phase\u0027\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier afterUniswapTransfer() {\r\n        require (\r\n            g.generatedDays \u003e 0 \u0026\u0026\r\n            g.totalWeiContributed == 0,\r\n            \u0027SWAPP: forward liquidity first\u0027\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier investmentDaysRange(uint256 _investmentDay) {\r\n        require(\r\n            _investmentDay \u003e 0 \u0026\u0026\r\n            _investmentDay \u003c= INVESTMENT_DAYS,\r\n            \u0027SWAPP: not in initial investment days range\u0027\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier investmentEntryAmount(uint256 _days) {\r\n        require(\r\n            msg.value \u003e= MIN_INVEST * _days,\r\n            \u0027SWAPP: investment below minimum\u0027\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyFundedDays(uint256 _investmentDay) {\r\n        require(\r\n            dailyTotalInvestment[_investmentDay] \u003e 0,\r\n            \u0027SWAPP: no investments on that day\u0027\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenDefiner() {\r\n        require(\r\n            msg.sender == TOKEN_DEFINER,\r\n            \u0027SWAPP: wrong sender\u0027\r\n        );\r\n        _;\r\n    }\r\n\r\n    receive() external payable {\r\n        require (\r\n            msg.sender == address(UNISWAP_ROUTER) ||\r\n            msg.sender == TEAM_ADDRESS ||\r\n            msg.sender == TOKEN_DEFINER,\r\n            \u0027SWAPP: direct deposits disabled\u0027\r\n        );\r\n    }\r\n\r\n    function defineToken(\r\n        address _swappToken\r\n    ) external onlyTokenDefiner {\r\n        SWAPP_CONTRACT = ISwappToken(_swappToken);\r\n    }\r\n\r\n    function revokeAccess() external onlyTokenDefiner {\r\n        TOKEN_DEFINER = address(0x0);\r\n    }\r\n\r\n    constructor() {\r\n        provable_setProof(proofType_Ledger);\r\n        provable_setCustomGasPrice(10000000000);\r\n\r\n        dailyMinSupply[1] = 5000000;\r\n        dailyMinSupply[2] = 5000000;\r\n        dailyMinSupply[3] = 3300000;\r\n        dailyMinSupply[4] = 4500000;\r\n        dailyMinSupply[5] = 5000000;\r\n        dailyMinSupply[6] = 4500000;\r\n        dailyMinSupply[7] = 5000000;\r\n        dailyMinSupply[8] = 2500000;\r\n        dailyMinSupply[9] = 5000000;\r\n        dailyMinSupply[10] = 5000000;\r\n\r\n        dailyMinSupply[11] = 3500000;\r\n        dailyMinSupply[12] = 5000000;\r\n        dailyMinSupply[13] = 3500000;\r\n        dailyMinSupply[14] = 3400000;\r\n        dailyMinSupply[15] = 5000000;\r\n        dailyMinSupply[16] = 5000000;\r\n        dailyMinSupply[17] = 3000000;\r\n        dailyMinSupply[18] = 5000000;\r\n        dailyMinSupply[19] = 3000000;\r\n        dailyMinSupply[20] = 5000000;\r\n\r\n        dailyMinSupply[21] = 3000000;\r\n        dailyMinSupply[22] = 5000000;\r\n        dailyMinSupply[23] = 2500000;\r\n        dailyMinSupply[24] = 5000000;\r\n        dailyMinSupply[25] = 2200000;\r\n        dailyMinSupply[26] = 5000000;\r\n        dailyMinSupply[27] = 3200000;\r\n        dailyMinSupply[28] = 5000000;\r\n        dailyMinSupply[29] = 7900000;\r\n        dailyMinSupply[30] = 5000000;\r\n    }\r\n\r\n    //  SWAPP RESERVATION (EXTERNAL FUNCTIONS)  //\r\n    //  -------------------------------------  //\r\n\r\n    /** @dev Performs reservation of SWAPP tokens with ETH\r\n      * @param _investmentDays array of reservation days.\r\n      * @param _referralAddress referral address for bonus.\r\n      */\r\n    function reserveSwapp(\r\n        uint8[] calldata _investmentDays,\r\n        address _referralAddress\r\n    ) external payable investmentEntryAmount(_investmentDays.length) {\r\n        checkInvestmentDays(\r\n            _investmentDays,\r\n            _currentSwappDay()\r\n        );\r\n\r\n        _reserveSwapp(\r\n            _investmentDays,\r\n            _referralAddress,\r\n            msg.sender,\r\n            msg.value\r\n        );\r\n    }\r\n\r\n    //  SWAPP RESERVATION (INTERNAL FUNCTIONS)  //\r\n    //  -------------------------------------  //\r\n\r\n    /** @notice Distributes ETH equaly between selected reservation days\r\n      * @dev this will require LT contract to be approved as a spender\r\n      * @param _investmentDays array of selected reservation days\r\n      * @param _referralAddress referral address for bonus\r\n      * @param _senderAddress address of the investor\r\n      * @param _senderValue amount of ETH contributed\r\n      */\r\n    function _reserveSwapp(\r\n        uint8[] memory _investmentDays,\r\n        address _referralAddress,\r\n        address _senderAddress,\r\n        uint256 _senderValue\r\n    ) internal {\r\n        require(\r\n            _senderAddress != _referralAddress,\r\n            \u0027SWAPP: must be a different address\u0027\r\n        );\r\n\r\n        require(\r\n            notContract(_referralAddress),\r\n            \u0027SWAPP: invalid referral address\u0027\r\n        );\r\n\r\n        uint256 _investmentBalance = _referralAddress == address(0x0)\r\n            ? _senderValue // no referral bonus\r\n            : _senderValue.mul(1100).div(1000); // 10% referral bonus\r\n\r\n        uint256 _totalDays = _investmentDays.length;\r\n        uint256 _dailyAmount = _investmentBalance.div(_totalDays);\r\n        uint256 _leftOver = _investmentBalance.mod(_totalDays);\r\n\r\n        _addBalance(\r\n            _senderAddress,\r\n            _investmentDays[0],\r\n            _dailyAmount.add(_leftOver)\r\n        );\r\n\r\n        for (uint8 _i = 1; _i \u003c _totalDays; _i++) {\r\n            _addBalance(\r\n                _senderAddress,\r\n                _investmentDays[_i],\r\n                _dailyAmount\r\n            );\r\n        }\r\n\r\n        _trackInvestors(\r\n            _senderAddress,\r\n            _investmentBalance\r\n        );\r\n\r\n        if (_referralAddress != address(0x0)) {\r\n\r\n            _trackReferrals(_referralAddress, _senderValue);\r\n\r\n            emit ReferralAdded(\r\n                _referralAddress,\r\n                _senderAddress,\r\n                _senderValue\r\n            );\r\n        }\r\n\r\n        originalInvestment[_senderAddress] += _senderValue;\r\n        g.totalWeiContributed += _senderValue;\r\n    }\r\n\r\n    /** @notice Allocates investors balance to specific day\r\n      * @param _senderAddress investors wallet address\r\n      * @param _investmentDay selected investment day\r\n      * @param _investmentBalance amount invested (with bonus)\r\n      */\r\n    function _addBalance(\r\n        address _senderAddress,\r\n        uint256 _investmentDay,\r\n        uint256 _investmentBalance\r\n    ) internal {\r\n        if (investorBalances[_senderAddress][_investmentDay] == 0) {\r\n            investorAccounts[_investmentDay][investorAccountCount[_investmentDay]] = _senderAddress;\r\n            investorAccountCount[_investmentDay]++;\r\n        }\r\n\r\n        investorBalances[_senderAddress][_investmentDay] += _investmentBalance;\r\n        dailyTotalInvestment[_investmentDay] += _investmentBalance;\r\n\r\n        emit SwappReservation(\r\n            _senderAddress,\r\n            _investmentDay,\r\n            _investmentBalance\r\n        );\r\n    }\r\n\r\n    //  SWAPP RESERVATION (PRIVATE FUNCTIONS)  //\r\n    //  ------------------------------------  //\r\n\r\n    /** @notice Tracks investorTotalBalance\r\n      * @dev used in _reserveSwapp() internal function\r\n      * @param _investorAddress address of the investor\r\n      * @param _value ETH amount invested (with bonus)\r\n      */\r\n    function _trackInvestors(address _investorAddress, uint256 _value) private {\r\n        if (investorTotalBalance[_investorAddress] == 0) {\r\n            totalInvestorCount++;\r\n        }\r\n        investorTotalBalance[_investorAddress] += _value;\r\n    }\r\n\r\n    /** @notice Tracks referralAmount and referralAccounts\r\n      * @dev used in _reserveSwapp() internal function\r\n      * @param _referralAddress address of the referrer\r\n      * @param _value ETH amount referred during reservation\r\n      */\r\n    function _trackReferrals(address _referralAddress, uint256 _value) private {\r\n        if (referralAmount[_referralAddress] == 0) {\r\n            referralAccounts[referralAccountCount] = _referralAddress;\r\n            referralAccountCount++;\r\n        }\r\n        referralAmount[_referralAddress] += _value;\r\n    }\r\n\r\n    //  SUPPLY GENERATION (EXTERNAL FUNCTION)  //\r\n    //  -------------------------------------  //\r\n\r\n    /** @notice Allows to generate supply for past funded days\r\n      * @param _investmentDay investemnt day index (1-30)\r\n      */\r\n    function generateSupply(\r\n        uint64 _investmentDay\r\n    ) external investmentDaysRange(_investmentDay) onlyFundedDays(_investmentDay) {\r\n        require(\r\n            _investmentDay \u003c _currentSwappDay(),\r\n            \u0027SWAPP: investment day must be in past\u0027\r\n        );\r\n\r\n        require(\r\n            g.generationDayBuffer == 0,\r\n            \u0027SWAPP: supply generation in progress\u0027\r\n        );\r\n\r\n        require(\r\n            dailyTotalSupply[_investmentDay] == 0,\r\n            \u0027SWAPP: supply already generated\u0027\r\n        );\r\n\r\n        g.generationDayBuffer = _investmentDay;\r\n        g.generationTimeout = uint64(block.timestamp.add(2 hours));\r\n\r\n        dailyMinSupply[_investmentDay] == 1\r\n            ? _generateRandomSupply(_investmentDay)\r\n            : _generateStaticSupply(_investmentDay);\r\n    }\r\n\r\n    //  SUPPLY GENERATION (INTERNAL FUNCTIONS)  //\r\n    //  --------------------------------------  //\r\n\r\n    /** @notice Generates supply for days with static supply\r\n      * @param _investmentDay investemnt day index (1-30)\r\n      */\r\n    function _generateStaticSupply(\r\n        uint256 _investmentDay\r\n    ) internal {\r\n        dailyTotalSupply[_investmentDay] = dailyMinSupply[_investmentDay] * TESLAS_PER_SWAPP;\r\n        g.totalTransferTokens += dailyTotalSupply[_investmentDay];\r\n\r\n        g.generatedDays++;\r\n        g.generationDayBuffer = 0;\r\n        g.generationTimeout = 0;\r\n\r\n        emit GeneratedSupply(\r\n            _investmentDay,\r\n            dailyTotalSupply[_investmentDay]\r\n        );\r\n    }\r\n\r\n    /** @notice Generates supply for days with random supply\r\n      * @dev uses provable api to request provable_newRandomDSQuery\r\n      * @param _investmentDay investemnt day index (1-30)\r\n      */\r\n    function _generateRandomSupply(\r\n        uint256 _investmentDay\r\n    ) internal {\r\n        uint256 QUERY_EXECUTION_DELAY = 0;\r\n        uint256 GAS_FOR_CALLBACK = 200000;\r\n        provable_newRandomDSQuery(\r\n            QUERY_EXECUTION_DELAY,\r\n            NUM_RANDOM_BYTES_REQUESTED,\r\n            GAS_FOR_CALLBACK\r\n        );\r\n\r\n        emit LogNewProvableQuery(\"Provable query was sent, standing by for the answer...\");\r\n    }\r\n\r\n    //  SUPPLY GENERATION (ORACLE FUNCTIONS)  //\r\n    //  ------------------------------------  //\r\n\r\n    /** @notice Function that generates random supply\r\n      * @dev expected to be called by oracle within 2 hours\r\n      * time-frame, otherwise __timeout() can be performed\r\n      */\r\n    function __callback(\r\n        bytes32 _queryId,\r\n        string memory _result,\r\n        bytes memory _proof\r\n    ) public override {\r\n        require(\r\n            msg.sender == provable_cbAddress(),\r\n            \u0027SWAPP: can only be called by Oracle\u0027\r\n        );\r\n\r\n        require(\r\n            g.generationDayBuffer \u003e 0 \u0026\u0026\r\n            g.generationDayBuffer \u003c= INVESTMENT_DAYS,\r\n            \u0027SWAPP: incorrect generation day\u0027\r\n        );\r\n\r\n        if (\r\n            provable_randomDS_proofVerify__returnCode(\r\n                _queryId,\r\n                _result,\r\n                _proof\r\n            ) != 0\r\n        ) {\r\n            g.generationDayBuffer = 0;\r\n            g.generationTimeout = 0;\r\n\r\n            emit GenerationStatus(\r\n                g.generationDayBuffer, false\r\n            );\r\n        } else {\r\n            g.generatedDays = g.generatedDays + 1;\r\n            uint256 _investmentDay = g.generationDayBuffer;\r\n\r\n            uint256 currentDayMaxSupply = DAILY_MAX_SUPPLY.sub(dailyMinSupply[_investmentDay]);\r\n            uint256 ceilingDayMaxSupply = currentDayMaxSupply.sub(dailyMinSupply[_investmentDay]);\r\n\r\n            uint256 randomSupply = uint256(\r\n                keccak256(\r\n                    abi.encodePacked(_result)\r\n                )\r\n            ) % ceilingDayMaxSupply;\r\n\r\n            require(\r\n                dailyTotalSupply[_investmentDay] == 0,\r\n                \u0027SWAPP: supply already generated!\u0027\r\n            );\r\n\r\n            dailyTotalSupply[_investmentDay] = dailyMinSupply[_investmentDay]\r\n                .add(randomSupply)\r\n                .mul(TESLAS_PER_SWAPP);\r\n\r\n            g.totalTransferTokens = g.totalTransferTokens\r\n                .add(dailyTotalSupply[_investmentDay]);\r\n\r\n            emit GeneratedSupply(\r\n                _investmentDay,\r\n                dailyTotalSupply[_investmentDay]\r\n            );\r\n\r\n            emit GenerationStatus(\r\n                g.generationDayBuffer, true\r\n            );\r\n\r\n            g.generationDayBuffer = 0;\r\n            g.generationTimeout = 0;\r\n        }\r\n    }\r\n\r\n    /** @notice Allows to reset expected oracle callback\r\n      * @dev resets generationDayBuffer to retry callback\r\n      * assigns static supply if no callback within a day\r\n      */\r\n    function __timeout() external {\r\n        require(\r\n            g.generationTimeout \u003e 0 \u0026\u0026\r\n            g.generationTimeout \u003c block.timestamp,\r\n            \u0027SWAPP: still awaiting!\u0027\r\n        );\r\n\r\n        uint64 _investmentDay = g.generationDayBuffer;\r\n\r\n        require(\r\n            _investmentDay \u003e 0 \u0026\u0026\r\n            _investmentDay \u003c= INVESTMENT_DAYS,\r\n            \u0027SWAPP: incorrect generation day\u0027\r\n        );\r\n\r\n        require(\r\n            dailyTotalSupply[_investmentDay] == 0,\r\n            \u0027SWAPP: supply already generated!\u0027\r\n        );\r\n\r\n        if (_currentSwappDay() - _investmentDay \u003e 1) {\r\n\r\n            dailyTotalSupply[_investmentDay] = dailyMinSupply[1]\r\n                .mul(TESLAS_PER_SWAPP);\r\n\r\n            g.totalTransferTokens = g.totalTransferTokens\r\n                .add(dailyTotalSupply[_investmentDay]);\r\n\r\n            g.generatedDays = g.generatedDays + 1;\r\n\r\n            emit GeneratedSupply(\r\n                _investmentDay,\r\n                dailyTotalSupply[_investmentDay]\r\n            );\r\n\r\n            emit GenerationStatus(\r\n                _investmentDay, true\r\n            );\r\n\r\n        } else {\r\n            emit GenerationStatus(\r\n                _investmentDay, false\r\n            );\r\n        }\r\n        g.generationDayBuffer = 0;\r\n        g.generationTimeout = 0;\r\n    }\r\n\r\n    //  PRE-LIQUIDITY GENERATION FUNCTION  //\r\n    //  ---------------------------------  //\r\n\r\n    /** @notice Pre-calculates amount of tokens each referrer will get\r\n      * @dev must run this for all referrer addresses in batches\r\n      * converts _referralAmount to _referralTokens based on dailyRatio\r\n      */\r\n    function prepareReferralBonuses(\r\n        uint256 _referralBatchFrom,\r\n        uint256 _referralBatchTo\r\n    ) external afterInvestmentPhase {\r\n        require(\r\n            _referralBatchFrom \u003c _referralBatchTo,\r\n            \u0027SWAPP: incorrect referral batch\u0027\r\n        );\r\n\r\n        require (\r\n            g.preparedReferrals \u003c referralAccountCount,\r\n            \u0027SWAPP: all referrals already prepared\u0027\r\n        );\r\n\r\n        uint256 _totalRatio = g.totalTransferTokens.div(g.totalWeiContributed);\r\n\r\n        for (uint256 i = _referralBatchFrom; i \u003c _referralBatchTo; i++) {\r\n            address _referralAddress = referralAccounts[i];\r\n            uint256 _referralAmount = referralAmount[_referralAddress];\r\n            if (referralAmount[_referralAddress] \u003e 0) {\r\n                referralAmount[_referralAddress] = 0;\r\n                if (_referralAmount \u003e= THRESHOLD_LIMIT_MIN) {\r\n                    if (_referralAmount \u003e= THRESHOLD_LIMIT_INFLUENCER) {\r\n                        _referralAmount \u003e= THRESHOLD_LIMIT_SUPPER\r\n                            ? _supperReferralBonus(_referralAddress, _referralAmount, _totalRatio)\r\n                            : _influencerReferralBonus(_referralAddress, _referralAmount, _totalRatio);\r\n                    } else {\r\n                        _familyReferralBonus(_referralAddress, _totalRatio);\r\n                    }\r\n                    g.totalReferralTokens = g.totalReferralTokens.add(\r\n                        referralTokens[_referralAddress]\r\n                    );\r\n                }\r\n                g.preparedReferrals++;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /** @notice performs token allocation for 12.5% of referral amount\r\n      * @dev after liquidity is formed referrer can withdraw this amount\r\n      * additionally this will give CM status to the referrer address\r\n      */\r\n    function _supperReferralBonus(address _referralAddress, uint256 _referralAmount, uint256 _ratio) internal {\r\n        referralTokens[_referralAddress] = _referralAmount.mul(_ratio).mul(1250).div(10000);\r\n        SWAPP_CONTRACT.giveStatus(_referralAddress);\r\n    }\r\n\r\n    /** @notice performs token allocation for 10% of referral amount\r\n      * @dev after liquidity is formed referrer can withdraw this amount\r\n      * additionally this will give CM status to the referrer address\r\n      */\r\n    function _influencerReferralBonus(address _referralAddress, uint256 _referralAmount, uint256 _ratio) internal {\r\n        referralTokens[_referralAddress] = _referralAmount.div(10).mul(_ratio);\r\n        SWAPP_CONTRACT.giveStatus(_referralAddress);\r\n    }\r\n\r\n    /** @notice performs token allocation for family bonus referrals\r\n      * @dev after liquidity is formed referrer can withdraw this amount\r\n      */\r\n    function _familyReferralBonus(address _referralAddress, uint256 _ratio) internal {\r\n        referralTokens[_referralAddress] = MIN_INVEST.mul(_ratio);\r\n    }\r\n\r\n    //  LIQUIDITY GENERATION FUNCTION  //\r\n    //  -----------------------------  //\r\n\r\n    /** @notice Creates initial liquidity on Uniswap by forwarding\r\n      * reserved tokens equivalent to ETH contributed to the contract\r\n      * @dev check addLiquidityETH documentation\r\n      */\r\n    function forwardLiquidity() external afterInvestmentPhase {\r\n        require(\r\n            g.generatedDays == fundedDays(),\r\n            \u0027SWAPP: must generate supply for all days\u0027\r\n        );\r\n\r\n        uint256 _balance = g.totalWeiContributed;\r\n        uint256 _buffer = g.totalTransferTokens + g.totalReferralTokens;\r\n\r\n        _balance = _balance.sub(\r\n            _teamContribution(\r\n                _balance.div(10)\r\n            )\r\n        );\r\n\r\n        _buffer = _buffer.mul(_balance).div(\r\n            g.totalWeiContributed\r\n        );\r\n\r\n        SWAPP_CONTRACT.mintSupply(\r\n            address(this), _buffer\r\n        );\r\n\r\n        SWAPP_CONTRACT.approve(\r\n            address(UNISWAP_ROUTER), _buffer\r\n        );\r\n\r\n        (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        ) = UNISWAP_ROUTER.addLiquidityETH{value: _balance}(\r\n            address(SWAPP_CONTRACT),\r\n            _buffer,\r\n            0,\r\n            0,\r\n            address(0x0),\r\n            block.timestamp.add(2 hours)\r\n        );\r\n\r\n        g.totalTransferTokens = 0;\r\n        g.totalReferralTokens = 0;\r\n        g.totalWeiContributed = 0;\r\n\r\n        emit UniSwapResult(\r\n            amountToken, amountETH, liquidity\r\n        );\r\n    }\r\n\r\n    //  SWAPP TOKEN PAYOUT FUNCTIONS (INDIVIDUAL)  //\r\n    //  ----------------------------------------  //\r\n\r\n    /** @notice Allows to mint all the tokens\r\n      * from investor and referrer perspectives\r\n      * @dev can be called after forwardLiquidity()\r\n      */\r\n    function getMyTokens() external afterUniswapTransfer {\r\n        payoutInvestorAddress(msg.sender);\r\n        payoutReferralAddress(msg.sender);\r\n    }\r\n\r\n    /** @notice Allows to mint tokens for specific investor address\r\n      * @dev aggregades investors tokens across all investment days\r\n      * and uses SWAPP_CONTRACT instance to mint all the SWAPP tokens\r\n      * @param _investorAddress requested investor calculation address\r\n      * @return _payout amount minted to the investors address\r\n      */\r\n    function payoutInvestorAddress(\r\n        address _investorAddress\r\n    ) public afterUniswapTransfer returns (uint256 _payout) {\r\n        for (uint8 i = 1; i \u003c= INVESTMENT_DAYS; i++) {\r\n            if (investorBalances[_investorAddress][i] \u003e 0) {\r\n                _payout += investorBalances[_investorAddress][i].mul(\r\n                    _calculateDailyRatio(i)\r\n                ).div(100E18);\r\n                investorBalances[_investorAddress][i] = 0;\r\n            }\r\n        }\r\n        if (_payout \u003e 0) {\r\n            SWAPP_CONTRACT.mintSupply(\r\n                _investorAddress,\r\n                _payout\r\n            );\r\n        }\r\n    }\r\n\r\n    /** @notice Allows to mint tokens for specific referrer address\r\n      * @dev must be pre-calculated in prepareReferralBonuses()\r\n      * @param _referralAddress referrer payout address\r\n      * @return _referralTokens amount minted to the referrer address\r\n      */\r\n    function payoutReferralAddress(\r\n        address _referralAddress\r\n    ) public afterUniswapTransfer returns (uint256 _referralTokens) {\r\n        _referralTokens = referralTokens[_referralAddress];\r\n        if (referralTokens[_referralAddress] \u003e 0) {\r\n            referralTokens[_referralAddress] = 0;\r\n            SWAPP_CONTRACT.mintSupply(\r\n                _referralAddress,\r\n                _referralTokens\r\n            );\r\n        }\r\n    }\r\n\r\n    //  SWAPP TOKEN PAYOUT FUNCTIONS (BATCHES)  //\r\n    //  -------------------------------------  //\r\n\r\n    /** @notice Allows to mint tokens for specific investment day\r\n      * recommended batch size is up to 50 addresses per call\r\n      * @param _investmentDay processing investment day\r\n      * @param _investorBatchFrom batch starting index\r\n      * @param _investorBatchTo bach finishing index\r\n      */\r\n    function payoutInvestmentDayBatch(\r\n        uint256 _investmentDay,\r\n        uint256 _investorBatchFrom,\r\n        uint256 _investorBatchTo\r\n    ) external afterUniswapTransfer onlyFundedDays(_investmentDay) {\r\n        require(\r\n            _investorBatchFrom \u003c _investorBatchTo,\r\n            \u0027SWAPP: incorrect investment batch\u0027\r\n        );\r\n\r\n        uint256 _dailyRatio = _calculateDailyRatio(_investmentDay);\r\n\r\n        for (uint256 i = _investorBatchFrom; i \u003c _investorBatchTo; i++) {\r\n            address _investor = investorAccounts[_investmentDay][i];\r\n            uint256 _balance = investorBalances[_investor][_investmentDay];\r\n            uint256 _payout = _balance.mul(_dailyRatio).div(100E18);\r\n\r\n            if (investorBalances[_investor][_investmentDay] \u003e 0) {\r\n                investorBalances[_investor][_investmentDay] = 0;\r\n                SWAPP_CONTRACT.mintSupply(\r\n                    _investor,\r\n                    _payout\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @notice Allows to mint tokens for referrers in batches\r\n      * @dev can be called right after forwardLiquidity()\r\n      * recommended batch size is up to 50 addresses per call\r\n      * @param _referralBatchFrom batch starting index\r\n      * @param _referralBatchTo bach finishing index\r\n      */\r\n    function payoutReferralBatch(\r\n        uint256 _referralBatchFrom,\r\n        uint256 _referralBatchTo\r\n    ) external afterUniswapTransfer {\r\n        require(\r\n            _referralBatchFrom \u003c _referralBatchTo,\r\n            \u0027SWAPP: incorrect referral batch\u0027\r\n        );\r\n\r\n        for (uint256 i = _referralBatchFrom; i \u003c _referralBatchTo; i++) {\r\n            address _referralAddress = referralAccounts[i];\r\n            uint256 _referralTokens = referralTokens[_referralAddress];\r\n            if (referralTokens[_referralAddress] \u003e 0) {\r\n                referralTokens[_referralAddress] = 0;\r\n                SWAPP_CONTRACT.mintSupply(\r\n                    _referralAddress,\r\n                    _referralTokens\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    //  INFO VIEW FUNCTIONS (PERSONAL)  //\r\n    //  ------------------------------  //\r\n\r\n    /** @notice checks for callers investment amount on each day (with bonus)\r\n      * @return _userAllDays total amount invested across all days (with bonus)\r\n      */\r\n    function userInvestmentAmountAllDays(address _investor) external view returns (uint256[31] memory _userAllDays) {\r\n        for (uint256 i = 1; i \u003c= INVESTMENT_DAYS; i++) {\r\n            _userAllDays[i] = investorBalances[_investor][i];\r\n        }\r\n    }\r\n\r\n    /** @notice checks for callers total investment amount (with bonus)\r\n      * @return total amount invested across all investment days (with bonus)\r\n      */\r\n    function userTotalInvestmentAmount(address _investor) external view returns (uint256) {\r\n        return investorTotalBalance[_investor];\r\n    }\r\n\r\n    //  INFO VIEW FUNCTIONS (GLOBAL)  //\r\n    //  ----------------------------  //\r\n\r\n    /** @notice checks for investors count on specific day\r\n      * @return investors count for specific day\r\n      */\r\n    function investorsOnDay(uint256 _investmentDay) public view returns (uint256) {\r\n        return dailyTotalInvestment[_investmentDay] \u003e 0 ? investorAccountCount[_investmentDay] : 0;\r\n    }\r\n\r\n    /** @notice checks for investors count on each day\r\n      * @return _allInvestors array with investors count for each day\r\n      */\r\n    function investorsOnAllDays() external view returns (uint256[31] memory _allInvestors) {\r\n        for (uint256 i = 1; i \u003c= INVESTMENT_DAYS; i++) {\r\n            _allInvestors[i] = investorsOnDay(i);\r\n        }\r\n    }\r\n\r\n    /** @notice checks for investment amount on each day\r\n      * @return _allInvestments array with investment amount for each day\r\n      */\r\n    function investmentsOnAllDays() external view returns (uint256[31] memory _allInvestments) {\r\n        for (uint256 i = 1; i \u003c= INVESTMENT_DAYS; i++) {\r\n            _allInvestments[i] = dailyTotalInvestment[i];\r\n        }\r\n    }\r\n\r\n    /** @notice checks for supply amount on each day\r\n      * @return _allSupply array with supply amount for each day\r\n      */\r\n    function supplyOnAllDays() external view returns (uint256[31] memory _allSupply) {\r\n        for (uint256 i = 1; i \u003c= INVESTMENT_DAYS; i++) {\r\n            _allSupply[i] = dailyTotalSupply[i];\r\n        }\r\n    }\r\n\r\n    //  HELPER FUNCTIONS (PURE)  //\r\n    //  -----------------------  //\r\n\r\n    /** @notice checks that provided days are valid for investemnt\r\n      * @dev used in reserveSwapp() and reserveSwappWithToken()\r\n      */\r\n    function checkInvestmentDays(\r\n        uint8[] memory _investmentDays,\r\n        uint64 _swappDay\r\n    ) internal pure {\r\n        for (uint8 _i = 0; _i \u003c _investmentDays.length; _i++) {\r\n            require(\r\n                _investmentDays[_i] \u003e= _swappDay,\r\n                \u0027SWAPP: investment day already passed\u0027\r\n            );\r\n            require(\r\n                _investmentDays[_i] \u003e 0 \u0026\u0026\r\n                _investmentDays[_i] \u003c= INVESTMENT_DAYS,\r\n                \u0027SWAPP: incorrect investment day\u0027\r\n            );\r\n        }\r\n    }\r\n\r\n    /** @notice prepares path variable for uniswap to exchange tokens\r\n      * @dev used in reserveSwappWithToken() swapExactTokensForETH call\r\n      * @param _tokenAddress ERC20 token address to be swapped for ETH\r\n      * @return _path that is used to swap tokens for ETH on uniswap\r\n      */\r\n    function preparePath(\r\n        address _tokenAddress\r\n    ) internal pure returns (address[] memory _path) {\r\n        _path = new address[](2);\r\n        _path[0] = _tokenAddress;\r\n        _path[1] = WETH;\r\n    }\r\n\r\n    /** @notice keeps team contribution at caped level\r\n      * @dev subtracts amount during forwardLiquidity()\r\n      * @return ETH amount the team is allowed to withdraw\r\n      */\r\n    function _teamContribution(\r\n        uint256 _teamAmount\r\n    ) internal pure returns (uint256) {\r\n        return _teamAmount \u003e TEAM_ETHER_MAX ? TEAM_ETHER_MAX : _teamAmount;\r\n    }\r\n\r\n    /** @notice checks for invesments on all days\r\n      * @dev used in forwardLiquidity() requirements\r\n      * @return $fundedDays - amount of funded days 0-30\r\n      */\r\n    function fundedDays() public view returns (uint8 $fundedDays) {\r\n        for (uint8 i = 1; i \u003c= INVESTMENT_DAYS; i++) {\r\n            if (dailyTotalInvestment[i] \u003e 0) $fundedDays++;\r\n        }\r\n    }\r\n\r\n    /** @notice SWAPP equivalent in ETH price calculation\r\n      * @dev returned value has 100E18 precision - divided later on\r\n      * @return token price for specific day based on total investement\r\n      */\r\n    function _calculateDailyRatio(\r\n        uint256 _investmentDay\r\n    ) internal view returns (uint256) {\r\n\r\n        uint256 dailyRatio = dailyTotalSupply[_investmentDay].mul(100E18)\r\n            .div(dailyTotalInvestment[_investmentDay]);\r\n\r\n        uint256 remainderCheck = dailyTotalSupply[_investmentDay].mul(100E18)\r\n            .mod(dailyTotalInvestment[_investmentDay]);\r\n\r\n        return remainderCheck == 0 ? dailyRatio : dailyRatio.add(1);\r\n    }\r\n\r\n    //  TIMING FUNCTIONS  //\r\n    //  ----------------  //\r\n\r\n    /** @notice shows current day of SwappToken\r\n      * @dev value is fetched from SWAPP_CONTRACT\r\n      * @return iteration day since SWAPP inception\r\n      */\r\n    function _currentSwappDay() public view returns (uint64) {\r\n        return SWAPP_CONTRACT.currentSwappDay();\r\n    }\r\n\r\n    //  EMERGENCY REFUND FUNCTIONS  //\r\n    //  --------------------------  //\r\n\r\n    /** @notice allows refunds if funds are stuck\r\n      * @param _investor address to be refunded\r\n      * @return _amount refunded to the investor\r\n      */\r\n    function requestRefund(\r\n        address payable _investor,\r\n        address payable _succesor\r\n    ) external returns (uint256 _amount) {\r\n        require(\r\n            g.totalWeiContributed \u003e 0  \u0026\u0026\r\n            originalInvestment[_investor] \u003e 0 \u0026\u0026\r\n            _currentSwappDay() \u003e INVESTMENT_DAYS + 10,\r\n           unicode\u0027SWAPP: liquidity successfully forwarded to uniswap\u0027\r\n        );\r\n\r\n        // refunds the investor\r\n        _amount = originalInvestment[_investor];\r\n        originalInvestment[_investor] = 0;\r\n        _succesor.transfer(_amount);\r\n\r\n        // deny possible comeback\r\n        g.totalTransferTokens = 0;\r\n    }\r\n\r\n    /** @notice allows to withdraw team funds for the work\r\n      * strictly only after the uniswap liquidity is formed\r\n      * @param _amount value to withdraw from the contract\r\n      */\r\n    function requestTeamFunds(\r\n        uint256 _amount\r\n    ) external {\r\n        TEAM_ADDRESS.transfer(_amount);\r\n    }\r\n\r\n    function notContract(address _addr) internal view returns (bool) {\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return (size == 0);\r\n    }\r\n\r\n}\r\n"},"provableAPI_0.6.sol":{"content":"// SPDX-License-Identifier: --ðŸ¦‰--\r\n\r\npragma solidity =0.7.6;\r\n\r\ninterface ProvableI {\r\n\r\n    function cbAddress() external returns (address _cbAddress);\r\n    function setProofType(byte _proofType) external;\r\n    function setCustomGasPrice(uint _gasPrice) external;\r\n    function getPrice(string calldata _datasource) external returns (uint _dsprice);\r\n    function randomDS_getSessionPubKeyHash() external view returns (bytes32 _sessionKeyHash);\r\n    function getPrice(string calldata _datasource, uint _gasLimit)  external returns (uint _dsprice);\r\n    function queryN(uint _timestamp, string calldata _datasource, bytes calldata _argN) external payable returns (bytes32 _id);\r\n    function query(uint _timestamp, string calldata _datasource, string calldata _arg) external payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string calldata _datasource, string calldata _arg1, string calldata _arg2) external payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string calldata _datasource, string calldata _arg, uint _gasLimit) external payable returns (bytes32 _id);\r\n    function queryN_withGasLimit(uint _timestamp, string calldata _datasource, bytes calldata _argN, uint _gasLimit) external payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string calldata _datasource, string calldata _arg1, string calldata _arg2, uint _gasLimit) external payable returns (bytes32 _id);\r\n}\r\n\r\ninterface OracleAddrResolverI {\r\n    function getAddress() external returns (address _address);\r\n}\r\n\r\nlibrary Buffer {\r\n\r\n    struct buffer {\r\n        bytes buf;\r\n        uint capacity;\r\n    }\r\n\r\n    function init(buffer memory _buf, uint _capacity) internal pure {\r\n        uint capacity = _capacity;\r\n        if (capacity % 32 != 0) {\r\n            capacity += 32 - (capacity % 32);\r\n        }\r\n        _buf.capacity = capacity; // Allocate space for the buffer data\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(_buf, ptr)\r\n            mstore(ptr, 0)\r\n            mstore(0x40, add(ptr, capacity))\r\n        }\r\n    }\r\n\r\n    function resize(buffer memory _buf, uint _capacity) private pure {\r\n        bytes memory oldbuf = _buf.buf;\r\n        init(_buf, _capacity);\r\n        append(_buf, oldbuf);\r\n    }\r\n\r\n    function max(uint _a, uint _b) private pure returns (uint _max) {\r\n        if (_a \u003e _b) {\r\n            return _a;\r\n        }\r\n        return _b;\r\n    }\r\n    /**\r\n      * @dev Appends a byte array to the end of the buffer. Resizes if doing so\r\n      *      would exceed the capacity of the buffer.\r\n      * @param _buf The buffer to append to.\r\n      * @param _data The data to append.\r\n      * @return _buffer The original buffer.\r\n      *\r\n      */\r\n    function append(buffer memory _buf, bytes memory _data) internal pure returns (buffer memory _buffer) {\r\n        if (_data.length + _buf.buf.length \u003e _buf.capacity) {\r\n            resize(_buf, max(_buf.capacity, _data.length) * 2);\r\n        }\r\n        uint dest;\r\n        uint src;\r\n        uint len = _data.length;\r\n        assembly {\r\n            let bufptr := mload(_buf) // Memory address of the buffer data\r\n            let buflen := mload(bufptr) // Length of existing buffer data\r\n            dest := add(add(bufptr, buflen), 32) // Start address = buffer address + buffer length + sizeof(buffer length)\r\n            mstore(bufptr, add(buflen, mload(_data))) // Update buffer length\r\n            src := add(_data, 32)\r\n        }\r\n        for(; len \u003e= 32; len -= 32) { // Copy word-length chunks while possible\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n        uint mask = 256 ** (32 - len) - 1; // Copy remaining bytes\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n        return _buf;\r\n    }\r\n    /**\r\n      *\r\n      * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n      * exceed the capacity of the buffer.\r\n      * @param _buf The buffer to append to.\r\n      * @param _data The data to append.\r\n      *\r\n      */\r\n    function append(buffer memory _buf, uint8 _data) internal pure {\r\n        if (_buf.buf.length + 1 \u003e _buf.capacity) {\r\n            resize(_buf, _buf.capacity * 2);\r\n        }\r\n        assembly {\r\n            let bufptr := mload(_buf) // Memory address of the buffer data\r\n            let buflen := mload(bufptr) // Length of existing buffer data\r\n            let dest := add(add(bufptr, buflen), 32) // Address = buffer address + buffer length + sizeof(buffer length)\r\n            mstore8(dest, _data)\r\n            mstore(bufptr, add(buflen, 1)) // Update buffer length\r\n        }\r\n    }\r\n    /**\r\n      *\r\n      * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n      * exceed the capacity of the buffer.\r\n      * @param _buf The buffer to append to.\r\n      * @param _data The data to append.\r\n      * @return _buffer The original buffer.\r\n      *\r\n      */\r\n    function appendInt(buffer memory _buf, uint _data, uint _len) internal pure returns (buffer memory _buffer) {\r\n        if (_len + _buf.buf.length \u003e _buf.capacity) {\r\n            resize(_buf, max(_buf.capacity, _len) * 2);\r\n        }\r\n        uint mask = 256 ** _len - 1;\r\n        assembly {\r\n            let bufptr := mload(_buf) // Memory address of the buffer data\r\n            let buflen := mload(bufptr) // Length of existing buffer data\r\n            let dest := add(add(bufptr, buflen), _len) // Address = buffer address + buffer length + sizeof(buffer length) + len\r\n            mstore(dest, or(and(mload(dest), not(mask)), _data))\r\n            mstore(bufptr, add(buflen, _len)) // Update buffer length\r\n        }\r\n        return _buf;\r\n    }\r\n}\r\n\r\nlibrary CBOR {\r\n\r\n    using Buffer for Buffer.buffer;\r\n\r\n    uint8 private constant MAJOR_TYPE_INT = 0;\r\n    uint8 private constant MAJOR_TYPE_MAP = 5;\r\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\r\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\r\n    uint8 private constant MAJOR_TYPE_STRING = 3;\r\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\r\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\r\n\r\n    function encodeType(Buffer.buffer memory _buf, uint8 _major, uint _value) private pure {\r\n        if (_value \u003c= 23) {\r\n            _buf.append(uint8((_major \u003c\u003c 5) | _value));\r\n        } else if (_value \u003c= 0xFF) {\r\n            _buf.append(uint8((_major \u003c\u003c 5) | 24));\r\n            _buf.appendInt(_value, 1);\r\n        } else if (_value \u003c= 0xFFFF) {\r\n            _buf.append(uint8((_major \u003c\u003c 5) | 25));\r\n            _buf.appendInt(_value, 2);\r\n        } else if (_value \u003c= 0xFFFFFFFF) {\r\n            _buf.append(uint8((_major \u003c\u003c 5) | 26));\r\n            _buf.appendInt(_value, 4);\r\n        } else if (_value \u003c= 0xFFFFFFFFFFFFFFFF) {\r\n            _buf.append(uint8((_major \u003c\u003c 5) | 27));\r\n            _buf.appendInt(_value, 8);\r\n        }\r\n    }\r\n\r\n    function encodeIndefiniteLengthType(Buffer.buffer memory _buf, uint8 _major) private pure {\r\n        _buf.append(uint8((_major \u003c\u003c 5) | 31));\r\n    }\r\n\r\n    function encodeUInt(Buffer.buffer memory _buf, uint _value) internal pure {\r\n        encodeType(_buf, MAJOR_TYPE_INT, _value);\r\n    }\r\n\r\n    function encodeInt(Buffer.buffer memory _buf, int _value) internal pure {\r\n        if (_value \u003e= 0) {\r\n            encodeType(_buf, MAJOR_TYPE_INT, uint(_value));\r\n        } else {\r\n            encodeType(_buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - _value));\r\n        }\r\n    }\r\n\r\n    function encodeBytes(Buffer.buffer memory _buf, bytes memory _value) internal pure {\r\n        encodeType(_buf, MAJOR_TYPE_BYTES, _value.length);\r\n        _buf.append(_value);\r\n    }\r\n\r\n    function encodeString(Buffer.buffer memory _buf, string memory _value) internal pure {\r\n        encodeType(_buf, MAJOR_TYPE_STRING, bytes(_value).length);\r\n        _buf.append(bytes(_value));\r\n    }\r\n\r\n    function startArray(Buffer.buffer memory _buf) internal pure {\r\n        encodeIndefiniteLengthType(_buf, MAJOR_TYPE_ARRAY);\r\n    }\r\n\r\n    function startMap(Buffer.buffer memory _buf) internal pure {\r\n        encodeIndefiniteLengthType(_buf, MAJOR_TYPE_MAP);\r\n    }\r\n\r\n    function endSequence(Buffer.buffer memory _buf) internal pure {\r\n        encodeIndefiniteLengthType(_buf, MAJOR_TYPE_CONTENT_FREE);\r\n    }\r\n}\r\n/*\r\nEnd solidity-cborutils\r\n*/\r\ncontract usingProvable {\r\n\r\n    using CBOR for Buffer.buffer;\r\n\r\n    ProvableI provable;\r\n    OracleAddrResolverI OAR;\r\n\r\n    uint constant day = 60 * 60 * 24;\r\n    uint constant week = 60 * 60 * 24 * 7;\r\n    uint constant month = 60 * 60 * 24 * 30;\r\n\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_Ledger = 0x30;\r\n    byte constant proofType_Native = 0xF0;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    byte constant proofType_Android = 0x40;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n\r\n    string provable_network_name;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    mapping(bytes32 =\u003e bytes32) provable_randomDS_args;\r\n    mapping(bytes32 =\u003e bool) provable_randomDS_sessionKeysHashVerified;\r\n\r\n    modifier provableAPI {\r\n        if ((address(OAR) == address(0)) || (getCodeSize(address(OAR)) == 0)) {\r\n            provable_setNetwork(networkID_auto);\r\n        }\r\n        if (address(provable) != OAR.getAddress()) {\r\n            provable = ProvableI(OAR.getAddress());\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier provable_randomDS_proofVerify(bytes32 _queryId, string memory _result, bytes memory _proof) {\r\n        // RandomDS Proof Step 1: The prefix has to match \u0027LP\\x01\u0027 (Ledger Proof version 1)\r\n        require((_proof[0] == \"L\") \u0026\u0026 (_proof[1] == \"P\") \u0026\u0026 (uint8(_proof[2]) == uint8(1)));\r\n        bool proofVerified = provable_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), provable_getNetworkName());\r\n        require(proofVerified);\r\n        _;\r\n    }\r\n\r\n    function provable_setNetwork(uint8 _networkID) internal returns (bool _networkSet) {\r\n      _networkID; // NOTE: Silence the warning and remain backwards compatible\r\n      return provable_setNetwork();\r\n    }\r\n\r\n    function provable_setNetworkName(string memory _network_name) internal {\r\n        provable_network_name = _network_name;\r\n    }\r\n\r\n    function provable_getNetworkName() internal view returns (string memory _networkName) {\r\n        return provable_network_name;\r\n    }\r\n\r\n    function provable_setNetwork() internal returns (bool _networkSet) {\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed) \u003e 0) { //mainnet\r\n            OAR = OracleAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n            provable_setNetworkName(\"eth_mainnet\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1) \u003e 0) { //ropsten testnet\r\n            OAR = OracleAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n            provable_setNetworkName(\"eth_ropsten3\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e) \u003e 0) { //kovan testnet\r\n            OAR = OracleAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n            provable_setNetworkName(\"eth_kovan\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48) \u003e 0) { //rinkeby testnet\r\n            OAR = OracleAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n            provable_setNetworkName(\"eth_rinkeby\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xa2998EFD205FB9D4B4963aFb70778D6354ad3A41) \u003e 0) { //goerli testnet\r\n            OAR = OracleAddrResolverI(0xa2998EFD205FB9D4B4963aFb70778D6354ad3A41);\r\n            provable_setNetworkName(\"eth_goerli\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475) \u003e 0) { //ethereum-bridge\r\n            OAR = OracleAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF) \u003e 0) { //ether.camp ide\r\n            OAR = OracleAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA) \u003e 0) { //browser-solidity\r\n            OAR = OracleAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * @dev The following `__callback` functions are just placeholders ideally\r\n     *      meant to be defined in child contract when proofs are used.\r\n     *      The function bodies simply silence compiler warnings.\r\n     */\r\n    function __callback(bytes32 _myid, string memory _result) virtual public {\r\n        __callback(_myid, _result, new bytes(0));\r\n    }\r\n\r\n    function __callback(bytes32 _myid, string memory _result, bytes memory _proof) virtual public {\r\n      _myid; _result; _proof;\r\n      provable_randomDS_args[bytes32(0)] = bytes32(0);\r\n    }\r\n\r\n    function provable_getPrice(string memory _datasource) provableAPI internal returns (uint _queryPrice) {\r\n        return provable.getPrice(_datasource);\r\n    }\r\n\r\n    function provable_getPrice(string memory _datasource, uint _gasLimit) provableAPI internal returns (uint _queryPrice) {\r\n        return provable.getPrice(_datasource, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string memory _arg) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return provable.query{value: price}(0, _datasource, _arg);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string memory _arg) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return provable.query{value: price}(_timestamp, _datasource, _arg);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string memory _arg, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource,_gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return provable.query_withGasLimit{value: price}(_timestamp, _datasource, _arg, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string memory _arg, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n           return 0; // Unexpectedly high price\r\n        }\r\n        return provable.query_withGasLimit{value: price}(0, _datasource, _arg, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string memory _arg1, string memory _arg2) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return provable.query2{value: price}(0, _datasource, _arg1, _arg2);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string memory _arg1, string memory _arg2) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return provable.query2{value: price}(_timestamp, _datasource, _arg1, _arg2);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string memory _arg1, string memory _arg2, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return provable.query2_withGasLimit{value: price}(_timestamp, _datasource, _arg1, _arg2, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string memory _arg1, string memory _arg2, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return provable.query2_withGasLimit{value: price}(0, _datasource, _arg1, _arg2, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[] memory _argN) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(_argN);\r\n        return provable.queryN{value: price}(0, _datasource, args);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[] memory _argN) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(_argN);\r\n        return provable.queryN{value: price}(_timestamp, _datasource, args);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[] memory _argN, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(_argN);\r\n        return provable.queryN_withGasLimit{value: price}(_timestamp, _datasource, args, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[] memory _argN, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(_argN);\r\n        return provable.queryN_withGasLimit{value: price}(0, _datasource, args, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[1] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = _args[0];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[1] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = _args[0];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[1] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = _args[0];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[1] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = _args[0];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[2] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[2] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[2] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[2] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[3] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[3] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[3] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[3] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[4] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[4] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[4] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[4] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[5] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[5] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[5] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[5] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[] memory _argN) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(_argN);\r\n        return provable.queryN{value: price}(0, _datasource, args);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[] memory _argN) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(_argN);\r\n        return provable.queryN{value: price}(_timestamp, _datasource, args);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[] memory _argN, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(_argN);\r\n        return provable.queryN_withGasLimit{value: price}(_timestamp, _datasource, args, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[] memory _argN, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(_argN);\r\n        return provable.queryN_withGasLimit{value: price}(0, _datasource, args, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[1] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = _args[0];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[1] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = _args[0];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[1] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = _args[0];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[1] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = _args[0];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[2] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[2] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[2] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[2] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[3] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[3] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[3] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[3] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[4] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[4] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[4] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[4] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[5] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[5] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[5] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[5] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_setProof(byte _proofP) provableAPI internal {\r\n        return provable.setProofType(_proofP);\r\n    }\r\n\r\n\r\n    function provable_cbAddress() provableAPI internal returns (address _callbackAddress) {\r\n        return provable.cbAddress();\r\n    }\r\n\r\n    function getCodeSize(address _addr) view internal returns (uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n    function provable_setCustomGasPrice(uint _gasPrice) provableAPI internal {\r\n        return provable.setCustomGasPrice(_gasPrice);\r\n    }\r\n\r\n    function provable_randomDS_getSessionPubKeyHash() provableAPI internal returns (bytes32 _sessionKeyHash) {\r\n        return provable.randomDS_getSessionPubKeyHash();\r\n    }\r\n\r\n    function parseAddr(string memory _a) internal pure returns (address _parsedAddress) {\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i = 2; i \u003c 2 + 2 * 20; i += 2) {\r\n            iaddr *= 256;\r\n            b1 = uint160(uint8(tmp[i]));\r\n            b2 = uint160(uint8(tmp[i + 1]));\r\n            if ((b1 \u003e= 97) \u0026\u0026 (b1 \u003c= 102)) {\r\n                b1 -= 87;\r\n            } else if ((b1 \u003e= 65) \u0026\u0026 (b1 \u003c= 70)) {\r\n                b1 -= 55;\r\n            } else if ((b1 \u003e= 48) \u0026\u0026 (b1 \u003c= 57)) {\r\n                b1 -= 48;\r\n            }\r\n            if ((b2 \u003e= 97) \u0026\u0026 (b2 \u003c= 102)) {\r\n                b2 -= 87;\r\n            } else if ((b2 \u003e= 65) \u0026\u0026 (b2 \u003c= 70)) {\r\n                b2 -= 55;\r\n            } else if ((b2 \u003e= 48) \u0026\u0026 (b2 \u003c= 57)) {\r\n                b2 -= 48;\r\n            }\r\n            iaddr += (b1 * 16 + b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n    function strCompare(string memory _a, string memory _b) internal pure returns (int _returnCode) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length \u003c minLength) {\r\n            minLength = b.length;\r\n        }\r\n        for (uint i = 0; i \u003c minLength; i ++) {\r\n            if (a[i] \u003c b[i]) {\r\n                return -1;\r\n            } else if (a[i] \u003e b[i]) {\r\n                return 1;\r\n            }\r\n        }\r\n        if (a.length \u003c b.length) {\r\n            return -1;\r\n        } else if (a.length \u003e b.length) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function indexOf(string memory _haystack, string memory _needle) internal pure returns (int _returnCode) {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if (h.length \u003c 1 || n.length \u003c 1 || (n.length \u003e h.length)) {\r\n            return -1;\r\n        } else if (h.length \u003e (2 ** 128 - 1)) {\r\n            return -1;\r\n        } else {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i \u003c h.length; i++) {\r\n                if (h[i] == n[0]) {\r\n                    subindex = 1;\r\n                    while(subindex \u003c n.length \u0026\u0026 (i + subindex) \u003c h.length \u0026\u0026 h[i + subindex] == n[subindex]) {\r\n                        subindex++;\r\n                    }\r\n                    if (subindex == n.length) {\r\n                        return int(i);\r\n                    }\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory _concatenatedString) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        uint i = 0;\r\n        for (i = 0; i \u003c _ba.length; i++) {\r\n            babcde[k++] = _ba[i];\r\n        }\r\n        for (i = 0; i \u003c _bb.length; i++) {\r\n            babcde[k++] = _bb[i];\r\n        }\r\n        for (i = 0; i \u003c _bc.length; i++) {\r\n            babcde[k++] = _bc[i];\r\n        }\r\n        for (i = 0; i \u003c _bd.length; i++) {\r\n            babcde[k++] = _bd[i];\r\n        }\r\n        for (i = 0; i \u003c _be.length; i++) {\r\n            babcde[k++] = _be[i];\r\n        }\r\n        return string(babcde);\r\n    }\r\n\r\n    function safeParseInt(string memory _a) internal pure returns (uint _parsedInt) {\r\n        return safeParseInt(_a, 0);\r\n    }\r\n\r\n    function safeParseInt(string memory _a, uint _b) internal pure returns (uint _parsedInt) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i = 0; i \u003c bresult.length; i++) {\r\n            if ((uint(uint8(bresult[i])) \u003e= 48) \u0026\u0026 (uint(uint8(bresult[i])) \u003c= 57)) {\r\n                if (decimals) {\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(uint8(bresult[i])) - 48;\r\n            } else if (uint(uint8(bresult[i])) == 46) {\r\n                require(!decimals, \u0027More than one decimal encountered in string!\u0027);\r\n                decimals = true;\r\n            } else {\r\n                revert(\"Non-numeral character encountered in string!\");\r\n            }\r\n        }\r\n        if (_b \u003e 0) {\r\n            mint *= 10 ** _b;\r\n        }\r\n        return mint;\r\n    }\r\n\r\n    function parseInt(string memory _a) internal pure returns (uint _parsedInt) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    function parseInt(string memory _a, uint _b) internal pure returns (uint _parsedInt) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i = 0; i \u003c bresult.length; i++) {\r\n            if ((uint(uint8(bresult[i])) \u003e= 48) \u0026\u0026 (uint(uint8(bresult[i])) \u003c= 57)) {\r\n                if (decimals) {\r\n                   if (_b == 0) {\r\n                       break;\r\n                   } else {\r\n                       _b--;\r\n                   }\r\n                }\r\n                mint *= 10;\r\n                mint += uint(uint8(bresult[i])) - 48;\r\n            } else if (uint(uint8(bresult[i])) == 46) {\r\n                decimals = true;\r\n            }\r\n        }\r\n        if (_b \u003e 0) {\r\n            mint *= 10 ** _b;\r\n        }\r\n        return mint;\r\n    }\r\n\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function stra2cbor(string[] memory _arr) internal pure returns (bytes memory _cborEncoding) {\r\n        Buffer.buffer memory buf;\r\n        Buffer.init(buf, 1024);\r\n        buf.startArray();\r\n        for (uint i = 0; i \u003c _arr.length; i++) {\r\n            buf.encodeString(_arr[i]);\r\n        }\r\n        buf.endSequence();\r\n        return buf.buf;\r\n    }\r\n\r\n    function ba2cbor(bytes[] memory _arr) internal pure returns (bytes memory _cborEncoding) {\r\n        Buffer.buffer memory buf;\r\n        Buffer.init(buf, 1024);\r\n        buf.startArray();\r\n        for (uint i = 0; i \u003c _arr.length; i++) {\r\n            buf.encodeBytes(_arr[i]);\r\n        }\r\n        buf.endSequence();\r\n        return buf.buf;\r\n    }\r\n\r\n    function provable_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32 _queryId) {\r\n        require((_nbytes \u003e 0) \u0026\u0026 (_nbytes \u003c= 32));\r\n        _delay *= 10; // Convert from seconds to ledger timer ticks\r\n        bytes memory nbytes = new bytes(1);\r\n        nbytes[0] = byte(uint8(_nbytes));\r\n        bytes memory unonce = new bytes(32);\r\n        bytes memory sessionKeyHash = new bytes(32);\r\n        bytes32 sessionKeyHash_bytes32 = provable_randomDS_getSessionPubKeyHash();\r\n        assembly {\r\n            mstore(unonce, 0x20)\r\n            /*\r\n             The following variables can be relaxed.\r\n             Check the relaxed random contract at https://github.com/oraclize/ethereum-examples\r\n             for an idea on how to override and replace commit hash variables.\r\n            */\r\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number(), 1)), xor(coinbase(), timestamp())))\r\n            mstore(sessionKeyHash, 0x20)\r\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\r\n        }\r\n        bytes memory delay = new bytes(32);\r\n        assembly {\r\n            mstore(add(delay, 0x20), _delay)\r\n        }\r\n        bytes memory delay_bytes8 = new bytes(8);\r\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\r\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\r\n        bytes32 queryId = provable_query(\"random\", args, _customGasLimit);\r\n        bytes memory delay_bytes8_left = new bytes(8);\r\n        assembly {\r\n            let x := mload(add(delay_bytes8, 0x20))\r\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\r\n        }\r\n        provable_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\r\n        return queryId;\r\n    }\r\n\r\n    function provable_randomDS_setCommitment(bytes32 _queryId, bytes32 _commitment) internal {\r\n        provable_randomDS_args[_queryId] = _commitment;\r\n    }\r\n\r\n    function verifySig(bytes32 _tosignh, bytes memory _dersig, bytes memory _pubkey) internal returns (bool _sigVerified) {\r\n        bool sigok;\r\n        address signer;\r\n        bytes32 sigr;\r\n        bytes32 sigs;\r\n        bytes memory sigr_ = new bytes(32);\r\n        uint offset = 4 + (uint(uint8(_dersig[3])) - 0x20);\r\n        sigr_ = copyBytes(_dersig, offset, 32, sigr_, 0);\r\n        bytes memory sigs_ = new bytes(32);\r\n        offset += 32 + 2;\r\n        sigs_ = copyBytes(_dersig, offset + (uint(uint8(_dersig[offset - 1])) - 0x20), 32, sigs_, 0);\r\n        assembly {\r\n            sigr := mload(add(sigr_, 32))\r\n            sigs := mload(add(sigs_, 32))\r\n        }\r\n        (sigok, signer) = safer_ecrecover(_tosignh, 27, sigr, sigs);\r\n        if (address(uint160(uint256(keccak256(_pubkey)))) == signer) {\r\n            return true;\r\n        } else {\r\n            (sigok, signer) = safer_ecrecover(_tosignh, 28, sigr, sigs);\r\n            return (address(uint160(uint256(keccak256(_pubkey)))) == signer);\r\n        }\r\n    }\r\n\r\n    function provable_randomDS_proofVerify__sessionKeyValidity(bytes memory _proof, uint _sig2offset) internal returns (bool _proofVerified) {\r\n        bool sigok;\r\n        // Random DS Proof Step 6: Verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\r\n        bytes memory sig2 = new bytes(uint(uint8(_proof[_sig2offset + 1])) + 2);\r\n        copyBytes(_proof, _sig2offset, sig2.length, sig2, 0);\r\n        bytes memory appkey1_pubkey = new bytes(64);\r\n        copyBytes(_proof, 3 + 1, 64, appkey1_pubkey, 0);\r\n        bytes memory tosign2 = new bytes(1 + 65 + 32);\r\n        tosign2[0] = byte(uint8(1)); //role\r\n        copyBytes(_proof, _sig2offset - 65, 65, tosign2, 1);\r\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\r\n        copyBytes(CODEHASH, 0, 32, tosign2, 1 + 65);\r\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\r\n        if (!sigok) {\r\n            return false;\r\n        }\r\n        // Random DS Proof Step 7: Verify the APPKEY1 provenance (must be signed by Ledger)\r\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\r\n        bytes memory tosign3 = new bytes(1 + 65);\r\n        tosign3[0] = 0xFE;\r\n        copyBytes(_proof, 3, 65, tosign3, 1);\r\n        bytes memory sig3 = new bytes(uint(uint8(_proof[3 + 65 + 1])) + 2);\r\n        copyBytes(_proof, 3 + 65, sig3.length, sig3, 0);\r\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\r\n        return sigok;\r\n    }\r\n\r\n    function provable_randomDS_proofVerify__returnCode(bytes32 _queryId, string memory _result, bytes memory _proof) internal returns (uint8 _returnCode) {\r\n        // Random DS Proof Step 1: The prefix has to match \u0027LP\\x01\u0027 (Ledger Proof version 1)\r\n        if ((_proof[0] != \"L\") || (_proof[1] != \"P\") || (uint8(_proof[2]) != uint8(1))) {\r\n            return 1;\r\n        }\r\n        bool proofVerified = provable_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), provable_getNetworkName());\r\n        if (!proofVerified) {\r\n            return 2;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function matchBytes32Prefix(bytes32 _content, bytes memory _prefix, uint _nRandomBytes) internal pure returns (bool _matchesPrefix) {\r\n        bool match_ = true;\r\n        require(_prefix.length == _nRandomBytes);\r\n        for (uint256 i = 0; i\u003c _nRandomBytes; i++) {\r\n            if (_content[i] != _prefix[i]) {\r\n                match_ = false;\r\n            }\r\n        }\r\n        return match_;\r\n    }\r\n\r\n    function provable_randomDS_proofVerify__main(bytes memory _proof, bytes32 _queryId, bytes memory _result, string memory _contextName) internal returns (bool _proofVerified) {\r\n        // Random DS Proof Step 2: The unique keyhash has to match with the sha256 of (context name + _queryId)\r\n        uint ledgerProofLength = 3 + 65 + (uint(uint8(_proof[3 + 65 + 1])) + 2) + 32;\r\n        bytes memory keyhash = new bytes(32);\r\n        copyBytes(_proof, ledgerProofLength, 32, keyhash, 0);\r\n        if (!(keccak256(keyhash) == keccak256(abi.encodePacked(sha256(abi.encodePacked(_contextName, _queryId)))))) {\r\n            return false;\r\n        }\r\n        bytes memory sig1 = new bytes(uint(uint8(_proof[ledgerProofLength + (32 + 8 + 1 + 32) + 1])) + 2);\r\n        copyBytes(_proof, ledgerProofLength + (32 + 8 + 1 + 32), sig1.length, sig1, 0);\r\n        // Random DS Proof Step 3: We assume sig1 is valid (it will be verified during step 5) and we verify if \u0027_result\u0027 is the _prefix of sha256(sig1)\r\n        if (!matchBytes32Prefix(sha256(sig1), _result, uint(uint8(_proof[ledgerProofLength + 32 + 8])))) {\r\n            return false;\r\n        }\r\n        // Random DS Proof Step 4: Commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\r\n        // This is to verify that the computed args match with the ones specified in the query.\r\n        bytes memory commitmentSlice1 = new bytes(8 + 1 + 32);\r\n        copyBytes(_proof, ledgerProofLength + 32, 8 + 1 + 32, commitmentSlice1, 0);\r\n        bytes memory sessionPubkey = new bytes(64);\r\n        uint sig2offset = ledgerProofLength + 32 + (8 + 1 + 32) + sig1.length + 65;\r\n        copyBytes(_proof, sig2offset - 64, 64, sessionPubkey, 0);\r\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\r\n        if (provable_randomDS_args[_queryId] == keccak256(abi.encodePacked(commitmentSlice1, sessionPubkeyHash))) { //unonce, nbytes and sessionKeyHash match\r\n            delete provable_randomDS_args[_queryId];\r\n        } else return false;\r\n        // Random DS Proof Step 5: Validity verification for sig1 (keyhash and args signed with the sessionKey)\r\n        bytes memory tosign1 = new bytes(32 + 8 + 1 + 32);\r\n        copyBytes(_proof, ledgerProofLength, 32 + 8 + 1 + 32, tosign1, 0);\r\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) {\r\n            return false;\r\n        }\r\n        // Verify if sessionPubkeyHash was verified already, if not.. let\u0027s do it!\r\n        if (!provable_randomDS_sessionKeysHashVerified[sessionPubkeyHash]) {\r\n            provable_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = provable_randomDS_proofVerify__sessionKeyValidity(_proof, sig2offset);\r\n        }\r\n        return provable_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\r\n    }\r\n    /*\r\n     The following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    */\r\n    function copyBytes(bytes memory _from, uint _fromOffset, uint _length, bytes memory _to, uint _toOffset) internal pure returns (bytes memory _copiedBytes) {\r\n        uint minLength = _length + _toOffset;\r\n        require(_to.length \u003e= minLength); // Buffer too small. Should be a better way?\r\n        uint i = 32 + _fromOffset; // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\r\n        uint j = 32 + _toOffset;\r\n        while (i \u003c (32 + _fromOffset + _length)) {\r\n            assembly {\r\n                let tmp := mload(add(_from, i))\r\n                mstore(add(_to, j), tmp)\r\n            }\r\n            i += 32;\r\n            j += 32;\r\n        }\r\n        return _to;\r\n    }\r\n    /*\r\n     The following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n     Duplicate Solidity\u0027s ecrecover, but catching the CALL return value\r\n    */\r\n    function safer_ecrecover(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) internal returns (bool _success, address _recoveredAddress) {\r\n        /*\r\n         We do our own memory management here. Solidity uses memory offset\r\n         0x40 to store the current end of memory. We write past it (as\r\n         writes are memory extensions), but don\u0027t update the offset so\r\n         Solidity will reuse it. The memory used here is only needed for\r\n         this context.\r\n         FIXME: inline assembly can\u0027t access return values\r\n        */\r\n        bool ret;\r\n        address addr;\r\n        assembly {\r\n            let size := mload(0x40)\r\n            mstore(size, _hash)\r\n            mstore(add(size, 32), _v)\r\n            mstore(add(size, 64), _r)\r\n            mstore(add(size, 96), _s)\r\n            ret := call(3000, 1, 0, size, 128, size, 32) // NOTE: we can reuse the request memory because we deal with the return code.\r\n            addr := mload(size)\r\n        }\r\n        return (ret, addr);\r\n    }\r\n    /*\r\n     The following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    */\r\n    function ecrecovery(bytes32 _hash, bytes memory _sig) internal returns (bool _success, address _recoveredAddress) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        if (_sig.length != 65) {\r\n            return (false, address(0));\r\n        }\r\n        /*\r\n         The signature format is a compact form of:\r\n           {bytes32 r}{bytes32 s}{uint8 v}\r\n         Compact means, uint8 is not padded to 32 bytes.\r\n        */\r\n        assembly {\r\n            r := mload(add(_sig, 32))\r\n            s := mload(add(_sig, 64))\r\n            /*\r\n             Here we are loading the last 32 bytes. We exploit the fact that\r\n             \u0027mload\u0027 will pad with zeroes if we overread.\r\n             There is no \u0027mload8\u0027 to do this, but that would be nicer.\r\n            */\r\n            v := byte(0, mload(add(_sig, 96)))\r\n            /*\r\n              Alternative solution:\r\n              \u0027byte\u0027 is not working due to the Solidity parser, so lets\r\n              use the second best option, \u0027and\u0027\r\n              v := and(mload(add(_sig, 65)), 255)\r\n            */\r\n        }\r\n        /*\r\n         albeit non-transactional signatures are not specified by the YP, one would expect it\r\n         to match the YP range of [27, 28]\r\n         geth uses [0, 1] and some clients have followed. This might change, see:\r\n         https://github.com/ethereum/go-ethereum/issues/2053\r\n        */\r\n        if (v \u003c 27) {\r\n            v += 27;\r\n        }\r\n        if (v != 27 \u0026\u0026 v != 28) {\r\n            return (false, address(0));\r\n        }\r\n        return safer_ecrecover(_hash, v, r, s);\r\n    }\r\n}"}}