{{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n"
    },
    "contracts/TwapOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\nimport './interfaces/ITwapOracle.sol';\nimport './interfaces/IERC20.sol';\nimport './libraries/SafeMath.sol';\nimport '@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol';\n\ncontract TwapOracle is ITwapOracle {\n    using SafeMath for uint256;\n    using SafeMath for int256;\n    uint8 public immutable override xDecimals;\n    uint8 public immutable override yDecimals;\n    int256 public immutable override decimalsConverter;\n    address public override owner;\n    address public override uniswapPair;\n\n    constructor(uint8 _xDecimals, uint8 _yDecimals) {\n        require(_xDecimals <= 75 && _yDecimals <= 75, 'TO4F');\n        if (_yDecimals > _xDecimals) {\n            require(_yDecimals - _xDecimals <= 18, 'TO47');\n        } else {\n            require(_xDecimals - _yDecimals <= 18, 'TO47');\n        }\n        owner = msg.sender;\n        xDecimals = _xDecimals;\n        yDecimals = _yDecimals;\n        decimalsConverter = (10**(18 + _xDecimals - _yDecimals)).toInt256();\n\n        emit OwnerSet(msg.sender);\n    }\n\n    function isContract(address addr) private view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n\n    function setOwner(address _owner) external override {\n        require(msg.sender == owner, 'TO00');\n        require(_owner != address(0), 'TO02');\n        require(_owner != owner, 'TO01');\n        owner = _owner;\n        emit OwnerSet(_owner);\n    }\n\n    function setUniswapPair(address _uniswapPair) external override {\n        require(msg.sender == owner, 'TO00');\n        require(_uniswapPair != uniswapPair, 'TO01');\n        require(_uniswapPair != address(0), 'TO02');\n        require(isContract(_uniswapPair), 'TO0B');\n        uniswapPair = _uniswapPair;\n\n        IUniswapV2Pair pairContract = IUniswapV2Pair(_uniswapPair);\n        require(\n            IERC20(pairContract.token0()).decimals() == xDecimals &&\n                IERC20(pairContract.token1()).decimals() == yDecimals,\n            'TO45'\n        );\n\n        (uint112 reserve0, uint112 reserve1, ) = pairContract.getReserves();\n        require(reserve0 != 0 && reserve1 != 0, 'TO1F');\n        emit UniswapPairSet(_uniswapPair);\n    }\n\n    // based on: https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol\n    function getPriceInfo() public view override returns (uint256 priceAccumulator, uint32 priceTimestamp) {\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapPair);\n        priceAccumulator = pair.price0CumulativeLast();\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = pair.getReserves();\n\n        // uint32 can be cast directly until Sun, 07 Feb 2106 06:28:15 GMT\n        priceTimestamp = uint32(block.timestamp);\n        if (blockTimestampLast != priceTimestamp) {\n            // allow overflow to stay consistent with Uniswap code and save some gas\n            uint32 timeElapsed = priceTimestamp - blockTimestampLast;\n            priceAccumulator += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n        }\n    }\n\n    function decodePriceInfo(bytes memory data) internal pure returns (uint256 price) {\n        assembly {\n            price := mload(add(data, 32))\n        }\n    }\n\n    function getSpotPrice() external view override returns (uint256) {\n        (uint112 reserve0, uint112 reserve1, ) = IUniswapV2Pair(uniswapPair).getReserves();\n        return uint256(reserve1).mul(uint256(decimalsConverter)).div(uint256(reserve0));\n    }\n\n    function getAveragePrice(uint256 priceAccumulator, uint32 priceTimestamp) public view override returns (uint256) {\n        (uint256 currentPriceAccumulator, uint32 currentPriceTimestamp) = getPriceInfo();\n\n        require(priceTimestamp < currentPriceTimestamp, 'TO20');\n\n        // timeElapsed = currentPriceTimestamp - priceTimestamp (overflow is desired)\n        // averagePrice = (currentPriceAccumulator - priceAccumulator) / timeElapsed\n        // return value = (averagePrice * decimalsConverter) / 2**112\n        return\n            ((currentPriceAccumulator - priceAccumulator) / (currentPriceTimestamp - priceTimestamp)).mul(\n                uint256(decimalsConverter)\n            ) >> 112;\n    }\n\n    function tradeX(\n        uint256 xAfter,\n        uint256 xBefore,\n        uint256 yBefore,\n        bytes calldata data\n    ) external view override returns (uint256 yAfter) {\n        int256 xAfterInt = xAfter.toInt256();\n        int256 xBeforeInt = xBefore.toInt256();\n        int256 yBeforeInt = yBefore.toInt256();\n        int256 averagePriceInt = decodePriceInfo(data).toInt256();\n\n        int256 yTradedInt = xAfterInt.sub(xBeforeInt).mul(averagePriceInt);\n\n        // yAfter = yBefore - yTraded = yBefore - ((xAfter - xBefore) * price)\n        // we are multiplying yBefore by decimalsConverter to push division to the very end\n        int256 yAfterInt = yBeforeInt.mul(decimalsConverter).sub(yTradedInt).div(decimalsConverter);\n        require(yAfterInt >= 0, 'TO27');\n        yAfter = uint256(yAfterInt);\n    }\n\n    function tradeY(\n        uint256 yAfter,\n        uint256 xBefore,\n        uint256 yBefore,\n        bytes calldata data\n    ) external view override returns (uint256 xAfter) {\n        int256 yAfterInt = yAfter.toInt256();\n        int256 xBeforeInt = xBefore.toInt256();\n        int256 yBeforeInt = yBefore.toInt256();\n        int256 averagePriceInt = decodePriceInfo(data).toInt256();\n\n        int256 xTradedInt = yAfterInt.sub(yBeforeInt).mul(decimalsConverter);\n\n        // xAfter = xBefore - xTraded = xBefore - ((yAfter - yBefore) * price)\n        // we are multiplying xBefore by averagePriceInt to push division to the very end\n        int256 xAfterInt = xBeforeInt.mul(averagePriceInt).sub(xTradedInt).div(averagePriceInt);\n        require(xAfterInt >= 0, 'TO28');\n\n        xAfter = uint256(xAfterInt);\n    }\n\n    function depositTradeXIn(\n        uint256 xLeft,\n        uint256 xBefore,\n        uint256 yBefore,\n        bytes calldata data\n    ) external view override returns (uint256) {\n        if (xBefore == 0 || yBefore == 0) {\n            return 0;\n        }\n\n        // ratio after swap = ratio after second mint\n        // (xBefore + xIn) / (yBefore - xIn * price) = (xBefore + xLeft) / yBefore\n        // xIn = xLeft * yBefore / (price * (xLeft + xBefore) + yBefore)\n        uint256 price = decodePriceInfo(data);\n        uint256 numerator = xLeft.mul(yBefore);\n        uint256 denominator = price.mul(xLeft.add(xBefore)).add(yBefore.mul(uint256(decimalsConverter)));\n        uint256 xIn = numerator.mul(uint256(decimalsConverter)).div(denominator);\n\n        // Don't swap when numbers are too large. This should actually never happen.\n        if (xIn.mul(price).div(uint256(decimalsConverter)) >= yBefore || xIn >= xLeft) {\n            return 0;\n        }\n\n        return xIn;\n    }\n\n    function depositTradeYIn(\n        uint256 yLeft,\n        uint256 xBefore,\n        uint256 yBefore,\n        bytes calldata data\n    ) external view override returns (uint256) {\n        if (xBefore == 0 || yBefore == 0) {\n            return 0;\n        }\n\n        // ratio after swap = ratio after second mint\n        // (xBefore - yIn / price) / (yBefore + yIn) = xBefore / (yBefore + yLeft)\n        // yIn = price * xBefore * yLeft / (price * xBefore + yLeft + yBefore)\n        uint256 price = decodePriceInfo(data);\n        uint256 numerator = price.mul(xBefore).mul(yLeft);\n        uint256 denominator = price.mul(xBefore).add(yLeft.add(yBefore).mul(uint256(decimalsConverter)));\n        uint256 yIn = numerator.div(denominator);\n\n        // Don't swap when numbers are too large. This should actually never happen.\n        if (yIn.mul(uint256(decimalsConverter)).div(price) >= xBefore || yIn >= yLeft) {\n            return 0;\n        }\n\n        return yIn;\n    }\n}\n"
    },
    "contracts/interfaces/ITwapOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\ninterface ITwapOracle {\n    event OwnerSet(address owner);\n    event UniswapPairSet(address uniswapPair);\n\n    function decimalsConverter() external view returns (int256);\n\n    function xDecimals() external view returns (uint8);\n\n    function yDecimals() external view returns (uint8);\n\n    function owner() external view returns (address);\n\n    function uniswapPair() external view returns (address);\n\n    function getPriceInfo() external view returns (uint256 priceAccumulator, uint32 priceTimestamp);\n\n    function getSpotPrice() external view returns (uint256);\n\n    function getAveragePrice(uint256 priceAccumulator, uint32 priceTimestamp) external view returns (uint256);\n\n    function setOwner(address _owner) external;\n\n    function setUniswapPair(address _uniswapPair) external;\n\n    function tradeX(\n        uint256 xAfter,\n        uint256 xBefore,\n        uint256 yBefore,\n        bytes calldata data\n    ) external view returns (uint256 yAfter);\n\n    function tradeY(\n        uint256 yAfter,\n        uint256 yBefore,\n        uint256 xBefore,\n        bytes calldata data\n    ) external view returns (uint256 xAfter);\n\n    function depositTradeXIn(\n        uint256 xLeft,\n        uint256 xBefore,\n        uint256 yBefore,\n        bytes calldata data\n    ) external view returns (uint256 xIn);\n\n    function depositTradeYIn(\n        uint256 yLeft,\n        uint256 yBefore,\n        uint256 xBefore,\n        bytes calldata data\n    ) external view returns (uint256 yIn);\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    int256 private constant _INT256_MIN = -2**255;\n\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, 'SM4E');\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = sub(x, y, 'SM12');\n    }\n\n    function sub(\n        uint256 x,\n        uint256 y,\n        string memory message\n    ) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, message);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, 'SM2A');\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, 'SM43');\n        uint256 c = a / b;\n        return c;\n    }\n\n    function ceil_div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = div(a, b);\n        if (c == mul(a, b)) {\n            return c;\n        } else {\n            return add(c, 1);\n        }\n    }\n\n    function toUint32(uint256 n) internal pure returns (uint32) {\n        require(n <= type(uint32).max, 'SM50');\n        return uint32(n);\n    }\n\n    function toUint112(uint256 n) internal pure returns (uint112) {\n        require(n <= type(uint112).max, 'SM51');\n        return uint112(n);\n    }\n\n    function toInt256(uint256 unsigned) internal pure returns (int256 signed) {\n        require(unsigned <= uint256(type(int256).max), 'SM34');\n        signed = int256(unsigned);\n    }\n\n    // int256\n\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), 'SM4D');\n\n        return c;\n    }\n\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), 'SM11');\n\n        return c;\n    }\n\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), 'SM29');\n\n        int256 c = a * b;\n        require(c / a == b, 'SM29');\n\n        return c;\n    }\n\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, 'SM43');\n        require(!(b == -1 && a == _INT256_MIN), 'SM42');\n\n        int256 c = a / b;\n\n        return c;\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/lib/contracts/libraries/FixedPoint.sol": {
      "content": "pragma solidity >=0.4.0;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n        uint z;\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n}\n"
    },
    "contracts/TwapDelay.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport './interfaces/ITwapPair.sol';\nimport './interfaces/ITwapDelay.sol';\nimport './interfaces/IWETH.sol';\nimport './libraries/SafeMath.sol';\nimport './libraries/Orders.sol';\nimport './libraries/TokenShares.sol';\nimport './libraries/AddLiquidity.sol';\nimport './libraries/WithdrawHelper.sol';\n\ncontract TwapDelay is ITwapDelay {\n    using SafeMath for uint256;\n    using Orders for Orders.Data;\n    using TokenShares for TokenShares.Data;\n    Orders.Data internal orders;\n    TokenShares.Data internal tokenShares;\n\n    uint256 private constant ORDER_CANCEL_TIME = 24 hours;\n    uint256 private constant BOT_EXECUTION_TIME = 20 minutes;\n    uint256 private constant ORDER_LIFESPAN = 48 hours;\n\n    address public override owner;\n    mapping(address => bool) public override isBot;\n\n    constructor(\n        address _factory,\n        address _weth,\n        address _bot\n    ) {\n        orders.factory = _factory;\n        owner = msg.sender;\n        isBot[_bot] = true;\n        orders.gasPrice = tx.gasprice - (tx.gasprice % 1e6);\n        tokenShares.setWeth(_weth);\n        orders.delay = 30 minutes;\n        orders.maxGasLimit = 5_000_000;\n        orders.gasPriceInertia = 20_000_000;\n        orders.maxGasPriceImpact = 1_000_000;\n        orders.setTransferGasCost(address(0), Orders.ETHER_TRANSFER_CALL_COST);\n\n        emit OwnerSet(msg.sender);\n    }\n\n    function getTransferGasCost(address token) external view override returns (uint256 gasCost) {\n        return orders.transferGasCosts[token];\n    }\n\n    function getDepositOrder(uint256 orderId) external view override returns (Orders.DepositOrder memory order) {\n        return orders.getDepositOrder(orderId);\n    }\n\n    function getWithdrawOrder(uint256 orderId) external view override returns (Orders.WithdrawOrder memory order) {\n        return orders.getWithdrawOrder(orderId);\n    }\n\n    function getSellOrder(uint256 orderId) external view override returns (Orders.SellOrder memory order) {\n        return orders.getSellOrder(orderId);\n    }\n\n    function getBuyOrder(uint256 orderId) external view override returns (Orders.BuyOrder memory order) {\n        return orders.getBuyOrder(orderId);\n    }\n\n    function getDepositDisabled(address pair) external view override returns (bool) {\n        return orders.getDepositDisabled(pair);\n    }\n\n    function getWithdrawDisabled(address pair) external view override returns (bool) {\n        return orders.getWithdrawDisabled(pair);\n    }\n\n    function getBuyDisabled(address pair) external view override returns (bool) {\n        return orders.getBuyDisabled(pair);\n    }\n\n    function getSellDisabled(address pair) external view override returns (bool) {\n        return orders.getSellDisabled(pair);\n    }\n\n    function getOrderStatus(uint256 orderId) external view override returns (Orders.OrderStatus) {\n        return orders.getOrderStatus(orderId);\n    }\n\n    uint256 private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, 'TD06');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function factory() external view override returns (address) {\n        return orders.factory;\n    }\n\n    function totalShares(address token) external view override returns (uint256) {\n        return tokenShares.totalShares[token];\n    }\n\n    function weth() external view override returns (address) {\n        return tokenShares.weth;\n    }\n\n    function delay() external view override returns (uint32) {\n        return orders.delay;\n    }\n\n    function lastProcessedOrderId() external view returns (uint256) {\n        return orders.lastProcessedOrderId;\n    }\n\n    function newestOrderId() external view returns (uint256) {\n        return orders.newestOrderId;\n    }\n\n    function getOrder(uint256 orderId) external view returns (Orders.OrderType orderType, uint32 validAfterTimestamp) {\n        return orders.getOrder(orderId);\n    }\n\n    function isOrderCanceled(uint256 orderId) external view returns (bool) {\n        return orders.canceled[orderId];\n    }\n\n    function maxGasLimit() external view override returns (uint256) {\n        return orders.maxGasLimit;\n    }\n\n    function maxGasPriceImpact() external view override returns (uint256) {\n        return orders.maxGasPriceImpact;\n    }\n\n    function gasPriceInertia() external view override returns (uint256) {\n        return orders.gasPriceInertia;\n    }\n\n    function gasPrice() external view override returns (uint256) {\n        return orders.gasPrice;\n    }\n\n    function setOrderDisabled(\n        address pair,\n        Orders.OrderType orderType,\n        bool disabled\n    ) external override {\n        require(msg.sender == owner, 'TD00');\n        orders.setOrderDisabled(pair, orderType, disabled);\n    }\n\n    function setOwner(address _owner) external override {\n        require(msg.sender == owner, 'TD00');\n        require(_owner != owner, 'TD01');\n        require(_owner != address(0), 'TD02');\n        owner = _owner;\n        emit OwnerSet(_owner);\n    }\n\n    function setBot(address _bot, bool _isBot) external override {\n        require(msg.sender == owner, 'TD00');\n        require(_isBot != isBot[_bot], 'TD01');\n        isBot[_bot] = _isBot;\n        emit BotSet(_bot, _isBot);\n    }\n\n    function setMaxGasLimit(uint256 _maxGasLimit) external override {\n        require(msg.sender == owner, 'TD00');\n        orders.setMaxGasLimit(_maxGasLimit);\n    }\n\n    function setDelay(uint32 _delay) external override {\n        require(msg.sender == owner, 'TD00');\n        require(_delay != orders.delay, 'TD01');\n        orders.delay = _delay;\n        emit DelaySet(_delay);\n    }\n\n    function setGasPriceInertia(uint256 _gasPriceInertia) external override {\n        require(msg.sender == owner, 'TD00');\n        orders.setGasPriceInertia(_gasPriceInertia);\n    }\n\n    function setMaxGasPriceImpact(uint256 _maxGasPriceImpact) external override {\n        require(msg.sender == owner, 'TD00');\n        orders.setMaxGasPriceImpact(_maxGasPriceImpact);\n    }\n\n    function setTransferGasCost(address token, uint256 gasCost) external override {\n        require(msg.sender == owner, 'TD00');\n        orders.setTransferGasCost(token, gasCost);\n    }\n\n    function deposit(Orders.DepositParams calldata depositParams)\n        external\n        payable\n        override\n        lock\n        returns (uint256 orderId)\n    {\n        orders.deposit(depositParams, tokenShares);\n        return orders.newestOrderId;\n    }\n\n    function withdraw(Orders.WithdrawParams calldata withdrawParams)\n        external\n        payable\n        override\n        lock\n        returns (uint256 orderId)\n    {\n        orders.withdraw(withdrawParams);\n        return orders.newestOrderId;\n    }\n\n    function sell(Orders.SellParams calldata sellParams) external payable override lock returns (uint256 orderId) {\n        orders.sell(sellParams, tokenShares);\n        return orders.newestOrderId;\n    }\n\n    function buy(Orders.BuyParams calldata buyParams) external payable override lock returns (uint256 orderId) {\n        orders.buy(buyParams, tokenShares);\n        return orders.newestOrderId;\n    }\n\n    function execute(uint256 n) external override lock {\n        emit Execute(msg.sender, n);\n        uint256 gasBefore = gasleft();\n        bool orderExecuted = false;\n        bool senderCanExecute = isBot[msg.sender] || isBot[address(0)];\n        for (uint256 i = 0; i < n; i++) {\n            if (orders.canceled[orders.lastProcessedOrderId + 1]) {\n                orders.dequeueCanceledOrder();\n                continue;\n            }\n            (Orders.OrderType orderType, uint256 validAfterTimestamp) = orders.getNextOrder();\n            if (orderType == Orders.OrderType.Empty || validAfterTimestamp >= block.timestamp) {\n                break;\n            }\n            require(senderCanExecute || block.timestamp >= validAfterTimestamp + BOT_EXECUTION_TIME, 'TD00');\n            orderExecuted = true;\n            if (orderType == Orders.OrderType.Deposit) {\n                executeDeposit();\n            } else if (orderType == Orders.OrderType.Withdraw) {\n                executeWithdraw();\n            } else if (orderType == Orders.OrderType.Sell) {\n                executeSell();\n            } else if (orderType == Orders.OrderType.Buy) {\n                executeBuy();\n            }\n        }\n        if (orderExecuted) {\n            orders.updateGasPrice(gasBefore.sub(gasleft()));\n        }\n    }\n\n    function executeDeposit() internal {\n        uint256 gasStart = gasleft();\n        Orders.DepositOrder memory depositOrder = orders.dequeueDepositOrder();\n        (, address token0, address token1) = orders.getPairInfo(depositOrder.pairId);\n        (bool executionSuccess, bytes memory data) = address(this).call{\n            gas: depositOrder.gasLimit.sub(\n                Orders.ORDER_BASE_COST.add(orders.transferGasCosts[token0]).add(orders.transferGasCosts[token1])\n            )\n        }(abi.encodeWithSelector(this._executeDeposit.selector, depositOrder));\n        bool refundSuccess = true;\n        if (!executionSuccess) {\n            refundSuccess = refundTokens(\n                depositOrder.to,\n                token0,\n                depositOrder.share0,\n                token1,\n                depositOrder.share1,\n                depositOrder.unwrap\n            );\n        }\n        finalizeOrder(refundSuccess);\n        (uint256 gasUsed, uint256 ethRefund) = refund(\n            depositOrder.gasLimit,\n            depositOrder.gasPrice,\n            gasStart,\n            depositOrder.to\n        );\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\n    }\n\n    function executeWithdraw() internal {\n        uint256 gasStart = gasleft();\n        Orders.WithdrawOrder memory withdrawOrder = orders.dequeueWithdrawOrder();\n        (bool executionSuccess, bytes memory data) = address(this).call{\n            gas: withdrawOrder.gasLimit.sub(Orders.ORDER_BASE_COST.add(Orders.PAIR_TRANSFER_COST))\n        }(abi.encodeWithSelector(this._executeWithdraw.selector, withdrawOrder));\n        bool refundSuccess = true;\n        if (!executionSuccess) {\n            (address pair, , ) = orders.getPairInfo(withdrawOrder.pairId);\n            refundSuccess = refundLiquidity(pair, withdrawOrder.to, withdrawOrder.liquidity);\n        }\n        finalizeOrder(refundSuccess);\n        (uint256 gasUsed, uint256 ethRefund) = refund(\n            withdrawOrder.gasLimit,\n            withdrawOrder.gasPrice,\n            gasStart,\n            withdrawOrder.to\n        );\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\n    }\n\n    function executeSell() internal {\n        uint256 gasStart = gasleft();\n        Orders.SellOrder memory sellOrder = orders.dequeueSellOrder();\n        (, address token0, address token1) = orders.getPairInfo(sellOrder.pairId);\n        (bool executionSuccess, bytes memory data) = address(this).call{\n            gas: sellOrder.gasLimit.sub(\n                Orders.ORDER_BASE_COST.add(orders.transferGasCosts[sellOrder.inverse ? token1 : token0])\n            )\n        }(abi.encodeWithSelector(this._executeSell.selector, sellOrder));\n        bool refundSuccess = true;\n        if (!executionSuccess) {\n            refundSuccess = refundToken(\n                sellOrder.inverse ? token1 : token0,\n                sellOrder.to,\n                sellOrder.shareIn,\n                sellOrder.unwrap\n            );\n        }\n        finalizeOrder(refundSuccess);\n        (uint256 gasUsed, uint256 ethRefund) = refund(sellOrder.gasLimit, sellOrder.gasPrice, gasStart, sellOrder.to);\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\n    }\n\n    function executeBuy() internal {\n        uint256 gasStart = gasleft();\n        Orders.BuyOrder memory buyOrder = orders.dequeueBuyOrder();\n        (, address token0, address token1) = orders.getPairInfo(buyOrder.pairId);\n        (bool executionSuccess, bytes memory data) = address(this).call{\n            gas: buyOrder.gasLimit.sub(\n                Orders.ORDER_BASE_COST.add(orders.transferGasCosts[buyOrder.inverse ? token1 : token0])\n            )\n        }(abi.encodeWithSelector(this._executeBuy.selector, buyOrder));\n        bool refundSuccess = true;\n        if (!executionSuccess) {\n            refundSuccess = refundToken(\n                buyOrder.inverse ? token1 : token0,\n                buyOrder.to,\n                buyOrder.shareInMax,\n                buyOrder.unwrap\n            );\n        }\n        finalizeOrder(refundSuccess);\n        (uint256 gasUsed, uint256 ethRefund) = refund(buyOrder.gasLimit, buyOrder.gasPrice, gasStart, buyOrder.to);\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\n    }\n\n    function finalizeOrder(bool refundSuccess) private {\n        if (!refundSuccess) {\n            orders.markRefundFailed();\n        } else {\n            orders.forgetLastProcessedOrder();\n        }\n    }\n\n    function refund(\n        uint256 gasLimit,\n        uint256 gasPriceInOrder,\n        uint256 gasStart,\n        address to\n    ) private returns (uint256 gasUsed, uint256 leftOver) {\n        uint256 feeCollected = gasLimit.mul(gasPriceInOrder);\n        gasUsed = gasStart.sub(gasleft()).add(Orders.REFUND_BASE_COST);\n        uint256 actualRefund = Math.min(feeCollected, gasUsed.mul(orders.gasPrice));\n        leftOver = feeCollected.sub(actualRefund);\n        require(refundEth(msg.sender, actualRefund), 'TD40');\n        refundEth(payable(to), leftOver);\n    }\n\n    function refundEth(address payable to, uint256 value) internal returns (bool success) {\n        if (value == 0) {\n            return true;\n        }\n        success = TransferHelper.transferETH(to, value, orders.transferGasCosts[address(0)]);\n        emit EthRefund(to, success, value);\n    }\n\n    function refundToken(\n        address token,\n        address to,\n        uint256 share,\n        bool unwrap\n    ) private returns (bool) {\n        if (share == 0) {\n            return true;\n        }\n        (bool success, bytes memory data) = address(this).call{ gas: orders.transferGasCosts[token] }(\n            abi.encodeWithSelector(this._refundToken.selector, token, to, share, unwrap)\n        );\n        if (!success) {\n            emit RefundFailed(to, token, share, data);\n        }\n        return success;\n    }\n\n    function refundTokens(\n        address to,\n        address token0,\n        uint256 share0,\n        address token1,\n        uint256 share1,\n        bool unwrap\n    ) private returns (bool) {\n        (bool success, bytes memory data) = address(this).call{\n            gas: orders.transferGasCosts[token0].add(orders.transferGasCosts[token1])\n        }(abi.encodeWithSelector(this._refundTokens.selector, to, token0, share0, token1, share1, unwrap));\n        if (!success) {\n            emit RefundFailed(to, token0, share0, data);\n            emit RefundFailed(to, token1, share1, data);\n        }\n        return success;\n    }\n\n    function _refundTokens(\n        address to,\n        address token0,\n        uint256 share0,\n        address token1,\n        uint256 share1,\n        bool unwrap\n    ) external {\n        // no need to check sender, because it is checked in _refundToken\n        _refundToken(token0, to, share0, unwrap);\n        _refundToken(token1, to, share1, unwrap);\n    }\n\n    function _refundToken(\n        address token,\n        address to,\n        uint256 share,\n        bool unwrap\n    ) public {\n        require(msg.sender == address(this), 'TD00');\n        if (token == tokenShares.weth && unwrap) {\n            uint256 amount = tokenShares.sharesToAmount(token, share);\n            IWETH(tokenShares.weth).withdraw(amount);\n            TransferHelper.safeTransferETH(to, amount, orders.transferGasCosts[address(0)]);\n        } else {\n            TransferHelper.safeTransfer(token, to, tokenShares.sharesToAmount(token, share));\n        }\n    }\n\n    function refundLiquidity(\n        address pair,\n        address to,\n        uint256 liquidity\n    ) private returns (bool) {\n        if (liquidity == 0) {\n            return true;\n        }\n        (bool success, bytes memory data) = address(this).call{ gas: Orders.PAIR_TRANSFER_COST }(\n            abi.encodeWithSelector(this._refundLiquidity.selector, pair, to, liquidity, false)\n        );\n        if (!success) {\n            emit RefundFailed(to, pair, liquidity, data);\n        }\n        return success;\n    }\n\n    function _refundLiquidity(\n        address pair,\n        address to,\n        uint256 liquidity\n    ) external {\n        require(msg.sender == address(this), 'TD00');\n        return TransferHelper.safeTransfer(pair, to, liquidity);\n    }\n\n    function _executeDeposit(Orders.DepositOrder memory depositOrder) external {\n        require(msg.sender == address(this), 'TD00');\n        require(depositOrder.validAfterTimestamp + ORDER_LIFESPAN >= block.timestamp, 'TD04');\n\n        (address pair, address token0, address token1, uint256 amount0Left, uint256 amount1Left) = _initialDeposit(\n            depositOrder\n        );\n        if (depositOrder.swap) {\n            if (amount0Left != 0) {\n                (amount0Left, amount1Left) = AddLiquidity.swapDeposit0(\n                    pair,\n                    token0,\n                    amount0Left,\n                    depositOrder.minSwapPrice,\n                    encodePriceInfo(pair, depositOrder.priceAccumulator, depositOrder.timestamp)\n                );\n            } else if (amount1Left != 0) {\n                (amount0Left, amount1Left) = AddLiquidity.swapDeposit1(\n                    pair,\n                    token1,\n                    amount1Left,\n                    depositOrder.maxSwapPrice,\n                    encodePriceInfo(pair, depositOrder.priceAccumulator, depositOrder.timestamp)\n                );\n            }\n        }\n        if (amount0Left != 0 && amount1Left != 0) {\n            (amount0Left, amount1Left) = AddLiquidity.addLiquidityAndMint(\n                pair,\n                depositOrder.to,\n                token0,\n                token1,\n                amount0Left,\n                amount1Left\n            );\n        }\n\n        _refundDeposit(depositOrder.to, token0, token1, amount0Left, amount1Left);\n    }\n\n    function _initialDeposit(Orders.DepositOrder memory depositOrder)\n        private\n        returns (\n            address pair,\n            address token0,\n            address token1,\n            uint256 amount0Left,\n            uint256 amount1Left\n        )\n    {\n        (pair, token0, token1) = orders.getPairInfo(depositOrder.pairId);\n        uint256 amount0Desired = tokenShares.sharesToAmount(token0, depositOrder.share0);\n        uint256 amount1Desired = tokenShares.sharesToAmount(token1, depositOrder.share1);\n        ITwapPair(pair).sync();\n        (amount0Left, amount1Left) = AddLiquidity.addLiquidityAndMint(\n            pair,\n            depositOrder.to,\n            token0,\n            token1,\n            amount0Desired,\n            amount1Desired\n        );\n    }\n\n    function _refundDeposit(\n        address to,\n        address token0,\n        address token1,\n        uint256 amount0,\n        uint256 amount1\n    ) private {\n        if (amount0 > 0) {\n            TransferHelper.safeTransfer(token0, to, amount0);\n        }\n        if (amount1 > 0) {\n            TransferHelper.safeTransfer(token1, to, amount1);\n        }\n    }\n\n    function _executeWithdraw(Orders.WithdrawOrder memory withdrawOrder) external {\n        require(msg.sender == address(this), 'TD00');\n        require(withdrawOrder.validAfterTimestamp + ORDER_LIFESPAN >= block.timestamp, 'TD04');\n\n        (address pair, address token0, address token1) = orders.getPairInfo(withdrawOrder.pairId);\n        ITwapPair(pair).sync();\n        TransferHelper.safeTransfer(pair, pair, withdrawOrder.liquidity);\n\n        (uint256 wethAmount, uint256 amount0, uint256 amount1) = (0, 0, 0);\n        if (withdrawOrder.unwrap && (token0 == tokenShares.weth || token1 == tokenShares.weth)) {\n            bool success;\n            (success, wethAmount, amount0, amount1) = WithdrawHelper.withdrawAndUnwrap(\n                token0,\n                token1,\n                pair,\n                tokenShares.weth,\n                withdrawOrder.to,\n                orders.transferGasCosts[address(0)]\n            );\n            if (!success) {\n                tokenShares.onUnwrapFailed(withdrawOrder.to, wethAmount);\n            }\n        } else {\n            (amount0, amount1) = ITwapPair(pair).burn(withdrawOrder.to);\n        }\n        require(amount0 >= withdrawOrder.amount0Min && amount1 >= withdrawOrder.amount1Min, 'TD03');\n    }\n\n    function _executeBuy(Orders.BuyOrder memory buyOrder) external {\n        require(msg.sender == address(this), 'TD00');\n        require(buyOrder.validAfterTimestamp + ORDER_LIFESPAN >= block.timestamp, 'TD04');\n\n        (address pairAddress, address tokenIn, address tokenOut) = _getPairAndTokens(buyOrder.pairId, buyOrder.inverse);\n        uint256 amountInMax = tokenShares.sharesToAmount(tokenIn, buyOrder.shareInMax);\n        ITwapPair pair = ITwapPair(pairAddress);\n        pair.sync();\n        bytes memory priceInfo = encodePriceInfo(pairAddress, buyOrder.priceAccumulator, buyOrder.timestamp);\n        uint256 amountIn = buyOrder.inverse\n            ? pair.getSwapAmount1In(buyOrder.amountOut, priceInfo)\n            : pair.getSwapAmount0In(buyOrder.amountOut, priceInfo);\n        require(amountInMax >= amountIn, 'TD08');\n        if (amountInMax > amountIn) {\n            if (tokenIn == tokenShares.weth && buyOrder.unwrap) {\n                _forceEtherTransfer(buyOrder.to, amountInMax.sub(amountIn));\n            } else {\n                TransferHelper.safeTransfer(tokenIn, buyOrder.to, amountInMax.sub(amountIn));\n            }\n        }\n        (uint256 amount0Out, uint256 amount1Out) = buyOrder.inverse\n            ? (buyOrder.amountOut, uint256(0))\n            : (uint256(0), buyOrder.amountOut);\n        TransferHelper.safeTransfer(tokenIn, pairAddress, amountIn);\n        if (tokenOut == tokenShares.weth && buyOrder.unwrap) {\n            pair.swap(amount0Out, amount1Out, address(this), priceInfo);\n            _forceEtherTransfer(buyOrder.to, buyOrder.amountOut);\n        } else {\n            pair.swap(amount0Out, amount1Out, buyOrder.to, priceInfo);\n        }\n    }\n\n    function _executeSell(Orders.SellOrder memory sellOrder) external {\n        require(msg.sender == address(this), 'TD00');\n        require(sellOrder.validAfterTimestamp + ORDER_LIFESPAN >= block.timestamp, 'TD04');\n\n        (address pairAddress, address tokenIn, address tokenOut) = _getPairAndTokens(\n            sellOrder.pairId,\n            sellOrder.inverse\n        );\n        uint256 amountIn = tokenShares.sharesToAmount(tokenIn, sellOrder.shareIn);\n        ITwapPair pair = ITwapPair(pairAddress);\n        pair.sync();\n        bytes memory priceInfo = encodePriceInfo(pairAddress, sellOrder.priceAccumulator, sellOrder.timestamp);\n        uint256 amountOut = sellOrder.inverse\n            ? pair.getSwapAmount0Out(amountIn, priceInfo)\n            : pair.getSwapAmount1Out(amountIn, priceInfo);\n        require(amountOut >= sellOrder.amountOutMin, 'TD37');\n        (uint256 amount0Out, uint256 amount1Out) = sellOrder.inverse\n            ? (amountOut, uint256(0))\n            : (uint256(0), amountOut);\n        TransferHelper.safeTransfer(tokenIn, pairAddress, amountIn);\n        if (tokenOut == tokenShares.weth && sellOrder.unwrap) {\n            pair.swap(amount0Out, amount1Out, address(this), priceInfo);\n            _forceEtherTransfer(sellOrder.to, amountOut);\n        } else {\n            pair.swap(amount0Out, amount1Out, sellOrder.to, priceInfo);\n        }\n    }\n\n    function _getPairAndTokens(uint32 pairId, bool pairInversed)\n        private\n        view\n        returns (\n            address,\n            address,\n            address\n        )\n    {\n        (address pairAddress, address token0, address token1) = orders.getPairInfo(pairId);\n        (address tokenIn, address tokenOut) = pairInversed ? (token1, token0) : (token0, token1);\n        return (pairAddress, tokenIn, tokenOut);\n    }\n\n    function _forceEtherTransfer(address to, uint256 amount) internal {\n        IWETH(tokenShares.weth).withdraw(amount);\n        (bool success, ) = to.call{ value: amount, gas: orders.transferGasCosts[address(0)] }('');\n        if (!success) {\n            tokenShares.onUnwrapFailed(to, amount);\n        }\n    }\n\n    function performRefund(\n        Orders.OrderType orderType,\n        uint256 validAfterTimestamp,\n        uint256 orderId,\n        bool shouldRefundEth\n    ) internal {\n        require(orderType != Orders.OrderType.Empty, 'TD41');\n        bool canOwnerRefund = validAfterTimestamp.add(365 days) < block.timestamp;\n\n        if (orderType == Orders.OrderType.Deposit) {\n            Orders.DepositOrder memory depositOrder = orders.getDepositOrder(orderId);\n            (, address token0, address token1) = orders.getPairInfo(depositOrder.pairId);\n            address to = canOwnerRefund ? owner : depositOrder.to;\n            require(\n                refundTokens(to, token0, depositOrder.share0, token1, depositOrder.share1, depositOrder.unwrap),\n                'TD14'\n            );\n            if (shouldRefundEth) {\n                uint256 value = depositOrder.gasPrice.mul(depositOrder.gasLimit);\n                require(refundEth(payable(to), value), 'TD40');\n            }\n        } else if (orderType == Orders.OrderType.Withdraw) {\n            Orders.WithdrawOrder memory withdrawOrder = orders.getWithdrawOrder(orderId);\n            (address pair, , ) = orders.getPairInfo(withdrawOrder.pairId);\n            address to = canOwnerRefund ? owner : withdrawOrder.to;\n            require(refundLiquidity(pair, to, withdrawOrder.liquidity), 'TD14');\n            if (shouldRefundEth) {\n                uint256 value = withdrawOrder.gasPrice.mul(withdrawOrder.gasLimit);\n                require(refundEth(payable(to), value), 'TD40');\n            }\n        } else if (orderType == Orders.OrderType.Sell) {\n            Orders.SellOrder memory sellOrder = orders.getSellOrder(orderId);\n            (, address token0, address token1) = orders.getPairInfo(sellOrder.pairId);\n            address to = canOwnerRefund ? owner : sellOrder.to;\n            require(refundToken(sellOrder.inverse ? token1 : token0, to, sellOrder.shareIn, sellOrder.unwrap), 'TD14');\n            if (shouldRefundEth) {\n                uint256 value = sellOrder.gasPrice.mul(sellOrder.gasLimit);\n                require(refundEth(payable(to), value), 'TD40');\n            }\n        } else if (orderType == Orders.OrderType.Buy) {\n            Orders.BuyOrder memory buyOrder = orders.getBuyOrder(orderId);\n            (, address token0, address token1) = orders.getPairInfo(buyOrder.pairId);\n            address to = canOwnerRefund ? owner : buyOrder.to;\n            require(refundToken(buyOrder.inverse ? token1 : token0, to, buyOrder.shareInMax, buyOrder.unwrap), 'TD14');\n            if (shouldRefundEth) {\n                uint256 value = buyOrder.gasPrice.mul(buyOrder.gasLimit);\n                require(refundEth(payable(to), value), 'TD40');\n            }\n        }\n        orders.forgetOrder(orderId);\n    }\n\n    function retryRefund(uint256 orderId) external override lock {\n        (Orders.OrderType orderType, uint256 validAfterTimestamp) = orders.getFailedOrderType(orderId);\n        performRefund(orderType, validAfterTimestamp, orderId, false);\n    }\n\n    function cancelOrder(uint256 orderId) external override lock {\n        require(orders.getOrderStatus(orderId) == Orders.OrderStatus.EnqueuedReady, 'TD52');\n        (Orders.OrderType orderType, uint256 validAfterTimestamp) = orders.getOrder(orderId);\n        require(validAfterTimestamp.sub(orders.delay).add(ORDER_CANCEL_TIME) < block.timestamp, 'TD1C');\n        orders.canceled[orderId] = true;\n        performRefund(orderType, validAfterTimestamp, orderId, true);\n    }\n\n    function encodePriceInfo(\n        address pair,\n        uint256 priceAccumulator,\n        uint32 priceTimestamp\n    ) internal view returns (bytes memory data) {\n        uint256 price = ITwapOracle(ITwapPair(pair).oracle()).getAveragePrice(priceAccumulator, priceTimestamp);\n        // Pack everything as 32 bytes / uint256 to simplify decoding\n        data = abi.encode(price);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/interfaces/ITwapPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\nimport './ITwapERC20.sol';\nimport './IReserves.sol';\n\ninterface ITwapPair is ITwapERC20, IReserves {\n    event Mint(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 liquidityOut, address indexed to);\n    event Burn(address indexed sender, uint256 amount0Out, uint256 amount1Out, uint256 liquidityIn, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event SetMintFee(uint256 fee);\n    event SetBurnFee(uint256 fee);\n    event SetSwapFee(uint256 fee);\n    event SetOracle(address account);\n    event SetTrader(address trader);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function oracle() external view returns (address);\n\n    function trader() external view returns (address);\n\n    function mintFee() external view returns (uint256);\n\n    function setMintFee(uint256 fee) external;\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burnFee() external view returns (uint256);\n\n    function setBurnFee(uint256 fee) external;\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swapFee() external view returns (uint256);\n\n    function setSwapFee(uint256 fee) external;\n\n    function setOracle(address account) external;\n\n    function setTrader(address account) external;\n\n    function collect(address to) external;\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function sync() external;\n\n    function initialize(\n        address _token0,\n        address _token1,\n        address _oracle,\n        address _trader\n    ) external;\n\n    function getSwapAmount0In(uint256 amount1Out, bytes calldata data) external view returns (uint256 swapAmount0In);\n\n    function getSwapAmount1In(uint256 amount0Out, bytes calldata data) external view returns (uint256 swapAmount1In);\n\n    function getSwapAmount0Out(uint256 amount1In, bytes calldata data) external view returns (uint256 swapAmount0Out);\n\n    function getSwapAmount1Out(uint256 amount0In, bytes calldata data) external view returns (uint256 swapAmount1Out);\n\n    function getDepositAmount0In(uint256 amount0, bytes calldata data) external view returns (uint256 depositAmount0In);\n\n    function getDepositAmount1In(uint256 amount1, bytes calldata data) external view returns (uint256 depositAmount1In);\n}\n"
    },
    "contracts/interfaces/ITwapDelay.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '../libraries/Orders.sol';\n\ninterface ITwapDelay {\n    event OrderExecuted(uint256 indexed id, bool indexed success, bytes data, uint256 gasSpent, uint256 ethRefunded);\n    event RefundFailed(address indexed to, address indexed token, uint256 amount, bytes data);\n    event EthRefund(address indexed to, bool indexed success, uint256 value);\n    event OwnerSet(address owner);\n    event BotSet(address bot, bool isBot);\n    event DelaySet(uint256 delay);\n    event MaxGasLimitSet(uint256 maxGasLimit);\n    event GasPriceInertiaSet(uint256 gasPriceInertia);\n    event MaxGasPriceImpactSet(uint256 maxGasPriceImpact);\n    event TransferGasCostSet(address token, uint256 gasCost);\n    event OrderDisabled(address pair, Orders.OrderType orderType, bool disabled);\n    event UnwrapFailed(address to, uint256 amount);\n    event Execute(address sender, uint256 n);\n\n    function factory() external returns (address);\n\n    function owner() external returns (address);\n\n    function isBot(address bot) external returns (bool);\n\n    function gasPriceInertia() external returns (uint256);\n\n    function gasPrice() external returns (uint256);\n\n    function maxGasPriceImpact() external returns (uint256);\n\n    function maxGasLimit() external returns (uint256);\n\n    function delay() external returns (uint32);\n\n    function totalShares(address token) external returns (uint256);\n\n    function weth() external returns (address);\n\n    function getTransferGasCost(address token) external returns (uint256);\n\n    function getDepositOrder(uint256 orderId) external returns (Orders.DepositOrder memory order);\n\n    function getWithdrawOrder(uint256 orderId) external returns (Orders.WithdrawOrder memory order);\n\n    function getSellOrder(uint256 orderId) external returns (Orders.SellOrder memory order);\n\n    function getBuyOrder(uint256 orderId) external returns (Orders.BuyOrder memory order);\n\n    function getDepositDisabled(address pair) external returns (bool);\n\n    function getWithdrawDisabled(address pair) external returns (bool);\n\n    function getBuyDisabled(address pair) external returns (bool);\n\n    function getSellDisabled(address pair) external returns (bool);\n\n    function getOrderStatus(uint256 orderId) external returns (Orders.OrderStatus);\n\n    function setOrderDisabled(\n        address pair,\n        Orders.OrderType orderType,\n        bool disabled\n    ) external;\n\n    function setOwner(address _owner) external;\n\n    function setBot(address _bot, bool _isBot) external;\n\n    function setMaxGasLimit(uint256 _maxGasLimit) external;\n\n    function setDelay(uint32 _delay) external;\n\n    function setGasPriceInertia(uint256 _gasPriceInertia) external;\n\n    function setMaxGasPriceImpact(uint256 _maxGasPriceImpact) external;\n\n    function setTransferGasCost(address token, uint256 gasCost) external;\n\n    function deposit(Orders.DepositParams memory depositParams) external payable returns (uint256 orderId);\n\n    function withdraw(Orders.WithdrawParams memory withdrawParams) external payable returns (uint256 orderId);\n\n    function sell(Orders.SellParams memory sellParams) external payable returns (uint256 orderId);\n\n    function buy(Orders.BuyParams memory buyParams) external payable returns (uint256 orderId);\n\n    function execute(uint256 n) external;\n\n    function retryRefund(uint256 orderId) external;\n\n    function cancelOrder(uint256 orderId) external;\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/libraries/Orders.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport './SafeMath.sol';\nimport '../libraries/Math.sol';\nimport '../interfaces/ITwapFactory.sol';\nimport '../interfaces/ITwapPair.sol';\nimport '../interfaces/ITwapOracle.sol';\nimport '../libraries/TokenShares.sol';\n\nlibrary Orders {\n    using SafeMath for uint256;\n    using TokenShares for TokenShares.Data;\n    using TransferHelper for address;\n\n    enum OrderType {\n        Empty,\n        Deposit,\n        Withdraw,\n        Sell,\n        Buy\n    }\n    enum OrderStatus {\n        NonExistent,\n        EnqueuedWaiting,\n        EnqueuedReady,\n        ExecutedSucceeded,\n        ExecutedFailed,\n        Canceled\n    }\n\n    event MaxGasLimitSet(uint256 maxGasLimit);\n    event GasPriceInertiaSet(uint256 gasPriceInertia);\n    event MaxGasPriceImpactSet(uint256 maxGasPriceImpact);\n    event TransferGasCostSet(address token, uint256 gasCost);\n\n    event DepositEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);\n    event WithdrawEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);\n    event SellEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);\n    event BuyEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);\n\n    event OrderDisabled(address pair, Orders.OrderType orderType, bool disabled);\n\n    uint8 private constant DEPOSIT_TYPE = 1;\n    uint8 private constant WITHDRAW_TYPE = 2;\n    uint8 private constant BUY_TYPE = 3;\n    uint8 private constant BUY_INVERTED_TYPE = 4;\n    uint8 private constant SELL_TYPE = 5;\n    uint8 private constant SELL_INVERTED_TYPE = 6;\n\n    uint8 private constant UNWRAP_NOT_FAILED = 0;\n    uint8 private constant KEEP_NOT_FAILED = 1;\n    uint8 private constant UNWRAP_FAILED = 2;\n    uint8 private constant KEEP_FAILED = 3;\n\n    uint256 private constant ETHER_TRANSFER_COST = 2600 + 1504; // EIP-2929 acct access cost + Gnosis Safe receive ETH cost\n    uint256 private constant BUFFER_COST = 10000;\n    uint256 private constant ORDER_EXECUTED_EVENT_COST = 3700;\n    uint256 private constant EXECUTE_PREPARATION_COST = 55000; // dequeue + getPair in execute\n\n    uint256 public constant ETHER_TRANSFER_CALL_COST = 10000;\n    uint256 public constant PAIR_TRANSFER_COST = 55000;\n    uint256 public constant REFUND_BASE_COST = 2 * ETHER_TRANSFER_COST + BUFFER_COST + ORDER_EXECUTED_EVENT_COST;\n    uint256 public constant ORDER_BASE_COST = EXECUTE_PREPARATION_COST + REFUND_BASE_COST;\n\n    // Masks used for setting order disabled\n    // Different bits represent different order types\n    uint8 private constant DEPOSIT_MASK = uint8(1) << uint8(OrderType.Deposit); //   00000010\n    uint8 private constant WITHDRAW_MASK = uint8(1) << uint8(OrderType.Withdraw); // 00000100\n    uint8 private constant SELL_MASK = uint8(1) << uint8(OrderType.Sell); //         00001000\n    uint8 private constant BUY_MASK = uint8(1) << uint8(OrderType.Buy); //           00010000\n\n    struct PairInfo {\n        address pair;\n        address token0;\n        address token1;\n    }\n\n    struct Data {\n        uint32 delay;\n        uint256 newestOrderId;\n        uint256 lastProcessedOrderId;\n        mapping(uint256 => StoredOrder) orderQueue;\n        address factory;\n        uint256 maxGasLimit;\n        uint256 gasPrice;\n        uint256 gasPriceInertia;\n        uint256 maxGasPriceImpact;\n        mapping(uint32 => PairInfo) pairs;\n        mapping(address => uint256) transferGasCosts;\n        mapping(uint256 => bool) canceled;\n        // Bit on specific positions indicates whether order type is disabled (1) or enabled (0) on specific pair\n        mapping(address => uint8) orderDisabled;\n    }\n\n    struct StoredOrder {\n        // slot 0\n        uint8 orderType;\n        uint32 validAfterTimestamp;\n        uint8 unwrapAndFailure;\n        uint32 timestamp;\n        uint32 gasLimit;\n        uint32 gasPrice;\n        uint112 liquidity;\n        // slot 1\n        uint112 value0;\n        uint112 value1;\n        uint32 pairId;\n        // slot2\n        address to;\n        uint32 minSwapPrice;\n        uint32 maxSwapPrice;\n        bool swap;\n        // slot3\n        uint256 priceAccumulator;\n    }\n\n    struct DepositOrder {\n        uint32 pairId;\n        uint256 share0;\n        uint256 share1;\n        uint256 minSwapPrice;\n        uint256 maxSwapPrice;\n        bool unwrap;\n        bool swap;\n        address to;\n        uint256 gasPrice;\n        uint256 gasLimit;\n        uint32 validAfterTimestamp;\n        uint256 priceAccumulator;\n        uint32 timestamp;\n    }\n\n    struct WithdrawOrder {\n        uint32 pairId;\n        uint256 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        bool unwrap;\n        address to;\n        uint256 gasPrice;\n        uint256 gasLimit;\n        uint32 validAfterTimestamp;\n    }\n\n    struct SellOrder {\n        uint32 pairId;\n        bool inverse;\n        uint256 shareIn;\n        uint256 amountOutMin;\n        bool unwrap;\n        address to;\n        uint256 gasPrice;\n        uint256 gasLimit;\n        uint32 validAfterTimestamp;\n        uint256 priceAccumulator;\n        uint32 timestamp;\n    }\n\n    struct BuyOrder {\n        uint32 pairId;\n        bool inverse;\n        uint256 shareInMax;\n        uint256 amountOut;\n        bool unwrap;\n        address to;\n        uint256 gasPrice;\n        uint256 gasLimit;\n        uint32 validAfterTimestamp;\n        uint256 priceAccumulator;\n        uint32 timestamp;\n    }\n\n    function decodeType(uint256 internalType) internal pure returns (OrderType orderType) {\n        if (internalType == DEPOSIT_TYPE) {\n            orderType = OrderType.Deposit;\n        } else if (internalType == WITHDRAW_TYPE) {\n            orderType = OrderType.Withdraw;\n        } else if (internalType == BUY_TYPE) {\n            orderType = OrderType.Buy;\n        } else if (internalType == BUY_INVERTED_TYPE) {\n            orderType = OrderType.Buy;\n        } else if (internalType == SELL_TYPE) {\n            orderType = OrderType.Sell;\n        } else if (internalType == SELL_INVERTED_TYPE) {\n            orderType = OrderType.Sell;\n        } else {\n            orderType = OrderType.Empty;\n        }\n    }\n\n    function getOrder(Data storage data, uint256 orderId)\n        public\n        view\n        returns (OrderType orderType, uint32 validAfterTimestamp)\n    {\n        StoredOrder storage order = data.orderQueue[orderId];\n        uint8 internalType = order.orderType;\n        validAfterTimestamp = order.validAfterTimestamp;\n        orderType = decodeType(internalType);\n    }\n\n    function getOrderStatus(Data storage data, uint256 orderId) external view returns (OrderStatus orderStatus) {\n        if (orderId > data.newestOrderId) {\n            return OrderStatus.NonExistent;\n        }\n        if (data.canceled[orderId]) {\n            return OrderStatus.Canceled;\n        }\n        if (isRefundFailed(data, orderId)) {\n            return OrderStatus.ExecutedFailed;\n        }\n        (OrderType orderType, uint32 validAfterTimestamp) = getOrder(data, orderId);\n        if (orderType == OrderType.Empty) {\n            return OrderStatus.ExecutedSucceeded;\n        }\n        if (validAfterTimestamp >= block.timestamp) {\n            return OrderStatus.EnqueuedWaiting;\n        }\n        return OrderStatus.EnqueuedReady;\n    }\n\n    function getPair(\n        Data storage data,\n        address tokenA,\n        address tokenB\n    )\n        internal\n        returns (\n            address pair,\n            uint32 pairId,\n            bool inverted\n        )\n    {\n        inverted = tokenA > tokenB;\n        (address token0, address token1) = inverted ? (tokenB, tokenA) : (tokenA, tokenB);\n        pair = ITwapFactory(data.factory).getPair(token0, token1);\n        require(pair != address(0), 'OS17');\n        pairId = uint32(bytes4(keccak256(abi.encodePacked(pair))));\n        if (data.pairs[pairId].pair == address(0)) {\n            data.pairs[pairId] = PairInfo(pair, token0, token1);\n        }\n    }\n\n    function getPairInfo(Data storage data, uint32 pairId)\n        external\n        view\n        returns (\n            address pair,\n            address token0,\n            address token1\n        )\n    {\n        PairInfo storage info = data.pairs[pairId];\n        pair = info.pair;\n        token0 = info.token0;\n        token1 = info.token1;\n    }\n\n    function getDepositDisabled(Data storage data, address pair) public view returns (bool) {\n        return data.orderDisabled[pair] & DEPOSIT_MASK != 0;\n    }\n\n    function getWithdrawDisabled(Data storage data, address pair) public view returns (bool) {\n        return data.orderDisabled[pair] & WITHDRAW_MASK != 0;\n    }\n\n    function getSellDisabled(Data storage data, address pair) public view returns (bool) {\n        return data.orderDisabled[pair] & SELL_MASK != 0;\n    }\n\n    function getBuyDisabled(Data storage data, address pair) public view returns (bool) {\n        return data.orderDisabled[pair] & BUY_MASK != 0;\n    }\n\n    function getDepositOrder(Data storage data, uint256 index) public view returns (DepositOrder memory order) {\n        StoredOrder memory stored = data.orderQueue[index];\n        require(stored.orderType == DEPOSIT_TYPE, 'OS32');\n        order.pairId = stored.pairId;\n        order.share0 = stored.value0;\n        order.share1 = stored.value1;\n        order.minSwapPrice = float32ToUint(stored.minSwapPrice);\n        order.maxSwapPrice = float32ToUint(stored.maxSwapPrice);\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\n        order.swap = stored.swap;\n        order.to = stored.to;\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\n        order.gasLimit = stored.gasLimit;\n        order.validAfterTimestamp = stored.validAfterTimestamp;\n        order.priceAccumulator = stored.priceAccumulator;\n        order.timestamp = stored.timestamp;\n    }\n\n    function getWithdrawOrder(Data storage data, uint256 index) public view returns (WithdrawOrder memory order) {\n        StoredOrder memory stored = data.orderQueue[index];\n        require(stored.orderType == WITHDRAW_TYPE, 'OS32');\n        order.pairId = stored.pairId;\n        order.liquidity = stored.liquidity;\n        order.amount0Min = stored.value0;\n        order.amount1Min = stored.value1;\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\n        order.to = stored.to;\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\n        order.gasLimit = stored.gasLimit;\n        order.validAfterTimestamp = stored.validAfterTimestamp;\n    }\n\n    function getSellOrder(Data storage data, uint256 index) public view returns (SellOrder memory order) {\n        StoredOrder memory stored = data.orderQueue[index];\n        require(stored.orderType == SELL_TYPE || stored.orderType == SELL_INVERTED_TYPE, 'OS32');\n        order.pairId = stored.pairId;\n        order.inverse = stored.orderType == SELL_INVERTED_TYPE;\n        order.shareIn = stored.value0;\n        order.amountOutMin = stored.value1;\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\n        order.to = stored.to;\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\n        order.gasLimit = stored.gasLimit;\n        order.validAfterTimestamp = stored.validAfterTimestamp;\n        order.priceAccumulator = stored.priceAccumulator;\n        order.timestamp = stored.timestamp;\n    }\n\n    function getBuyOrder(Data storage data, uint256 index) public view returns (BuyOrder memory order) {\n        StoredOrder memory stored = data.orderQueue[index];\n        require(stored.orderType == BUY_TYPE || stored.orderType == BUY_INVERTED_TYPE, 'OS32');\n        order.pairId = stored.pairId;\n        order.inverse = stored.orderType == BUY_INVERTED_TYPE;\n        order.shareInMax = stored.value0;\n        order.amountOut = stored.value1;\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\n        order.to = stored.to;\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\n        order.gasLimit = stored.gasLimit;\n        order.validAfterTimestamp = stored.validAfterTimestamp;\n        order.timestamp = stored.timestamp;\n        order.priceAccumulator = stored.priceAccumulator;\n    }\n\n    function getFailedOrderType(Data storage data, uint256 orderId)\n        external\n        view\n        returns (OrderType orderType, uint32 validAfterTimestamp)\n    {\n        require(isRefundFailed(data, orderId), 'OS21');\n        (orderType, validAfterTimestamp) = getOrder(data, orderId);\n    }\n\n    function getUnwrap(uint8 unwrapAndFailure) private pure returns (bool) {\n        return unwrapAndFailure == UNWRAP_FAILED || unwrapAndFailure == UNWRAP_NOT_FAILED;\n    }\n\n    function getUnwrapAndFailure(bool unwrap) private pure returns (uint8) {\n        return unwrap ? UNWRAP_NOT_FAILED : KEEP_NOT_FAILED;\n    }\n\n    function timestampToUint32(uint256 timestamp) private pure returns (uint32 timestamp32) {\n        if (timestamp == type(uint256).max) {\n            return type(uint32).max;\n        }\n        timestamp32 = timestamp.toUint32();\n    }\n\n    function gasPriceToUint32(uint256 gasPrice) private pure returns (uint32 gasPrice32) {\n        require((gasPrice / 1e6) * 1e6 == gasPrice, 'OS3C');\n        gasPrice32 = (gasPrice / 1e6).toUint32();\n    }\n\n    function uint32ToGasPrice(uint32 gasPrice32) public pure returns (uint256 gasPrice) {\n        gasPrice = uint256(gasPrice32) * 1e6;\n    }\n\n    function uintToFloat32(uint256 number) internal pure returns (uint32 float32) {\n        // Number is encoded on 4 bytes. 3 bytes for mantissa and 1 for exponent.\n        // If the number fits in the mantissa we set the exponent to zero and return.\n        if (number < 2 << 24) {\n            return uint32(number << 8);\n        }\n        // We find the exponent by counting the number of trailing zeroes.\n        // Simultaneously we remove those zeroes from the number.\n        uint32 exponent;\n        for (exponent = 0; exponent < 256 - 24; exponent++) {\n            // Last bit is one.\n            if (number & 1 == 1) {\n                break;\n            }\n            number = number >> 1;\n        }\n        // The number must fit in the mantissa.\n        require(number < 2 << 24, 'OS1A');\n        // Set the first three bytes to the number and the fourth to the exponent.\n        float32 = uint32(number << 8) | exponent;\n    }\n\n    function float32ToUint(uint32 float32) internal pure returns (uint256 number) {\n        // Number is encoded on 4 bytes. 3 bytes for mantissa and 1 for exponent.\n        // We get the exponent by extracting the last byte.\n        uint256 exponent = float32 & 0xFF;\n        // Sanity check. Only triggered for values not encoded with uintToFloat32.\n        require(exponent <= 256 - 24, 'OS1B');\n        // We get the mantissa by extracting the first three bytes and removing the fourth.\n        uint256 mantissa = (float32 & 0xFFFFFF00) >> 8;\n        // We add exponent number zeroes after the mantissa.\n        number = mantissa << exponent;\n    }\n\n    function setOrderDisabled(\n        Data storage data,\n        address pair,\n        Orders.OrderType orderType,\n        bool disabled\n    ) external {\n        require(orderType != Orders.OrderType.Empty, 'OS32');\n        uint8 currentSettings = data.orderDisabled[pair];\n\n        // zeros with 1 bit set at position specified by orderType\n        uint8 mask = uint8(1) << uint8(orderType);\n\n        // set/unset a bit accordingly to 'disabled' value\n        if (disabled) {\n            // OR operation to disable order\n            // e.g. for disable DEPOSIT\n            // currentSettings   = 00010100 (BUY and WITHDRAW disabled)\n            // mask for DEPOSIT  = 00000010\n            // the result of OR  = 00010110\n            currentSettings = currentSettings | mask;\n        } else {\n            // AND operation with a mask negation to enable order\n            // e.g. for enable DEPOSIT\n            // currentSettings   = 00010100 (BUY and WITHDRAW disabled)\n            // 0xff              = 11111111\n            // mask for Deposit  = 00000010\n            // mask negation     = 11111101\n            // the result of AND = 00010100\n            currentSettings = currentSettings & (mask ^ 0xff);\n        }\n        require(currentSettings != data.orderDisabled[pair], 'OS01');\n        data.orderDisabled[pair] = currentSettings;\n\n        emit OrderDisabled(pair, orderType, disabled);\n    }\n\n    function enqueueDepositOrder(Data storage data, DepositOrder memory depositOrder) internal {\n        data.newestOrderId++;\n        emit DepositEnqueued(data.newestOrderId, depositOrder.validAfterTimestamp, depositOrder.gasPrice);\n        data.orderQueue[data.newestOrderId] = StoredOrder(\n            DEPOSIT_TYPE,\n            depositOrder.validAfterTimestamp,\n            getUnwrapAndFailure(depositOrder.unwrap),\n            depositOrder.timestamp,\n            depositOrder.gasLimit.toUint32(),\n            gasPriceToUint32(depositOrder.gasPrice),\n            0, // liquidity\n            depositOrder.share0.toUint112(),\n            depositOrder.share1.toUint112(),\n            depositOrder.pairId,\n            depositOrder.to,\n            uintToFloat32(depositOrder.minSwapPrice),\n            uintToFloat32(depositOrder.maxSwapPrice),\n            depositOrder.swap,\n            depositOrder.priceAccumulator\n        );\n    }\n\n    function enqueueWithdrawOrder(Data storage data, WithdrawOrder memory withdrawOrder) internal {\n        data.newestOrderId++;\n        emit WithdrawEnqueued(data.newestOrderId, withdrawOrder.validAfterTimestamp, withdrawOrder.gasPrice);\n        data.orderQueue[data.newestOrderId] = StoredOrder(\n            WITHDRAW_TYPE,\n            withdrawOrder.validAfterTimestamp,\n            getUnwrapAndFailure(withdrawOrder.unwrap),\n            0, // timestamp\n            withdrawOrder.gasLimit.toUint32(),\n            gasPriceToUint32(withdrawOrder.gasPrice),\n            withdrawOrder.liquidity.toUint112(),\n            withdrawOrder.amount0Min.toUint112(),\n            withdrawOrder.amount1Min.toUint112(),\n            withdrawOrder.pairId,\n            withdrawOrder.to,\n            0, // minSwapPrice\n            0, // maxSwapPrice\n            false, // swap\n            0 // priceAccumulator\n        );\n    }\n\n    function enqueueSellOrder(Data storage data, SellOrder memory sellOrder) internal {\n        data.newestOrderId++;\n        emit SellEnqueued(data.newestOrderId, sellOrder.validAfterTimestamp, sellOrder.gasPrice);\n        data.orderQueue[data.newestOrderId] = StoredOrder(\n            sellOrder.inverse ? SELL_INVERTED_TYPE : SELL_TYPE,\n            sellOrder.validAfterTimestamp,\n            getUnwrapAndFailure(sellOrder.unwrap),\n            sellOrder.timestamp,\n            sellOrder.gasLimit.toUint32(),\n            gasPriceToUint32(sellOrder.gasPrice),\n            0, // liquidity\n            sellOrder.shareIn.toUint112(),\n            sellOrder.amountOutMin.toUint112(),\n            sellOrder.pairId,\n            sellOrder.to,\n            0, // minSwapPrice\n            0, // maxSwapPrice\n            false, // swap\n            sellOrder.priceAccumulator\n        );\n    }\n\n    function enqueueBuyOrder(Data storage data, BuyOrder memory buyOrder) internal {\n        data.newestOrderId++;\n        emit BuyEnqueued(data.newestOrderId, buyOrder.validAfterTimestamp, buyOrder.gasPrice);\n        data.orderQueue[data.newestOrderId] = StoredOrder(\n            buyOrder.inverse ? BUY_INVERTED_TYPE : BUY_TYPE,\n            buyOrder.validAfterTimestamp,\n            getUnwrapAndFailure(buyOrder.unwrap),\n            buyOrder.timestamp,\n            buyOrder.gasLimit.toUint32(),\n            gasPriceToUint32(buyOrder.gasPrice),\n            0, // liquidity\n            buyOrder.shareInMax.toUint112(),\n            buyOrder.amountOut.toUint112(),\n            buyOrder.pairId,\n            buyOrder.to,\n            0, // minSwapPrice\n            0, // maxSwapPrice\n            false, // swap\n            buyOrder.priceAccumulator\n        );\n    }\n\n    function isRefundFailed(Data storage data, uint256 index) internal view returns (bool) {\n        uint8 unwrapAndFailure = data.orderQueue[index].unwrapAndFailure;\n        return unwrapAndFailure == UNWRAP_FAILED || unwrapAndFailure == KEEP_FAILED;\n    }\n\n    function markRefundFailed(Data storage data) internal {\n        StoredOrder storage stored = data.orderQueue[data.lastProcessedOrderId];\n        stored.unwrapAndFailure = stored.unwrapAndFailure == UNWRAP_NOT_FAILED ? UNWRAP_FAILED : KEEP_FAILED;\n    }\n\n    function getNextOrder(Data storage data) internal view returns (OrderType orderType, uint256 validAfterTimestamp) {\n        return getOrder(data, data.lastProcessedOrderId + 1);\n    }\n\n    function dequeueCanceledOrder(Data storage data) external {\n        data.lastProcessedOrderId++;\n    }\n\n    function dequeueDepositOrder(Data storage data) external returns (DepositOrder memory order) {\n        data.lastProcessedOrderId++;\n        order = getDepositOrder(data, data.lastProcessedOrderId);\n    }\n\n    function dequeueWithdrawOrder(Data storage data) external returns (WithdrawOrder memory order) {\n        data.lastProcessedOrderId++;\n        order = getWithdrawOrder(data, data.lastProcessedOrderId);\n    }\n\n    function dequeueSellOrder(Data storage data) external returns (SellOrder memory order) {\n        data.lastProcessedOrderId++;\n        order = getSellOrder(data, data.lastProcessedOrderId);\n    }\n\n    function dequeueBuyOrder(Data storage data) external returns (BuyOrder memory order) {\n        data.lastProcessedOrderId++;\n        order = getBuyOrder(data, data.lastProcessedOrderId);\n    }\n\n    function forgetOrder(Data storage data, uint256 orderId) internal {\n        delete data.orderQueue[orderId];\n    }\n\n    function forgetLastProcessedOrder(Data storage data) internal {\n        delete data.orderQueue[data.lastProcessedOrderId];\n    }\n\n    struct DepositParams {\n        address token0;\n        address token1;\n        uint256 amount0;\n        uint256 amount1;\n        uint256 minSwapPrice;\n        uint256 maxSwapPrice;\n        bool wrap;\n        bool swap;\n        address to;\n        uint256 gasLimit;\n        uint32 submitDeadline;\n    }\n\n    function deposit(\n        Data storage data,\n        DepositParams calldata depositParams,\n        TokenShares.Data storage tokenShares\n    ) external {\n        uint256 token0TransferCost = data.transferGasCosts[depositParams.token0];\n        uint256 token1TransferCost = data.transferGasCosts[depositParams.token1];\n        require(token0TransferCost != 0 && token1TransferCost != 0, 'OS0F');\n        checkOrderParams(\n            data,\n            depositParams.to,\n            depositParams.gasLimit,\n            depositParams.submitDeadline,\n            ORDER_BASE_COST.add(token0TransferCost).add(token1TransferCost)\n        );\n        require(depositParams.amount0 != 0 || depositParams.amount1 != 0, 'OS25');\n        (address pairAddress, uint32 pairId, bool inverted) = getPair(data, depositParams.token0, depositParams.token1);\n        require(!getDepositDisabled(data, pairAddress), 'OS46');\n        {\n            // scope for value, avoids stack too deep errors\n            uint256 value = msg.value;\n\n            // allocate gas refund\n            if (depositParams.wrap) {\n                if (depositParams.token0 == tokenShares.weth) {\n                    value = value.sub(depositParams.amount0, 'OS1E');\n                } else if (depositParams.token1 == tokenShares.weth) {\n                    value = value.sub(depositParams.amount1, 'OS1E');\n                }\n            }\n            allocateGasRefund(data, value, depositParams.gasLimit);\n        }\n\n        uint256 shares0 = tokenShares.amountToShares(depositParams.token0, depositParams.amount0, depositParams.wrap);\n        uint256 shares1 = tokenShares.amountToShares(depositParams.token1, depositParams.amount1, depositParams.wrap);\n\n        (uint256 priceAccumulator, uint32 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();\n        enqueueDepositOrder(\n            data,\n            DepositOrder(\n                pairId,\n                inverted ? shares1 : shares0,\n                inverted ? shares0 : shares1,\n                depositParams.minSwapPrice,\n                depositParams.maxSwapPrice,\n                depositParams.wrap,\n                depositParams.swap,\n                depositParams.to,\n                data.gasPrice,\n                depositParams.gasLimit,\n                timestamp + data.delay, // validAfterTimestamp\n                priceAccumulator,\n                timestamp\n            )\n        );\n    }\n\n    struct WithdrawParams {\n        address token0;\n        address token1;\n        uint256 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        bool unwrap;\n        address to;\n        uint256 gasLimit;\n        uint32 submitDeadline;\n    }\n\n    function withdraw(Data storage data, WithdrawParams calldata withdrawParams) external {\n        (address pair, uint32 pairId, bool inverted) = getPair(data, withdrawParams.token0, withdrawParams.token1);\n        require(!getWithdrawDisabled(data, pair), 'OS0A');\n        checkOrderParams(\n            data,\n            withdrawParams.to,\n            withdrawParams.gasLimit,\n            withdrawParams.submitDeadline,\n            ORDER_BASE_COST.add(PAIR_TRANSFER_COST)\n        );\n        require(withdrawParams.liquidity != 0, 'OS22');\n\n        allocateGasRefund(data, msg.value, withdrawParams.gasLimit);\n        pair.safeTransferFrom(msg.sender, address(this), withdrawParams.liquidity);\n        enqueueWithdrawOrder(\n            data,\n            WithdrawOrder(\n                pairId,\n                withdrawParams.liquidity,\n                inverted ? withdrawParams.amount1Min : withdrawParams.amount0Min,\n                inverted ? withdrawParams.amount0Min : withdrawParams.amount1Min,\n                withdrawParams.unwrap,\n                withdrawParams.to,\n                data.gasPrice,\n                withdrawParams.gasLimit,\n                timestampToUint32(block.timestamp) + data.delay\n            )\n        );\n    }\n\n    struct SellParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint256 amountOutMin;\n        bool wrapUnwrap;\n        address to;\n        uint256 gasLimit;\n        uint32 submitDeadline;\n    }\n\n    function sell(\n        Data storage data,\n        SellParams calldata sellParams,\n        TokenShares.Data storage tokenShares\n    ) external {\n        uint256 tokenTransferCost = data.transferGasCosts[sellParams.tokenIn];\n        require(tokenTransferCost != 0, 'OS0F');\n        checkOrderParams(\n            data,\n            sellParams.to,\n            sellParams.gasLimit,\n            sellParams.submitDeadline,\n            ORDER_BASE_COST.add(tokenTransferCost)\n        );\n        require(sellParams.amountIn != 0, 'OS24');\n        (address pairAddress, uint32 pairId, bool inverted) = getPair(data, sellParams.tokenIn, sellParams.tokenOut);\n        require(!getSellDisabled(data, pairAddress), 'OS13');\n        uint256 value = msg.value;\n\n        // allocate gas refund\n        if (sellParams.tokenIn == tokenShares.weth && sellParams.wrapUnwrap) {\n            value = value.sub(sellParams.amountIn, 'OS1E');\n        }\n        allocateGasRefund(data, value, sellParams.gasLimit);\n\n        uint256 shares = tokenShares.amountToShares(sellParams.tokenIn, sellParams.amountIn, sellParams.wrapUnwrap);\n\n        (uint256 priceAccumulator, uint32 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();\n        enqueueSellOrder(\n            data,\n            SellOrder(\n                pairId,\n                inverted,\n                shares,\n                sellParams.amountOutMin,\n                sellParams.wrapUnwrap,\n                sellParams.to,\n                data.gasPrice,\n                sellParams.gasLimit,\n                timestamp + data.delay,\n                priceAccumulator,\n                timestamp\n            )\n        );\n    }\n\n    struct BuyParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountInMax;\n        uint256 amountOut;\n        bool wrapUnwrap;\n        address to;\n        uint256 gasLimit;\n        uint32 submitDeadline;\n    }\n\n    function buy(\n        Data storage data,\n        BuyParams calldata buyParams,\n        TokenShares.Data storage tokenShares\n    ) external {\n        uint256 tokenTransferCost = data.transferGasCosts[buyParams.tokenIn];\n        require(tokenTransferCost != 0, 'OS0F');\n        checkOrderParams(\n            data,\n            buyParams.to,\n            buyParams.gasLimit,\n            buyParams.submitDeadline,\n            ORDER_BASE_COST.add(tokenTransferCost)\n        );\n        require(buyParams.amountOut != 0, 'OS23');\n        (address pairAddress, uint32 pairId, bool inverted) = getPair(data, buyParams.tokenIn, buyParams.tokenOut);\n        require(!getBuyDisabled(data, pairAddress), 'OS49');\n        uint256 value = msg.value;\n\n        // allocate gas refund\n        if (buyParams.tokenIn == tokenShares.weth && buyParams.wrapUnwrap) {\n            value = value.sub(buyParams.amountInMax, 'OS1E');\n        }\n        allocateGasRefund(data, value, buyParams.gasLimit);\n\n        uint256 shares = tokenShares.amountToShares(buyParams.tokenIn, buyParams.amountInMax, buyParams.wrapUnwrap);\n\n        (uint256 priceAccumulator, uint32 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();\n        enqueueBuyOrder(\n            data,\n            BuyOrder(\n                pairId,\n                inverted,\n                shares,\n                buyParams.amountOut,\n                buyParams.wrapUnwrap,\n                buyParams.to,\n                data.gasPrice,\n                buyParams.gasLimit,\n                timestamp + data.delay,\n                priceAccumulator,\n                timestamp\n            )\n        );\n    }\n\n    function checkOrderParams(\n        Data storage data,\n        address to,\n        uint256 gasLimit,\n        uint32 submitDeadline,\n        uint256 minGasLimit\n    ) private view {\n        require(submitDeadline >= block.timestamp, 'OS04');\n        require(gasLimit <= data.maxGasLimit, 'OS3E');\n        require(gasLimit >= minGasLimit, 'OS3D');\n        require(to != address(0), 'OS26');\n    }\n\n    function allocateGasRefund(\n        Data storage data,\n        uint256 value,\n        uint256 gasLimit\n    ) private returns (uint256 futureFee) {\n        futureFee = data.gasPrice.mul(gasLimit);\n        require(value >= futureFee, 'OS1E');\n        if (value > futureFee) {\n            TransferHelper.safeTransferETH(msg.sender, value.sub(futureFee), data.transferGasCosts[address(0)]);\n        }\n    }\n\n    function updateGasPrice(Data storage data, uint256 gasUsed) external {\n        uint256 scale = Math.min(gasUsed, data.maxGasPriceImpact);\n        uint256 updated = data.gasPrice.mul(data.gasPriceInertia.sub(scale)).add(tx.gasprice.mul(scale)).div(\n            data.gasPriceInertia\n        );\n        // we lower the precision for gas savings in order queue\n        data.gasPrice = updated - (updated % 1e6);\n    }\n\n    function setMaxGasLimit(Data storage data, uint256 _maxGasLimit) external {\n        require(_maxGasLimit != data.maxGasLimit, 'OS01');\n        require(_maxGasLimit <= 10000000, 'OS2B');\n        data.maxGasLimit = _maxGasLimit;\n        emit MaxGasLimitSet(_maxGasLimit);\n    }\n\n    function setGasPriceInertia(Data storage data, uint256 _gasPriceInertia) external {\n        require(_gasPriceInertia != data.gasPriceInertia, 'OS01');\n        require(_gasPriceInertia >= 1, 'OS35');\n        data.gasPriceInertia = _gasPriceInertia;\n        emit GasPriceInertiaSet(_gasPriceInertia);\n    }\n\n    function setMaxGasPriceImpact(Data storage data, uint256 _maxGasPriceImpact) external {\n        require(_maxGasPriceImpact != data.maxGasPriceImpact, 'OS01');\n        require(_maxGasPriceImpact <= data.gasPriceInertia, 'OS33');\n        data.maxGasPriceImpact = _maxGasPriceImpact;\n        emit MaxGasPriceImpactSet(_maxGasPriceImpact);\n    }\n\n    function setTransferGasCost(\n        Data storage data,\n        address token,\n        uint256 gasCost\n    ) external {\n        require(gasCost != data.transferGasCosts[token], 'OS01');\n        data.transferGasCosts[token] = gasCost;\n        emit TransferGasCostSet(token, gasCost);\n    }\n}\n"
    },
    "contracts/libraries/TokenShares.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\nimport '../interfaces/IERC20.sol';\nimport '../interfaces/IWETH.sol';\nimport './SafeMath.sol';\nimport './TransferHelper.sol';\n\nlibrary TokenShares {\n    using SafeMath for uint256;\n    using TransferHelper for address;\n\n    event UnwrapFailed(address to, uint256 amount);\n\n    struct Data {\n        mapping(address => uint256) totalShares;\n        address weth;\n    }\n\n    function setWeth(Data storage data, address _weth) internal {\n        data.weth = _weth;\n    }\n\n    function sharesToAmount(\n        Data storage data,\n        address token,\n        uint256 share\n    ) external returns (uint256) {\n        if (share == 0) {\n            return 0;\n        }\n        if (token == data.weth) {\n            return share;\n        }\n        uint256 totalTokenShares = data.totalShares[token];\n        require(totalTokenShares >= share, 'TS3A');\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        uint256 value = balance.mul(share).div(totalTokenShares);\n        data.totalShares[token] = totalTokenShares.sub(share);\n        return value;\n    }\n\n    function amountToShares(\n        Data storage data,\n        address token,\n        uint256 amount,\n        bool wrap\n    ) external returns (uint256) {\n        if (amount == 0) {\n            return 0;\n        }\n        if (token == data.weth) {\n            if (wrap) {\n                require(msg.value >= amount, 'TS03');\n                IWETH(token).deposit{ value: amount }();\n            } else {\n                token.safeTransferFrom(msg.sender, address(this), amount);\n            }\n            return amount;\n        } else {\n            uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n            uint256 totalTokenShares = data.totalShares[token];\n            require(balanceBefore > 0 || totalTokenShares == 0, 'TS30');\n            if (totalTokenShares == 0) {\n                totalTokenShares = balanceBefore;\n            }\n            token.safeTransferFrom(msg.sender, address(this), amount);\n            uint256 balanceAfter = IERC20(token).balanceOf(address(this));\n            require(balanceAfter > balanceBefore, 'TS2C');\n            if (balanceBefore > 0) {\n                uint256 newShares = totalTokenShares.mul(balanceAfter).div(balanceBefore);\n                data.totalShares[token] = newShares;\n                return newShares - totalTokenShares;\n            } else {\n                data.totalShares[token] = balanceAfter;\n                return balanceAfter;\n            }\n        }\n    }\n\n    function onUnwrapFailed(\n        Data storage data,\n        address to,\n        uint256 amount\n    ) external {\n        emit UnwrapFailed(to, amount);\n        IWETH(data.weth).deposit{ value: amount }();\n        TransferHelper.safeTransfer(data.weth, to, amount);\n    }\n}\n"
    },
    "contracts/libraries/AddLiquidity.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\nimport './TransferHelper.sol';\nimport './SafeMath.sol';\nimport './Math.sol';\nimport '../interfaces/ITwapPair.sol';\nimport '../interfaces/ITwapOracle.sol';\n\nlibrary AddLiquidity {\n    using SafeMath for uint256;\n\n    function _quote(\n        uint256 amount0,\n        uint256 reserve0,\n        uint256 reserve1\n    ) private pure returns (uint256 amountB) {\n        require(amount0 > 0, 'AL03');\n        require(reserve0 > 0 && reserve1 > 0, 'AL07');\n        amountB = amount0.mul(reserve1) / reserve0;\n    }\n\n    function addLiquidity(\n        address pair,\n        uint256 amount0Desired,\n        uint256 amount1Desired\n    ) internal view returns (uint256 amount0, uint256 amount1) {\n        if (amount0Desired == 0 || amount1Desired == 0) {\n            return (0, 0);\n        }\n        (uint256 reserve0, uint256 reserve1) = ITwapPair(pair).getReserves();\n        if (reserve0 == 0 && reserve1 == 0) {\n            (amount0, amount1) = (amount0Desired, amount1Desired);\n        } else {\n            uint256 amount1Optimal = _quote(amount0Desired, reserve0, reserve1);\n            if (amount1Optimal <= amount1Desired) {\n                (amount0, amount1) = (amount0Desired, amount1Optimal);\n            } else {\n                uint256 amount0Optimal = _quote(amount1Desired, reserve1, reserve0);\n                assert(amount0Optimal <= amount0Desired);\n                (amount0, amount1) = (amount0Optimal, amount1Desired);\n            }\n        }\n    }\n\n    function addLiquidityAndMint(\n        address pair,\n        address to,\n        address token0,\n        address token1,\n        uint256 amount0Desired,\n        uint256 amount1Desired\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\n        (uint256 amount0, uint256 amount1) = addLiquidity(pair, amount0Desired, amount1Desired);\n        if (amount0 == 0 || amount1 == 0) {\n            return (amount0Desired, amount1Desired);\n        }\n        TransferHelper.safeTransfer(token0, pair, amount0);\n        TransferHelper.safeTransfer(token1, pair, amount1);\n        ITwapPair(pair).mint(to);\n\n        amount0Left = amount0Desired.sub(amount0);\n        amount1Left = amount1Desired.sub(amount1);\n    }\n\n    function swapDeposit0(\n        address pair,\n        address token0,\n        uint256 amount0,\n        uint256 minSwapPrice,\n        bytes calldata data\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\n        uint256 amount0In = ITwapPair(pair).getDepositAmount0In(amount0, data);\n        amount1Left = ITwapPair(pair).getSwapAmount1Out(amount0In, data);\n        if (amount1Left == 0) {\n            return (amount0, amount1Left);\n        }\n        uint256 price = getPrice(amount0In, amount1Left, pair);\n        require(minSwapPrice == 0 || price >= minSwapPrice, 'AL15');\n        TransferHelper.safeTransfer(token0, pair, amount0In);\n        ITwapPair(pair).swap(0, amount1Left, address(this), data);\n        amount0Left = amount0.sub(amount0In);\n    }\n\n    function swapDeposit1(\n        address pair,\n        address token1,\n        uint256 amount1,\n        uint256 maxSwapPrice,\n        bytes calldata data\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\n        uint256 amount1In = ITwapPair(pair).getDepositAmount1In(amount1, data);\n        amount0Left = ITwapPair(pair).getSwapAmount0Out(amount1In, data);\n        if (amount0Left == 0) {\n            return (amount0Left, amount1);\n        }\n        uint256 price = getPrice(amount0Left, amount1In, pair);\n        require(maxSwapPrice == 0 || price <= maxSwapPrice, 'AL16');\n        TransferHelper.safeTransfer(token1, pair, amount1In);\n        ITwapPair(pair).swap(amount0Left, 0, address(this), data);\n        amount1Left = amount1.sub(amount1In);\n    }\n\n    function getPrice(\n        uint256 amount0,\n        uint256 amount1,\n        address pair\n    ) internal view returns (uint256) {\n        ITwapOracle oracle = ITwapOracle(ITwapPair(pair).oracle());\n        return amount1.mul(uint256(oracle.decimalsConverter())).div(amount0);\n    }\n}\n"
    },
    "contracts/libraries/WithdrawHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '../interfaces/ITwapPair.sol';\nimport '../interfaces/IWETH.sol';\nimport './Orders.sol';\n\nlibrary WithdrawHelper {\n    using SafeMath for uint256;\n\n    function _transferToken(\n        uint256 balanceBefore,\n        address token,\n        address to\n    ) internal {\n        uint256 tokenAmount = IERC20(token).balanceOf(address(this)).sub(balanceBefore);\n        TransferHelper.safeTransfer(token, to, tokenAmount);\n    }\n\n    function _unwrapWeth(\n        uint256 ethAmount,\n        address weth,\n        address to,\n        uint256 gasLimit\n    ) internal returns (bool) {\n        IWETH(weth).withdraw(ethAmount);\n        (bool success, ) = to.call{ value: ethAmount, gas: gasLimit }('');\n        return success;\n    }\n\n    function withdrawAndUnwrap(\n        address token0,\n        address token1,\n        address pair,\n        address weth,\n        address to,\n        uint256 gasLimit\n    )\n        external\n        returns (\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        bool isToken0Weth = token0 == weth;\n        address otherToken = isToken0Weth ? token1 : token0;\n\n        uint256 balanceBefore = IERC20(otherToken).balanceOf(address(this));\n        (uint256 amount0, uint256 amount1) = ITwapPair(pair).burn(address(this));\n        _transferToken(balanceBefore, otherToken, to);\n\n        bool success = _unwrapWeth(isToken0Weth ? amount0 : amount1, weth, to, gasLimit);\n\n        return (success, isToken0Weth ? amount0 : amount1, amount0, amount1);\n    }\n}\n"
    },
    "contracts/interfaces/ITwapERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\nimport './IERC20.sol';\n\ninterface ITwapERC20 is IERC20 {\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IReserves.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\ninterface IReserves {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1);\n\n    function getFees() external view returns (uint256 fee0, uint256 fee1);\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x < y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x > y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ITwapFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\ninterface ITwapFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n    event OwnerSet(address owner);\n\n    function owner() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        address oracle,\n        address trader\n    ) external returns (address pair);\n\n    function setOwner(address) external;\n\n    function setMintFee(\n        address tokenA,\n        address tokenB,\n        uint256 fee\n    ) external;\n\n    function setBurnFee(\n        address tokenA,\n        address tokenB,\n        uint256 fee\n    ) external;\n\n    function setSwapFee(\n        address tokenA,\n        address tokenB,\n        uint256 fee\n    ) external;\n\n    function setOracle(\n        address tokenA,\n        address tokenB,\n        address oracle\n    ) external;\n\n    function setTrader(\n        address tokenA,\n        address tokenB,\n        address trader\n    ) external;\n\n    function collect(\n        address tokenA,\n        address tokenB,\n        address to\n    ) external;\n\n    function withdraw(\n        address tokenA,\n        address tokenB,\n        uint256 amount,\n        address to\n    ) external;\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH4B');\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH05');\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH0E');\n    }\n\n    function safeTransferETH(\n        address to,\n        uint256 value,\n        uint256 gasLimit\n    ) internal {\n        (bool success, ) = to.call{ value: value, gas: gasLimit }('');\n        require(success, 'TH3F');\n    }\n\n    function transferETH(\n        address to,\n        uint256 value,\n        uint256 gasLimit\n    ) internal returns (bool success) {\n        (success, ) = to.call{ value: value, gas: gasLimit }('');\n    }\n}\n"
    },
    "contracts/TwapPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\nimport './interfaces/ITwapPair.sol';\nimport './libraries/Reserves.sol';\nimport './TwapLPToken.sol';\nimport './libraries/Math.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/ITwapFactory.sol';\nimport './interfaces/ITwapOracle.sol';\n\ncontract TwapPair is Reserves, TwapLPToken, ITwapPair {\n    using SafeMath for uint256;\n\n    uint256 private constant PRECISION = 10**18;\n\n    uint256 public override mintFee = 0;\n    uint256 public override burnFee = 0;\n    uint256 public override swapFee = 0;\n\n    uint256 public constant override MINIMUM_LIQUIDITY = 10**3;\n\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n    address public immutable override factory;\n    address public override token0;\n    address public override token1;\n    address public override oracle;\n    address public override trader;\n\n    uint256 private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, 'TP06');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function isContract(address addr) private view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n\n    function setMintFee(uint256 fee) external override {\n        require(msg.sender == factory, 'TP00');\n        require(fee != mintFee, 'TP01');\n        mintFee = fee;\n        emit SetMintFee(fee);\n    }\n\n    function setBurnFee(uint256 fee) external override {\n        require(msg.sender == factory, 'TP00');\n        require(fee != burnFee, 'TP01');\n        burnFee = fee;\n        emit SetBurnFee(fee);\n    }\n\n    function setSwapFee(uint256 fee) external override {\n        require(msg.sender == factory, 'TP00');\n        require(fee != swapFee, 'TP01');\n        swapFee = fee;\n        emit SetSwapFee(fee);\n    }\n\n    function setOracle(address _oracle) external override {\n        require(msg.sender == factory, 'TP00');\n        require(_oracle != oracle, 'TP01');\n        require(_oracle != address(0), 'TP02');\n        require(isContract(_oracle), 'TP1D');\n        oracle = _oracle;\n        emit SetOracle(_oracle);\n    }\n\n    function setTrader(address _trader) external override {\n        require(msg.sender == factory, 'TP00');\n        require(_trader != trader, 'TP01');\n        // Allow trader to be set as address(0) to disable interaction\n        trader = _trader;\n        emit SetTrader(_trader);\n    }\n\n    function collect(address to) external override lock {\n        require(msg.sender == factory, 'TP00');\n        require(to != address(0), 'TP02');\n        (uint256 fee0, uint256 fee1) = getFees();\n        if (fee0 > 0) _safeTransfer(token0, to, fee0);\n        if (fee1 > 0) _safeTransfer(token1, to, fee1);\n        setFees(0, 0);\n        _sync();\n    }\n\n    function _safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TP05');\n    }\n\n    function canTrade(address user) private view returns (bool) {\n        return user == trader || user == factory;\n    }\n\n    constructor() {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(\n        address _token0,\n        address _token1,\n        address _oracle,\n        address _trader\n    ) external override {\n        require(msg.sender == factory, 'TP00');\n        require(_oracle != address(0), 'TP02');\n        require(isContract(_oracle), 'TP1D');\n        require(isContract(_token0) && isContract(_token1), 'TP10');\n        token0 = _token0;\n        token1 = _token1;\n        oracle = _oracle;\n        trader = _trader;\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external override lock returns (uint256 liquidityOut) {\n        require(canTrade(msg.sender), 'TP0C');\n        require(to != address(0), 'TP02');\n        (uint112 reserve0, uint112 reserve1) = getReserves();\n        (uint256 balance0, uint256 balance1) = getBalances(token0, token1);\n        uint256 amount0In = balance0.sub(reserve0);\n        uint256 amount1In = balance1.sub(reserve1);\n\n        uint256 _totalSupply = totalSupply; // gas savings\n        if (_totalSupply == 0) {\n            liquidityOut = Math.sqrt(amount0In.mul(amount1In)).sub(MINIMUM_LIQUIDITY);\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidityOut = Math.min(amount0In.mul(_totalSupply) / reserve0, amount1In.mul(_totalSupply) / reserve1);\n        }\n\n        require(liquidityOut > 0, 'TP38');\n        if (mintFee > 0) {\n            uint256 fee = liquidityOut.mul(mintFee).div(PRECISION);\n            liquidityOut = liquidityOut.sub(fee);\n            _mint(factory, fee);\n        }\n        _mint(to, liquidityOut);\n\n        setReserves(balance0, balance1);\n\n        emit Mint(msg.sender, amount0In, amount1In, liquidityOut, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external override lock returns (uint256 amount0Out, uint256 amount1Out) {\n        require(canTrade(msg.sender), 'TP0C');\n        require(to != address(0), 'TP02');\n        uint256 _totalSupply = totalSupply; // gas savings\n        require(_totalSupply > 0, 'TP36');\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        (uint256 balance0, uint256 balance1) = getBalances(token0, token1);\n        uint256 liquidityIn = balanceOf[address(this)];\n\n        if (msg.sender != factory && burnFee > 0) {\n            uint256 fee = liquidityIn.mul(burnFee).div(PRECISION);\n            liquidityIn = liquidityIn.sub(fee);\n            _transfer(address(this), factory, fee);\n        }\n        _burn(address(this), liquidityIn);\n\n        amount0Out = liquidityIn.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1Out = liquidityIn.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0Out > 0 && amount1Out > 0, 'TP39');\n\n        _safeTransfer(_token0, to, amount0Out);\n        _safeTransfer(_token1, to, amount1Out);\n\n        (balance0, balance1) = getBalances(token0, token1);\n        setReserves(balance0, balance1);\n\n        emit Burn(msg.sender, amount0Out, amount1Out, liquidityIn, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external override lock {\n        require(canTrade(msg.sender), 'TP0C');\n        require(to != address(0), 'TP02');\n        require((amount0Out > 0 && amount1Out == 0) || (amount1Out > 0 && amount0Out == 0), 'TP31');\n        (uint112 _reserve0, uint112 _reserve1) = getReserves();\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'TP07');\n\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 && to != _token1, 'TP2D');\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        }\n        (uint256 balance0, uint256 balance1) = getBalances(token0, token1);\n\n        if (amount0Out > 0) {\n            // trading token1 for token0\n            require(balance1 > _reserve1, 'TP08');\n            uint256 amount1In = balance1 - _reserve1;\n\n            emit Swap(msg.sender, 0, amount1In, amount0Out, 0, to);\n\n            uint256 fee1 = amount1In.mul(swapFee).div(PRECISION);\n            uint256 balance1After = balance1.sub(fee1);\n            uint256 balance0After = ITwapOracle(oracle).tradeY(balance1After, _reserve0, _reserve1, data);\n            require(balance0 >= balance0After, 'TP2E');\n            uint256 fee0 = balance0.sub(balance0After);\n            addFees(fee0, fee1);\n            setReserves(balance0After, balance1After);\n        } else {\n            // trading token0 for token1\n            require(balance0 > _reserve0, 'TP08');\n            uint256 amount0In = balance0 - _reserve0;\n\n            emit Swap(msg.sender, amount0In, 0, 0, amount1Out, to);\n\n            uint256 fee0 = amount0In.mul(swapFee).div(PRECISION);\n            uint256 balance0After = balance0.sub(fee0);\n            uint256 balance1After = ITwapOracle(oracle).tradeX(balance0After, _reserve0, _reserve1, data);\n            require(balance1 >= balance1After, 'TP2E');\n            uint256 fee1 = balance1.sub(balance1After);\n            addFees(fee0, fee1);\n            setReserves(balance0After, balance1After);\n        }\n    }\n\n    function sync() external override lock {\n        require(canTrade(msg.sender), 'TP0C');\n        _sync();\n    }\n\n    // force reserves to match balances\n    function _sync() internal {\n        syncReserves(token0, token1);\n        uint256 tokens = balanceOf[address(this)];\n        if (tokens > 0) {\n            _transfer(address(this), factory, tokens);\n        }\n    }\n\n    function getSwapAmount0In(uint256 amount1Out, bytes calldata data)\n        public\n        view\n        override\n        returns (uint256 swapAmount0In)\n    {\n        (uint112 reserve0, uint112 reserve1) = getReserves();\n        uint256 balance1After = uint256(reserve1).sub(amount1Out);\n        uint256 balance0After = ITwapOracle(oracle).tradeY(balance1After, reserve0, reserve1, data);\n        return balance0After.sub(uint256(reserve0)).mul(PRECISION).ceil_div(PRECISION.sub(swapFee));\n    }\n\n    function getSwapAmount1In(uint256 amount0Out, bytes calldata data)\n        public\n        view\n        override\n        returns (uint256 swapAmount1In)\n    {\n        (uint112 reserve0, uint112 reserve1) = getReserves();\n        uint256 balance0After = uint256(reserve0).sub(amount0Out);\n        uint256 balance1After = ITwapOracle(oracle).tradeX(balance0After, reserve0, reserve1, data);\n        return balance1After.add(1).sub(uint256(reserve1)).mul(PRECISION).ceil_div(PRECISION.sub(swapFee));\n    }\n\n    function getSwapAmount0Out(uint256 amount1In, bytes calldata data)\n        public\n        view\n        override\n        returns (uint256 swapAmount0Out)\n    {\n        (uint112 reserve0, uint112 reserve1) = getReserves();\n        uint256 fee = amount1In.mul(swapFee).div(PRECISION);\n        uint256 balance0After = ITwapOracle(oracle).tradeY(\n            uint256(reserve1).add(amount1In).sub(fee),\n            reserve0,\n            reserve1,\n            data\n        );\n        return uint256(reserve0).sub(balance0After);\n    }\n\n    function getSwapAmount1Out(uint256 amount0In, bytes calldata data)\n        public\n        view\n        override\n        returns (uint256 swapAmount1Out)\n    {\n        (uint112 reserve0, uint112 reserve1) = getReserves();\n        uint256 fee = amount0In.mul(swapFee).div(PRECISION);\n        uint256 balance1After = ITwapOracle(oracle).tradeX(\n            uint256(reserve0).add(amount0In).sub(fee),\n            reserve0,\n            reserve1,\n            data\n        );\n        return uint256(reserve1).sub(balance1After);\n    }\n\n    function getDepositAmount0In(uint256 amount0, bytes calldata data) external view override returns (uint256) {\n        (uint112 reserve0, uint112 reserve1) = getReserves();\n        return ITwapOracle(oracle).depositTradeXIn(amount0, reserve0, reserve1, data);\n    }\n\n    function getDepositAmount1In(uint256 amount1, bytes calldata data) external view override returns (uint256) {\n        (uint112 reserve0, uint112 reserve1) = getReserves();\n        return ITwapOracle(oracle).depositTradeYIn(amount1, reserve0, reserve1, data);\n    }\n}\n"
    },
    "contracts/libraries/Reserves.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\nimport '../interfaces/IReserves.sol';\nimport '../interfaces/IERC20.sol';\nimport '../libraries/SafeMath.sol';\n\ncontract Reserves is IReserves {\n    using SafeMath for uint256;\n\n    uint112 private reserve0;\n    uint112 private reserve1;\n\n    uint112 private fee0;\n    uint112 private fee1;\n\n    function getReserves() public view override returns (uint112, uint112) {\n        return (reserve0, reserve1);\n    }\n\n    function setReserves(uint256 balance0MinusFee, uint256 balance1MinusFee) internal {\n        require(balance0MinusFee != 0 && balance1MinusFee != 0, 'RS09');\n        reserve0 = balance0MinusFee.toUint112();\n        reserve1 = balance1MinusFee.toUint112();\n    }\n\n    function syncReserves(address token0, address token1) internal {\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n\n        uint256 oldBalance0 = uint256(reserve0) + fee0;\n        uint256 oldBalance1 = uint256(reserve1) + fee1;\n\n        if (balance0 != oldBalance0 || balance1 != oldBalance1) {\n            if (oldBalance0 != 0) {\n                fee0 = (balance0.mul(fee0).div(oldBalance0)).toUint112();\n            }\n            if (oldBalance1 != 0) {\n                fee1 = (balance1.mul(fee1).div(oldBalance1)).toUint112();\n            }\n\n            setReserves(balance0.sub(fee0), balance1.sub(fee1));\n        }\n    }\n\n    function getFees() public view override returns (uint256, uint256) {\n        return (fee0, fee1);\n    }\n\n    function addFees(uint256 _fee0, uint256 _fee1) internal {\n        setFees(_fee0.add(fee0), _fee1.add(fee1));\n    }\n\n    function setFees(uint256 _fee0, uint256 _fee1) internal {\n        fee0 = _fee0.toUint112();\n        fee1 = _fee1.toUint112();\n    }\n\n    function getBalances(address token0, address token1) internal returns (uint256, uint256) {\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        if (fee0 > balance0) {\n            fee0 = uint112(balance0);\n        }\n        if (fee1 > balance1) {\n            fee1 = uint112(balance1);\n        }\n        return (balance0.sub(fee0), balance1.sub(fee1));\n    }\n}\n"
    },
    "contracts/TwapLPToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\nimport './libraries/AbstractERC20.sol';\n\ncontract TwapLPToken is AbstractERC20 {\n    constructor() {\n        name = 'Twap LP';\n        symbol = 'TWAP-LP';\n        decimals = 18;\n    }\n}\n"
    },
    "contracts/libraries/AbstractERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\nimport '../interfaces/ITwapERC20.sol';\nimport './SafeMath.sol';\n\nabstract contract AbstractERC20 is ITwapERC20 {\n    using SafeMath for uint256;\n\n    string public override name;\n    string public override symbol;\n    uint8 public override decimals;\n\n    uint256 public override totalSupply;\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public override nonces;\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external override returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external override returns (bool) {\n        uint256 currentAllowance = allowance[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, 'TA48');\n        _approve(msg.sender, spender, currentAllowance.sub(subtractedValue));\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external override returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(deadline >= block.timestamp, 'TA04');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                getDomainSeparator(),\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'TA2F');\n        _approve(owner, spender, value);\n    }\n\n    function getDomainSeparator() public view returns (bytes32) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return\n            keccak256(\n                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes('1')), chainId, address(this))\n            );\n    }\n}\n"
    },
    "contracts/TwapFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\nimport './interfaces/ITwapFactory.sol';\nimport './TwapPair.sol';\n\ncontract TwapFactory is ITwapFactory {\n    mapping(address => mapping(address => address)) public override getPair;\n    address[] public override allPairs;\n    address public override owner;\n\n    constructor() {\n        owner = msg.sender;\n\n        emit OwnerSet(msg.sender);\n    }\n\n    function allPairsLength() external view override returns (uint256) {\n        return allPairs.length;\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        address oracle,\n        address trader\n    ) external override returns (address pair) {\n        require(msg.sender == owner, 'TF00');\n        require(tokenA != tokenB, 'TF3B');\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'TF02');\n        require(getPair[token0][token1] == address(0), 'TF18'); // single check is sufficient\n        bytes memory bytecode = type(TwapPair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        ITwapPair(pair).initialize(token0, token1, oracle, trader);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n\n    function setOwner(address _owner) external override {\n        require(msg.sender == owner, 'TF00');\n        require(_owner != owner, 'TF01');\n        require(_owner != address(0), 'TF02');\n        owner = _owner;\n        emit OwnerSet(_owner);\n    }\n\n    function setMintFee(\n        address tokenA,\n        address tokenB,\n        uint256 fee\n    ) external override {\n        require(msg.sender == owner, 'TF00');\n        _getPair(tokenA, tokenB).setMintFee(fee);\n    }\n\n    function setBurnFee(\n        address tokenA,\n        address tokenB,\n        uint256 fee\n    ) external override {\n        require(msg.sender == owner, 'TF00');\n        _getPair(tokenA, tokenB).setBurnFee(fee);\n    }\n\n    function setSwapFee(\n        address tokenA,\n        address tokenB,\n        uint256 fee\n    ) external override {\n        require(msg.sender == owner, 'TF00');\n        _getPair(tokenA, tokenB).setSwapFee(fee);\n    }\n\n    function setOracle(\n        address tokenA,\n        address tokenB,\n        address oracle\n    ) external override {\n        require(msg.sender == owner, 'TF00');\n        _getPair(tokenA, tokenB).setOracle(oracle);\n    }\n\n    function setTrader(\n        address tokenA,\n        address tokenB,\n        address trader\n    ) external override {\n        require(msg.sender == owner, 'TF00');\n        _getPair(tokenA, tokenB).setTrader(trader);\n    }\n\n    function collect(\n        address tokenA,\n        address tokenB,\n        address to\n    ) external override {\n        require(msg.sender == owner, 'TF00');\n        _getPair(tokenA, tokenB).collect(to);\n    }\n\n    function withdraw(\n        address tokenA,\n        address tokenB,\n        uint256 amount,\n        address to\n    ) external override {\n        require(msg.sender == owner, 'TF00');\n        ITwapPair pair = _getPair(tokenA, tokenB);\n        pair.transfer(address(pair), amount);\n        pair.burn(to);\n    }\n\n    function _getPair(address tokenA, address tokenB) internal view returns (ITwapPair pair) {\n        pair = ITwapPair(getPair[tokenA][tokenB]);\n        require(address(pair) != address(0), 'TF19');\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {
      "contracts/libraries/AddLiquidity.sol": {
        "AddLiquidity": "0xb291730099d3ac9975abd4003ba3bd47401fd2fd"
      },
      "contracts/libraries/Orders.sol": {
        "Orders": "0x6336788a85f54d8856782d58c1ca63c7d3844531"
      },
      "contracts/libraries/TokenShares.sol": {
        "TokenShares": "0xb28c804e3dacff80701bbbafd106dbfb416a5168"
      },
      "contracts/libraries/WithdrawHelper.sol": {
        "WithdrawHelper": "0x6195015b38773f468dd43620dd5a64e9bb63c2e3"
      }
    }
  }
}}