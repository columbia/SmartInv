{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "berlin",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@thesis/solidity-contracts/contracts/token/ERC20WithPermit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./IERC20WithPermit.sol\";\nimport \"./IReceiveApproval.sol\";\n\n/// @title  ERC20WithPermit\n/// @notice Burnable ERC20 token with EIP2612 permit functionality. User can\n///         authorize a transfer of their token with a signature conforming\n///         EIP712 standard instead of an on-chain transaction from their\n///         address. Anyone can submit this signature on the user's behalf by\n///         calling the permit function, as specified in EIP2612 standard,\n///         paying gas fees, and possibly performing other actions in the same\n///         transaction.\ncontract ERC20WithPermit is IERC20WithPermit, Ownable {\n    /// @notice The amount of tokens owned by the given account.\n    mapping(address => uint256) public override balanceOf;\n\n    /// @notice The remaining number of tokens that spender will be\n    ///         allowed to spend on behalf of owner through `transferFrom` and\n    ///         `burnFrom`. This is zero by default.\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    /// @notice Returns the current nonce for EIP2612 permission for the\n    ///         provided token owner for a replay protection. Used to construct\n    ///         EIP2612 signature provided to `permit` function.\n    mapping(address => uint256) public override nonces;\n\n    uint256 public immutable cachedChainId;\n    bytes32 public immutable cachedDomainSeparator;\n\n    /// @notice Returns EIP2612 Permit message hash. Used to construct EIP2612\n    ///         signature provided to `permit` function.\n    bytes32 public constant override PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n    /// @notice The amount of tokens in existence.\n    uint256 public override totalSupply;\n\n    /// @notice The name of the token.\n    string public override name;\n\n    /// @notice The symbol of the token.\n    string public override symbol;\n\n    /// @notice The decimals places of the token.\n    uint8 public constant override decimals = 18;\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n\n        cachedChainId = block.chainid;\n        cachedDomainSeparator = buildDomainSeparator();\n    }\n\n    /// @notice Moves `amount` tokens from the caller's account to `recipient`.\n    /// @return True if the operation succeeded, reverts otherwise.\n    /// @dev Requirements:\n    ///       - `recipient` cannot be the zero address,\n    ///       - the caller must have a balance of at least `amount`.\n    function transfer(address recipient, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /// @notice Moves `amount` tokens from `sender` to `recipient` using the\n    ///         allowance mechanism. `amount` is then deducted from the caller's\n    ///         allowance unless the allowance was made for `type(uint256).max`.\n    /// @return True if the operation succeeded, reverts otherwise.\n    /// @dev Requirements:\n    ///      - `sender` and `recipient` cannot be the zero address,\n    ///      - `sender` must have a balance of at least `amount`,\n    ///      - the caller must have allowance for `sender`'s tokens of at least\n    ///        `amount`.\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external override returns (bool) {\n        uint256 currentAllowance = allowance[sender][msg.sender];\n        if (currentAllowance != type(uint256).max) {\n            require(\n                currentAllowance >= amount,\n                \"Transfer amount exceeds allowance\"\n            );\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    /// @notice EIP2612 approval made with secp256k1 signature.\n    ///         Users can authorize a transfer of their tokens with a signature\n    ///         conforming EIP712 standard, rather than an on-chain transaction\n    ///         from their address. Anyone can submit this signature on the\n    ///         user's behalf by calling the permit function, paying gas fees,\n    ///         and possibly performing other actions in the same transaction.\n    /// @dev    The deadline argument can be set to `type(uint256).max to create\n    ///         permits that effectively never expire.  If the `amount` is set\n    ///         to `type(uint256).max` then `transferFrom` and `burnFrom` will\n    ///         not reduce an allowance.\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        /* solhint-disable-next-line not-rely-on-time */\n        require(deadline >= block.timestamp, \"Permission expired\");\n\n        // Validate `s` and `v` values for a malleability concern described in EIP2.\n        // Only signatures with `s` value in the lower half of the secp256k1\n        // curve's order and `v` value of 27 or 28 are considered valid.\n        require(\n            uint256(s) <=\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"Invalid signature 's' value\"\n        );\n        require(v == 27 || v == 28, \"Invalid signature 'v' value\");\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR(),\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        amount,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"Invalid signature\"\n        );\n        _approve(owner, spender, amount);\n    }\n\n    /// @notice Creates `amount` tokens and assigns them to `account`,\n    ///         increasing the total supply.\n    /// @dev Requirements:\n    ///      - `recipient` cannot be the zero address.\n    function mint(address recipient, uint256 amount) external onlyOwner {\n        require(recipient != address(0), \"Mint to the zero address\");\n\n        beforeTokenTransfer(address(0), recipient, amount);\n\n        totalSupply += amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(address(0), recipient, amount);\n    }\n\n    /// @notice Destroys `amount` tokens from the caller.\n    /// @dev Requirements:\n    ///       - the caller must have a balance of at least `amount`.\n    function burn(uint256 amount) external override {\n        _burn(msg.sender, amount);\n    }\n\n    /// @notice Destroys `amount` of tokens from `account` using the allowance\n    ///         mechanism. `amount` is then deducted from the caller's allowance\n    ///         unless the allowance was made for `type(uint256).max`.\n    /// @dev Requirements:\n    ///      - `account` must have a balance of at least `amount`,\n    ///      - the caller must have allowance for `account`'s tokens of at least\n    ///        `amount`.\n    function burnFrom(address account, uint256 amount) external override {\n        uint256 currentAllowance = allowance[account][msg.sender];\n        if (currentAllowance != type(uint256).max) {\n            require(\n                currentAllowance >= amount,\n                \"Burn amount exceeds allowance\"\n            );\n            _approve(account, msg.sender, currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n\n    /// @notice Calls `receiveApproval` function on spender previously approving\n    ///         the spender to withdraw from the caller multiple times, up to\n    ///         the `amount` amount. If this function is called again, it\n    ///         overwrites the current allowance with `amount`. Reverts if the\n    ///         approval reverted or if `receiveApproval` call on the spender\n    ///         reverted.\n    /// @return True if both approval and `receiveApproval` calls succeeded.\n    /// @dev If the `amount` is set to `type(uint256).max` then\n    ///      `transferFrom` and `burnFrom` will not reduce an allowance.\n    function approveAndCall(\n        address spender,\n        uint256 amount,\n        bytes memory extraData\n    ) external override returns (bool) {\n        if (approve(spender, amount)) {\n            IReceiveApproval(spender).receiveApproval(\n                msg.sender,\n                amount,\n                address(this),\n                extraData\n            );\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's\n    ///         tokens.\n    /// @return True if the operation succeeded.\n    /// @dev If the `amount` is set to `type(uint256).max` then\n    ///      `transferFrom` and `burnFrom` will not reduce an allowance.\n    ///      Beware that changing an allowance with this method brings the risk\n    ///      that someone may use both the old and the new allowance by\n    ///      unfortunate transaction ordering. One possible solution to mitigate\n    ///      this race condition is to first reduce the spender's allowance to 0\n    ///      and set the desired value afterwards:\n    ///      https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @notice Returns hash of EIP712 Domain struct with the token name as\n    ///         a signing domain and token contract as a verifying contract.\n    ///         Used to construct EIP2612 signature provided to `permit`\n    ///         function.\n    /* solhint-disable-next-line func-name-mixedcase */\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\n        // As explained in EIP-2612, if the DOMAIN_SEPARATOR contains the\n        // chainId and is defined at contract deployment instead of\n        // reconstructed for every signature, there is a risk of possible replay\n        // attacks between chains in the event of a future chain split.\n        // To address this issue, we check the cached chain ID against the\n        // current one and in case they are different, we build domain separator\n        // from scratch.\n        if (block.chainid == cachedChainId) {\n            return cachedDomainSeparator;\n        } else {\n            return buildDomainSeparator();\n        }\n    }\n\n    /// @dev Hook that is called before any transfer of tokens. This includes\n    ///      minting and burning.\n    ///\n    /// Calling conditions:\n    /// - when `from` and `to` are both non-zero, `amount` of `from`'s tokens\n    ///   will be to transferred to `to`.\n    /// - when `from` is zero, `amount` tokens will be minted for `to`.\n    /// - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n    /// - `from` and `to` are never both zero.\n    // slither-disable-next-line dead-code\n    function beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function _burn(address account, uint256 amount) internal {\n        uint256 currentBalance = balanceOf[account];\n        require(currentBalance >= amount, \"Burn amount exceeds balance\");\n\n        beforeTokenTransfer(account, address(0), amount);\n\n        balanceOf[account] = currentBalance - amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) private {\n        require(sender != address(0), \"Transfer from the zero address\");\n        require(recipient != address(0), \"Transfer to the zero address\");\n        require(recipient != address(this), \"Transfer to the token address\");\n\n        beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = balanceOf[sender];\n        require(senderBalance >= amount, \"Transfer amount exceeds balance\");\n        balanceOf[sender] = senderBalance - amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        require(owner != address(0), \"Approve from the zero address\");\n        require(spender != address(0), \"Approve to the zero address\");\n        allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function buildDomainSeparator() private view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(name)),\n                    keccak256(bytes(\"1\")),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n}\n"
    },
    "@thesis/solidity-contracts/contracts/token/IApproveAndCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\n/// @notice An interface that should be implemented by tokens supporting\n///         `approveAndCall`/`receiveApproval` pattern.\ninterface IApproveAndCall {\n    /// @notice Executes `receiveApproval` function on spender as specified in\n    ///         `IReceiveApproval` interface. Approves spender to withdraw from\n    ///         the caller multiple times, up to the `amount`. If this\n    ///         function is called again, it overwrites the current allowance\n    ///         with `amount`. Reverts if the approval reverted or if\n    ///         `receiveApproval` call on the spender reverted.\n    function approveAndCall(\n        address spender,\n        uint256 amount,\n        bytes memory extraData\n    ) external returns (bool);\n}\n"
    },
    "@thesis/solidity-contracts/contracts/token/IERC20WithPermit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./IApproveAndCall.sol\";\n\n/// @title  IERC20WithPermit\n/// @notice Burnable ERC20 token with EIP2612 permit functionality. User can\n///         authorize a transfer of their token with a signature conforming\n///         EIP712 standard instead of an on-chain transaction from their\n///         address. Anyone can submit this signature on the user's behalf by\n///         calling the permit function, as specified in EIP2612 standard,\n///         paying gas fees, and possibly performing other actions in the same\n///         transaction.\ninterface IERC20WithPermit is IERC20, IERC20Metadata, IApproveAndCall {\n    /// @notice EIP2612 approval made with secp256k1 signature.\n    ///         Users can authorize a transfer of their tokens with a signature\n    ///         conforming EIP712 standard, rather than an on-chain transaction\n    ///         from their address. Anyone can submit this signature on the\n    ///         user's behalf by calling the permit function, paying gas fees,\n    ///         and possibly performing other actions in the same transaction.\n    /// @dev    The deadline argument can be set to `type(uint256).max to create\n    ///         permits that effectively never expire.\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /// @notice Destroys `amount` tokens from the caller.\n    function burn(uint256 amount) external;\n\n    /// @notice Destroys `amount` of tokens from `account`, deducting the amount\n    ///         from caller's allowance.\n    function burnFrom(address account, uint256 amount) external;\n\n    /// @notice Returns hash of EIP712 Domain struct with the token name as\n    ///         a signing domain and token contract as a verifying contract.\n    ///         Used to construct EIP2612 signature provided to `permit`\n    ///         function.\n    /* solhint-disable-next-line func-name-mixedcase */\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /// @notice Returns the current nonce for EIP2612 permission for the\n    ///         provided token owner for a replay protection. Used to construct\n    ///         EIP2612 signature provided to `permit` function.\n    function nonces(address owner) external view returns (uint256);\n\n    /// @notice Returns EIP2612 Permit message hash. Used to construct EIP2612\n    ///         signature provided to `permit` function.\n    /* solhint-disable-next-line func-name-mixedcase */\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n}\n"
    },
    "@thesis/solidity-contracts/contracts/token/IReceiveApproval.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\n/// @notice An interface that should be implemented by contracts supporting\n///         `approveAndCall`/`receiveApproval` pattern.\ninterface IReceiveApproval {\n    /// @notice Receives approval to spend tokens. Called as a result of\n    ///         `approveAndCall` call on the token.\n    function receiveApproval(\n        address from,\n        uint256 amount,\n        address token,\n        bytes calldata extraData\n    ) external;\n}\n"
    },
    "contracts/AssetPool.sol": {
      "content": "// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.5;\n\nimport \"./interfaces/IAssetPool.sol\";\nimport \"./interfaces/IAssetPoolUpgrade.sol\";\nimport \"./RewardsPool.sol\";\nimport \"./UnderwriterToken.sol\";\nimport \"./GovernanceUtils.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Asset Pool\n/// @notice Asset pool is a component of a Coverage Pool. Asset Pool\n///         accepts a single ERC20 token as collateral, and returns an\n///         underwriter token. For example, an asset pool might accept deposits\n///         in KEEP in return for covKEEP underwriter tokens. Underwriter tokens\n///         represent an ownership share in the underlying collateral of the\n///         Asset Pool.\ncontract AssetPool is Ownable, IAssetPool {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for UnderwriterToken;\n\n    IERC20 public immutable collateralToken;\n    UnderwriterToken public immutable underwriterToken;\n\n    RewardsPool public immutable rewardsPool;\n\n    IAssetPoolUpgrade public newAssetPool;\n\n    /// @notice The time it takes the underwriter to withdraw their collateral\n    ///         and rewards from the pool. This is the time that needs to pass\n    ///         between initiating and completing the withdrawal. During that\n    ///         time, underwriter is still earning rewards and their share of\n    ///         the pool is still a subject of a possible coverage claim.\n    uint256 public withdrawalDelay = 21 days;\n    uint256 public newWithdrawalDelay;\n    uint256 public withdrawalDelayChangeInitiated;\n\n    /// @notice The time the underwriter has after the withdrawal delay passed\n    ///         to complete the withdrawal. During that time, underwriter is\n    ///         still earning rewards and their share of the pool is still\n    ///         a subject of a possible coverage claim.\n    ///         After the withdrawal timeout elapses, tokens stay in the pool\n    ///         and the underwriter has to initiate the withdrawal again and\n    ///         wait for the full withdrawal delay to complete the withdrawal.\n    uint256 public withdrawalTimeout = 2 days;\n    uint256 public newWithdrawalTimeout;\n    uint256 public withdrawalTimeoutChangeInitiated;\n\n    mapping(address => uint256) public withdrawalInitiatedTimestamp;\n    mapping(address => uint256) public pendingWithdrawal;\n\n    event Deposited(\n        address indexed underwriter,\n        uint256 amount,\n        uint256 covAmount\n    );\n\n    event CoverageClaimed(\n        address indexed recipient,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    event WithdrawalInitiated(\n        address indexed underwriter,\n        uint256 covAmount,\n        uint256 timestamp\n    );\n    event WithdrawalCompleted(\n        address indexed underwriter,\n        uint256 amount,\n        uint256 covAmount,\n        uint256 timestamp\n    );\n\n    event ApprovedAssetPoolUpgrade(address newAssetPool);\n    event CancelledAssetPoolUpgrade(address cancelledAssetPool);\n    event AssetPoolUpgraded(\n        address indexed underwriter,\n        uint256 collateralAmount,\n        uint256 covAmount,\n        uint256 timestamp\n    );\n\n    event WithdrawalDelayUpdateStarted(\n        uint256 withdrawalDelay,\n        uint256 timestamp\n    );\n    event WithdrawalDelayUpdated(uint256 withdrawalDelay);\n    event WithdrawalTimeoutUpdateStarted(\n        uint256 withdrawalTimeout,\n        uint256 timestamp\n    );\n    event WithdrawalTimeoutUpdated(uint256 withdrawalTimeout);\n\n    /// @notice Reverts if the withdrawal governance delay has not passed yet or\n    ///         if the change was not yet initiated.\n    /// @param changeInitiatedTimestamp The timestamp at which the change has\n    ///        been initiated\n    modifier onlyAfterWithdrawalGovernanceDelay(\n        uint256 changeInitiatedTimestamp\n    ) {\n        require(changeInitiatedTimestamp > 0, \"Change not initiated\");\n        require(\n            /* solhint-disable-next-line not-rely-on-time */\n            block.timestamp - changeInitiatedTimestamp >=\n                withdrawalGovernanceDelay(),\n            \"Governance delay has not elapsed\"\n        );\n        _;\n    }\n\n    constructor(\n        IERC20 _collateralToken,\n        UnderwriterToken _underwriterToken,\n        address rewardsManager\n    ) {\n        collateralToken = _collateralToken;\n        underwriterToken = _underwriterToken;\n\n        rewardsPool = new RewardsPool(\n            _collateralToken,\n            address(this),\n            rewardsManager\n        );\n    }\n\n    /// @notice Accepts the given amount of collateral token as a deposit and\n    ///         mints underwriter tokens representing pool's ownership.\n    ///         Optional data in extraData may include a minimal amount of\n    ///         underwriter tokens expected to be minted for a depositor. There\n    ///         are cases when an amount of minted tokens matters for a\n    ///         depositor, as tokens might be used in third party exchanges.\n    /// @dev This function is a shortcut for approve + deposit.\n    function receiveApproval(\n        address from,\n        uint256 amount,\n        address token,\n        bytes calldata extraData\n    ) external {\n        require(msg.sender == token, \"Only token caller allowed\");\n        require(\n            token == address(collateralToken),\n            \"Unsupported collateral token\"\n        );\n\n        uint256 toMint = _calculateTokensToMint(amount);\n        if (extraData.length != 0) {\n            require(extraData.length == 32, \"Unexpected data length\");\n            uint256 minAmountToMint = abi.decode(extraData, (uint256));\n            require(\n                minAmountToMint <= toMint,\n                \"Amount to mint is smaller than the required minimum\"\n            );\n        }\n\n        _deposit(from, amount, toMint);\n    }\n\n    /// @notice Accepts the given amount of collateral token as a deposit and\n    ///         mints underwriter tokens representing pool's ownership.\n    /// @dev Before calling this function, collateral token needs to have the\n    ///      required amount accepted to transfer to the asset pool.\n    /// @param amountToDeposit Collateral tokens amount that a user deposits to\n    ///                        the asset pool\n    /// @return The amount of minted underwriter tokens\n    function deposit(uint256 amountToDeposit)\n        external\n        override\n        returns (uint256)\n    {\n        uint256 toMint = _calculateTokensToMint(amountToDeposit);\n        _deposit(msg.sender, amountToDeposit, toMint);\n        return toMint;\n    }\n\n    /// @notice Accepts the given amount of collateral token as a deposit and\n    ///         mints at least a minAmountToMint underwriter tokens representing\n    ///         pool's ownership.\n    /// @dev Before calling this function, collateral token needs to have the\n    ///      required amount accepted to transfer to the asset pool.\n    /// @param amountToDeposit Collateral tokens amount that a user deposits to\n    ///                        the asset pool\n    /// @param minAmountToMint Underwriter minimal tokens amount that a user\n    ///                        expects to receive in exchange for the deposited\n    ///                        collateral tokens\n    /// @return The amount of minted underwriter tokens\n    function depositWithMin(uint256 amountToDeposit, uint256 minAmountToMint)\n        external\n        override\n        returns (uint256)\n    {\n        uint256 toMint = _calculateTokensToMint(amountToDeposit);\n\n        require(\n            minAmountToMint <= toMint,\n            \"Amount to mint is smaller than the required minimum\"\n        );\n\n        _deposit(msg.sender, amountToDeposit, toMint);\n        return toMint;\n    }\n\n    /// @notice Initiates the withdrawal of collateral and rewards from the\n    ///         pool. Must be followed with completeWithdrawal call after the\n    ///         withdrawal delay passes. Accepts the amount of underwriter\n    ///         tokens representing the share of the pool that should be\n    ///         withdrawn. Can be called multiple times increasing the pool share\n    ///         to withdraw and resetting the withdrawal initiated timestamp for\n    ///         each call. Can be called with 0 covAmount to reset the\n    ///         withdrawal initiated timestamp if the underwriter has a pending\n    ///         withdrawal. In practice 0 covAmount should be used only to\n    ///         initiate the withdrawal again in case one did not complete the\n    ///         withdrawal before the withdrawal timeout elapsed.\n    /// @dev Before calling this function, underwriter token needs to have the\n    ///      required amount accepted to transfer to the asset pool.\n    function initiateWithdrawal(uint256 covAmount) external override {\n        uint256 pending = pendingWithdrawal[msg.sender];\n        require(\n            covAmount > 0 || pending > 0,\n            \"Underwriter token amount must be greater than 0\"\n        );\n\n        pending += covAmount;\n        pendingWithdrawal[msg.sender] = pending;\n        /* solhint-disable not-rely-on-time */\n        withdrawalInitiatedTimestamp[msg.sender] = block.timestamp;\n\n        emit WithdrawalInitiated(msg.sender, pending, block.timestamp);\n        /* solhint-enable not-rely-on-time */\n\n        if (covAmount > 0) {\n            underwriterToken.safeTransferFrom(\n                msg.sender,\n                address(this),\n                covAmount\n            );\n        }\n    }\n\n    /// @notice Completes the previously initiated withdrawal for the\n    ///         underwriter. Anyone can complete the withdrawal for the\n    ///         underwriter. The withdrawal has to be completed before the\n    ///         withdrawal timeout elapses. Otherwise, the withdrawal has to\n    ///         be initiated again and the underwriter has to wait for the\n    ///         entire withdrawal delay again before being able to complete\n    ///         the withdrawal.\n    /// @return The amount of collateral withdrawn\n    function completeWithdrawal(address underwriter)\n        external\n        override\n        returns (uint256)\n    {\n        /* solhint-disable not-rely-on-time */\n        uint256 initiatedAt = withdrawalInitiatedTimestamp[underwriter];\n        require(initiatedAt > 0, \"No withdrawal initiated for the underwriter\");\n\n        uint256 withdrawalDelayEndTimestamp = initiatedAt + withdrawalDelay;\n        require(\n            withdrawalDelayEndTimestamp < block.timestamp,\n            \"Withdrawal delay has not elapsed\"\n        );\n\n        require(\n            withdrawalDelayEndTimestamp + withdrawalTimeout >= block.timestamp,\n            \"Withdrawal timeout elapsed\"\n        );\n\n        uint256 covAmount = pendingWithdrawal[underwriter];\n        uint256 covSupply = underwriterToken.totalSupply();\n        delete withdrawalInitiatedTimestamp[underwriter];\n        delete pendingWithdrawal[underwriter];\n\n        // slither-disable-next-line reentrancy-events\n        rewardsPool.withdraw();\n\n        uint256 collateralBalance = collateralToken.balanceOf(address(this));\n\n        uint256 amountToWithdraw = (covAmount * collateralBalance) / covSupply;\n\n        emit WithdrawalCompleted(\n            underwriter,\n            amountToWithdraw,\n            covAmount,\n            block.timestamp\n        );\n        collateralToken.safeTransfer(underwriter, amountToWithdraw);\n\n        /* solhint-enable not-rely-on-time */\n        underwriterToken.burn(covAmount);\n\n        return amountToWithdraw;\n    }\n\n    /// @notice Transfers collateral tokens to a new Asset Pool which previously\n    ///         was approved by the governance. Upgrade does not have to obey\n    ///         withdrawal delay.\n    ///         Old underwriter tokens are burned in favor of new tokens minted\n    ///         in a new Asset Pool. New tokens are sent directly to the\n    ///         underwriter from a new Asset Pool.\n    /// @param covAmount Amount of underwriter tokens used to calculate collateral\n    ///                  tokens which are transferred to a new asset pool\n    /// @param _newAssetPool New Asset Pool address to check validity with the one\n    ///                      that was approved by the governance\n    function upgradeToNewAssetPool(uint256 covAmount, address _newAssetPool)\n        external\n    {\n        /* solhint-disable not-rely-on-time */\n        require(\n            address(newAssetPool) != address(0),\n            \"New asset pool must be assigned\"\n        );\n\n        require(\n            address(newAssetPool) == _newAssetPool,\n            \"Addresses of a new asset pool must match\"\n        );\n\n        require(\n            covAmount > 0,\n            \"Underwriter token amount must be greater than 0\"\n        );\n\n        uint256 covSupply = underwriterToken.totalSupply();\n\n        // slither-disable-next-line reentrancy-events\n        rewardsPool.withdraw();\n\n        uint256 collateralBalance = collateralToken.balanceOf(address(this));\n\n        uint256 collateralToTransfer = (covAmount * collateralBalance) /\n            covSupply;\n\n        collateralToken.safeApprove(\n            address(newAssetPool),\n            collateralToTransfer\n        );\n        // old underwriter tokens are burned in favor of new minted in a new\n        // asset pool\n        underwriterToken.burnFrom(msg.sender, covAmount);\n        // collateralToTransfer will be sent to a new AssetPool and new\n        // underwriter tokens will be minted and transferred back to the underwriter\n        newAssetPool.depositFor(msg.sender, collateralToTransfer);\n\n        emit AssetPoolUpgraded(\n            msg.sender,\n            collateralToTransfer,\n            covAmount,\n            block.timestamp\n        );\n    }\n\n    /// @notice Allows governance to set a new asset pool so the underwriters\n    ///         can move their collateral tokens to a new asset pool without\n    ///         having to wait for the withdrawal delay.\n    function approveNewAssetPoolUpgrade(IAssetPoolUpgrade _newAssetPool)\n        external\n        onlyOwner\n    {\n        require(\n            address(_newAssetPool) != address(0),\n            \"New asset pool can't be zero address\"\n        );\n\n        newAssetPool = _newAssetPool;\n\n        emit ApprovedAssetPoolUpgrade(address(_newAssetPool));\n    }\n\n    /// @notice Allows governance to cancel already approved new asset pool\n    ///         in case of some misconfiguration.\n    function cancelNewAssetPoolUpgrade() external onlyOwner {\n        emit CancelledAssetPoolUpgrade(address(newAssetPool));\n\n        newAssetPool = IAssetPoolUpgrade(address(0));\n    }\n\n    /// @notice Allows the coverage pool to demand coverage from the asset hold\n    ///         by this pool and send it to the provided recipient address.\n    function claim(address recipient, uint256 amount) external onlyOwner {\n        emit CoverageClaimed(recipient, amount, block.timestamp);\n        rewardsPool.withdraw();\n        collateralToken.safeTransfer(recipient, amount);\n    }\n\n    /// @notice Lets the contract owner to begin an update of withdrawal delay\n    ///         parameter value. Withdrawal delay is the time it takes the\n    ///         underwriter to withdraw their collateral and rewards from the\n    ///         pool. This is the time that needs to pass between initiating and\n    ///         completing the withdrawal. The change needs to be finalized with\n    ///         a call to finalizeWithdrawalDelayUpdate after the required\n    ///         governance delay passes. It is up to the contract owner to\n    ///         decide what the withdrawal delay value should be but it should\n    ///         be long enough so that the possibility of having free-riding\n    ///         underwriters escaping from a potential coverage claim by\n    ///         withdrawing their positions from the pool is negligible.\n    /// @param _newWithdrawalDelay The new value of withdrawal delay\n    function beginWithdrawalDelayUpdate(uint256 _newWithdrawalDelay)\n        external\n        onlyOwner\n    {\n        newWithdrawalDelay = _newWithdrawalDelay;\n        withdrawalDelayChangeInitiated = block.timestamp;\n        emit WithdrawalDelayUpdateStarted(_newWithdrawalDelay, block.timestamp);\n    }\n\n    /// @notice Lets the contract owner to finalize an update of withdrawal\n    ///         delay parameter value. This call has to be preceded with\n    ///         a call to beginWithdrawalDelayUpdate and the governance delay\n    ///         has to pass.\n    function finalizeWithdrawalDelayUpdate()\n        external\n        onlyOwner\n        onlyAfterWithdrawalGovernanceDelay(withdrawalDelayChangeInitiated)\n    {\n        withdrawalDelay = newWithdrawalDelay;\n        emit WithdrawalDelayUpdated(withdrawalDelay);\n        newWithdrawalDelay = 0;\n        withdrawalDelayChangeInitiated = 0;\n    }\n\n    /// @notice Lets the contract owner to begin an update of withdrawal timeout\n    ///         parameter value. The withdrawal timeout is the time the\n    ///         underwriter has - after the withdrawal delay passed - to\n    ///         complete the withdrawal. The change needs to be finalized with\n    ///         a call to finalizeWithdrawalTimeoutUpdate after the required\n    ///         governance delay passes. It is up to the contract owner to\n    ///         decide what the withdrawal timeout value should be but it should\n    ///         be short enough so that the time of free-riding by being able to\n    ///         immediately escape from the claim is minimal and long enough so\n    ///         that honest underwriters have a possibility to finalize the\n    ///         withdrawal. It is all about the right proportions with\n    ///         a relation to withdrawal delay value.\n    /// @param  _newWithdrawalTimeout The new value of the withdrawal timeout\n    function beginWithdrawalTimeoutUpdate(uint256 _newWithdrawalTimeout)\n        external\n        onlyOwner\n    {\n        newWithdrawalTimeout = _newWithdrawalTimeout;\n        withdrawalTimeoutChangeInitiated = block.timestamp;\n        emit WithdrawalTimeoutUpdateStarted(\n            _newWithdrawalTimeout,\n            block.timestamp\n        );\n    }\n\n    /// @notice Lets the contract owner to finalize an update of withdrawal\n    ///         timeout parameter value. This call has to be preceded with\n    ///         a call to beginWithdrawalTimeoutUpdate and the governance delay\n    ///         has to pass.\n    function finalizeWithdrawalTimeoutUpdate()\n        external\n        onlyOwner\n        onlyAfterWithdrawalGovernanceDelay(withdrawalTimeoutChangeInitiated)\n    {\n        withdrawalTimeout = newWithdrawalTimeout;\n        emit WithdrawalTimeoutUpdated(withdrawalTimeout);\n        newWithdrawalTimeout = 0;\n        withdrawalTimeoutChangeInitiated = 0;\n    }\n\n    /// @notice Grants pool shares by minting a given amount of the underwriter\n    ///         tokens for the recipient address. In result, the recipient\n    ///         obtains part of the pool ownership without depositing any\n    ///         collateral tokens. Shares are usually granted for notifiers\n    ///         reporting about various contract state changes.\n    /// @dev Can be called only by the contract owner.\n    /// @param recipient Address of the underwriter tokens recipient\n    /// @param covAmount Amount of the underwriter tokens which should be minted\n    function grantShares(address recipient, uint256 covAmount)\n        external\n        onlyOwner\n    {\n        rewardsPool.withdraw();\n        underwriterToken.mint(recipient, covAmount);\n    }\n\n    /// @notice Returns the remaining time that has to pass before the contract\n    ///         owner will be able to finalize withdrawal delay update.\n    ///         Bear in mind the contract owner may decide to wait longer and\n    ///         this value is just an absolute minimum.\n    /// @return The time left until withdrawal delay update can be finalized\n    function getRemainingWithdrawalDelayUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return\n            GovernanceUtils.getRemainingChangeTime(\n                withdrawalDelayChangeInitiated,\n                withdrawalGovernanceDelay()\n            );\n    }\n\n    /// @notice Returns the remaining time that has to pass before the contract\n    ///         owner will be able to finalize withdrawal timeout update.\n    ///         Bear in mind the contract owner may decide to wait longer and\n    ///         this value is just an absolute minimum.\n    /// @return The time left until withdrawal timeout update can be finalized\n    function getRemainingWithdrawalTimeoutUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return\n            GovernanceUtils.getRemainingChangeTime(\n                withdrawalTimeoutChangeInitiated,\n                withdrawalGovernanceDelay()\n            );\n    }\n\n    /// @notice Returns the current collateral token balance of the asset pool\n    ///         plus the reward amount (in collateral token) earned by the asset\n    ///         pool and not yet withdrawn to the asset pool.\n    /// @return The total value of asset pool in collateral token.\n    function totalValue() external view returns (uint256) {\n        return collateralToken.balanceOf(address(this)) + rewardsPool.earned();\n    }\n\n    /// @notice The time it takes to initiate and complete the withdrawal from\n    ///         the pool plus 2 days to make a decision. This governance delay\n    ///         should be used for all changes directly affecting underwriter\n    ///         positions. This time is a minimum and the governance may choose\n    ///         to wait longer before finalizing the update.\n    /// @return The withdrawal governance delay in seconds\n    function withdrawalGovernanceDelay() public view returns (uint256) {\n        return withdrawalDelay + withdrawalTimeout + 2 days;\n    }\n\n    /// @dev Calculates underwriter tokens to mint.\n    function _calculateTokensToMint(uint256 amountToDeposit)\n        internal\n        returns (uint256)\n    {\n        rewardsPool.withdraw();\n\n        uint256 covSupply = underwriterToken.totalSupply();\n        uint256 collateralBalance = collateralToken.balanceOf(address(this));\n\n        if (covSupply == 0) {\n            return amountToDeposit;\n        }\n\n        return (amountToDeposit * covSupply) / collateralBalance;\n    }\n\n    function _deposit(\n        address depositor,\n        uint256 amountToDeposit,\n        uint256 amountToMint\n    ) internal {\n        require(depositor != address(this), \"Self-deposit not allowed\");\n\n        require(\n            amountToMint > 0,\n            \"Minted tokens amount must be greater than 0\"\n        );\n\n        emit Deposited(depositor, amountToDeposit, amountToMint);\n\n        underwriterToken.mint(depositor, amountToMint);\n        collateralToken.safeTransferFrom(\n            depositor,\n            address(this),\n            amountToDeposit\n        );\n    }\n}\n"
    },
    "contracts/GovernanceUtils.sol": {
      "content": "// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.5;\n\nlibrary GovernanceUtils {\n    /// @notice Gets the time remaining until the governable parameter update\n    ///         can be committed.\n    /// @param changeTimestamp Timestamp indicating the beginning of the change.\n    /// @param delay Governance delay.\n    /// @return Remaining time in seconds.\n    function getRemainingChangeTime(uint256 changeTimestamp, uint256 delay)\n        internal\n        view\n        returns (uint256)\n    {\n        require(changeTimestamp > 0, \"Change not initiated\");\n        /* solhint-disable-next-line not-rely-on-time */\n        uint256 elapsed = block.timestamp - changeTimestamp;\n        if (elapsed >= delay) {\n            return 0;\n        } else {\n            return delay - elapsed;\n        }\n    }\n}\n"
    },
    "contracts/RewardsPool.sol": {
      "content": "// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.5;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Rewards Pool\n/// @notice RewardsPool accepts a single reward token and releases it to the\n///         AssetPool over time in one week reward intervals. The owner of this\n///         contract is the reward distribution address funding it with reward\n///         tokens.\ncontract RewardsPool is Ownable {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant DURATION = 7 days;\n\n    IERC20 public immutable rewardToken;\n    address public immutable assetPool;\n\n    // timestamp of the current reward interval end or the timestamp of the\n    // last interval end in case a new reward interval has not been allocated\n    uint256 public intervalFinish = 0;\n    // rate per second with which reward tokens are unlocked\n    uint256 public rewardRate = 0;\n    // amount of rewards accumulated and not yet withdrawn from the previous\n    // reward interval(s)\n    uint256 public rewardAccumulated = 0;\n    // the last time information in this contract was updated\n    uint256 public lastUpdateTime = 0;\n\n    event RewardToppedUp(uint256 amount);\n    event RewardWithdrawn(uint256 amount);\n\n    constructor(\n        IERC20 _rewardToken,\n        address _assetPool,\n        address owner\n    ) {\n        rewardToken = _rewardToken;\n        // slither-disable-next-line missing-zero-check\n        assetPool = _assetPool;\n        transferOwnership(owner);\n    }\n\n    /// @notice Transfers the provided reward amount into RewardsPool and\n    ///         creates a new, one-week reward interval starting from now.\n    ///         Reward tokens from the previous reward interval that unlocked\n    ///         over the time will be available for withdrawal immediately.\n    ///         Reward tokens from the previous interval that has not been yet\n    ///         unlocked, are added to the new interval being created.\n    /// @dev This function can be called only by the owner given that it creates\n    ///      a new interval with one week length, starting from now.\n    function topUpReward(uint256 reward) external onlyOwner {\n        rewardAccumulated = earned();\n\n        /* solhint-disable not-rely-on-time */\n        if (block.timestamp >= intervalFinish) {\n            // see https://github.com/crytic/slither/issues/844\n            // slither-disable-next-line divide-before-multiply\n            rewardRate = reward / DURATION;\n        } else {\n            uint256 remaining = intervalFinish - block.timestamp;\n            uint256 leftover = remaining * rewardRate;\n            rewardRate = (reward + leftover) / DURATION;\n        }\n        intervalFinish = block.timestamp + DURATION;\n        lastUpdateTime = block.timestamp;\n        /* solhint-enable avoid-low-level-calls */\n\n        emit RewardToppedUp(reward);\n        rewardToken.safeTransferFrom(msg.sender, address(this), reward);\n    }\n\n    /// @notice Withdraws all unlocked reward tokens to the AssetPool.\n    function withdraw() external {\n        uint256 amount = earned();\n        rewardAccumulated = 0;\n        lastUpdateTime = lastTimeRewardApplicable();\n        emit RewardWithdrawn(amount);\n        rewardToken.safeTransfer(assetPool, amount);\n    }\n\n    /// @notice Returns the amount of earned and not yet withdrawn reward\n    /// tokens.\n    function earned() public view returns (uint256) {\n        return\n            rewardAccumulated +\n            ((lastTimeRewardApplicable() - lastUpdateTime) * rewardRate);\n    }\n\n    /// @notice Returns the timestamp at which a reward was last time applicable.\n    ///         When reward interval is pending, returns current block's\n    ///         timestamp. If the last reward interval ended and no other reward\n    ///         interval had been allocated, returns the last reward interval's\n    ///         end timestamp.\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, intervalFinish);\n    }\n}\n"
    },
    "contracts/UnderwriterToken.sol": {
      "content": "// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.5;\n\nimport \"@thesis/solidity-contracts/contracts/token/ERC20WithPermit.sol\";\n\n/// @title  UnderwriterToken\n/// @notice Underwriter tokens represent an ownership share in the underlying\n///         collateral of the asset-specific pool. Underwriter tokens are minted\n///         when a user deposits ERC20 tokens into asset-specific pool and they\n///         are burned when a user exits the position. Underwriter tokens\n///         natively support meta transactions. Users can authorize a transfer\n///         of their underwriter tokens with a signature conforming EIP712\n///         standard instead of an on-chain transaction from their address.\n///         Anyone can submit this signature on the user's behalf by calling the\n///         permit function, as specified in EIP2612 standard, paying gas fees,\n///         and possibly performing other actions in the same transaction.\ncontract UnderwriterToken is ERC20WithPermit {\n    constructor(string memory _name, string memory _symbol)\n        ERC20WithPermit(_name, _symbol)\n    {}\n}\n"
    },
    "contracts/interfaces/IAssetPool.sol": {
      "content": "// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.5;\n\n/// @title Asset Pool interface\n/// @notice Asset Pool accepts a single ERC20 token as collateral, and returns\n///         an underwriter token. For example, an asset pool might accept deposits\n///         in KEEP in return for covKEEP underwriter tokens. Underwriter tokens\n///         represent an ownership share in the underlying collateral of the\n///         Asset Pool.\ninterface IAssetPool {\n    /// @notice Accepts the given amount of collateral token as a deposit and\n    ///         mints underwriter tokens representing pool's ownership.\n    /// @dev Before calling this function, collateral token needs to have the\n    ///      required amount accepted to transfer to the asset pool.\n    /// @return The amount of minted underwriter tokens\n    function deposit(uint256 amount) external returns (uint256);\n\n    /// @notice Accepts the given amount of collateral token as a deposit and\n    ///         mints at least a minAmountToMint underwriter tokens representing\n    ///         pool's ownership.\n    /// @dev Before calling this function, collateral token needs to have the\n    ///      required amount accepted to transfer to the asset pool.\n    /// @return The amount of minted underwriter tokens\n    function depositWithMin(uint256 amountToDeposit, uint256 minAmountToMint)\n        external\n        returns (uint256);\n\n    /// @notice Initiates the withdrawal of collateral and rewards from the pool.\n    /// @dev Before calling this function, underwriter token needs to have the\n    ///      required amount accepted to transfer to the asset pool.\n    function initiateWithdrawal(uint256 covAmount) external;\n\n    /// @notice Completes the previously initiated withdrawal for the\n    ///         underwriter.\n    /// @return The amount of collateral withdrawn\n    function completeWithdrawal(address underwriter) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IAssetPoolUpgrade.sol": {
      "content": "// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.5;\n\n/// @title Asset Pool upgrade interface\n/// @notice Interface that has to be implemented by an Asset Pool accepting\n///         upgrades from another asset pool.\ninterface IAssetPoolUpgrade {\n    /// @notice Accepts the given underwriter with collateral tokens amount as a\n    ///         deposit. In exchange new underwriter tokens will be calculated,\n    ///         minted and then transferred back to the underwriter.\n    function depositFor(address underwriter, uint256 amount) external;\n}\n"
    }
  }
}}