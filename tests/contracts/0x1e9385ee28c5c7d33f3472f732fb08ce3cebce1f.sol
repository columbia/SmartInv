{{
  "language": "Solidity",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "MoonCatLootprintsMetadata.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity 0.8.1;\r\n\r\n/**\r\n * @dev On-chain art generation for MoonCatLootprints\r\n * Takes individual trait values as parameters, and outputs complete representations of them.\r\n */\r\ncontract MoonCatLootprintsMetadata {\r\n\r\n    string[5] internal class_names =\r\n        [\r\n         \"Mech\",\r\n         \"Sub\",\r\n         \"Tank\",\r\n         \"Cruiser\",\r\n         \"Unknown\"\r\n         ];\r\n\r\n    /**\r\n     * @dev Convert a Classification ID number into a string name\r\n     */\r\n    function getClassName(uint8 classId) public view returns (string memory) {\r\n        return class_names[classId];\r\n    }\r\n\r\n    string[15] internal color_names =\r\n        [\"Hero Silver\",\r\n         \"Genesis White\",\r\n         \"Genesis Black\",\r\n         \"Red\",\r\n         \"Orange\",\r\n         \"Yellow\",\r\n         \"Chartreuse\",\r\n         \"Green\",\r\n         \"Teal\",\r\n         \"Cyan\",\r\n         \"SkyBlue\",\r\n         \"Blue\",\r\n         \"Purple\",\r\n         \"Magenta\",\r\n         \"Fuchsia\"];\r\n\r\n    /**\r\n     * @dev Convert a Color ID number into a string name\r\n     */\r\n    function getColorName(uint8 colorId) public view returns (string memory) {\r\n        return color_names[colorId];\r\n    }\r\n\r\n    // Color codes used for the background color of an image representation\r\n    string[15] internal color_codes =\r\n        [\"#777777\", // Silver\r\n         \"#cccccc\", // White\r\n         \"#111111\", // Black\r\n         \"hsl(0,60%,38%)\", // Red\r\n         \"hsl(30,60%,38%)\", // Orange\r\n         \"hsl(60,60%,38%)\", // Yellow\r\n         \"hsl(80,60%,38%)\", // Chartreuse\r\n         \"hsl(120,60%,38%)\", // Green\r\n         \"hsl(150,60%,38%)\", // Teal\r\n         \"hsl(180,60%,38%)\", // Cyan\r\n         \"hsl(210,60%,38%)\", // SkyBlue\r\n         \"hsl(240,60%,38%)\", // Blue\r\n         \"hsl(270,60%,38%)\", // Purple\r\n         \"hsl(300,60%,38%)\", // Magenta\r\n         \"hsl(330,60%,38%)\"]; // Fuchsia\r\n\r\n    // SVG codes for the different icons for each ship classification\r\n    string[4] public ship_images =\r\n        [\"<path class=\\\"s\\\" d=\\\"M-61.74,77.79h-12.61V32.32h12.61V77.79z M-28.03,26.64l-7.58-12.63v44.12h7.58V26.64z M-0.65,52.52h10.99 L41.41,1.36L24.74-12.66H-0.65h-25.39L-42.72,1.36l31.07,51.16H-0.65z M60.43,77.79h12.61V32.32H60.43V77.79z M26.73,58.14h7.58 V14.02l-7.58,12.63V58.14z\\\"/><path class=\\\"s\\\" d=\\\"M-23.89,32.56v4.77h-44.15V8.75h29.81 M-58.76,13.76h-18.55v18.55h18.55V13.76z M22.59,32.56v4.77h44.15V8.75 H36.92 M57.46,32.32h18.55V13.76H57.46V32.32z M5.79,46.98L5.79,46.98c0-1.07-0.87-1.94-1.94-1.94h-9c-1.07,0-1.94,0.87-1.94,1.94 v0c0,1.07,0.87,1.94,1.94,1.94h9C4.92,48.93,5.79,48.06,5.79,46.98z\\\"/><path class=\\\"s s1\\\" d=\\\"M-79.92,94.43V86.1 M-56.04,94.43V86.1 M78.61,94.43V86.1 M54.74,94.43V86.1 M-14.48,5.33h28.04 M-9.45,1.1 H8.52\\\"/><path class=\\\"s s1\\\" d=\\\"M-44.11,94.43h-47.87V82.76c0-2.76,2.24-5,5-5h37.87c2.76,0,5,2.24,5,5V94.43z M-19.88,57.67v-6.18 c0-1.64-1.33-2.97-2.97-2.97h-9.15v12.13h9.15C-21.22,60.65-19.88,59.32-19.88,57.67z M42.8,94.43h47.87V82.76c0-2.76-2.24-5-5-5 H47.8c-2.76,0-5,2.24-5,5V94.43z M-0.65,31.11h14.08L33.42,3.86L25.39,2.2l-8.96,8.83H-0.65h-17.08l-8.96-8.83l-8.04,1.66 l19.99,27.25H-0.65z M21.55,60.65h9.15V48.52h-9.15c-1.64,0-2.97,1.33-2.97,2.97v6.18C18.58,59.32,19.91,60.65,21.55,60.65z\\\"/><path class=\\\"s s1\\\" d=\\\"M-26.04-12.66l-11.17,9.4v-27.46h7.51l16.17,18.06H-26.04z M24.74-12.66l11.17,9.4v-27.46H28.4L12.23-12.66 H24.74z\\\"/><path class=\\\"s s2\\\" d=\\\"M-19.88,52.86h-3.79 M-19.88,56.46h-3.79 M22.37,52.86h-3.79 M18.58,56.46h3.79\\\"/>  <path class=\\\"s s2\\\" d=\\\"M-39.67,8.41l-1.58,33.83h-11.47l-1.58-33.83c0-4.04,3.28-7.32,7.32-7.32C-42.95,1.1-39.67,4.37-39.67,8.41z M-43.38,42.24h-6.9l-1.01,4.74h8.91L-43.38,42.24z M38.37,8.41l1.58,33.83h11.47L53,8.41c0-4.04-3.28-7.32-7.32-7.32 C41.64,1.1,38.37,4.37,38.37,8.41z M41.06,46.98h8.91l-1.01-4.74h-6.9L41.06,46.98z\\\"/>\", // Mech\r\n\r\n         \"<path class=\\\"s\\\" d=\\\"M55.52,60.62l-125.85,7.15c-13.35,0.76-24.59-9.86-24.59-23.23v0c0-13.37,11.24-23.99,24.59-23.23l125.85,7.15 V60.62z\\\"/><path class=\\\"s\\\" d=\\\"M48.39,42.2v10.28l-5.47-1.16v-7.96L48.39,42.2z M63.26,21.92L63.26,21.92c-2.75,0-4.82,2.5-4.31,5.2 l3.33,17.61h1.97l3.33-17.61C68.09,24.42,66.01,21.92,63.26,21.92z M63.26,67.55L63.26,67.55c2.75,0,4.82-2.5,4.31-5.2l-3.33-17.61 h-1.97l-3.33,17.61C58.44,65.05,60.51,67.55,63.26,67.55z M-44.97,43.64L-44.97,43.64c0.76,0.76,1.99,0.76,2.75,0l6.36-6.36 c0.76-0.76,0.76-1.99,0-2.75l0,0c-0.76-0.76-1.99-0.76-2.75,0l-6.36,6.36C-45.72,41.65-45.72,42.88-44.97,43.64z M-34.82,43.64 L-34.82,43.64c0.76,0.76,1.99,0.76,2.75,0l6.36-6.36c0.76-0.76,0.76-1.99,0-2.75l0,0c-0.76-0.76-1.99-0.76-2.75,0l-6.36,6.36 C-35.58,41.65-35.58,42.88-34.82,43.64z M63.26,43.33h-7.74v2.81h7.74V43.33z\\\"/><path class=\\\"s\\\" d=\\\"M-71.47,62.75v15.73 M-65.61,62.75v22.93\\\"/> <path class=\\\"s s1\\\" d=\\\"M52.24,60.8l1.72,11.04l19.89,4.4v6.21L38.9,88.39c-8.09,1.37-15.55-4.68-15.87-12.88l-0.51-13.03 M51.24,28.2 L67.16,2.56l-80.25-3.16c-6.16-0.24-12.13,2.16-16.4,6.61l-16.03,16.69\\\"/><path class=\\\"s s1\\\" d=\\\"M3.89,39.09l39.03,1.83v13.24L3.89,55.98c-4.66,0-8.44-3.78-8.44-8.44C-4.56,42.87-0.78,39.09,3.89,39.09z M-42.74,31.11l-31.49-1.26c-5.73,0-10.75,3.81-12.3,9.33l-0.67,5.36h29.01L-42.74,31.11z M30.03,47.53L30.03,47.53 c0-1.07-0.87-1.94-1.94-1.94h-9c-1.07,0-1.94,0.87-1.94,1.94v0c0,1.07,0.87,1.94,1.94,1.94h9C29.16,49.47,30.03,48.6,30.03,47.53z\\\"/>\", // Sub\r\n\r\n         \"<path class=\\\"s\\\" d=\\\"M-41.05,64.38H-76.3c-9.83,0-17.79-7.98-17.77-17.8l0.02-7.96l53-31.34V64.38z M-33.49,21.94v36.39l12.96,9.64 c7.01,5.22,15.52,8.03,24.26,8.03h50.54V7.29l-12-2.39C27.98,2.05,13.19,3.4-0.34,8.77L-33.49,21.94z\\\"/> <path class=\\\"s\\\" d=\\\"M-53.74,49.67l93.8-17.28 M-53.74,96.38h99.86 M-60.37,44.65L-60.37,44.65c0-1.07-0.87-1.94-1.94-1.94h-9 c-1.07,0-1.94,0.87-1.94,1.94v0c0,1.07,0.87,1.94,1.94,1.94h9C-61.24,46.59-60.37,45.72-60.37,44.65z M-60.37,37.78L-60.37,37.78 c0-1.07-0.87-1.94-1.94-1.94h-9c-1.07,0-1.94,0.87-1.94,1.94v0c0,1.07,0.87,1.94,1.94,1.94h9C-61.24,39.72-60.37,38.85-60.37,37.78 z M-33.49,26.33h-7.56v27.92h7.56V26.33z\\\"/><path class=\\\"s s1\\\" d=\\\"M-0.29,30.83v-9c0-1.07,0.87-1.94,1.94-1.94h0c1.07,0,1.94,0.87,1.94,1.94v9c0,1.07-0.87,1.94-1.94,1.94h0 C0.58,32.77-0.29,31.9-0.29,30.83z M1.47-0.14c-4.66,0-8.44,3.78-8.44,8.44l1.83,39.03H8.08L9.91,8.3 C9.91,3.64,6.13-0.14,1.47-0.14z\\\"/> <path class=\\\"s s1\\\" d=\\\"M42.26,32.38c-17.67,0-32,14.33-32,32s14.33,32,32,32s32-14.33,32-32S59.94,32.38,42.26,32.38z M42.26,89.98 c-14.14,0-25.6-11.46-25.6-25.6s11.46-25.6,25.6-25.6s25.6,11.46,25.6,25.6S56.4,89.98,42.26,89.98z M-51.74,49.57 c-12.93,0-23.4,10.48-23.4,23.41c0,12.93,10.48,23.4,23.4,23.4s23.4-10.48,23.4-23.4C-28.33,60.05-38.81,49.57-51.74,49.57z M-51.74,91.7c-10.34,0-18.72-8.38-18.72-18.72c0-10.34,8.38-18.72,18.72-18.72s18.72,8.38,18.72,18.72 C-33.01,83.32-41.4,91.7-51.74,91.7z M-46.35,29.02h-14.78l14.4-10.61L-46.35,29.02z M6.8,52.81H-3.49l1.16-5.47h7.96L6.8,52.81z M54.26,20.3l9-3v18.97l-9-3.28 M54.26,53.04l9-3v18.97l-9-3.28\\\"/>\", // Tank\r\n\r\n         \"<path class=\\\"s\\\" d=\\\"M0.26,93.33h14.33c0,0-0.76-11.46-2.27-32s13.64-76.47,19.95-99.97s-2.52-60.03-32-60.03 s-38.31,36.54-32,60.03s21.46,79.43,19.95,99.97s-2.27,32-2.27,32H0.26\\\"/><path class=\\\"s\\\" d=\\\"M-12.9,76.57l-47.02,6.06l3.03-18.95l43.64-22.42 M-26.38-18.46l-9.09,14.31v19.33l14.78-10.8 M13.42,76.57 l47.02,6.06l-3.03-18.95L13.77,41.25 M21.22,4.37L36,15.17V-4.15l-9.09-14.31\\\"/><path class=\\\"s s1\\\" d=\\\"M-33.66,46.63l-1.83,39.03h-13.24l-1.83-39.03c0-4.66,3.78-8.44,8.44-8.44 C-37.44,38.18-33.66,41.96-33.66,46.63z M34.19,46.63l1.83,39.03h13.24l1.83-39.03c0-4.66-3.78-8.44-8.44-8.44 C37.97,38.18,34.19,41.96,34.19,46.63z\\\"/><path class=\\\"s s1\\\" d=\\\"M-19.18-74.83c1.04,1.8,0.95,17.15,3.03,27c1.51,7.14,4.01,15.92,2.38,18.14c-1.43,1.94-7.59,1.24-9.95-1.37 c-3.41-3.78-4.15-10.56-4.93-16.67C-30.13-59.39-22.35-80.31-19.18-74.83z M-37.94,85.66h-7.96l-1.16,5.47h10.28L-37.94,85.66z M-10.65,93.33l-1.33,8.05H0.26h12.24l-1.33-8.05 M0.26-34.67c0,0,1.82,0,6.12,0s7.45-32,7.04-43S9.28-88.66,0.26-88.66 s-12.75-0.01-13.16,10.99c-0.41,11,2.74,43,7.04,43S0.26-34.67,0.26-34.67z M19.71-74.83c-1.04,1.8-0.95,17.15-3.03,27 c-1.51,7.14-4.01,15.92-2.38,18.14c1.43,1.94,7.59,1.24,9.95-1.37c3.41-3.78,4.15-10.56,4.93-16.67 C30.65-59.39,22.88-80.31,19.71-74.83z M37.3,91.13h10.28l-1.16-5.47h-7.96L37.3,91.13z\\\"/>\" // Cruiser\r\n         ];\r\n\r\n    /**\r\n     * @dev Render an SVG of a ship with the specified features.\r\n     */\r\n    function getImage (uint256 lootprintId, uint8 classId, uint8 colorId, uint8 bays, string calldata shipName)\r\n        public\r\n        view\r\n        returns (string memory)\r\n    {\r\n\r\n        string memory regStr = uint2str(lootprintId);\r\n        string memory baysStr = uint2str(bays);\r\n\r\n        string[15] memory parts;\r\n        parts[0] = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 600 600\\\"><style> .s{fill:white;stroke:white;stroke-width:2;stroke-miterlimit:10;fill-opacity:0.1;stroke-linecap:round}.s1{fill-opacity:0.3}.s2{stroke-width:1}.t{ fill:white;font-family:serif;font-size:20px;}.k{font-weight:bold;text-anchor:end;fill:#ddd;}.n{font-size:22px;font-weight:bold;text-anchor:middle}.l{fill:none;stroke:rgb(230,230,230,0.5);stroke-width:1;clip-path:url(#c);}.r{fill:rgba(0,0,0,0.5);stroke:white;stroke-width:3;}.r1{stroke-width: 1} .a{fill:#FFFFFF;fill-opacity:0.1;stroke:#FFFFFF;stroke-width:2;stroke-miterlimit:10;}.b{fill:none;stroke:#FFFFFF;stroke-width:2;stroke-miterlimit:10;} .c{fill:#FFFFFF;fill-opacity:0.2;stroke:#FFFFFF;stroke-width:2;stroke-miterlimit:10;} .d{fill:#FFFFFF;fill-opacity:0.3;stroke:#FFFFFF;stroke-width:2;stroke-miterlimit:10;}</style><defs><clipPath id=\\\"c\\\"><rect width=\\\"600\\\" height=\\\"600\\\" /></clipPath></defs><rect width=\\\"600\\\" height=\\\"600\\\" fill=\\\"\";\r\n        parts[1] = color_codes[colorId];\r\n        parts[2] = \"\\\"/><polyline class=\\\"l\\\" points=\\\"40,-5 40,605 80,605 80,-5 120,-5 120,605 160,605 160,-5 200,-5 200,605 240,605 240,-5 280,-5 280,605 320,605 320,-5 360,-5 360,605 400,605 400,-5 440,-5 440,605 480,605 480,-5 520,-5 520,605 560,605 560,-5 600,-5 600,605\\\" /><polyline class=\\\"l\\\" points=\\\"-5,40 605,40 605,80 -5,80 -5,120 605,120 605,160 -5,160 -5,200 605,200 605,240 -5,240 -5,280 605,280 605,320 -5,320 -5,360 605,360 605,400 -5,400 -5,440 605,440 605,480 -5,480 -5,520 605,520 605,560 -5,560 -5,600 605,600\\\" /><rect class=\\\"r\\\" x=\\\"10\\\" y=\\\"10\\\" width=\\\"580\\\" height=\\\"50\\\" rx=\\\"15\\\" /><rect class=\\\"l r r1\\\" x=\\\"-5\\\" y=\\\"80\\\" width=\\\"285\\\" height=\\\"535\\\" /><text class=\\\"t n\\\" x=\\\"300\\\" y=\\\"42\\\">\";\r\n        parts[3] = shipName;\r\n        parts[4] = \"</text><text class=\\\"t k\\\" x=\\\"115\\\" y=\\\"147\\\">Reg:</text><text class=\\\"t\\\" x=\\\"125\\\" y=\\\"147\\\">#\";\r\n        parts[5] = regStr;\r\n        parts[6] = \"</text><text class=\\\"t k\\\" x=\\\"115\\\" y=\\\"187\\\">Class:</text><text class=\\\"t\\\" x=\\\"125\\\" y=\\\"187\\\">\";\r\n        parts[7] = class_names[classId];\r\n        parts[8] = \"</text><text class=\\\"t k\\\" x=\\\"115\\\" y=\\\"227\\\">Color:</text><text class=\\\"t\\\" x=\\\"125\\\" y=\\\"227\\\">\";\r\n        parts[9] = color_names[colorId];\r\n        parts[10] = \"</text><text class=\\\"t k\\\" x=\\\"115\\\" y=\\\"267\\\">Bays:</text><text class=\\\"t\\\" x=\\\"125\\\" y=\\\"267\\\">\";\r\n        parts[11] = baysStr;\r\n        parts[12] = \"</text><g transform=\\\"translate(440,440)scale(1.2)\\\">\";\r\n        if (classId < 4) {\r\n            parts[13] = ship_images[classId];\r\n        }\r\n        parts[14] = \"</g></svg>\";\r\n\r\n        bytes memory svg0 = abi.encodePacked(parts[0], parts[1], parts[2],\r\n                                             parts[3], parts[4], parts[5],\r\n                                             parts[6], parts[7], parts[8]);\r\n        bytes memory svg1 = abi.encodePacked(parts[9], parts[10], parts[11],\r\n                                             parts[12], parts[13], parts[14]);\r\n\r\n        return string(abi.encodePacked(\"data:image/svg+xml;base64,\", Base64.encode(abi.encodePacked(svg0, svg1))));\r\n    }\r\n\r\n    /**\r\n     * @dev Encode a key/value pair as a JSON trait property, where the value is a numeric item (doesn't need quotes)\r\n     */\r\n    function encodeAttribute(string memory key, string memory value) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(\"{\\\"trait_type\\\":\\\"\", key,\"\\\",\\\"value\\\":\",value,\"}\"));\r\n    }\r\n\r\n    /**\r\n     * @dev Encode a key/value pair as a JSON trait property, where the value is a string item (needs quotes around it)\r\n     */\r\n    function encodeStringAttribute(string memory key, string memory value) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(\"{\\\"trait_type\\\":\\\"\", key,\"\\\",\\\"value\\\":\\\"\",value,\"\\\"}\"));\r\n    }\r\n\r\n    /**\r\n     * @dev Render a JSON metadata object of a ship with the specified features.\r\n     */\r\n    function getJSON(uint256 lootprintId, uint8 classId, uint8 colorId, uint8 bays, string calldata shipName)\r\n        public\r\n        view\r\n        returns (string memory) {\r\n        string memory colorName = color_names[colorId];\r\n        string memory svg = getImage(lootprintId, classId, colorId, bays, shipName);\r\n        bytes memory tokenName = abi.encodePacked(\"Lootprint #\", uint2str(lootprintId), \": \", shipName);\r\n        bytes memory json = abi.encodePacked(\"{\",\r\n                                             \"\\\"attributes\\\":[\",\r\n                                             encodeAttribute(\"Registration #\", uint2str(lootprintId)), \",\",\r\n                                             encodeStringAttribute(\"Class\", class_names[classId]), \",\",\r\n                                             encodeAttribute(\"Bays\", uint2str(bays)), \",\",\r\n                                             encodeStringAttribute(\"Color\", colorName),\r\n                                             \"],\\\"name\\\":\\\"\", tokenName,\r\n                                             \"\\\",\\\"description\\\":\\\"Build Plans for a MoonCat Spacecraft\\\",\\\"image\\\":\\\"\", svg,\r\n                                             \"\\\"}\");\r\n        return string(abi.encodePacked('data:application/json;base64,', Base64.encode(json)));\r\n\r\n    }\r\n\r\n    /* Utilities */\r\n\r\n    function uint2str(uint value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n}\r\n\r\n/// [MIT License]\r\n/// @title Base64\r\n/// @notice Provides a function for encoding some bytes in base64\r\n/// @author Brecht Devos <brecht@loopring.org>\r\nlibrary Base64 {\r\n    bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n    /// @notice Encodes some bytes to the base64 representation\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        uint256 len = data.length;\r\n        if (len == 0) return \"\";\r\n\r\n        // multiply by 4/3 rounded up\r\n        uint256 encodedLen = 4 * ((len + 2) / 3);\r\n\r\n        // Add some extra buffer at the end\r\n        bytes memory result = new bytes(encodedLen + 32);\r\n\r\n        bytes memory table = TABLE;\r\n\r\n        assembly {\r\n            let tablePtr := add(table, 1)\r\n                let resultPtr := add(result, 32)\r\n\r\n                for {\r\n                     let i := 0\r\n                } lt(i, len) {\r\n\r\n            } {\r\n            i := add(i, 3)\r\n            let input := and(mload(add(data, i)), 0xffffff)\r\n\r\n            let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\r\n            out := shl(8, out)\r\n            out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\r\n            out := shl(8, out)\r\n            out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\r\n            out := shl(8, out)\r\n            out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\r\n            out := shl(224, out)\r\n\r\n            mstore(resultPtr, out)\r\n\r\n            resultPtr := add(resultPtr, 4)\r\n            }\r\n\r\n            switch mod(len, 3)\r\n                          case 1 {\r\n                                  mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\r\n                }\r\n            case 2 {\r\n                    mstore(sub(resultPtr, 1), shl(248, 0x3d))\r\n            }\r\n\r\n            mstore(result, encodedLen)\r\n                }\r\n\r\n        return string(result);\r\n    }\r\n}\r\n"
    },
    "MoonCatLootprints.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity 0.8.1;\r\n\r\ninterface IMoonCatAcclimator {\r\n    function getApproved(uint256 tokenId) external view returns (address);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n}\r\n\r\ninterface IMoonCatRescue {\r\n    function rescueOrder(uint256 tokenId) external view returns (bytes5);\r\n    function catOwners(bytes5 catId) external view returns (address);\r\n}\r\n\r\ninterface IReverseResolver {\r\n    function claim(address owner) external returns (bytes32);\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IERC721Enumerable is IERC721 {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IMoonCatLootprintsMetadata {\r\n    function getJSON(uint256 lootprintId,\r\n                     uint8 classId,\r\n                     uint8 colorId,\r\n                     uint8 bays,\r\n                     string calldata shipName)\r\n        external view returns (string memory);\r\n    function getImage(uint256 lootprintId,\r\n                      uint8 classId,\r\n                      uint8 colorId,\r\n                      uint8 bays,\r\n                      string calldata shipName)\r\n        external view returns (string memory);\r\n    function getClassName(uint8 classId) external view returns (string memory);\r\n    function getColorName(uint8 classId) external view returns (string memory);\r\n}\r\n\r\n\r\n/**\r\n * @dev Derived from OpenZeppelin standard template\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol\r\n * b0cf6fbb7a70f31527f36579ad644e1cf12fdf4e\r\n */\r\nlibrary EnumerableSet {\r\n    struct Set {\r\n        uint256[] _values;\r\n        mapping (uint256 => uint256) _indexes;\r\n    }\r\n\r\n    function at(Set storage set, uint256 index) internal view returns (uint256) {\r\n        return set._values[index];\r\n    }\r\n\r\n    function contains(Set storage set, uint256 value) internal view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    function length(Set storage set) internal view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    function add(Set storage set, uint256 value) internal returns (bool) {\r\n        if (!contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function remove(Set storage set, uint256 value) internal returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n            if (lastIndex != toDeleteIndex) {\r\n                uint256 lastvalue = set._values[lastIndex];\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastvalue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title MoonCatâ€‹Lootprints\r\n * @dev MoonCats have found some plans for building spaceships\r\n */\r\ncontract MoonCatLootprints is IERC165, IERC721Enumerable, IERC721Metadata {\r\n\r\n    /* ERC-165 */\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165) returns (bool) {\r\n        return (interfaceId == type(IERC721).interfaceId ||\r\n                interfaceId == type(IERC721Metadata).interfaceId ||\r\n                interfaceId == type(IERC721Enumerable).interfaceId);\r\n    }\r\n\r\n    /* External Contracts */\r\n\r\n    IMoonCatAcclimator MCA = IMoonCatAcclimator(0xc3f733ca98E0daD0386979Eb96fb1722A1A05E69);\r\n    IMoonCatRescue MCR = IMoonCatRescue(0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6);\r\n    IMoonCatLootprintsMetadata public Metadata;\r\n\r\n    /* Name String Data */\r\n\r\n    string[4] internal honorifics =\r\n        [\r\n         \"Legendary\",\r\n         \"Notorious\",\r\n         \"Distinguished\",\r\n         \"Renowned\"\r\n         ];\r\n\r\n    string[32] internal adjectives =\r\n        [\r\n         \"Turbo\",\r\n         \"Tectonic\",\r\n         \"Rugged\",\r\n         \"Derelict\",\r\n         \"Scratchscarred\",\r\n         \"Purrfect\",\r\n         \"Rickety\",\r\n         \"Sparkly\",\r\n         \"Ethereal\",\r\n         \"Hissing\",\r\n         \"Pouncing\",\r\n         \"Stalking\",\r\n         \"Standing\",\r\n         \"Sleeping\",\r\n         \"Playful\",\r\n         \"Menancing\", // Poor Steve.\r\n         \"Cuddly\",\r\n         \"Neurotic\",\r\n         \"Skittish\",\r\n         \"Impulsive\",\r\n         \"Sly\",\r\n         \"Ponderous\",\r\n         \"Prodigal\",\r\n         \"Hungry\",\r\n         \"Grumpy\",\r\n         \"Harmless\",\r\n         \"Mysterious\",\r\n         \"Frisky\",\r\n         \"Furry\",\r\n         \"Scratchy\",\r\n         \"Patchy\",\r\n         \"Hairless\"\r\n         ];\r\n\r\n    string[15] internal mods =\r\n        [\r\n         \"Star\",\r\n         \"Galaxy\",\r\n         \"Constellation\",\r\n         \"World\",\r\n         \"Moon\",\r\n         \"Alley\",\r\n         \"Midnight\",\r\n         \"Wander\",\r\n         \"Tuna\",\r\n         \"Mouse\",\r\n         \"Catnip\",\r\n         \"Toy\",\r\n         \"Kibble\",\r\n         \"Hairball\",\r\n         \"Litterbox\"\r\n         ];\r\n\r\n    string[32] internal mains =\r\n        [\r\n         \"Lightning\",\r\n         \"Wonder\",\r\n         \"Toebean\",\r\n         \"Whisker\",\r\n         \"Paw\",\r\n         \"Fang\",\r\n         \"Tail\",\r\n         \"Purrbox\",\r\n         \"Meow\",\r\n         \"Claw\",\r\n         \"Scratcher\",\r\n         \"Chomper\",\r\n         \"Nibbler\",\r\n         \"Mouser\",\r\n         \"Racer\",\r\n         \"Teaser\",\r\n         \"Chaser\",\r\n         \"Hunter\",\r\n         \"Leaper\",\r\n         \"Sleeper\",\r\n         \"Pouncer\",\r\n         \"Stalker\",\r\n         \"Stander\",\r\n         \"TopCat\",\r\n         \"Ambassador\",\r\n         \"Admiral\",\r\n         \"Commander\",\r\n         \"Negotiator\",\r\n         \"Vandal\",\r\n         \"Mischief\",\r\n         \"Ultimatum\",\r\n         \"Frolic\"\r\n         ];\r\n\r\n    string[16] internal designations =\r\n        [\r\n         \"Alpha\",\r\n         \"Tau\",\r\n         \"Pi\",\r\n         \"I\",\r\n         \"II\",\r\n         \"III\",\r\n         \"IV\",\r\n         \"V\",\r\n         \"X\",\r\n         \"Prime\",\r\n         \"Proper\",\r\n         \"1\",\r\n         \"1701-D\",\r\n         \"2017\",\r\n         \"A\",\r\n         \"Runt\"\r\n         ];\r\n\r\n    /* Data */\r\n\r\n    bytes32[400] ColorTable;\r\n\r\n    /* Structs */\r\n\r\n    struct Lootprint {\r\n        uint16 index;\r\n        address owner;\r\n    }\r\n\r\n    /* State */\r\n\r\n    using EnumerableSet for EnumerableSet.Set;\r\n\r\n    address payable public contractOwner;\r\n\r\n    bool public frozen = true;\r\n\r\n    bool public mintingWindowOpen = true;\r\n\r\n    uint8 revealCount = 0;\r\n\r\n    uint256 public price = 50000000000000000;\r\n\r\n    bytes32[100] NoChargeList;\r\n\r\n    bytes32[20] revealBlockHashes;\r\n\r\n    Lootprint[25600] public Lootprints; // lootprints by lootprintId/rescueOrder\r\n\r\n    EnumerableSet.Set internal LootprintIdByIndex;\r\n\r\n    mapping(address => EnumerableSet.Set) internal LootprintsByOwner;\r\n\r\n    mapping(uint256 => address) private TokenApprovals; // lootprint id -> approved address\r\n\r\n    mapping(address => mapping(address => bool)) private OperatorApprovals; // owner address -> operator address -> bool\r\n\r\n    /* Modifiers */\r\n\r\n    modifier onlyContractOwner () {\r\n        require(msg.sender == contractOwner, \"Only Contract Owner\");\r\n        _;\r\n    }\r\n\r\n    modifier lootprintExists (uint256 lootprintId) {\r\n        require(LootprintIdByIndex.contains(lootprintId), \"ERC721: operator query for nonexistent token\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrApproved(uint256 lootprintId) {\r\n        require(LootprintIdByIndex.contains(lootprintId), \"ERC721: query for nonexistent token\");\r\n        address owner = ownerOf(lootprintId);\r\n        require(msg.sender == owner || msg.sender == TokenApprovals[lootprintId] || OperatorApprovals[owner][msg.sender],\r\n                \"ERC721: transfer caller is not owner nor approved\");\r\n        _;\r\n    }\r\n\r\n    modifier notFrozen () {\r\n        require(!frozen, \"Frozen\");\r\n        _;\r\n    }\r\n\r\n    /* ERC-721 Helpers */\r\n\r\n    function setApprove(address to, uint256 lootprintId) private {\r\n        TokenApprovals[lootprintId] = to;\r\n        emit Approval(msg.sender, to, lootprintId);\r\n    }\r\n\r\n    function handleTransfer(address from, address to, uint256 lootprintId) private {\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n        setApprove(address(0), lootprintId);\r\n        LootprintsByOwner[from].remove(lootprintId);\r\n        LootprintsByOwner[to].add(lootprintId);\r\n        Lootprints[lootprintId].owner = to;\r\n        emit Transfer(from, to, lootprintId);\r\n    }\r\n\r\n    /* ERC-721 */\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return LootprintIdByIndex.length();\r\n    }\r\n\r\n    function balanceOf(address owner) public view override returns (uint256 balance) {\r\n        return LootprintsByOwner[owner].length();\r\n    }\r\n\r\n    function ownerOf(uint256 lootprintId) public view override returns (address owner) {\r\n        return Lootprints[lootprintId].owner;\r\n    }\r\n\r\n    function approve(address to, uint256 lootprintId) public override lootprintExists(lootprintId) {\r\n        address owner = ownerOf(lootprintId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \"ERC721: approve caller is not owner nor approved for all\");\r\n        setApprove(to, lootprintId);\r\n    }\r\n\r\n    function getApproved(uint256 lootprintId) public view override returns (address operator) {\r\n        return TokenApprovals[lootprintId];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public override {\r\n        require(operator != msg.sender, \"ERC721: approve to caller\");\r\n        OperatorApprovals[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\r\n        return OperatorApprovals[owner][operator];\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 lootprintId, bytes memory _data) public override onlyOwnerOrApproved(lootprintId) {\r\n        handleTransfer(from, to, lootprintId);\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(to)\r\n        }\r\n        if (size > 0) {\r\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, lootprintId, _data) returns (bytes4 retval) {\r\n                if (retval != IERC721Receiver.onERC721Received.selector) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                }\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 lootprintId) public override {\r\n        safeTransferFrom(from, to, lootprintId, \"\");\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 lootprintId) public override onlyOwnerOrApproved(lootprintId) {\r\n        handleTransfer(from, to, lootprintId);\r\n    }\r\n\r\n    /* ERC-721 Enumerable */\r\n\r\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\r\n        return LootprintIdByIndex.at(index);\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\r\n        require(index < balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n        return LootprintsByOwner[owner].at(index);\r\n    }\r\n\r\n    /* Reveal */\r\n\r\n    bool pendingReveal = false;\r\n    uint256 revealPrepBlock;\r\n    bytes32 revealSeedHash;\r\n\r\n    /**\r\n     * @dev How many lootprints are awaiting being revealed?\r\n     */\r\n    function pendingRevealCount() public view returns (uint256) {\r\n        uint256 numRevealed = revealCount * 2560;\r\n        if (numRevealed > LootprintIdByIndex.length()) return 0;\r\n        return LootprintIdByIndex.length() - numRevealed;\r\n    }\r\n\r\n    /**\r\n     * @dev Start a reveal action.\r\n     * The hash submitted here must be the keccak256 hash of a secret number that will be submitted to the next function\r\n     */\r\n    function prepReveal(bytes32 seedHash) public onlyContractOwner {\r\n        require(!pendingReveal && seedHash != revealSeedHash && revealCount < 20, \"Prep Conditions Not Met\");\r\n        revealSeedHash = seedHash;\r\n        revealPrepBlock = block.number;\r\n        pendingReveal = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Finalize a reveal action.\r\n     * Must take place at least one block after the `prepReveal` action was taken\r\n     */\r\n    function reveal(uint256 revealSeed) public onlyContractOwner{\r\n        require(pendingReveal\r\n                && block.number > revealPrepBlock\r\n                && keccak256(abi.encodePacked(revealSeed)) == revealSeedHash\r\n                , \"Reveal Conditions Not Met\");\r\n\r\n        if (block.number - revealPrepBlock < 255) {\r\n            bytes32 blockSeed = keccak256(abi.encodePacked(revealSeed, blockhash(revealPrepBlock)));\r\n            revealBlockHashes[revealCount] = blockSeed;\r\n            revealCount++;\r\n        }\r\n        pendingReveal = false;\r\n    }\r\n\r\n    /* Minting */\r\n\r\n    /**\r\n     * @dev Is the minting of a specific rescueOrder needing payment or is it free?\r\n     */\r\n    function paidMint(uint256 rescueOrder) public view returns (bool) {\r\n        uint256 wordIndex = rescueOrder / 256;\r\n        uint256 bitIndex = rescueOrder % 256;\r\n        return (uint(NoChargeList[wordIndex] >> (255 - bitIndex)) & 1) == 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Create the token\r\n     * Checks that the address minting is the current owner of the MoonCat, and ensures that MoonCat is Acclimated\r\n     */\r\n    function handleMint(uint256 rescueOrder, address to) private {\r\n        require(mintingWindowOpen, \"Minting Window Closed\");\r\n        require(MCR.catOwners(MCR.rescueOrder(rescueOrder)) == 0xc3f733ca98E0daD0386979Eb96fb1722A1A05E69,\r\n                \"Not Acclimated\");\r\n        address moonCatOwner = MCA.ownerOf(rescueOrder);\r\n        require((msg.sender == moonCatOwner)\r\n            || (msg.sender == MCA.getApproved(rescueOrder))\r\n            || (MCA.isApprovedForAll(moonCatOwner, msg.sender)),\r\n            \"Not AMC Owner or Approved\"\r\n        );\r\n\r\n        require(!LootprintIdByIndex.contains(rescueOrder), \"Already Minted\");\r\n        Lootprints[rescueOrder] = Lootprint(uint16(LootprintIdByIndex.length()), to);\r\n        LootprintIdByIndex.add(rescueOrder);\r\n        LootprintsByOwner[to].add(rescueOrder);\r\n        emit Transfer(address(0), to, rescueOrder);\r\n    }\r\n\r\n    /**\r\n     * @dev Mint a lootprint, and give it to a specific address\r\n     */\r\n    function mint(uint256 rescueOrder, address to) public payable notFrozen {\r\n        if (paidMint(rescueOrder)) {\r\n            require(address(this).balance >= price, \"Insufficient Value\");\r\n            contractOwner.transfer(price);\r\n        }\r\n        handleMint(rescueOrder, to);\r\n        if (address(this).balance > 0) {\r\n            // The buyer over-paid; transfer their funds back to them\r\n            payable(msg.sender).transfer(address(this).balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Mint a lootprint, and give it to the address making the transaction\r\n     */\r\n    function mint(uint256 rescueOrder) public payable {\r\n        mint(rescueOrder, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Mint multiple lootprints, sending them all to a specific address\r\n     */\r\n    function mintMultiple(uint256[] calldata rescueOrders, address to) public payable notFrozen {\r\n        uint256 totalPrice = 0;\r\n        for (uint i = 0; i < rescueOrders.length; i++) {\r\n            if (paidMint(rescueOrders[i])) {\r\n                totalPrice += price;\r\n            }\r\n            handleMint(rescueOrders[i], to);\r\n        }\r\n        require(address(this).balance >= totalPrice, \"Insufficient Value\");\r\n        if (totalPrice > 0) {\r\n            contractOwner.transfer(totalPrice);\r\n        }\r\n        if (address(this).balance > 0) {\r\n            // The buyer over-paid; transfer their funds back to them\r\n            payable(msg.sender).transfer(address(this).balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Mint multiple lootprints, sending them all to the address making the transaction\r\n     */\r\n    function mintMultiple(uint256[] calldata rescueOrders) public payable {\r\n        mintMultiple(rescueOrders, msg.sender);\r\n    }\r\n\r\n    /* Contract Owner */\r\n\r\n    constructor(address metadataContract) {\r\n        contractOwner = payable(msg.sender);\r\n\r\n        Metadata = IMoonCatLootprintsMetadata(metadataContract);\r\n\r\n        // https://docs.ens.domains/contract-api-reference/reverseregistrar#claim-address\r\n        IReverseResolver(0x084b1c3C81545d370f3634392De611CaaBFf8148)\r\n            .claim(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Mint the 160 Hero lootprint tokens, and give them to the contract owner\r\n     */\r\n    function setupHeroShips(bool groupTwo) public onlyContractOwner {\r\n        uint startIndex = 25440;\r\n        if (groupTwo) {\r\n             startIndex = 25520;\r\n        }\r\n        require(Lootprints[startIndex].owner == address(0), \"Already Set Up\");\r\n        for (uint i = startIndex; i < (startIndex+80); i++) {\r\n            Lootprints[i] = Lootprint(uint16(LootprintIdByIndex.length()), contractOwner);\r\n            LootprintIdByIndex.add(i);\r\n            LootprintsByOwner[contractOwner].add(i);\r\n            emit Transfer(address(0), contractOwner, i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Update the contract used for image/JSON rendering\r\n     */\r\n    function setMetadataContract(address metadataContract) public onlyContractOwner{\r\n        Metadata = IMoonCatLootprintsMetadata(metadataContract);\r\n    }\r\n\r\n    /**\r\n     * @dev Set configuration values for which MoonCat creates which color lootprint when minted\r\n     */\r\n    function setColorTable(bytes32[] calldata table, uint startAt) public onlyContractOwner {\r\n        for (uint i = 0; i < table.length; i++) {\r\n            ColorTable[startAt + i] = table[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set configuration values for which MoonCats need to pay for minting a lootprint\r\n     */\r\n    function setNoChargeList (bytes32[100] calldata noChargeList) public onlyContractOwner {\r\n        NoChargeList = noChargeList;\r\n    }\r\n\r\n    /**\r\n     * @dev Set configuration values for how much a paid lootprint costs\r\n     */\r\n    function setPrice(uint256 priceWei) public onlyContractOwner {\r\n        price = priceWei;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow current `owner` to transfer ownership to another address\r\n     */\r\n    function transferOwnership (address payable newOwner) public onlyContractOwner {\r\n        contractOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevent creating lootprints\r\n     */\r\n    function freeze () public onlyContractOwner notFrozen {\r\n        frozen = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Enable creating lootprints\r\n     */\r\n    function unfreeze () public onlyContractOwner {\r\n        frozen = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevent any further minting from happening\r\n     * Checks to ensure all have been revealed before allowing locking down the minting process\r\n     */\r\n    function permanentlyCloseMintingWindow() public onlyContractOwner {\r\n        require(revealCount >= 20, \"Reveal Pending\");\r\n        mintingWindowOpen = false;\r\n    }\r\n\r\n    /* Property Decoders */\r\n\r\n    function decodeColor(uint256 rescueOrder) public view returns (uint8) {\r\n        uint256 wordIndex = rescueOrder / 64;\r\n        uint256 nibbleIndex = rescueOrder % 64;\r\n        bytes32 word = ColorTable[wordIndex];\r\n        return uint8(uint(word >> (252 - nibbleIndex * 4)) & 15);\r\n    }\r\n\r\n    function decodeName(uint32 seed) internal view returns (string memory) {\r\n        seed = seed >> 8;\r\n        uint index;\r\n        string[9] memory parts;\r\n        //honorific\r\n        index = seed & 15;\r\n        if (index < 8) {\r\n            parts[0] = \"The \";\r\n            if (index < 4) {\r\n                parts[1] = honorifics[index];\r\n                parts[2] = \" \";\r\n            }\r\n        }\r\n        seed >>= 4;\r\n        //adjective\r\n        if ((seed & 1) == 1) {\r\n            index = (seed >> 1) & 31;\r\n            parts[3] = adjectives[index];\r\n            parts[4] = \" \";\r\n        }\r\n        seed >>= 6;\r\n        //mod\r\n        index = seed & 15;\r\n        if (index < 15) {\r\n            parts[5] = mods[index];\r\n        }\r\n        seed >>= 4;\r\n        //main\r\n        index = seed & 31;\r\n        parts[6] = mains[index];\r\n        seed >>= 5;\r\n        //designation\r\n        if ((seed & 1) == 1) {\r\n            index = (seed >> 1) & 15;\r\n            parts[7] = \" \";\r\n            parts[8] = designations[index];\r\n        }\r\n\r\n        return string(abi.encodePacked(parts[0], parts[1], parts[2],\r\n                                       parts[3], parts[4], parts[5],\r\n                                       parts[6], parts[7], parts[8]));\r\n\r\n    }\r\n\r\n    function decodeClass(uint32 seed) internal pure returns (uint8) {\r\n        uint class_determiner = seed & 15;\r\n        if (class_determiner < 2) {\r\n            return 0;\r\n        } else if (class_determiner < 5) {\r\n            return 1;\r\n        } else if (class_determiner < 9) {\r\n            return 2;\r\n        } else {\r\n            return 3;\r\n        }\r\n    }\r\n\r\n    function decodeBays(uint32 seed) internal pure returns (uint8) {\r\n        uint bay_determiner = (seed >> 4) & 15;\r\n\r\n        if (bay_determiner < 3) {\r\n            return 5;\r\n        } else if (bay_determiner < 8) {\r\n            return 4;\r\n        } else {\r\n            return 3;\r\n        }\r\n    }\r\n\r\n    uint8 constant internal STATUS_NOT_MINTED = 0;\r\n    uint8 constant internal STATUS_NOT_MINTED_FREE = 1;\r\n    uint8 constant internal STATUS_PENDING = 2;\r\n    uint8 constant internal STATUS_MINTED = 3;\r\n\r\n    /**\r\n     * @dev Get detailed traits about a lootprint token\r\n     * Provides trait values in native contract return values, which can be used by other contracts\r\n     */\r\n    function getDetails (uint256 lootprintId)\r\n        public\r\n        view\r\n        returns (uint8 status, string memory class, uint8 bays, string memory colorName, string memory shipName, address tokenOwner, uint32 seed)\r\n    {\r\n        Lootprint memory lootprint = Lootprints[lootprintId];\r\n        colorName = Metadata.getColorName(decodeColor(lootprintId));\r\n        tokenOwner = address(0);\r\n        if (LootprintIdByIndex.contains(lootprintId)) {\r\n            if (revealBlockHashes[lootprint.index / 1280] > 0) {\r\n                seed = uint32(uint256(keccak256(abi.encodePacked(lootprintId, revealBlockHashes[lootprint.index / 1280]))));\r\n                return (STATUS_MINTED,\r\n                        Metadata.getClassName(decodeClass(seed)),\r\n                        decodeBays(seed),\r\n                        colorName,\r\n                        decodeName(seed),\r\n                        lootprint.owner,\r\n                        seed);\r\n            }\r\n            status = STATUS_PENDING;\r\n            tokenOwner = lootprint.owner;\r\n        } else if (paidMint(lootprintId)) {\r\n            status = STATUS_NOT_MINTED;\r\n        } else {\r\n            status = STATUS_NOT_MINTED_FREE;\r\n        }\r\n        return (status, \"Unknown\", 0, colorName, \"?\", tokenOwner, 0);\r\n    }\r\n\r\n    /* ERC-721 Metadata */\r\n\r\n    function name() public pure override returns (string memory) {\r\n        return \"MoonCatLootprint\";\r\n    }\r\n\r\n    function symbol() public pure override returns (string memory) {\r\n        return unicode\"ðŸ“œ\";\r\n    }\r\n\r\n    function tokenURI(uint256 lootprintId) public view override lootprintExists(lootprintId) returns (string memory) {\r\n        Lootprint memory lootprint = Lootprints[lootprintId];\r\n        uint8 colorId = decodeColor(lootprintId);\r\n        if (revealBlockHashes[lootprint.index / 1280] > 0) {\r\n            uint32 seed = uint32(uint256(keccak256(abi.encodePacked(lootprintId, revealBlockHashes[lootprint.index / 1280]))));\r\n            uint8 classId = decodeClass(seed);\r\n            string memory shipName = decodeName(seed);\r\n            uint8 bays = decodeBays(seed);\r\n            return Metadata.getJSON(lootprintId, classId, colorId, bays, shipName);\r\n        } else {\r\n            return Metadata.getJSON(lootprintId, 4, colorId, 0, \"?\");\r\n        }\r\n    }\r\n\r\n    function imageURI(uint256 lootprintId) public view lootprintExists(lootprintId) returns (string memory) {\r\n        Lootprint memory lootprint = Lootprints[lootprintId];\r\n        uint8 colorId = decodeColor(lootprintId);\r\n        if (revealBlockHashes[lootprint.index / 1280] > 0) {\r\n            uint32 seed = uint32(uint256(keccak256(abi.encodePacked(lootprintId, revealBlockHashes[lootprint.index / 1280]))));\r\n            uint8 classId = decodeClass(seed);\r\n            string memory shipName = decodeName(seed);\r\n            uint8 bays = decodeBays(seed);\r\n            return Metadata.getImage(lootprintId, classId, colorId, bays, shipName);\r\n        } else {\r\n            return Metadata.getImage(lootprintId, 4, colorId, 0, \"?\");\r\n        }\r\n    }\r\n\r\n    /* Rescue Tokens */\r\n\r\n    /**\r\n     * @dev Rescue ERC20 assets sent directly to this contract.\r\n     */\r\n    function withdrawForeignERC20(address tokenContract)\r\n        public\r\n        onlyContractOwner\r\n    {\r\n        IERC20 token = IERC20(tokenContract);\r\n        token.transfer(contractOwner, token.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * @dev Rescue ERC721 assets sent directly to this contract.\r\n     */\r\n    function withdrawForeignERC721(address tokenContract, uint256 lootprintId)\r\n        public\r\n        onlyContractOwner\r\n    {\r\n        IERC721(tokenContract).safeTransferFrom(address(this), contractOwner, lootprintId);\r\n    }\r\n\r\n}\r\n"
    }
  }
}}