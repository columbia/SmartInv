{"Administratable.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \u0027./Ownable.sol\u0027;\n\ncontract Administratable is Ownable {\n  mapping (address =\u003e bool) admins;\n\n  modifier onlyAdmin() {\n    require(msg.sender == owner || admins[msg.sender]);\n    _;\n  }\n  \n  function addAdmin(address _adminAddr) onlyAdmin public returns (bool success) {\n    admins[_adminAddr] = true;\n    emit AdminAdded(_adminAddr, msg.sender);\n    return true;\n  }\n\n  function revokeAdmin(address _adminAddr) onlyAdmin public returns (bool success) {\n    require(msg.sender != _adminAddr);\n    admins[_adminAddr] = false;\n    emit AdminRevoked(_adminAddr, msg.sender);\n    return true;\n  }\n  \n  event AdminAdded(address indexed _admin, address indexed _by);\n  event AdminRevoked(address indexed _admin, address indexed _by);\n}\n"},"BasicToken.sol":{"content":"pragma solidity ^0.4.23;\n\n\nimport \"./ERC20Basic.sol\";\nimport \"./SafeMath.sol\";\n\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address =\u003e uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value \u003c= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n"},"DividendToken.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \u0027./Administratable.sol\u0027;\nimport \u0027./Pausable.sol\u0027;\nimport \u0027./StandardToken.sol\u0027;\nimport \u0027./SafeMath.sol\u0027;\n\ncontract DividendToken is StandardToken, Pausable, Administratable {\n  using SafeMath for uint256;\n\n  uint256 public period = 0;\n  uint256 public buyBackTime;\n  bool public ended = false;\n  \n  mapping (uint256 =\u003e uint256) public dividends;\n  mapping (uint256 =\u003e uint256) public dividendDates;\n  uint256 public buyBackTotal;\n  mapping (address =\u003e bool) public boughtBack;\n  \n  mapping (address =\u003e mapping (uint256 =\u003e uint256)) internal holdings;\n  mapping (address =\u003e uint256) internal last;\n  mapping (address =\u003e uint256) public claimedTo;\n  mapping (address =\u003e bool) beenDivLocked;\n  mapping (address =\u003e uint256[]) divLocks;\n\n  mapping(uint256 =\u003e uint256) totalAt;\n\n  modifier canBuyBack() {\n    require(now \u003e buyBackTime);\n    _;\n  }\n\n  modifier onlyLive() {\n    require(!ended);\n    _;\n  }\n\n  function updateHoldings(address _holder) internal returns (bool success) {\n    uint256 lastPeriod = last[_holder];\n    uint256 lastAmount = holdings[_holder][lastPeriod];\n    if(lastAmount != 0) {\n      for (uint i = lastPeriod + 1; i \u003c= period; i++) {\n        holdings[_holder][i] = lastAmount;\n      }\n    }\n    last[_holder] = period;\n    return true;\n  }\n\n  function updateHoldingsTo(address _holder, uint256 _to) public onlyAdmin returns (bool success){\n    require(_to \u003e last[_holder]);\n    require(_to \u003c= period);\n    uint256 lastPeriod = last[_holder];\n    uint256 lastAmount = holdings[_holder][lastPeriod];\n    if(lastAmount != 0) {\n      for (uint i = lastPeriod + 1; i \u003c= _to; i++) {\n        holdings[_holder][i] = lastAmount;\n      }\n    }\n    last[_holder] = _to;\n    return true;\n  }\n  \n  function lockedAt(address _address, uint256 _period) public view returns (bool) {\n    if(!beenDivLocked[_address]) {\n      return false;\n    }\n    bool locked = false;\n    for(uint i = 0; i \u003c divLocks[_address].length; i++) {\n      if(divLocks[_address][i] \u003e _period) {\n        break;\n      } \n      locked = !locked;\n    }\n    return locked;\n  }\n\n  function addLock(address _locked) onlyOwner public returns (bool success) {\n    require(!lockedAt(_locked, period));\n    if (last[_locked] \u003c period) {\n      updateHoldings(_locked);\n    }\n    totalAt[period] = totalAt[period].sub(balanceOf(_locked));\n    beenDivLocked[_locked] = true;\n    divLocks[_locked].push(period);\n    emit Locked(_locked, period);\n    return true;\n  }\n\n  function revokeLock(address _unlocked) onlyOwner public returns (bool success) {\n    require(lockedAt(_unlocked, period));\n    if (last[_unlocked] \u003c period) {\n      updateHoldings(_unlocked);\n    }\n    totalAt[period] = totalAt[period].add(balanceOf(_unlocked));\n    divLocks[_unlocked].push(period);\n    emit Unlocked(_unlocked, period);\n    return true;\n  }\n\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    if(ended) {\n      return 0;\n    }\n    return holdings[_owner][last[_owner]];\n  }\n\n  function transfer(address _to, uint256 _value) onlyLive whenNotPaused public returns (bool) {\n    require(_to != address(0));\n    uint256 senderLastPeriod = last[msg.sender];\n    require(_value \u003c= holdings[msg.sender][senderLastPeriod]);\n\n    if (senderLastPeriod \u003c period) {\n      updateHoldings(msg.sender);\n    }\n\n    if (last[_to] \u003c period) {\n      updateHoldings(_to);\n    }\n\n    holdings[msg.sender][period] = holdings[msg.sender][period].sub(_value);\n    holdings[_to][period] = holdings[_to][period].add(_value);\n    bool fromLocked = lockedAt(msg.sender, period);\n    bool toLocked = lockedAt(_to, period);\n    if(fromLocked \u0026\u0026 !toLocked) {\n      totalAt[period] = totalAt[period].add(_value);\n    } else if(!fromLocked \u0026\u0026 toLocked) {\n      totalAt[period] = totalAt[period].sub(_value);\n    }\n    emit Transfer(msg.sender, _to, _value);\n\n    return true;\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) onlyLive whenNotPaused public returns (bool) {\n    require(_to != address(0));\n    uint256 senderLastPeriod = last[_from];\n    require(_value \u003c= holdings[_from][senderLastPeriod]);\n    require(_value \u003c= allowed[_from][msg.sender]);\n\n     if (senderLastPeriod \u003c period) {\n       updateHoldings(_from);\n    }\n\n    if (last[_to] \u003c period) {\n      updateHoldings(_to);\n    }\n\n    holdings[_from][period] = holdings[_from][period].sub(_value);\n    holdings[_to][period] = holdings[_to][period].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    bool fromLocked = lockedAt(_from, period);\n    bool toLocked = lockedAt(_to, period);\n    if(fromLocked \u0026\u0026 !toLocked) {\n      totalAt[period] = totalAt[period].add(_value);\n    } else if(!fromLocked \u0026\u0026 toLocked) {\n      totalAt[period] = totalAt[period].sub(_value);\n    }\n    emit Transfer(_from, _to, _value);\n\n    return true;\n  }\n\n  function () public onlyAdmin onlyLive payable {\n    payIn();\n  }\n\n  function payIn() public onlyLive onlyAdmin payable returns (bool) {\n    dividends[period] = msg.value;\n    dividendDates[period] = now;\n    period = period.add(1);\n    totalAt[period] = totalAt[period.sub(1)];\n    emit Paid(msg.sender, period.sub(1), msg.value);\n    return true;\n  }\n  \n  function claimDividends() whenNotPaused public returns (uint256 amount) {\n    require(claimedTo[msg.sender] \u003c period);\n    uint256 total = 0;\n    if (last[msg.sender] \u003c period) {\n      updateHoldings(msg.sender);\n    }\n    for (uint i = claimedTo[msg.sender]; i \u003c period; i++) {\n      if (holdings[msg.sender][i] \u003e 0 \u0026\u0026 !lockedAt(msg.sender, i)) {\n        uint256 multiplier = dividends[i].mul(holdings[msg.sender][i]);\n        total += multiplier.div(totalAt[i]);\n      }\n    }\n    claimedTo[msg.sender] = period;\n    if(total \u003e 0) {\n      msg.sender.transfer(total);\n      emit Claimed(msg.sender, i, total);\n    }\n    return total;\n  }\n\n  function claimDividendsFor(address _address) onlyAdmin public returns (uint256 amount) {\n    require(claimedTo[_address] \u003c period);\n    uint256 total = 0;\n    if (last[_address] \u003c period) {\n      updateHoldings(_address);\n    }\n    for (uint i = claimedTo[_address]; i \u003c period; i++) {\n      if (holdings[_address][i] \u003e 0 \u0026\u0026 !lockedAt(_address, i)) {\n        uint256 multiplier = dividends[i].mul(holdings[_address][i]);\n        total += multiplier.div(totalAt[i]);\n      }\n    }\n    claimedTo[_address] = period;\n    if(total \u003e 0) {\n      _address.transfer(total);\n      emit Claimed(_address, i, total);\n    }\n    return total;\n  }\n  \n  function outstandingFor(address _address) public view returns (uint256 amount) {\n    uint256 total = 0;\n    uint256 holds = 0;\n    for (uint i = claimedTo[_address]; i \u003c period; i++) {\n      if(last[_address] \u003c i) {\n        holds = holdings[_address][last[_address]];\n      } else {\n        holds = holdings[_address][i];\n      }\n      if (holds \u003e 0 \u0026\u0026 !lockedAt(_address, i)) {\n        uint256 multiplier = dividends[i].mul(holds);\n        uint256 owed = multiplier.div(totalAt[i]);\n        total += owed;\n      }\n    }\n    return total;\n  }\n\n  function outstanding() public view returns (uint256 amount) {\n    uint256 total = 0;\n    uint256 holds = 0;\n    for (uint i = claimedTo[msg.sender]; i \u003c period; i++) {\n       if(last[msg.sender] \u003c i) {\n        holds = holdings[msg.sender][last[msg.sender]];\n      } else {\n        holds = holdings[msg.sender][i];\n      }\n      if (holds \u003e 0 \u0026\u0026 !lockedAt(msg.sender, i)) {\n        uint256 multiplier = dividends[i].mul(holds);\n        uint256 owed = multiplier.div(totalAt[i]);\n        total += owed;\n      }      \n    }\n    return total;\n  }\n  \n  function buyBack() public onlyAdmin onlyLive canBuyBack payable returns (bool) {\n    buyBackTotal = msg.value;\n    period += 1;\n    emit Paid(msg.sender, period - 1, msg.value);\n    ended = true;\n  }\n\n  function claimBuyBack() public returns (bool) {\n    require(ended);\n    require(!boughtBack[msg.sender]);\n    if (last[msg.sender] \u003c period) {\n      updateHoldings(msg.sender);\n    }\n    uint256 multiplier = buyBackTotal.mul(holdings[msg.sender][period]);    \n    uint256 owed = multiplier.div(totalAt[period.sub(1)]);\n    boughtBack[msg.sender] = true;\n    msg.sender.transfer(owed);\n  }\n\n  function claimBuyBackFor(address _address) onlyAdmin public returns (bool) {\n    require(ended);\n    require(!boughtBack[_address]);\n    if (last[_address] \u003c period) {\n      updateHoldings(_address);\n    }\n    uint256 multiplier = buyBackTotal.mul(holdings[_address][period]);    \n    uint256 owed = multiplier.div(totalAt[period.sub(1)]);\n    boughtBack[_address] = true;\n    _address.transfer(owed);\n  }\n\n  function dividendDateHistory() public view returns (uint256[]) {\n    uint256[] memory dates = new uint[](period);\n    for(uint i = 0; i \u003c period; i++) {\n      dates[i] = dividendDates[i];\n    }\n    return dates;\n  }\n\n  function dividendHistory() public view returns (uint256[]) {\n    uint256[] memory divs = new uint[](period);\n    for(uint i = 0; i \u003c period; i++) {\n      divs[i] = dividends[i];\n    }\n    return divs;\n  }\n\n  function dividendHistoryFor(address _address) public view returns (uint256[]) {\n    uint256[] memory divs = new uint[](period);\n    for(uint i = 0; i \u003c period; i++) {\n      uint256 multiplier;\n      if(last[_address] \u003c i) {\n        multiplier = dividends[i].mul(holdings[_address][i]);\n      } else {\n        multiplier = dividends[i].mul(holdings[_address][last[_address]]);\n      }\n      if(lockedAt(_address, i)) {\n        divs[i] = 0;\n      } else {\n        divs[i] = multiplier.div(totalAt[i]);\n      }\n    }\n    return divs;\n  }\n\n  event Paid(address indexed _sender, uint256 indexed _period, uint256 amount);\n\n  event Claimed(address indexed _recipient, uint256 indexed _period, uint256 _amount);\n\n  event Locked(address indexed _locked, uint256 indexed _at);\n\n  event Unlocked(address indexed _unlocked, uint256 indexed _at);\n}\n"},"DividendTokenStore.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \u0027./Pausable.sol\u0027;\n\ncontract DividendTokenStore is Pausable {\n\n  function totalSupply() public view returns (uint256);\n\n  function addLock(address _locked) public returns (bool);\n\n  function revokeLock(address _unlocked) public returns (bool);\n  \n  function balanceOf(address _owner) public view returns (uint256);\n\n  function transfer(address _from, address _to, uint256 _value) public returns (bool);\n  \n  function () public payable {\n    payIn();\n  }\n\n  function payIn() public payable returns (bool);\n  \n  function claimDividends() public returns (uint256);\n  \n  function claimDividendsFor(address _address) public returns (uint256);\n    \n  function buyBack() public payable returns (bool);\n\n  function claimBuyBack() public returns (bool);\n\n  function claimBuyBackFor(address _address) public returns (bool);\n\n  function mint(address _to, uint256 _amount) public returns (bool);\n  \n  event Paid(address indexed _sender, uint256 indexed _period, uint256 amount);\n\n  event Claimed(address indexed _recipient, uint256 indexed _period, uint256 _amount);\n\n  event Locked(address indexed _locked, uint256 indexed _at);\n\n  event Unlocked(address indexed _unlocked, uint256 indexed _at);\n}\n"},"ERC20.sol":{"content":"pragma solidity ^0.4.23;\n\nimport \"./ERC20Basic.sol\";\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n"},"ERC20Basic.sol":{"content":"pragma solidity ^0.4.23;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n"},"MoriaToken.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \u0027./DividendTokenStore.sol\u0027;\nimport \u0027./Administratable.sol\u0027;\nimport \u0027./StandardToken.sol\u0027;\n\ncontract MoriaToken is StandardToken, Administratable {\n  \n  string public constant name = \"MoriaToken\";\n  string public constant symbol = \"MOR\";\n  uint8 public constant decimals = 18;\n\n  DividendTokenStore public store;\n  bool public canDestroy = true;\n  bool public minting = true;\n\n  modifier isDestroyable() {\n    require(canDestroy);\n    _;\n  }\n\n  modifier canMint() {\n    require(minting);\n    _;\n  }\n\n  constructor() public {\n  }\n\n  function () public payable {\n    require(store.payIn.value(msg.value)());\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return store.totalSupply();\n  }\n\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return store.balanceOf(_owner);\n  }\n\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    store.transfer(msg.sender, _to, _value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_value \u003c= allowed[_from][msg.sender]);\n    store.transfer(_from, _to, _value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  function pause() public onlyOwner {\n    store.pause();\n  }\n\n  function unpause() public onlyOwner {\n    store.unpause();\n  }\n\n  function addLock(address _address) onlyAdmin public returns (bool) {\n    return store.addLock(_address);\n  }\n\n  function revokeLock(address _address) onlyAdmin public returns (bool) {\n    return store.revokeLock(_address);\n  }\n\n  function claimDividends() public returns (uint256 amount) {\n    return store.claimDividendsFor(msg.sender);\n  }\n\n  function claimDividendsFor(address _address) public onlyAdmin returns (uint256 amount) {\n    return store.claimDividendsFor(_address);\n  }\n\n  function buyBack() public onlyAdmin payable returns (bool) {\n    require(store.buyBack.value(msg.value)());\n    return true;\n  }\n\n  function claimBuyBack() public returns (bool) {\n    return claimBuyBackFor(msg.sender);\n  }\n\n  function claimBuyBackFor(address _address) public onlyAdmin returns (bool) {\n    return claimBuyBackFor(_address);\n  }\n \n  // admin\n\n  function mint(address _from, address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\n    store.mint(_to, _amount);\n    emit Transfer(_from, _to, _amount);\n  }\n\n  function endMinting() public onlyOwner canMint returns (bool) {\n    minting = false;\n  }\n\n  function upgradeEvent(address _from, address _to) public onlyAdmin {\n    emit Transfer(_from, _to,  store.balanceOf(_to));\n  }\n\n  function changeStore(DividendTokenStore _store) public onlyOwner returns (bool) {\n    store = _store;\n    emit StoreChanged(address(store));\n    return true;\n  }\n\n  function transferStoreOwnership() public onlyOwner {\n    store.transferOwnership(owner);\n  }\n\n  function destroyToken() public onlyOwner isDestroyable {\n    transferStoreOwnership();\n    selfdestruct(owner);\n  }\n\n  function disableSelfDestruct() public onlyOwner isDestroyable {\n    canDestroy = false;\n  } \n\n  event StoreChanged(address indexed _newStore);\n  \n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.4.23;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n"},"Pausable.sol":{"content":"pragma solidity ^0.4.23;\n\n\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.4.23;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting \u0027a\u0027 not being zero, but the\n    // benefit is lost if \u0027b\u0027 is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b \u003c= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c \u003e= a);\n    return c;\n  }\n}\n"},"StandardDividendTokenStore.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \u0027./DividendTokenStore.sol\u0027;\nimport \u0027./SafeMath.sol\u0027;\n\ncontract StandardDividendTokenStore is DividendTokenStore {\n  using SafeMath for uint256;\n\n  uint256 public period = 0;\n  uint256 public buyBackTime;\n  bool public ended = false;\n  \n  mapping (uint256 =\u003e uint256) public dividends;\n  mapping (uint256 =\u003e uint256) public dividendDates;\n  uint256 public buyBackTotal;\n  mapping (address =\u003e bool) public boughtBack;\n  \n  mapping (address =\u003e mapping (uint256 =\u003e uint256)) public holdings;\n  mapping (address =\u003e uint256) public last;\n  mapping (address =\u003e uint256) public claimedTo;\n  mapping (address =\u003e bool) beenDivLocked;\n  mapping (address =\u003e uint256[]) divLocks;\n\n  mapping(uint256 =\u003e uint256) totalAt;\n  uint256 public totalSupply_ = 0;\n\n  modifier canBuyBack() {\n    require(now \u003e buyBackTime);\n    _;\n  }\n\n  modifier onlyLive() {\n    require(!ended);\n    _;\n  }\n\n  constructor(uint256 _buyBackTime) public {\n    buyBackTime = _buyBackTime;\n  }\n\n  function mint(address _to, uint256 _amount) public onlyOwner returns (bool) {\n    require(period == 0);\n    holdings[_to][0] = holdings[_to][0].add(_amount);\n    totalAt[0] = totalAt[0].add(_amount);\n    totalSupply_ = totalAt[0];\n    return true;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  function updateHoldings(address _holder) internal returns (bool success) {\n    uint256 lastPeriod = last[_holder];\n    uint256 lastAmount = holdings[_holder][lastPeriod];\n    if(lastAmount != 0) {\n      for (uint i = lastPeriod + 1; i \u003c= period; i++) {\n        holdings[_holder][i] = lastAmount;\n      }\n    }\n    last[_holder] = period;\n    return true;\n  }\n\n  function updateHoldingsTo(address _holder, uint256 _to) public whenNotPaused returns (bool success){\n    require(_to \u003e last[_holder]);\n    require(_to \u003c= period);\n    uint256 lastPeriod = last[_holder];\n    uint256 lastAmount = holdings[_holder][lastPeriod];\n    if(lastAmount != 0) {\n      for (uint i = lastPeriod + 1; i \u003c= _to; i++) {\n        holdings[_holder][i] = lastAmount;\n      }\n    }\n    last[_holder] = _to;\n    return true;\n  }\n  \n  function lockedAt(address _address, uint256 _period) public view returns (bool) {\n    if(!beenDivLocked[_address]) {\n      return false;\n    }\n    bool locked = false;\n    for(uint i = 0; i \u003c divLocks[_address].length; i++) {\n      if(divLocks[_address][i] \u003e _period) {\n        break;\n      } \n      locked = !locked;\n    }\n    return locked;\n  }\n\n  function addLock(address _locked) onlyOwner public returns (bool success) {\n    require(!lockedAt(_locked, period));\n    if (last[_locked] \u003c period) {\n      updateHoldings(_locked);\n    }\n    totalAt[period] = totalAt[period].sub(balanceOf(_locked));\n    beenDivLocked[_locked] = true;\n    divLocks[_locked].push(period);\n    emit Locked(_locked, period);\n    return true;\n  }\n\n  function revokeLock(address _unlocked) onlyOwner public returns (bool success) {\n    require(lockedAt(_unlocked, period));\n    if (last[_unlocked] \u003c period) {\n      updateHoldings(_unlocked);\n    }\n    totalAt[period] = totalAt[period].add(balanceOf(_unlocked));\n    divLocks[_unlocked].push(period);\n    emit Unlocked(_unlocked, period);\n    return true;\n  }\n\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    if(ended) {\n      return 0;\n    }\n    return holdings[_owner][last[_owner]];\n  }\n\n  function transfer(address _from, address _to, uint256 _value) onlyLive onlyOwner whenNotPaused public returns (bool) {\n    require(_to != address(0));\n    uint256 senderLastPeriod = last[_from];\n    require(_value \u003c= holdings[_from][senderLastPeriod]);\n\n    if (senderLastPeriod \u003c period) {\n      updateHoldings(_from);\n    }\n\n    if (last[_to] \u003c period) {\n      updateHoldings(_to);\n    }\n\n    holdings[_from][period] = holdings[_from][period].sub(_value);\n    holdings[_to][period] = holdings[_to][period].add(_value);\n    bool fromLocked = lockedAt(_from, period);\n    bool toLocked = lockedAt(_to, period);\n    if(fromLocked \u0026\u0026 !toLocked) {\n      totalAt[period] = totalAt[period].add(_value);\n    } else if(!fromLocked \u0026\u0026 toLocked) {\n      totalAt[period] = totalAt[period].sub(_value);\n    }\n\n    return true;\n  }\n\n  function () public payable {\n    payIn();\n  }\n\n  function payIn() public payable onlyLive onlyOwner whenNotPaused returns (bool) {\n    dividends[period] = msg.value;\n    dividendDates[period] = now;\n    period = period.add(1);\n    totalAt[period] = totalAt[period.sub(1)];\n    emit Paid(msg.sender, period.sub(1), msg.value);\n    return true;\n  }\n  \n  function claimDividends() whenNotPaused public returns (uint256 amount) {\n    require(claimedTo[msg.sender] \u003c period);\n    uint256 total = 0;\n    if (last[msg.sender] \u003c period) {\n      updateHoldings(msg.sender);\n    }\n    for (uint i = claimedTo[msg.sender]; i \u003c period; i++) {\n      if (holdings[msg.sender][i] \u003e 0 \u0026\u0026 !lockedAt(msg.sender, i)) {\n        uint256 multiplier = dividends[i].mul(holdings[msg.sender][i]);\n        total += multiplier.div(totalAt[i]);\n      }\n    }\n    claimedTo[msg.sender] = period;\n    if(total \u003e 0) {\n      msg.sender.transfer(total);\n      emit Claimed(msg.sender, i, total);\n    }\n    return total;\n  }\n\n  function claimDividendsFor(address _address) onlyOwner public returns (uint256 amount) {\n    require(claimedTo[_address] \u003c period);\n    uint256 total = 0;\n    if (last[_address] \u003c period) {\n      updateHoldings(_address);\n    }\n    for (uint i = claimedTo[_address]; i \u003c period; i++) {\n      if (holdings[_address][i] \u003e 0 \u0026\u0026 !lockedAt(_address, i)) {\n        uint256 multiplier = dividends[i].mul(holdings[_address][i]);\n        total += multiplier.div(totalAt[i]);\n      }\n    }\n    claimedTo[_address] = period;\n    if(total \u003e 0) {\n      _address.transfer(total);\n      emit Claimed(_address, i, total);\n    }\n    return total;\n  }\n  \n  function outstandingFor(address _address) public view returns (uint256 amount) {\n    uint256 total = 0;\n    uint256 holds = 0;\n    for (uint i = claimedTo[_address]; i \u003c period; i++) {\n      if(last[_address] \u003c i) {\n        holds = holdings[_address][last[_address]];\n      } else {\n        holds = holdings[_address][i];\n      }\n      if (holds \u003e 0 \u0026\u0026 !lockedAt(_address, i)) {\n        uint256 multiplier = dividends[i].mul(holds);\n        uint256 owed = multiplier.div(totalAt[i]);\n        total += owed;\n      }\n    }\n    return total;\n  }\n\n  function outstanding() public view returns (uint256 amount) {\n    uint256 total = 0;\n    uint256 holds = 0;\n    for (uint i = claimedTo[msg.sender]; i \u003c period; i++) {\n       if(last[msg.sender] \u003c i) {\n        holds = holdings[msg.sender][last[msg.sender]];\n      } else {\n        holds = holdings[msg.sender][i];\n      }\n      if (holds \u003e 0 \u0026\u0026 !lockedAt(msg.sender, i)) {\n        uint256 multiplier = dividends[i].mul(holds);\n        uint256 owed = multiplier.div(totalAt[i]);\n        total += owed;\n      }      \n    }\n    return total;\n  }\n  \n  function buyBack() public onlyOwner onlyLive canBuyBack payable returns (bool) {\n    buyBackTotal = msg.value;\n    period += 1;\n    emit Paid(msg.sender, period - 1, msg.value);\n    ended = true;\n  }\n\n  function claimBuyBack() public returns (bool) {\n    require(ended);\n    require(!boughtBack[msg.sender]);\n    if (last[msg.sender] \u003c period) {\n      updateHoldings(msg.sender);\n    }\n    uint256 multiplier = buyBackTotal.mul(holdings[msg.sender][period]);    \n    uint256 owed = multiplier.div(totalAt[period.sub(1)]);\n    boughtBack[msg.sender] = true;\n    msg.sender.transfer(owed);\n  }\n\n  function claimBuyBackFor(address _address) onlyOwner public returns (bool) {\n    require(ended);\n    require(!boughtBack[_address]);\n    if (last[_address] \u003c period) {\n      updateHoldings(_address);\n    }\n    uint256 multiplier = buyBackTotal.mul(holdings[_address][period]);    \n    uint256 owed = multiplier.div(totalAt[period.sub(1)]);\n    boughtBack[_address] = true;\n    _address.transfer(owed);\n  }\n\n  function dividendDateHistory() public view returns (uint256[]) {\n    uint256[] memory dates = new uint[](period);\n    for(uint i = 0; i \u003c period; i++) {\n      dates[i] = dividendDates[i];\n    }\n    return dates;\n  }\n\n  function dividendHistory() public view returns (uint256[]) {\n    uint256[] memory divs = new uint[](period);\n    for(uint i = 0; i \u003c period; i++) {\n      divs[i] = dividends[i];\n    }\n    return divs;\n  }\n\n  function dividendHistoryFor(address _address) public view returns (uint256[]) {\n    uint256[] memory divs = new uint[](period);\n    for(uint i = 0; i \u003c period; i++) {\n      uint256 multiplier;\n      if(last[_address] \u003c i) {\n        multiplier = dividends[i].mul(holdings[_address][i]);\n      } else {\n        multiplier = dividends[i].mul(holdings[_address][last[_address]]);\n      }\n      if(lockedAt(_address, i)) {\n        divs[i] = 0;\n      } else {\n        divs[i] = multiplier.div(totalAt[i]);\n      }\n    }\n    return divs;\n  }\n\n  event Paid(address indexed _sender, uint256 indexed _period, uint256 amount);\n\n  event Claimed(address indexed _recipient, uint256 indexed _period, uint256 _amount);\n\n  event Locked(address indexed _locked, uint256 indexed _at);\n\n  event Unlocked(address indexed _unlocked, uint256 indexed _at);\n}\n"},"StandardToken.sol":{"content":"pragma solidity ^0.4.23;\n\nimport \"./BasicToken.sol\";\nimport \"./ERC20.sol\";\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address =\u003e mapping (address =\u003e uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    require(_value \u003c= balances[_from]);\n    require(_value \u003c= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender\u0027s allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue \u003e oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n"}}